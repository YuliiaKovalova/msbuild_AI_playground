{
  "number": 6974,
  "title": "Optimized immutable files up to date checks",
  "body": "Fixes #6761 \r\n\r\n### Context\r\nFiles from 'program files' and NuGet caches as considered immutable so we can optimize their up to date checks\r\nby caching their last known timestamp.\r\n\r\n### Changes Made\r\nChanges made in `NativeMethodShare.LastWriteFileUtcTime`. Caching Last Write File Times into static cache without eviction. By our test on `Orchard Core` there were only about 400 files in that cache - in the end.\r\n\r\n### Testing\r\nDebugging, unit tests, compile Orchard Core m:1 and m:8\r\n\r\n### Notes\r\nResults into 10x faster cumulative time of  `NativeMethodShare.LastWriteFileUtcTime` during Orchard Core incremental build.\r\n![image](https://user-images.githubusercontent.com/25249058/138052217-28efeb0f-ef07-4811-97bf-c109c525dca9.png)\r\n\r\nThere are two main most perf demanding use cases:\r\n\r\na) TargetUpToDateChecker\r\n![image](https://user-images.githubusercontent.com/25249058/138150020-fbf34292-2feb-44c7-8f4f-9ca43c7405af.png)\r\n![image](https://user-images.githubusercontent.com/25249058/138150067-fe1c63b2-698f-49e7-82b5-831aec1b8e1c.png)\r\n\r\nb) Check validity of the RAR cache\r\n![image](https://user-images.githubusercontent.com/25249058/138153686-d0cad9d2-cfc4-4b99-bb8f-943f0f3060b7.png)\r\n![image](https://user-images.githubusercontent.com/25249058/138153729-e3f9d269-1026-4897-acda-165b392451bc.png)\r\n\r\nHowever, when I  measured wall clock time of build, the actual savings was small. ~2% of overall build time in incremental build and ~1% in rebuild.",
  "state": "MERGED",
  "createdAt": "2021-10-20T07:59:16Z",
  "updatedAt": "2021-11-25T13:25:03Z",
  "closedAt": "2021-11-25T13:25:03Z",
  "mergedAt": "2021-11-25T13:25:03Z",
  "additions": 423,
  "deletions": 19,
  "changedFiles": 7,
  "headRefName": "rokonec/6761-immutable-files-up-to-date",
  "isDraft": false,
  "author": {
    "login": "rokonec"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "0f3b0d0001a7599e601ee74f1db4e3c2913ff552",
          "message": "MK1: events introduced",
          "committedDate": "2021-10-15T14:48:29Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "220e62165f939aefa0732543ccc82113e7478cda",
          "message": "Still under development",
          "committedDate": "2021-10-18T14:37:03Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "33641f0ce29cb03934837c71dd9721bec596dd26",
          "message": "Move cache from Shared to Framework",
          "committedDate": "2021-10-18T15:34:24Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "218db448843e59f4e934f7b0b34c3379a2442189",
          "message": "Cleaning and refactoring",
          "committedDate": "2021-10-19T09:33:45Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2d85bd9ab8d952c56db8ea7926e637f9f1783ef9",
          "message": "Added tests for FileClassifier (#4)",
          "committedDate": "2021-10-19T12:37:19Z",
          "author": {
            "name": "MichalPavlik",
            "email": "michalpavlik@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b19b5c59a0b5e9f404af3a8022554d7ce2c0f942",
          "message": "Remove sealed",
          "committedDate": "2021-10-19T14:07:45Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "34c746ef1809e5c0d944ffb66ec528981146e605",
          "message": "Change singleton to Lazy",
          "committedDate": "2021-10-19T14:53:55Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8dcd598f0bceab7bb3cf896f214b7e2ac49e0f7c",
          "message": "Remove temp ETWs",
          "committedDate": "2021-10-19T14:57:16Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "251e0710a758d88db5fda07bf7ff6673320e8988",
          "message": "Outadted comments",
          "committedDate": "2021-10-20T07:52:50Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cf3929ed9b365db8ddae577076eb2ff4b215a779",
          "message": "Fix linux unit tests",
          "committedDate": "2021-10-20T11:07:13Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "209df6972bcf86695e99d1fb5e5669894aad1cf2",
          "message": "Clean leftovers",
          "committedDate": "2021-10-20T12:01:17Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7b0489198aeb043ae1023e286730aec7614e41bf",
          "message": "Review comments of Rainer #1",
          "committedDate": "2021-10-20T22:04:50Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "98e6689ae08ddb1982f31b2b9d4626f600c37106",
          "message": "Review comment #2",
          "committedDate": "2021-10-21T19:45:39Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "517a3a19a85988570aa04521a0c7f08fbb74d0b4",
          "message": "Minor refactoring and add under ChangeWave",
          "committedDate": "2021-10-21T20:59:30Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ae56eb35d78b4325d35c8ed61dc6301c930df5f6",
          "message": "Change immutable folders list",
          "committedDate": "2021-11-01T15:49:11Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "63a93623b178d43693018cd1838d6d0b874ed16f",
          "message": "Moving MSBuildFrameworkToolsPaths registration into ToolsetReader.\nTypo fix.",
          "committedDate": "2021-11-03T20:44:29Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "20798be25c6ff2deb76efb991f447533796c7583",
          "message": "Do not register dotnet root in Classifier constructor, but relay on registration by property 'NetCoreRoot'",
          "committedDate": "2021-11-03T22:37:38Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a7fd9ab53c92b6b534578287b263788520ce09de",
          "message": "Register VS root also when msbuild called from CLI.",
          "committedDate": "2021-11-03T22:38:27Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b65b835401a237edc7f81cc03b5c497ee608b31d",
          "message": "Adding volatile to _knownImmutableDirectoriesSnapshot\n\nconcern is the ARM memory model",
          "committedDate": "2021-11-08T00:15:39Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "67d96888a3721aaef2e540ae0778267de1dbc759",
          "message": "Fix eng grammar FileClassifier.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-11-08T00:16:10Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "86bf313187310c02d6ffde55796297abc492d5c0",
          "message": "English grammar",
          "committedDate": "2021-11-11T10:17:52Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e6ce75aea2c90ef7f84f1bfec153b10a6a8df3d0",
          "message": "Remove nuget caches from immutable directories list.",
          "committedDate": "2021-11-11T10:53:40Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4dde5355a021094f2b86cdaff8a3c215375bf0da",
          "message": "Merge remote-tracking branch 'upstream/main' into rokonec/6761-immutable-files-up-to-date\n\nConflicts:\n\tsrc/Shared/NativeMethodsShared.cs",
          "committedDate": "2021-11-23T22:34:49Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Just curious do we know whether time stamp checks can themselves be parallelized? It would depend on how the file system works, but if a node needs to check 50 time stamps at one point, would it be any faster to kick off a Task for each?",
        "createdAt": "2021-10-21T05:28:14Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "@Forgind \r\n> I know we talked about the (presumably lesser) perf wins on non-Windows; maybe ifdef out the Windows-specific paths and such?\r\n\r\nI honestly believe it is good as is. Added ifdefs would have negligible effect on perf and would. IMHO, harm readability of the code.\r\nThe main perf gains, which are skipping up-to-date checks from SDK is handled by SDK resolver and will work in all environments.\r\n",
        "createdAt": "2021-11-11T18:25:56Z",
        "author": {
          "login": "rokonec"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Why `TryGetValue`/`TryAdd` instead of `GetOrAdd`?",
              "createdAt": "2021-10-20T15:01:42Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec?.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath) => _knownImmutableDirectory.Any(folder => filePath.StartsWith(folder.Key, PathComparison));\n+    }\n+\n+    /// <summary>\n+    ///     Caching 'Last Write File Utc' times for Immutable files <see cref=\"FileClassifier\" />.\n+    ///     <remarks>\n+    ///         Cache is add only. It does not updates already existing cached items.\n+    ///     </remarks>\n+    /// </summary>\n+    internal class ImmutableFilesTimestampCache\n+    {\n+        private readonly ConcurrentDictionary<string, DateTime> _cache = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Shared singleton instance\n+        /// </summary>\n+        public static ImmutableFilesTimestampCache Shared { get; } = new();\n+\n+        /// <summary>\n+        ///     Try get 'Last Write File Utc' time of particular file.\n+        /// </summary>\n+        /// <returns><see langword=\"true\" /> if record exists</returns>\n+        public bool TryGetValue(string fullPath, out DateTime lastModified) => _cache.TryGetValue(fullPath, out lastModified);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I though about it. But I have considered immutable folders as folders into which (or any of its subdirs) files could be later added. So I do not cache its existence. The internal value factory returns `DateTime.MinValue` when file does not exists, so I am forced to split value factory and insertion as I basically need `GetOrMaybeAdd`\r\n",
              "createdAt": "2021-10-20T21:28:23Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec?.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath) => _knownImmutableDirectory.Any(folder => filePath.StartsWith(folder.Key, PathComparison));\n+    }\n+\n+    /// <summary>\n+    ///     Caching 'Last Write File Utc' times for Immutable files <see cref=\"FileClassifier\" />.\n+    ///     <remarks>\n+    ///         Cache is add only. It does not updates already existing cached items.\n+    ///     </remarks>\n+    /// </summary>\n+    internal class ImmutableFilesTimestampCache\n+    {\n+        private readonly ConcurrentDictionary<string, DateTime> _cache = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Shared singleton instance\n+        /// </summary>\n+        public static ImmutableFilesTimestampCache Shared { get; } = new();\n+\n+        /// <summary>\n+        ///     Try get 'Last Write File Utc' time of particular file.\n+        /// </summary>\n+        /// <returns><see langword=\"true\" /> if record exists</returns>\n+        public bool TryGetValue(string fullPath, out DateTime lastModified) => _cache.TryGetValue(fullPath, out lastModified);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I'd pull this into its own file",
              "createdAt": "2021-10-20T15:02:31Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec?.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath) => _knownImmutableDirectory.Any(folder => filePath.StartsWith(folder.Key, PathComparison));\n+    }\n+\n+    /// <summary>\n+    ///     Caching 'Last Write File Utc' times for Immutable files <see cref=\"FileClassifier\" />.\n+    ///     <remarks>\n+    ///         Cache is add only. It does not updates already existing cached items.\n+    ///     </remarks>\n+    /// </summary>\n+    internal class ImmutableFilesTimestampCache",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Done",
              "createdAt": "2021-10-20T21:35:32Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec?.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath) => _knownImmutableDirectory.Any(folder => filePath.StartsWith(folder.Key, PathComparison));\n+    }\n+\n+    /// <summary>\n+    ///     Caching 'Last Write File Utc' times for Immutable files <see cref=\"FileClassifier\" />.\n+    ///     <remarks>\n+    ///         Cache is add only. It does not updates already existing cached items.\n+    ///     </remarks>\n+    /// </summary>\n+    internal class ImmutableFilesTimestampCache",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: new file, can it be `#nullable enable`?",
              "createdAt": "2021-10-20T15:02:51Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Also copyright headers please",
              "createdAt": "2021-10-20T15:03:09Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We have this in `FileUtilities`",
              "createdAt": "2021-10-20T15:07:33Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "`FileUtilities` is in Shared and I did not want to link that shared file and all its dependencies into `Framework` assembly.\r\nShall I put TODO there to reuse `FileUtilities` once they make it into `Framework`?",
              "createdAt": "2021-10-20T21:43:35Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "nit: You can use `Path.EndsInDirectorySeparator` now that we reference Microsoft.IO.Redist.",
              "createdAt": "2021-10-21T12:02:08Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I will keep as it is. It shall soon be reusing FileUtilities.EnsureTrailingSlash",
              "createdAt": "2021-10-22T10:04:13Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Note that the version in FileUtilities is subtly different: if fileSpec.Length == 0, this will return fileSpec, whereas that would return Path.DirectorySeparatorChar.",
              "createdAt": "2021-11-05T21:47:23Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            RegisterImmutableDirectory(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory);\r\n```\r\n\r\nshould get you this automagically.",
              "createdAt": "2021-10-20T15:53:27Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "`BuildEnvironmentHelper` is in Shared and I did not want to link that shared file and all its dependencies into Framework assembly.\r\nShall I put TODO there to reuse `BuildEnvironmentHelper` once they make it into Framework?",
              "createdAt": "2021-10-20T21:46:58Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Can you do this only on windows/full framework and also add a case for .net core?",
              "createdAt": "2021-10-21T15:46:41Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Currently linux vs windows is handled by 'null' check. If particular property or env var does not make sense on linux it is currently null and skipped. Some properties like for example `FrameworkPathOverride` are null on linux while others like for example `NetCoreRoot` have correct values in both OS.\r\nPlease let me know, given the latest changes I made, how exactly shall I interpret your request:\r\n> Can you do this only on windows/full framework and also add a case for .net core?",
              "createdAt": "2021-11-01T16:39:43Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Also a changewave",
              "createdAt": "2021-10-20T15:54:55Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -1052,37 +1053,67 @@ internal static MemoryStatus GetMemoryStatus()\n         /// </remarks>\n         internal static DateTime GetLastWriteFileUtcTime(string fullPath)\n         {\n-            DateTime fileModifiedTime = DateTime.MinValue;\n+#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+            if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "17.0 it is",
              "createdAt": "2021-10-21T15:22:27Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -1052,37 +1053,67 @@ internal static MemoryStatus GetMemoryStatus()\n         /// </remarks>\n         internal static DateTime GetLastWriteFileUtcTime(string fullPath)\n         {\n-            DateTime fileModifiedTime = DateTime.MinValue;\n+#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+            if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Check `NativeMethodsShared.OSUsesCaseSensitivePaths` and possibly use a case-sensitive comparer here.",
              "createdAt": "2021-10-20T16:18:24Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "RuntimeInformation.IsOSPlatform(OSPlatform.Linux) instead until NativeMethodsShared makes it into Framework.",
              "createdAt": "2021-10-21T15:26:29Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What are the threading guarantees of `ConcurrentDictionary`'s enumeration/Any? Is this safe to do while modifying?",
              "createdAt": "2021-10-20T16:20:46Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec?.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath) => _knownImmutableDirectory.Any(folder => filePath.StartsWith(folder.Key, PathComparison));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes, it is. See: https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentdictionary-2.getenumerator?view=netframework-4.7.2#remarks",
              "createdAt": "2021-10-20T21:50:26Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec?.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath) => _knownImmutableDirectory.Any(folder => filePath.StartsWith(folder.Key, PathComparison));",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "It allocates an array on enumeration, as it has to make a copy of the buckets. This might prove heavy, but would need to be tested for performance.",
              "createdAt": "2021-10-21T04:43:52Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec?.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath) => _knownImmutableDirectory.Any(folder => filePath.StartsWith(folder.Key, PathComparison));",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "This will also allocate a closure object to capture the `filePath` variable.\r\n\r\nIf you can use `System.Collections.Immutable` consider using `ImmutableArray<string>` or `ImmutableHashSet<string>`, potentially with the `ImmutableInterlocked` operations.",
              "createdAt": "2021-10-21T06:45:05Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec?.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath) => _knownImmutableDirectory.Any(folder => filePath.StartsWith(folder.Key, PathComparison));",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "Good point. I had reworked it into copy-on-write List which is enumerated without any allocation.",
              "createdAt": "2021-10-21T20:41:56Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string GetVSInstallationDirectory()\n+            {\n+                string dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string DevEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(DevEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - DevEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string directory)\n+        {\n+            if (!string.IsNullOrEmpty(directory))\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+                _knownImmutableDirectory.TryAdd(d, d);\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec?.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath) => _knownImmutableDirectory.Any(folder => filePath.StartsWith(folder.Key, PathComparison));",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd love to shorten this name. `MSBUILDDONOTCACHEMODIFICATIONTIME`?",
              "createdAt": "2021-10-20T16:24:59Z",
              "path": "src/Shared/Traits.cs",
              "diffHunk": "@@ -145,6 +145,11 @@ internal class EscapeHatches\n         /// </summary>\n         public readonly bool AlwaysEvaluateDangerousGlobs = Environment.GetEnvironmentVariable(\"MSBuildAlwaysEvaluateDangerousGlobs\") == \"1\";\n \n+        /// <summary>\n+        /// Disables skipping full up to date check for immutable files. See FileClassifier class.\n+        /// </summary>\n+        public readonly bool AlwaysDoImmutableFilesUpToDateCheck = Environment.GetEnvironmentVariable(\"MSBuildAlwaysDoImmutableFilesUpToDateCheck\") == \"1\";",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Done. I kept the name of variable as is to be aligned with its comment.  ",
              "createdAt": "2021-10-20T21:52:44Z",
              "path": "src/Shared/Traits.cs",
              "diffHunk": "@@ -145,6 +145,11 @@ internal class EscapeHatches\n         /// </summary>\n         public readonly bool AlwaysEvaluateDangerousGlobs = Environment.GetEnvironmentVariable(\"MSBuildAlwaysEvaluateDangerousGlobs\") == \"1\";\n \n+        /// <summary>\n+        /// Disables skipping full up to date check for immutable files. See FileClassifier class.\n+        /// </summary>\n+        public readonly bool AlwaysDoImmutableFilesUpToDateCheck = Environment.GetEnvironmentVariable(\"MSBuildAlwaysDoImmutableFilesUpToDateCheck\") == \"1\";",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is read in a \"typical\" build from program files that _isn't_ in the VS directory? One thing I'm worried about here is people doing something like \"make install\" that puts junk in Program Files and then consumes it.",
              "createdAt": "2021-10-20T16:27:13Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "In my testing it was the .NET SDK. Files in these directories were accessed in one typical build:\r\n\r\nC:\\Program Files\\dotnet\\packs\\Microsoft.NETCore.App.Ref\\5.0.0\\ref\\net5.0\r\nC:\\Program Files\\dotnet\\sdk\\6.0.100-rc.2.21478.25\\Sdks\\Microsoft.NET.Sdk\\analyzers\\build\\config\r\nC:\\Program Files\\dotnet\\packs\\Microsoft.AspNetCore.App.Ref\\5.0.0\\ref\\net5.0",
              "createdAt": "2021-10-21T11:57:24Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Ah, I think we should explicitly add the properties for those directories like we do with NuGet.",
              "createdAt": "2021-10-21T15:04:46Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Looked for a good property for this with @rokonec and we couldn't find one.",
              "createdAt": "2021-10-21T15:42:50Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I have indetified these properties:\r\n```C#\r\n//example: C:\\Users\\USER_NAME\\.nuget\\;C:\\Program Files\\dotnet\\sdk\\NuGetFallbackFolder\r\nFileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"NuGetPackageFolders\")?.Trim());\r\n// example: C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\\r\nFileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"MSBuildFrameworkToolsPath32\")?.Trim());\r\n// example:  C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\\r\nFileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"MSBuildFrameworkToolsPath64\")?.Trim());\r\n// example: C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7.2\r\nFileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"FrameworkPathOverride\")?.Trim());\r\n// example: C:\\Program Files\\dotnet\\\r\nFileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"NetCoreRoot\")?.Trim());\r\n```",
              "createdAt": "2021-11-01T15:52:44Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,172 @@\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This should probably be `Path.PathSeparator`, Unix platforms use `:`.",
              "createdAt": "2021-10-21T04:42:54Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(devEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "That value is taken from MSBuild property `NugetPackageFolders` which uses `;` as separator even on linux OS. ",
              "createdAt": "2021-10-21T20:37:21Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(devEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If this is called a second time, the values from the first invocation will still be in memory. Is that ok?",
              "createdAt": "2021-10-21T06:45:32Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(devEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "Because it will be called on 'singleton' instance and it is backed up by ConcutrentDictionary as a cheap implementation of ConcurrentSet it will **ADD** all nuget folders into set of known folders.",
              "createdAt": "2021-10-21T11:31:27Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(devEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I wasn't very clear. Imagine this is called with `A;B;C`, then later called with `C;D;E`, the final state will be `A;B;C;D;E`. Is that intended?",
              "createdAt": "2021-10-22T02:57:06Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(devEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "Yes. That is intended. If one project deem particular folder as nuget cache, I believe there is no harm if another project consider files in such folder as immutable as well because they are.\r\nI expect that in vast majority of use cases it will be just 2 same folders used by every project.",
              "createdAt": "2021-10-22T09:43:46Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectory = new(StringComparer.OrdinalIgnoreCase);\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(devEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I haven't seen this form before. Isn't `<remarks>` usually a sibling of `<summary>` rather than a child?",
              "createdAt": "2021-10-21T08:14:36Z",
              "path": "src/Framework/ImmutableFilesTimestampCache.cs",
              "diffHunk": "@@ -0,0 +1,36 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Caching 'Last Write File Utc' times for Immutable files <see cref=\"FileClassifier\" />.\n+    ///     <remarks>\n+    ///         Cache is add only. It does not updates already existing cached items.\n+    ///     </remarks>",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "Intelisense offers it as a child, but you are right, it is mostly outside, if will fix it",
              "createdAt": "2021-10-21T11:32:13Z",
              "path": "src/Framework/ImmutableFilesTimestampCache.cs",
              "diffHunk": "@@ -0,0 +1,36 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Caching 'Last Write File Utc' times for Immutable files <see cref=\"FileClassifier\" />.\n+    ///     <remarks>\n+    ///         Cache is add only. It does not updates already existing cached items.\n+    ///     </remarks>",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "cc @samharwell who has an interest in documentation correctness. If IntelliSense is offering an invalid item, we may wish to track fixing it.",
              "createdAt": "2021-10-21T21:57:47Z",
              "path": "src/Framework/ImmutableFilesTimestampCache.cs",
              "diffHunk": "@@ -0,0 +1,36 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Caching 'Last Write File Utc' times for Immutable files <see cref=\"FileClassifier\" />.\n+    ///     <remarks>\n+    ///         Cache is add only. It does not updates already existing cached items.\n+    ///     </remarks>",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This looks redundant as `String.Split` also has an overload taking a single `char` for separator.\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.string.split?view=net-6.0#System_String_Split_System_Char_System_StringSplitOptions_",
              "createdAt": "2021-10-21T11:50:26Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Not until .NET Core, unfortunately: https://docs.microsoft.com/en-us/dotnet/api/system.string.split?view=netframework-4.7.2#System_String_Split_System_Char_System_StringSplitOptions",
              "createdAt": "2021-10-21T14:49:36Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "\ud83d\ude22 ",
              "createdAt": "2021-10-21T14:56:47Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "This is still redundant though because of Constants.SemicolonChar?",
              "createdAt": "2021-11-05T21:28:16Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        private const StringComparison PathComparison = StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is it safe to trim the prop value?",
              "createdAt": "2021-10-21T12:09:05Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -1355,6 +1358,16 @@ private void ConfigureWarningsAsErrorsAndMessages()\n             }\n         }\n \n+        private void ConfigureKnownNuGetFolders()\n+        {\n+            ProjectInstance project = _requestEntry?.RequestConfiguration?.Project;\n+            if (project != null)\n+            {\n+                string nuGetFolders = project.GetPropertyValue(\"NuGetPackageFolders\")?.Trim();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "It's a pretty common pattern to extend properties with something like\r\n\r\n```xml\r\n<PropertyGroup>\r\n  <PropertyThatWillBeExtended>\r\n    $(PropertyThatWillBeExtended);\r\n    NewThing;\r\n    AnotherNewThing\r\n  </PropertyThatWillBeExtended>\r\n</PropertyGroup>\r\n```\r\n\r\nMany semicolon-delimited properties actually split and then trim to allow for that.",
              "createdAt": "2021-10-21T15:06:46Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -1355,6 +1358,16 @@ private void ConfigureWarningsAsErrorsAndMessages()\n             }\n         }\n \n+        private void ConfigureKnownNuGetFolders()\n+        {\n+            ProjectInstance project = _requestEntry?.RequestConfiguration?.Project;\n+            if (project != null)\n+            {\n+                string nuGetFolders = project.GetPropertyValue(\"NuGetPackageFolders\")?.Trim();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This makes sense but then `Trim` should be applied to all paths *after* splitting, so in `RegisterNuGetPackageFolders`.",
              "createdAt": "2021-10-21T20:14:41Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -1355,6 +1358,16 @@ private void ConfigureWarningsAsErrorsAndMessages()\n             }\n         }\n \n+        private void ConfigureKnownNuGetFolders()\n+        {\n+            ProjectInstance project = _requestEntry?.RequestConfiguration?.Project;\n+            if (project != null)\n+            {\n+                string nuGetFolders = project.GetPropertyValue(\"NuGetPackageFolders\")?.Trim();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n            bool isNonModifiable = FileClassifier.Shared.IsNonModifiable(fullPath);\r\n```\r\nand remove the negation from the two uses below.",
              "createdAt": "2021-10-21T12:15:13Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -1052,37 +1053,67 @@ internal static MemoryStatus GetMemoryStatus()\n         /// </remarks>\n         internal static DateTime GetLastWriteFileUtcTime(string fullPath)\n         {\n-            DateTime fileModifiedTime = DateTime.MinValue;\n+#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+            if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+            {\n+                return LastWriteFileUtcTime(fullPath);\n+            }\n \n-            if (IsWindows)\n+            bool isModifiable = !FileClassifier.Shared.IsNonModifiable(fullPath);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Done",
              "createdAt": "2021-10-21T20:53:26Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -1052,37 +1053,67 @@ internal static MemoryStatus GetMemoryStatus()\n         /// </remarks>\n         internal static DateTime GetLastWriteFileUtcTime(string fullPath)\n         {\n-            DateTime fileModifiedTime = DateTime.MinValue;\n+#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS\n+            if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+            {\n+                return LastWriteFileUtcTime(fullPath);\n+            }\n \n-            if (IsWindows)\n+            bool isModifiable = !FileClassifier.Shared.IsNonModifiable(fullPath);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If you declare the local `immutableDirectories` as `List<string>` rather than the interface, you can have allocation-free enumeration, and access items without virtual method calls. ",
              "createdAt": "2021-10-22T03:00:36Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,186 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(devEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);\n+                }\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath)\n+        {\n+            // In order to have allocation-less iteration we can not use nor foreach neither linq.Any.\n+            // We shall copy reference of _knownImmutableDirectoriesSnapshot into local variable as otherwise\n+            // it could be changed during for loop enumeration by other thread.\n+            IReadOnlyList<string> immutableDirectories = _knownImmutableDirectoriesSnapshot;",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "I always wanted to know how those differs, so I have made, for curiosity sake, some benchmarking:\r\n|                    Method |    Toolchain |        Mean |     Error |  Gen 0 | Allocated |\r\n|-------------------------- |------------- |------------:|----------:|-------:|----------:|\r\n|      ConcurrentDictionary | netcoreapp50 |   469.57 ns |  1.568 ns | 0.0038 |      64 B |\r\n|          ImmutableHashSet | netcoreapp50 | 1,264.59 ns |  5.588 ns |      - |         - |\r\n| CopyOnWriteReadOnlySet | netcoreapp50 |   192.23 ns |  1.739 ns | 0.0024 |      40 B |\r\n|        CopyOnWriteList | netcoreapp50 |   128.26 ns |  1.934 ns |      - |         - |\r\n| CopyOnWriteReadOnlySetFor | netcoreapp50 |   112.88 ns |  0.809 ns |      - |         - |\r\n|      ConcurrentDictionary |        net60 |   509.34 ns |  2.575 ns | 0.0038 |      64 B |\r\n|          ImmutableHashSet |        net60 |   660.25 ns |  2.831 ns |      - |         - |\r\n| CopyOnWriteReadOnlySet |        net60 |   191.07 ns |  2.015 ns | 0.0024 |      40 B |\r\n|        CopyOnWriteList |        net60 |    81.93 ns |  0.485 ns |      - |         - |\r\n| CopyOnWriteReadOnlySetFor |        net60 |   107.90 ns |  0.507 ns |      - |         - |\r\n|      ConcurrentDictionary | netcoreapp31 |   481.35 ns |  7.861 ns | 0.0038 |      64 B |\r\n|          ImmutableHashSet | netcoreapp31 | 3,063.05 ns | 11.953 ns |      - |         - |\r\n| CopyOnWriteReadOnlySet | netcoreapp31 |   209.52 ns |  2.303 ns | 0.0024 |      40 B |\r\n|        CopyOnWriteList | netcoreapp31 |   134.69 ns |  2.706 ns |      - |         - |\r\n| CopyOnWriteReadOnlySetFor | netcoreapp31 |   125.71 ns |  0.374 ns |      - |         - |\r\n|      ConcurrentDictionary |        net48 |   625.87 ns |  3.476 ns | 0.0381 |      64 B |\r\n|          ImmutableHashSet |        net48 | 3,401.27 ns | 25.671 ns |      - |         - |\r\n| CopyOnWriteReadOnlySet |        net48 |   440.32 ns |  4.786 ns | 0.0238 |      40 B |\r\n|        CopyOnWriteList |        net48 |   374.10 ns |  1.836 ns |      - |         - |\r\n| CopyOnWriteReadOnlySetFor |        net48 |   365.92 ns |  1.113 ns |      - |         - |\r\n\r\nRelevant for this discussion are CopyOnWriteList  vs CopyOnWriteReadOnlySetFor implemented as:\r\n```C#\r\n        private readonly IReadOnlyList<string> _cow;\r\n        private readonly List<string> _cowl;\r\n\r\n        [Benchmark]\r\n        [Arguments(LookUpValue)]\r\n        public bool CopyOnWriteListAny(string lookupValue)\r\n        {\r\n            foreach (var s in _cowl)\r\n            {\r\n                if (s.StartsWith(lookupValue, StringComparison.OrdinalIgnoreCase))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n\r\n        [Benchmark]\r\n        [Arguments(LookUpValue)]\r\n        public bool CopyOnWriteReadOnlySetFor(string lookupValue)\r\n        {\r\n            for (int i = 0; i < _cow.Count; ++i)\r\n            {\r\n                if (_cow[i].StartsWith(LookUpValue, StringComparison.OrdinalIgnoreCase))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n```\r\n\r\nFrom above it seems that on net60 we would be faster by ~25ns for invocation. With total calls of about 170K that would be ~5ms CPU total from OrchardCore builds which took ~125s total CPU.\r\nOn framework, List enemuration is slightly ~10ns slower than IReadOnly for(int) enumeration.\r\n\r\nBoth differences as insignificant so I rather stick to readability of code, and IMHO `IReadOnlyList<string>` is communicating its intent better.\r\n\r\nAlso Kudos to runtime team for dotnet 6 perf work.\r\n",
              "createdAt": "2021-10-22T10:30:48Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,186 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterNuGetPackageFolders\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramW6432\"));\n+            RegisterImmutableDirectory(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\"));\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                // The path provided is not the installation root, but rather the location of devenv.exe.\n+                // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                // Failing a better way to obtain the installation root, remove that suffix.\n+                // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                // unlikely and should be easy to work around if ever needed.\n+                const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                if (dir?.EndsWith(devEnvExeRelativePath, PathComparison) == true)\n+                {\n+                    dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+                }\n+\n+                return dir;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found in the <c>NuGetPackageFolders</c> property value for a project into set of known immutable\n+        ///     paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterNuGetPackageFolders(string nuGetPackageFolders)\n+        {\n+            if (!string.IsNullOrEmpty(nuGetPackageFolders))\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);\n+                }\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath)\n+        {\n+            // In order to have allocation-less iteration we can not use nor foreach neither linq.Any.\n+            // We shall copy reference of _knownImmutableDirectoriesSnapshot into local variable as otherwise\n+            // it could be changed during for loop enumeration by other thread.\n+            IReadOnlyList<string> immutableDirectories = _knownImmutableDirectoriesSnapshot;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "These are defined in the toolset. Should they be registered there instead of here?",
              "createdAt": "2021-11-03T14:21:18Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -1355,6 +1358,24 @@ private void ConfigureWarningsAsErrorsAndMessages()\n             }\n         }\n \n+        private void ConfigureKnownImmutableFolders()\n+        {\n+            ProjectInstance project = _requestEntry?.RequestConfiguration?.Project;\n+            if (project != null)\n+            {\n+                //example: C:\\Users\\USER_NAME\\.nuget\\;C:\\Program Files\\dotnet\\sdk\\NuGetFallbackFolder\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"NuGetPackageFolders\")?.Trim());\n+                // example: C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"MSBuildFrameworkToolsPath32\")?.Trim());\n+                // example:  C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"MSBuildFrameworkToolsPath64\")?.Trim());\n+                // example: C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7.2",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Toolset seem to be better place. I think about putting it bellow this line:\r\nhttps://github.com/dotnet/msbuild/blob/9bcc06cbe19ae2482ab18eab90a82fd079b26897/src/Build/Definition/ToolsetReader.cs#L423",
              "createdAt": "2021-11-03T20:25:58Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -1355,6 +1358,24 @@ private void ConfigureWarningsAsErrorsAndMessages()\n             }\n         }\n \n+        private void ConfigureKnownImmutableFolders()\n+        {\n+            ProjectInstance project = _requestEntry?.RequestConfiguration?.Project;\n+            if (project != null)\n+            {\n+                //example: C:\\Users\\USER_NAME\\.nuget\\;C:\\Program Files\\dotnet\\sdk\\NuGetFallbackFolder\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"NuGetPackageFolders\")?.Trim());\n+                // example: C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"MSBuildFrameworkToolsPath32\")?.Trim());\n+                // example:  C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"MSBuildFrameworkToolsPath64\")?.Trim());\n+                // example: C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7.2",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-11-03T20:44:45Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -1355,6 +1358,24 @@ private void ConfigureWarningsAsErrorsAndMessages()\n             }\n         }\n \n+        private void ConfigureKnownImmutableFolders()\n+        {\n+            ProjectInstance project = _requestEntry?.RequestConfiguration?.Project;\n+            if (project != null)\n+            {\n+                //example: C:\\Users\\USER_NAME\\.nuget\\;C:\\Program Files\\dotnet\\sdk\\NuGetFallbackFolder\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"NuGetPackageFolders\")?.Trim());\n+                // example: C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"MSBuildFrameworkToolsPath32\")?.Trim());\n+                // example:  C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"MSBuildFrameworkToolsPath64\")?.Trim());\n+                // example: C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7.2",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nice find. I was curious so I tracked it down. It's generated here: https://github.com/dotnet/installer/blob/38669b06cb1816de2574123e874f9c3a5e1428fb/src/redist/targets/GenerateBundledVersions.targets#L280",
              "createdAt": "2021-11-03T14:41:02Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -1355,6 +1358,24 @@ private void ConfigureWarningsAsErrorsAndMessages()\n             }\n         }\n \n+        private void ConfigureKnownImmutableFolders()\n+        {\n+            ProjectInstance project = _requestEntry?.RequestConfiguration?.Project;\n+            if (project != null)\n+            {\n+                //example: C:\\Users\\USER_NAME\\.nuget\\;C:\\Program Files\\dotnet\\sdk\\NuGetFallbackFolder\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"NuGetPackageFolders\")?.Trim());\n+                // example: C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"MSBuildFrameworkToolsPath32\")?.Trim());\n+                // example:  C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"MSBuildFrameworkToolsPath64\")?.Trim());\n+                // example: C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7.2\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"FrameworkPathOverride\")?.Trim());\n+                // example: C:\\Program Files\\dotnet\\\n+                FileClassifier.Shared.RegisterImmutableDirectories(project.GetPropertyValue(\"NetCoreRoot\")?.Trim());",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\r\n```",
              "createdAt": "2021-11-03T14:42:00Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-11-03T20:44:35Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we have these if they're _not_ `$(NetCoreRoot)`?",
              "createdAt": "2021-11-03T14:43:47Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"dotnet\"));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It is attempt to put that on known list of immutable dirs so even code which runs before is that property resolved would leverage from this. I am not sure however, how much code that is. My gut feelings is 'not a lot'.\r\nShall we keep it here, or just relay of that one from `RequestBuilder`?",
              "createdAt": "2021-11-03T19:56:05Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"dotnet\"));",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I don't feel strongly but would propose: do just the other one and if we observe it being insufficient we can do it here. ",
              "createdAt": "2021-11-03T20:29:15Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"dotnet\"));",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think this variable is reliable; it's not defined on my machine for instance:\r\n\r\n```sh-session\r\n\u276f ls env:VS*\r\n\r\nName                           Value\r\n----                           -----\r\nVSSDKINSTALL                   C:\\Program Files\\Microsoft Visual Studio\\2022\\Preview\\VSSDK\r\nVS170COMNTOOLS                 C:\\Program Files\\Microsoft Visual Studio\\2022\\Preview\\Common7\\Tools\\\r\nVSCMD_VER                      17.1.0-pre.2.0\r\nVSCMD_ARG_HOST_ARCH            x86\r\nVSSDK150INSTALL                C:\\Program Files\\Microsoft Visual Studio\\2022\\Preview\\VSSDK\r\nVSCMD_ARG_TGT_ARCH             x86\r\nVSCMD_ARG_app_plat             Desktop\r\nVSINSTALLDIR                   C:\\Program Files\\Microsoft Visual Studio\\2022\\Preview\\\r\n```\r\n\r\nCan you use something like the current-assembly-directory-minus-some-layers code in BuildEnvironmentHelper? And yeah, please add a comment about disentangling from shared (on that glorious future day).\r\n\r\nhttps://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Shared/BuildEnvironmentHelper.cs#L317-L324",
              "createdAt": "2021-11-03T14:50:15Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"dotnet\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"dotnet\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "VSAPPIDDIR env var is created and VS process. So the code will always work if MSBuild is invoked/spawned from VS.\r\nIf MSBuild is invoked from command line this will not work. \r\nHowever, according to our traces there is only limited amount of files with multiply up-to-date checks from VS folder. I am just trying to do the best effort here, maybe we can consider to not include VS in there for now. Shall we?",
              "createdAt": "2021-11-03T19:47:47Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"dotnet\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"dotnet\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "> However, according to our traces there is only limited amount of files with multiply up-to-date checks from VS folder.\r\n\r\nReally? I'd expect them to be quite common since there are a bunch of `.targets` files installed with VS and we should be checking ~all of them at every project load to get the latest one for `$(MSBuildAllProjects)`.",
              "createdAt": "2021-11-03T19:50:30Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"dotnet\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"dotnet\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Hmmm, you are right. I have been misled by the fact that I have captured traces when running MSBuilld from bootstrap artifacts. Now when I look at it, I have find that bellow files are queried quite often:\r\nfile | # of checks\r\n-- | --\r\nE:\\dev\\msbuild\\artifacts\\bin\\bootstrap\\net472\\MSBuild\\Current\\Bin\\amd64\\Microsoft.Common.targets | 149\r\nE:\\dev\\msbuild\\artifacts\\bin\\bootstrap\\net472\\MSBuild\\Current\\Bin\\amd64\\Microsoft.Xaml.targets | 504\r\n\r\nHowever, to use BuildEnvironmentHelper.cs i'd have to include all bunch of Shared files in Framework. I can of course clone the related parts of code. What would you recommend?",
              "createdAt": "2021-11-03T20:14:29Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"dotnet\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"dotnet\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I'm fine with copy/paste and a note.",
              "createdAt": "2021-11-03T20:15:35Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"dotnet\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"dotnet\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Done. Quite a few lines has been cloned. Tested and verified in debugger.",
              "createdAt": "2021-11-03T22:40:54Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Singe, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"dotnet\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"dotnet\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            return;\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wouldn't this miss mac?",
              "createdAt": "2021-11-05T21:27:12Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "macOS is generally case insensitive, but case preserving. Although dotnet uses case sensitive for it as well.\r\n\r\nMaybe use `!IsWindows`?",
              "createdAt": "2021-11-05T22:42:12Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "This logic is copied from `NativeMethodsShared.OSUsesCaseSensitivePaths`. If we shall change this logic, I would recommend to address it in another PR.",
              "createdAt": "2021-11-08T00:11:30Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a normal scenario in which one of these is not set?",
              "createdAt": "2021-11-05T21:33:12Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Wouldn't the Environment.GetSpecialFolder be good as a fallback?",
              "createdAt": "2021-11-05T22:42:50Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "They are always SET, as far as I know. This optimization does needs to be bullet proof as long as it hit majority of the cases. \r\nEnvironment.GetSpecialFolder are not used intentionally, as I wanted something which would guarantee to be null at !windows.",
              "createdAt": "2021-11-07T23:39:56Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "!string.IsNullOrEmpty?",
              "createdAt": "2021-11-05T21:34:19Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I had it that way, for some reason, it surfaces bug in Roslyn analyzers flagging line 115 bellow as possible null ref bug.",
              "createdAt": "2021-11-08T00:19:53Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Weird. I feel like that's a very common pattern; I'm surprised Roslyn analyzers don't have it covered.",
              "createdAt": "2021-11-08T03:18:29Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                if (processFileName.Equals(\"MSBUILD\", StringComparison.OrdinalIgnoreCase) ||\r\n                    processFileName.Equals(\"MSBUILDTASKHOST\", StringComparison.OrdinalIgnoreCase))\r\n```\r\n? Seems much simpler",
              "createdAt": "2021-11-05T21:39:30Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This code was clones from Shared. In order to minimize bugs, I was trying to keep it as close as possible to originals. \r\nThis code will be eventually deleted and replaces when Framework adopt Shared functionality.",
              "createdAt": "2021-11-08T16:05:34Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Rather than trimming at call sites, maybe trim here? That said, are they really expected to have random spaces?",
              "createdAt": "2021-11-05T21:41:07Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I though about that too, but rejected it.\r\nOnly the calling side knows if the value shall be trimmed as in case of MSBuild properties which, being human editable, are prone to either end spaces.\r\nI actually do not think it matter as much. I am resolving it, if you feel string about it, feel free to unresolve it please.\r\n\r\n",
              "createdAt": "2021-11-08T00:26:43Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I vaguely remember TryAdd not being available on some framework, but since it doesn't seem to be failing, it's probably fine here.",
              "createdAt": "2021-11-05T21:43:45Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It is netstandard 2.1 so it will probably fails 3.5. But I kept 3.5 as is.",
              "createdAt": "2021-11-07T23:44:58Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Often good to avoid negatives. IsModifiable?",
              "createdAt": "2021-11-05T21:49:57Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);\n+                }\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "\r\nMy English skill is not as strong as to understand if `NonModifiable` is better than `Immutable` or `Unchangable` so  I stickled to whatever was used in source I have adopted it from [CPS](https://github.com/dotnet/project-system/blob/6dcc31fa39ad6c922bfd73af553e37e7cdfd8b80/src/Microsoft.VisualStudio.ProjectSystem.Managed/ProjectSystem/ProjectFileClassifier.cs).\r\nAlso because the default if is mostly like `if (IsNonModifiable) {check_and_skip_check}` and having it `if (!IsModifiable) {check_and_skip_check}` would not make it any less readable.",
              "createdAt": "2021-11-08T00:42:08Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);\n+                }\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I'd prefer IsFixed...but it's also reasonable to align with CPS. The bigger issue is if you get `!IsNonModifiable` at some point, at which point you have to do mental gymnastics to figure out what that actually means.",
              "createdAt": "2021-11-08T03:12:03Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);\n+                }\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not optimal memory-wise, in this particular case it does not matter\r\n        ///     much as the expected size of this set is ~5 and in very extreme cases less then 100.\r\n```",
              "createdAt": "2021-11-05T21:52:28Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            // We can't use a foreach loop or linq.Any to avoid allocations because another thread can change\r\n            // _knownImmutableDirectoriesSnapshot during enumeration.\r\n```",
              "createdAt": "2021-11-05T21:55:45Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);\n+                }\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath)\n+        {\n+            // In order to have allocation-less iteration we can not use nor foreach neither linq.Any.\n+            // We shall copy reference of _knownImmutableDirectoriesSnapshot into local variable as otherwise\n+            // it could be changed during for loop enumeration by other thread.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The had different meaning in mind:\r\n1) We can't use a foreach loop or linq.Any as its iterator allocates\r\n2) We have to keep _knownImmutableDirectoriesSnapshot  in local variable so the possible changes of _knownImmutableDirectoriesSnapshot would not be visible in during this method invocation",
              "createdAt": "2021-11-08T16:02:39Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);\n+                }\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath)\n+        {\n+            // In order to have allocation-less iteration we can not use nor foreach neither linq.Any.\n+            // We shall copy reference of _knownImmutableDirectoriesSnapshot into local variable as otherwise\n+            // it could be changed during for loop enumeration by other thread.",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Ah, missed that. How about:\r\n\r\nAvoid a foreach loop or linq.Any because they allocate.\r\nCopy _knownImmutableDirectoriesSnapshot into a local variable so other threads can't modify it during enumeration.\r\n\r\n?",
              "createdAt": "2021-11-08T18:54:06Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);\n+                }\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath)\n+        {\n+            // In order to have allocation-less iteration we can not use nor foreach neither linq.Any.\n+            // We shall copy reference of _knownImmutableDirectoriesSnapshot into local variable as otherwise\n+            // it could be changed during for loop enumeration by other thread.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Like it. Done",
              "createdAt": "2021-11-11T10:17:18Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);\n+                }\n+            }\n+        }\n+\n+        private static string EnsureTrailingSlash(string fileSpec)\n+        {\n+            if (fileSpec.Length >= 1)\n+            {\n+                char lastChar = fileSpec[fileSpec.Length - 1];\n+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)\n+                {\n+                    fileSpec += Path.DirectorySeparatorChar;\n+                }\n+            }\n+\n+            return fileSpec;\n+        }\n+\n+        /// <summary>\n+        ///     Gets whether a file is expected to not be modified in place on disk once it has been created.\n+        /// </summary>\n+        /// <param name=\"filePath\">The path to the file to test.</param>\n+        /// <returns><see langword=\"true\" /> if the file is non-modifiable, otherwise <see langword=\"false\" />.</returns>\n+        public bool IsNonModifiable(string filePath)\n+        {\n+            // In order to have allocation-less iteration we can not use nor foreach neither linq.Any.\n+            // We shall copy reference of _knownImmutableDirectoriesSnapshot into local variable as otherwise\n+            // it could be changed during for loop enumeration by other thread.",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is clearly an allocation-heavy part. Since things don't leave the known immutable directories list, we could check if _knownImmutableDirectories has just one thing more than the snapshot and add to the snapshot if so rather than allocating a new list. Alternatively, do this lazily with adding to the snapshot only when someone tries to check if something is modifiable? Combining the two would presumably require an auxiliary list, which would probably be too messy to be worth it.",
              "createdAt": "2021-11-05T21:58:06Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It is not, IMHO, allocation-heavy path. I expect that average size of `_knownImmutableDirectories` will be ~5. So it is 5 allocations, once per process existence. This is negligible, and I feel like in this particular case, not worth further optimization.\r\nAlso, we can not add to existing snapshot as its not thread safe as access to `_knownImmutableDirectoriesSnapshot` is lockless.",
              "createdAt": "2021-11-08T00:31:54Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I thought it was 5 per project, which would be a bit more, so probably not worth worrying about unless people start adding a lot more immutable folders.\r\n\r\nRight, and that's why I was thinking of checking its size first. If the size is only one greater than the previous, you don't have to worry about another process having jumped in.",
              "createdAt": "2021-11-08T03:17:07Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Runtime.InteropServices;\n+using System.Text.RegularExpressions;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///     Attempts to classify project files for various purposes such as safety and performance.\n+    /// </summary>\n+    /// <remarks>\n+    ///     Callers of this class are responsible to respect current OS path string comparison.\n+    ///     <para>\n+    ///         The term \"project files\" refers to the root project file (e.g. <c>MyProject.csproj</c>) and\n+    ///         any other <c>.props</c> and <c>.targets</c> files it imports.\n+    ///     </para>\n+    ///     <para>\n+    ///         Classifications provided are:\n+    ///         <list type=\"number\">\n+    ///             <item>\n+    ///                 <see cref=\"IsNonModifiable\" /> which indicates the file is not expected to change over time,\n+    ///                 other than when it is first created. This is a subset of non-user-editable files and\n+    ///                 generally excludes generated files which can be regenerated in response to user actions.\n+    ///             </item>\n+    ///         </list>\n+    ///     </para>\n+    /// </remarks>\n+    internal class FileClassifier\n+    {\n+        /// <summary>\n+        ///     StringComparison used for comparing paths on current OS.\n+        /// </summary>\n+        /// <remarks>\n+        ///     TODO: Replace RuntimeInformation.IsOSPlatform(OSPlatform.Linux) by NativeMethodsShared.OSUsesCaseSensitivePaths once it is moved out from Shared\n+        /// </remarks>\n+        private static readonly StringComparison PathComparison = RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;\n+\n+        /// <summary>\n+        ///     Single, static instance of an array that contains a semi-colon ';', which is used to split strings.\n+        /// </summary>\n+        private static readonly char[] s_semicolonDelimiter = {';'};\n+\n+        /// <summary>\n+        ///     Single, static <see cref=\"Lazy{T}\"/> instance of shared file FileClassifier for <see cref=\"Shared\"/> member.\n+        /// </summary>\n+        private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());\n+\n+        /// <summary>\n+        ///     Serves purpose of thread safe set of known immutable directories.\n+        /// </summary>\n+        /// <remarks>\n+        ///     Although <see cref=\"ConcurrentDictionary{TKey,TValue}\"></see> is not memory wise optimal solution, int this particular case it does no matter\n+        ///     as much as expected size of this set is ~5 and in very extreme cases less then 100.\n+        /// </remarks>\n+        private readonly ConcurrentDictionary<string, string> _knownImmutableDirectories = new();\n+\n+        /// <summary>\n+        ///     Copy on write snapshot of <see cref=\"_knownImmutableDirectories\"/>.\n+        /// </summary>\n+        private IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();\n+\n+        /// <summary>\n+        ///     Creates default FileClassifier which following immutable folders:\n+        ///     Classifications provided are:\n+        ///     <list type=\"number\">\n+        ///         <item>Program Files</item>\n+        ///         <item>Program Files (x86)</item>\n+        ///         <item>Default .nuget cache location</item>\n+        ///         <item>Visual Studio installation root</item>\n+        ///     </list>\n+        /// </summary>\n+        /// <remarks>\n+        ///     Individual projects NuGet folders are added during project build by calling\n+        ///     <see cref=\"RegisterImmutableDirectories\" />\n+        /// </remarks>\n+        public FileClassifier()\n+        {\n+            string? programFiles32 = Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\");\n+            string? programFiles64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");\n+\n+            if (!string.IsNullOrEmpty(programFiles32))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles32, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            if (!string.IsNullOrEmpty(programFiles64))\n+            {\n+                RegisterImmutableDirectory(Path.Combine(programFiles64, \"Reference Assemblies\", \"Microsoft\"));\n+            }\n+            RegisterImmutableDirectory(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".nuget\", \"packages\"));\n+\n+#if !RUNTIME_TYPE_NETCORE\n+            RegisterImmutableDirectory(GetVSInstallationDirectory());\n+\n+            static string? GetVSInstallationDirectory()\n+            {\n+                string? dir = Environment.GetEnvironmentVariable(\"VSAPPIDDIR\");\n+\n+                if (dir != null)\n+                {\n+                    // The path provided is not the installation root, but rather the location of devenv.exe.\n+                    // __VSSPROPID.VSSPROPID_InstallDirectory has the same value.\n+                    // Failing a better way to obtain the installation root, remove that suffix.\n+                    // Obviously this is brittle against changes to the relative path of devenv.exe, however that seems\n+                    // unlikely and should be easy to work around if ever needed.\n+                    const string devEnvExeRelativePath = \"Common7\\\\IDE\\\\\";\n+\n+                    if (dir.EndsWith(devEnvExeRelativePath, PathComparison))\n+                    {\n+                        dir = dir.Substring(0, dir.Length - devEnvExeRelativePath.Length);\n+\n+                        return dir;\n+                    }\n+                }\n+\n+                // TODO: Once BuildEnvironmentHelper makes it from Shared into Framework, rework the code bellow. Hint: implement GetVsRootFromMSBuildAssembly() in BuildEnvironmentHelper\n+\n+                // Seems like MSBuild did not run from VS but from CLI.\n+                // Identify current process and run it\n+                string processName = Process.GetCurrentProcess().MainModule.FileName;\n+                string processFileName = Path.GetFileNameWithoutExtension(processName);\n+\n+                if (string.IsNullOrEmpty(processFileName))\n+                {\n+                    return null;\n+                }\n+\n+                string[] msBuildProcess = { \"MSBUILD\", \"MSBUILDTASKHOST\" };\n+                if (msBuildProcess.Any(s =>\n+                    processFileName.Equals(s, StringComparison.OrdinalIgnoreCase)))\n+                {\n+                    // Check if we're in a VS installation\n+                    if (Regex.IsMatch(processName, $@\".*\\\\MSBuild\\\\Current\\\\Bin\\\\.*MSBuild(?:TaskHost)?\\.exe\", RegexOptions.IgnoreCase))\n+                    {\n+                        return GetVsRootFromMSBuildAssembly(processName);\n+                    }\n+                }\n+\n+                return null;\n+\n+                static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)\n+                {\n+                    return GetFolderAbove(msBuildAssembly,\n+                        Path.GetDirectoryName(msBuildAssembly)?.EndsWith(@\"\\amd64\", StringComparison.OrdinalIgnoreCase) == true\n+                            ? 5\n+                            : 4);\n+                }\n+\n+                static string GetFolderAbove(string path, int count = 1)\n+                {\n+                    if (count < 1)\n+                        return path;\n+\n+                    var parent = Directory.GetParent(path);\n+\n+                    while (count > 1 && parent?.Parent != null)\n+                    {\n+                        parent = parent.Parent;\n+                        count--;\n+                    }\n+\n+                    return parent?.FullName ?? path;\n+                }\n+            }\n+#endif\n+        }\n+\n+        /// <summary>\n+        ///     Shared singleton instance.\n+        /// </summary>\n+        public static FileClassifier Shared => s_sharedInstance.Value;\n+\n+        /// <summary>\n+        ///     Try add paths found into set of known immutable paths.\n+        ///     Project files under any of these folders are considered non-modifiable.\n+        /// </summary>\n+        /// <remarks>\n+        ///     This value is used by <see cref=\"IsNonModifiable\" />.\n+        ///     Files in the NuGet package cache are not expected to change over time, once they are created.\n+        /// </remarks>\n+        /// <remarks>\n+        ///     Example value: <c>\"C:\\Users\\myusername\\.nuget\\;D:\\LocalNuGetCache\\\"</c>\n+        /// </remarks>\n+        public void RegisterImmutableDirectories(string? nuGetPackageFolders)\n+        {\n+            if (nuGetPackageFolders?.Length > 0)\n+            {\n+                string[] folders = nuGetPackageFolders.Split(s_semicolonDelimiter, StringSplitOptions.RemoveEmptyEntries);\n+                foreach (string folder in folders)\n+                {\n+                    RegisterImmutableDirectory(folder);\n+                }\n+            }\n+        }\n+\n+        private void RegisterImmutableDirectory(string? directory)\n+        {\n+            if (directory?.Length > 0)\n+            {\n+                string d = EnsureTrailingSlash(directory);\n+\n+                if (_knownImmutableDirectories.TryAdd(d, d))\n+                {\n+                    _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}