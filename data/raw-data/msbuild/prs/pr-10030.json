{
  "number": 10030,
  "title": "Support lazy instantiation of ProjectInstance values when CPS Evaluation cache is used",
  "body": "### Context\r\nThis PR targets the specific scenario of constructing a ProjectInstance object from the evaluation data stored in CPS's evaluation cache, with the goal of saving memory and execution time during Solution Load.\r\n\r\nIn a previous change (https://github.com/dotnet/msbuild/commit/2a789cd8bd34b92e3f508cd2eb6ecfa9343472f9), I modified the ProjectInstance logic to rely on virtualized collections that are wrappers around the CPS evaluation cache's collection. The ProjectPropertyInstance, ProjectItemInstance, etc. objects were created ahead of time and associated with the corresponding CPS object, such that only one copy of the collections needed to exist.\r\n\r\nIn this PR, the goal is to extend that further such that the ProjectPropertyInstance, ProjectItemInstance, etc. values are only created when they're actually needed, and some new logic is introduced for reading Property values and Metadata values that allows avoiding creating the ProjectPropertyInstance and ProjectMetadataInstance when all that's sought is the EscapedValue string.\r\n\r\n### Changes Made\r\nThe collections for ProjectInstance's _properties, _itemDefinitions, _items, _itemsByEvaluatedInclude, _globalProperties, _targets, _importPaths, and _importPathsincludingDuplicates collections are replaced with specialized virtualizing collections that wrap the associated CPS collection. These collections create the ProjectPropertyInstance et al objects only when a caller requests them. Additionally, the ProjectItemDefinitionInstance's metadata collection, and the ProjectItemInstance's ItemDefinition and Metadata collections are all similarly replaced by a virtualizing collection.\r\n\r\nProjectInstance's _environmentVariableProperties still relies on the ProjectCollection's EnvironmentVariables, but a new SharedReadOnlyEnvironmentProperties collection is introduced that does not hand out copies of the PropertyDictionary, but instead the same PropertyDictionary instance whose backing collection has been made read only.\r\n\r\n### Testing\r\nManual verification of impacted scenarios and performance measurements.\r\n",
  "state": "MERGED",
  "createdAt": "2024-04-18T01:58:00Z",
  "updatedAt": "2024-05-24T07:12:40Z",
  "closedAt": "2024-05-24T07:12:40Z",
  "mergedAt": "2024-05-24T07:12:40Z",
  "additions": 1582,
  "deletions": 297,
  "changedFiles": 29,
  "headRefName": "dev/sgreen/lazyInstantiation",
  "isDraft": false,
  "author": {
    "login": "sgreenmsft"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "006ab0fafbda00902624093d0dffdc85c0c35691",
          "message": "Changes to ProjectInstance construction when the origin is an immutable data source (the evaluation cache).",
          "committedDate": "2024-04-16T22:06:57Z",
          "author": {
            "name": "Steven Green",
            "email": "sgreen@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "918a7adc9be1f67e72d44e0514baebb89f0756b2",
          "message": "Update to add GetMetadataValue that bypasses ProjectMetadataInstance instantiation",
          "committedDate": "2024-04-17T23:10:42Z",
          "author": {
            "name": "Steven Green",
            "email": "sgreen@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6ae60e4ab98473c4a5d6d18f2a3b4cfbf7aff886",
          "message": "Update to avoid building fast lookup table (as one is available from CPS).",
          "committedDate": "2024-04-18T19:02:41Z",
          "author": {
            "name": "Steven Green",
            "email": "sgreen@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0e4643ad22591c447dcdcf529e3f45d366e6f1c9",
          "message": "Merge branch 'main' into dev/sgreen/lazyInstantiation",
          "committedDate": "2024-04-18T20:02:39Z",
          "author": {
            "name": "SGreen",
            "email": "sgreen@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e5a91f88c662aa04046503cc22f652ac1de1ac7f",
          "message": "Updates as per PR feedback.",
          "committedDate": "2024-05-21T20:43:54Z",
          "author": {
            "name": "Steven Green",
            "email": "sgreen@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@sgreenmsft, Speedometer is reporting broken tests ([internal link](https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequest/551518?discussionId=6470565)), can you please take a look?",
        "createdAt": "2024-05-21T07:30:43Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "> @sgreenmsft, Speedometer is reporting broken tests ([internal link](https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequest/551518?discussionId=6470565)), can you please take a look?\r\n\r\nThank you for getting these results! \ud83d\ude42\r\n\r\nI checked and it turns out that those errors are a known infrastructure issue and the guidance is to ignore them. The ICM incident is linked under \"1 active outage\" in the Speedometer result.\r\n",
        "createdAt": "2024-05-21T20:51:42Z",
        "author": {
          "login": "sgreenmsft"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we remove this?\r\n\r\nIs this class going throgh any serialization? If yes - wehre?",
              "createdAt": "2024-05-15T10:06:38Z",
              "path": "src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs",
              "diffHunk": "@@ -0,0 +1,54 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Collections\n+{\n+    /// <inheritdoc />\n+    [DebuggerTypeProxy(typeof(HashSetDebugView<>))]\n+    [DebuggerDisplay(\"Count = {Count}\")]\n+    [Serializable()]",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Fixed.",
              "createdAt": "2024-05-21T20:55:12Z",
              "path": "src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs",
              "diffHunk": "@@ -0,0 +1,54 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Collections\n+{\n+    /// <inheritdoc />\n+    [DebuggerTypeProxy(typeof(HashSetDebugView<>))]\n+    [DebuggerDisplay(\"Count = {Count}\")]\n+    [Serializable()]",
              "author": {
                "login": "sgreenmsft"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This class might need a short comment of a a goal and implementation (as currently it might look confusing why global properties and all properties backing data are checked/fetched together)",
              "createdAt": "2024-05-15T10:14:56Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,245 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.CodeDom;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Runtime.Serialization;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Instance.ImmutableProjectCollections\n+{\n+    internal class ImmutableGlobalPropertiesCollectionConverter : IRetrievableEntryHashSet<ProjectPropertyInstance>",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Fixed.",
              "createdAt": "2024-05-21T20:55:04Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,245 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.CodeDom;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Runtime.Serialization;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Instance.ImmutableProjectCollections\n+{\n+    internal class ImmutableGlobalPropertiesCollectionConverter : IRetrievableEntryHashSet<ProjectPropertyInstance>",
              "author": {
                "login": "sgreenmsft"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can you please add a comment?",
              "createdAt": "2024-05-16T09:44:03Z",
              "path": "src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs",
              "diffHunk": "@@ -0,0 +1,22 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+using System.Runtime.Serialization;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Collections\n+{\n+    internal interface IRetrievableValuedEntryHashSet<T> : IRetrievableEntryHashSet<T>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed.",
              "createdAt": "2024-05-21T20:54:35Z",
              "path": "src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs",
              "diffHunk": "@@ -0,0 +1,22 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+using System.Runtime.Serialization;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Collections\n+{\n+    internal interface IRetrievableValuedEntryHashSet<T> : IRetrievableEntryHashSet<T>",
              "author": {
                "login": "sgreenmsft"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Would it be worth moving this to a helper, called from here and from the other `Contains` above?",
              "createdAt": "2024-05-16T09:57:54Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs",
              "diffHunk": "@@ -173,8 +196,20 @@ public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCach\n \n             public bool Contains(T item)\n             {\n-                return MSBuildNameIgnoreCaseComparer.Default.Equals(item.Key, _itemType) &&\n-                       _allItems.Contains(item);\n+                return _list.Any(\n+                    cachedItem =>\n+                    {\n+                        if (MSBuildNameIgnoreCaseComparer.Default.Equals(cachedItem.EvaluatedIncludeEscaped, item.EvaluatedIncludeEscaped))\n+                        {\n+                            T? foundItem = _getInstance(cachedItem);\n+                            if (foundItem is not null && foundItem.Equals(item))\n+                            {\n+                                return true;\n+                            }\n+                        }\n+\n+                        return false;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Thanks for this suggestion. I determined that walking the collection of all items is an inefficient and so modified it to avoid that, which results in only one implementation of Contains.",
              "createdAt": "2024-05-21T20:54:23Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs",
              "diffHunk": "@@ -173,8 +196,20 @@ public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCach\n \n             public bool Contains(T item)\n             {\n-                return MSBuildNameIgnoreCaseComparer.Default.Equals(item.Key, _itemType) &&\n-                       _allItems.Contains(item);\n+                return _list.Any(\n+                    cachedItem =>\n+                    {\n+                        if (MSBuildNameIgnoreCaseComparer.Default.Equals(cachedItem.EvaluatedIncludeEscaped, item.EvaluatedIncludeEscaped))\n+                        {\n+                            T? foundItem = _getInstance(cachedItem);\n+                            if (foundItem is not null && foundItem.Equals(item))\n+                            {\n+                                return true;\n+                            }\n+                        }\n+\n+                        return false;",
              "author": {
                "login": "sgreenmsft"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is the null check really intended here? This method is assumed to populate `Count` array elements and with the null checks it may end up with an (unknown) part of the array uninitialized.",
              "createdAt": "2024-05-16T10:08:41Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs",
              "diffHunk": "@@ -0,0 +1,103 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    internal class ImmutableStringValuedListConverter<T> : IList<string>, IReadOnlyList<string>\n+    {\n+        private readonly IList<T> _itemList;\n+        private readonly Func<T, string> _getStringValue;\n+\n+        public ImmutableStringValuedListConverter(IList<T> itemList, Func<T, string> getStringValue)\n+        {\n+            _itemList = itemList;\n+            _getStringValue = getStringValue;\n+        }\n+\n+        public string this[int index]\n+        {\n+            set => throw new NotSupportedException();\n+            get => _getStringValue(_itemList[index]);\n+        }\n+\n+        public int Count => _itemList.Count;\n+\n+        public bool IsReadOnly => true;\n+\n+        public void Add(string item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public void Insert(int index, string item) => throw new NotSupportedException();\n+\n+        public bool Remove(string item) => throw new NotSupportedException();\n+\n+        public void RemoveAt(int index) => throw new NotSupportedException();\n+\n+        public bool Contains(string item)\n+        {\n+            return IndexOf(item) >= 0;\n+        }\n+\n+        public void CopyTo(string[] array, int arrayIndex)\n+        {\n+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _itemList.Count);\n+\n+            int currentIndex = arrayIndex;\n+            foreach (var item in _itemList)\n+            {\n+                string? stringValue = _getStringValue(item);\n+                if (stringValue != null)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed.",
              "createdAt": "2024-05-21T20:53:20Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs",
              "diffHunk": "@@ -0,0 +1,103 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    internal class ImmutableStringValuedListConverter<T> : IList<string>, IReadOnlyList<string>\n+    {\n+        private readonly IList<T> _itemList;\n+        private readonly Func<T, string> _getStringValue;\n+\n+        public ImmutableStringValuedListConverter(IList<T> itemList, Func<T, string> getStringValue)\n+        {\n+            _itemList = itemList;\n+            _getStringValue = getStringValue;\n+        }\n+\n+        public string this[int index]\n+        {\n+            set => throw new NotSupportedException();\n+            get => _getStringValue(_itemList[index]);\n+        }\n+\n+        public int Count => _itemList.Count;\n+\n+        public bool IsReadOnly => true;\n+\n+        public void Add(string item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public void Insert(int index, string item) => throw new NotSupportedException();\n+\n+        public bool Remove(string item) => throw new NotSupportedException();\n+\n+        public void RemoveAt(int index) => throw new NotSupportedException();\n+\n+        public bool Contains(string item)\n+        {\n+            return IndexOf(item) >= 0;\n+        }\n+\n+        public void CopyTo(string[] array, int arrayIndex)\n+        {\n+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _itemList.Count);\n+\n+            int currentIndex = arrayIndex;\n+            foreach (var item in _itemList)\n+            {\n+                string? stringValue = _getStringValue(item);\n+                if (stringValue != null)",
              "author": {
                "login": "sgreenmsft"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Same question about null values and the number of populated array elements being unpredictable for the caller as in `ImmutableStringValuedListConverter`.",
              "createdAt": "2024-05-16T10:21:52Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs",
              "diffHunk": "@@ -0,0 +1,186 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    internal class ImmutableItemDefinitionsListConverter<TCached, T> : IList<T>\n+        where T : IKeyed\n+        where TCached : IKeyed\n+    {\n+        private readonly IList<TCached>? _itemList;\n+        private readonly TCached? _itemTypeDefinition;\n+        private readonly Func<TCached, T> _getInstance;\n+\n+        public ImmutableItemDefinitionsListConverter(\n+            IList<TCached>? itemList,\n+            TCached? itemTypeDefinition,\n+            Func<TCached, T> getInstance)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentNull(getInstance, nameof(getInstance));\n+\n+            _itemList = itemList;\n+            _itemTypeDefinition = itemTypeDefinition;\n+            _getInstance = getInstance;\n+        }\n+\n+        public T this[int index]\n+        {\n+            set => throw new NotSupportedException();\n+            get\n+            {\n+                if (_itemList == null)\n+                {\n+                    if (index != 0 || _itemTypeDefinition == null)\n+                    {\n+                        throw new IndexOutOfRangeException();\n+                    }\n+\n+                    return _getInstance(_itemTypeDefinition);\n+                }\n+\n+                if (index > _itemList.Count)\n+                {\n+                    throw new IndexOutOfRangeException();\n+                }\n+\n+                if (index == _itemList.Count)\n+                {\n+                    if (_itemTypeDefinition == null)\n+                    {\n+                        throw new IndexOutOfRangeException();\n+                    }\n+\n+                    return _getInstance(_itemTypeDefinition);\n+                }\n+\n+                return _getInstance(_itemList[index]);\n+            }\n+        }\n+\n+        public int Count => (_itemList == null ? 0 : _itemList.Count) + (_itemTypeDefinition == null ? 0 : 1);\n+\n+        public bool IsReadOnly => true;\n+\n+        public void Add(T item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public void Insert(int index, T item) => throw new NotSupportedException();\n+\n+        public bool Remove(T item) => throw new NotSupportedException();\n+\n+        public void RemoveAt(int index) => throw new NotSupportedException();\n+\n+        public bool Contains(T item)\n+        {\n+            return IndexOf(item) >= 0;\n+        }\n+\n+        public void CopyTo(T[] array, int arrayIndex)\n+        {\n+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), Count);\n+\n+            int currentIndex = arrayIndex;\n+            void PutItemIntoArray(TCached item)\n+            {\n+                T? instance = _getInstance(item);\n+                if (instance != null)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed.",
              "createdAt": "2024-05-21T20:53:14Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs",
              "diffHunk": "@@ -0,0 +1,186 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    internal class ImmutableItemDefinitionsListConverter<TCached, T> : IList<T>\n+        where T : IKeyed\n+        where TCached : IKeyed\n+    {\n+        private readonly IList<TCached>? _itemList;\n+        private readonly TCached? _itemTypeDefinition;\n+        private readonly Func<TCached, T> _getInstance;\n+\n+        public ImmutableItemDefinitionsListConverter(\n+            IList<TCached>? itemList,\n+            TCached? itemTypeDefinition,\n+            Func<TCached, T> getInstance)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentNull(getInstance, nameof(getInstance));\n+\n+            _itemList = itemList;\n+            _itemTypeDefinition = itemTypeDefinition;\n+            _getInstance = getInstance;\n+        }\n+\n+        public T this[int index]\n+        {\n+            set => throw new NotSupportedException();\n+            get\n+            {\n+                if (_itemList == null)\n+                {\n+                    if (index != 0 || _itemTypeDefinition == null)\n+                    {\n+                        throw new IndexOutOfRangeException();\n+                    }\n+\n+                    return _getInstance(_itemTypeDefinition);\n+                }\n+\n+                if (index > _itemList.Count)\n+                {\n+                    throw new IndexOutOfRangeException();\n+                }\n+\n+                if (index == _itemList.Count)\n+                {\n+                    if (_itemTypeDefinition == null)\n+                    {\n+                        throw new IndexOutOfRangeException();\n+                    }\n+\n+                    return _getInstance(_itemTypeDefinition);\n+                }\n+\n+                return _getInstance(_itemList[index]);\n+            }\n+        }\n+\n+        public int Count => (_itemList == null ? 0 : _itemList.Count) + (_itemTypeDefinition == null ? 0 : 1);\n+\n+        public bool IsReadOnly => true;\n+\n+        public void Add(T item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public void Insert(int index, T item) => throw new NotSupportedException();\n+\n+        public bool Remove(T item) => throw new NotSupportedException();\n+\n+        public void RemoveAt(int index) => throw new NotSupportedException();\n+\n+        public bool Contains(T item)\n+        {\n+            return IndexOf(item) >= 0;\n+        }\n+\n+        public void CopyTo(T[] array, int arrayIndex)\n+        {\n+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), Count);\n+\n+            int currentIndex = arrayIndex;\n+            void PutItemIntoArray(TCached item)\n+            {\n+                T? instance = _getInstance(item);\n+                if (instance != null)",
              "author": {
                "login": "sgreenmsft"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: These can be `readonly`.",
              "createdAt": "2024-05-16T11:27:36Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,245 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.CodeDom;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Runtime.Serialization;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Instance.ImmutableProjectCollections\n+{\n+    internal class ImmutableGlobalPropertiesCollectionConverter : IRetrievableEntryHashSet<ProjectPropertyInstance>\n+    {\n+        private IDictionary<string, string> _globalProperties;\n+        private PropertyDictionary<ProjectPropertyInstance> _allProperties;\n+        private ValuesCollection _values;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed.",
              "createdAt": "2024-05-21T20:53:02Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,245 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.CodeDom;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Runtime.Serialization;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Instance.ImmutableProjectCollections\n+{\n+    internal class ImmutableGlobalPropertiesCollectionConverter : IRetrievableEntryHashSet<ProjectPropertyInstance>\n+    {\n+        private IDictionary<string, string> _globalProperties;\n+        private PropertyDictionary<ProjectPropertyInstance> _allProperties;\n+        private ValuesCollection _values;",
              "author": {
                "login": "sgreenmsft"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This method returns null if `_globalProperties` contains the key, while the other `Get` overload return null if `_globalProperties` does not contain the key. Expected?",
              "createdAt": "2024-05-16T11:32:10Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,245 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.CodeDom;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Runtime.Serialization;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Instance.ImmutableProjectCollections\n+{\n+    internal class ImmutableGlobalPropertiesCollectionConverter : IRetrievableEntryHashSet<ProjectPropertyInstance>\n+    {\n+        private IDictionary<string, string> _globalProperties;\n+        private PropertyDictionary<ProjectPropertyInstance> _allProperties;\n+        private ValuesCollection _values;\n+\n+        public ImmutableGlobalPropertiesCollectionConverter(\n+            IDictionary<string, string> globalProperties,\n+            PropertyDictionary<ProjectPropertyInstance> allProperties)\n+        {\n+            _globalProperties = globalProperties;\n+            _allProperties = allProperties;\n+            _values = new ValuesCollection(this);\n+        }\n+\n+        public ProjectPropertyInstance this[string key]\n+        {\n+            set => throw new NotSupportedException();\n+            get\n+            {\n+                if (_globalProperties.ContainsKey(key))\n+                {\n+                    return _allProperties[key];\n+                }\n+\n+                return null;\n+            }\n+        }\n+\n+        public int Count => _globalProperties.Count;\n+\n+        public bool IsReadOnly => true;\n+\n+        public ICollection<string> Keys => _globalProperties.Keys;\n+\n+        public ICollection<ProjectPropertyInstance> Values => _values;\n+\n+        public void Add(ProjectPropertyInstance item) => throw new NotSupportedException();\n+\n+        public void Add(string key, ProjectPropertyInstance value) => throw new NotSupportedException();\n+\n+        public void Add(KeyValuePair<string, ProjectPropertyInstance> item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public bool Contains(ProjectPropertyInstance item) => _values.Contains(item);\n+\n+        public bool Contains(KeyValuePair<string, ProjectPropertyInstance> itemKvp) => _values.Contains(itemKvp.Value);\n+\n+        public bool ContainsKey(string key) => _globalProperties.ContainsKey(key);\n+\n+        public void CopyTo(ProjectPropertyInstance[] array) => _values.CopyTo(array, arrayIndex: 0);\n+\n+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);\n+\n+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);\n+\n+        public void CopyTo(KeyValuePair<string, ProjectPropertyInstance>[] array, int arrayIndex)\n+        {\n+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _globalProperties.Count);\n+\n+            int currentIndex = arrayIndex;\n+            foreach (var itemKey in _globalProperties.Keys)\n+            {\n+                ProjectPropertyInstance instance = _allProperties[itemKey];\n+                if (instance != null)\n+                {\n+                    array[currentIndex] = new KeyValuePair<string, ProjectPropertyInstance>(itemKey, instance);\n+                    ++currentIndex;\n+                }\n+            }\n+        }\n+\n+        public ProjectPropertyInstance Get(string key)\n+        {\n+            if (_globalProperties.ContainsKey(key))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Thanks for finding this! Fixed.",
              "createdAt": "2024-05-21T20:52:33Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,245 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.CodeDom;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Runtime.Serialization;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Instance.ImmutableProjectCollections\n+{\n+    internal class ImmutableGlobalPropertiesCollectionConverter : IRetrievableEntryHashSet<ProjectPropertyInstance>\n+    {\n+        private IDictionary<string, string> _globalProperties;\n+        private PropertyDictionary<ProjectPropertyInstance> _allProperties;\n+        private ValuesCollection _values;\n+\n+        public ImmutableGlobalPropertiesCollectionConverter(\n+            IDictionary<string, string> globalProperties,\n+            PropertyDictionary<ProjectPropertyInstance> allProperties)\n+        {\n+            _globalProperties = globalProperties;\n+            _allProperties = allProperties;\n+            _values = new ValuesCollection(this);\n+        }\n+\n+        public ProjectPropertyInstance this[string key]\n+        {\n+            set => throw new NotSupportedException();\n+            get\n+            {\n+                if (_globalProperties.ContainsKey(key))\n+                {\n+                    return _allProperties[key];\n+                }\n+\n+                return null;\n+            }\n+        }\n+\n+        public int Count => _globalProperties.Count;\n+\n+        public bool IsReadOnly => true;\n+\n+        public ICollection<string> Keys => _globalProperties.Keys;\n+\n+        public ICollection<ProjectPropertyInstance> Values => _values;\n+\n+        public void Add(ProjectPropertyInstance item) => throw new NotSupportedException();\n+\n+        public void Add(string key, ProjectPropertyInstance value) => throw new NotSupportedException();\n+\n+        public void Add(KeyValuePair<string, ProjectPropertyInstance> item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public bool Contains(ProjectPropertyInstance item) => _values.Contains(item);\n+\n+        public bool Contains(KeyValuePair<string, ProjectPropertyInstance> itemKvp) => _values.Contains(itemKvp.Value);\n+\n+        public bool ContainsKey(string key) => _globalProperties.ContainsKey(key);\n+\n+        public void CopyTo(ProjectPropertyInstance[] array) => _values.CopyTo(array, arrayIndex: 0);\n+\n+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);\n+\n+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);\n+\n+        public void CopyTo(KeyValuePair<string, ProjectPropertyInstance>[] array, int arrayIndex)\n+        {\n+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _globalProperties.Count);\n+\n+            int currentIndex = arrayIndex;\n+            foreach (var itemKey in _globalProperties.Keys)\n+            {\n+                ProjectPropertyInstance instance = _allProperties[itemKey];\n+                if (instance != null)\n+                {\n+                    array[currentIndex] = new KeyValuePair<string, ProjectPropertyInstance>(itemKey, instance);\n+                    ++currentIndex;\n+                }\n+            }\n+        }\n+\n+        public ProjectPropertyInstance Get(string key)\n+        {\n+            if (_globalProperties.ContainsKey(key))",
              "author": {
                "login": "sgreenmsft"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This namespace import looks unused.",
              "createdAt": "2024-05-16T11:42:59Z",
              "path": "src/Build/Instance/ProjectInstance.cs",
              "diffHunk": "@@ -10,6 +10,7 @@\n using System.IO;\n using System.Linq;\n using System.Runtime.CompilerServices;\n+using System.Threading;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Thanks. Removed.",
              "createdAt": "2024-05-21T20:52:03Z",
              "path": "src/Build/Instance/ProjectInstance.cs",
              "diffHunk": "@@ -10,6 +10,7 @@\n using System.IO;\n using System.Linq;\n using System.Runtime.CompilerServices;\n+using System.Threading;",
              "author": {
                "login": "sgreenmsft"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I am a bit confused here with `GetOrSet` idea of a function. In particular, it does not allow to get the value without trying to provide some value to set (which would be ignored if it is already set). I might be missing something, but it seems to me that further in the code the input value is created with \"new\" and may actually not be used? If so, why do not have separate `Get()` and `Set()` functions? ",
              "createdAt": "2024-05-22T12:29:19Z",
              "path": "src/Build/Instance/IImmutableInstanceProvider.cs",
              "diffHunk": "@@ -9,6 +9,19 @@ namespace Microsoft.Build.Execution\n     /// <typeparam name=\"T\">The Instance type.</typeparam>\n     internal interface IImmutableInstanceProvider<T>\n     {\n-        T ImmutableInstance { get; set; }\n+        /// <summary>\n+        /// Gets the Immutable Instance.\n+        /// </summary>\n+        T ImmutableInstance { get; }\n+\n+        /// <summary>\n+        /// If the ImmutableInstance has not already been set, then this\n+        /// method sets the ImmutableInstance to the requested value.\n+        /// An already set ImmutableInstance is never replaced.\n+        /// </summary>\n+        /// <param name=\"instance\">An instance that will be set as the immutable instance, provided that\n+        /// the immutable instance has not already been set.</param>\n+        /// <returns>The immutable instance, which may or may not be the supplied <paramref name=\"instance\"/>.</returns>\n+        T GetOrSetImmutableInstance(T instance);",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "This pattern is used for thread-safe initialization of the value. It's similar to ConcurrentDictionary's GetOrAdd method.\r\n\r\nThe IImmutableInstanceProvider interface provides a getter (T ImmutableInstance { get; }) and a GetOrSet method. The convention is for callers to try retrieving the value using the getter and, if it's not been initialized, the caller instantiates a new instance of T and calls GetOrSet. The GetOrSet method's job is to set the value while taking into consideration the fact that multiple callers could be attempting to initialize the value simultaneously.\r\n\r\nIn the typical case, where no race condition happens, the instance provided to GetOrSet by the caller is stored as the value and that value is handed back to the caller. In the rare condition of a race, then one of the two callers will end up having instantiated an instance of T that gets discarded, but that's acceptable as it's rare and the cost of instantiation isn't massive.",
              "createdAt": "2024-05-22T19:06:23Z",
              "path": "src/Build/Instance/IImmutableInstanceProvider.cs",
              "diffHunk": "@@ -9,6 +9,19 @@ namespace Microsoft.Build.Execution\n     /// <typeparam name=\"T\">The Instance type.</typeparam>\n     internal interface IImmutableInstanceProvider<T>\n     {\n-        T ImmutableInstance { get; set; }\n+        /// <summary>\n+        /// Gets the Immutable Instance.\n+        /// </summary>\n+        T ImmutableInstance { get; }\n+\n+        /// <summary>\n+        /// If the ImmutableInstance has not already been set, then this\n+        /// method sets the ImmutableInstance to the requested value.\n+        /// An already set ImmutableInstance is never replaced.\n+        /// </summary>\n+        /// <param name=\"instance\">An instance that will be set as the immutable instance, provided that\n+        /// the immutable instance has not already been set.</param>\n+        /// <returns>The immutable instance, which may or may not be the supplied <paramref name=\"instance\"/>.</returns>\n+        T GetOrSetImmutableInstance(T instance);",
              "author": {
                "login": "sgreenmsft"
              }
            }
          ]
        }
      }
    ]
  }
}