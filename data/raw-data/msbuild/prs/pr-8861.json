{
  "number": 8861,
  "title": "Fix TaskRegistry CPUWatson issues due to false optimistic concurrency",
  "body": "Fixes [ADO#1801351](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1801351) and [ADO#1801341](https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1801341)\r\n\r\n### Context\r\nVarious `TaskRegistry` methods were reported to have infinite loops caused by corrupted dictionary state.\r\n\r\n### Changes Made\r\nReplacing the flagged Dictionaries and as well other ones on similar execution paths with ConcurrentDictionaries, plus where appropriate guarded access to inner structures as well (where reads are expected only after all writes - simple lock was added)\r\n\r\n",
  "state": "CLOSED",
  "createdAt": "2023-06-08T17:25:01Z",
  "updatedAt": "2023-07-14T08:30:05Z",
  "closedAt": "2023-06-30T10:17:37Z",
  "mergedAt": null,
  "additions": 123,
  "deletions": 114,
  "changedFiles": 3,
  "headRefName": "perfbug/taskregistry-concurrent",
  "isDraft": true,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Performance",
    "do-not-merge"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "3e01b5ef3c47dfd8a2034fabdb6f5cd302b9fde3",
          "message": "Make TaskRegistry.GetTaskRegistrationRecord and TaskRegistry.RegisterTask thread safe",
          "committedDate": "2023-06-08T16:08:53Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b9bbf23bb9d7f3f3b885685ab2d2bca876dbb513",
          "message": "Makete TaskRegistry.CanTaskBeCreatedByFactory thread safe",
          "committedDate": "2023-06-08T16:31:00Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "53b00cee53542fcd0153fa9e0998fd3f2cccefde",
          "message": "Make _cachedTaskRecordsWithExactMatch thread safe",
          "committedDate": "2023-06-08T17:03:12Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a88e70d0041424d79bb664e44f44784fb9fc4aa5",
          "message": "Make _cachedTaskRecordsWithFuzzyMatch threadsafe",
          "committedDate": "2023-06-08T17:15:20Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "88343e126a5a9a55d32e73055a0e301a9f94501d",
          "message": "Fix _cachedTaskRecordsWithExactMatch",
          "committedDate": "2023-06-08T17:18:20Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8c0891fc81b68c7d1a83655ffdeea7d4d4b68f45",
          "message": "Add order agnostic dictionaries comparison",
          "committedDate": "2023-06-09T09:06:02Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3d36b54a15e55b5a792e0a597140a8ff301bf79d",
          "message": "Make TaskRegistry task ordering deterministic (FIFO)",
          "committedDate": "2023-06-15T08:41:06Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5ac71c394641539b2f016f0d5b5e4d20130f9092",
          "message": "Fix style",
          "committedDate": "2023-06-15T11:29:35Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e12bec2abf094cd46d72d99ddb7b3ca3672ee595",
          "message": "Reflect PR suggestions",
          "committedDate": "2023-06-16T11:44:04Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aa21310eb457502efb0066e44429b7ced3b18c33",
          "message": "Fix nullref",
          "committedDate": "2023-06-16T12:27:29Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Aaah - there is a hidden trap - we're relying on implicit ordering of the data in the Dictionary fields (e.g. here https://github.com/dotnet/msbuild/pull/8861/files#diff-9233ff64c785ef48b792931b3c5f0d709e741671c2c0bb2b7afb6c09aaaaeb81R626 ordering influences which task will be returned), which by itself feel very wrong, but it can (and does) break with replacing the backing field with ConcurrentDictionary, which has different internal ordering.\r\n\r\nThe proper solution is to order the enumerations explicitly (probably by the order of registrations) - however since the previous implementation was lacking the ordering, this can lead to altered behavior perceived as regressions.\r\n\r\n@rainersigwald - thoughts on this? Can we introdce explicit ordering by order of registrations?",
        "createdAt": "2023-06-09T09:23:13Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "> Aaah - there is a hidden trap - we're relying on implicit ordering of the data in the Dictionary fields (e.g. here https://github.com/dotnet/msbuild/pull/8861/files#diff-9233ff64c785ef48b792931b3c5f0d709e741671c2c0bb2b7afb6c09aaaaeb81R626 ordering influences which task will be returned), which by itself feel very wrong, but it can (and does) break with replacing the backing field with ConcurrentDictionary, which has different internal ordering.\r\n> \r\n> The proper solution is to order the enumerations explicitly (probably by the order of registrations) - however since the previous implementation was lacking the ordering, this can lead to altered behavior perceived as regressions.\r\n> \r\n> @rainersigwald Rainer Sigwald FTE - thoughts on this? Can we introdce explicit ordering by order of registrations?\r\n\r\nExplicitly addressed here: https://github.com/dotnet/msbuild/pull/8861/files#diff-9233ff64c785ef48b792931b3c5f0d709e741671c2c0bb2b7afb6c09aaaaeb81R593 and here: https://github.com/dotnet/msbuild/pull/8861/files#diff-9233ff64c785ef48b792931b3c5f0d709e741671c2c0bb2b7afb6c09aaaaeb81R604\r\n\r\nWhile this is very likely intended behavior (LIFO of the multiple matching tasks) - it may cause unexpected results in some cases - e.g.: this https://github.com/dotnet/msbuild/pull/8861/files#diff-0c7ff4eddab39e683e61e6f11011eac73dae76d2574999184b3c0e74f9c2fa10R44 was needed to fix the failing test (as wrong `GenerateResource` task was selected)\r\n\r\nAlthough not sure about this comment: https://github.com/dotnet/msbuild/blob/main/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs#LL836C33-L836C52\r\n\r\nDo we want the conflicting UsingTasks to be LIFO or FIFO? I believe it's the former..",
        "createdAt": "2023-06-14T16:28:50Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "I was just writing a comment in a file and it disappeared from the diff. I'll paste it here because it may still be relevant.\r\n\r\nI was specifically looking at the way `GenerateResource` tasks are registered.\r\n\r\nSo multiple tasks are registered under the same name, but with different runtimes. You're saying that previously we relied on implicit ordering and it worked \"by accident\". How does one select the task to run in this scenario? Is there a way to say \"I want to invoke the CLR2 version of this task\"?\r\n\r\n- If yes, then all call sites should do it (there's likely a bug somewhere else).\r\n- If not, then is it useful at all to have multiple `UsingTask`s with the same `TaskName` that would have their conditions evaluate to true? When we know we always want the last one to win anyways?\r\n\r\nI'm still flabbergasted by this, apologies for the stupid questions.",
        "createdAt": "2023-06-15T09:06:59Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "@JanKrivanek and I have synced offline and here's what we found:\r\n- There _is_ a way to invoke a task with a specific runtime and/or architecture using the `MSBuildRuntime` and `MSBuildArchitecture` attributes.\r\n- The `GenerateResource` task in common targets is indeed invoked with these attributes specified and the issue with undefined behavior of `TaskRegistry`, related to non-deterministic order of dictionary enumeration, may not be a problem in practice. It was uncovered with a unit test.\r\n- Arguably it is still better to avoid this undefined behavior and a introduce a well-defined task-matching order. (My opinion: if someone relies on the current behavior, is is OK to break them.)\r\n- Since .NET Core does not support cross-runtime or cross-architecture task execution, it is very likely that `TaskRegistry` could be made much simpler in the .NET build of MSBuild. This would be at the expense of ifdef's or code duplication, and as-of-now-unmeasured perf benefits. It is better left as a future exercise, out of scope of this PR.",
        "createdAt": "2023-06-15T20:00:50Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "> Changes LGTM.\r\n> \r\n> However we are fixing symptoms and not the root cause. `TaskRegistry` was never supposed to be thread safety and whole object graph which is referencing it is not supposed to be thread safety as well.\r\n> \r\n> Something is violating our non-thread-safe usage requirements. This shall not be fixed, IMO, by making some subset of data structures thread safe, as it has performance and complexity consequences, but by fixing concurrency usage of our non-thread-safe data structures. That being said, it is hard to guess if guilty code is in MSBuild or VS.\r\n> \r\n> I have made experimental code changes to detect wrong concurrency usages, but I was not able to repro it locally in patched VS INT for Orchard SLN open and build scenario.\r\n> \r\n> We can still decide to fix it this way, but this will hide other possible concurrency bugs caused by same root cause.\r\n> \r\n> I am blocking this PR so we, core msbuild team @rainersigwald @ladipro @JanKrivanek @AR-May, can decide how to approach it.\r\n\r\n**tl;dr:** There is a possibility of race between public API build and evaluation calls. And I agree there might be other ways to fix this.\r\n\r\n---\r\nMore details: The TaskRegistry is shared via the [`Data`](https://github.com/dotnet/msbuild/blob/main/src/Build/Definition/Project.cs#L4010) type which is member of `ProjectImpl` - which is part of Project. The Data structure can be shared between the evaluation and build (sample usage during build: https://github.com/dotnet/msbuild/blob/main/src/Build/Definition/Project.cs#L3341).\r\n\r\nBuild is more-or-less guarded not to be concurrent ([`StartBuilderThread`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L634) and [`DedicatedThreadsTaskScheduler`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#LL1391C30-L1391C60) are both subject to races - but it's very edgy, so can be considered fine). However evaluation is not being guarded via same exclusion as build requests. Both are exposed via public API in `Project`.\r\nSo we either would need to make Evaluation and Build fully exclusive or make the `Data` class not to be shared between the two, or make the members of `Data` class thread safe. First two seem possibly too impactful. Last one can be done by steps (individual members of `Data` class) - this PR is step for TaskRegistry\r\n",
        "createdAt": "2023-06-22T10:38:59Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Each evaluation creates new `TasklRegistry` for purpose of that evaluation. So evaluations can't clash with build.\r\n\r\nI have found two suspicious places which are indeed wrong, and might be the root cause of observed issues:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/402af3b0510be4e25a6b830da7c0a0a1533795bd/src/Build/Instance/ProjectInstance.cs#L564\r\n\r\nhttps://github.com/dotnet/msbuild/blob/402af3b0510be4e25a6b830da7c0a0a1533795bd/src/Build/Instance/ProjectInstance.cs#L644-L645\r\n\r\nThis needs to be fixed. We have to somehow create deep clone of `TaskRegistry`. We can't share task registry between clones of ProjectInstance as source ProjectInstance might be affected by cloned ProjectInstance TaskRegistry mutation or data corruption.",
        "createdAt": "2023-06-22T12:15:22Z",
        "author": {
          "login": "rokonec"
        }
      },
      {
        "body": "Discussed this offline with @rokonec - a new PR will be created (we need better isolation guarantees way up the stack in ProjectInstance)",
        "createdAt": "2023-06-23T08:43:14Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "superseded by: https://github.com/dotnet/msbuild/pull/8973",
        "createdAt": "2023-06-30T10:17:37Z",
        "author": {
          "login": "JanKrivanek"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                List<RegisteredTaskRecord> records = _overriddenTasks.GetOrAdd(unqualifiedTaskName, _ => new List<RegisteredTaskRecord>());\r\n```\r\n\r\n?",
              "createdAt": "2023-06-08T19:14:30Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -682,37 +673,39 @@ private static bool IsTaskFactoryClass(Type type, object unused)\n                 string[] nameComponents = taskName.Split('.');\n                 string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];\n \n-                // Is the task already registered?\n-                if (overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))\n+                List<RegisteredTaskRecord> records = _overriddenTasks.GetOrAdd(unqualifiedTaskName, new List<RegisteredTaskRecord>());",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Looks like they added \"pass `-1` to use the default\" in .NET 8 but I don't think it's worth ifdefing around it.",
              "createdAt": "2023-06-08T19:20:13Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -682,37 +673,39 @@ private static bool IsTaskFactoryClass(Type type, object unused)\n                 string[] nameComponents = taskName.Split('.');\n                 string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];\n \n-                // Is the task already registered?\n-                if (overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))\n+                List<RegisteredTaskRecord> records = _overriddenTasks.GetOrAdd(unqualifiedTaskName, new List<RegisteredTaskRecord>());\n+\n+                lock (records)\n                 {\n-                    foreach (RegisteredTaskRecord rec in recs)\n+                    if (records.Count == 0)\n                     {\n-                        if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))\n-                        {\n-                            loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n-                            break;\n-                        }\n+                        // New record's name may be fully qualified. Use it anyway to account for partial matches.\n+                        records.Add(newRecord);\n+                        loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n+                    }\n+                    // Is the task already registered?\n+                    else if (records.Any(rec => rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase)))\n+                    {\n+                        loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n+                    }\n+                    else\n+                    {\n+                        records.Add(newRecord);\n                     }\n-                    recs.Add(newRecord);\n-                }\n-                else\n-                {\n-                    // New record's name may be fully qualified. Use it anyway to account for partial matches.\n-                    List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();\n-                    unqualifiedTaskNameMatches.Add(newRecord);\n-                    overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);\n-                    loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n                 }\n             }\n \n-            registeredTaskEntries.Add(newRecord);\n+            lock (registeredTaskEntries)\n+            {\n+                registeredTaskEntries.Add(newRecord);\n+            }\n         }\n \n-        private static Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(int? capacity = null)\n+        private static ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(int? capacity = null)\n         {\n             return capacity != null\n-                ? new Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(capacity.Value, RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact)\n-                : new Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);\n+                ? new ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(Environment.ProcessorCount, capacity.Value, RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "\r\nGood to know!\r\nFor now - let's keep this simple",
              "createdAt": "2023-06-14T16:16:01Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -682,37 +673,39 @@ private static bool IsTaskFactoryClass(Type type, object unused)\n                 string[] nameComponents = taskName.Split('.');\n                 string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];\n \n-                // Is the task already registered?\n-                if (overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))\n+                List<RegisteredTaskRecord> records = _overriddenTasks.GetOrAdd(unqualifiedTaskName, new List<RegisteredTaskRecord>());\n+\n+                lock (records)\n                 {\n-                    foreach (RegisteredTaskRecord rec in recs)\n+                    if (records.Count == 0)\n                     {\n-                        if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))\n-                        {\n-                            loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n-                            break;\n-                        }\n+                        // New record's name may be fully qualified. Use it anyway to account for partial matches.\n+                        records.Add(newRecord);\n+                        loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n+                    }\n+                    // Is the task already registered?\n+                    else if (records.Any(rec => rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase)))\n+                    {\n+                        loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n+                    }\n+                    else\n+                    {\n+                        records.Add(newRecord);\n                     }\n-                    recs.Add(newRecord);\n-                }\n-                else\n-                {\n-                    // New record's name may be fully qualified. Use it anyway to account for partial matches.\n-                    List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();\n-                    unqualifiedTaskNameMatches.Add(newRecord);\n-                    overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);\n-                    loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n                 }\n             }\n \n-            registeredTaskEntries.Add(newRecord);\n+            lock (registeredTaskEntries)\n+            {\n+                registeredTaskEntries.Add(newRecord);\n+            }\n         }\n \n-        private static Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(int? capacity = null)\n+        private static ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(int? capacity = null)\n         {\n             return capacity != null\n-                ? new Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(capacity.Value, RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact)\n-                : new Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);\n+                ? new ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(Environment.ProcessorCount, capacity.Value, RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why do this instead of GetOrAdd with this as a lambda?",
              "createdAt": "2023-06-08T19:23:29Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1215,18 +1210,13 @@ internal ParameterGroupAndTaskElementRecord ParameterGroupAndTaskBody\n             /// <returns>true if the task can be created by the factory, false if it cannot be created</returns>\n             internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile, IDictionary<string, string> taskIdentityParameters, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation)\n             {\n-                // Keep a cache of task identities which have been checked against the factory, this is useful because we ask this question everytime we get a registered task record or a taskFactory wrapper.\n-                if (_taskNamesCreatableByFactory == null)\n-                {\n-                    _taskNamesCreatableByFactory = new Dictionary<RegisteredTaskIdentity, object>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);\n-                }\n-\n                 RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskIdentityParameters);\n \n                 // See if the task name as already been checked against the factory, return the value if it has\n                 object creatableByFactory = null;\n-                if (!_taskNamesCreatableByFactory.TryGetValue(taskIdentity, out creatableByFactory))\n+                if (!_taskNamesCreatableByFactory.Value.TryGetValue(taskIdentity, out creatableByFactory))\n                 {\n+                    // Multiple threads can enter here for a single taskIdentity and create the factory, only one will be stored in the dictionary",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "The `finally` block here is a bit of catch (haha - unitended pun) - as currently in case of unhandled exception an explicit null will be inserted into the dictionary (in finally); with `GetOrAdd` this is not possible.\r\nWhile I *think* such behavior was not fully intended, I do not understand all the possible corner cases - so didn't want to change this",
              "createdAt": "2023-06-14T16:24:28Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1215,18 +1210,13 @@ internal ParameterGroupAndTaskElementRecord ParameterGroupAndTaskBody\n             /// <returns>true if the task can be created by the factory, false if it cannot be created</returns>\n             internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile, IDictionary<string, string> taskIdentityParameters, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation)\n             {\n-                // Keep a cache of task identities which have been checked against the factory, this is useful because we ask this question everytime we get a registered task record or a taskFactory wrapper.\n-                if (_taskNamesCreatableByFactory == null)\n-                {\n-                    _taskNamesCreatableByFactory = new Dictionary<RegisteredTaskIdentity, object>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);\n-                }\n-\n                 RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskIdentityParameters);\n \n                 // See if the task name as already been checked against the factory, return the value if it has\n                 object creatableByFactory = null;\n-                if (!_taskNamesCreatableByFactory.TryGetValue(taskIdentity, out creatableByFactory))\n+                if (!_taskNamesCreatableByFactory.Value.TryGetValue(taskIdentity, out creatableByFactory))\n                 {\n+                    // Multiple threads can enter here for a single taskIdentity and create the factory, only one will be stored in the dictionary",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Why is it not possible to add null with `GetOrAdd`? I believe the `Func<TKey,TValue>` can legally return null and have it added as a value.",
              "createdAt": "2023-06-15T21:27:23Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1215,18 +1210,13 @@ internal ParameterGroupAndTaskElementRecord ParameterGroupAndTaskBody\n             /// <returns>true if the task can be created by the factory, false if it cannot be created</returns>\n             internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile, IDictionary<string, string> taskIdentityParameters, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation)\n             {\n-                // Keep a cache of task identities which have been checked against the factory, this is useful because we ask this question everytime we get a registered task record or a taskFactory wrapper.\n-                if (_taskNamesCreatableByFactory == null)\n-                {\n-                    _taskNamesCreatableByFactory = new Dictionary<RegisteredTaskIdentity, object>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);\n-                }\n-\n                 RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskIdentityParameters);\n \n                 // See if the task name as already been checked against the factory, return the value if it has\n                 object creatableByFactory = null;\n-                if (!_taskNamesCreatableByFactory.TryGetValue(taskIdentity, out creatableByFactory))\n+                if (!_taskNamesCreatableByFactory.Value.TryGetValue(taskIdentity, out creatableByFactory))\n                 {\n+                    // Multiple threads can enter here for a single taskIdentity and create the factory, only one will be stored in the dictionary",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "That is possible.\r\nWhat is not possible is to add a null and throw an exception (if GetOrAdd throws, then value is not added and vice versa). The previous code was adding the value in `finally` - so in case of exception it'd add null and exception would still be thrown.",
              "createdAt": "2023-06-16T11:02:18Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1215,18 +1210,13 @@ internal ParameterGroupAndTaskElementRecord ParameterGroupAndTaskBody\n             /// <returns>true if the task can be created by the factory, false if it cannot be created</returns>\n             internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile, IDictionary<string, string> taskIdentityParameters, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation)\n             {\n-                // Keep a cache of task identities which have been checked against the factory, this is useful because we ask this question everytime we get a registered task record or a taskFactory wrapper.\n-                if (_taskNamesCreatableByFactory == null)\n-                {\n-                    _taskNamesCreatableByFactory = new Dictionary<RegisteredTaskIdentity, object>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);\n-                }\n-\n                 RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskIdentityParameters);\n \n                 // See if the task name as already been checked against the factory, return the value if it has\n                 object creatableByFactory = null;\n-                if (!_taskNamesCreatableByFactory.TryGetValue(taskIdentity, out creatableByFactory))\n+                if (!_taskNamesCreatableByFactory.Value.TryGetValue(taskIdentity, out creatableByFactory))\n                 {\n+                    // Multiple threads can enter here for a single taskIdentity and create the factory, only one will be stored in the dictionary",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I see! Ok, there may be ways around it (e.g. switch from `finally` to `catch` and do a `TryAdd(..., null)` there, but the perf benefit of calling only on operation on the happy path is probably negligible. Looks good!",
              "createdAt": "2023-06-16T11:32:26Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1215,18 +1210,13 @@ internal ParameterGroupAndTaskElementRecord ParameterGroupAndTaskBody\n             /// <returns>true if the task can be created by the factory, false if it cannot be created</returns>\n             internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile, IDictionary<string, string> taskIdentityParameters, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation)\n             {\n-                // Keep a cache of task identities which have been checked against the factory, this is useful because we ask this question everytime we get a registered task record or a taskFactory wrapper.\n-                if (_taskNamesCreatableByFactory == null)\n-                {\n-                    _taskNamesCreatableByFactory = new Dictionary<RegisteredTaskIdentity, object>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);\n-                }\n-\n                 RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskIdentityParameters);\n \n                 // See if the task name as already been checked against the factory, return the value if it has\n                 object creatableByFactory = null;\n-                if (!_taskNamesCreatableByFactory.TryGetValue(taskIdentity, out creatableByFactory))\n+                if (!_taskNamesCreatableByFactory.Value.TryGetValue(taskIdentity, out creatableByFactory))\n                 {\n+                    // Multiple threads can enter here for a single taskIdentity and create the factory, only one will be stored in the dictionary",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This one can also be `readonly`.",
              "createdAt": "2023-06-15T20:48:36Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -126,23 +129,23 @@ internal sealed class TaskRegistry : ITranslatable\n         /// Cache of tasks already found using exact matching,\n         /// keyed by the task identity requested.\n         /// </summary>\n-        private Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord> _cachedTaskRecordsWithExactMatch;\n+        private readonly Lazy<ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord>> _cachedTaskRecordsWithExactMatch = new(() => new(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact));\n \n         /// <summary>\n         /// Cache of tasks already found using fuzzy matching,\n         /// keyed by the task name requested.\n         /// Value is a dictionary of all possible matches for that\n         /// task name, by unique identity.\n         /// </summary>\n-        private Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>> _cachedTaskRecordsWithFuzzyMatch;\n+        private Lazy<ConcurrentDictionary<string, ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord>>> _cachedTaskRecordsWithFuzzyMatch = new(() => new(StringComparer.OrdinalIgnoreCase));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This statement looks redundant. We know `taskRecords` is already in the outer dictionary because we got it from `GetOrAdd`.",
              "createdAt": "2023-06-15T20:57:30Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -575,14 +561,12 @@ internal Toolset Toolset\n                 // 3. Look up Foo | baz (gets its own entry because it doesn't match Foo | bar)\n                 // 4. Look up Foo | * (should get the Foo | * under Foo | bar, but depending on what the dictionary looks up \n                 //    first, might get Foo | baz, which also matches, instead) \n-                Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords;\n-                if (!_cachedTaskRecordsWithFuzzyMatch.TryGetValue(taskIdentity.Name, out taskRecords))\n-                {\n-                    taskRecords = new Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);\n-                }\n+                ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords\n+                    = _cachedTaskRecordsWithFuzzyMatch.Value.GetOrAdd(taskIdentity.Name,\n+                        _ => new (RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact));\n \n                 taskRecords[taskIdentity] = taskRecord;\n-                _cachedTaskRecordsWithFuzzyMatch[taskIdentity.Name] = taskRecords;\n+                _cachedTaskRecordsWithFuzzyMatch.Value[taskIdentity.Name] = taskRecords;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Good catch!",
              "createdAt": "2023-06-16T10:42:03Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -575,14 +561,12 @@ internal Toolset Toolset\n                 // 3. Look up Foo | baz (gets its own entry because it doesn't match Foo | bar)\n                 // 4. Look up Foo | * (should get the Foo | * under Foo | bar, but depending on what the dictionary looks up \n                 //    first, might get Foo | baz, which also matches, instead) \n-                Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords;\n-                if (!_cachedTaskRecordsWithFuzzyMatch.TryGetValue(taskIdentity.Name, out taskRecords))\n-                {\n-                    taskRecords = new Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);\n-                }\n+                ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords\n+                    = _cachedTaskRecordsWithFuzzyMatch.Value.GetOrAdd(taskIdentity.Name,\n+                        _ => new (RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact));\n \n                 taskRecords[taskIdentity] = taskRecord;\n-                _cachedTaskRecordsWithFuzzyMatch[taskIdentity.Name] = taskRecords;\n+                _cachedTaskRecordsWithFuzzyMatch.Value[taskIdentity.Name] = taskRecords;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it really correct to add the new record without checking if it's already there? (Think two threads running this method in parallel.)",
              "createdAt": "2023-06-15T21:05:41Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -682,37 +646,39 @@ private static bool IsTaskFactoryClass(Type type, object unused)\n                 string[] nameComponents = taskName.Split('.');\n                 string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];\n \n-                // Is the task already registered?\n-                if (overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))\n+                List<RegisteredTaskRecord> records = _overriddenTasks.GetOrAdd(unqualifiedTaskName, _ => new List<RegisteredTaskRecord>());\n+\n+                lock (records)\n                 {\n-                    foreach (RegisteredTaskRecord rec in recs)\n+                    if (records.Count == 0)\n                     {\n-                        if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))\n-                        {\n-                            loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n-                            break;\n-                        }\n+                        // New record's name may be fully qualified. Use it anyway to account for partial matches.\n+                        records.Add(newRecord);\n+                        loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n+                    }\n+                    // Is the task already registered?\n+                    else if (records.Any(rec => rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase)))\n+                    {\n+                        loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n+                    }\n+                    else\n+                    {\n+                        records.Add(newRecord);\n                     }\n-                    recs.Add(newRecord);\n-                }\n-                else\n-                {\n-                    // New record's name may be fully qualified. Use it anyway to account for partial matches.\n-                    List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();\n-                    unqualifiedTaskNameMatches.Add(newRecord);\n-                    overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);\n-                    loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n                 }\n             }\n \n-            registeredTaskEntries.Add(newRecord);\n+            lock (registeredTaskEntries)\n+            {\n+                registeredTaskEntries.Add(newRecord);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Technically it would be fine - as we allways select just one task. Question is the perf impact\r\n\r\nLooking on the execution paths leading to here (either from `Evaluate` or from `ExecuteTarget`), there is currently no option of executing this method concurrently - so I think even the `lock` is actually wrong here - so removing that one.\r\n\r\nDoes that sound ok? ",
              "createdAt": "2023-06-16T10:59:33Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -682,37 +646,39 @@ private static bool IsTaskFactoryClass(Type type, object unused)\n                 string[] nameComponents = taskName.Split('.');\n                 string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];\n \n-                // Is the task already registered?\n-                if (overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))\n+                List<RegisteredTaskRecord> records = _overriddenTasks.GetOrAdd(unqualifiedTaskName, _ => new List<RegisteredTaskRecord>());\n+\n+                lock (records)\n                 {\n-                    foreach (RegisteredTaskRecord rec in recs)\n+                    if (records.Count == 0)\n                     {\n-                        if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))\n-                        {\n-                            loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n-                            break;\n-                        }\n+                        // New record's name may be fully qualified. Use it anyway to account for partial matches.\n+                        records.Add(newRecord);\n+                        loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n+                    }\n+                    // Is the task already registered?\n+                    else if (records.Any(rec => rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase)))\n+                    {\n+                        loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n+                    }\n+                    else\n+                    {\n+                        records.Add(newRecord);\n                     }\n-                    recs.Add(newRecord);\n-                }\n-                else\n-                {\n-                    // New record's name may be fully qualified. Use it anyway to account for partial matches.\n-                    List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();\n-                    unqualifiedTaskNameMatches.Add(newRecord);\n-                    overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);\n-                    loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n                 }\n             }\n \n-            registeredTaskEntries.Add(newRecord);\n+            lock (registeredTaskEntries)\n+            {\n+                registeredTaskEntries.Add(newRecord);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "As long as this is provably separate from the code paths where we're currently hitting concurrency issues (which, presumably led us to this PR), it sounds OK!",
              "createdAt": "2023-06-16T11:25:09Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -682,37 +646,39 @@ private static bool IsTaskFactoryClass(Type type, object unused)\n                 string[] nameComponents = taskName.Split('.');\n                 string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];\n \n-                // Is the task already registered?\n-                if (overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))\n+                List<RegisteredTaskRecord> records = _overriddenTasks.GetOrAdd(unqualifiedTaskName, _ => new List<RegisteredTaskRecord>());\n+\n+                lock (records)\n                 {\n-                    foreach (RegisteredTaskRecord rec in recs)\n+                    if (records.Count == 0)\n                     {\n-                        if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))\n-                        {\n-                            loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n-                            break;\n-                        }\n+                        // New record's name may be fully qualified. Use it anyway to account for partial matches.\n+                        records.Add(newRecord);\n+                        loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n+                    }\n+                    // Is the task already registered?\n+                    else if (records.Any(rec => rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase)))\n+                    {\n+                        loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n+                    }\n+                    else\n+                    {\n+                        records.Add(newRecord);\n                     }\n-                    recs.Add(newRecord);\n-                }\n-                else\n-                {\n-                    // New record's name may be fully qualified. Use it anyway to account for partial matches.\n-                    List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();\n-                    unqualifiedTaskNameMatches.Add(newRecord);\n-                    overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);\n-                    loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n                 }\n             }\n \n-            registeredTaskEntries.Add(newRecord);\n+            lock (registeredTaskEntries)\n+            {\n+                registeredTaskEntries.Add(newRecord);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "On a second thought (and crawlingthrough the code) - I'm not so 100% sure that the writer part cannot be concurrent (and it can always be attempted to be made concrrent in the future) - so rather keeping the lock.\r\n\r\nAs for double registration - that sounds as a niche case, that would force all registrations to first traverse existing lists (despite they'll most often have zero items), so I believe the perf tradeoff is correct here. But I'm open to opposing ideas :-)",
              "createdAt": "2023-06-16T11:48:49Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -682,37 +646,39 @@ private static bool IsTaskFactoryClass(Type type, object unused)\n                 string[] nameComponents = taskName.Split('.');\n                 string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];\n \n-                // Is the task already registered?\n-                if (overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))\n+                List<RegisteredTaskRecord> records = _overriddenTasks.GetOrAdd(unqualifiedTaskName, _ => new List<RegisteredTaskRecord>());\n+\n+                lock (records)\n                 {\n-                    foreach (RegisteredTaskRecord rec in recs)\n+                    if (records.Count == 0)\n                     {\n-                        if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))\n-                        {\n-                            loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n-                            break;\n-                        }\n+                        // New record's name may be fully qualified. Use it anyway to account for partial matches.\n+                        records.Add(newRecord);\n+                        loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n+                    }\n+                    // Is the task already registered?\n+                    else if (records.Any(rec => rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase)))\n+                    {\n+                        loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), \"DuplicateOverrideUsingTaskElement\", taskName);\n+                    }\n+                    else\n+                    {\n+                        records.Add(newRecord);\n                     }\n-                    recs.Add(newRecord);\n-                }\n-                else\n-                {\n-                    // New record's name may be fully qualified. Use it anyway to account for partial matches.\n-                    List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();\n-                    unqualifiedTaskNameMatches.Add(newRecord);\n-                    overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);\n-                    loggingService.LogComment(context, MessageImportance.Low, \"OverrideUsingTaskElementCreated\", taskName, projectUsingTaskInXml.OverrideLocation);\n                 }\n             }\n \n-            registeredTaskEntries.Add(newRecord);\n+            lock (registeredTaskEntries)\n+            {\n+                registeredTaskEntries.Add(newRecord);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "In light of multi-threading, is it guaranteed that the order defined by this global monotonically increasing counter is always stable in all scenarios? I.e. can multiple threads be registering tasks from, say, different project files, each defining a task with a colliding name, and racing to define the one in their file as \"first\"?",
              "createdAt": "2023-06-15T21:35:39Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1126,6 +1099,7 @@ internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLo\n                 _taskFactoryParameters = taskFactoryParameters;\n                 _taskIdentity = new RegisteredTaskIdentity(registeredName, taskFactoryParameters);\n                 _parameterGroupAndTaskBody = inlineTask;\n+                _registrationOrderId = Interlocked.Increment(ref s_nextRegistrationOrderId);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I'm specifically thinking of cases where there is no race in the user input but MSBuild internally decides to do some work in parallel. It looks unlikely but not all that far-fetched either.",
              "createdAt": "2023-06-15T22:06:00Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1126,6 +1099,7 @@ internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLo\n                 _taskFactoryParameters = taskFactoryParameters;\n                 _taskIdentity = new RegisteredTaskIdentity(registeredName, taskFactoryParameters);\n                 _parameterGroupAndTaskBody = inlineTask;\n+                _registrationOrderId = Interlocked.Increment(ref s_nextRegistrationOrderId);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Great question!\r\nCan we actually have `UsingTask` that step outside of the project boundary?\r\n\r\n*I believe* we are entitled to keep undeterministic behavior in such (theoretical only?) scenario (multple project files with coliding UsingTask elements) - as otherwise we'd need to commit to zero level of paralelism or add ability to explicitly specify priority/order of tasks. If explicit order would need to be added by user - they can already add disambiguate namings.\r\n\r\nAgain - I beleive we are concerned only in a single project here - so the situation likely doesn't exist",
              "createdAt": "2023-06-16T11:09:35Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1126,6 +1099,7 @@ internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLo\n                 _taskFactoryParameters = taskFactoryParameters;\n                 _taskIdentity = new RegisteredTaskIdentity(registeredName, taskFactoryParameters);\n                 _parameterGroupAndTaskBody = inlineTask;\n+                _registrationOrderId = Interlocked.Increment(ref s_nextRegistrationOrderId);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How will the registration ID compare to tasks registered in another process after this instance is deserialized there? Are serialized and then deserialized task registries effectively read-only?",
              "createdAt": "2023-06-15T21:44:46Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1765,6 +1739,7 @@ public void Translate(ITranslator translator)\n                 translator.Translate(ref _taskFactoryAssemblyLoadInfo, AssemblyLoadInfo.FactoryForTranslation);\n                 translator.Translate(ref _taskFactory);\n                 translator.Translate(ref _parameterGroupAndTaskBody);\n+                translator.Translate(ref _registrationOrderId);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Oh - good question - let's make sure we do not have to have answer for it :-) (I'll move the counter to TaskRegistry and update it on deserialization)",
              "createdAt": "2023-06-16T11:28:11Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1765,6 +1739,7 @@ public void Translate(ITranslator translator)\n                 translator.Translate(ref _taskFactoryAssemblyLoadInfo, AssemblyLoadInfo.FactoryForTranslation);\n                 translator.Translate(ref _taskFactory);\n                 translator.Translate(ref _parameterGroupAndTaskBody);\n+                translator.Translate(ref _registrationOrderId);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`copy.Count` may be smaller than the maximum order ID on the serializing side. Shouldn't you actually make `s_nextRegistrationOrderId` part of the payload?",
              "createdAt": "2023-06-16T11:41:34Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1790,10 +1766,12 @@ public void Translate(ITranslator translator)\n \n             IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> copy = _taskRegistrations;\n             translator.TranslateDictionary(ref copy, TranslateTaskRegistrationKey, TranslateTaskRegistrationValue, count => CreateRegisteredTaskDictionary(count));\n+            // Ensure that mutations of the deserialized task registry are getting unique order ids.\n+            s_nextRegistrationOrderId = Math.Max(s_nextRegistrationOrderId, copy.Count);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "That should be fine - we only need to prevent colisions. \r\n\r\nIf receiving site already have the `s_nextRegistrationOrderId` greater than what was the last order id on sending side, than it will not have collisions after possible mutations.\r\n\r\nThe only possible catch would be if we'd allow transfering registeret tasks between different instances of TaskRegistry on different nodes - in such case we'd need to maintain some form of globla distributed identity (e.g. [snowflake ids](https://github.com/RobThree/IdGen)) - but that is overkill now",
              "createdAt": "2023-06-16T11:59:19Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1790,10 +1766,12 @@ public void Translate(ITranslator translator)\n \n             IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> copy = _taskRegistrations;\n             translator.TranslateDictionary(ref copy, TranslateTaskRegistrationKey, TranslateTaskRegistrationValue, count => CreateRegisteredTaskDictionary(count));\n+            // Ensure that mutations of the deserialized task registry are getting unique order ids.\n+            s_nextRegistrationOrderId = Math.Max(s_nextRegistrationOrderId, copy.Count);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Based on discusion with @rokonec - those fields might probably be fine to just initialize greedily (low chance of them staying noninitialized after usage of TaskRegistry)",
              "createdAt": "2023-06-22T10:16:35Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -122,27 +125,33 @@ internal sealed class TaskRegistry : ITranslatable\n         /// </summary>\n         private static string s_potentialTasksCoreLocation = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksCoreFilename);\n \n+        /// <summary>\n+        /// Monotonically increasing counter for registered tasks.\n+        /// It's not guaranteed not to have gaps, but it's purpose is the uniqueness.\n+        /// </summary>\n+        private static int s_nextRegistrationOrderId = 0;\n+\n         /// <summary>\n         /// Cache of tasks already found using exact matching,\n         /// keyed by the task identity requested.\n         /// </summary>\n-        private Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord> _cachedTaskRecordsWithExactMatch;\n+        private readonly Lazy<ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord>> _cachedTaskRecordsWithExactMatch = new(() => new(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact));",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}