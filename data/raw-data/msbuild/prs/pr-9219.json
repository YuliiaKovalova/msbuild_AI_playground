{
  "number": 9219,
  "title": "[Binlogs Redacting] API and support for external redaction functionality",
  "body": "Fixes #9147 and contributes to https://github.com/dotnet/msbuild/issues/8400\r\n\r\n**All the fixes are now contributed to the extending branch only - so please review https://github.com/dotnet/msbuild/pull/9307 only.**\r\n\r\n\r\n-------------------------------------------------\r\n\r\n\r\n~~**The fwd-compatability reading support PR**: https://github.com/JanKrivanek/msbuild/pull/1 (this aims to be incorporated into this PR).\r\n**If you prefer to review both set of changes within single PR:** https://github.com/dotnet/msbuild/pull/9307~~\r\n\r\n### Context\r\nhttps://github.com/dotnet/msbuild/issues/8400\r\n\r\nThis PR enables:\r\n * Transparentness of binlogs replaying\r\n   * Equalitity of build events upon de/serialization\r\n   * Ability to configure replaying of binlog embedded files\r\n   * Ability to configure replaying of initial binlog information events (version, params)\r\n   * Ability to opt-in into determinstic compression of binlog stream (via `GreedyBufferedStream`)\r\n* Adjustments to Binary log replaying API - (exposing ability to supply file vs reader - plus ownership considerations; ability to subscribe to embedded files replaying events)\r\n* `BuildEventArgsReader` exposes event for optional editing embedded files during replaying\r\n  * Either accessible via more versatile `ArchiveFileEventArgs` - that allows accessing file contents via `StreamReader` for more optimal work with large files\r\n  * Or handleable via simple `Action<StringReadEventArgs` handler - allowing to reuse identical handler as exposed for editing strings\r\n  * Binlogs replaying optimaly switches the embedded content reading stratgy based on if/what is the caller subscribing to (just skipping the content vs replaying the embedded stream as is vs unpacking it and interpretting it as embedded files).\r\n\r\nIn combination with the complement PR implementing the actual redactor (https://github.com/JanKrivanek/MSBuildBinlogRedactor/pull/2) it enables:\r\n\r\n\r\n<img width=\"1022\" alt=\"image\" src=\"https://github.com/dotnet/msbuild/assets/3809076/0676b224-e441-449e-b46a-5b6172777c76\">\r\n",
  "state": "CLOSED",
  "createdAt": "2023-09-15T13:56:02Z",
  "updatedAt": "2023-10-30T14:01:10Z",
  "closedAt": "2023-10-30T14:01:10Z",
  "mergedAt": null,
  "additions": 1057,
  "deletions": 179,
  "changedFiles": 23,
  "headRefName": "proto/binlog-replay",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "b8e30485eb68e31688e0149c57a7fa335e34860b",
          "message": "Add embedded content transfering and build events binary equality",
          "committedDate": "2023-09-12T11:38:28Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "282de14076d8022415f8203deaad23b53c883601",
          "message": "Added support for embedded files; fixing, cleaning",
          "committedDate": "2023-09-15T13:53:09Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "19fd9137be6e82e9fb695d7cef6b85f4f075ed70",
          "message": "Decrease scope where accidentally exposed",
          "committedDate": "2023-09-18T12:26:55Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6e03efed6c85f1d6fae5ad9b48c238603b282c96",
          "message": "Sealing types",
          "committedDate": "2023-09-19T13:17:04Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8a3bb35c15e0bc1069ed9fdf11180b6b6eba86b1",
          "message": "Adjust visibility, add comments",
          "committedDate": "2023-09-20T14:50:12Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "09f32ed4fc30fd893bbc9747fafec5e5a84c1f6e",
          "message": "Cache encoding",
          "committedDate": "2023-09-21T10:07:47Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "248043fc7525f622e55f8c5ace07ff9ade457eca",
          "message": "Merge remote-tracking branch 'upstream/main' into proto/binlog-replay",
          "committedDate": "2023-10-02T12:08:44Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7cdd0e09292fb475e2b5f7560d9cdbceead9eded",
          "message": "Fix code after merge",
          "committedDate": "2023-10-02T12:12:58Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e970a9921617390bcac107eb9c354551f569702c",
          "message": "Fix after merge",
          "committedDate": "2023-10-04T08:28:27Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Also, I forgot to mention it in the review, please consider covering the new code with unit tests. The new stream adaptors, for one,  should be easily testable.",
        "createdAt": "2023-10-09T13:44:37Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "**All the fixes are now contributed to the extending branch only - so please review https://github.com/dotnet/msbuild/pull/9307 only.**",
        "createdAt": "2023-10-10T20:34:38Z",
        "author": {
          "login": "JanKrivanek"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't this be non-nullable so the event handler knows how many bytes it should read? Currently you don't seem to be initializing this field (all instances are new'ed up using the two-parameter constructor).",
              "createdAt": "2023-09-26T12:04:44Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/EmbeddedContentEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,28 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    internal sealed class EmbeddedContentEventArgs : EventArgs\n+    {\n+        public EmbeddedContentEventArgs(EmbeddedContentKind contentKind, Stream contentStream, int length)\n+        {\n+            ContentKind = contentKind;\n+            ContentStream = contentStream;\n+            Length = length;\n+        }\n+\n+        public EmbeddedContentEventArgs(EmbeddedContentKind contentKind, Stream contentStream)\n+        {\n+            ContentKind = contentKind;\n+            ContentStream = contentStream;\n+        }\n+\n+        public EmbeddedContentKind ContentKind { get; }\n+        public Stream ContentStream { get; }\n+        public int? Length { get; }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Yes!\r\nThis is removed in the extending PR https://github.com/JanKrivanek/msbuild/pull/1/files#diff-73ad6161ceba968f5877a2765742d8bd157286950e90fc66c75daafbc423c4efL26",
              "createdAt": "2023-10-06T14:30:52Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/EmbeddedContentEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,28 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    internal sealed class EmbeddedContentEventArgs : EventArgs\n+    {\n+        public EmbeddedContentEventArgs(EmbeddedContentKind contentKind, Stream contentStream, int length)\n+        {\n+            ContentKind = contentKind;\n+            ContentStream = contentStream;\n+            Length = length;\n+        }\n+\n+        public EmbeddedContentEventArgs(EmbeddedContentKind contentKind, Stream contentStream)\n+        {\n+            ContentKind = contentKind;\n+            ContentStream = contentStream;\n+        }\n+\n+        public EmbeddedContentKind ContentKind { get; }\n+        public Stream ContentStream { get; }\n+        public int? Length { get; }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why are suppressions needed for _newly added_ API surface?\r\n\r\nCP0002 means \"A member that is visible outside of the assembly is missing in the compared assembly when required to be present.\" which I would expect to happen when we accidentally remove something. Am I misunderstanding how  package validation works?",
              "createdAt": "2023-10-05T15:37:27Z",
              "path": "src/Build/CompatibilitySuppressions.xml",
              "diffHunk": "@@ -1,4 +1,174 @@\n \ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->\n <Suppressions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n-</Suppressions>\n+  <!-- Start of suppressions needed for adjustments of added binlog reader API -->",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "This was inteded removal. Per discussion - reintroducing the member back and removing the suppressions",
              "createdAt": "2023-10-10T18:21:45Z",
              "path": "src/Build/CompatibilitySuppressions.xml",
              "diffHunk": "@@ -1,4 +1,174 @@\n \ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->\n <Suppressions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n-</Suppressions>\n+  <!-- Start of suppressions needed for adjustments of added binlog reader API -->",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Wouldn't the value of this be 17 regardless? Do we need stronger compat guarantees for this particular value?",
              "createdAt": "2023-10-05T15:46:48Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs",
              "diffHunk": "@@ -24,7 +24,7 @@ internal enum BinaryLogRecordKind\n         ProjectEvaluationStarted,\n         ProjectEvaluationFinished,\n         ProjectImported,\n-        ProjectImportArchive,\n+        ProjectImportArchive = 17,",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Resolved by adoping your tip to initialize `EmbeddedContentKind.ProjectImportArchive` via `BinaryLogRecordKind.ProjectImportArchive`",
              "createdAt": "2023-10-10T18:30:34Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs",
              "diffHunk": "@@ -24,7 +24,7 @@ internal enum BinaryLogRecordKind\n         ProjectEvaluationStarted,\n         ProjectEvaluationFinished,\n         ProjectImported,\n-        ProjectImportArchive,\n+        ProjectImportArchive = 17,",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: \r\n```suggestion\r\n            ProcessParameters(out bool replayInitialInfo);\r\n```",
              "createdAt": "2023-10-06T12:30:16Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -130,7 +138,9 @@ public void Initialize(IEventSource eventSource)\n             Traits.Instance.EscapeHatches.LogProjectImports = true;\n             bool logPropertiesAndItemsAfterEvaluation = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;\n \n-            ProcessParameters();\n+            bool replayInitialInfo;\n+            ILogVersionInfo versionInfo = null;\n+            ProcessParameters(out replayInitialInfo);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed in the extending branch: https://github.com/dotnet/msbuild/pull/9307/files#diff-0864a6f2e10a87d935fbf19d81370f534e67f33931642dec1f30023b108e2cdcR142",
              "createdAt": "2023-10-10T18:32:04Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -130,7 +138,9 @@ public void Initialize(IEventSource eventSource)\n             Traits.Instance.EscapeHatches.LogProjectImports = true;\n             bool logPropertiesAndItemsAfterEvaluation = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;\n \n-            ProcessParameters();\n+            bool replayInitialInfo;\n+            ILogVersionInfo versionInfo = null;\n+            ProcessParameters(out replayInitialInfo);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could the \"replay\" mode be enabled implicitly when the eventSource is `IEmbeddedContentSource`? I'm just trying to justify adding a new enum value and think through all the validation that may be needed. E.g. should it be an error to specify `Replay` when the event source is not `IEmbeddedContentSource`? What exactly happens when replaying with the `ZipFile` option, for example? Are there combinations that don't make sense?",
              "createdAt": "2023-10-06T13:22:41Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -92,7 +95,12 @@ public enum ProjectImportsCollectionMode\n             /// <summary>\n             /// Create an external .ProjectImports.zip archive for the project files.\n             /// </summary>\n-            ZipFile\n+            ZipFile,\n+\n+            /// <summary>\n+            /// Don't collect any files from build events, but instead replay them from the given event source (if that one supports it).\n+            /// </summary>\n+            Replay,",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Removed",
              "createdAt": "2023-10-10T19:05:20Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -92,7 +95,12 @@ public enum ProjectImportsCollectionMode\n             /// <summary>\n             /// Create an external .ProjectImports.zip archive for the project files.\n             /// </summary>\n-            ZipFile\n+            ZipFile,\n+\n+            /// <summary>\n+            /// Don't collect any files from build events, but instead replay them from the given event source (if that one supports it).\n+            /// </summary>\n+            Replay,",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This will allocate `length` bytes only to throw them away. A better way to skip bytes in a non-seekable stream would be to call one of the `Read` overloads with a reasonable buffer length in a loop.\r\n\r\nAlso, maybe `Skip` could be added as an extension method to the existing `src\\Shared\\BinaryReaderExtensions.cs`.",
              "createdAt": "2023-10-06T13:35:03Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -212,11 +224,86 @@ private static bool IsAuxiliaryRecord(BinaryLogRecordKind recordKind)\n                 || recordKind == BinaryLogRecordKind.ProjectImportArchive;\n         }\n \n-        private void ReadBlob(BinaryLogRecordKind kind)\n+        private void ReadEmbeddedContent(BinaryLogRecordKind recordKind)\n         {\n             int length = ReadInt32();\n-            byte[] bytes = binaryReader.ReadBytes(length);\n-            OnBlobRead?.Invoke(kind, bytes);\n+\n+            if (ArchiveFileEncountered != null)\n+            {\n+                // We could create ZipArchive over the target stream, and write to that directly,\n+                //  however, binlog format needs to know stream size upfront - which is unknown,\n+                //  so we would need to write the size after - and that would require the target stream to be seekable (which it's not)\n+                ProjectImportsCollector? projectImportsCollector = null;\n+\n+                if (EmbeddedContentRead != null)\n+                {\n+                    projectImportsCollector =\n+                        new ProjectImportsCollector(Path.GetRandomFileName(), false, runOnBackground: false);\n+                }\n+\n+                Stream embeddedStream = new SubStream(binaryReader.BaseStream, length);\n+\n+                // We are intentionally not grace handling corrupt embedded stream\n+\n+                using var zipArchive = new ZipArchive(embeddedStream, ZipArchiveMode.Read);\n+\n+                foreach (var entry in zipArchive.Entries/*.OrderBy(e => e.LastWriteTime)*/)\n+                {\n+                    var file = ArchiveFile.From(entry);\n+                    ArchiveFileEventArgs archiveFileEventArgs = new(file);\n+                    // ArchiveFileEventArgs is not IDisposable as we do not want to clutter exposed API\n+                    using var cleanupScope = new CleanupScope(archiveFileEventArgs.Dispose);\n+                    ArchiveFileEncountered(archiveFileEventArgs);\n+\n+                    if (projectImportsCollector != null)\n+                    {\n+                        var resultFile = archiveFileEventArgs.ObtainArchiveFile();\n+\n+                        if (resultFile.CanUseReader)\n+                        {\n+                            projectImportsCollector.AddFileFromMemory(\n+                                resultFile.FullPath,\n+                                resultFile.GetContentReader().BaseStream,\n+                                makePathAbsolute: false,\n+                                entryCreationStamp: entry.LastWriteTime);\n+                        }\n+                        else\n+                        {\n+                            projectImportsCollector.AddFileFromMemory(\n+                                resultFile.FullPath,\n+                                resultFile.GetContent(),\n+                                encoding: resultFile.Encoding,\n+                                makePathAbsolute: false,\n+                                entryCreationStamp: entry.LastWriteTime);\n+                        }\n+                    }\n+                }\n+\n+                if (EmbeddedContentRead != null)\n+                {\n+                    projectImportsCollector!.ProcessResult(\n+                        streamToEmbed => EmbeddedContentRead(new EmbeddedContentEventArgs(EmbeddedContentKind.ProjectImportArchive, streamToEmbed)),\n+                        error => throw new InvalidDataException(error));\n+                    projectImportsCollector.DeleteArchive();\n+                }\n+            }\n+            else if (EmbeddedContentRead != null)\n+            {\n+                EmbeddedContentRead(new EmbeddedContentEventArgs(\n+                    recordKind.ToEmbeddedContentKind(),\n+                    new SubStream(binaryReader.BaseStream, length)));\n+            }\n+            else\n+            {\n+                if (binaryReader.BaseStream.CanSeek)\n+                {\n+                    binaryReader.BaseStream.Seek(length, SeekOrigin.Current);\n+                }\n+                else\n+                {\n+                    binaryReader.ReadBytes(length);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Added `SkipBytes` extension to `StreamExtensions` (and leveraged array pool for that as well)",
              "createdAt": "2023-10-10T19:18:35Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -212,11 +224,86 @@ private static bool IsAuxiliaryRecord(BinaryLogRecordKind recordKind)\n                 || recordKind == BinaryLogRecordKind.ProjectImportArchive;\n         }\n \n-        private void ReadBlob(BinaryLogRecordKind kind)\n+        private void ReadEmbeddedContent(BinaryLogRecordKind recordKind)\n         {\n             int length = ReadInt32();\n-            byte[] bytes = binaryReader.ReadBytes(length);\n-            OnBlobRead?.Invoke(kind, bytes);\n+\n+            if (ArchiveFileEncountered != null)\n+            {\n+                // We could create ZipArchive over the target stream, and write to that directly,\n+                //  however, binlog format needs to know stream size upfront - which is unknown,\n+                //  so we would need to write the size after - and that would require the target stream to be seekable (which it's not)\n+                ProjectImportsCollector? projectImportsCollector = null;\n+\n+                if (EmbeddedContentRead != null)\n+                {\n+                    projectImportsCollector =\n+                        new ProjectImportsCollector(Path.GetRandomFileName(), false, runOnBackground: false);\n+                }\n+\n+                Stream embeddedStream = new SubStream(binaryReader.BaseStream, length);\n+\n+                // We are intentionally not grace handling corrupt embedded stream\n+\n+                using var zipArchive = new ZipArchive(embeddedStream, ZipArchiveMode.Read);\n+\n+                foreach (var entry in zipArchive.Entries/*.OrderBy(e => e.LastWriteTime)*/)\n+                {\n+                    var file = ArchiveFile.From(entry);\n+                    ArchiveFileEventArgs archiveFileEventArgs = new(file);\n+                    // ArchiveFileEventArgs is not IDisposable as we do not want to clutter exposed API\n+                    using var cleanupScope = new CleanupScope(archiveFileEventArgs.Dispose);\n+                    ArchiveFileEncountered(archiveFileEventArgs);\n+\n+                    if (projectImportsCollector != null)\n+                    {\n+                        var resultFile = archiveFileEventArgs.ObtainArchiveFile();\n+\n+                        if (resultFile.CanUseReader)\n+                        {\n+                            projectImportsCollector.AddFileFromMemory(\n+                                resultFile.FullPath,\n+                                resultFile.GetContentReader().BaseStream,\n+                                makePathAbsolute: false,\n+                                entryCreationStamp: entry.LastWriteTime);\n+                        }\n+                        else\n+                        {\n+                            projectImportsCollector.AddFileFromMemory(\n+                                resultFile.FullPath,\n+                                resultFile.GetContent(),\n+                                encoding: resultFile.Encoding,\n+                                makePathAbsolute: false,\n+                                entryCreationStamp: entry.LastWriteTime);\n+                        }\n+                    }\n+                }\n+\n+                if (EmbeddedContentRead != null)\n+                {\n+                    projectImportsCollector!.ProcessResult(\n+                        streamToEmbed => EmbeddedContentRead(new EmbeddedContentEventArgs(EmbeddedContentKind.ProjectImportArchive, streamToEmbed)),\n+                        error => throw new InvalidDataException(error));\n+                    projectImportsCollector.DeleteArchive();\n+                }\n+            }\n+            else if (EmbeddedContentRead != null)\n+            {\n+                EmbeddedContentRead(new EmbeddedContentEventArgs(\n+                    recordKind.ToEmbeddedContentKind(),\n+                    new SubStream(binaryReader.BaseStream, length)));\n+            }\n+            else\n+            {\n+                if (binaryReader.BaseStream.CanSeek)\n+                {\n+                    binaryReader.BaseStream.Seek(length, SeekOrigin.Current);\n+                }\n+                else\n+                {\n+                    binaryReader.ReadBytes(length);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Isn't this exposed from `Stream`? Could you simply do:\r\n\r\n```suggestion\r\n            stream.CopyTo(destinationStream, length);\r\n```\r\n",
              "createdAt": "2023-10-06T13:40:35Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -1139,9 +1113,35 @@ private void Write(byte[] bytes)\n             binaryWriter.Write(bytes);\n         }\n \n-        private void Write(Stream stream)\n+        private void Write(Stream stream, int? length)\n         {\n-            stream.CopyTo(binaryWriter.BaseStream);\n+            Stream destinationStream = binaryWriter.BaseStream;\n+            if (length == null)\n+            {\n+                stream.CopyTo(destinationStream);\n+                return;\n+            }\n+\n+            // borrowed from runtime from Stream.cs\n+            const int defaultCopyBufferSize = 81920;\n+            int bufferSize = Math.Min(defaultCopyBufferSize, length.Value);\n+\n+            byte[] buffer = ArrayPool<byte>.Shared.Rent(bufferSize);\n+            try\n+            {\n+                int bytesRead;\n+                while (\n+                    length > 0 &&\n+                    (bytesRead = stream.Read(buffer, 0, Math.Min(buffer.Length, length.Value))) != 0)\n+                {\n+                    destinationStream.Write(buffer, 0, bytesRead);\n+                    length -= bytesRead;\n+                }\n+            }\n+            finally\n+            {\n+                ArrayPool<byte>.Shared.Return(buffer);\n+            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "IIRC it wasn't available for Framework - hence the need to 'borrow' the impl from Stream.\r\nHowever - thanks to `SubStream` this is not need. It's one of the few places where the extended branch overlaps the original changes - it was removed there - https://github.com/dotnet/msbuild/pull/9307/files#diff-02de8b63c474f29b5f0b4cebfef35896934503bb16bb83d2411dda65600a42f0R1135-R1139",
              "createdAt": "2023-10-10T19:22:03Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -1139,9 +1113,35 @@ private void Write(byte[] bytes)\n             binaryWriter.Write(bytes);\n         }\n \n-        private void Write(Stream stream)\n+        private void Write(Stream stream, int? length)\n         {\n-            stream.CopyTo(binaryWriter.BaseStream);\n+            Stream destinationStream = binaryWriter.BaseStream;\n+            if (length == null)\n+            {\n+                stream.CopyTo(destinationStream);\n+                return;\n+            }\n+\n+            // borrowed from runtime from Stream.cs\n+            const int defaultCopyBufferSize = 81920;\n+            int bufferSize = Math.Min(defaultCopyBufferSize, length.Value);\n+\n+            byte[] buffer = ArrayPool<byte>.Shared.Rent(bufferSize);\n+            try\n+            {\n+                int bytesRead;\n+                while (\n+                    length > 0 &&\n+                    (bytesRead = stream.Read(buffer, 0, Math.Min(buffer.Length, length.Value))) != 0)\n+                {\n+                    destinationStream.Write(buffer, 0, bytesRead);\n+                    length -= bytesRead;\n+                }\n+            }\n+            finally\n+            {\n+                ArrayPool<byte>.Shared.Return(buffer);\n+            }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it intentional to default to `UTF8` (with preamble) here and to `s_utf8WithoutPreamble` in the other constructor?",
              "createdAt": "2023-10-06T13:48:01Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs",
              "diffHunk": "@@ -0,0 +1,94 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Text;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    public sealed class ArchiveFile\n+    {\n+        // We need to specify encoding without preamble - as then StreamReader will\n+        //  automatically adjust the encoding to match the preamble (if present).\n+        // It will as well change to other encoding if detected.\n+        private static readonly Encoding s_utf8WithoutPreamble = new UTF8Encoding(false);\n+\n+        public ArchiveFile(string fullPath, Stream contentStream)\n+        {\n+            FullPath = fullPath;\n+            _contentReader = new StreamReader(contentStream, s_utf8WithoutPreamble);\n+        }\n+\n+        public ArchiveFile(string fullPath, string content, Encoding? contentEncoding = null)\n+        {\n+            FullPath = fullPath;\n+            _content = content;\n+            _stringAcquired = true;\n+            _contentReader = StreamReader.Null;\n+            _stringEncoding = contentEncoding ?? Encoding.UTF8;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I removed the encoding handling alltogether (it was needed only for the byte-for-byte replay equality)",
              "createdAt": "2023-10-10T19:23:01Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs",
              "diffHunk": "@@ -0,0 +1,94 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Text;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    public sealed class ArchiveFile\n+    {\n+        // We need to specify encoding without preamble - as then StreamReader will\n+        //  automatically adjust the encoding to match the preamble (if present).\n+        // It will as well change to other encoding if detected.\n+        private static readonly Encoding s_utf8WithoutPreamble = new UTF8Encoding(false);\n+\n+        public ArchiveFile(string fullPath, Stream contentStream)\n+        {\n+            FullPath = fullPath;\n+            _contentReader = new StreamReader(contentStream, s_utf8WithoutPreamble);\n+        }\n+\n+        public ArchiveFile(string fullPath, string content, Encoding? contentEncoding = null)\n+        {\n+            FullPath = fullPath;\n+            _content = content;\n+            _stringAcquired = true;\n+            _contentReader = StreamReader.Null;\n+            _stringEncoding = contentEncoding ?? Encoding.UTF8;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo `GetContnetReader`.",
              "createdAt": "2023-10-06T13:49:03Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs",
              "diffHunk": "@@ -0,0 +1,94 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Text;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    public sealed class ArchiveFile\n+    {\n+        // We need to specify encoding without preamble - as then StreamReader will\n+        //  automatically adjust the encoding to match the preamble (if present).\n+        // It will as well change to other encoding if detected.\n+        private static readonly Encoding s_utf8WithoutPreamble = new UTF8Encoding(false);\n+\n+        public ArchiveFile(string fullPath, Stream contentStream)\n+        {\n+            FullPath = fullPath;\n+            _contentReader = new StreamReader(contentStream, s_utf8WithoutPreamble);\n+        }\n+\n+        public ArchiveFile(string fullPath, string content, Encoding? contentEncoding = null)\n+        {\n+            FullPath = fullPath;\n+            _content = content;\n+            _stringAcquired = true;\n+            _contentReader = StreamReader.Null;\n+            _stringEncoding = contentEncoding ?? Encoding.UTF8;\n+        }\n+\n+        internal static ArchiveFile From(ZipArchiveEntry entry)\n+        {\n+            return new ArchiveFile(entry.FullName, entry.Open());\n+        }\n+\n+        public string FullPath { get; }\n+\n+        public Encoding Encoding => _stringEncoding ?? _contentReader.CurrentEncoding;\n+\n+        public bool CanUseReader => !_stringAcquired;\n+        public bool CanUseString => !_streamAcquired;\n+\n+        /// <summary>\n+        /// Fetches the file content as a stream reader (forward only).\n+        /// This prevents the content to be read as string.\n+        /// </summary>\n+        /// <returns></returns>\n+        /// <exception cref=\"InvalidOperationException\"></exception>\n+        public StreamReader GetContentReader()\n+        {\n+            if (_stringAcquired)\n+            {\n+                throw new InvalidOperationException(\"Content already acquired as string via GetContent or initialized as string only.\");\n+            }\n+\n+            _streamAcquired = true;\n+            return _contentReader;\n+        }\n+\n+        /// <summary>\n+        /// Fetches the file content as a string.\n+        /// This prevents the content to be fetched via StreamReader.\n+        /// </summary>\n+        /// <returns></returns>\n+        /// <exception cref=\"InvalidOperationException\"></exception>\n+        public string GetContent()\n+        {\n+            if (_streamAcquired)\n+            {\n+                throw new InvalidOperationException(\"Content already acquired as StreamReader via GetContnetReader.\");",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks unnecessarily complicated. Do you think that a simple `ArchiveFile` getter and a pair of `SetArchiveFile` or maybe `ReplaceArchiveFile` methods would be misused?",
              "createdAt": "2023-10-06T13:58:44Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,54 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging;\n+\n+public sealed class ArchiveFileEventArgs : EventArgs\n+{\n+    private ArchiveFile  _archiveFile;\n+    private bool _resultSet;\n+    private Action _disposeAction;\n+\n+    public ArchiveFileEventArgs(ArchiveFile archiveFile) =>\n+        (_archiveFile, _resultSet, _disposeAction) = (archiveFile, true, archiveFile.Dispose);\n+\n+    /// <summary>\n+    /// Acquires the <see cref=\"ArchiveFile\"/> instance. This method can only be called once and\n+    /// <see cref=\"SetResult(string,Stream)\"/> or <see cref=\"SetResult(string,string)\"/> must be called afterwards\n+    /// (this is because the embedded files are stored as forward only stream - reading them prevents re-reads).\n+    /// </summary>\n+    /// <returns></returns>\n+    /// <exception cref=\"InvalidOperationException\"></exception>\n+    public ArchiveFile ObtainArchiveFile()\n+    {\n+        if (!_resultSet)\n+        {\n+            throw new InvalidOperationException(\n+                \"ArchiveFile was obtained, but the final edited version was not set.\");\n+        }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I feel it is needed. Let me try to explain - if it makes sense:\r\n\r\nDue to dual access pattern to `ArchiveFile` - via Stream and via string - the behavior is undefined if the content is obtained multiple time. And for the Stream case - even once it's obtained once, the value cannot then be read by the exposing reader or by the next event in the subscription chain. This contract tries to express this situation explicitly and fail fast and clearly if any subscriber just reads the value and doesn't properly set the result. Event the name of the method tries to suggest it is one-time action, taking the ownership.\r\n\r\ntl;dr; Having getter could lead to out of bounds exception (due to reading beyond end of exposed stream) for the second subscriber (or the event firing reader) when subscriber wouldn't call SetResults afterwards.\r\n\r\n\r\n\r\nWith this background - would you still prefer getter? Or at least different naming?",
              "createdAt": "2023-10-10T19:31:57Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,54 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging;\n+\n+public sealed class ArchiveFileEventArgs : EventArgs\n+{\n+    private ArchiveFile  _archiveFile;\n+    private bool _resultSet;\n+    private Action _disposeAction;\n+\n+    public ArchiveFileEventArgs(ArchiveFile archiveFile) =>\n+        (_archiveFile, _resultSet, _disposeAction) = (archiveFile, true, archiveFile.Dispose);\n+\n+    /// <summary>\n+    /// Acquires the <see cref=\"ArchiveFile\"/> instance. This method can only be called once and\n+    /// <see cref=\"SetResult(string,Stream)\"/> or <see cref=\"SetResult(string,string)\"/> must be called afterwards\n+    /// (this is because the embedded files are stored as forward only stream - reading them prevents re-reads).\n+    /// </summary>\n+    /// <returns></returns>\n+    /// <exception cref=\"InvalidOperationException\"></exception>\n+    public ArchiveFile ObtainArchiveFile()\n+    {\n+        if (!_resultSet)\n+        {\n+            throw new InvalidOperationException(\n+                \"ArchiveFile was obtained, but the final edited version was not set.\");\n+        }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This could be a readonly struct. ",
              "createdAt": "2023-10-06T14:02:43Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/CleanupScope.cs",
              "diffHunk": "@@ -0,0 +1,15 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Logging;\n+\n+internal class CleanupScope : IDisposable",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Nice suggestion! Adopted",
              "createdAt": "2023-10-10T19:32:37Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/CleanupScope.cs",
              "diffHunk": "@@ -0,0 +1,15 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Logging;\n+\n+internal class CleanupScope : IDisposable",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Could this be initialized with the value of `BinaryLogRecordKind.ProjectImportArchive` ?",
              "createdAt": "2023-10-06T14:04:40Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/EmbeddedContentKind.cs",
              "diffHunk": "@@ -0,0 +1,17 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    internal enum EmbeddedContentKind\n+    {\n+        Unknown = -1,\n+        ProjectImportArchive = 17,",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Thanks for the tip!\r\nDone",
              "createdAt": "2023-10-10T18:29:28Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/EmbeddedContentKind.cs",
              "diffHunk": "@@ -0,0 +1,17 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    internal enum EmbeddedContentKind\n+    {\n+        Unknown = -1,\n+        ProjectImportArchive = 17,",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would it be worth handling the case where `_position` is 0 and `buffer` is larger than `_buffer`, avoiding the `BlockCopy`?",
              "createdAt": "2023-10-09T11:46:06Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/GreedyBufferedStream.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// This is write-only, append-only stream that always buffers the wrapped stream\n+    /// into the chunks of the same size (except the possible shorter last chunk).\n+    /// So unlike the <see cref=\"BufferedStream\"/> it never writes to the wrapped stream\n+    /// until it has full chunk or is closing.\n+    ///\n+    /// This is not supposed to bring performance benefits, but it allows to avoid nondeterministic\n+    /// GZipStream output for the identical input.\n+    /// </summary>\n+    internal class GreedyBufferedStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private readonly byte[] _buffer;\n+        private int _position;\n+\n+        public GreedyBufferedStream(Stream stream, int bufferSize)\n+        {\n+            _stream = stream;\n+            _buffer = new byte[bufferSize];\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Write(_buffer, 0, _position);\n+            _position = 0;\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count) => throw UnsupportedException;\n+\n+        public override long Seek(long offset, SeekOrigin origin) => throw UnsupportedException;\n+\n+        public override void SetLength(long value) => throw UnsupportedException;\n+\n+        public override void Write(byte[] buffer, int offset, int count)\n+        {\n+            // Appends input to the buffer until it is full - then flushes it to the wrapped stream.\n+            // Repeat above until all input is processed.\n+\n+            int srcOffset = offset;\n+            do\n+            {\n+                int currentCount = Math.Min(count, _buffer.Length - _position);\n+                Buffer.BlockCopy(buffer, srcOffset, _buffer, _position, currentCount);\n+                _position += currentCount;\n+                count -= currentCount;\n+                srcOffset += currentCount;\n+\n+                if (_position == _buffer.Length)\n+                {\n+                    Flush();\n+                }\n+            } while (count > 0);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Removed the class alltogether\r\n(it was needed for the byte-for-byte replay equality - as zipstream needed to receive identical chunks of data - including their size. This stream was supposed to perform the chunking - for this reason writing directly to underlying stream - even for larger writes - was not intended behavior)",
              "createdAt": "2023-10-10T19:38:23Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/GreedyBufferedStream.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// This is write-only, append-only stream that always buffers the wrapped stream\n+    /// into the chunks of the same size (except the possible shorter last chunk).\n+    /// So unlike the <see cref=\"BufferedStream\"/> it never writes to the wrapped stream\n+    /// until it has full chunk or is closing.\n+    ///\n+    /// This is not supposed to bring performance benefits, but it allows to avoid nondeterministic\n+    /// GZipStream output for the identical input.\n+    /// </summary>\n+    internal class GreedyBufferedStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private readonly byte[] _buffer;\n+        private int _position;\n+\n+        public GreedyBufferedStream(Stream stream, int bufferSize)\n+        {\n+            _stream = stream;\n+            _buffer = new byte[bufferSize];\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Write(_buffer, 0, _position);\n+            _position = 0;\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count) => throw UnsupportedException;\n+\n+        public override long Seek(long offset, SeekOrigin origin) => throw UnsupportedException;\n+\n+        public override void SetLength(long value) => throw UnsupportedException;\n+\n+        public override void Write(byte[] buffer, int offset, int count)\n+        {\n+            // Appends input to the buffer until it is full - then flushes it to the wrapped stream.\n+            // Repeat above until all input is processed.\n+\n+            int srcOffset = offset;\n+            do\n+            {\n+                int currentCount = Math.Min(count, _buffer.Length - _position);\n+                Buffer.BlockCopy(buffer, srcOffset, _buffer, _position, currentCount);\n+                _position += currentCount;\n+                count -= currentCount;\n+                srcOffset += currentCount;\n+\n+                if (_position == _buffer.Length)\n+                {\n+                    Flush();\n+                }\n+            } while (count > 0);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think this should rather go into `Dispose`.",
              "createdAt": "2023-10-09T11:52:30Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/GreedyBufferedStream.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// This is write-only, append-only stream that always buffers the wrapped stream\n+    /// into the chunks of the same size (except the possible shorter last chunk).\n+    /// So unlike the <see cref=\"BufferedStream\"/> it never writes to the wrapped stream\n+    /// until it has full chunk or is closing.\n+    ///\n+    /// This is not supposed to bring performance benefits, but it allows to avoid nondeterministic\n+    /// GZipStream output for the identical input.\n+    /// </summary>\n+    internal class GreedyBufferedStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private readonly byte[] _buffer;\n+        private int _position;\n+\n+        public GreedyBufferedStream(Stream stream, int bufferSize)\n+        {\n+            _stream = stream;\n+            _buffer = new byte[bufferSize];\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Write(_buffer, 0, _position);\n+            _position = 0;\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count) => throw UnsupportedException;\n+\n+        public override long Seek(long offset, SeekOrigin origin) => throw UnsupportedException;\n+\n+        public override void SetLength(long value) => throw UnsupportedException;\n+\n+        public override void Write(byte[] buffer, int offset, int count)\n+        {\n+            // Appends input to the buffer until it is full - then flushes it to the wrapped stream.\n+            // Repeat above until all input is processed.\n+\n+            int srcOffset = offset;\n+            do\n+            {\n+                int currentCount = Math.Min(count, _buffer.Length - _position);\n+                Buffer.BlockCopy(buffer, srcOffset, _buffer, _position, currentCount);\n+                _position += currentCount;\n+                count -= currentCount;\n+                srcOffset += currentCount;\n+\n+                if (_position == _buffer.Length)\n+                {\n+                    Flush();\n+                }\n+            } while (count > 0);\n+        }\n+\n+        public override bool CanRead => false;\n+        public override bool CanSeek => false;\n+        public override bool CanWrite => _stream.CanWrite;\n+        public override long Length => _stream.Length + _position;\n+\n+        public override long Position\n+        {\n+            get => _stream.Position + _position;\n+            set => throw UnsupportedException;\n+        }\n+\n+        public override void Close()\n+        {\n+            Flush();\n+            _stream.Close();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "The base `Close` is documented to call `Dispose`.",
              "createdAt": "2023-10-09T11:52:54Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/GreedyBufferedStream.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// This is write-only, append-only stream that always buffers the wrapped stream\n+    /// into the chunks of the same size (except the possible shorter last chunk).\n+    /// So unlike the <see cref=\"BufferedStream\"/> it never writes to the wrapped stream\n+    /// until it has full chunk or is closing.\n+    ///\n+    /// This is not supposed to bring performance benefits, but it allows to avoid nondeterministic\n+    /// GZipStream output for the identical input.\n+    /// </summary>\n+    internal class GreedyBufferedStream : Stream\n+    {\n+        private readonly Stream _stream;\n+        private readonly byte[] _buffer;\n+        private int _position;\n+\n+        public GreedyBufferedStream(Stream stream, int bufferSize)\n+        {\n+            _stream = stream;\n+            _buffer = new byte[bufferSize];\n+        }\n+\n+        public override void Flush()\n+        {\n+            _stream.Write(_buffer, 0, _position);\n+            _position = 0;\n+        }\n+\n+        public override int Read(byte[] buffer, int offset, int count) => throw UnsupportedException;\n+\n+        public override long Seek(long offset, SeekOrigin origin) => throw UnsupportedException;\n+\n+        public override void SetLength(long value) => throw UnsupportedException;\n+\n+        public override void Write(byte[] buffer, int offset, int count)\n+        {\n+            // Appends input to the buffer until it is full - then flushes it to the wrapped stream.\n+            // Repeat above until all input is processed.\n+\n+            int srcOffset = offset;\n+            do\n+            {\n+                int currentCount = Math.Min(count, _buffer.Length - _position);\n+                Buffer.BlockCopy(buffer, srcOffset, _buffer, _position, currentCount);\n+                _position += currentCount;\n+                count -= currentCount;\n+                srcOffset += currentCount;\n+\n+                if (_position == _buffer.Length)\n+                {\n+                    Flush();\n+                }\n+            } while (count > 0);\n+        }\n+\n+        public override bool CanRead => false;\n+        public override bool CanSeek => false;\n+        public override bool CanWrite => _stream.CanWrite;\n+        public override long Length => _stream.Length + _position;\n+\n+        public override long Position\n+        {\n+            get => _stream.Position + _position;\n+            set => throw UnsupportedException;\n+        }\n+\n+        public override void Close()\n+        {\n+            Flush();\n+            _stream.Close();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: It may be just my understanding of the word but the implementation doesn't quite match what I would consider a 'greedy' behavior. `DeterministicallyBufferedStream`, `ConstantBufferStream`, `ChunkedBufferStream`, `ChunkBufferedStream`?",
              "createdAt": "2023-10-09T11:57:12Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/GreedyBufferedStream.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// This is write-only, append-only stream that always buffers the wrapped stream\n+    /// into the chunks of the same size (except the possible shorter last chunk).\n+    /// So unlike the <see cref=\"BufferedStream\"/> it never writes to the wrapped stream\n+    /// until it has full chunk or is closing.\n+    ///\n+    /// This is not supposed to bring performance benefits, but it allows to avoid nondeterministic\n+    /// GZipStream output for the identical input.\n+    /// </summary>\n+    internal class GreedyBufferedStream : Stream",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Right - correct!\r\nThough - removed now for simplicity :-)",
              "createdAt": "2023-10-10T19:39:00Z",
              "path": "src/Build/Logging/BinaryLogger/Postprocessing/GreedyBufferedStream.cs",
              "diffHunk": "@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+\n+namespace Microsoft.Build.Logging\n+{\n+    /// <summary>\n+    /// This is write-only, append-only stream that always buffers the wrapped stream\n+    /// into the chunks of the same size (except the possible shorter last chunk).\n+    /// So unlike the <see cref=\"BufferedStream\"/> it never writes to the wrapped stream\n+    /// until it has full chunk or is closing.\n+    ///\n+    /// This is not supposed to bring performance benefits, but it allows to avoid nondeterministic\n+    /// GZipStream output for the identical input.\n+    /// </summary>\n+    internal class GreedyBufferedStream : Stream",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\*.cs\" />\r\n```",
              "createdAt": "2023-10-09T13:04:44Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -164,10 +164,21 @@\n     <Compile Include=\"BackEnd\\Components\\SdkResolution\\TranslationHelpers.cs\" />\n     <Compile Include=\"FileSystem\\*.cs\" />\n     <Compile Include=\"Evaluation\\IItemTypeDefinition.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\ArchiveFile.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\ArchiveFileEventArgs.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\ArchiveFileEventArgsExtensions.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\CleanupScope.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\EmbeddedContentEventArgs.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\EmbeddedContentKind.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\EmbeddedContentKindExtensions.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\GreedyBufferedStream.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\IBuildEventArgsReaderNotifications.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\IBuildEventStringsReader.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\IBuildFileReader.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\IEmbeddedContentSource.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\StringReadEventArgs.cs\" />\n+    <Compile Include=\"Logging\\BinaryLogger\\Postprocessing\\SubStream.cs\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Typo: MSBUILDDETER**MN**ISTICBINLOG",
              "createdAt": "2023-10-09T13:05:32Z",
              "path": "src/Framework/Traits.cs",
              "diffHunk": "@@ -120,6 +120,12 @@ public Traits()\n         /// </summary>\n         public readonly int LogPropertyTracking = ParseIntFromEnvironmentVariableOrDefault(\"MsBuildLogPropertyTracking\", 0); // Default to logging nothing via the property tracker.\n \n+        /// <summary>\n+        /// Turn on greedy buffering stream decorator for binlog writer.\n+        /// This will ensure that 2 identical binlog contents will result into identical binlog files (as writing different chunks to GZipStream can lead to different result).\n+        /// </summary>\n+        public readonly bool DeterministicBinlogStreamBuffering = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDDETERMNISTICBINLOG\"));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Removed alltogether",
              "createdAt": "2023-10-10T19:42:27Z",
              "path": "src/Framework/Traits.cs",
              "diffHunk": "@@ -120,6 +120,12 @@ public Traits()\n         /// </summary>\n         public readonly int LogPropertyTracking = ParseIntFromEnvironmentVariableOrDefault(\"MsBuildLogPropertyTracking\", 0); // Default to logging nothing via the property tracker.\n \n+        /// <summary>\n+        /// Turn on greedy buffering stream decorator for binlog writer.\n+        /// This will ensure that 2 identical binlog contents will result into identical binlog files (as writing different chunks to GZipStream can lead to different result).\n+        /// </summary>\n+        public readonly bool DeterministicBinlogStreamBuffering = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDDETERMNISTICBINLOG\"));",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Taking and returning `Action` looks like an avoidable indirection. Why not add a local function to `AddFileHelper` with the try/catch and just call it from the two call sites?",
              "createdAt": "2023-10-09T13:09:58Z",
              "path": "src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs",
              "diffHunk": "@@ -69,50 +72,72 @@ public ProjectImportsCollector(string logFilePath, bool createFile, string sourc\n                 _fileStream = null;\n                 _zipArchive = null;\n             }\n+            _runOnBackground = runOnBackground;\n+        }\n+\n+        public void AddFile(string? filePath)\n+        {\n+            AddFileHelper(filePath, AddFileCore);\n         }\n \n-        public void AddFile(string filePath)\n+        public void AddFileFromMemory(\n+            string? filePath,\n+            string data,\n+            Encoding? encoding = null,\n+            DateTimeOffset? entryCreationStamp = null,\n+            bool makePathAbsolute = true)\n+        {\n+            AddFileHelper(filePath, path =>\n+                AddFileFromMemoryCore(path, data, encoding ?? Encoding.UTF8, makePathAbsolute, entryCreationStamp));\n+        }\n+\n+        public void AddFileFromMemory(\n+            string? filePath,\n+            Stream data,\n+            DateTimeOffset? entryCreationStamp = null,\n+            bool makePathAbsolute = true)\n+        {\n+            AddFileHelper(filePath, path => AddFileFromMemoryCore(path, data, makePathAbsolute, entryCreationStamp));\n+        }\n+\n+        private void AddFileHelper(\n+            string? filePath,\n+            Action<string> addFileWorker)\n         {\n             if (filePath != null && _fileStream != null)\n             {\n+                Action addFileAction = WrapWithExceptionSwallowing(() => addFileWorker(filePath));\n+\n                 lock (_fileStream)\n                 {\n-                    // enqueue the task to add a file and return quickly\n-                    // to avoid holding up the current thread\n-                    _currentTask = _currentTask.ContinueWith(t =>\n+                    if (_runOnBackground)\n+                    {\n+                        // enqueue the task to add a file and return quickly\n+                        // to avoid holding up the current thread\n+                        _currentTask = _currentTask.ContinueWith(\n+                            t => { addFileAction(); },\n+                            TaskScheduler.Default);\n+                    }\n+                    else\n                     {\n-                        try\n-                        {\n-                            AddFileCore(filePath);\n-                        }\n-                        catch\n-                        {\n-                        }\n-                    }, TaskScheduler.Default);\n+                        addFileAction();\n+                    }\n                 }\n             }\n         }\n \n-        public void AddFileFromMemory(string filePath, string data)\n+        private Action WrapWithExceptionSwallowing(Action action)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}