{
  "number": 7484,
  "title": "Log environment-derived properties",
  "body": "### Context\r\nWe currently log all environment variables, which is useful in giving you a sense of where things come from sometimes but doesn't really tell you if those environment variables are used or what other environment variables we might have expected. This shifts to logging only those environment variables we actually used. This also partially mitigates potential privacy issues, as random environment variables with secrets aren't logged unless they happen to correspond to something MSBuild actually uses during the build.\r\n\r\n### Changes Made\r\nKeep track of environment variable usages for looking at properties. Log those in the binlog instead of all environment variables.\r\n\r\nMore specifically, we'd previously kept track of environment-derived properties under more generic types such as ProjectPropertyNotXmlBacked. I added an extension specifically for environment-derived properties. That derived class keeps track of relatively few new things: logging context and whether it's been logged already. In some cases, that logging context is up-to-date; in others, it's invalidated before we could use it, in which case we replace it with the correct logging context as brought forward from wherever we actually had one.\r\n\r\nWith the logging context and information about the property, once we know we need to log it, we log an EnvironmentVariableRead build event. With this change, that event is now properly serialized to the main node, where it is outputted to the binlog and text logs.\r\n\r\nThe binlog viewer was also modified to better accommodate the EnvironmentVariableRead events.\r\n\r\nFinally, the binlog writer was modified such that, unless you specify that you should log all environment variables, it would not output the environment for BuildStarted. I made a similar change for the text logger. I also filtered which properties made it to the event args to weed out environment-derived properties.\r\n\r\n### Testing\r\nVerified that environment variables are not logged in the binlog by default. Verified that they are logged if they are used. (Also checked the text logs for both.) Modified some unit tests and added one.\r\n\r\n### Notes\r\nIt seems that all environment-derived properties used in execution go through [this method](https://github.com/dotnet/msbuild/blob/cd75d014831860da851c61853521fb0b0d9ba63e/src/Build/Evaluation/Expander.cs#L1467). Ideally, that would make this PR tiny: log at that point rather that an BuildStarted. However, there is no single logging context possible at that point, which meant that was brought in from the various ways properties could be used.",
  "state": "MERGED",
  "createdAt": "2022-03-23T15:57:30Z",
  "updatedAt": "2022-06-15T20:00:08Z",
  "closedAt": "2022-06-15T17:11:35Z",
  "mergedAt": "2022-06-15T17:11:35Z",
  "additions": 589,
  "deletions": 303,
  "changedFiles": 59,
  "headRefName": "log-env-var-properties",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "c7e5c0a46d5795461b6f254f8c127f71adb6b64a",
          "message": "Log environment variables read as properties",
          "committedDate": "2022-03-22T23:06:41Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "418b210dafd258d4b5432c1db4c9a0c3f499f3f9",
          "message": "Only log random environment variables if asked\n\nThis is both a privacy issue and a waste from a performance perspective.",
          "committedDate": "2022-03-23T15:54:46Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fb96241a71ef5d66fb652ce5c226977439350634",
          "message": "Don't write a full (empty) dictionary",
          "committedDate": "2022-03-23T17:27:29Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cf9c72290c06429b9dde62a0b1b34347355a788c",
          "message": "Only log nonempty env vars",
          "committedDate": "2022-03-23T21:01:51Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d7c03b2b98587e60ba51d168c6deef8e08ce79aa",
          "message": "Fix NRE",
          "committedDate": "2022-03-23T21:46:01Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5b58243448962877fb84d2c31d44fe6005a00f28",
          "message": "Make tests pass",
          "committedDate": "2022-03-23T23:04:49Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fdee1138759322169182e1dd1e29764ccdcd25ff",
          "message": "Only find environment properties",
          "committedDate": "2022-03-28T22:47:21Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "be584ed98c109853ad74fefa08aa6aab918ee238",
          "message": "PR comments",
          "committedDate": "2022-03-29T00:05:03Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "16332a7061392f4403fe6aadff319be0db514ca9",
          "message": "Log on first property read",
          "committedDate": "2022-03-30T23:36:32Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2a749b8bc1795d5911145034d57e691b5d49bfcd",
          "message": "Account for prior logging and EvaluationFinished",
          "committedDate": "2022-04-01T21:30:52Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "150a4424376044e282c57c52fb253a6ae7991508",
          "message": "Tweak tests",
          "committedDate": "2022-04-04T18:34:02Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dfe55d728503706abec9b83c6cdc8e7013c53221",
          "message": "Random cleanup",
          "committedDate": "2022-04-07T18:02:23Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb51b1fa2952d18111b14a346b8842f0662c17e8",
          "message": "Make it work across nodes",
          "committedDate": "2022-04-07T18:20:41Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "133f760db7a6a581fdcc0606dba558fba916f92e",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild into log-env-var-properties",
          "committedDate": "2022-04-08T00:22:37Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "775a20de09f4448f99d981af5b7a2edf0919ec73",
          "message": "EnvironmentVariableReadEventArgs serialization\n\nIt can't serialize itself, currently.",
          "committedDate": "2022-04-08T00:27:49Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2fc3b004decfa1cd2f231a1886f33e50ec22db85",
          "message": "Self comments",
          "committedDate": "2022-04-11T23:58:37Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4c0f001c6f1a2c16c1ca6683e19c3e83f14b01c8",
          "message": "PR comments",
          "committedDate": "2022-04-13T17:21:38Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "30cb0e1365764f67ea35cd2adfa5d8624921f1da",
          "message": "Remove IProperty.IsEnvironmentProperty",
          "committedDate": "2022-04-13T21:28:37Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d13ef4433589b043a49912402bc30ab04ed590b6",
          "message": "Reduce allocations in mainline case",
          "committedDate": "2022-04-14T20:29:01Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "01d33625bda90f082d09c357ed00a93ac03054de",
          "message": "Break up long line",
          "committedDate": "2022-04-15T19:03:12Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "75dc9dd85d91cec776f20ebb7f3c3003289f7325",
          "message": "Make text log align with binlog",
          "committedDate": "2022-04-18T22:14:41Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7914d878e52d4b778714c3e25d9f72856d930d88",
          "message": "PR feedback",
          "committedDate": "2022-04-26T23:46:46Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "47d80f67daa8d46dbd51863566ee6d341d51ff65",
          "message": "Filter from ProjectStarted",
          "committedDate": "2022-04-27T00:01:45Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fff4f97d9826cd2518d93411129c1003cd1565b0",
          "message": "Add test",
          "committedDate": "2022-04-27T23:06:27Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9fb427c392e287fd0110ca12905b9936bcff42ca",
          "message": "merge",
          "committedDate": "2022-04-27T23:16:00Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0b830e52ed81f5e7aa9e1a73f86f7c42da99a25a",
          "message": "Reorder usings\n\nThis is the correct order according to VS. It failed when I had them in a different order.",
          "committedDate": "2022-04-28T23:38:56Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c2b93b958bd914e829facaa4677678b37b6bd631",
          "message": "Make list instead of yield returning\n\nI think this yield return might be modifying the PropertyDictionary or something?",
          "committedDate": "2022-04-29T00:12:25Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d1cad7b2b5aa8371d3410f5ce24ce8e136dda0f2",
          "message": "Remove expectation of file\n\n_env.ExpectFile(\".binlog\").Path means every test in this file would have to make a binlog in the folder without an interesting name. That's too restraining.",
          "committedDate": "2022-04-29T00:36:14Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d4c2f060c887c6fc983ee6dce1fbff7e1f0e0fd5",
          "message": "Use log file instead",
          "committedDate": "2022-04-29T00:38:10Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "add1258fd7ce2246d39f9b07ea1f6529ae9d5198",
          "message": "Update src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs",
          "committedDate": "2022-04-29T22:13:32Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "679c0034b692c1157ede472feb084fcbf602d026",
          "message": "Notice env properties accessed in tasks",
          "committedDate": "2022-05-10T21:44:32Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aa466612a1cf7514800d84e73d1501ace7982fa1",
          "message": "PR comments",
          "committedDate": "2022-05-10T22:19:41Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ce8dad44473498909e69e0ee83b8a87525ac8a21",
          "message": "Account for more cases",
          "committedDate": "2022-05-14T00:01:50Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "01ee110a5363b3dc9f011e9f68474290477c19dd",
          "message": "One more case",
          "committedDate": "2022-05-14T00:26:46Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ad9232378a5b9a3749a753982ccda222b358ab74",
          "message": "Fix another case",
          "committedDate": "2022-05-16T18:15:48Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0316ba7c63e9c0971e60146a54138baed1934a04",
          "message": "Fix condition on task execution",
          "committedDate": "2022-05-17T20:48:10Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "44aa9b660da4baec4b252a37cfabff32e214bd21",
          "message": "Fixed other cases mentioned in PR",
          "committedDate": "2022-05-17T21:51:37Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f7ccf3d4a7308a20604b795e33b7e682d4cd5bfa",
          "message": "PR comments",
          "committedDate": "2022-05-27T17:54:41Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "22525b63efacc65aab8d3a52aac116b351b725f0",
          "message": "Using statement",
          "committedDate": "2022-05-31T17:45:56Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@Forgind @KirillOsenkov We should chat offline about this change. I had thought that Kirill wanted to know which environment variables were used in the build so we could hide the rest from the binlogs.  This PR appears to log whenever an environment property is used which is somewhat different. It also does it by checking for an existing environment variable every time a property is accessed so I'd expect there to be perf implications.\r\n\r\nSince every environment variable is converted to a property, shouldn't we just record the initial list at that time and so we won't have to call GetEnvironmentVariable later? Rainer also mentioned that there was code that sort of did this already but had perf issues so it might be better to track down that code and see if the perf issues can be resolved.",
        "createdAt": "2022-03-23T18:58:36Z",
        "author": {
          "login": "marcpopMSFT"
        }
      },
      {
        "body": "The prior art in this area is around dotnet/msbuild#3432, which moved forward with dotnet/msbuild#5038 but isn't finished. Would it be possible to pick that up instead?",
        "createdAt": "2022-03-23T19:24:04Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "This keeps track of which environment variables were used _as properties_ in the build and (by default) hides the rest from binlogs. It isn't actually logging anything when an environment property is used, just putting that in a dictionary that we log once with BuildFinishedEventArgs(2). I do access and environment variable every time I add it to the dictionary, but that part is just an implementation detail; I can get the (possibly but probably not stale) value from a dictionary full of environment variables instead.\r\n\r\nWe don't have an initial list of properties that will be read as environment variables. All we have is which end up being read as environment variables, as you see here. The previous environment variable logging didn't care about which were actually used and just logged everything.\r\n\r\nI am aware of that issue and PR. The PR was ultimately reverted because of performance issues. It's a big change that does more than this PR attempts. I'd also have to look into which RPS tests it failed, try to recreate them, analyze what went wrong from a performance perspective, and try to fix it. It's fully possible in my mind that at the end of that, it may be impossible to truly fix that PR without losing functionality. This is a much more scoped PR that accomplishes the most important part of maneely's PR without taking weeks. So I'd really rather not pick up #5038 and just try to optimize it.",
        "createdAt": "2022-03-23T19:32:28Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Add environment variables to text log (replace missing ones)",
        "createdAt": "2022-03-23T20:38:39Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "My main concern is that we know that this has been tried before and had problematic performance impact. There are also a few different ways of solving this. So I think it's worth having design discussion on what the goal is.\r\n\r\nOpen questions in my mind:\r\n\r\n- Should this be opt in to limit perf impact?\r\n- Can we record the initial list of env variables so we aren't calling Environment.Get... every time.\r\n- Should we include a bool on the property object on whether it was used or not and merge with the environment list at the end once?\r\n- Is there value in sharing with customers what properties aren't used that aren't environment variables (to clean up project files perhaps though there is risk that a property would get used with slightly different build params)?",
        "createdAt": "2022-03-24T18:15:57Z",
        "author": {
          "login": "marcpopMSFT"
        }
      },
      {
        "body": "The previous approach logged a few event args, such as EnvironmentVariableReadEventArgs, etc. It was expensive because of logging all these extra args messages.\r\n\r\nThis approach is much more targeted and from what I saw the perf impact should be negligible (we should measure however).\r\n\r\nWe should be careful about adding fields on a class that is potentially instantiated millions of times.\r\n\r\nTracking used properties in general I think should be separate from this PR. Here we just want the minimum surgical fix to track and log only the environment variables that were actually used. Everything else I think should be out of scope.",
        "createdAt": "2022-03-24T18:24:10Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "We should also add a unit-test that builds this project and ensures that BuildStarted has no environment variables, and BuildFinished has a single environment variable OS=Windows_NT (only assert the name, not the value as it may change on other OSs)\r\n\r\n```\r\n<Project>\r\n\r\n  <PropertyGroup>\r\n    <A>$(OS)</A>\r\n  </PropertyGroup>\r\n\r\n  <Target Name=\"Build\">\r\n    <Message Text=\"$(A)\" />\r\n  </Target>\r\n  \r\n</Project>\r\n```",
        "createdAt": "2022-03-28T18:40:32Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Along with my PR in the structured log viewer, it currently looks like this:\r\n<img width=\"658\" alt=\"image\" src=\"https://user-images.githubusercontent.com/12969783/162340151-aa95025d-c497-4e6a-9ed6-7758995d4d0c.png\">\r\n",
        "createdAt": "2022-04-08T00:28:13Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Text log was apparently unaffected.",
        "createdAt": "2022-04-18T21:32:36Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I've just realized one important thing: we're still logging the environment-backed properties either on `ProjectEvaluationFinished` or on `ProjectStarted` (if legacy). \r\n\r\nWhen we are logging properties we should be filtering out environment-backed properties unless they were read.\r\n\r\nOtherwise it defeats the purpose of not logging the environment! Good news is that as a side effect this will significantly reduce the amount of properties logged and reduce noise.",
        "createdAt": "2022-04-26T02:27:58Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Here for ProjectEvaluationFinished:\r\nhttps://github.com/dotnet/msbuild/blob/cff0b1f269303530cf8c32630586eeb1108f8a93/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs#L546\r\n\r\n(or rather here to be precise):\r\nhttps://github.com/dotnet/msbuild/blob/cff0b1f269303530cf8c32630586eeb1108f8a93/src/Build/Evaluation/Evaluator.cs#L814\r\n\r\nAnd here for the legacy case on ProjectStarted:\r\nhttps://github.com/dotnet/msbuild/blob/cff0b1f269303530cf8c32630586eeb1108f8a93/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs#L103\r\n\r\nUgh, this is getting gnarly. Need to be very careful here to not lose safety and performance when iterating and filtering.",
        "createdAt": "2022-04-26T02:30:07Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Ugh, ignore everything I wrote below, I got confused. 6704 is about items, not properties. Don't think we have the same problem for properties.\r\n\r\n> On the plus side, this may be our opportunity to also fix https://github.com/dotnet/msbuild/issues/6704\r\n> \r\n> If we're going to force iterate all properties [here](https://github.com/dotnet/msbuild/blob/cff0b1f269303530cf8c32630586eeb1108f8a93/src/Build/Evaluation/Evaluator.cs#L814), we will incur allocations, but on the plus side it will fix the subtle race condition from #6704\r\n> \r\n> Otherwise the problem was that we passed the pointer to the original collection to the node packet translator, that asynchronously (after a while and on another thread) serialized the properties to pass them to the central node. At the time the collection was iterated, its contents might have had changed already since the moment we created the event args.\r\n> \r\n> Would be super nice to have true immutable collections here, such that we can take a snapshot of the properties at the exact moment and not worry about them changing. We could also safely iterate to filter out the unused environment properties.",
        "createdAt": "2022-04-26T02:53:41Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "We are also probably missing a negative test that validates that an environment variable not used by the build is not present anywhere in the log.",
        "createdAt": "2022-04-26T03:00:05Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I pushed the first part with ProjectEvaluationFinished\u2014an important catch. I was less sure about the second part, so I put it in a second commit. I can try to add the test tomorrow. What were you thinking for that? The best test would be making a binlog and making sure an environment variable doesn't appear, but that's hard with binary. Replay the binlog and make sure ProjectStarted and ProjectEvaluationFinished don't have it? That doesn't seem as robust if there are more events we haven't fixed yet.",
        "createdAt": "2022-04-27T00:04:12Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "we could playback the binlog into text and ensure the env var doesn\u2019t appear in the text",
        "createdAt": "2022-04-27T20:47:00Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2022-04-28T23:28:27Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2022-04-28T23:28:36Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "I'm seeing another problem. For some reason I'm not seeing the EnvironmentVariableRead message emitted when the variable is read during target execution:\r\n\r\n```\r\n  <Target Name=\"Foo\" BeforeTargets=\"BeforeBuild\">\r\n    <Message Text=\"$(ComSpec)\" />\r\n  </Target>\r\n```\r\n\r\nIf you build this, there will be no record of ComSpec being read. We should also add a test for this scenario.",
        "createdAt": "2022-05-04T00:36:30Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Could it be that during execution it calls `EvaluatedValue` and bypasses our logic to emit the event?\r\nhttps://github.com/dotnet/msbuild/blob/43e2af40c5345094a8069c3c53d36c152e00bfcd/src/Build/Definition/ProjectProperty.cs#L82\r\n\r\nFeels like we should have a central single point of being \"read\" that all accesses go through, not just the `EvaluatedValueEscaped`.",
        "createdAt": "2022-05-04T00:45:07Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I also made a viewer change to list all the used environment variables under the Environment folder:\r\n\r\n![image](https://user-images.githubusercontent.com/679326/166610360-d237d4fc-0460-4ca2-bd0a-c2476e38bd58.png)\r\n",
        "createdAt": "2022-05-04T01:02:58Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "In terms of perf, binlog size didn't seem to noticeably change, and (maybe a fluke) perf improved very slightly by not logging all env vars:\r\n\r\n```\r\nNew default:\r\n============\r\n\r\nBinlog size:\r\n3888\r\n3903\r\n3930\r\n3917\r\n\r\nBuild time:\r\n10.395\r\n11.113\r\n10.450\r\n11.208\r\n11.131\r\nAverage: 10.859 s\r\n\r\nAll env vars trait:\r\n===================\r\n\r\nBinlog size:\r\n3912\r\n3902\r\n3897\r\n\r\nBuild time:\r\n10.913\r\n10.917\r\n10.605\r\n11.570\r\n11.390\r\nAverage: 11.079 s\r\n```\r\n\r\nThis is all highly non-scientific of course, but still a data point. This for for a fully incremental single-proc build, where almost no tasks were running (other than RAR and a few small other ones). So mostly measures MSBuild overhead.",
        "createdAt": "2022-05-04T01:24:22Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "> I'm seeing another problem. For some reason I'm not seeing the EnvironmentVariableRead message emitted when the variable is read during target execution:\r\n> \r\n> ```\r\n>   <Target Name=\"Foo\" BeforeTargets=\"BeforeBuild\">\r\n>     <Message Text=\"$(ComSpec)\" />\r\n>   </Target>\r\n> ```\r\n> \r\n> If you build this, there will be no record of ComSpec being read. We should also add a test for this scenario.\r\n\r\nThis was entirely too complicated, but I think I got it to work. It seems to have been added statically in Utilities when we accessed all environment variables, but at that point, there was no logging context to use. Then we re-added it at evaluate time, which meant it had the context from evaluate. On the other hand, we couldn't use that loggingContext because we didn't know yet if it would be accessed in the future, and we wouldn't know until we were executing tasks, at which point the evaluation logging context was gone == invalid. That's why it wasn't being logged. It was still being accessed via EvaluatedValueEscaped, so I threaded the targetLoggingContext through to the call point and used that after checking if something was an EnvironmentDerivedProjectPropertyInstance.",
        "createdAt": "2022-05-10T21:49:35Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> We should also add a test for this scenario.\r\n\r\nFunny story: I had one: UnusedEnvironmentVariablesDoNotAppearInBinaryLog. It started failing after I made the first change. As far as I can tell, it _should_ have been failing all along. Very weird.",
        "createdAt": "2022-05-10T22:58:50Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Sorry that I keep finding issues. Turns out that this area is super complicated (as always, MSBuild).\r\n\r\n```\r\n<Project>\r\n\r\n  <Target Name=\"Build\" DependsOnTargets=\"$(OS)\">\r\n  </Target>\r\n\r\n  <Target Name=\"Windows_NT\">\r\n  </Target>\r\n  \r\n</Project>\r\n```\r\n\r\nWhen building this project I expect the usage of the environment variable `OS` to get logged.",
        "createdAt": "2022-05-11T01:41:00Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Another one:\r\n\r\n```\r\n<Project>\r\n\r\n  <Target Name=\"Build\" Condition=\"$(OS) != ''\">\r\n  </Target>\r\n  \r\n</Project>\r\n```\r\n\r\nBasically we need to check all places properties can be read: `Condition`, `BeforeTargets`, `AfterTargets`, `DependsOnTargets`, maybe check task parameters, item names, expressions. The surface area is huge, it turns out :(",
        "createdAt": "2022-05-11T01:43:26Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Yeah, this doesn't report the env var read either:\r\n\r\n```\r\n<Import Project=\"$(OS)\" />\r\n```",
        "createdAt": "2022-05-11T01:46:42Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "We need to find a place that all of these code paths are going through and place the reporting logic there, I think.\r\n\r\nI'm sorry I had no idea this is going to snowball into such a huge thing. I totally thought we just need to add a wrapper in one place.\r\n\r\nNow I'm super curious whether the (disabled) https://github.com/dotnet/msbuild/pull/5038 deals with all these cases correctly or not.",
        "createdAt": "2022-05-11T01:52:48Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "For reference, a bunch of related PRs and issues:\r\nhttps://github.com/dotnet/msbuild/issues/3432\r\nhttps://github.com/dotnet/msbuild/pull/4437\r\nhttps://github.com/dotnet/msbuild/pull/4461\r\nhttps://github.com/dotnet/msbuild/pull/4939\r\nhttps://github.com/dotnet/msbuild/pull/5038",
        "createdAt": "2022-05-11T01:54:07Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "For all the little snippets I'm pasting above we should have tests. Let's also brainstorm other similar scenarios to make sure we're logging it all comprehensively. \r\n\r\nIt would be quite bad if we used an environment variable and didn't report it. Can cause people a lot of grief.",
        "createdAt": "2022-05-11T01:55:33Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "> Sorry that I keep finding issues. Turns out that this area is super complicated (as always, MSBuild).\r\n> \r\n> ```\r\n> <Project>\r\n> \r\n>   <Target Name=\"Build\" DependsOnTargets=\"$(OS)\">\r\n>   </Target>\r\n> \r\n>   <Target Name=\"Windows_NT\">\r\n>   </Target>\r\n>   \r\n> </Project>\r\n> ```\r\n> \r\n> When building this project I expect the usage of the environment variable `OS` to get logged.\r\n\r\nIt's good to find every way this can go wrong! But also, do people really do that? Looks like a disaster waiting to happen to me. Still, I'll see if I can plumb it through.\r\n\r\n> We need to find a place that all of these code paths are going through and place the reporting logic there, I think.\r\n\r\nI found one pretty early on in this process: Expander.LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties). The only problem is that Expander doesn't have an associated logging context, so we can reach that point, see an EnvironmentDerivedProjectPropertyInstance or whatever, and _not log it_ because even though it has an associated logging context, that logging context is no longer valid. (It can also just be null.) Unfortunately, it makes sense for logging contexts to not be valid at some point, which means we need to update them if we can.",
        "createdAt": "2022-05-11T21:04:29Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Have we investigated this avenue?\r\nhttps://github.com/dotnet/msbuild/pull/7484#issuecomment-1116836721\r\n\r\nBasically I think we inserted logging into EvaluatedValueEscaped, but not EvaluatedValue. Could it be that this is the missing codepath?\r\n",
        "createdAt": "2022-05-11T23:32:45Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I looked into EvaluatedValue vs. EvaluatedValueEscaped a while ago, and everything looked like it went through EvaluatedValueEscaped. So far, when I've tested scenarios you've proposed, they've all gone through EvaluatedValueEscaped.",
        "createdAt": "2022-05-12T00:08:52Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I know it looks awful threading logging context everywhere, but I was thinking: maybe ultimately it's the right thing to do? We want to be able to log from all evaluation locations, so in the future when we want to add more logging messages perhaps it should come in handy?\r\n\r\nRemember that until recently we weren't able to log anything from evaluation at all, so perhaps consider this trailblazing for future generations.",
        "createdAt": "2022-05-14T00:15:09Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Hmm, in my testing it didn't log the `OS` variable here:\r\n\r\n```\r\n<Project>\r\n\r\n  <PropertyGroup Condition=\"$(OS) == 'Windows_NT'\">\r\n    <A>$(UserProfile)</A>\r\n  </PropertyGroup>\r\n\r\n  <Target Name=\"Build\">\r\n    <Message Text=\"$(A)\" />\r\n  </Target>\r\n\r\n</Project>\r\n```",
        "createdAt": "2022-05-16T01:02:21Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I'm afraid we're going to need tests for all these usage scenarios (e.g. Condition on property groups).\r\n\r\nI'm also still worried about the `EvaluatedValue` property - how come it's never accessed? Would be nice to place a breakpoint and see if this is ever hit during either a real-world build or a full test run. The worry is that there's a way to bypass the logging of environment variables if we access through that property - I want to know if it's at all possible.",
        "createdAt": "2022-05-16T01:05:07Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Interesting...I just tested it, and it logged the EnvVar variable in \r\n\r\n> Hmm, in my testing it didn't log the `OS` variable here:\r\n> \r\n> ```\r\n> <Project>\r\n> \r\n>   <PropertyGroup Condition=\"$(OS) == 'Windows_NT'\">\r\n>     <A>$(UserProfile)</A>\r\n>   </PropertyGroup>\r\n> \r\n>   <Target Name=\"Build\">\r\n>     <Message Text=\"$(A)\" />\r\n>   </Target>\r\n> \r\n> </Project>\r\n> ```\r\n\r\nFixed this case. I'd foolishly thought a condition on a target might be the same as a condition on a propertygroup. I'll check a couple other places.",
        "createdAt": "2022-05-16T18:16:50Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I re-did the perf measurements and was a bit surprised (pleasantly). Could totally be a fluke, but this PR seems slightly faster than baseline and also produces smaller binlogs.\r\n\r\n\u00a0 | Baseline: | This PR:\r\n-- | -- | --\r\n\u00a0 | 8.828 | 9.079\r\n\u00a0 | 9.204 | 8.448\r\n\u00a0 | 9.875 | 9.471\r\n\u00a0 | 9.114 | 8.066\r\n\u00a0 | 10.119 | 7.928\r\n\u00a0 | 8.6 | 7.809\r\n\u00a0 | 8.566 | 8.238\r\n\u00a0 | 8.781 | 8.799\r\n\u00a0 | 8.615 | 8.14\r\nAverage: | 9.078 | 8.442\r\n\r\nBinlog size goes down slightly from 5.137 MB -> 5.058 MB.\r\n\r\nI'm guessing this is because we don't log the properties that came from the environment so those huge property lists are now way smaller.\r\n\r\n![image](https://user-images.githubusercontent.com/679326/169578900-3f121b55-fc88-4f4f-a614-a7db5f782899.png)\r\n",
        "createdAt": "2022-05-20T17:14:04Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@KirillOsenkov, what project did you do the perf testing on? I'm curious if there might be a difference between a big project and a smaller one, or perhaps between frameworks/OSs/etc.",
        "createdAt": "2022-06-01T21:42:35Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I only did a ~270KLOC project on Windows with ~40 projects, fully incremental build. Didn't do much more than that.",
        "createdAt": "2022-06-02T00:27:01Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I did some testing for a clean build of a small console app. With this change, it was 5ms slower on average (so easily within standard deviation), and the binlogs were about 2kb smaller.",
        "createdAt": "2022-06-02T23:35:37Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Awesome!!! Congrats everyone! Huge thanks Nathan!\r\n\r\nDo we know which release this should ship in?",
        "createdAt": "2022-06-15T19:59:01Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Unless something goes wrong, this should be in 17.3 preview 3.",
        "createdAt": "2022-06-15T20:00:07Z",
        "author": {
          "login": "rainersigwald"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "maybe use pattern-matching here",
              "createdAt": "2022-03-28T05:32:40Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1470,6 +1470,10 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n+                if (!string.IsNullOrEmpty(property?.EvaluatedValue))",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Hmm, I am confused, this seems to just make a list of all properties ever read? We only need the properties that were resolved to an environment variable. I would imagine that we track it somewhere close to where we take a snapshot of the environment at the start of the build?",
              "createdAt": "2022-03-28T05:44:27Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1470,6 +1470,10 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n+                if (!string.IsNullOrEmpty(property?.EvaluatedValue))",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Also I think we should move this logic down to line 1519, in the else block (when we have an escaped value). ",
              "createdAt": "2022-03-28T07:08:10Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1470,6 +1470,10 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n+                if (!string.IsNullOrEmpty(property?.EvaluatedValue))",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Basically here we should check whether the property we got came from the environment (see https://github.com/dotnet/msbuild/blob/058a0262c6b37fba7bb55ec03315232d5d83be6e/src/Build/Instance/ProjectInstance.cs#L1482)",
              "createdAt": "2022-03-28T07:08:41Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1470,6 +1470,10 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n+                if (!string.IsNullOrEmpty(property?.EvaluatedValue))",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "and yes, move this new if block into the else block, where we've verified that the property is not null. here is too early.",
              "createdAt": "2022-03-28T07:09:42Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1470,6 +1470,10 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n+                if (!string.IsNullOrEmpty(property?.EvaluatedValue))",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "https://github.com/dotnet/msbuild/blob/058a0262c6b37fba7bb55ec03315232d5d83be6e/src/Build/Evaluation/Evaluator.cs#L1200",
              "createdAt": "2022-03-28T07:13:44Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1470,6 +1470,10 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n+                if (!string.IsNullOrEmpty(property?.EvaluatedValue))",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "by pattern-matching I mean:\r\n\r\n```\r\nif (property?.EvaluatedValue is { Length: > 0 } evaluatedValue) { ... }\r\n```",
              "createdAt": "2022-03-28T18:42:23Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1470,6 +1470,10 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n+                if (!string.IsNullOrEmpty(property?.EvaluatedValue))",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "What's the added value of pattern matching here of string.IsNullOrEmpty?",
              "createdAt": "2022-03-28T22:53:29Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1470,6 +1470,10 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n+                if (!string.IsNullOrEmpty(property?.EvaluatedValue))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "worried that if the `EvaluatedValue` getter does anything expensive, or is not idempotent, we'll be calling it twice. It might be benign or not. I prefer to only call properties once and reuse, just to be safe in general. Pattern matching lets you capture and cache the value.",
              "createdAt": "2022-03-29T01:27:10Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1470,6 +1470,10 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)\n             {\n                 T property = properties.GetProperty(propertyName, startIndex, endIndex);\n+                if (!string.IsNullOrEmpty(property?.EvaluatedValue))",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd be more specific and mention that we now only log the used env vars on BuildFinishedEventArgs",
              "createdAt": "2022-03-28T05:34:07Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -53,7 +53,9 @@ public sealed class BinaryLogger : ILogger\n         //   - TargetSkippedEventArgs: added OriginallySucceeded, Condition, EvaluatedCondition\n         // version 14:\n         //   - TargetSkippedEventArgs: added SkipReason, OriginalBuildEventContext\n-        internal const int FileFormatVersion = 14;\n+        // version 15:\n+        //   - Log only environment variables accessed as properties",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "need to check the fileFormatVersion and only ReadStringDictionary() if >= 15. Need to preserve current behavior when reading older binlogs.",
              "createdAt": "2022-03-28T05:35:03Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -362,12 +362,14 @@ private BuildEventArgs ReadBuildFinishedEventArgs()\n         {\n             var fields = ReadBuildEventArgsFields();\n             var succeeded = ReadBoolean();\n+            var environmentProperties = ReadStringDictionary();",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "maybe consider => or an auto-property",
              "createdAt": "2022-03-28T05:36:30Z",
              "path": "src/Framework/BuildFinishedEventArgs.cs",
              "diffHunk": "@@ -125,5 +155,16 @@ public bool Succeeded\n                 return succeeded;\n             }\n         }\n+\n+        /// <summary>\n+        /// Gets all environment variables read when trying to evaluate properties along with their values.\n+        /// </summary>\n+        public IDictionary<string, string> EnvironmentVariables",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think we should use OrdinalIgnoreCase as env vars are not case-sensitive.",
              "createdAt": "2022-03-28T05:37:47Z",
              "path": "src/Shared/EnvironmentUtilities.cs",
              "diffHunk": "@@ -14,5 +15,7 @@ internal static partial class EnvironmentUtilities\n \n         public static bool Is64BitOperatingSystem =>\n             Environment.Is64BitOperatingSystem;\n+\n+        public static Dictionary<string, string> EnvironmentVariablesUsedAsProperties { get; } = new();",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "we should find some way to not repeat `property.EvaluatedValueEscaped` three times in this else block. If propertyValue is an object, let's perhaps do something like this:\r\n\r\n```\r\nif (propertyValue is { Length: > 0 } value && property.IsEnvironmentProperty) ...\r\n```",
              "createdAt": "2022-03-29T00:57:52Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1517,6 +1513,10 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n                 else\n                 {\n                     propertyValue = property.EvaluatedValueEscaped;\n+                    if (!string.IsNullOrEmpty(property.EvaluatedValueEscaped) && property.IsEnvironmentProperty)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I should be able to say:\r\nstring propertyValueEscaped = property.EvaluatedValueEscaped;\r\npropertyValue = propertyValueEscaped;\r\nif (!string.IsNullOrEmpty(propertyValueEscaped)...\r\n\r\nThat seems simplest to me.",
              "createdAt": "2022-03-29T14:59:31Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1517,6 +1513,10 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n                 else\n                 {\n                     propertyValue = property.EvaluatedValueEscaped;\n+                    if (!string.IsNullOrEmpty(property.EvaluatedValueEscaped) && property.IsEnvironmentProperty)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        //   - Log environment variables accessed as properties via EnvironmentVariableReadEventArgs\r\n```",
              "createdAt": "2022-04-08T19:11:59Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -53,7 +53,10 @@ public sealed class BinaryLogger : ILogger\n         //   - TargetSkippedEventArgs: added OriginallySucceeded, Condition, EvaluatedCondition\n         // version 14:\n         //   - TargetSkippedEventArgs: added SkipReason, OriginalBuildEventContext\n-        internal const int FileFormatVersion = 14;\n+        // version 15:\n+        //   - Don't log all environment variables at BuildStarted\n+        //   - Log environment variables accessed as properties at BuildFinished",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Revert these changes",
              "createdAt": "2022-04-08T19:12:46Z",
              "path": "src/Framework/BuildFinishedEventArgs.cs",
              "diffHunk": "@@ -25,6 +26,11 @@ public class BuildFinishedEventArgs : BuildStatusEventArgs\n         /// </summary>\n         private bool succeeded;\n \n+        /// <summary>\n+        /// Environment variable-derived properties\n+        /// </summary>",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "And these",
              "createdAt": "2022-04-08T19:12:57Z",
              "path": "src/Framework/PublicAPI/net/PublicAPI.Unshipped.txt",
              "diffHunk": "@@ -0,0 +1,2 @@\n+Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp, System.Collections.Generic.IDictionary<string, string> environmentVariables, params object[] messageArgs) -> void",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This minimized the #ifdefs; it won't actually be sent or received by TaskHosts.",
              "createdAt": "2022-04-08T19:13:48Z",
              "path": "src/MSBuildTaskHost/MSBuildTaskHost.csproj",
              "diffHunk": "@@ -39,6 +39,9 @@\n     <Compile Include=\"..\\Shared\\BuildEnvironmentHelper.cs\">\n       <Link>BuildEnvironmentHelper.cs</Link>\n     </Compile>\n+    <Compile Include=\"..\\Framework\\EnvironmentVariableReadEventArgs.cs\">",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Works for me but put the comment in the file :)",
              "createdAt": "2022-04-12T13:55:24Z",
              "path": "src/MSBuildTaskHost/MSBuildTaskHost.csproj",
              "diffHunk": "@@ -39,6 +39,9 @@\n     <Compile Include=\"..\\Shared\\BuildEnvironmentHelper.cs\">\n       <Link>BuildEnvironmentHelper.cs</Link>\n     </Compile>\n+    <Compile Include=\"..\\Framework\\EnvironmentVariableReadEventArgs.cs\">",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Remove this",
              "createdAt": "2022-04-08T19:14:10Z",
              "path": "src/Shared/EnvironmentUtilities.cs",
              "diffHunk": "@@ -14,5 +14,7 @@ internal static partial class EnvironmentUtilities\n \n         public static bool Is64BitOperatingSystem =>\n             Environment.Is64BitOperatingSystem;\n+\n+        public static Dictionary<string, string> EnvironmentVariablesUsedAsProperties { get; } = new(MSBuildNameIgnoreCaseComparer.Default);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "All these extra substrings in tests are because the text log still has environment variables at the top, and the binlog is now hiding that.",
              "createdAt": "2022-04-08T19:15:35Z",
              "path": "src/Shared/UnitTests/EngineTestEnvironment.cs",
              "diffHunk": "@@ -235,7 +235,9 @@ private IEnumerable<(ILogger logger, Func<string> textGetter)> GetLoggers()\n                     foreach (var pair in pairs)\n                     {\n                         var expectedText = pair.expected.textGetter();\n+                        expectedText = expectedText.Substring(expectedText.IndexOf(\"Project\"));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Why does the text log have environment variables at the top? Isn't that what you're fixing with this PR?",
              "createdAt": "2022-04-12T13:50:38Z",
              "path": "src/Shared/UnitTests/EngineTestEnvironment.cs",
              "diffHunk": "@@ -235,7 +235,9 @@ private IEnumerable<(ILogger logger, Func<string> textGetter)> GetLoggers()\n                     foreach (var pair in pairs)\n                     {\n                         var expectedText = pair.expected.textGetter();\n+                        expectedText = expectedText.Substring(expectedText.IndexOf(\"Project\"));",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is a new format actually required? What does this provide that wasn't added in version 9?",
              "createdAt": "2022-04-12T13:53:16Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -53,7 +53,10 @@ public sealed class BinaryLogger : ILogger\n         //   - TargetSkippedEventArgs: added OriginallySucceeded, Condition, EvaluatedCondition\n         // version 14:\n         //   - TargetSkippedEventArgs: added SkipReason, OriginalBuildEventContext\n-        internal const int FileFormatVersion = 14;\n+        // version 15:\n+        //   - Don't log all environment variables at BuildStarted\n+        //   - Log environment variables accessed as properties via EnvironmentVariableReadEventArgs\n+        internal const int FileFormatVersion = 15;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Also behind a changewave?",
              "createdAt": "2022-04-12T13:53:29Z",
              "path": "src/Framework/Traits.cs",
              "diffHunk": "@@ -92,6 +92,11 @@ public Traits()\n         /// </summary>\n         public readonly bool LogPropertyFunctionsRequiringReflection = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBuildLogPropertyFunctionsRequiringReflection\"));\n \n+        /// <summary>\n+        /// Log all environment variables whether or not they are used in a build in the binary log.\n+        /// </summary>\n+        public readonly bool LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDLOGALLENVIRONMENTVARIABLES\"));",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I find this surprising. I expected an implementation more along the lines of \"do not populate the `BuildEnvironment` field in the new mode\", which would then change the behavior of all loggers. Is this a better approach?",
              "createdAt": "2022-04-12T13:54:57Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -251,7 +247,14 @@ private void Write(BuildStartedEventArgs e)\n         {\n             Write(BinaryLogRecordKind.BuildStarted);\n             WriteBuildEventArgsFields(e);\n-            Write(e.BuildEnvironment);\n+            if (Traits.Instance.LogAllEnvironmentVariables)\n+            {\n+                Write(e.BuildEnvironment);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Update comment on line 4521 (and similar) please.",
              "createdAt": "2022-04-12T13:56:25Z",
              "path": "src/Build.UnitTests/Evaluation/Evaluator_Tests.cs",
              "diffHunk": "@@ -4531,7 +4531,9 @@ public void VerifyPropertyTrackingLoggingDefault()\n                     logger\n                         .AllBuildEvents\n                         .OfType<EnvironmentVariableReadEventArgs>()\n-                        .ShouldBeEmpty();\n+                        .ShouldHaveSingleItem()\n+                        .EnvironmentVariableName\n+                        .ShouldBe(\"DEFINED_ENVIRONMENT_VARIABLE2\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I just saw one comment to update\u2014were you thinking I should add more, or was that all?",
              "createdAt": "2022-05-27T17:30:26Z",
              "path": "src/Build.UnitTests/Evaluation/Evaluator_Tests.cs",
              "diffHunk": "@@ -4531,7 +4531,9 @@ public void VerifyPropertyTrackingLoggingDefault()\n                     logger\n                         .AllBuildEvents\n                         .OfType<EnvironmentVariableReadEventArgs>()\n-                        .ShouldBeEmpty();\n+                        .ShouldHaveSingleItem()\n+                        .EnvironmentVariableName\n+                        .ShouldBe(\"DEFINED_ENVIRONMENT_VARIABLE2\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "If that's the only comment about empty environment, it's all we need. I think I thought there were others in other test cases?",
              "createdAt": "2022-05-31T15:07:36Z",
              "path": "src/Build.UnitTests/Evaluation/Evaluator_Tests.cs",
              "diffHunk": "@@ -4531,7 +4531,9 @@ public void VerifyPropertyTrackingLoggingDefault()\n                     logger\n                         .AllBuildEvents\n                         .OfType<EnvironmentVariableReadEventArgs>()\n-                        .ShouldBeEmpty();\n+                        .ShouldHaveSingleItem()\n+                        .EnvironmentVariableName\n+                        .ShouldBe(\"DEFINED_ENVIRONMENT_VARIABLE2\");",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: for new code I strongly prefer [using statements](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/using-statement) rather than blocks, where possible.",
              "createdAt": "2022-04-12T13:57:24Z",
              "path": "src/Build.UnitTests/Utilities_Tests.cs",
              "diffHunk": "@@ -80,54 +81,42 @@ public UtilitiesTestReadOnlyLoad()\n         [Fact]\n         public void CommentsInPreprocessing()\n         {\n-            Microsoft.Build.Construction.XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();\n-\n-            string input = FileUtilities.GetTemporaryFile();\n-            string output = FileUtilities.GetTemporaryFile();\n-\n-            string _initialLoadFilesWriteable = Environment.GetEnvironmentVariable(\"MSBUILDLOADALLFILESASWRITEABLE\");\n-            try\n+            using (TestEnvironment env = TestEnvironment.Create())",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Mind explaining why? I don't have a strong preference, but blocks make it clearer to me where scope starts and ends. The only advantage I know of to using statements is that they don't require extra indenting.",
              "createdAt": "2022-05-27T17:34:38Z",
              "path": "src/Build.UnitTests/Utilities_Tests.cs",
              "diffHunk": "@@ -80,54 +81,42 @@ public UtilitiesTestReadOnlyLoad()\n         [Fact]\n         public void CommentsInPreprocessing()\n         {\n-            Microsoft.Build.Construction.XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();\n-\n-            string input = FileUtilities.GetTemporaryFile();\n-            string output = FileUtilities.GetTemporaryFile();\n-\n-            string _initialLoadFilesWriteable = Environment.GetEnvironmentVariable(\"MSBUILDLOADALLFILESASWRITEABLE\");\n-            try\n+            using (TestEnvironment env = TestEnvironment.Create())",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Reduced indentation. If the `using` doesn't line up nicely with the  containing block, I prefer it, but if it does (as here where it's the whole method), I like the statement which has less ceremony.",
              "createdAt": "2022-05-31T15:14:32Z",
              "path": "src/Build.UnitTests/Utilities_Tests.cs",
              "diffHunk": "@@ -80,54 +81,42 @@ public UtilitiesTestReadOnlyLoad()\n         [Fact]\n         public void CommentsInPreprocessing()\n         {\n-            Microsoft.Build.Construction.XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();\n-\n-            string input = FileUtilities.GetTemporaryFile();\n-            string output = FileUtilities.GetTemporaryFile();\n-\n-            string _initialLoadFilesWriteable = Environment.GetEnvironmentVariable(\"MSBUILDLOADALLFILESASWRITEABLE\");\n-            try\n+            using (TestEnvironment env = TestEnvironment.Create())",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I thought we didn't want to do this because it adds a field to all of the millions of properties in a build?",
              "createdAt": "2022-04-12T14:00:26Z",
              "path": "src/Build/Evaluation/IProperty.cs",
              "diffHunk": "@@ -35,5 +35,11 @@ string EvaluatedValueEscaped\n         {\n             get;\n         }\n+\n+        bool IsEnvironmentProperty",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is also adding a field to a commonly used type, which we'd strongly prefer to avoid.",
              "createdAt": "2022-04-12T14:04:58Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -79,13 +83,28 @@ public string EvaluatedValue\n         /// </summary>\n         public virtual bool IsImmutable => false;\n \n+        private bool _loggedEnvProperty = false;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Also, is per-instance the right place to decide whether we've logged an environment variable? Shouldn't it be per build, rather than per property per project?",
              "createdAt": "2022-04-12T14:05:50Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -79,13 +83,28 @@ public string EvaluatedValue\n         /// </summary>\n         public virtual bool IsImmutable => false;\n \n+        private bool _loggedEnvProperty = false;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Sorry, stale comment.",
              "createdAt": "2022-05-23T20:18:06Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -79,13 +83,28 @@ public string EvaluatedValue\n         /// </summary>\n         public virtual bool IsImmutable => false;\n \n+        private bool _loggedEnvProperty = false;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think it's important to preserve the error here.",
              "createdAt": "2022-04-12T14:10:55Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -1001,33 +1030,33 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat\n             translator.Translate(ref helpKeyword);\n             translator.Translate(ref senderName);\n \n-            BuildEventArgs buildEvent = null;\n-            switch (eventType)\n+            return eventType switch\n             {\n-                case LoggingEventType.TaskCommandLineEvent:\n-                    buildEvent = ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildErrorEvent:\n-                    buildEvent = ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.ProjectStartedEvent:\n-                    buildEvent = ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.ProjectFinishedEvent:\n-                    buildEvent = ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildMessageEvent:\n-                    buildEvent = ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildWarningEvent:\n-                    buildEvent = ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                default:\n-                    ErrorUtilities.ThrowInternalError(\"Not Supported LoggingEventType {0}\", eventType.ToString());\n-                    break;\n-            }\n+                LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),\n+                _ => null,",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I agree. This is the only way this method can return null, and I added a VerifyThrow right after ReadEventFromStream to log the error. That said, KirillOsenkov was also surprised by this. Those are two points in favor of reverting that part, at least. My argument in favor of keeping it as-is is that return switch is beautiful and clear, and the effect is identical. Preference?",
              "createdAt": "2022-05-27T17:37:58Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -1001,33 +1030,33 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat\n             translator.Translate(ref helpKeyword);\n             translator.Translate(ref senderName);\n \n-            BuildEventArgs buildEvent = null;\n-            switch (eventType)\n+            return eventType switch\n             {\n-                case LoggingEventType.TaskCommandLineEvent:\n-                    buildEvent = ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildErrorEvent:\n-                    buildEvent = ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.ProjectStartedEvent:\n-                    buildEvent = ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.ProjectFinishedEvent:\n-                    buildEvent = ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildMessageEvent:\n-                    buildEvent = ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildWarningEvent:\n-                    buildEvent = ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                default:\n-                    ErrorUtilities.ThrowInternalError(\"Not Supported LoggingEventType {0}\", eventType.ToString());\n-                    break;\n-            }\n+                LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),\n+                _ => null,",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "If the semantics are identical then I'm fine with leaving as is",
              "createdAt": "2022-05-27T18:18:02Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -1001,33 +1030,33 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat\n             translator.Translate(ref helpKeyword);\n             translator.Translate(ref senderName);\n \n-            BuildEventArgs buildEvent = null;\n-            switch (eventType)\n+            return eventType switch\n             {\n-                case LoggingEventType.TaskCommandLineEvent:\n-                    buildEvent = ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildErrorEvent:\n-                    buildEvent = ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.ProjectStartedEvent:\n-                    buildEvent = ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.ProjectFinishedEvent:\n-                    buildEvent = ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildMessageEvent:\n-                    buildEvent = ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildWarningEvent:\n-                    buildEvent = ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                default:\n-                    ErrorUtilities.ThrowInternalError(\"Not Supported LoggingEventType {0}\", eventType.ToString());\n-                    break;\n-            }\n+                LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),\n+                _ => null,",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "> return switch is beautiful and clear\r\n\r\nYou don't have to avoid it here; you can `throw` inside a `switch`:\r\n\r\n```suggestion\r\n                _ => throw ...,\r\n```\r\n\r\nBut yeah if the semantics are identical you can leave this.",
              "createdAt": "2022-05-31T15:12:18Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -1001,33 +1030,33 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat\n             translator.Translate(ref helpKeyword);\n             translator.Translate(ref senderName);\n \n-            BuildEventArgs buildEvent = null;\n-            switch (eventType)\n+            return eventType switch\n             {\n-                case LoggingEventType.TaskCommandLineEvent:\n-                    buildEvent = ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildErrorEvent:\n-                    buildEvent = ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.ProjectStartedEvent:\n-                    buildEvent = ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.ProjectFinishedEvent:\n-                    buildEvent = ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildMessageEvent:\n-                    buildEvent = ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildWarningEvent:\n-                    buildEvent = ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                default:\n-                    ErrorUtilities.ThrowInternalError(\"Not Supported LoggingEventType {0}\", eventType.ToString());\n-                    break;\n-            }\n+                LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),\n+                _ => null,",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "throw... would be different semantically; we were using ErrorUtilities.Throw... before, which doesn't throw if (!s_throwExceptions). I don't think that's too important, but I thought it best to avoid that change anyway.",
              "createdAt": "2022-05-31T17:13:17Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -1001,33 +1030,33 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat\n             translator.Translate(ref helpKeyword);\n             translator.Translate(ref senderName);\n \n-            BuildEventArgs buildEvent = null;\n-            switch (eventType)\n+            return eventType switch\n             {\n-                case LoggingEventType.TaskCommandLineEvent:\n-                    buildEvent = ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildErrorEvent:\n-                    buildEvent = ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.ProjectStartedEvent:\n-                    buildEvent = ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.ProjectFinishedEvent:\n-                    buildEvent = ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildMessageEvent:\n-                    buildEvent = ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                case LoggingEventType.BuildWarningEvent:\n-                    buildEvent = ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName);\n-                    break;\n-                default:\n-                    ErrorUtilities.ThrowInternalError(\"Not Supported LoggingEventType {0}\", eventType.ToString());\n-                    break;\n-            }\n+                LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),\n+                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),\n+                _ => null,",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Notice that we're now doing the type check twice in this method where we only did one previously. We check if something is a warning, then check it again. I'm sure it's fine and we won't notice the perf difference, but it's important to be aware of these things in general. Again, I'm not worried about this place in particular.",
              "createdAt": "2022-04-13T02:20:07Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -1175,10 +1171,10 @@ public void LogBuildEvent(BuildEventArgs buildEvent)\n                 {\n                     // Only log certain events if OnlyLogCriticalEvents is true\n                     if (\n-                        (warningEvent != null)\n-                        || (errorEvent != null)\n-                        || (buildEvent is CustomBuildEventArgs)\n-                        || (buildEvent is CriticalBuildMessageEventArgs)\n+                        buildEvent is BuildWarningEventArgs",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Good thing to point out. I'd originally written it with just one type check but cleaner, and my code didn't compile. I ended up going with cleaner over more performant here.",
              "createdAt": "2022-04-13T16:04:31Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -1175,10 +1171,10 @@ public void LogBuildEvent(BuildEventArgs buildEvent)\n                 {\n                     // Only log certain events if OnlyLogCriticalEvents is true\n                     if (\n-                        (warningEvent != null)\n-                        || (errorEvent != null)\n-                        || (buildEvent is CustomBuildEventArgs)\n-                        || (buildEvent is CriticalBuildMessageEventArgs)\n+                        buildEvent is BuildWarningEventArgs",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We should try to include the argument name when passing literals, otherwise it's not clear which parameter this maps to.\r\n\r\nSee how this line already attempts this for other arguments (badly). We could remove the /* comments */ and insert argument names for other boolean literals on this line.",
              "createdAt": "2022-04-13T02:22:29Z",
              "path": "src/Build/Definition/Project.cs",
              "diffHunk": "@@ -2923,7 +2923,7 @@ public override bool SetGlobalProperty(string name, string escapedValue)\n                     string originalValue = (existing == null) ? String.Empty : ((IProperty)existing).EvaluatedValueEscaped;\n \n                     _data.GlobalPropertiesDictionary.Set(ProjectPropertyInstance.Create(name, escapedValue));\n-                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, true /* is global */, false /* may not be reserved name */));\n+                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, true /* is global */, false /* may not be reserved name */, null));",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "do we need a setter here?\r\n\r\ndo we need this at all? Should we just add this to ProjectPropertyNotXmlBacked?",
              "createdAt": "2022-04-13T02:28:46Z",
              "path": "src/Build/Evaluation/IProperty.cs",
              "diffHunk": "@@ -35,5 +35,11 @@ string EvaluatedValueEscaped\n         {\n             get;\n         }\n+\n+        bool IsEnvironmentProperty\n+        {\n+            get;\n+            set;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I see we also rely on this in ProjectPropertyInstance too",
              "createdAt": "2022-04-13T02:30:19Z",
              "path": "src/Build/Evaluation/IProperty.cs",
              "diffHunk": "@@ -35,5 +35,11 @@ string EvaluatedValueEscaped\n         {\n             get;\n         }\n+\n+        bool IsEnvironmentProperty\n+        {\n+            get;\n+            set;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I can add IsEnvironmentProperty to ProjectPropertyInstance and ProjectProperty instead of IProperty, but this seems safer to me should we add a new kind of property. It forces us to consider whether it can be environment-derived and log an event if so.\r\n\r\nIt was (in my opinion) a really clean way of doing this in a previous iteration. Now, it's more of a push as far as I'm concerned.\r\n\r\nI use the setter once in ProjectPropertyInstance as you saw. It means I don't need an extra constructor, but that isn't a great reason. I can take it out if you don't like it.",
              "createdAt": "2022-04-13T16:09:17Z",
              "path": "src/Build/Evaluation/IProperty.cs",
              "diffHunk": "@@ -35,5 +35,11 @@ string EvaluatedValueEscaped\n         {\n             get;\n         }\n+\n+        bool IsEnvironmentProperty\n+        {\n+            get;\n+            set;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Don't think we need to increment the format anymore?",
              "createdAt": "2022-04-13T02:32:24Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -53,7 +53,10 @@ public sealed class BinaryLogger : ILogger\n         //   - TargetSkippedEventArgs: added OriginallySucceeded, Condition, EvaluatedCondition\n         // version 14:\n         //   - TargetSkippedEventArgs: added SkipReason, OriginalBuildEventContext\n-        internal const int FileFormatVersion = 14;\n+        // version 15:\n+        //   - Don't log all environment variables at BuildStarted\n+        //   - Log environment variables accessed as properties via EnvironmentVariableReadEventArgs\n+        internal const int FileFormatVersion = 15;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Writing an empty dictionary here shouldn't be a format breaking change.",
              "createdAt": "2022-04-13T02:33:11Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -251,7 +247,14 @@ private void Write(BuildStartedEventArgs e)\n         {\n             Write(BinaryLogRecordKind.BuildStarted);\n             WriteBuildEventArgsFields(e);\n-            Write(e.BuildEnvironment);\n+            if (Traits.Instance.LogAllEnvironmentVariables)\n+            {\n+                Write(e.BuildEnvironment);\n+            }\n+            else\n+            {\n+                Write(0);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "What do you mean by that?",
              "createdAt": "2022-04-13T16:09:54Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -251,7 +247,14 @@ private void Write(BuildStartedEventArgs e)\n         {\n             Write(BinaryLogRecordKind.BuildStarted);\n             WriteBuildEventArgsFields(e);\n-            Write(e.BuildEnvironment);\n+            if (Traits.Instance.LogAllEnvironmentVariables)\n+            {\n+                Write(e.BuildEnvironment);\n+            }\n+            else\n+            {\n+                Write(0);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "basically this change is compliant with format version 14, so no need to increment the format version to 15.",
              "createdAt": "2022-04-13T17:01:39Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -251,7 +247,14 @@ private void Write(BuildStartedEventArgs e)\n         {\n             Write(BinaryLogRecordKind.BuildStarted);\n             WriteBuildEventArgsFields(e);\n-            Write(e.BuildEnvironment);\n+            if (Traits.Instance.LogAllEnvironmentVariables)\n+            {\n+                Write(e.BuildEnvironment);\n+            }\n+            else\n+            {\n+                Write(0);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Ah, gotcha. Yes; I agree.",
              "createdAt": "2022-04-13T17:10:35Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -251,7 +247,14 @@ private void Write(BuildStartedEventArgs e)\n         {\n             Write(BinaryLogRecordKind.BuildStarted);\n             WriteBuildEventArgsFields(e);\n-            Write(e.BuildEnvironment);\n+            if (Traits.Instance.LogAllEnvironmentVariables)\n+            {\n+                Write(e.BuildEnvironment);\n+            }\n+            else\n+            {\n+                Write(0);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "maybe keep both scenarios, having null and the dictionary are still valid cases (if the user turns on the trait)",
              "createdAt": "2022-04-13T02:34:10Z",
              "path": "src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs",
              "diffHunk": "@@ -38,13 +38,8 @@ public void RoundtripBuildStartedEventArgs()\n \n             args = new BuildStartedEventArgs(\n                 \"M\",\n-                null,\n-                new Dictionary<string, string>\n-                {\n-                    { \"SampleName\", \"SampleValue\" }\n-                });\n+                null);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Kind of scary to just throw here, perhaps log an error instead? Or do we think that this will receive enough testing before the release?",
              "createdAt": "2022-04-13T02:36:12Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -403,6 +409,7 @@ internal void ReadFromStream(ITranslator translator)\n                 else\n                 {\n                     _buildEvent = ReadEventFromStream(_eventType, translator);\n+                    ErrorUtilities.VerifyThrow(_buildEvent is not null, \"Not Supported LoggingEventType {0}\", _eventType.ToString());",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "This is actually just following the behavior from before. Previously, we went through a list of known build event types, and if something wasn't on the list, we threw an internal error:\r\nhttps://github.com/dotnet/msbuild/pull/7484/files#diff-e026e72274c4b9acd5923583b75c730b968d4297b0ed715b472fa4df88efe7caL1026\r\n\r\nUnfortunately, you can't have \"return \\<var> switch { _ => throw Exception(); }, so that's the one case in which it will return null, and I have to account for that here.\r\n\r\nIt's technically a null check beyond what it was doing before, but the \"return \\<var> switch\" pattern looks so pretty to me that I'd like to keep it if possible \ud83d\ude04 ",
              "createdAt": "2022-04-13T16:15:02Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -403,6 +409,7 @@ internal void ReadFromStream(ITranslator translator)\n                 else\n                 {\n                     _buildEvent = ReadEventFromStream(_eventType, translator);\n+                    ErrorUtilities.VerifyThrow(_buildEvent is not null, \"Not Supported LoggingEventType {0}\", _eventType.ToString());",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "sure",
              "createdAt": "2022-04-14T00:04:57Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -403,6 +409,7 @@ internal void ReadFromStream(ITranslator translator)\n                 else\n                 {\n                     _buildEvent = ReadEventFromStream(_eventType, translator);\n+                    ErrorUtilities.VerifyThrow(_buildEvent is not null, \"Not Supported LoggingEventType {0}\", _eventType.ToString());",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "are we not serializing the value?",
              "createdAt": "2022-04-13T02:36:59Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -661,12 +673,29 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even\n                 case LoggingEventType.ProjectFinishedEvent:\n                     WriteExternalProjectFinishedEventToStream((ExternalProjectFinishedEventArgs)buildEvent, translator);\n                     break;\n+                case LoggingEventType.EnvironmentVariableReadEvent:\n+                    WriteEnvironmentVariableReadEventArgs((EnvironmentVariableReadEventArgs)buildEvent, translator);\n+                    break;\n                 default:\n                     ErrorUtilities.ThrowInternalError(\"Not Supported LoggingEventType {0}\", eventType.ToString());\n                     break;\n             }\n         }\n \n+        /// <summary>\n+        /// Serializes EnvironmentVariableRead Event argument to the stream. Does not work properly on TaskHosts due to BuildEventContext serialization not being\n+        /// enabled on TaskHosts, but that shouldn't matter, as this should never be called from a TaskHost anyway.\n+        /// </summary>\n+        private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator)\n+        {\n+            string name = environmentVariableReadEventArgs.EnvironmentVariableName;\n+            translator.Translate(ref name);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "The value is in the message (confusingly\u2014I would not have done it that way, but that's how it was), so it was already being properly serialized.",
              "createdAt": "2022-04-13T16:11:09Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -661,12 +673,29 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even\n                 case LoggingEventType.ProjectFinishedEvent:\n                     WriteExternalProjectFinishedEventToStream((ExternalProjectFinishedEventArgs)buildEvent, translator);\n                     break;\n+                case LoggingEventType.EnvironmentVariableReadEvent:\n+                    WriteEnvironmentVariableReadEventArgs((EnvironmentVariableReadEventArgs)buildEvent, translator);\n+                    break;\n                 default:\n                     ErrorUtilities.ThrowInternalError(\"Not Supported LoggingEventType {0}\", eventType.ToString());\n                     break;\n             }\n         }\n \n+        /// <summary>\n+        /// Serializes EnvironmentVariableRead Event argument to the stream. Does not work properly on TaskHosts due to BuildEventContext serialization not being\n+        /// enabled on TaskHosts, but that shouldn't matter, as this should never be called from a TaskHost anyway.\n+        /// </summary>\n+        private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator)\n+        {\n+            string name = environmentVariableReadEventArgs.EnvironmentVariableName;\n+            translator.Translate(ref name);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "this line is too long :) maybe wrap each parameter on its own line",
              "createdAt": "2022-04-14T22:29:46Z",
              "path": "src/Build/Definition/ProjectProperty.cs",
              "diffHunk": "@@ -645,5 +642,16 @@ public override bool IsImported\n                 get { return false; }\n             }\n         }\n+\n+        private class EnvironmentDerivedProjectProperty : ProjectPropertyNotXmlBacked\n+        {\n+            internal bool _loggedEnvProperty = false;\n+            internal LoggingContext loggingContext;\n+\n+            internal EnvironmentDerivedProjectProperty(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext) : base(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved)",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd maybe do `environmentProperty.loggingContext is { IsValid: true } loggingContext` and then just use `loggingContext` to avoid repeating `environmentProperty.loggingContext`\r\n\r\nhttps://en.wikipedia.org/wiki/Law_of_Demeter",
              "createdAt": "2022-04-26T01:53:57Z",
              "path": "src/Build/Definition/ProjectProperty.cs",
              "diffHunk": "@@ -94,7 +96,18 @@ public string EvaluatedValue\n         string IProperty.EvaluatedValueEscaped\n         {\n             [DebuggerStepThrough]\n-            get => EvaluatedValueEscapedInternal;\n+            get\n+            {\n+                if (this is EnvironmentDerivedProjectProperty environmentProperty && environmentProperty.loggingContext?.IsValid == true && !environmentProperty._loggedEnvProperty)",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "[Q after a quick first pass]\r\n\r\nThis is the only place I see where `EnvironmentDerivedProjectPropertyInstance` is marked as \"logged\", is it true that it would only ever be considered logged whenever `EvaluatedValueEscaped` is called?",
              "createdAt": "2022-04-27T20:43:19Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -84,8 +86,21 @@ public string EvaluatedValue\n         /// Setter assumes caller has protected global properties, if necessary.\n         /// </summary>\n         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n-        string IProperty.EvaluatedValueEscaped => _escapedValue;\n-\n+        string IProperty.EvaluatedValueEscaped\n+        {\n+            get\n+            {\n+                if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty)\n+                {\n+                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);\n+                    args.BuildEventContext = envProperty.loggingContext.BuildEventContext;\n+                    envProperty.loggingContext.LogBuildEvent(args);\n+                    envProperty._loggedEnvProperty = true;",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Is this the only point that the env var would get added to the binlog?",
              "createdAt": "2022-04-27T20:46:39Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -84,8 +86,21 @@ public string EvaluatedValue\n         /// Setter assumes caller has protected global properties, if necessary.\n         /// </summary>\n         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n-        string IProperty.EvaluatedValueEscaped => _escapedValue;\n-\n+        string IProperty.EvaluatedValueEscaped\n+        {\n+            get\n+            {\n+                if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty)\n+                {\n+                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);\n+                    args.BuildEventContext = envProperty.loggingContext.BuildEventContext;\n+                    envProperty.loggingContext.LogBuildEvent(args);\n+                    envProperty._loggedEnvProperty = true;",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Correct on only considered logged when EvaluatedValueEscaped is called. That's the only way an EnvironmentDerivedProjectPropertyInstance's environment-derived property could get added to the binlog, but I also added EnvironmentDerivedProjectProperty, and that's another place environment-derived properties could get added.",
              "createdAt": "2022-04-27T21:07:31Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -84,8 +86,21 @@ public string EvaluatedValue\n         /// Setter assumes caller has protected global properties, if necessary.\n         /// </summary>\n         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n-        string IProperty.EvaluatedValueEscaped => _escapedValue;\n-\n+        string IProperty.EvaluatedValueEscaped\n+        {\n+            get\n+            {\n+                if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty)\n+                {\n+                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);\n+                    args.BuildEventContext = envProperty.loggingContext.BuildEventContext;\n+                    envProperty.loggingContext.LogBuildEvent(args);\n+                    envProperty._loggedEnvProperty = true;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "good catch, I think there's a loophole where other properties on `ProjectPropertyInstance` are called that effectively constitute a \"read\", but we don't log those. ",
              "createdAt": "2022-05-04T00:53:31Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -84,8 +86,21 @@ public string EvaluatedValue\n         /// Setter assumes caller has protected global properties, if necessary.\n         /// </summary>\n         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n-        string IProperty.EvaluatedValueEscaped => _escapedValue;\n-\n+        string IProperty.EvaluatedValueEscaped\n+        {\n+            get\n+            {\n+                if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty)\n+                {\n+                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);\n+                    args.BuildEventContext = envProperty.loggingContext.BuildEventContext;\n+                    envProperty.loggingContext.LogBuildEvent(args);\n+                    envProperty._loggedEnvProperty = true;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "@Forgind let's revisit this - I think this might be potentially the cause of our problems",
              "createdAt": "2022-05-11T23:31:24Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -84,8 +86,21 @@ public string EvaluatedValue\n         /// Setter assumes caller has protected global properties, if necessary.\n         /// </summary>\n         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n-        string IProperty.EvaluatedValueEscaped => _escapedValue;\n-\n+        string IProperty.EvaluatedValueEscaped\n+        {\n+            get\n+            {\n+                if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty)\n+                {\n+                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);\n+                    args.BuildEventContext = envProperty.loggingContext.BuildEventContext;\n+                    envProperty.loggingContext.LogBuildEvent(args);\n+                    envProperty._loggedEnvProperty = true;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "you can do `if (property is not EnvironmentDerivedProjectPropertyInstance)`",
              "createdAt": "2022-04-29T00:28:22Z",
              "path": "src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs",
              "diffHunk": "@@ -71,6 +72,17 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque\n         {\n         }\n \n+        private IEnumerable<DictionaryEntry> FilterEnvironmentDerivedProperties(PropertyDictionary<ProjectPropertyInstance> properties)\n+        {\n+            foreach (ProjectPropertyInstance property in properties)\n+            {\n+                if (!(property is EnvironmentDerivedProjectPropertyInstance))",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                if (property is not EnvironmentDerivedProjectPropertyInstance)\r\n```",
              "createdAt": "2022-04-29T22:13:28Z",
              "path": "src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs",
              "diffHunk": "@@ -71,6 +72,17 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque\n         {\n         }\n \n+        private IEnumerable<DictionaryEntry> FilterEnvironmentDerivedProperties(PropertyDictionary<ProjectPropertyInstance> properties)\n+        {\n+            foreach (ProjectPropertyInstance property in properties)\n+            {\n+                if (!(property is EnvironmentDerivedProjectPropertyInstance))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "we should probably pass the dictionary.Count if available as the capacity of the list, to do one single large allocation instead of log(Count) progressively larger allocations.",
              "createdAt": "2022-05-04T00:49:59Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -811,13 +812,28 @@ private void Evaluate()\n             if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)\n             {\n                 globalProperties = _data.GlobalPropertiesDictionary;\n-                properties = _data.Properties;\n+                properties = Traits.Instance.LogAllEnvironmentVariables ? _data.Properties : FilterOutEnvironmentDerivedProperties(_data.Properties);\n                 items = _data.Items;\n             }\n \n             _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);\n         }\n \n+        private IEnumerable FilterOutEnvironmentDerivedProperties(PropertyDictionary<P> dictionary)\n+        {\n+            List<P> list = new();",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "this condition is confusing to read. Is there a way to simplify this and remove unnecessary parentheses? Potentially also invert it and call `continue;` if false?",
              "createdAt": "2022-05-04T00:51:00Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -811,13 +812,28 @@ private void Evaluate()\n             if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)\n             {\n                 globalProperties = _data.GlobalPropertiesDictionary;\n-                properties = _data.Properties;\n+                properties = Traits.Instance.LogAllEnvironmentVariables ? _data.Properties : FilterOutEnvironmentDerivedProperties(_data.Properties);\n                 items = _data.Items;\n             }\n \n             _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);\n         }\n \n+        private IEnumerable FilterOutEnvironmentDerivedProperties(PropertyDictionary<P> dictionary)\n+        {\n+            List<P> list = new();\n+            foreach (P p in dictionary)\n+            {\n+                if (!((p is ProjectProperty pp && pp.IsEnvironmentProperty) ||",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we need to localize this?",
              "createdAt": "2022-05-04T00:56:14Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1204,16 +1204,21 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)\n         /// </summary>\n         private void PrintMessage(BuildMessageEventArgs e, bool lightenText)\n         {\n-            string nonNullMessage;\n+            string nonNullMessage = null;\n+\n+            if (e is EnvironmentVariableReadEventArgs environmentPropertyReadEventArgs)\n+            {\n+                nonNullMessage = $\"Property {environmentPropertyReadEventArgs.EnvironmentVariableName} with value {e.Message} expanded from the environment.\";",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "probably need to use a resource string here too",
              "createdAt": "2022-05-04T00:57:46Z",
              "path": "src/Build/Logging/SerialConsoleLogger.cs",
              "diffHunk": "@@ -511,7 +511,9 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)\n                     setColor(ConsoleColor.DarkGray);\n                 }\n \n-                string nonNullMessage;\n+                string nonNullMessage = e is EnvironmentVariableReadEventArgs environmentDerivedProperty ?\n+                    $\"Property {environmentDerivedProperty.EnvironmentVariableName} with value {e.Message} expanded from the environment.\"",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm also thinking whether an iterator is risky here. Always feels safer to allocate and return (what if someone iterates over this several times? what if the underlying properties collection changes before or while we iterate?) I don't know where this will be realized. \r\n\r\nOn the other hand allocating eagerly will allocate, while in theory an iterator will have a fixed allocation cost. Not sure really...",
              "createdAt": "2022-05-04T01:10:16Z",
              "path": "src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs",
              "diffHunk": "@@ -71,6 +72,17 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque\n         {\n         }\n \n+        private IEnumerable<DictionaryEntry> FilterEnvironmentDerivedProperties(PropertyDictionary<ProjectPropertyInstance> properties)\n+        {\n+            foreach (ProjectPropertyInstance property in properties)\n+            {\n+                if (property is not EnvironmentDerivedProjectPropertyInstance)\n+                {\n+                    yield return new DictionaryEntry(property.Name, property.EvaluatedValue);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "This seems to be called as part of logging that the build started in RequestBuilder.BuildProject. I would imagine that the _requestEntry is stable before that's called? If so, that would make this safe; I'm not at all sure, though.",
              "createdAt": "2022-05-10T22:27:35Z",
              "path": "src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs",
              "diffHunk": "@@ -71,6 +72,17 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque\n         {\n         }\n \n+        private IEnumerable<DictionaryEntry> FilterEnvironmentDerivedProperties(PropertyDictionary<ProjectPropertyInstance> properties)\n+        {\n+            foreach (ProjectPropertyInstance property in properties)\n+            {\n+                if (property is not EnvironmentDerivedProjectPropertyInstance)\n+                {\n+                    yield return new DictionaryEntry(property.Name, property.EvaluatedValue);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Put breakpoints on other ways to access value to see if/when they're hit.\r\n\r\nRun all tests with a Debugger.Launch as well as try building msbuild/roslyn/C++ project.\r\n\r\nOnce we understand this better, write it down.",
              "createdAt": "2022-05-16T15:20:57Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -84,8 +86,21 @@ public string EvaluatedValue\n         /// Setter assumes caller has protected global properties, if necessary.\n         /// </summary>\n         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n-        string IProperty.EvaluatedValueEscaped => _escapedValue;\n-\n+        string IProperty.EvaluatedValueEscaped",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Augment unit test with Env Vars to be much more comprehensive",
              "createdAt": "2022-05-16T15:22:30Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -84,8 +86,21 @@ public string EvaluatedValue\n         /// Setter assumes caller has protected global properties, if necessary.\n         /// </summary>\n         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n-        string IProperty.EvaluatedValueEscaped => _escapedValue;\n-\n+        string IProperty.EvaluatedValueEscaped",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "See if other PR works with unit test",
              "createdAt": "2022-05-16T15:28:34Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -84,8 +86,21 @@ public string EvaluatedValue\n         /// Setter assumes caller has protected global properties, if necessary.\n         /// </summary>\n         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n-        string IProperty.EvaluatedValueEscaped => _escapedValue;\n-\n+        string IProperty.EvaluatedValueEscaped",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Check conditions on:\r\n[ ] - task execution\r\n[ ] - itemgroup in target\r\n[ ] - itemgroup not in target\r\n[ ] - propertygroup in target\r\n[ ] - import statement",
              "createdAt": "2022-05-16T18:18:17Z",
              "path": "src/Build/Instance/ProjectPropertyInstance.cs",
              "diffHunk": "@@ -84,8 +86,21 @@ public string EvaluatedValue\n         /// Setter assumes caller has protected global properties, if necessary.\n         /// </summary>\n         [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n-        string IProperty.EvaluatedValueEscaped => _escapedValue;\n-\n+        string IProperty.EvaluatedValueEscaped",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "do we need to also check for `EnvironmentDerivedProjectProperty` here? or is it OK?",
              "createdAt": "2022-05-20T16:46:55Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1512,6 +1516,11 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n                 }\n                 else\n                 {\n+                    if (property is ProjectPropertyInstance.EnvironmentDerivedProjectPropertyInstance environmentDerivedProperty)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Sorry I missed this. I believe it's ok. I looked through uses of EnvironmentDerivedProjectProperties, and I believe they're only relevant at evaluation time, at which point our logging context hasn't yet been invalidated, so they get logged then.",
              "createdAt": "2022-06-01T21:40:48Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1512,6 +1516,11 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro\n                 }\n                 else\n                 {\n+                    if (property is ProjectPropertyInstance.EnvironmentDerivedProjectPropertyInstance environmentDerivedProperty)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}