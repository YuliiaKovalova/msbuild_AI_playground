{
  "number": 7005,
  "title": "msbuild overview doc",
  "body": "Wrote this for the internal qb docs but came out pretty generic. Don't know if it adds any value over the existing msbuild intros, feel free to close if that's the case. It's mainly stuff I found myself explaining to new hires.",
  "state": "MERGED",
  "createdAt": "2021-10-30T00:39:43Z",
  "updatedAt": "2022-02-15T17:55:18Z",
  "closedAt": "2022-02-15T17:55:18Z",
  "mergedAt": "2022-02-15T17:55:18Z",
  "additions": 89,
  "deletions": 23,
  "changedFiles": 4,
  "headRefName": "msbuildIntro",
  "isDraft": false,
  "author": {
    "login": "cdmihai"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "50fee0a89e8271e972ca5269275676599497982f",
          "message": "msbuild overview doc",
          "committedDate": "2021-10-30T00:35:19Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7d6f5c49aa45fc3b50ff5e88217fff4b9a852521",
          "message": "Moved overview to Contributions",
          "committedDate": "2021-11-17T23:19:12Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "abad9e956197b131ba1088fc87c0c591e4de2cd3",
          "message": "add contribution",
          "committedDate": "2021-11-17T23:19:51Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6a148c82d8fb0d94f4146d2d64040f917d3a4ba5",
          "message": "Explain Contributions doc folder",
          "committedDate": "2021-11-23T20:22:13Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ebd01c717717d1e0c577a7ee28b6917e99acb884",
          "message": "Items detail",
          "committedDate": "2021-12-04T16:32:27Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "codobanmihai@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "36c953dad00ae820d1f8ec838c9dfd6800e76c70",
          "message": "Clarify Project/ProjectInstance",
          "committedDate": "2021-12-04T16:38:02Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "codobanmihai@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d09e9388e13eda2846406b4778f7c2ade3605f4d",
          "message": "Move home and contribution out of wiki",
          "committedDate": "2022-02-15T16:59:25Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cfc46dd5ab7bbd4d2e7250c3d68a220dec8cc09d",
          "message": "Merge branch 'msbuildIntro' of https://github.com/cdmihai/msbuild into msbuildIntro",
          "committedDate": "2022-02-15T17:09:24Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d0927ac1ab0ebd0e7c5507aebaf1dcad9d401f1f",
          "message": "Merge fix",
          "committedDate": "2022-02-15T17:11:39Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "It's not that VS has hardcoded logic. It's that VS ran the evaluation step described above at some earlier time, so knows those files advertised by the project as being build inputs and outputs. This allows VS to more quickly scan those timestamps and skip calling MSBuild when no build is needed.",
              "createdAt": "2021-10-30T06:03:37Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.\n+\n+Typewise, everything is a string in MSBuild.\n+\n+Executing logic is grouped in [Targets](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets). They are like functions in C#. Targets can contain a single type of statement, [Tasks](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks). Targets form dependencies between themselves and are executed via a stack, similar to stack based function execution in other languages.\n+\n+Data structures (properties and items) can be declared either inside or outside targets. There is a single scope in MSBuild, you could call it the static scope. There's no automatic \"target scopes\". So if you declare a property or an item inside a target, it's still static and visible to the rest of the targets.\n+\n+# Language interpretation parts \n+\n+The parser, which produces the AST: [ProjectParser](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Evaluation/ProjectParser.cs#L125). The AST top node is the [ProjectRootElement](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Construction/ProjectRootElement.cs#L44)\n+\n+Interpretation happens in two big separate phases.\n+\n+The first interpretation phase is called **project evaluation**. It's done by the msbuild [Evaluator](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/Evaluator.cs#L52). The result of evaluation is an object tree similar (but different) to the symbol trees done by [compilers](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/get-started/semantic-analysis#understanding-compilations-and-symbols). The semantic top nodes are `ProjectInstance` and `Project`. You can sort of think of the `ProjectRootElement` as the syntax API and the `Project` / `ProjectInstance` as the semantic API. The big difference in MSBuild is that `ProjectInstance`/`Project` also contain the actual interpretation results of MSBuild's state (properties and items) that sits outside targets.\n+\n+Evaluation does not execute the targets in a project. It only interprets and stores the results of logic outside targets.\n+\n+The second phase of msbuild interpretation is target execution. This happens in the [TargetBuilder](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs#L100). The `TargetBuilder` uses a stack to execute targets. The initial state is the state contained inside a given `ProjectInstance`. So targets execute in a stack based manner and mutate the global state inside a `ProjectInstance`.\n+\n+What's the difference between `Project` and `ProjectInstance`? Sad story, but they are duplicates. `Project` objects are specialized in introspecting / analyzing MSBuild code and also in providing high level project editing operations. `ProjectInstance` objects are  read only. So the objects in the `Project` tree point back to their corresponding `ProjectRootElement` AST elements. The objects in the `ProjectInstance` tree do not point back to the `ProjectRootElement` elements (so they have a much smaller memory footprint). For example, the `Project` tree is used by Visual Studio to analyze msbuild projects, and to reflect UI changes all the way down to the XML elements. The `TargetBuilder` only works with the lighter weight `ProjectInstance` tree, since it only needs to read state.\n+\n+# MSBuild APIs and components\n+- `Project` / `ProjectInstance`: entrypoint APIs for working with MSBuild evaluations.\n+- `BuildManager`: entrypoint API for executing targets in MSBuild.\n+  - - Project build stack: RequestBuilder -> TargetBuilder -> TaskBuilder. The RequestBuilder is responsible for evaluating and running targets on a project. The TargetBuilder is responsible for running the target execution stack. The TaskBuilder is responsible for running individual tasks.\n+- MSBuild nodes\n+  - MSBuild distributes work across multiple processes.\n+  - All processes live on the same machine.\n+  - Types of nodes:\n+    - A main node, called the \"BuildManager node\" or the \"Scheduler node\". It contains BuildManager instances and its main role is to coordinate the entire build. It's a big state machine that decides when to create other nodes and on which nodes to build projects.\n+    - Multiple worker nodes whose single responsibility is to build projects. A worker node builds only one project at a time (99% true).\n+  - The process hosting the single BuildManager node can also host one worker node (called the \"inproc node\"). This is done for perf reasons, to avoid serialization costs. When the BuildManager node decides to spawn a new Worker node, it creates a new process for it. These are called out of process nodes, or \"oop nodes\". So Worker nodes can either be inproc nodes (a single one), or oop nodes (multiple).\n+\n+# MSBuild execution modes\n+- Building from cmdline (type msbuild.exe)\n+    - MSBuild is responsible for discovering project dependencies, and building them in a depth first search manner\n+    - There is no static graph of project dependencies. MSBuild does not know ahead of time what work it needs to do. It does a Just In Time DFS descent over the project references.\n+    - references form a DAG. A -> {B, C}, B -> {C, D}\n+    - there's a convention on how to declare and build references\n+      - documented here: https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md\n+      - mostly implemented here: https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.CurrentVersion.targets\n+- Building from Visual Studio (VS) (pressing ctrl+shift+B, or the context menu `Build -> Build Solution`)\n+    - VS implements an object model for an MSBuild dependency graph\n+    - VS takes over the responsibility of handling the graph dependencies and constructs its own graph\n+    - It bypasses MSBuild's scheduler and \"orders\" MSBuild to build a single project at a time, ignoring its references\n+    - It builds the graph bottom up in reverse toposort order (starting from nodes without references and going up).\n+    - Fast up to date checks:  VS hardcodes relevant project file inputs for each language SDK. (for example it knows that C# projects read global.json). It uses these hardcoded rules to skip building projects. (whereas quickbuild does this in a generic non hardcoded way by observing actual IO inputs and outputs)",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "That's true, but the VS rules on what inputs to extract from a project evaluation are still hardcoded rules (for example: look at @(Compile), look at @(Content), look at global.json, etc). During actual runtime, msbuild tasks may read file inputs not covered by the VS rules (leading to underbuilds, a correctness issue), or may read less file inputs than the VS rules (leading to overbuilds, wasted time). At best, VS can only play catch-up with what happens at runtime. This is opposed to a monitored build runtime that captures the concrete IO that's performed as it happens, thus being accurate by definition (or at least as accurate as the monitoring APIs).",
              "createdAt": "2021-11-01T21:16:11Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.\n+\n+Typewise, everything is a string in MSBuild.\n+\n+Executing logic is grouped in [Targets](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets). They are like functions in C#. Targets can contain a single type of statement, [Tasks](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks). Targets form dependencies between themselves and are executed via a stack, similar to stack based function execution in other languages.\n+\n+Data structures (properties and items) can be declared either inside or outside targets. There is a single scope in MSBuild, you could call it the static scope. There's no automatic \"target scopes\". So if you declare a property or an item inside a target, it's still static and visible to the rest of the targets.\n+\n+# Language interpretation parts \n+\n+The parser, which produces the AST: [ProjectParser](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Evaluation/ProjectParser.cs#L125). The AST top node is the [ProjectRootElement](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Construction/ProjectRootElement.cs#L44)\n+\n+Interpretation happens in two big separate phases.\n+\n+The first interpretation phase is called **project evaluation**. It's done by the msbuild [Evaluator](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/Evaluator.cs#L52). The result of evaluation is an object tree similar (but different) to the symbol trees done by [compilers](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/get-started/semantic-analysis#understanding-compilations-and-symbols). The semantic top nodes are `ProjectInstance` and `Project`. You can sort of think of the `ProjectRootElement` as the syntax API and the `Project` / `ProjectInstance` as the semantic API. The big difference in MSBuild is that `ProjectInstance`/`Project` also contain the actual interpretation results of MSBuild's state (properties and items) that sits outside targets.\n+\n+Evaluation does not execute the targets in a project. It only interprets and stores the results of logic outside targets.\n+\n+The second phase of msbuild interpretation is target execution. This happens in the [TargetBuilder](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs#L100). The `TargetBuilder` uses a stack to execute targets. The initial state is the state contained inside a given `ProjectInstance`. So targets execute in a stack based manner and mutate the global state inside a `ProjectInstance`.\n+\n+What's the difference between `Project` and `ProjectInstance`? Sad story, but they are duplicates. `Project` objects are specialized in introspecting / analyzing MSBuild code and also in providing high level project editing operations. `ProjectInstance` objects are  read only. So the objects in the `Project` tree point back to their corresponding `ProjectRootElement` AST elements. The objects in the `ProjectInstance` tree do not point back to the `ProjectRootElement` elements (so they have a much smaller memory footprint). For example, the `Project` tree is used by Visual Studio to analyze msbuild projects, and to reflect UI changes all the way down to the XML elements. The `TargetBuilder` only works with the lighter weight `ProjectInstance` tree, since it only needs to read state.\n+\n+# MSBuild APIs and components\n+- `Project` / `ProjectInstance`: entrypoint APIs for working with MSBuild evaluations.\n+- `BuildManager`: entrypoint API for executing targets in MSBuild.\n+  - - Project build stack: RequestBuilder -> TargetBuilder -> TaskBuilder. The RequestBuilder is responsible for evaluating and running targets on a project. The TargetBuilder is responsible for running the target execution stack. The TaskBuilder is responsible for running individual tasks.\n+- MSBuild nodes\n+  - MSBuild distributes work across multiple processes.\n+  - All processes live on the same machine.\n+  - Types of nodes:\n+    - A main node, called the \"BuildManager node\" or the \"Scheduler node\". It contains BuildManager instances and its main role is to coordinate the entire build. It's a big state machine that decides when to create other nodes and on which nodes to build projects.\n+    - Multiple worker nodes whose single responsibility is to build projects. A worker node builds only one project at a time (99% true).\n+  - The process hosting the single BuildManager node can also host one worker node (called the \"inproc node\"). This is done for perf reasons, to avoid serialization costs. When the BuildManager node decides to spawn a new Worker node, it creates a new process for it. These are called out of process nodes, or \"oop nodes\". So Worker nodes can either be inproc nodes (a single one), or oop nodes (multiple).\n+\n+# MSBuild execution modes\n+- Building from cmdline (type msbuild.exe)\n+    - MSBuild is responsible for discovering project dependencies, and building them in a depth first search manner\n+    - There is no static graph of project dependencies. MSBuild does not know ahead of time what work it needs to do. It does a Just In Time DFS descent over the project references.\n+    - references form a DAG. A -> {B, C}, B -> {C, D}\n+    - there's a convention on how to declare and build references\n+      - documented here: https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md\n+      - mostly implemented here: https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.CurrentVersion.targets\n+- Building from Visual Studio (VS) (pressing ctrl+shift+B, or the context menu `Build -> Build Solution`)\n+    - VS implements an object model for an MSBuild dependency graph\n+    - VS takes over the responsibility of handling the graph dependencies and constructs its own graph\n+    - It bypasses MSBuild's scheduler and \"orders\" MSBuild to build a single project at a time, ignoring its references\n+    - It builds the graph bottom up in reverse toposort order (starting from nodes without references and going up).\n+    - Fast up to date checks:  VS hardcodes relevant project file inputs for each language SDK. (for example it knows that C# projects read global.json). It uses these hardcoded rules to skip building projects. (whereas quickbuild does this in a generic non hardcoded way by observing actual IO inputs and outputs)",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Not really like a string arrays because they can have metadata",
              "createdAt": "2021-10-30T20:14:06Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "True, but my intent was to keep this is as a big overview that gives one the \"feel of the landscape\", not an exhaustive specification. I'll describe this intent in the introduction. There's also the hyperlink to the VS docs containing most of the details on items.",
              "createdAt": "2021-11-01T21:25:13Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "IMHO this is a core concept -- if you don't want to mention it here I'd avoid analogizing with `string[]` as it's misleading.",
              "createdAt": "2021-11-01T21:40:26Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "The main aspect I wanted to convey was that: \"there's two types, one that represents a single thing, and another that's a list of things\". Maybe `object foo` and `object[] foo`? :) Or maybe `ItemType[] foo` where `ItemType` is `{string ItemValue, Dict<string, string> Metadata}`",
              "createdAt": "2021-11-01T21:51:56Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "```suggestion\r\n- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#, except the array has a name called an item-type, and each item may not only have a value, but also have associated key-value pairs known as metadata.\r\n```\r\n?",
              "createdAt": "2021-11-01T22:04:04Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Worth noting they can never run twice",
              "createdAt": "2021-10-30T20:14:31Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.\n+\n+Typewise, everything is a string in MSBuild.\n+\n+Executing logic is grouped in [Targets](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets). They are like functions in C#. Targets can contain a single type of statement, [Tasks](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks). Targets form dependencies between themselves and are executed via a stack, similar to stack based function execution in other languages.",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "That would require explaining global properties and what a target's identity really is (tuple of file path, global props, toolsversion). Probably too much for a quick overview? Maybe worth a followup sentence on how targets broadly differs from mainstream function calls.",
              "createdAt": "2021-11-01T21:32:13Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.\n+\n+Typewise, everything is a string in MSBuild.\n+\n+Executing logic is grouped in [Targets](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets). They are like functions in C#. Targets can contain a single type of statement, [Tasks](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks). Targets form dependencies between themselves and are executed via a stack, similar to stack based function execution in other languages.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "fair enough.",
              "createdAt": "2021-11-01T21:40:40Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.\n+\n+Typewise, everything is a string in MSBuild.\n+\n+Executing logic is grouped in [Targets](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets). They are like functions in C#. Targets can contain a single type of statement, [Tasks](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks). Targets form dependencies between themselves and are executed via a stack, similar to stack based function execution in other languages.",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Sad story? \ud83d\ude43 they're intended for design time (eg solution explorer) and build time (eg command line)",
              "createdAt": "2021-10-30T20:16:18Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.\n+\n+Typewise, everything is a string in MSBuild.\n+\n+Executing logic is grouped in [Targets](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets). They are like functions in C#. Targets can contain a single type of statement, [Tasks](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks). Targets form dependencies between themselves and are executed via a stack, similar to stack based function execution in other languages.\n+\n+Data structures (properties and items) can be declared either inside or outside targets. There is a single scope in MSBuild, you could call it the static scope. There's no automatic \"target scopes\". So if you declare a property or an item inside a target, it's still static and visible to the rest of the targets.\n+\n+# Language interpretation parts \n+\n+The parser, which produces the AST: [ProjectParser](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Evaluation/ProjectParser.cs#L125). The AST top node is the [ProjectRootElement](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Construction/ProjectRootElement.cs#L44)\n+\n+Interpretation happens in two big separate phases.\n+\n+The first interpretation phase is called **project evaluation**. It's done by the msbuild [Evaluator](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/Evaluator.cs#L52). The result of evaluation is an object tree similar (but different) to the symbol trees done by [compilers](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/get-started/semantic-analysis#understanding-compilations-and-symbols). The semantic top nodes are `ProjectInstance` and `Project`. You can sort of think of the `ProjectRootElement` as the syntax API and the `Project` / `ProjectInstance` as the semantic API. The big difference in MSBuild is that `ProjectInstance`/`Project` also contain the actual interpretation results of MSBuild's state (properties and items) that sits outside targets.\n+\n+Evaluation does not execute the targets in a project. It only interprets and stores the results of logic outside targets.\n+\n+The second phase of msbuild interpretation is target execution. This happens in the [TargetBuilder](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs#L100). The `TargetBuilder` uses a stack to execute targets. The initial state is the state contained inside a given `ProjectInstance`. So targets execute in a stack based manner and mutate the global state inside a `ProjectInstance`.\n+\n+What's the difference between `Project` and `ProjectInstance`? Sad story, but they are duplicates. `Project` objects are specialized in introspecting / analyzing MSBuild code and also in providing high level project editing operations. `ProjectInstance` objects are  read only. So the objects in the `Project` tree point back to their corresponding `ProjectRootElement` AST elements. The objects in the `ProjectInstance` tree do not point back to the `ProjectRootElement` elements (so they have a much smaller memory footprint). For example, the `Project` tree is used by Visual Studio to analyze msbuild projects, and to reflect UI changes all the way down to the XML elements. The `TargetBuilder` only works with the lighter weight `ProjectInstance` tree, since it only needs to read state.",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "The use cases are indeed legitimate, but the actual implementation involves a lot of duplicated code, with all its downsides, hence the \"sad story\".  :)",
              "createdAt": "2021-11-01T21:21:24Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.\n+\n+Typewise, everything is a string in MSBuild.\n+\n+Executing logic is grouped in [Targets](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets). They are like functions in C#. Targets can contain a single type of statement, [Tasks](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks). Targets form dependencies between themselves and are executed via a stack, similar to stack based function execution in other languages.\n+\n+Data structures (properties and items) can be declared either inside or outside targets. There is a single scope in MSBuild, you could call it the static scope. There's no automatic \"target scopes\". So if you declare a property or an item inside a target, it's still static and visible to the rest of the targets.\n+\n+# Language interpretation parts \n+\n+The parser, which produces the AST: [ProjectParser](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Evaluation/ProjectParser.cs#L125). The AST top node is the [ProjectRootElement](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Construction/ProjectRootElement.cs#L44)\n+\n+Interpretation happens in two big separate phases.\n+\n+The first interpretation phase is called **project evaluation**. It's done by the msbuild [Evaluator](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/Evaluator.cs#L52). The result of evaluation is an object tree similar (but different) to the symbol trees done by [compilers](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/get-started/semantic-analysis#understanding-compilations-and-symbols). The semantic top nodes are `ProjectInstance` and `Project`. You can sort of think of the `ProjectRootElement` as the syntax API and the `Project` / `ProjectInstance` as the semantic API. The big difference in MSBuild is that `ProjectInstance`/`Project` also contain the actual interpretation results of MSBuild's state (properties and items) that sits outside targets.\n+\n+Evaluation does not execute the targets in a project. It only interprets and stores the results of logic outside targets.\n+\n+The second phase of msbuild interpretation is target execution. This happens in the [TargetBuilder](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs#L100). The `TargetBuilder` uses a stack to execute targets. The initial state is the state contained inside a given `ProjectInstance`. So targets execute in a stack based manner and mutate the global state inside a `ProjectInstance`.\n+\n+What's the difference between `Project` and `ProjectInstance`? Sad story, but they are duplicates. `Project` objects are specialized in introspecting / analyzing MSBuild code and also in providing high level project editing operations. `ProjectInstance` objects are  read only. So the objects in the `Project` tree point back to their corresponding `ProjectRootElement` AST elements. The objects in the `ProjectInstance` tree do not point back to the `ProjectRootElement` elements (so they have a much smaller memory footprint). For example, the `Project` tree is used by Visual Studio to analyze msbuild projects, and to reflect UI changes all the way down to the XML elements. The `TargetBuilder` only works with the lighter weight `ProjectInstance` tree, since it only needs to read state.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "that's not going to be clear -- I would change \"sad story they are duplicates\" with \"they are for scenarios X and Y respectively\"",
              "createdAt": "2021-11-01T21:39:27Z",
              "path": "documentation/wiki/MSBuild-overview.md",
              "diffHunk": "@@ -0,0 +1,60 @@\n+- [Quick intro](#quick-intro)\n+- [Language interpretation parts](#language-interpretation-parts)\n+- [MSBuild APIs and components](#msbuild-apis-and-components)\n+- [MSBuild execution modes](#msbuild-execution-modes)\n+\n+# Quick intro\n+MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.\n+\n+MSBuild has two data structures:\n+- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#\n+- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, vectors. Like `string[] foo` in C#.\n+\n+Typewise, everything is a string in MSBuild.\n+\n+Executing logic is grouped in [Targets](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets). They are like functions in C#. Targets can contain a single type of statement, [Tasks](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks). Targets form dependencies between themselves and are executed via a stack, similar to stack based function execution in other languages.\n+\n+Data structures (properties and items) can be declared either inside or outside targets. There is a single scope in MSBuild, you could call it the static scope. There's no automatic \"target scopes\". So if you declare a property or an item inside a target, it's still static and visible to the rest of the targets.\n+\n+# Language interpretation parts \n+\n+The parser, which produces the AST: [ProjectParser](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Evaluation/ProjectParser.cs#L125). The AST top node is the [ProjectRootElement](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Construction/ProjectRootElement.cs#L44)\n+\n+Interpretation happens in two big separate phases.\n+\n+The first interpretation phase is called **project evaluation**. It's done by the msbuild [Evaluator](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/Evaluator.cs#L52). The result of evaluation is an object tree similar (but different) to the symbol trees done by [compilers](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/get-started/semantic-analysis#understanding-compilations-and-symbols). The semantic top nodes are `ProjectInstance` and `Project`. You can sort of think of the `ProjectRootElement` as the syntax API and the `Project` / `ProjectInstance` as the semantic API. The big difference in MSBuild is that `ProjectInstance`/`Project` also contain the actual interpretation results of MSBuild's state (properties and items) that sits outside targets.\n+\n+Evaluation does not execute the targets in a project. It only interprets and stores the results of logic outside targets.\n+\n+The second phase of msbuild interpretation is target execution. This happens in the [TargetBuilder](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs#L100). The `TargetBuilder` uses a stack to execute targets. The initial state is the state contained inside a given `ProjectInstance`. So targets execute in a stack based manner and mutate the global state inside a `ProjectInstance`.\n+\n+What's the difference between `Project` and `ProjectInstance`? Sad story, but they are duplicates. `Project` objects are specialized in introspecting / analyzing MSBuild code and also in providing high level project editing operations. `ProjectInstance` objects are  read only. So the objects in the `Project` tree point back to their corresponding `ProjectRootElement` AST elements. The objects in the `ProjectInstance` tree do not point back to the `ProjectRootElement` elements (so they have a much smaller memory footprint). For example, the `Project` tree is used by Visual Studio to analyze msbuild projects, and to reflect UI changes all the way down to the XML elements. The `TargetBuilder` only works with the lighter weight `ProjectInstance` tree, since it only needs to read state.",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      }
    ]
  }
}