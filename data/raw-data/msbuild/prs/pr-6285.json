{
  "number": 6285,
  "title": "Allow parameter type name to be specified for WriteCodeFragment task",
  "body": "Fixes #2281\r\n\r\n### Context\r\n\r\nThis change allows the `WriteCodeFragment` task to define assembly attributes that require parameters that are not of type `System.String`. For example, `CSLCompliantAttribute` can be generated with a parameter of `true` instead of `\"true\"`.\r\n\r\n### Changes Made\r\n\r\nAdditional metadata can be defined on an `AssemblyAttribute` that specifies how to treat the parameters specified in the metadata. There are three different ways that the parameters can be treated.\r\n\r\n#### Infer the Type\r\n\r\nWithout specifying any additional metadata, attributes that are defined in the `mscorlib` assembly (i.e. types that can be loaded via `System.Type.GetType(string)`) will have their parameter types inferred by finding the constructor where the parameter count matches the number of parameters specified in the metadata. For example, this:\r\n\r\n```xml\r\n<ItemGroup>\r\n  <AssemblyAttribute Include=\"CLSCompliantAttribute\">\r\n    <_Parameter1>true</_Parameter1>\r\n  </AssemblyAttribute>\r\n</ItemGroup>\r\n```\r\n\r\nWill produce the code:\r\n\r\n```csharp\r\n[assembly: CLSCompliantAttribute(true)]\r\n```\r\n\r\nFor backward-compatibility, if the attribute cannot be found, or no matching constructor is found, the parameter is treated as a string.\r\n\r\n#### Declare the Type\r\n\r\nAn additional metadata item can be used to specify the full name of the parameter type. To do this, add a metadata item that has the same name as the parameter with \"_TypeName\" appended to the end. For example, this:\r\n\r\n```xml\r\n<ItemGroup>\r\n  <AssemblyAttribute Include=\"TestAttribute\">\r\n    <_Parameter1>True</_Parameter1>\r\n    <_Parameter1_TypeName>System.Boolean</_Parameter1_TypeName>\r\n  </AssemblyAttribute>\r\n</ItemGroup>\r\n```\r\n\r\nWill produce the code:\r\n\r\n```csharp\r\n[assembly: TestAttribute(true)]\r\n```\r\n\r\nThis also works with named parameters:\r\n\r\n```xml\r\n<ItemGroup>\r\n  <AssemblyAttribute Include=\"TestAttribute\">\r\n    <Foo>42</IdentifyLevel>\r\n    <Foo_TypeName>System.Int32</Foo_TypeName>\r\n  </AssemblyAttribute>\r\n</ItemGroup>\r\n```\r\n\r\n```csharp\r\n[assembly: TestAttribute(42)]\r\n```\r\n\r\nAll types that can be used as attribute parameters are supported, except for arrays.\r\n\r\nFor backward-compatibility, if a metadata item ends with \"_TypeName\", but there is no metadata item for the parameter with that name, then it will be treated as another named property. For example, this:\r\n\r\n```xml\r\n<ItemGroup>\r\n  <AssemblyAttribute Include=\"TestAttribute\">\r\n    <Foo_TypeName>System.Int32</Foo_TypeName>\r\n  </AssemblyAttribute>\r\n</ItemGroup>\r\n```\r\n\r\nWould produce the code:\r\n\r\n```csharp\r\n[assembly: TestAttribute(Foo_TypeName=\"System.Int32\")]\r\n```\r\n\r\n#### Specify the Exact Code\r\n\r\nFor cases where declaring the type is insufficient (such as when the parameter is an array), you can specify the exact that that will be generated for the parameter by adding metadata that has the same name as the parameter with \"_IsLiteral\" appended to the end. For example, this:\r\n\r\n```xml\r\n<ItemGroup>\r\n  <AssemblyAttribute Include=\"TestAttribute\">\r\n    <_Parameter1>new int[] { 1, 3, 5 } /* odd numbers */</_Parameter1>\r\n    <_Parameter1_IsLiteral>true</_Parameter1_IsLiteral>\r\n  </AssemblyAttribute>\r\n</ItemGroup>\r\n```\r\n\r\nWill produce the code:\r\n\r\n```csharp\r\n[assembly: TestAttribute(new int[] { 1, 3, 5 } /* odd numbers */)]\r\n```\r\n\r\nThe limitation with this is that the code you provide is language-specific. For example, the literal value in the metadata above will only work in C#. If you used that same metadata in a VB.NET project, you would receive a compiler error.\r\n\r\nThis works with both positional and named parameters. As with the `..._TypeName` metadata, if an `..._IsLiteral` metadata does not have a corresponding parameter name, it will be treated as a named parameter for backward-compatibility.\r\n\r\n#### Mixed Parameter Behavior\r\n\r\nBecause the additional metadata only applies to a specific parameter, you can choose to treat different parameters in different ways. For example, you can infer/use the default behavior for one parameter, specify the type for the second parameter and use a literal value for the third. For example:\r\n\r\n```xml\r\n<ItemGroup>\r\n  <AssemblyAttribute Include=\"TestAttribute\">\r\n    <_Parameter1>This is a string</_Parameter1>\r\n    <_Parameter2>42></Parameter2>\r\n    <_Parameter2_TypeName>System.Int32</_Parameter2_TypeName>\r\n    <_Parameter3>new int[] { 1 }</_Parameter3>\r\n    <_Parameter3_IsLiteral>true</_Parameter3_IsLiteral>\r\n  </AssemblyAttribute>\r\n</ItemGroup>\r\n```\r\n\r\n### Testing\r\n\r\nI've added tests for inferring the parameter type, declaring the parameter type and using literal values. I've also added tests to confirm backward-compatibility is maintained where it's possible to do so.\r\n\r\nThe new tests I added all use helper methods to reduce the boilerplate that the existing tests had. The existing tests could also be changed to use these new methods, but I've left them as is to reduce the amount of changes in this PR.\r\n\r\n### Notes\r\n\r\nI'm not sure if \"IsLiteral\" is the best terminology, but the general consensus in #2281 was that it was a good term to use, so I stuck with it. I'm happy to change it to something else if needed.",
  "state": "MERGED",
  "createdAt": "2021-03-20T01:08:16Z",
  "updatedAt": "2024-11-13T20:09:24Z",
  "closedAt": "2021-04-08T16:08:48Z",
  "mergedAt": "2021-04-08T16:08:47Z",
  "additions": 1161,
  "deletions": 12,
  "changedFiles": 17,
  "headRefName": "write-code-fragment-non-string-parameters",
  "isDraft": false,
  "author": {
    "login": "reduckted"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "c684258d56be58df15b46f72078875f828c7c3a0",
          "message": "Allow parameter type name to be specified for WriteCodeFragment task.",
          "committedDate": "2021-03-20T01:02:40Z",
          "author": {
            "name": "reduckted",
            "email": "reduckted@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ece1f5976898a89e3df5b0214ffe2ac744a447f4",
          "message": "Readability improvements.",
          "committedDate": "2021-04-04T04:05:30Z",
          "author": {
            "name": "reduckted",
            "email": "reduckted@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "38e5d3369f8c423be1e00d008862639da266535f",
          "message": "Delay-created the collections when extracting parameter types to avoid allocations.",
          "committedDate": "2021-04-04T04:12:59Z",
          "author": {
            "name": "reduckted",
            "email": "reduckted@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d41cb3a50cea07350f44b7ab7f669007f89c0306",
          "message": "Added a better explanation about selecting the first constructor when inferring parameter types.",
          "committedDate": "2021-04-04T04:41:31Z",
          "author": {
            "name": "reduckted",
            "email": "reduckted@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4a1913e91606e846ab474991c7ecb832986ef9e4",
          "message": "Added argument names to improve readability.",
          "committedDate": "2021-04-05T00:30:12Z",
          "author": {
            "name": "reduckted",
            "email": "reduckted@outlook.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Thank you @reduckted!",
        "createdAt": "2021-04-08T16:09:15Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "How can I know when this will be available? Ideally I'd subscribe to something somewhere on github to be alerted when I can start using this.",
        "createdAt": "2021-04-08T18:40:41Z",
        "author": {
          "login": "billybraga"
        }
      },
      {
        "body": "This should be available in 16.10 preview 3. I will try to remember to ping you in this thread when that's available. That should be roughly a month from now.",
        "createdAt": "2021-04-08T20:06:35Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> available in 16.10 preview 3\r\n\r\nAre you referring to the MSBuild or Visual Studio version? Will it be part of the next [.NET 6.0 SDK](https://dotnet.microsoft.com/download/dotnet/6.0) preview release?",
        "createdAt": "2021-04-12T21:35:48Z",
        "author": {
          "login": "0xced"
        }
      },
      {
        "body": "MSBuild versions and Visual Studio versions line up nicely, so both.\r\n\r\n> Will it be part of the next .NET 6.0 SDK preview release?\r\n\r\nThat's a good question. I think it will be in preview 4, but I'm not 100% sure on that. @dsplaisted, do you know?",
        "createdAt": "2021-04-15T22:30:04Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "@marcpopMSFT for the release alignment question.",
        "createdAt": "2021-04-16T02:50:38Z",
        "author": {
          "login": "dsplaisted"
        }
      },
      {
        "body": "16.10 preview 3 has been released! The .NET 6 preview 4 SDK hasn't been released yet.\r\n\r\n/cc: @billybraga",
        "createdAt": "2021-05-13T22:40:02Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "When the .NET 6 preview 4 SDK releases, it should include this fix as we'll be shipping with an MSBuild from the first week of May it looks like.",
        "createdAt": "2021-05-14T21:18:34Z",
        "author": {
          "login": "marcpopMSFT"
        }
      },
      {
        "body": "Hey @reduckted , thanks for a really nice contribution!\r\n\r\nQuick question: is this supposed to work for F# projects as well?",
        "createdAt": "2021-09-18T15:15:55Z",
        "author": {
          "login": "Crono1981"
        }
      },
      {
        "body": "@Crono1981 Good question! I just had a look into it, and no, it doesn't work for F#. It looks like F# has [its own `WriteCodeFragment` task](https://github.com/dotnet/fsharp/blob/dbf9a625d3188184ecb787a536ddb85a4ea7a587/src/fsharp/FSharp.Build/WriteCodeFragment.fs) that's based on an older version of this task.",
        "createdAt": "2021-09-19T00:35:08Z",
        "author": {
          "login": "reduckted"
        }
      },
      {
        "body": "@reduckted I see. I'll document my plugin accordingly. Thanks for confirming.",
        "createdAt": "2021-09-19T22:38:31Z",
        "author": {
          "login": "Crono1981"
        }
      },
      {
        "body": "Is this feature documented anywhere at learn.microsoft.com? It was rather non-trivial to find this implementation, but I couldn't find any public docs for it.",
        "createdAt": "2023-06-29T00:03:29Z",
        "author": {
          "login": "RussKie"
        }
      },
      {
        "body": "@RussKie good catch: https://github.com/MicrosoftDocs/visualstudio-docs/issues/9379.",
        "createdAt": "2023-06-29T14:29:38Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@rainersigwald Your link is dead. [The docs](https://learn.microsoft.com/en-us/dotnet/standard/assembly/set-attributes-project-file#set-arbitrary-attributes) are still missing most of this.\r\n\r\nHere are some things I learned from experimenting with the feature:\r\n- If you make a typo in the attribute class' qualified name, the error you get suggests you've made a typo in the param name\r\n- `*_TypeName` feels redundant when it doesn't work sometimes (enums? non-BCL?) and `*_IsLiteral` is always shorter\r\n- It seems only property initialisation can use the shorter syntax of (XML) attributes on `<AssemblyAttribute/>`, positional arguments must be as child elements\r\n- edit: And it seems you can't apply an attribute multiple times, which makes sense since it's an 'item'",
        "createdAt": "2024-05-09T17:30:47Z",
        "author": {
          "login": "YoshiRulz"
        }
      },
      {
        "body": "@YoshiRulz \r\nWe added some examples to the WriteCodeFragment task article to address this:\r\nhttps://learn.microsoft.com/en-us/visualstudio/msbuild/writecodefragment-task?view=vs-2022\r\n\r\nRainer's link unfortunately isn't working since the Visual Studio repo no longer supports the Issues functionality, but before the issues got shut down, I fixed by adding a section in that article that discusses this.\r\n\r\nMaybe this information should also be added to the .NET article you linked to. Those are open-source docs, so it could be submitted as an issue or PR in those docs.\r\n",
        "createdAt": "2024-05-09T18:45:06Z",
        "author": {
          "login": "ghogen"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "If you save off the list of keys ahead of time, you can iterate over that and avoid allocating as much. I'm not sure which I like better, though, since I also like iterating over kvps.",
              "createdAt": "2021-03-29T14:45:22Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "\ud83e\udd14 Looking at this again, it might be better to delay-create `keysToRemove`. The most common case will surely be not having any special keys, since that was the original usage. That means most of the time the list will be created for no reason.",
              "createdAt": "2021-04-03T11:04:50Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();",
              "author": {
                "login": "reduckted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nThis could be cleaner with the pattern:\r\nCodeExpression value = parameter.Type.Kind switch\r\n{\r\n    ParameterTypeKind.Literal => new CodeSnippetExpression(parameter.Value),\r\n    ParameterTypeKind.Typed => parameter.Type.TypeName.Equals(\"System.Type\") ?\r\n...\r\n}",
              "createdAt": "2021-03-29T14:52:21Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();\n+\n+            foreach (DictionaryEntry entry in customMetadata)\n+            {\n+                string key = (string)entry.Key;\n+                string value = (string)entry.Value;\n+\n+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);\n+\n+                    // To remain as backward-compatible as possible, we will only treat this metadata\n+                    // item as a type name if there's a corresponding metadata item for the parameter.\n+                    // This is done to avoid the very small chance of treating \"Foo_TypeName\" as a\n+                    // type indicator when it was previously being used as a named attribute parameter.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // The parameter will have an explicit type. The metadata value is the type name.\n+                        parameterTypes[parameterNameKey] = new ParameterType {\n+                            Kind = ParameterTypeKind.Typed,\n+                            TypeName = value\n+                        };\n+                    }\n+                }\n+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);\n+\n+                    // As mentioned above for the type name metadata, we will only treat\n+                    // this metadata item as a literal flag if there's a corresponding\n+                    // metadata item for the parameter for backward-compatibility reasons.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // If the value is true, the parameter value will be the exact code\n+                        // that needs to be written to the generated file for that parameter.\n+                        if (string.Equals(value, \"true\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            parameterTypes[parameterNameKey] = new ParameterType {\n+                                Kind = ParameterTypeKind.Literal\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Remove any metadata items that we used\n+            // for type names or literal flags.\n+            foreach (var key in keysToRemove)\n+            {\n+                customMetadata.Remove(key);\n+            }\n+\n+            return parameterTypes;\n+        }\n+\n+        /// <summary>\n+        /// Uses the given parameters to add CodeDom arguments to the given attribute.\n+        /// Returns true if the arguments could be defined, or false if the values could\n+        /// not be converted to the required type. An error is also logged for failures.\n+        /// </summary>\n+        private bool AddArguments(\n+            CodeAttributeDeclaration attribute,\n+            Lazy<Type> attributeType,\n+            IReadOnlyList<AttributeParameter> parameters,\n+            bool isPositional\n+        )\n+        {\n+            Type[] constructorParameterTypes = null;\n+\n+            for (int i = 0; i < parameters.Count; i++)\n+            {\n+                AttributeParameter parameter = parameters[i];\n+                CodeExpression value;\n+\n+                switch (parameter.Type.Kind)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I'm not sure this is possible because the case for `ParameterTypeKind.Typed` can return false instead of setting `value`.",
              "createdAt": "2021-04-03T12:38:40Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();\n+\n+            foreach (DictionaryEntry entry in customMetadata)\n+            {\n+                string key = (string)entry.Key;\n+                string value = (string)entry.Value;\n+\n+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);\n+\n+                    // To remain as backward-compatible as possible, we will only treat this metadata\n+                    // item as a type name if there's a corresponding metadata item for the parameter.\n+                    // This is done to avoid the very small chance of treating \"Foo_TypeName\" as a\n+                    // type indicator when it was previously being used as a named attribute parameter.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // The parameter will have an explicit type. The metadata value is the type name.\n+                        parameterTypes[parameterNameKey] = new ParameterType {\n+                            Kind = ParameterTypeKind.Typed,\n+                            TypeName = value\n+                        };\n+                    }\n+                }\n+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);\n+\n+                    // As mentioned above for the type name metadata, we will only treat\n+                    // this metadata item as a literal flag if there's a corresponding\n+                    // metadata item for the parameter for backward-compatibility reasons.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // If the value is true, the parameter value will be the exact code\n+                        // that needs to be written to the generated file for that parameter.\n+                        if (string.Equals(value, \"true\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            parameterTypes[parameterNameKey] = new ParameterType {\n+                                Kind = ParameterTypeKind.Literal\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Remove any metadata items that we used\n+            // for type names or literal flags.\n+            foreach (var key in keysToRemove)\n+            {\n+                customMetadata.Remove(key);\n+            }\n+\n+            return parameterTypes;\n+        }\n+\n+        /// <summary>\n+        /// Uses the given parameters to add CodeDom arguments to the given attribute.\n+        /// Returns true if the arguments could be defined, or false if the values could\n+        /// not be converted to the required type. An error is also logged for failures.\n+        /// </summary>\n+        private bool AddArguments(\n+            CodeAttributeDeclaration attribute,\n+            Lazy<Type> attributeType,\n+            IReadOnlyList<AttributeParameter> parameters,\n+            bool isPositional\n+        )\n+        {\n+            Type[] constructorParameterTypes = null;\n+\n+            for (int i = 0; i < parameters.Count; i++)\n+            {\n+                AttributeParameter parameter = parameters[i];\n+                CodeExpression value;\n+\n+                switch (parameter.Type.Kind)",
              "author": {
                "login": "reduckted"
              }
            },
            {
              "body": "For the return false case, you had previously called `TryConvertParameterValue(parameter.Type.TypeName, parameter.Value, out value)`, which would set value.",
              "createdAt": "2021-04-03T12:58:34Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();\n+\n+            foreach (DictionaryEntry entry in customMetadata)\n+            {\n+                string key = (string)entry.Key;\n+                string value = (string)entry.Value;\n+\n+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);\n+\n+                    // To remain as backward-compatible as possible, we will only treat this metadata\n+                    // item as a type name if there's a corresponding metadata item for the parameter.\n+                    // This is done to avoid the very small chance of treating \"Foo_TypeName\" as a\n+                    // type indicator when it was previously being used as a named attribute parameter.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // The parameter will have an explicit type. The metadata value is the type name.\n+                        parameterTypes[parameterNameKey] = new ParameterType {\n+                            Kind = ParameterTypeKind.Typed,\n+                            TypeName = value\n+                        };\n+                    }\n+                }\n+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);\n+\n+                    // As mentioned above for the type name metadata, we will only treat\n+                    // this metadata item as a literal flag if there's a corresponding\n+                    // metadata item for the parameter for backward-compatibility reasons.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // If the value is true, the parameter value will be the exact code\n+                        // that needs to be written to the generated file for that parameter.\n+                        if (string.Equals(value, \"true\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            parameterTypes[parameterNameKey] = new ParameterType {\n+                                Kind = ParameterTypeKind.Literal\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Remove any metadata items that we used\n+            // for type names or literal flags.\n+            foreach (var key in keysToRemove)\n+            {\n+                customMetadata.Remove(key);\n+            }\n+\n+            return parameterTypes;\n+        }\n+\n+        /// <summary>\n+        /// Uses the given parameters to add CodeDom arguments to the given attribute.\n+        /// Returns true if the arguments could be defined, or false if the values could\n+        /// not be converted to the required type. An error is also logged for failures.\n+        /// </summary>\n+        private bool AddArguments(\n+            CodeAttributeDeclaration attribute,\n+            Lazy<Type> attributeType,\n+            IReadOnlyList<AttributeParameter> parameters,\n+            bool isPositional\n+        )\n+        {\n+            Type[] constructorParameterTypes = null;\n+\n+            for (int i = 0; i < parameters.Count; i++)\n+            {\n+                AttributeParameter parameter = parameters[i];\n+                CodeExpression value;\n+\n+                switch (parameter.Type.Kind)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The default case causes problems here because it delays finding the positional parameters until they are needed, and that can't (as far as I'm aware) be put in a switch expression. This could be worked around using a `Lazy<Type[]>` for the positional parameter types, but that would result in an allocation that _could_ be avoided in some situations.\r\n\r\nI'm happy to go ahead and make that change, but just thought I would check if it's worth the extra allocation. \ud83d\ude04 ",
              "createdAt": "2021-04-04T04:55:26Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();\n+\n+            foreach (DictionaryEntry entry in customMetadata)\n+            {\n+                string key = (string)entry.Key;\n+                string value = (string)entry.Value;\n+\n+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);\n+\n+                    // To remain as backward-compatible as possible, we will only treat this metadata\n+                    // item as a type name if there's a corresponding metadata item for the parameter.\n+                    // This is done to avoid the very small chance of treating \"Foo_TypeName\" as a\n+                    // type indicator when it was previously being used as a named attribute parameter.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // The parameter will have an explicit type. The metadata value is the type name.\n+                        parameterTypes[parameterNameKey] = new ParameterType {\n+                            Kind = ParameterTypeKind.Typed,\n+                            TypeName = value\n+                        };\n+                    }\n+                }\n+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);\n+\n+                    // As mentioned above for the type name metadata, we will only treat\n+                    // this metadata item as a literal flag if there's a corresponding\n+                    // metadata item for the parameter for backward-compatibility reasons.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // If the value is true, the parameter value will be the exact code\n+                        // that needs to be written to the generated file for that parameter.\n+                        if (string.Equals(value, \"true\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            parameterTypes[parameterNameKey] = new ParameterType {\n+                                Kind = ParameterTypeKind.Literal\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Remove any metadata items that we used\n+            // for type names or literal flags.\n+            foreach (var key in keysToRemove)\n+            {\n+                customMetadata.Remove(key);\n+            }\n+\n+            return parameterTypes;\n+        }\n+\n+        /// <summary>\n+        /// Uses the given parameters to add CodeDom arguments to the given attribute.\n+        /// Returns true if the arguments could be defined, or false if the values could\n+        /// not be converted to the required type. An error is also logged for failures.\n+        /// </summary>\n+        private bool AddArguments(\n+            CodeAttributeDeclaration attribute,\n+            Lazy<Type> attributeType,\n+            IReadOnlyList<AttributeParameter> parameters,\n+            bool isPositional\n+        )\n+        {\n+            Type[] constructorParameterTypes = null;\n+\n+            for (int i = 0; i < parameters.Count; i++)\n+            {\n+                AttributeParameter parameter = parameters[i];\n+                CodeExpression value;\n+\n+                switch (parameter.Type.Kind)",
              "author": {
                "login": "reduckted"
              }
            },
            {
              "body": "I was thinking something like:\r\n```C#\r\nint t = 0;\r\nchar[] b = null;\r\nint k = t switch\r\n{\r\n        2 => 3,\r\n         _ => otherFunc((b = b is null ? new char[] { 'A', 'B' } : b)[0])\r\n};\r\n```\r\n\r\nThat's a little messy, but I think it would be cleaner. Probably have to write out everything to see for sure, and if you are happy with it this way, I am, too.",
              "createdAt": "2021-04-05T19:28:44Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();\n+\n+            foreach (DictionaryEntry entry in customMetadata)\n+            {\n+                string key = (string)entry.Key;\n+                string value = (string)entry.Value;\n+\n+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);\n+\n+                    // To remain as backward-compatible as possible, we will only treat this metadata\n+                    // item as a type name if there's a corresponding metadata item for the parameter.\n+                    // This is done to avoid the very small chance of treating \"Foo_TypeName\" as a\n+                    // type indicator when it was previously being used as a named attribute parameter.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // The parameter will have an explicit type. The metadata value is the type name.\n+                        parameterTypes[parameterNameKey] = new ParameterType {\n+                            Kind = ParameterTypeKind.Typed,\n+                            TypeName = value\n+                        };\n+                    }\n+                }\n+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);\n+\n+                    // As mentioned above for the type name metadata, we will only treat\n+                    // this metadata item as a literal flag if there's a corresponding\n+                    // metadata item for the parameter for backward-compatibility reasons.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // If the value is true, the parameter value will be the exact code\n+                        // that needs to be written to the generated file for that parameter.\n+                        if (string.Equals(value, \"true\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            parameterTypes[parameterNameKey] = new ParameterType {\n+                                Kind = ParameterTypeKind.Literal\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Remove any metadata items that we used\n+            // for type names or literal flags.\n+            foreach (var key in keysToRemove)\n+            {\n+                customMetadata.Remove(key);\n+            }\n+\n+            return parameterTypes;\n+        }\n+\n+        /// <summary>\n+        /// Uses the given parameters to add CodeDom arguments to the given attribute.\n+        /// Returns true if the arguments could be defined, or false if the values could\n+        /// not be converted to the required type. An error is also logged for failures.\n+        /// </summary>\n+        private bool AddArguments(\n+            CodeAttributeDeclaration attribute,\n+            Lazy<Type> attributeType,\n+            IReadOnlyList<AttributeParameter> parameters,\n+            bool isPositional\n+        )\n+        {\n+            Type[] constructorParameterTypes = null;\n+\n+            for (int i = 0; i < parameters.Count; i++)\n+            {\n+                AttributeParameter parameter = parameters[i];\n+                CodeExpression value;\n+\n+                switch (parameter.Type.Kind)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could this throw with an invalid type?",
              "createdAt": "2021-03-29T17:30:18Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -221,12 +238,24 @@ private string GenerateCode(out string extension)\n                         return null;\n                     }\n \n-                    attribute.Arguments.Add(orderedParameters[i]);\n+                    providedOrderedParameters.Add(orderedParameters[i].Value);\n                 }\n \n-                foreach (CodeAttributeArgument namedParameter in namedParameters)\n+                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));\n+\n+                // We might need the type of the attribute if we need to infer the\n+                // types of the parameters. Search for it by the given type name,\n+                // as well as within the namespaces that we automatically import.\n+                Lazy<Type> attributeType = new(\n+                    () => Type.GetType(attribute.Name) ?? NamespaceImports.Select(x => Type.GetType($\"{x}.{attribute.Name}\")).FirstOrDefault(),",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`Type.GetType(string)` will return null if the type is not found. There's an overload that takes a boolean, which lets you specify whether to throw an exception if the type is not found. If you'd prefer, I could change it to call that overload and pass false, which would make this more readable.\r\n\r\n```csharp\r\nType.GetType(typeName, throwOnError: false)\r\n```",
              "createdAt": "2021-04-03T11:03:11Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -221,12 +238,24 @@ private string GenerateCode(out string extension)\n                         return null;\n                     }\n \n-                    attribute.Arguments.Add(orderedParameters[i]);\n+                    providedOrderedParameters.Add(orderedParameters[i].Value);\n                 }\n \n-                foreach (CodeAttributeArgument namedParameter in namedParameters)\n+                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));\n+\n+                // We might need the type of the attribute if we need to infer the\n+                // types of the parameters. Search for it by the given type name,\n+                // as well as within the namespaces that we automatically import.\n+                Lazy<Type> attributeType = new(\n+                    () => Type.GetType(attribute.Name) ?? NamespaceImports.Select(x => Type.GetType($\"{x}.{attribute.Name}\")).FirstOrDefault(),",
              "author": {
                "login": "reduckted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n                // Find the constructors with the same number\r\n                // of parameters as we will be specifying.\r\n                List<Type[]>candidates = attributeType\r\n                    .GetConstructors()\r\n                    .Select(c => c.GetParameters().Select(p => p.ParameterType).ToArray())\r\n                    .Where(t => t.Length == positionalParameters.Count)\r\n                    .ToList();\r\n```",
              "createdAt": "2021-03-29T17:33:04Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();\n+\n+            foreach (DictionaryEntry entry in customMetadata)\n+            {\n+                string key = (string)entry.Key;\n+                string value = (string)entry.Value;\n+\n+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);\n+\n+                    // To remain as backward-compatible as possible, we will only treat this metadata\n+                    // item as a type name if there's a corresponding metadata item for the parameter.\n+                    // This is done to avoid the very small chance of treating \"Foo_TypeName\" as a\n+                    // type indicator when it was previously being used as a named attribute parameter.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // The parameter will have an explicit type. The metadata value is the type name.\n+                        parameterTypes[parameterNameKey] = new ParameterType {\n+                            Kind = ParameterTypeKind.Typed,\n+                            TypeName = value\n+                        };\n+                    }\n+                }\n+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);\n+\n+                    // As mentioned above for the type name metadata, we will only treat\n+                    // this metadata item as a literal flag if there's a corresponding\n+                    // metadata item for the parameter for backward-compatibility reasons.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // If the value is true, the parameter value will be the exact code\n+                        // that needs to be written to the generated file for that parameter.\n+                        if (string.Equals(value, \"true\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            parameterTypes[parameterNameKey] = new ParameterType {\n+                                Kind = ParameterTypeKind.Literal\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Remove any metadata items that we used\n+            // for type names or literal flags.\n+            foreach (var key in keysToRemove)\n+            {\n+                customMetadata.Remove(key);\n+            }\n+\n+            return parameterTypes;\n+        }\n+\n+        /// <summary>\n+        /// Uses the given parameters to add CodeDom arguments to the given attribute.\n+        /// Returns true if the arguments could be defined, or false if the values could\n+        /// not be converted to the required type. An error is also logged for failures.\n+        /// </summary>\n+        private bool AddArguments(\n+            CodeAttributeDeclaration attribute,\n+            Lazy<Type> attributeType,\n+            IReadOnlyList<AttributeParameter> parameters,\n+            bool isPositional\n+        )\n+        {\n+            Type[] constructorParameterTypes = null;\n+\n+            for (int i = 0; i < parameters.Count; i++)\n+            {\n+                AttributeParameter parameter = parameters[i];\n+                CodeExpression value;\n+\n+                switch (parameter.Type.Kind)\n+                {\n+                    case ParameterTypeKind.Literal:\n+                        // The exact value provided by the metadata is what we use.\n+                        // Note that this value is used verbatim, so its the user's\n+                        // responsibility to ensure that it is in the correct language.\n+                        value = new CodeSnippetExpression(parameter.Value);\n+                        break;\n+\n+                    case ParameterTypeKind.Typed:\n+                        if (string.Equals(parameter.Type.TypeName, \"System.Type\"))\n+                        {\n+                            // Types are a special case, because we can't convert a string to a\n+                            // type, but because we're using the CodeDom, we don't need to\n+                            // convert it. we can just create a type expression.\n+                            value = new CodeTypeOfExpression(parameter.Value);\n+                        }\n+                        else\n+                        {\n+                            // We've been told what type this parameter needs to be.\n+                            // If we cannot convert the value to that type, then we need to fail.\n+                            if (!TryConvertParameterValue(parameter.Type.TypeName, parameter.Value, out value))\n+                            {\n+                                return false;\n+                            }\n+                        }\n+\n+                        break;\n+\n+                    default:\n+                        if (isPositional)\n+                        {\n+                            // For positional parameters, infer the type\n+                            // using the constructor argument types.\n+                            if (constructorParameterTypes is null)\n+                            {\n+                                constructorParameterTypes = FindPositionalParameterTypes(attributeType.Value, parameters);\n+                            }\n+\n+                            value = ConvertParameterValueToInferredType(\n+                                constructorParameterTypes[i],\n+                                parameter.Value,\n+                                $\"#{i + 1}\" /* back to 1 based */\n+                            );\n+                        }\n+                        else\n+                        {\n+                            // For named parameters, use the type of the property if we can find it.\n+                            value = ConvertParameterValueToInferredType(\n+                                attributeType.Value?.GetProperty(parameter.Name)?.PropertyType,\n+                                parameter.Value,\n+                                parameter.Name\n+                            );\n+                        }\n+\n+                        break;\n+\n+                }\n+\n+                attribute.Arguments.Add(new CodeAttributeArgument(parameter.Name, value));\n+            }\n+\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// Finds the types that the parameters are likely to be, by finding a constructor\n+        /// on the attribute that has the same number of parameters that have been provided.\n+        /// Returns an array of types with a length equal to the number of positional parameters.\n+        /// If no suitable constructor is found, the array will contain null types.\n+        /// </summary>\n+        private Type[] FindPositionalParameterTypes(Type attributeType, IReadOnlyList<AttributeParameter> positionalParameters)\n+        {\n+            // The attribute type might not be known.\n+            if (attributeType is not null)\n+            {\n+                List<Type[]> candidates;\n+\n+                // Find the constructors with the same number\n+                // of parameters as we will be specifying.\n+                candidates = attributeType\n+                    .GetConstructors()\n+                    .Select(c => c.GetParameters().Select(p => p.ParameterType).ToArray())\n+                    .Where(t => t.Length == positionalParameters.Count)\n+                    .ToList();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't understand this part. Are there multiple equally valid constructors, as long as there is no constructor of the right length with only string parameters? Is there some way of figuring out which constructor we should prefer?",
              "createdAt": "2021-03-29T17:39:19Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();\n+\n+            foreach (DictionaryEntry entry in customMetadata)\n+            {\n+                string key = (string)entry.Key;\n+                string value = (string)entry.Value;\n+\n+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);\n+\n+                    // To remain as backward-compatible as possible, we will only treat this metadata\n+                    // item as a type name if there's a corresponding metadata item for the parameter.\n+                    // This is done to avoid the very small chance of treating \"Foo_TypeName\" as a\n+                    // type indicator when it was previously being used as a named attribute parameter.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // The parameter will have an explicit type. The metadata value is the type name.\n+                        parameterTypes[parameterNameKey] = new ParameterType {\n+                            Kind = ParameterTypeKind.Typed,\n+                            TypeName = value\n+                        };\n+                    }\n+                }\n+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);\n+\n+                    // As mentioned above for the type name metadata, we will only treat\n+                    // this metadata item as a literal flag if there's a corresponding\n+                    // metadata item for the parameter for backward-compatibility reasons.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // If the value is true, the parameter value will be the exact code\n+                        // that needs to be written to the generated file for that parameter.\n+                        if (string.Equals(value, \"true\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            parameterTypes[parameterNameKey] = new ParameterType {\n+                                Kind = ParameterTypeKind.Literal\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Remove any metadata items that we used\n+            // for type names or literal flags.\n+            foreach (var key in keysToRemove)\n+            {\n+                customMetadata.Remove(key);\n+            }\n+\n+            return parameterTypes;\n+        }\n+\n+        /// <summary>\n+        /// Uses the given parameters to add CodeDom arguments to the given attribute.\n+        /// Returns true if the arguments could be defined, or false if the values could\n+        /// not be converted to the required type. An error is also logged for failures.\n+        /// </summary>\n+        private bool AddArguments(\n+            CodeAttributeDeclaration attribute,\n+            Lazy<Type> attributeType,\n+            IReadOnlyList<AttributeParameter> parameters,\n+            bool isPositional\n+        )\n+        {\n+            Type[] constructorParameterTypes = null;\n+\n+            for (int i = 0; i < parameters.Count; i++)\n+            {\n+                AttributeParameter parameter = parameters[i];\n+                CodeExpression value;\n+\n+                switch (parameter.Type.Kind)\n+                {\n+                    case ParameterTypeKind.Literal:\n+                        // The exact value provided by the metadata is what we use.\n+                        // Note that this value is used verbatim, so its the user's\n+                        // responsibility to ensure that it is in the correct language.\n+                        value = new CodeSnippetExpression(parameter.Value);\n+                        break;\n+\n+                    case ParameterTypeKind.Typed:\n+                        if (string.Equals(parameter.Type.TypeName, \"System.Type\"))\n+                        {\n+                            // Types are a special case, because we can't convert a string to a\n+                            // type, but because we're using the CodeDom, we don't need to\n+                            // convert it. we can just create a type expression.\n+                            value = new CodeTypeOfExpression(parameter.Value);\n+                        }\n+                        else\n+                        {\n+                            // We've been told what type this parameter needs to be.\n+                            // If we cannot convert the value to that type, then we need to fail.\n+                            if (!TryConvertParameterValue(parameter.Type.TypeName, parameter.Value, out value))\n+                            {\n+                                return false;\n+                            }\n+                        }\n+\n+                        break;\n+\n+                    default:\n+                        if (isPositional)\n+                        {\n+                            // For positional parameters, infer the type\n+                            // using the constructor argument types.\n+                            if (constructorParameterTypes is null)\n+                            {\n+                                constructorParameterTypes = FindPositionalParameterTypes(attributeType.Value, parameters);\n+                            }\n+\n+                            value = ConvertParameterValueToInferredType(\n+                                constructorParameterTypes[i],\n+                                parameter.Value,\n+                                $\"#{i + 1}\" /* back to 1 based */\n+                            );\n+                        }\n+                        else\n+                        {\n+                            // For named parameters, use the type of the property if we can find it.\n+                            value = ConvertParameterValueToInferredType(\n+                                attributeType.Value?.GetProperty(parameter.Name)?.PropertyType,\n+                                parameter.Value,\n+                                parameter.Name\n+                            );\n+                        }\n+\n+                        break;\n+\n+                }\n+\n+                attribute.Arguments.Add(new CodeAttributeArgument(parameter.Name, value));\n+            }\n+\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// Finds the types that the parameters are likely to be, by finding a constructor\n+        /// on the attribute that has the same number of parameters that have been provided.\n+        /// Returns an array of types with a length equal to the number of positional parameters.\n+        /// If no suitable constructor is found, the array will contain null types.\n+        /// </summary>\n+        private Type[] FindPositionalParameterTypes(Type attributeType, IReadOnlyList<AttributeParameter> positionalParameters)\n+        {\n+            // The attribute type might not be known.\n+            if (attributeType is not null)\n+            {\n+                List<Type[]> candidates;\n+\n+                // Find the constructors with the same number\n+                // of parameters as we will be specifying.\n+                candidates = attributeType\n+                    .GetConstructors()\n+                    .Select(c => c.GetParameters().Select(p => p.ParameterType).ToArray())\n+                    .Where(t => t.Length == positionalParameters.Count)\n+                    .ToList();\n+\n+                if (candidates.Count == 1)\n+                {\n+                    return candidates[0];\n+                }\n+                else if (candidates.Count > 1)\n+                {\n+                    Log.LogMessageFromResources(\"WriteCodeFragment.MultipleConstructorsFound\");\n+\n+                    // Before parameter types could be specified, all parameter values were\n+                    // treated as strings. To be backward-compatible, we need prefer the\n+                    // constructor that has all string parameters, if it exists.\n+                    var allStringParameters = candidates.FirstOrDefault(c => c.All(t => t == typeof(string)));\n+\n+                    if (allStringParameters is not null)\n+                    {\n+                        return allStringParameters;\n+                    }\n+\n+                    // There isn't a constructor where all parameters are strings, so we are free\n+                    // to pick one of the candidates. To ensure that we always select the same\n+                    // constructor, sort the candidates by type names, then pick the first one.\n+                    return candidates",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> Is there some way of figuring out which constructor we should prefer?\r\n\r\nPossibly, but it felt like overkill given how rarely this code path will be hit. We could:\r\n1. Look at other parameter types that _do_ have declared types and use them to select a constructor, but we're still not guaranteed to find a single constructor if we do that.\r\n2. We could see which type the parameter value \"looks like\". For example, `42` is numeric, so we could match it to the constructor that has a numeric type for that parameter. But again, we're still not guaranteed to find a single constructor.\r\n3. Just pick one and if it wasn't the correct one, then the consumer will need to declare the type of the parameter. \r\n\r\nI choose option three because it was the simplest, but also because this particular code path is very unlikely to be hit. The reason for that is how the attribute type is found. The [documentation](https://docs.microsoft.com/en-us/dotnet/api/system.type.gettype?view=net-5.0#System_Type_GetType_System_String_) for the `Type.GetType(string)` method says this about the `typeName` parameter:\r\n\r\n> The assembly-qualified name of the type to get. See `AssemblyQualifiedName`. _If the type is in the currently executing assembly or in mscorlib.dll/System.Private.CoreLib.dll, it is sufficient to supply the type name qualified by its namespace._\r\n\r\nBecause the attribute's type name needs to be used in code as the name of the attribute, that means an assembly-qualified name _cannot_ be used, which means the only attribute types that we can support are those that are found in this assembly (`Microsoft.Build.Tasks`) or in `mscorlib`. This assembly has no attributes that can be added to assemblies, which means the attributes can only come from `mscorlib`. \r\n\r\nLooking into `mscorlib` we find that:\r\n* There are 216 attributes currently defined in `mscorlib`.\r\n* 92 of those attributes can be added to assemblies.\r\n* Ignoring the default constructor, only 10 of those attributes have more than one constructor.\r\n* Excluding attributes that have a constructor with strings for every parameter leaves us with six attributes.\r\n* And from those attributes, if we only take attributes that have overloads with the same number of parameters, we are left with five attributes.\r\n\r\nThose attributes are:\r\n* `System.Reflection.AssemblyAlgorithmIdAttribute`\r\n* `System.Reflection.AssemblyFlagsAttribute`\r\n* `System.Runtime.CompilerServices.CompilationRelaxationsAttribute`\r\n* `System.Runtime.InteropServices.ClassInterfaceAttribute`\r\n* `System.Runtime.InteropServices.IDispatchImplAttribute`\r\n\r\nThe code I used to find these types is:\r\n```csharp\r\ntypeof(string)\r\n    .Assembly\r\n    .GetTypes()\r\n    .Where(t => typeof(Attribute).IsAssignableFrom(t))\r\n    .Where(t => ((AttributeUsageAttribute)t.GetCustomAttribute(typeof(AttributeUsageAttribute))).ValidOn.HasFlag(AttributeTargets.Assembly))\r\n    .Where(t => t.GetConstructors().Where(c => c.GetParameters().Length > 0).Count() > 1)\r\n    .Where(t => !t.GetConstructors().Any(c => c.GetParameters().All(p => p.ParameterType == typeof(string))))\r\n    .SelectMany(t => t.GetConstructors().Select(c => c.GetParameters().Select(p => p.ParameterType.Name)).ToArray(), (t, p) => new { Type = t, Parameters = p})\r\n    .GroupBy(x => new { x.Type, Parameters = x.Parameters.Count() })\r\n    .Where(g => g.Count() > 1)\r\n    .Select(g => new {g.Key.Type, Constructors = g.Select(x => string.Join(\", \", x.Parameters))})\r\n```\r\n\r\nSo for five attribute types, it didn't seem like it was worth the effort to do anything else. I should add a comment that briefly explains this reasoning.\r\n\r\nAs for why it's ordering them, that ensures that the _same_ constructor is always chosen, regardless of the order that the attributes are returned in from `attributeType.GetConstructors()`.",
              "createdAt": "2021-04-03T12:37:01Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();\n+\n+            foreach (DictionaryEntry entry in customMetadata)\n+            {\n+                string key = (string)entry.Key;\n+                string value = (string)entry.Value;\n+\n+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);\n+\n+                    // To remain as backward-compatible as possible, we will only treat this metadata\n+                    // item as a type name if there's a corresponding metadata item for the parameter.\n+                    // This is done to avoid the very small chance of treating \"Foo_TypeName\" as a\n+                    // type indicator when it was previously being used as a named attribute parameter.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // The parameter will have an explicit type. The metadata value is the type name.\n+                        parameterTypes[parameterNameKey] = new ParameterType {\n+                            Kind = ParameterTypeKind.Typed,\n+                            TypeName = value\n+                        };\n+                    }\n+                }\n+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);\n+\n+                    // As mentioned above for the type name metadata, we will only treat\n+                    // this metadata item as a literal flag if there's a corresponding\n+                    // metadata item for the parameter for backward-compatibility reasons.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // If the value is true, the parameter value will be the exact code\n+                        // that needs to be written to the generated file for that parameter.\n+                        if (string.Equals(value, \"true\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            parameterTypes[parameterNameKey] = new ParameterType {\n+                                Kind = ParameterTypeKind.Literal\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Remove any metadata items that we used\n+            // for type names or literal flags.\n+            foreach (var key in keysToRemove)\n+            {\n+                customMetadata.Remove(key);\n+            }\n+\n+            return parameterTypes;\n+        }\n+\n+        /// <summary>\n+        /// Uses the given parameters to add CodeDom arguments to the given attribute.\n+        /// Returns true if the arguments could be defined, or false if the values could\n+        /// not be converted to the required type. An error is also logged for failures.\n+        /// </summary>\n+        private bool AddArguments(\n+            CodeAttributeDeclaration attribute,\n+            Lazy<Type> attributeType,\n+            IReadOnlyList<AttributeParameter> parameters,\n+            bool isPositional\n+        )\n+        {\n+            Type[] constructorParameterTypes = null;\n+\n+            for (int i = 0; i < parameters.Count; i++)\n+            {\n+                AttributeParameter parameter = parameters[i];\n+                CodeExpression value;\n+\n+                switch (parameter.Type.Kind)\n+                {\n+                    case ParameterTypeKind.Literal:\n+                        // The exact value provided by the metadata is what we use.\n+                        // Note that this value is used verbatim, so its the user's\n+                        // responsibility to ensure that it is in the correct language.\n+                        value = new CodeSnippetExpression(parameter.Value);\n+                        break;\n+\n+                    case ParameterTypeKind.Typed:\n+                        if (string.Equals(parameter.Type.TypeName, \"System.Type\"))\n+                        {\n+                            // Types are a special case, because we can't convert a string to a\n+                            // type, but because we're using the CodeDom, we don't need to\n+                            // convert it. we can just create a type expression.\n+                            value = new CodeTypeOfExpression(parameter.Value);\n+                        }\n+                        else\n+                        {\n+                            // We've been told what type this parameter needs to be.\n+                            // If we cannot convert the value to that type, then we need to fail.\n+                            if (!TryConvertParameterValue(parameter.Type.TypeName, parameter.Value, out value))\n+                            {\n+                                return false;\n+                            }\n+                        }\n+\n+                        break;\n+\n+                    default:\n+                        if (isPositional)\n+                        {\n+                            // For positional parameters, infer the type\n+                            // using the constructor argument types.\n+                            if (constructorParameterTypes is null)\n+                            {\n+                                constructorParameterTypes = FindPositionalParameterTypes(attributeType.Value, parameters);\n+                            }\n+\n+                            value = ConvertParameterValueToInferredType(\n+                                constructorParameterTypes[i],\n+                                parameter.Value,\n+                                $\"#{i + 1}\" /* back to 1 based */\n+                            );\n+                        }\n+                        else\n+                        {\n+                            // For named parameters, use the type of the property if we can find it.\n+                            value = ConvertParameterValueToInferredType(\n+                                attributeType.Value?.GetProperty(parameter.Name)?.PropertyType,\n+                                parameter.Value,\n+                                parameter.Name\n+                            );\n+                        }\n+\n+                        break;\n+\n+                }\n+\n+                attribute.Arguments.Add(new CodeAttributeArgument(parameter.Name, value));\n+            }\n+\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// Finds the types that the parameters are likely to be, by finding a constructor\n+        /// on the attribute that has the same number of parameters that have been provided.\n+        /// Returns an array of types with a length equal to the number of positional parameters.\n+        /// If no suitable constructor is found, the array will contain null types.\n+        /// </summary>\n+        private Type[] FindPositionalParameterTypes(Type attributeType, IReadOnlyList<AttributeParameter> positionalParameters)\n+        {\n+            // The attribute type might not be known.\n+            if (attributeType is not null)\n+            {\n+                List<Type[]> candidates;\n+\n+                // Find the constructors with the same number\n+                // of parameters as we will be specifying.\n+                candidates = attributeType\n+                    .GetConstructors()\n+                    .Select(c => c.GetParameters().Select(p => p.ParameterType).ToArray())\n+                    .Where(t => t.Length == positionalParameters.Count)\n+                    .ToList();\n+\n+                if (candidates.Count == 1)\n+                {\n+                    return candidates[0];\n+                }\n+                else if (candidates.Count > 1)\n+                {\n+                    Log.LogMessageFromResources(\"WriteCodeFragment.MultipleConstructorsFound\");\n+\n+                    // Before parameter types could be specified, all parameter values were\n+                    // treated as strings. To be backward-compatible, we need prefer the\n+                    // constructor that has all string parameters, if it exists.\n+                    var allStringParameters = candidates.FirstOrDefault(c => c.All(t => t == typeof(string)));\n+\n+                    if (allStringParameters is not null)\n+                    {\n+                        return allStringParameters;\n+                    }\n+\n+                    // There isn't a constructor where all parameters are strings, so we are free\n+                    // to pick one of the candidates. To ensure that we always select the same\n+                    // constructor, sort the candidates by type names, then pick the first one.\n+                    return candidates",
              "author": {
                "login": "reduckted"
              }
            },
            {
              "body": "Thank you for the explanation! That sounds reasonable to me. I didn't realize that case affected so few constructors.",
              "createdAt": "2021-04-05T19:30:44Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();\n+\n+            foreach (DictionaryEntry entry in customMetadata)\n+            {\n+                string key = (string)entry.Key;\n+                string value = (string)entry.Value;\n+\n+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);\n+\n+                    // To remain as backward-compatible as possible, we will only treat this metadata\n+                    // item as a type name if there's a corresponding metadata item for the parameter.\n+                    // This is done to avoid the very small chance of treating \"Foo_TypeName\" as a\n+                    // type indicator when it was previously being used as a named attribute parameter.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // The parameter will have an explicit type. The metadata value is the type name.\n+                        parameterTypes[parameterNameKey] = new ParameterType {\n+                            Kind = ParameterTypeKind.Typed,\n+                            TypeName = value\n+                        };\n+                    }\n+                }\n+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);\n+\n+                    // As mentioned above for the type name metadata, we will only treat\n+                    // this metadata item as a literal flag if there's a corresponding\n+                    // metadata item for the parameter for backward-compatibility reasons.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // If the value is true, the parameter value will be the exact code\n+                        // that needs to be written to the generated file for that parameter.\n+                        if (string.Equals(value, \"true\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            parameterTypes[parameterNameKey] = new ParameterType {\n+                                Kind = ParameterTypeKind.Literal\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Remove any metadata items that we used\n+            // for type names or literal flags.\n+            foreach (var key in keysToRemove)\n+            {\n+                customMetadata.Remove(key);\n+            }\n+\n+            return parameterTypes;\n+        }\n+\n+        /// <summary>\n+        /// Uses the given parameters to add CodeDom arguments to the given attribute.\n+        /// Returns true if the arguments could be defined, or false if the values could\n+        /// not be converted to the required type. An error is also logged for failures.\n+        /// </summary>\n+        private bool AddArguments(\n+            CodeAttributeDeclaration attribute,\n+            Lazy<Type> attributeType,\n+            IReadOnlyList<AttributeParameter> parameters,\n+            bool isPositional\n+        )\n+        {\n+            Type[] constructorParameterTypes = null;\n+\n+            for (int i = 0; i < parameters.Count; i++)\n+            {\n+                AttributeParameter parameter = parameters[i];\n+                CodeExpression value;\n+\n+                switch (parameter.Type.Kind)\n+                {\n+                    case ParameterTypeKind.Literal:\n+                        // The exact value provided by the metadata is what we use.\n+                        // Note that this value is used verbatim, so its the user's\n+                        // responsibility to ensure that it is in the correct language.\n+                        value = new CodeSnippetExpression(parameter.Value);\n+                        break;\n+\n+                    case ParameterTypeKind.Typed:\n+                        if (string.Equals(parameter.Type.TypeName, \"System.Type\"))\n+                        {\n+                            // Types are a special case, because we can't convert a string to a\n+                            // type, but because we're using the CodeDom, we don't need to\n+                            // convert it. we can just create a type expression.\n+                            value = new CodeTypeOfExpression(parameter.Value);\n+                        }\n+                        else\n+                        {\n+                            // We've been told what type this parameter needs to be.\n+                            // If we cannot convert the value to that type, then we need to fail.\n+                            if (!TryConvertParameterValue(parameter.Type.TypeName, parameter.Value, out value))\n+                            {\n+                                return false;\n+                            }\n+                        }\n+\n+                        break;\n+\n+                    default:\n+                        if (isPositional)\n+                        {\n+                            // For positional parameters, infer the type\n+                            // using the constructor argument types.\n+                            if (constructorParameterTypes is null)\n+                            {\n+                                constructorParameterTypes = FindPositionalParameterTypes(attributeType.Value, parameters);\n+                            }\n+\n+                            value = ConvertParameterValueToInferredType(\n+                                constructorParameterTypes[i],\n+                                parameter.Value,\n+                                $\"#{i + 1}\" /* back to 1 based */\n+                            );\n+                        }\n+                        else\n+                        {\n+                            // For named parameters, use the type of the property if we can find it.\n+                            value = ConvertParameterValueToInferredType(\n+                                attributeType.Value?.GetProperty(parameter.Name)?.PropertyType,\n+                                parameter.Value,\n+                                parameter.Name\n+                            );\n+                        }\n+\n+                        break;\n+\n+                }\n+\n+                attribute.Arguments.Add(new CodeAttributeArgument(parameter.Name, value));\n+            }\n+\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// Finds the types that the parameters are likely to be, by finding a constructor\n+        /// on the attribute that has the same number of parameters that have been provided.\n+        /// Returns an array of types with a length equal to the number of positional parameters.\n+        /// If no suitable constructor is found, the array will contain null types.\n+        /// </summary>\n+        private Type[] FindPositionalParameterTypes(Type attributeType, IReadOnlyList<AttributeParameter> positionalParameters)\n+        {\n+            // The attribute type might not be known.\n+            if (attributeType is not null)\n+            {\n+                List<Type[]> candidates;\n+\n+                // Find the constructors with the same number\n+                // of parameters as we will be specifying.\n+                candidates = attributeType\n+                    .GetConstructors()\n+                    .Select(c => c.GetParameters().Select(p => p.ParameterType).ToArray())\n+                    .Where(t => t.Length == positionalParameters.Count)\n+                    .ToList();\n+\n+                if (candidates.Count == 1)\n+                {\n+                    return candidates[0];\n+                }\n+                else if (candidates.Count > 1)\n+                {\n+                    Log.LogMessageFromResources(\"WriteCodeFragment.MultipleConstructorsFound\");\n+\n+                    // Before parameter types could be specified, all parameter values were\n+                    // treated as strings. To be backward-compatible, we need prefer the\n+                    // constructor that has all string parameters, if it exists.\n+                    var allStringParameters = candidates.FirstOrDefault(c => c.All(t => t == typeof(string)));\n+\n+                    if (allStringParameters is not null)\n+                    {\n+                        return allStringParameters;\n+                    }\n+\n+                    // There isn't a constructor where all parameters are strings, so we are free\n+                    // to pick one of the candidates. To ensure that we always select the same\n+                    // constructor, sort the candidates by type names, then pick the first one.\n+                    return candidates",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can this throw?",
              "createdAt": "2021-03-29T17:40:33Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();\n+\n+            foreach (DictionaryEntry entry in customMetadata)\n+            {\n+                string key = (string)entry.Key;\n+                string value = (string)entry.Value;\n+\n+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);\n+\n+                    // To remain as backward-compatible as possible, we will only treat this metadata\n+                    // item as a type name if there's a corresponding metadata item for the parameter.\n+                    // This is done to avoid the very small chance of treating \"Foo_TypeName\" as a\n+                    // type indicator when it was previously being used as a named attribute parameter.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // The parameter will have an explicit type. The metadata value is the type name.\n+                        parameterTypes[parameterNameKey] = new ParameterType {\n+                            Kind = ParameterTypeKind.Typed,\n+                            TypeName = value\n+                        };\n+                    }\n+                }\n+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);\n+\n+                    // As mentioned above for the type name metadata, we will only treat\n+                    // this metadata item as a literal flag if there's a corresponding\n+                    // metadata item for the parameter for backward-compatibility reasons.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // If the value is true, the parameter value will be the exact code\n+                        // that needs to be written to the generated file for that parameter.\n+                        if (string.Equals(value, \"true\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            parameterTypes[parameterNameKey] = new ParameterType {\n+                                Kind = ParameterTypeKind.Literal\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Remove any metadata items that we used\n+            // for type names or literal flags.\n+            foreach (var key in keysToRemove)\n+            {\n+                customMetadata.Remove(key);\n+            }\n+\n+            return parameterTypes;\n+        }\n+\n+        /// <summary>\n+        /// Uses the given parameters to add CodeDom arguments to the given attribute.\n+        /// Returns true if the arguments could be defined, or false if the values could\n+        /// not be converted to the required type. An error is also logged for failures.\n+        /// </summary>\n+        private bool AddArguments(\n+            CodeAttributeDeclaration attribute,\n+            Lazy<Type> attributeType,\n+            IReadOnlyList<AttributeParameter> parameters,\n+            bool isPositional\n+        )\n+        {\n+            Type[] constructorParameterTypes = null;\n+\n+            for (int i = 0; i < parameters.Count; i++)\n+            {\n+                AttributeParameter parameter = parameters[i];\n+                CodeExpression value;\n+\n+                switch (parameter.Type.Kind)\n+                {\n+                    case ParameterTypeKind.Literal:\n+                        // The exact value provided by the metadata is what we use.\n+                        // Note that this value is used verbatim, so its the user's\n+                        // responsibility to ensure that it is in the correct language.\n+                        value = new CodeSnippetExpression(parameter.Value);\n+                        break;\n+\n+                    case ParameterTypeKind.Typed:\n+                        if (string.Equals(parameter.Type.TypeName, \"System.Type\"))\n+                        {\n+                            // Types are a special case, because we can't convert a string to a\n+                            // type, but because we're using the CodeDom, we don't need to\n+                            // convert it. we can just create a type expression.\n+                            value = new CodeTypeOfExpression(parameter.Value);\n+                        }\n+                        else\n+                        {\n+                            // We've been told what type this parameter needs to be.\n+                            // If we cannot convert the value to that type, then we need to fail.\n+                            if (!TryConvertParameterValue(parameter.Type.TypeName, parameter.Value, out value))\n+                            {\n+                                return false;\n+                            }\n+                        }\n+\n+                        break;\n+\n+                    default:\n+                        if (isPositional)\n+                        {\n+                            // For positional parameters, infer the type\n+                            // using the constructor argument types.\n+                            if (constructorParameterTypes is null)\n+                            {\n+                                constructorParameterTypes = FindPositionalParameterTypes(attributeType.Value, parameters);\n+                            }\n+\n+                            value = ConvertParameterValueToInferredType(\n+                                constructorParameterTypes[i],\n+                                parameter.Value,\n+                                $\"#{i + 1}\" /* back to 1 based */\n+                            );\n+                        }\n+                        else\n+                        {\n+                            // For named parameters, use the type of the property if we can find it.\n+                            value = ConvertParameterValueToInferredType(\n+                                attributeType.Value?.GetProperty(parameter.Name)?.PropertyType,\n+                                parameter.Value,\n+                                parameter.Name\n+                            );\n+                        }\n+\n+                        break;\n+\n+                }\n+\n+                attribute.Arguments.Add(new CodeAttributeArgument(parameter.Name, value));\n+            }\n+\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// Finds the types that the parameters are likely to be, by finding a constructor\n+        /// on the attribute that has the same number of parameters that have been provided.\n+        /// Returns an array of types with a length equal to the number of positional parameters.\n+        /// If no suitable constructor is found, the array will contain null types.\n+        /// </summary>\n+        private Type[] FindPositionalParameterTypes(Type attributeType, IReadOnlyList<AttributeParameter> positionalParameters)\n+        {\n+            // The attribute type might not be known.\n+            if (attributeType is not null)\n+            {\n+                List<Type[]> candidates;\n+\n+                // Find the constructors with the same number\n+                // of parameters as we will be specifying.\n+                candidates = attributeType\n+                    .GetConstructors()\n+                    .Select(c => c.GetParameters().Select(p => p.ParameterType).ToArray())\n+                    .Where(t => t.Length == positionalParameters.Count)\n+                    .ToList();\n+\n+                if (candidates.Count == 1)\n+                {\n+                    return candidates[0];\n+                }\n+                else if (candidates.Count > 1)\n+                {\n+                    Log.LogMessageFromResources(\"WriteCodeFragment.MultipleConstructorsFound\");\n+\n+                    // Before parameter types could be specified, all parameter values were\n+                    // treated as strings. To be backward-compatible, we need prefer the\n+                    // constructor that has all string parameters, if it exists.\n+                    var allStringParameters = candidates.FirstOrDefault(c => c.All(t => t == typeof(string)));\n+\n+                    if (allStringParameters is not null)\n+                    {\n+                        return allStringParameters;\n+                    }\n+\n+                    // There isn't a constructor where all parameters are strings, so we are free\n+                    // to pick one of the candidates. To ensure that we always select the same\n+                    // constructor, sort the candidates by type names, then pick the first one.\n+                    return candidates\n+                        .OrderBy(c => string.Join(\",\", c.Select(t => t.FullName)))\n+                        .First();\n+                }\n+            }\n+\n+            // If a matching constructor was not found, or we don't\n+            // know the attribute type, then return an array of null\n+            // types to indicate that each parameter type is unknown.\n+            return positionalParameters.Select(x => default(Type)).ToArray();\n+        }\n+\n+        /// <summary>\n+        /// Attempts to convert the raw value provided in the metadata to the type with the specified name.\n+        /// Returns true if conversion is successful. An error is logged and false is returned if the conversion fails.\n+        /// </summary>\n+        private bool TryConvertParameterValue(string typeName, string rawValue, out CodeExpression value)\n+        {\n+            var parameterType = Type.GetType(typeName);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`Type.GetType(string)` will return null if the type is not found.",
              "createdAt": "2021-04-03T12:39:48Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)\n             // as there's no point writing the file\n             return haveGeneratedContent ? code : String.Empty;\n         }\n+\n+        /// <summary>\n+        /// Finds the metadata items that are used to indicate the types of\n+        /// parameters, and removes those items from the given dictionary.\n+        /// Returns a dictionary that maps parameter names to their declared types.\n+        /// </summary>\n+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)\n+        {\n+            Dictionary<string, ParameterType> parameterTypes = new();\n+            List<string> keysToRemove = new();\n+\n+            foreach (DictionaryEntry entry in customMetadata)\n+            {\n+                string key = (string)entry.Key;\n+                string value = (string)entry.Value;\n+\n+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);\n+\n+                    // To remain as backward-compatible as possible, we will only treat this metadata\n+                    // item as a type name if there's a corresponding metadata item for the parameter.\n+                    // This is done to avoid the very small chance of treating \"Foo_TypeName\" as a\n+                    // type indicator when it was previously being used as a named attribute parameter.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // The parameter will have an explicit type. The metadata value is the type name.\n+                        parameterTypes[parameterNameKey] = new ParameterType {\n+                            Kind = ParameterTypeKind.Typed,\n+                            TypeName = value\n+                        };\n+                    }\n+                }\n+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // Remove the suffix to get the corresponding parameter name.\n+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);\n+\n+                    // As mentioned above for the type name metadata, we will only treat\n+                    // this metadata item as a literal flag if there's a corresponding\n+                    // metadata item for the parameter for backward-compatibility reasons.\n+                    if (customMetadata.Contains(parameterNameKey))\n+                    {\n+                        // Remove this metadata item so that\n+                        // we don't use it as a parameter name.\n+                        keysToRemove.Add(key);\n+\n+                        // If the value is true, the parameter value will be the exact code\n+                        // that needs to be written to the generated file for that parameter.\n+                        if (string.Equals(value, \"true\", StringComparison.OrdinalIgnoreCase))\n+                        {\n+                            parameterTypes[parameterNameKey] = new ParameterType {\n+                                Kind = ParameterTypeKind.Literal\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Remove any metadata items that we used\n+            // for type names or literal flags.\n+            foreach (var key in keysToRemove)\n+            {\n+                customMetadata.Remove(key);\n+            }\n+\n+            return parameterTypes;\n+        }\n+\n+        /// <summary>\n+        /// Uses the given parameters to add CodeDom arguments to the given attribute.\n+        /// Returns true if the arguments could be defined, or false if the values could\n+        /// not be converted to the required type. An error is also logged for failures.\n+        /// </summary>\n+        private bool AddArguments(\n+            CodeAttributeDeclaration attribute,\n+            Lazy<Type> attributeType,\n+            IReadOnlyList<AttributeParameter> parameters,\n+            bool isPositional\n+        )\n+        {\n+            Type[] constructorParameterTypes = null;\n+\n+            for (int i = 0; i < parameters.Count; i++)\n+            {\n+                AttributeParameter parameter = parameters[i];\n+                CodeExpression value;\n+\n+                switch (parameter.Type.Kind)\n+                {\n+                    case ParameterTypeKind.Literal:\n+                        // The exact value provided by the metadata is what we use.\n+                        // Note that this value is used verbatim, so its the user's\n+                        // responsibility to ensure that it is in the correct language.\n+                        value = new CodeSnippetExpression(parameter.Value);\n+                        break;\n+\n+                    case ParameterTypeKind.Typed:\n+                        if (string.Equals(parameter.Type.TypeName, \"System.Type\"))\n+                        {\n+                            // Types are a special case, because we can't convert a string to a\n+                            // type, but because we're using the CodeDom, we don't need to\n+                            // convert it. we can just create a type expression.\n+                            value = new CodeTypeOfExpression(parameter.Value);\n+                        }\n+                        else\n+                        {\n+                            // We've been told what type this parameter needs to be.\n+                            // If we cannot convert the value to that type, then we need to fail.\n+                            if (!TryConvertParameterValue(parameter.Type.TypeName, parameter.Value, out value))\n+                            {\n+                                return false;\n+                            }\n+                        }\n+\n+                        break;\n+\n+                    default:\n+                        if (isPositional)\n+                        {\n+                            // For positional parameters, infer the type\n+                            // using the constructor argument types.\n+                            if (constructorParameterTypes is null)\n+                            {\n+                                constructorParameterTypes = FindPositionalParameterTypes(attributeType.Value, parameters);\n+                            }\n+\n+                            value = ConvertParameterValueToInferredType(\n+                                constructorParameterTypes[i],\n+                                parameter.Value,\n+                                $\"#{i + 1}\" /* back to 1 based */\n+                            );\n+                        }\n+                        else\n+                        {\n+                            // For named parameters, use the type of the property if we can find it.\n+                            value = ConvertParameterValueToInferredType(\n+                                attributeType.Value?.GetProperty(parameter.Name)?.PropertyType,\n+                                parameter.Value,\n+                                parameter.Name\n+                            );\n+                        }\n+\n+                        break;\n+\n+                }\n+\n+                attribute.Arguments.Add(new CodeAttributeArgument(parameter.Name, value));\n+            }\n+\n+            return true;\n+        }\n+\n+        /// <summary>\n+        /// Finds the types that the parameters are likely to be, by finding a constructor\n+        /// on the attribute that has the same number of parameters that have been provided.\n+        /// Returns an array of types with a length equal to the number of positional parameters.\n+        /// If no suitable constructor is found, the array will contain null types.\n+        /// </summary>\n+        private Type[] FindPositionalParameterTypes(Type attributeType, IReadOnlyList<AttributeParameter> positionalParameters)\n+        {\n+            // The attribute type might not be known.\n+            if (attributeType is not null)\n+            {\n+                List<Type[]> candidates;\n+\n+                // Find the constructors with the same number\n+                // of parameters as we will be specifying.\n+                candidates = attributeType\n+                    .GetConstructors()\n+                    .Select(c => c.GetParameters().Select(p => p.ParameterType).ToArray())\n+                    .Where(t => t.Length == positionalParameters.Count)\n+                    .ToList();\n+\n+                if (candidates.Count == 1)\n+                {\n+                    return candidates[0];\n+                }\n+                else if (candidates.Count > 1)\n+                {\n+                    Log.LogMessageFromResources(\"WriteCodeFragment.MultipleConstructorsFound\");\n+\n+                    // Before parameter types could be specified, all parameter values were\n+                    // treated as strings. To be backward-compatible, we need prefer the\n+                    // constructor that has all string parameters, if it exists.\n+                    var allStringParameters = candidates.FirstOrDefault(c => c.All(t => t == typeof(string)));\n+\n+                    if (allStringParameters is not null)\n+                    {\n+                        return allStringParameters;\n+                    }\n+\n+                    // There isn't a constructor where all parameters are strings, so we are free\n+                    // to pick one of the candidates. To ensure that we always select the same\n+                    // constructor, sort the candidates by type names, then pick the first one.\n+                    return candidates\n+                        .OrderBy(c => string.Join(\",\", c.Select(t => t.FullName)))\n+                        .First();\n+                }\n+            }\n+\n+            // If a matching constructor was not found, or we don't\n+            // know the attribute type, then return an array of null\n+            // types to indicate that each parameter type is unknown.\n+            return positionalParameters.Select(x => default(Type)).ToArray();\n+        }\n+\n+        /// <summary>\n+        /// Attempts to convert the raw value provided in the metadata to the type with the specified name.\n+        /// Returns true if conversion is successful. An error is logged and false is returned if the conversion fails.\n+        /// </summary>\n+        private bool TryConvertParameterValue(string typeName, string rawValue, out CodeExpression value)\n+        {\n+            var parameterType = Type.GetType(typeName);",
              "author": {
                "login": "reduckted"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "mind adding the argument name for literals such as `true`?",
              "createdAt": "2021-04-04T18:31:46Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -221,12 +238,24 @@ private string GenerateCode(out string extension)\n                         return null;\n                     }\n \n-                    attribute.Arguments.Add(orderedParameters[i]);\n+                    providedOrderedParameters.Add(orderedParameters[i].Value);\n                 }\n \n-                foreach (CodeAttributeArgument namedParameter in namedParameters)\n+                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));\n+\n+                // We might need the type of the attribute if we need to infer the\n+                // types of the parameters. Search for it by the given type name,\n+                // as well as within the namespaces that we automatically import.\n+                Lazy<Type> attributeType = new(\n+                    () => Type.GetType(attribute.Name) ?? NamespaceImports.Select(x => Type.GetType($\"{x}.{attribute.Name}\")).FirstOrDefault(),\n+                    System.Threading.LazyThreadSafetyMode.None\n+                );\n+\n+                if (\n+                    !AddArguments(attribute, attributeType, providedOrderedParameters, true)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Done. \ud83d\ude04 ",
              "createdAt": "2021-04-05T00:30:41Z",
              "path": "src/Tasks/WriteCodeFragment.cs",
              "diffHunk": "@@ -221,12 +238,24 @@ private string GenerateCode(out string extension)\n                         return null;\n                     }\n \n-                    attribute.Arguments.Add(orderedParameters[i]);\n+                    providedOrderedParameters.Add(orderedParameters[i].Value);\n                 }\n \n-                foreach (CodeAttributeArgument namedParameter in namedParameters)\n+                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));\n+\n+                // We might need the type of the attribute if we need to infer the\n+                // types of the parameters. Search for it by the given type name,\n+                // as well as within the namespaces that we automatically import.\n+                Lazy<Type> attributeType = new(\n+                    () => Type.GetType(attribute.Name) ?? NamespaceImports.Select(x => Type.GetType($\"{x}.{attribute.Name}\")).FirstOrDefault(),\n+                    System.Threading.LazyThreadSafetyMode.None\n+                );\n+\n+                if (\n+                    !AddArguments(attribute, attributeType, providedOrderedParameters, true)",
              "author": {
                "login": "reduckted"
              }
            }
          ]
        }
      }
    ]
  }
}