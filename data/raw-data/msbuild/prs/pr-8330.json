{
  "number": 8330,
  "title": "Support `SkipNonexistentTargets` in project reference target protocol",
  "body": "Fixes #4252\r\n\r\n### Context\r\nThis PR extracts the relevant logic from the closed https://github.com/dotnet/msbuild/pull/5297, which adds support for the `SkipNonexistentTargets` metadatum on the `ProjectReferenceTargets` item:\r\n\r\n```xml\r\n<ProjectReferenceTargets Include='<some-target>' Targets='<some-target1>;<some-target2>' SkipNonexistentTargets='<boolean>'>\r\n```\r\nIf `SkipNonexistentTargets` is `true`, then any targets in `Targets` are skipped if they're nonexistent. `SkipNonexistentTargets` cannot be added to `ProjectReferenceTargets` items whose `Targets` contain `.default` or `.projectReferenceTargetsOrDefaultTargets`, which represent the default targets and targets specified on the `ProjectReference` item (with fallback to default targets if none are specified), respectively.\r\n\r\n### Changes Made\r\n* `GetTargetLists` filters out skippable nonexistent targets on referenced projects.\r\n* Determining whether a target is skippable required storing the defined project targets in `BuildResult`s to ensure that corresponding `BuildRequestConfiguration`s on the build manager node have set project targets if the build manager node created a configuration based on a request from an external node but hadn't received a result (since the project may not have been loaded locally and thus the project targets would be unknown).\r\n* Added `SkipNonexistentTargets='true'` to `GetTargetFrameworks` since [in the non-graph case it is added to the relevant MSBuild task](https://github.com/dotnet/msbuild/blob/a2490dd3f78cce4abc8f9e6f1b5268437332818f/src/Tasks/Microsoft.Common.CurrentVersion.targets#L1785-L1795).\r\n\r\n### Testing\r\nUTs and manual testing with `/graph` and `/graph /isolate` (the latter run without `restore` being called due to https://github.com/dotnet/msbuild/issues/6856) on the erroring repos I saw when testing https://github.com/dotnet/msbuild/pull/8249.\r\n\r\n### Notes\r\nAddressing this since it came up when testing https://github.com/dotnet/msbuild/pull/8249.\r\n\r\ncc @dfederm ",
  "state": "MERGED",
  "createdAt": "2023-01-20T18:16:31Z",
  "updatedAt": "2023-02-07T13:59:07Z",
  "closedAt": "2023-02-07T07:41:24Z",
  "mergedAt": "2023-02-07T07:41:24Z",
  "additions": 280,
  "deletions": 54,
  "changedFiles": 11,
  "headRefName": "skip-nonexistent-targets",
  "isDraft": false,
  "author": {
    "login": "DmitriyShepelev"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Static Graph",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "65ef8ae48cca49d50fad82a40de0b0a1621b0b04",
          "message": "Support `SkipNonexistentTargets` in project reference target protocol",
          "committedDate": "2023-01-24T20:04:53Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "773f369184dadcadf2202c1e63e40aca4fd72c9a",
          "message": "Fix error-checking",
          "committedDate": "2023-01-24T20:04:53Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ac665852852cbc680e2e868f379e05d101b0dab2",
          "message": "Add `SkipNonExistentTargets` to `GetTargetFrameworks` in project reference protocol",
          "committedDate": "2023-01-25T15:13:52Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7c53b6949d535f068fe7ebd0580480a0344e52c2",
          "message": "Make `BuildResult.ProjectTargets` `internal`",
          "committedDate": "2023-01-25T22:04:26Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "11cb7102fb90a28a5a70bb054e1e436ff50fe774",
          "message": "Make `BuildRequestConfiguration.ProjectTargets` `internal` & add `SkipNonexistentTargets='true'` to `GetTargetFrameworksWithPlatformForSingleTargetFramework`",
          "committedDate": "2023-01-25T23:48:12Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "95af1dfff23b104973bb9b47b4667eafe110c4b1",
          "message": "Merge branch 'main' into skip-nonexistent-targets",
          "committedDate": "2023-01-26T14:56:45Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "417874e5dcfe618c586c72259ca27d343fc5c67b",
          "message": "Fix indentation",
          "committedDate": "2023-01-26T14:57:01Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bc8f8ae6502f3d64e0ec3e56455ff3fa27187204",
          "message": "Remove ending newline",
          "committedDate": "2023-01-26T15:15:49Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "657b8c6f6a4742216279d65f5c951bee02ad845c",
          "message": "Merge branch 'main' into skip-nonexistent-targets",
          "committedDate": "2023-01-26T15:54:11Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ff426c8f3d8e9c0419b101290c49b02d3fda6b17",
          "message": "Add `GetTargetFrameworksWithPlatformForSingleTargetFramework` to `Rebuild` and address documentation",
          "committedDate": "2023-01-26T16:57:49Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "75a78fb8e5503f323387744ab9ddcef606b87b4d",
          "message": "Merge branch 'main' into skip-nonexistent-targets",
          "committedDate": "2023-01-26T16:58:10Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e34ff600d1dcab543e22e7ee54f10b1d43b0951e",
          "message": "Fix nits",
          "committedDate": "2023-01-30T15:00:51Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4a926e21e00c1c6eaee13257f84d611e7eb410ac",
          "message": "Merge branch 'main' into skip-nonexistent-targets",
          "committedDate": "2023-01-30T15:01:25Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d0035eb840f835d5b2f2e7cdd305f49ccbf24546",
          "message": "Merge branch 'main' into skip-nonexistent-targets",
          "committedDate": "2023-02-06T15:22:58Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Is there a specific use-case for this? I see a theoretical one, but I'm not aware of anything in the typical p2p protocol which uses `SkipNonexistentTargets`",
        "createdAt": "2023-01-23T16:06:25Z",
        "author": {
          "login": "dfederm"
        }
      },
      {
        "body": "> Is there a specific use-case for this? I see a theoretical one, but I'm not aware of anything in the typical p2p protocol which uses `SkipNonexistentTargets`\r\n\r\n`.wixproj` projects don't define `GetTargetFrameworks` nor `GetTargetFrameworksWithPlatformForSingleTargetFramework` so, if they happen to be referenced, MSBuild will emit errors about nonexistent targets being called.",
        "createdAt": "2023-01-25T15:26:13Z",
        "author": {
          "login": "DmitriyShepelev"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2023-01-30T12:45:53Z",
        "author": {
          "login": "rokonec"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2023-01-30T12:46:03Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2023-01-30T16:19:59Z",
        "author": {
          "login": "DmitriyShepelev"
        }
      },
      {
        "body": "<samp>\nCommenter does not have sufficient privileges for PR 8330 in repo dotnet/msbuild<br>\r\n\n</samp>",
        "createdAt": "2023-01-30T16:20:05Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2023-01-30T17:25:54Z",
        "author": {
          "login": "rokonec"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2023-01-30T17:26:05Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "@DmitriyShepelev Please help resolve the conflicts",
        "createdAt": "2023-02-06T02:22:52Z",
        "author": {
          "login": "JaynieBai"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Renamed to disambiguate from `ProjectTargets`.",
              "createdAt": "2023-01-20T18:17:56Z",
              "path": "src/Build/BackEnd/Shared/BuildRequestConfiguration.cs",
              "diffHunk": "@@ -138,7 +143,7 @@ internal class BuildRequestConfiguration : IEquatable<BuildRequestConfiguration>\n         /// <summary>\n         /// The target names that were requested to execute.\n         /// </summary>\n-        internal IReadOnlyCollection<string> TargetNames { get; }\n+        internal IReadOnlyCollection<string> RequestedTargets { get; }",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is now a nop. Same with `ProjectReferenceTargetsForCleanInOuterBuild` below",
              "createdAt": "2023-01-25T15:36:14Z",
              "path": "src/Tasks/Microsoft.Managed.After.targets",
              "diffHunk": "@@ -41,10 +41,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     <_MainReferenceTargetForBuild Condition=\"'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'\">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>\n     <_MainReferenceTargetForBuild Condition=\"'$(_MainReferenceTargetForBuild)' == ''\">GetTargetPath</_MainReferenceTargetForBuild>\n \n-    <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>\n+    <ProjectReferenceTargetsForBuildInOuterBuild>$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "The top of the file has\r\n```\r\n Properties for extension of ProjectReferenceTargets.\r\n      Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.\r\n```\r\n\r\nI thought the current value referenced here would be any preexisting property definitions in Directory.Build.props?",
              "createdAt": "2023-01-25T15:41:47Z",
              "path": "src/Tasks/Microsoft.Managed.After.targets",
              "diffHunk": "@@ -41,10 +41,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     <_MainReferenceTargetForBuild Condition=\"'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'\">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>\n     <_MainReferenceTargetForBuild Condition=\"'$(_MainReferenceTargetForBuild)' == ''\">GetTargetPath</_MainReferenceTargetForBuild>\n \n-    <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>\n+    <ProjectReferenceTargetsForBuildInOuterBuild>$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>",
              "author": {
                "login": "DmitriyShepelev"
              }
            },
            {
              "body": "So this is intended to preserve existing values, but effectively you're changing from:\r\n\r\n```cs\r\nstring foo = string.Empty; // Or possibly some other value\r\nfoo = \"bar;\" + foo;\r\n```\r\n\r\nto:\r\n\r\n```cs\r\nstring foo = string.Empty; // Or possibly some other value\r\nfoo = foo;\r\n```\r\n\r\nSo the updated line doesn't actually do anything now. You're assigning it to its current value.",
              "createdAt": "2023-01-25T22:15:50Z",
              "path": "src/Tasks/Microsoft.Managed.After.targets",
              "diffHunk": "@@ -41,10 +41,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     <_MainReferenceTargetForBuild Condition=\"'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'\">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>\n     <_MainReferenceTargetForBuild Condition=\"'$(_MainReferenceTargetForBuild)' == ''\">GetTargetPath</_MainReferenceTargetForBuild>\n \n-    <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>\n+    <ProjectReferenceTargetsForBuildInOuterBuild>$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is adding to the public API. Is this needed?",
              "createdAt": "2023-01-25T15:44:04Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -433,6 +437,17 @@ internal List<string> DefaultTargets\n             { _defaultTargets = value; }\n         }\n \n+        /// <summary>\n+        /// The defined targets for the project associated with this build result.\n+        /// </summary>\n+        public HashSet<string> ProjectTargets",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Huh, looks like I can get away with making it `internal`\u2014no need to add it to the public API.\r\n\r\nI do believe it's functionally needed, for reasons described in `BuildManager.HandleResult`/PR description. If the `BuildManager` doesn't have the `ProjectTargets` for a particular configuration, the scheduler (which uses the same global config cache as the `BuildManager`) won't be able to `SkipNonexistentTargets` properly.",
              "createdAt": "2023-01-25T22:02:38Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -433,6 +437,17 @@ internal List<string> DefaultTargets\n             { _defaultTargets = value; }\n         }\n \n+        /// <summary>\n+        /// The defined targets for the project associated with this build result.\n+        /// </summary>\n+        public HashSet<string> ProjectTargets",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This shouldn't be hard-coded",
              "createdAt": "2023-01-25T15:46:46Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -451,11 +467,38 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj\n \n             public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance reference)\n             {\n-                return (GetProjectType(reference)) switch\n+                ImmutableList<string> RemoveNonexistentTargetsIfSkippable(ImmutableList<TargetSpecification> targets)\n+                {\n+                    var targetsToKeep = new List<string>();\n+                    bool getTargetFrameworksRemoved = false;\n+                    foreach (TargetSpecification target in targets)\n+                    {\n+                        // Keep targets that are non-skippable or that exist but are skippable.\n+                        if (!target.SkipIfNonexistent || reference.Targets.ContainsKey(target.Target))\n+                        {\n+                            targetsToKeep.Add(target.Target);\n+                        }\n+                        else if (target.Target.Equals(\"GetTargetFrameworks\"))",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "`GetTargetFrameworksWithPlatformForSingleTargetFramework` below also seems pretty dubious.",
              "createdAt": "2023-01-25T15:47:15Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -451,11 +467,38 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj\n \n             public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance reference)\n             {\n-                return (GetProjectType(reference)) switch\n+                ImmutableList<string> RemoveNonexistentTargetsIfSkippable(ImmutableList<TargetSpecification> targets)\n+                {\n+                    var targetsToKeep = new List<string>();\n+                    bool getTargetFrameworksRemoved = false;\n+                    foreach (TargetSpecification target in targets)\n+                    {\n+                        // Keep targets that are non-skippable or that exist but are skippable.\n+                        if (!target.SkipIfNonexistent || reference.Targets.ContainsKey(target.Target))\n+                        {\n+                            targetsToKeep.Add(target.Target);\n+                        }\n+                        else if (target.Target.Equals(\"GetTargetFrameworks\"))",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Probably the p2p protocol isn't expressed correctly.",
              "createdAt": "2023-01-25T15:48:01Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -451,11 +467,38 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj\n \n             public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance reference)\n             {\n-                return (GetProjectType(reference)) switch\n+                ImmutableList<string> RemoveNonexistentTargetsIfSkippable(ImmutableList<TargetSpecification> targets)\n+                {\n+                    var targetsToKeep = new List<string>();\n+                    bool getTargetFrameworksRemoved = false;\n+                    foreach (TargetSpecification target in targets)\n+                    {\n+                        // Keep targets that are non-skippable or that exist but are skippable.\n+                        if (!target.SkipIfNonexistent || reference.Targets.ContainsKey(target.Target))\n+                        {\n+                            targetsToKeep.Add(target.Target);\n+                        }\n+                        else if (target.Target.Equals(\"GetTargetFrameworks\"))",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "OK, looking at https://github.com/dotnet/msbuild/pull/5657, I think the best solution here is to actually add `SkipNonexistentTargets='true'` to `GetTargetFrameworksWithPlatformForSingleTargetFramework` in `Microsoft.Managed.After.targets`. The only issue with this is that if an inner build doesn't have `GetTargetFrameworksWithPlatformForSingleTargetFramework` defined, the outer build's `GetTargetFrameworks` target will fail since it depends on it. For non-multitargeting nodes, explicitly specifying `GetTargetFrameworksWithPlatformForSingleTargetFramework` is unnecessary since `GetTargetFrameworks` calls it, so there's no harm in marking it as `SkipNonexistentTargets='true'`.",
              "createdAt": "2023-01-25T21:46:55Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -451,11 +467,38 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj\n \n             public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance reference)\n             {\n-                return (GetProjectType(reference)) switch\n+                ImmutableList<string> RemoveNonexistentTargetsIfSkippable(ImmutableList<TargetSpecification> targets)\n+                {\n+                    var targetsToKeep = new List<string>();\n+                    bool getTargetFrameworksRemoved = false;\n+                    foreach (TargetSpecification target in targets)\n+                    {\n+                        // Keep targets that are non-skippable or that exist but are skippable.\n+                        if (!target.SkipIfNonexistent || reference.Targets.ContainsKey(target.Target))\n+                        {\n+                            targetsToKeep.Add(target.Target);\n+                        }\n+                        else if (target.Target.Equals(\"GetTargetFrameworks\"))",
              "author": {
                "login": "DmitriyShepelev"
              }
            },
            {
              "body": "Make sure to add a comment in `Microsoft.Managed.After.targets` explaining that since it doesn't strictly follow the actual behavior. Mention that the p2p protocol isn't expressive enough to specify specific targets executing from the outer to the inner build or whatever, as I believe that's the main problem here?",
              "createdAt": "2023-01-25T22:20:30Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -451,11 +467,38 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj\n \n             public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance reference)\n             {\n-                return (GetProjectType(reference)) switch\n+                ImmutableList<string> RemoveNonexistentTargetsIfSkippable(ImmutableList<TargetSpecification> targets)\n+                {\n+                    var targetsToKeep = new List<string>();\n+                    bool getTargetFrameworksRemoved = false;\n+                    foreach (TargetSpecification target in targets)\n+                    {\n+                        // Keep targets that are non-skippable or that exist but are skippable.\n+                        if (!target.SkipIfNonexistent || reference.Targets.ContainsKey(target.Target))\n+                        {\n+                            targetsToKeep.Add(target.Target);\n+                        }\n+                        else if (target.Target.Equals(\"GetTargetFrameworks\"))",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Rebuild probably needs it too",
              "createdAt": "2023-01-26T15:59:40Z",
              "path": "src/Tasks/Microsoft.Managed.After.targets",
              "diffHunk": "@@ -59,11 +57,22 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   <ItemGroup Condition=\"'$(IsGraphBuild)' == 'true'\">\n     <ProjectReferenceTargets Include=\"Build\" Targets=\"$(ProjectReferenceTargetsForBuildInOuterBuild)\" Condition=\" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' \" OuterBuild=\"true\" />\n+    <ProjectReferenceTargets Include=\"Build\" Targets=\"GetTargetFrameworks\" OuterBuild=\"true\" SkipNonexistentTargets=\"true\" />\n     <ProjectReferenceTargets Include=\"Build\" Targets=\"$(ProjectReferenceTargetsForBuild)\" Condition=\" '$(ProjectReferenceTargetsForBuild)' != '' \" />\n-\n+    \n     <ProjectReferenceTargets Include=\"Clean\" Targets=\"$(ProjectReferenceTargetsForCleanInOuterBuild)\" Condition=\" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' \" OuterBuild=\"true\" />\n+    <ProjectReferenceTargets Include=\"Clean\" Targets=\"GetTargetFrameworks\" OuterBuild=\"true\" SkipNonexistentTargets=\"true\" />\n     <ProjectReferenceTargets Include=\"Clean\" Targets=\"$(ProjectReferenceTargetsForClean)\" Condition=\" '$(ProjectReferenceTargetsForClean)' != '' \" />\n \n+    <!--\n+     Note: SkipNonexistentTargets=\"true\" on the following two items means that an outer build node's call to its existent GetTargetFrameworks\n+     target will fail if its inner build nodes don't define GetTargetFrameworksWithPlatformForSingleTargetFrameworks. This is necessary\n+     since the P2P protocol cannot express logic that allows nonexistent targets to be skipped if other targets marked as SkipNonexistentTargets=\"true\"\n+     are actually skipped on a project due to their nonexistence.\n+     -->\n+    <ProjectReferenceTargets Include=\"Build\" Targets=\"GetTargetFrameworksWithPlatformForSingleTargetFramework\" SkipNonexistentTargets=\"true\" />\n+    <ProjectReferenceTargets Include=\"Clean\" Targets=\"GetTargetFrameworksWithPlatformForSingleTargetFramework\" SkipNonexistentTargets=\"true\" />",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Rebuild probably needs the `GetTargetFrameworks` changes as well actually.",
              "createdAt": "2023-01-26T16:06:49Z",
              "path": "src/Tasks/Microsoft.Managed.After.targets",
              "diffHunk": "@@ -59,11 +57,22 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   <ItemGroup Condition=\"'$(IsGraphBuild)' == 'true'\">\n     <ProjectReferenceTargets Include=\"Build\" Targets=\"$(ProjectReferenceTargetsForBuildInOuterBuild)\" Condition=\" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' \" OuterBuild=\"true\" />\n+    <ProjectReferenceTargets Include=\"Build\" Targets=\"GetTargetFrameworks\" OuterBuild=\"true\" SkipNonexistentTargets=\"true\" />\n     <ProjectReferenceTargets Include=\"Build\" Targets=\"$(ProjectReferenceTargetsForBuild)\" Condition=\" '$(ProjectReferenceTargetsForBuild)' != '' \" />\n-\n+    \n     <ProjectReferenceTargets Include=\"Clean\" Targets=\"$(ProjectReferenceTargetsForCleanInOuterBuild)\" Condition=\" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' \" OuterBuild=\"true\" />\n+    <ProjectReferenceTargets Include=\"Clean\" Targets=\"GetTargetFrameworks\" OuterBuild=\"true\" SkipNonexistentTargets=\"true\" />\n     <ProjectReferenceTargets Include=\"Clean\" Targets=\"$(ProjectReferenceTargetsForClean)\" Condition=\" '$(ProjectReferenceTargetsForClean)' != '' \" />\n \n+    <!--\n+     Note: SkipNonexistentTargets=\"true\" on the following two items means that an outer build node's call to its existent GetTargetFrameworks\n+     target will fail if its inner build nodes don't define GetTargetFrameworksWithPlatformForSingleTargetFrameworks. This is necessary\n+     since the P2P protocol cannot express logic that allows nonexistent targets to be skipped if other targets marked as SkipNonexistentTargets=\"true\"\n+     are actually skipped on a project due to their nonexistence.\n+     -->\n+    <ProjectReferenceTargets Include=\"Build\" Targets=\"GetTargetFrameworksWithPlatformForSingleTargetFramework\" SkipNonexistentTargets=\"true\" />\n+    <ProjectReferenceTargets Include=\"Clean\" Targets=\"GetTargetFrameworksWithPlatformForSingleTargetFramework\" SkipNonexistentTargets=\"true\" />",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think this is the problem as much as there isn't a way to express the targets called from the outer build to the inner build.\r\n\r\nWhat we have today effectively is saying \"when `Build` is called on me, I call `GetTargetFrameworksWithPlatformForSingleTargetFramework` on my project references\". But that isn't actually true at all. Instead what actually happens is that `GetTargetFrameworks` is called on the project references and then that calls `GetTargetFrameworksWithPlatformForSingleTargetFramework` on itself. We aren't able to express that here though, in particular \"I call this target on my inner builds\" so the middle part is cut out.",
              "createdAt": "2023-01-26T16:04:50Z",
              "path": "src/Tasks/Microsoft.Managed.After.targets",
              "diffHunk": "@@ -59,11 +57,22 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   <ItemGroup Condition=\"'$(IsGraphBuild)' == 'true'\">\n     <ProjectReferenceTargets Include=\"Build\" Targets=\"$(ProjectReferenceTargetsForBuildInOuterBuild)\" Condition=\" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' \" OuterBuild=\"true\" />\n+    <ProjectReferenceTargets Include=\"Build\" Targets=\"GetTargetFrameworks\" OuterBuild=\"true\" SkipNonexistentTargets=\"true\" />\n     <ProjectReferenceTargets Include=\"Build\" Targets=\"$(ProjectReferenceTargetsForBuild)\" Condition=\" '$(ProjectReferenceTargetsForBuild)' != '' \" />\n-\n+    \n     <ProjectReferenceTargets Include=\"Clean\" Targets=\"$(ProjectReferenceTargetsForCleanInOuterBuild)\" Condition=\" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' \" OuterBuild=\"true\" />\n+    <ProjectReferenceTargets Include=\"Clean\" Targets=\"GetTargetFrameworks\" OuterBuild=\"true\" SkipNonexistentTargets=\"true\" />\n     <ProjectReferenceTargets Include=\"Clean\" Targets=\"$(ProjectReferenceTargetsForClean)\" Condition=\" '$(ProjectReferenceTargetsForClean)' != '' \" />\n \n+    <!--\n+     Note: SkipNonexistentTargets=\"true\" on the following two items means that an outer build node's call to its existent GetTargetFrameworks\n+     target will fail if its inner build nodes don't define GetTargetFrameworksWithPlatformForSingleTargetFrameworks. This is necessary\n+     since the P2P protocol cannot express logic that allows nonexistent targets to be skipped if other targets marked as SkipNonexistentTargets=\"true\"",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: `.Targets.Keys.ToHashSet()` repeats three times in scope of this document. We can either create private method `TargetsOfProjectInstace(ProjectInstance pi)` or getter `ProjectInstance.TargetsList`.",
              "createdAt": "2023-01-30T12:14:27Z",
              "path": "src/Build/BackEnd/Shared/BuildRequestConfiguration.cs",
              "diffHunk": "@@ -170,15 +175,15 @@ internal BuildRequestConfiguration(int configId, BuildRequestData data, string d\n             _explicitToolsVersionSpecified = data.ExplicitToolsVersionSpecified;\n             _toolsVersion = ResolveToolsVersion(data, defaultToolsVersion);\n             _globalProperties = data.GlobalPropertiesDictionary;\n-            TargetNames = new List<string>(data.TargetNames);\n+            RequestedTargets = new List<string>(data.TargetNames);\n \n             // The following information only exists when the request is populated with an existing project.\n             if (data.ProjectInstance != null)\n             {\n                 _project = data.ProjectInstance;\n                 _projectInitialTargets = data.ProjectInstance.InitialTargets;\n                 _projectDefaultTargets = data.ProjectInstance.DefaultTargets;\n-\n+                _projectTargets = data.ProjectInstance.Targets.Keys.ToHashSet();",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I created a private method since `Targets.Keys.ToHashSet()` is only called in this file.",
              "createdAt": "2023-01-30T15:04:02Z",
              "path": "src/Build/BackEnd/Shared/BuildRequestConfiguration.cs",
              "diffHunk": "@@ -170,15 +175,15 @@ internal BuildRequestConfiguration(int configId, BuildRequestData data, string d\n             _explicitToolsVersionSpecified = data.ExplicitToolsVersionSpecified;\n             _toolsVersion = ResolveToolsVersion(data, defaultToolsVersion);\n             _globalProperties = data.GlobalPropertiesDictionary;\n-            TargetNames = new List<string>(data.TargetNames);\n+            RequestedTargets = new List<string>(data.TargetNames);\n \n             // The following information only exists when the request is populated with an existing project.\n             if (data.ProjectInstance != null)\n             {\n                 _project = data.ProjectInstance;\n                 _projectInitialTargets = data.ProjectInstance.InitialTargets;\n                 _projectDefaultTargets = data.ProjectInstance.DefaultTargets;\n-\n+                _projectTargets = data.ProjectInstance.Targets.Keys.ToHashSet();",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: opinionated, but I believe that avoiding NOTs will make it more readable:\r\n```\r\n!(skipIfNonexistent \r\n  && (target.Equals(MSBuildConstants.DefaultTargetsMarker \r\n   || target.Equals(MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker))\r\n````\r\nAs we are asserting exceptional conditions which shall not happen",
              "createdAt": "2023-01-30T12:25:03Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -63,6 +63,23 @@ public ReferenceInfo(ConfigurationMetadata referenceConfiguration, ProjectItemIn\n             }\n         }\n \n+        private readonly struct TargetSpecification\n+        {\n+            public TargetSpecification(string target, bool skipIfNonexistent)\n+            {\n+                ErrorUtilities.VerifyThrow(\n+                    !skipIfNonexistent || (!target.Equals(MSBuildConstants.DefaultTargetsMarker)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I added an explanatory comment to enhance readability.",
              "createdAt": "2023-01-30T15:03:04Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -63,6 +63,23 @@ public ReferenceInfo(ConfigurationMetadata referenceConfiguration, ProjectItemIn\n             }\n         }\n \n+        private readonly struct TargetSpecification\n+        {\n+            public TargetSpecification(string target, bool skipIfNonexistent)\n+            {\n+                ErrorUtilities.VerifyThrow(\n+                    !skipIfNonexistent || (!target.Equals(MSBuildConstants.DefaultTargetsMarker)",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I am NOT 100% sold on automatic `var` removal. Lets discuss it.",
              "createdAt": "2023-01-30T12:31:43Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -1976,14 +1977,14 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF\n                             NewBuildEventContext(),\n                             MessageImportance.Normal,\n                             \"SkippedConstraintsOnRequest\",\n-                            configs.parentConfig.ProjectFullPath,\n-                            configs.requestConfig.ProjectFullPath);\n+                            configs.ParentConfig.ProjectFullPath,\n+                            configs.RequestConfig.ProjectFullPath);\n                 }\n \n                 return true;\n             }\n \n-            var (requestConfig, parentConfig) = GetConfigurations();\n+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) = GetConfigurations();",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I removed it to abide by the style guidelines in `.editorconfig`: https://github.com/dotnet/msbuild/blob/main/.editorconfig#L46\r\nSince I'm the last person to touch this code, I thought it would be a good idea to fix style issues as well.",
              "createdAt": "2023-01-30T14:56:04Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -1976,14 +1977,14 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF\n                             NewBuildEventContext(),\n                             MessageImportance.Normal,\n                             \"SkippedConstraintsOnRequest\",\n-                            configs.parentConfig.ProjectFullPath,\n-                            configs.requestConfig.ProjectFullPath);\n+                            configs.ParentConfig.ProjectFullPath,\n+                            configs.RequestConfig.ProjectFullPath);\n                 }\n \n                 return true;\n             }\n \n-            var (requestConfig, parentConfig) = GetConfigurations();\n+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) = GetConfigurations();",
              "author": {
                "login": "DmitriyShepelev"
              }
            },
            {
              "body": "OK. No big deal.",
              "createdAt": "2023-01-30T15:47:40Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -1976,14 +1977,14 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF\n                             NewBuildEventContext(),\n                             MessageImportance.Normal,\n                             \"SkippedConstraintsOnRequest\",\n-                            configs.parentConfig.ProjectFullPath,\n-                            configs.requestConfig.ProjectFullPath);\n+                            configs.ParentConfig.ProjectFullPath,\n+                            configs.RequestConfig.ProjectFullPath);\n                 }\n \n                 return true;\n             }\n \n-            var (requestConfig, parentConfig) = GetConfigurations();\n+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) = GetConfigurations();",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I prefer no var, personally, and I think we talked about it a while ago and collectively decided on removing var.",
              "createdAt": "2023-01-30T15:59:58Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -1976,14 +1977,14 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF\n                             NewBuildEventContext(),\n                             MessageImportance.Normal,\n                             \"SkippedConstraintsOnRequest\",\n-                            configs.parentConfig.ProjectFullPath,\n-                            configs.requestConfig.ProjectFullPath);\n+                            configs.ParentConfig.ProjectFullPath,\n+                            configs.RequestConfig.ProjectFullPath);\n                 }\n \n                 return true;\n             }\n \n-            var (requestConfig, parentConfig) = GetConfigurations();\n+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) = GetConfigurations();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}