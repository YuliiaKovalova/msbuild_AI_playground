{
  "number": 11359,
  "title": "Collecting some build data for tasks/targets telemetry",
  "body": "Fixes #10946\r\n\r\n**If split into separate PRs is prefered - please indicate so in comments**\r\n\r\n### Goal\r\nObtaining information about build composition from microsoft versus 3rd party tasks and targets.\r\n\r\n### Approach\r\n\r\nSince the information is present in the building worker nodes - the code collects it there and then (if requested) send it via `WorkerNodeTelemetryEventArgs` to the main node.\r\n\r\nThe classification of 3rd party versus 1st party is for simplicity being done based on location of defining msbuild project and naming of the assembly.\r\n\r\n### Changes\r\n - Added class for the exexution statistics of tasks - this is contained in TaskRegistry as well as in TaskFactoryWrappers\r\n - RequestBuilder is the orchestration here, that decides whether statistics are needed and if yes - traverses the TaskRegistry, BuildResult and ProjectCollection in order to accumulate and populate the statistics\r\n - Added WorkerNodeTelemetryEventArgs that holds data, InternalTelemeteryConsumingLogger and InternalTelemeteryForwardingLogger to transfer the data (only if telemetry is sampled in)\r\n\r\n### Performance considerations\r\n\r\nBy default the data collection logic is *off* and hence statistics are not collected on worker node, nor serialized to the event args. The perf impact of collection and serialization was though beyond the recognition level of basic 'full duration' testing of full and incremental build of small console and bigger size projects.\r\n\r\n\r\n### Sample of collected data\r\n\r\nThis is stringified flushed version of stats collected and aggregated from nodes.\r\nOnce inputing into our telemetry client, we might send just subset (topN).\r\nWe collect the info about whether the task/target is 1st or 3rd party ('C:' prefix), whether it's comming from nuget cache ('N:' prefix) or is generated within metaproj, the task/target name (will be hashed for 3rd party), the duration of the task, the memory consumption of the task and the number of executions of the task\r\n\r\n\r\n```\r\n==========================================\r\nTasks: (258)\r\nCustom tasks:\r\nC:ReplaceFileText\r\n==========================================\r\nTasks by time:\r\nMicrosoft.Build.Tasks.ResolveAssemblyReference - 00:00:34.5173355\r\nMicrosoft.CodeAnalysis.BuildTasks.CopyRefAssembly - 00:00:20.0824767\r\nMicrosoft.Build.Tasks.WriteLinesToFile - 00:00:08.7755037\r\nMicrosoft.NET.Build.Tasks.ResolvePackageAssets - 00:00:07.6207085\r\nMicrosoft.CodeAnalysis.BuildTasks.Csc - 00:00:06.6906938\r\n(...)\r\n==========================================\r\nTasks by memory consumption:\r\nMicrosoft.Build.Tasks.ResolveAssemblyReference - 10751256.03 kB\r\nMicrosoft.Build.Tasks.AssignProjectConfiguration - 1189559.04 kB\r\nMicrosoft.Build.Tasks.AssignTargetPath - 393482.46 kB\r\nMicrosoft.Build.Tasks.SetRidAgnosticValueForProjects - 294210.73 kB\r\n(...)\r\nN:Microsoft.Build.Tasks.Git.GetUntrackedFiles - 3543.50 kB\r\n(...)\r\n==========================================\r\nTasks by Executions count:\r\nGetPackageDirectory - 4140\r\nMicrosoft.Build.Tasks.AssignTargetPath - 3050\r\nMicrosoft.Build.Tasks.FindUnderPath - 2126\r\n(...)\r\nN:Microsoft.SourceLink.GitHub.GetSourceLinkUrl - 1242\r\nMicrosoft.Build.Tasks.RemoveDuplicates - 1086\r\n(...)\r\n=========================================\r\nTargets (1621) - name : executed:\r\nAfterSdkPublish : False\r\nC:MakeWebRootFolder : False\r\n(...)\r\n```\r\n\r\n### Performance impact considerations\r\n\r\nSomethings always costs more than nothing :-) Beyond that - those changes should be with hardly observable impact.\r\n\r\nIf telemetry is opted out - there is no extra data collection, processing and sending applied.\r\nWhen telemetry is opted in - we keep and update hashtables with stats for all tasks and targets in all nodes and at the end of build send those stats to the main node. This minimizes costly traffic during the build.\r\n\r\nWhen measured with 'wall clock time' on incremental build of OrchardCore via:\r\n```\r\npskill msbuild; pskill dotnet; pskill vbcscompiler\r\nMeasure-Command { & \"C:\\src\\msbuild-2\\artifacts\\bin\\bootstrap\\net472\\MSBuild\\Current\\Bin\\MSBuild.exe\" -v:m | Out-Default }\r\n```\r\nAnd excluding warmup and slowest and fastest runs - the versions seems indistinguishable:\r\n\r\n**main (@aff5455):**\r\n\r\nMinutes           : 2\r\nSeconds           : 34\r\nMilliseconds      : 352\r\n\r\nMinutes           : 2\r\nSeconds           : 30\r\nMilliseconds      : 665\r\n\r\nMinutes           : 2\r\nSeconds           : 30\r\nMilliseconds      : 109\r\n\r\n**This PR** (with _isTelemetryEnabled forced to true and `$env:MSBUILDOUTPUTNODESTELEMETRY=1`):\r\n\r\nMinutes           : 3\r\nSeconds           : 36\r\nMilliseconds      : 707\r\n\r\nMinutes           : 2\r\nSeconds           : 37\r\nMilliseconds      : 763\r\n\r\nMinutes           : 2\r\nSeconds           : 35\r\nMilliseconds      : 794\r\n\r\n",
  "state": "MERGED",
  "createdAt": "2025-01-29T19:28:10Z",
  "updatedAt": "2025-02-20T15:51:53Z",
  "closedAt": "2025-02-20T15:51:50Z",
  "mergedAt": "2025-02-20T15:51:49Z",
  "additions": 1155,
  "deletions": 50,
  "changedFiles": 36,
  "headRefName": "proto/task-telemetry-data-plan-b",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "3ca3d949250cc5ac64d2bb77e8cceb76494f172a",
          "message": "[WIP] Initial prototype of classifying tasks",
          "committedDate": "2024-12-27T20:57:37Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0e5a17dc213ad211e8de29ee6d70522d612ceabb",
          "message": "Fix and improve",
          "committedDate": "2025-01-09T15:00:14Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a47597e93d4ff83b8ebbaeef2a297c01e84b2123",
          "message": "Refactor",
          "committedDate": "2025-01-09T18:00:01Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e21b7ccc5fba42e1e4cf8923da2083095d1c61c7",
          "message": "Refactor",
          "committedDate": "2025-01-09T20:10:13Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "63d033deeb0c88d6e77d6a01417e50d3475df964",
          "message": "Add tests, fixing",
          "committedDate": "2025-01-10T17:42:51Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e410af3b892a9b28d6737ea68dda73b3552b1aa7",
          "message": "Remove empty hange",
          "committedDate": "2025-01-13T13:50:08Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5b4aa6bcbf09634e4e488c5ec5f03104f3a148a8",
          "message": "Additional changes",
          "committedDate": "2025-01-13T15:03:01Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f8d2c04355f3d1a8ea7fbe4caf09dfbca54abcab",
          "message": "Move code",
          "committedDate": "2025-01-13T16:26:56Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "72a58a9e48606719cc3db3829c88da5070e2708f",
          "message": "Remove redundant code",
          "committedDate": "2025-01-13T16:28:54Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "34850ae18a6345aea5c50815bd566a1996607720",
          "message": "WIP",
          "committedDate": "2025-01-22T17:52:29Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2247ce13075e3f14810616c5283c3d8fc21fb1ad",
          "message": "WIP",
          "committedDate": "2025-01-23T17:25:28Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3d9355eb564add346497476d3425e6753956c778",
          "message": "WIP2",
          "committedDate": "2025-01-23T17:34:07Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cfaef68fa9aa338f9246c03484fe62cce6257296",
          "message": "Merge branch 'proto/task-telemetry-data-plan-b' of https://github.com/dotnet/msbuild into proto/task-telemetry-data-plan-b",
          "committedDate": "2025-01-24T09:02:13Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8176214fca132808aa5e03e4c68ddd890dd3be0b",
          "message": "Add support for sending data through dedicated event",
          "committedDate": "2025-01-24T16:23:02Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "79772f4b2d397c0efbad6edb5db37dcc4bbf9575",
          "message": "Remove sending via ProjectFinishedEventArgs",
          "committedDate": "2025-01-24T16:32:32Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "15692e8dc0c1f86363f535e6d89105d76ed746bb",
          "message": "Fixing the data being reported",
          "committedDate": "2025-01-29T15:41:09Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d951d6a7191bf999e6690ef7160e8e8683f5c90d",
          "message": "Add metaproj info",
          "committedDate": "2025-01-29T16:57:39Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "669a7fe47717e2479a549cd34d1dc1d59a3b1971",
          "message": "Refactor the code",
          "committedDate": "2025-01-29T19:18:15Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4e9511f76472cc52889dae6efeb0889a7b7c96a8",
          "message": "Reflect PR comments",
          "committedDate": "2025-01-30T12:24:49Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "550b7428b138d25a5fc3981b606934216bc3a2e8",
          "message": "Fix build",
          "committedDate": "2025-01-30T12:27:09Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ed7defc1b3a86a4b2c1eb9fdcc0e7a9de2dce6b4",
          "message": "Fix tests",
          "committedDate": "2025-02-03T18:22:02Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3516cce2c18fa22961a8108765e611318be472ae",
          "message": "Fix build",
          "committedDate": "2025-02-04T07:34:31Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2604eec82e09576abd4247a135789d865f182572",
          "message": "Reflect PR comments",
          "committedDate": "2025-02-05T10:03:29Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0dd49d9fd84e5ab192cf86ff5bb7826533c4c50e",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Jan Provazn\u00edk <janprovaznik@microsoft.com>",
          "committedDate": "2025-02-13T17:07:38Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a3ad3db4ffb05039bbd5d25242f64dc8fe441128",
          "message": "Add custom keying",
          "committedDate": "2025-02-13T17:43:40Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3952a7313e3cb200f6eff18e26cf1e0a414f4758",
          "message": "Merge branch 'proto/task-telemetry-data-plan-b' of https://github.com/dotnet/msbuild into proto/task-telemetry-data-plan-b",
          "committedDate": "2025-02-13T17:43:43Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "faaa693f6ab461fc8b579e24b889f0c49c5ef5ef",
          "message": "Buildfix",
          "committedDate": "2025-02-13T17:47:28Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6f3e421399bdd426b2736cd5fa22afc637abd748",
          "message": "Merge branch 'main' into proto/task-telemetry-data-plan-b",
          "committedDate": "2025-02-19T14:20:20Z",
          "author": {
            "name": "Jan Provazn\u00edk",
            "email": "janprovaznik@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "I would prefer different terminology than Collector to prevent confusion with OTel and VS OTel concept of a collector.",
              "createdAt": "2025-01-30T11:08:12Z",
              "path": "src/Build/Telemetry/ITelemetryCollector.cs",
              "diffHunk": "@@ -0,0 +1,31 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.BackEnd.Logging;\n+\n+namespace Microsoft.Build.Telemetry;\n+\n+/// <summary>\n+/// A build component responsible for accumulating telemetry data from worker node and then sending it to main node\n+/// at the end of the build.\n+/// </summary>\n+internal interface ITelemetryCollector",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "quick suggestions from GPT I like:\r\n- **NodeTelemetrySender**\r\n- **NodeTelemetryReporter**\r\n- **TelemetryForwarder**\r\n- **TelemetryAccumulator**",
              "createdAt": "2025-01-30T11:19:24Z",
              "path": "src/Build/Telemetry/ITelemetryCollector.cs",
              "diffHunk": "@@ -0,0 +1,31 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.BackEnd.Logging;\n+\n+namespace Microsoft.Build.Telemetry;\n+\n+/// <summary>\n+/// A build component responsible for accumulating telemetry data from worker node and then sending it to main node\n+/// at the end of the build.\n+/// </summary>\n+internal interface ITelemetryCollector",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this just a refactor that slipped to this PR or is there a functional change I'm not seeing?",
              "createdAt": "2025-01-30T11:15:13Z",
              "path": "src/Framework/BuildCheck/BuildCheckEventArgs.cs",
              "diffHunk": "@@ -46,12 +46,7 @@ internal override void WriteToStream(BinaryWriter writer)\n     {\n         base.WriteToStream(writer);\n \n-        writer.Write7BitEncodedInt(TracingData.InfrastructureTracingData.Count);\n-        foreach (KeyValuePair<string, TimeSpan> kvp in TracingData.InfrastructureTracingData)\n-        {\n-            writer.Write(kvp.Key);\n-            writer.Write(kvp.Value.Ticks);\n-        }\n+        writer.WriteDurationsDictionary(TracingData.InfrastructureTracingData);",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Refactoring. I thought I'd need it, but didn't end up without it.\r\nI can remove it",
              "createdAt": "2025-01-30T12:12:01Z",
              "path": "src/Framework/BuildCheck/BuildCheckEventArgs.cs",
              "diffHunk": "@@ -46,12 +46,7 @@ internal override void WriteToStream(BinaryWriter writer)\n     {\n         base.WriteToStream(writer);\n \n-        writer.Write7BitEncodedInt(TracingData.InfrastructureTracingData.Count);\n-        foreach (KeyValuePair<string, TimeSpan> kvp in TracingData.InfrastructureTracingData)\n-        {\n-            writer.Write(kvp.Key);\n-            writer.Write(kvp.Value.Ticks);\n-        }\n+        writer.WriteDurationsDictionary(TracingData.InfrastructureTracingData);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I like this refactoring",
              "createdAt": "2025-02-07T15:13:13Z",
              "path": "src/Framework/BuildCheck/BuildCheckEventArgs.cs",
              "diffHunk": "@@ -46,12 +46,7 @@ internal override void WriteToStream(BinaryWriter writer)\n     {\n         base.WriteToStream(writer);\n \n-        writer.Write7BitEncodedInt(TracingData.InfrastructureTracingData.Count);\n-        foreach (KeyValuePair<string, TimeSpan> kvp in TracingData.InfrastructureTracingData)\n-        {\n-            writer.Write(kvp.Key);\n-            writer.Write(kvp.Value.Ticks);\n-        }\n+        writer.WriteDurationsDictionary(TracingData.InfrastructureTracingData);",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "this is very confusing",
              "createdAt": "2025-01-30T11:26:08Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1189,12 +1247,36 @@ internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLo\n                 {\n                     _parameterGroupAndTaskBody = new ParameterGroupAndTaskElementRecord();\n                 }\n+\n+                _definingFileFullPath = containingFileFullPath;\n             }\n \n             private RegisteredTaskRecord()\n             {\n             }\n \n+            public bool GetIsCustom()",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Added claryfying comment - please hav a look whether it feels sufficient.",
              "createdAt": "2025-01-30T12:23:03Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1189,12 +1247,36 @@ internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLo\n                 {\n                     _parameterGroupAndTaskBody = new ParameterGroupAndTaskElementRecord();\n                 }\n+\n+                _definingFileFullPath = containingFileFullPath;\n             }\n \n             private RegisteredTaskRecord()\n             {\n             }\n \n+            public bool GetIsCustom()",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "the comment clarifies the confusion, but the name is still a little confusing. \r\n`IsCustom` probably not a great name because it is not a set bool, you still need to calculate it (probably that is why it is `GetIsCustom`)\r\n\r\nsuggestion: rename to smth like `ComputeIfCustom`, `CheckIfCustom` or `DetermineIfCustom`",
              "createdAt": "2025-02-04T12:09:41Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1189,12 +1247,36 @@ internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLo\n                 {\n                     _parameterGroupAndTaskBody = new ParameterGroupAndTaskElementRecord();\n                 }\n+\n+                _definingFileFullPath = containingFileFullPath;\n             }\n \n             private RegisteredTaskRecord()\n             {\n             }\n \n+            public bool GetIsCustom()",
              "author": {
                "login": "surayya-MS"
              }
            },
            {
              "body": "Makes sense! - renamed",
              "createdAt": "2025-02-05T10:03:14Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1189,12 +1247,36 @@ internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLo\n                 {\n                     _parameterGroupAndTaskBody = new ParameterGroupAndTaskElementRecord();\n                 }\n+\n+                _definingFileFullPath = containingFileFullPath;\n             }\n \n             private RegisteredTaskRecord()\n             {\n             }\n \n+            public bool GetIsCustom()",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The class name 'InternalTelemeteryConsumingLogger' contains a typo. It should be 'InternalTelemetryConsumingLogger'.\n```suggestion\n            InternalTelemetryConsumingLogger.TestOnly_InternalTelemetryAggregted += dt => workerNodeTelemetryData = dt;\n```",
              "createdAt": "2025-01-30T11:39:43Z",
              "path": "src/Build.UnitTests/TelemetryTests.cs",
              "diffHunk": "@@ -0,0 +1,168 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Engine.UnitTests\n+{\n+    public class TelemetryTests\n+    {\n+        private readonly ITestOutputHelper _output;\n+\n+        public TelemetryTests(ITestOutputHelper output)\n+        {\n+            _output = output;\n+        }\n+\n+        private sealed class ProjectFinishedCapturingLogger : ILogger\n+        {\n+            private readonly List<ProjectFinishedEventArgs> _projectFinishedEventArgs = [];\n+            public LoggerVerbosity Verbosity { get; set; }\n+            public string? Parameters { get; set; }\n+\n+            public IReadOnlyList<ProjectFinishedEventArgs> ProjectFinishedEventArgsReceived =>\n+                _projectFinishedEventArgs;\n+\n+            public void Initialize(IEventSource eventSource)\n+            {\n+                eventSource.ProjectFinished += EventSource_ProjectFinished;\n+            }\n+\n+            private void EventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)\n+            {\n+                _projectFinishedEventArgs.Add(e);\n+            }\n+\n+            public void Shutdown()\n+            { }\n+        }\n+\n+        [Fact]\n+        public void WorkerNodeTelemetryCollection_BasicTarget()\n+        {\n+            WorkerNodeTelemetryData? workerNodeTelemetryData = null;\n+            InternalTelemeteryConsumingLogger.TestOnly_InternalTelemetryAggregted += dt => workerNodeTelemetryData = dt;",
              "author": {
                "login": "copilot-pull-request-reviewer"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The class name 'InternalTelemeteryConsumingLogger' contains a typo. It should be 'InternalTelemetryConsumingLogger'.\n```suggestion\n            InternalTelemetryConsumingLogger.TestOnly_InternalTelemetryAggregted += dt => workerNodeTelemetryData = dt;\n```",
              "createdAt": "2025-01-30T11:39:43Z",
              "path": "src/Build.UnitTests/TelemetryTests.cs",
              "diffHunk": "@@ -0,0 +1,168 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Engine.UnitTests\n+{\n+    public class TelemetryTests\n+    {\n+        private readonly ITestOutputHelper _output;\n+\n+        public TelemetryTests(ITestOutputHelper output)\n+        {\n+            _output = output;\n+        }\n+\n+        private sealed class ProjectFinishedCapturingLogger : ILogger\n+        {\n+            private readonly List<ProjectFinishedEventArgs> _projectFinishedEventArgs = [];\n+            public LoggerVerbosity Verbosity { get; set; }\n+            public string? Parameters { get; set; }\n+\n+            public IReadOnlyList<ProjectFinishedEventArgs> ProjectFinishedEventArgsReceived =>\n+                _projectFinishedEventArgs;\n+\n+            public void Initialize(IEventSource eventSource)\n+            {\n+                eventSource.ProjectFinished += EventSource_ProjectFinished;\n+            }\n+\n+            private void EventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)\n+            {\n+                _projectFinishedEventArgs.Add(e);\n+            }\n+\n+            public void Shutdown()\n+            { }\n+        }\n+\n+        [Fact]\n+        public void WorkerNodeTelemetryCollection_BasicTarget()\n+        {\n+            WorkerNodeTelemetryData? workerNodeTelemetryData = null;\n+            InternalTelemeteryConsumingLogger.TestOnly_InternalTelemetryAggregted += dt => workerNodeTelemetryData = dt;\n+\n+            var testProject = \"\"\"\n+                                      <Project>\n+                                          <Target Name=\"Build\">\n+                                              <Message Text=\"Hello World\"/>\n+                                              <CreateItem Include=\"foo.bar\">\n+                                                  <Output TaskParameter=\"Include\" ItemName=\"I\" />\n+                                              </CreateItem>\n+                                              <Message Text=\"Bye World\"/>\n+                                          </Target>\n+                                      </Project>\n+                              \"\"\";\n+\n+            MockLogger logger = new MockLogger(_output);\n+            Helpers.BuildProjectContentUsingBuildManager(testProject, logger,\n+                new BuildParameters() { IsTelemetryEnabled = true }).OverallResult.ShouldBe(BuildResultCode.Success);\n+\n+            workerNodeTelemetryData!.ShouldNotBeNull();\n+            workerNodeTelemetryData.TargetsExecutionData.ShouldContainKey(\"C:Build\");\n+            workerNodeTelemetryData.TargetsExecutionData[\"C:Build\"].ShouldBeTrue();\n+            workerNodeTelemetryData.TargetsExecutionData.Keys.Count.ShouldBe(1);\n+\n+            workerNodeTelemetryData.TasksExecutionData.Keys.Count.ShouldBeGreaterThan(2);\n+            ((int)workerNodeTelemetryData.TasksExecutionData[\"Microsoft.Build.Tasks.Message\"].ExecutionsCount).ShouldBe(2);\n+            workerNodeTelemetryData.TasksExecutionData[\"Microsoft.Build.Tasks.Message\"].CumulativeExecutionTime.ShouldBeGreaterThan(TimeSpan.Zero);\n+            ((int)workerNodeTelemetryData.TasksExecutionData[\"Microsoft.Build.Tasks.CreateItem\"].ExecutionsCount).ShouldBe(1);\n+            workerNodeTelemetryData.TasksExecutionData[\"Microsoft.Build.Tasks.CreateItem\"].CumulativeExecutionTime.ShouldBeGreaterThan(TimeSpan.Zero);\n+\n+            workerNodeTelemetryData.TasksExecutionData.Keys.ShouldAllBe(k => !k.StartsWith(\"C:\") && !k.StartsWith(\"N:\"));\n+            workerNodeTelemetryData.TasksExecutionData.Values\n+                .Count(v => v.CumulativeExecutionTime > TimeSpan.Zero || v.ExecutionsCount > 0).ShouldBe(2);\n+        }\n+\n+        [Fact]\n+        public void WorkerNodeTelemetryCollection_CustomTargetsAndTasks()\n+        {\n+            WorkerNodeTelemetryData? workerNodeTelemetryData = null;\n+            InternalTelemeteryConsumingLogger.TestOnly_InternalTelemetryAggregted += dt => workerNodeTelemetryData = dt;",
              "author": {
                "login": "copilot-pull-request-reviewer"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The parameter name 'cumulativeExectionTime' has a typo. It should be 'cumulativeExecutionTime'.\n```suggestion\n    void AddTask(string name, TimeSpan cumulativeExecutionTime, short executionsCount, long totalMemoryConsumed, bool isCustom,\n```",
              "createdAt": "2025-01-30T11:39:44Z",
              "path": "src/Build/Telemetry/ITelemetryCollector.cs",
              "diffHunk": "@@ -0,0 +1,31 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.BackEnd.Logging;\n+\n+namespace Microsoft.Build.Telemetry;\n+\n+/// <summary>\n+/// A build component responsible for accumulating telemetry data from worker node and then sending it to main node\n+/// at the end of the build.\n+/// </summary>\n+internal interface ITelemetryCollector\n+{\n+    bool IsTelemetryCollected { get; }\n+\n+    void AddTask(string name, TimeSpan cumulativeExectionTime, short executionsCount, long totalMemoryConsumed, bool isCustom,",
              "author": {
                "login": "copilot-pull-request-reviewer"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The method name 'ExecutionStoped' contains a typo. It should be 'ExecutionStopped'.\n```suggestion\n                public void ExecutionStopped()\n```",
              "createdAt": "2025-01-30T11:39:44Z",
              "path": "src/Build/Instance/TaskRegistry.cs",
              "diffHunk": "@@ -1158,10 +1168,58 @@ internal class RegisteredTaskRecord : ITranslatable\n             /// </summary>\n             private int _registrationOrderId;\n \n+            /// <summary>\n+            /// Full path to the file that contains definition of this task.\n+            /// </summary>\n+            private string _definingFileFullPath;\n+\n+            /// <summary>\n+            /// Execution statistics for the tasks.\n+            /// Not translatable - the statistics are anyway expected to be reset after each project request.\n+            /// </summary>\n+            internal Stats Statistics { get; private init; } = new Stats();\n+\n+            internal class Stats()\n+            {\n+                public short ExecutedCount { get; private set; } = 0;\n+                public long TotalMemoryConsumption { get; private set; } = 0;\n+                private readonly Stopwatch _executedSw  = new Stopwatch();\n+                private long _memoryConsumptionOnStart;\n+\n+                public TimeSpan ExecutedTime => _executedSw.Elapsed;\n+\n+                public void ExecutionStarted()\n+                {\n+                    _memoryConsumptionOnStart = GC.GetTotalMemory(false);\n+                    _executedSw.Start();\n+                    ExecutedCount++;\n+                }\n+\n+                public void ExecutionStoped()",
              "author": {
                "login": "copilot-pull-request-reviewer"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "typo: MessageImportance",
              "createdAt": "2025-02-04T11:52:25Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2949,6 +2949,25 @@ private ILoggingService CreateLoggingService(\n                 forwardingLoggers = forwardingLoggers?.Concat(forwardingLogger) ?? forwardingLogger;\n             }\n \n+            if (_buildParameters.IsTelemetryEnabled)\n+            {\n+                // We do want to dictate our own forwarding logger (otherwise CentralForwardingLogger with minimum transferred importance MessageImportnace.Low is used)",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What does this acheive?",
              "createdAt": "2025-02-05T14:55:25Z",
              "path": "src/Framework/Telemetry/TaskExecutionStats.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework;\n+\n+internal class TaskExecutionStats(TimeSpan cumulativeExecutionTime, short executionsCount, long totalMemoryConsumption)\n+{\n+    public TimeSpan CumulativeExecutionTime { get; set; } = cumulativeExecutionTime;\n+    public long TotalMemoryConsumption { get; set; } = totalMemoryConsumption;\n+    public short ExecutionsCount { get; set; } = executionsCount;\n+\n+    // We need custom Equals for easier assertations in tests\n+    public override bool Equals(object? obj)\n+    {\n+        if (obj is TaskExecutionStats other)\n+        {\n+            return Equals(other);\n+        }\n+        return false;\n+    }\n+\n+    protected bool Equals(TaskExecutionStats other)\n+        => CumulativeExecutionTime.Equals(other.CumulativeExecutionTime) &&\n+           TotalMemoryConsumption == other.TotalMemoryConsumption &&\n+           ExecutionsCount == other.ExecutionsCount;\n+\n+    public override int GetHashCode()\n+    {\n+        unchecked\n+        {\n+            var hashCode = CumulativeExecutionTime.GetHashCode();\n+            hashCode = (hashCode * 397) ^ TotalMemoryConsumption.GetHashCode();\n+            hashCode = (hashCode * 397) ^ ExecutionsCount.GetHashCode();\n+            return hashCode;\n+        }\n+    }",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "It's needed since we override Equals - I added comment for it.\r\nOtherwise it's just trying to have a hash code with uniform distribution based on all members (it's a generated code, using a variant of VNF hash - that needs a specific seeding prime)",
              "createdAt": "2025-02-13T17:06:30Z",
              "path": "src/Framework/Telemetry/TaskExecutionStats.cs",
              "diffHunk": "@@ -0,0 +1,39 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework;\n+\n+internal class TaskExecutionStats(TimeSpan cumulativeExecutionTime, short executionsCount, long totalMemoryConsumption)\n+{\n+    public TimeSpan CumulativeExecutionTime { get; set; } = cumulativeExecutionTime;\n+    public long TotalMemoryConsumption { get; set; } = totalMemoryConsumption;\n+    public short ExecutionsCount { get; set; } = executionsCount;\n+\n+    // We need custom Equals for easier assertations in tests\n+    public override bool Equals(object? obj)\n+    {\n+        if (obj is TaskExecutionStats other)\n+        {\n+            return Equals(other);\n+        }\n+        return false;\n+    }\n+\n+    protected bool Equals(TaskExecutionStats other)\n+        => CumulativeExecutionTime.Equals(other.CumulativeExecutionTime) &&\n+           TotalMemoryConsumption == other.TotalMemoryConsumption &&\n+           ExecutionsCount == other.ExecutionsCount;\n+\n+    public override int GetHashCode()\n+    {\n+        unchecked\n+        {\n+            var hashCode = CumulativeExecutionTime.GetHashCode();\n+            hashCode = (hashCode * 397) ^ TotalMemoryConsumption.GetHashCode();\n+            hashCode = (hashCode * 397) ^ ExecutionsCount.GetHashCode();\n+            return hashCode;\n+        }\n+    }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "These consts are needed to prefix tasks/targets names in `TelemetryForwarderProvider`. And if I understand correctly the name can have all three prefixes.\r\nCan we instead add 3 bool values (maybe even scoop them into a class/struct smth like `SourceClassification`), and keep them in the value part of `TasksExecutionData` and `TargetsExecutionData` dictionaries? ",
              "createdAt": "2025-02-07T14:45:13Z",
              "path": "src/Framework/Telemetry/WorkerNodeTelemetryData.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+internal class WorkerNodeTelemetryData : IWorkerNodeTelemetryData\n+{\n+    // Indicate custom targets/task - those must be hashed.\n+    public const string CustomPrefix = \"C:\";\n+    // Indicate targets/tasks sourced from nuget cache - those can be custom or MSFT provided ones.\n+    public const string FromNugetPrefix = \"N:\";\n+    // Indicate targets/tasks generated during build - those must be hashed (as they contain paths).\n+    public const string MetaProjPrefix = \"M:\";",
              "author": {
                "login": "surayya-MS"
              }
            },
            {
              "body": "Those were to simplify hashing and adding the tasks/targets to dictionary (where target from nuget hiding target from sdk should not hide each other).\r\n\r\nI've now reworked this to use a custom indexing struct, that hashes the name + booleans",
              "createdAt": "2025-02-13T17:39:33Z",
              "path": "src/Framework/Telemetry/WorkerNodeTelemetryData.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+internal class WorkerNodeTelemetryData : IWorkerNodeTelemetryData\n+{\n+    // Indicate custom targets/task - those must be hashed.\n+    public const string CustomPrefix = \"C:\";\n+    // Indicate targets/tasks sourced from nuget cache - those can be custom or MSFT provided ones.\n+    public const string FromNugetPrefix = \"N:\";\n+    // Indicate targets/tasks generated during build - those must be hashed (as they contain paths).\n+    public const string MetaProjPrefix = \"M:\";",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    ITelemetryForwarder telemetryForwarder = (_componentHost.GetComponent(BuildComponentType.TelemetryForwarder) as TelemetryForwarderProvider)!.Instance;\r\n```",
              "createdAt": "2025-02-07T16:04:39Z",
              "path": "src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs",
              "diffHunk": "@@ -286,6 +287,9 @@ public void CleanupForBuild()\n                     IBuildCheckManagerProvider buildCheckProvider = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider);\n                     var buildCheckManager = buildCheckProvider!.Instance;\n                     buildCheckManager.FinalizeProcessing(_nodeLoggingContext);\n+                    // Flush and send the final telemetry data if they are being collected\n+                    ITelemetryForwarder telemetryCollector = (_componentHost.GetComponent(BuildComponentType.TelemetryForwarder) as TelemetryForwarderProvider)!.Instance;",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    telemetryForwarder.FinalizeProcessing(_nodeLoggingContext);\r\n```",
              "createdAt": "2025-02-07T16:04:54Z",
              "path": "src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs",
              "diffHunk": "@@ -286,6 +287,9 @@ public void CleanupForBuild()\n                     IBuildCheckManagerProvider buildCheckProvider = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider);\n                     var buildCheckManager = buildCheckProvider!.Instance;\n                     buildCheckManager.FinalizeProcessing(_nodeLoggingContext);\n+                    // Flush and send the final telemetry data if they are being collected\n+                    ITelemetryForwarder telemetryCollector = (_componentHost.GetComponent(BuildComponentType.TelemetryForwarder) as TelemetryForwarderProvider)!.Instance;\n+                    telemetryCollector.FinalizeProcessing(_nodeLoggingContext);",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            ITelemetryForwarder telemetryForwarder =\r\n```",
              "createdAt": "2025-02-07T16:06:01Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -1257,6 +1260,86 @@ BuildResult CopyTargetResultsFromProxyTargetsToRealTargets(BuildResult resultFro\n             }\n         }\n \n+        private void UpdateStatisticsPostBuild()\n+        {\n+            ITelemetryForwarder collector =",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    telemetryForwarder.AddTask(registeredTaskRecord.TaskIdentity.Name,\r\n```",
              "createdAt": "2025-02-07T16:06:44Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -1257,6 +1260,86 @@ BuildResult CopyTargetResultsFromProxyTargetsToRealTargets(BuildResult resultFro\n             }\n         }\n \n+        private void UpdateStatisticsPostBuild()\n+        {\n+            ITelemetryForwarder collector =\n+                ((TelemetryForwarderProvider)_componentHost.GetComponent(BuildComponentType.TelemetryForwarder))\n+                .Instance;\n+\n+            if (!collector.IsTelemetryCollected)\n+            {\n+                return;\n+            }\n+\n+            IResultsCache resultsCache = (IResultsCache)_componentHost.GetComponent(BuildComponentType.ResultsCache);\n+            // The TargetBuilder filters out results for targets not explicitly requested before returning the result.\n+            // Hence we need to fetch the original result from the cache - to get the data for all executed targets.\n+            BuildResult unfilteredResult = resultsCache.GetResultsForConfiguration(_requestEntry.Request.ConfigurationId);\n+\n+            foreach (var projectTargetInstance in _requestEntry.RequestConfiguration.Project.Targets)\n+            {\n+                bool wasExecuted =\n+                    unfilteredResult.ResultsByTarget.TryGetValue(projectTargetInstance.Key, out TargetResult targetResult) &&\n+                    // We need to match on location of target as well - as multiple targets with same name can be defined.\n+                    // E.g. _SourceLinkHasSingleProvider can be brought explicitly via nuget (Microsoft.SourceLink.GitHub) as well as sdk\n+                    projectTargetInstance.Value.Location.Equals(targetResult.TargetLocation);\n+\n+                bool isFromNuget, isMetaprojTarget, isCustom;\n+\n+                if (IsMetaprojTargetPath(projectTargetInstance.Value.FullPath))\n+                {\n+                    isMetaprojTarget = true;\n+                    isFromNuget = false;\n+                    isCustom = false;\n+                }\n+                else\n+                {\n+                    isMetaprojTarget = false;\n+                    isFromNuget = FileClassifier.Shared.IsInNugetCache(projectTargetInstance.Value.FullPath);\n+                    isCustom = !FileClassifier.Shared.IsBuiltInLogic(projectTargetInstance.Value.FullPath) ||\n+                               // add the isFromNuget to condition - to prevent double checking of nonnuget package\n+                               (isFromNuget && FileClassifier.Shared.IsMicrosoftPackageInNugetCache(projectTargetInstance.Value.FullPath));\n+                }\n+\n+                collector.AddTarget(\n+                    projectTargetInstance.Key,\n+                    // would we want to distinguish targets that were executed only during this execution - we'd need\n+                    //  to remember target names from ResultsByTarget from before execution\n+                    wasExecuted,\n+                    isCustom,\n+                    isMetaprojTarget,\n+                    isFromNuget);\n+            }\n+\n+            TaskRegistry taskReg = _requestEntry.RequestConfiguration.Project.TaskRegistry;\n+            CollectTasksStats(taskReg);\n+\n+            void CollectTasksStats(TaskRegistry taskRegistry)\n+            {\n+                if (taskRegistry == null)\n+                {\n+                    return;\n+                }\n+\n+                foreach (TaskRegistry.RegisteredTaskRecord registeredTaskRecord in taskRegistry.TaskRegistrations.Values.SelectMany(record => record))\n+                {\n+                    collector.AddTask(registeredTaskRecord.TaskIdentity.Name,",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                telemetryForwarder.AddTarget(\r\n```",
              "createdAt": "2025-02-07T16:08:00Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -1257,6 +1260,86 @@ BuildResult CopyTargetResultsFromProxyTargetsToRealTargets(BuildResult resultFro\n             }\n         }\n \n+        private void UpdateStatisticsPostBuild()\n+        {\n+            ITelemetryForwarder collector =\n+                ((TelemetryForwarderProvider)_componentHost.GetComponent(BuildComponentType.TelemetryForwarder))\n+                .Instance;\n+\n+            if (!collector.IsTelemetryCollected)\n+            {\n+                return;\n+            }\n+\n+            IResultsCache resultsCache = (IResultsCache)_componentHost.GetComponent(BuildComponentType.ResultsCache);\n+            // The TargetBuilder filters out results for targets not explicitly requested before returning the result.\n+            // Hence we need to fetch the original result from the cache - to get the data for all executed targets.\n+            BuildResult unfilteredResult = resultsCache.GetResultsForConfiguration(_requestEntry.Request.ConfigurationId);\n+\n+            foreach (var projectTargetInstance in _requestEntry.RequestConfiguration.Project.Targets)\n+            {\n+                bool wasExecuted =\n+                    unfilteredResult.ResultsByTarget.TryGetValue(projectTargetInstance.Key, out TargetResult targetResult) &&\n+                    // We need to match on location of target as well - as multiple targets with same name can be defined.\n+                    // E.g. _SourceLinkHasSingleProvider can be brought explicitly via nuget (Microsoft.SourceLink.GitHub) as well as sdk\n+                    projectTargetInstance.Value.Location.Equals(targetResult.TargetLocation);\n+\n+                bool isFromNuget, isMetaprojTarget, isCustom;\n+\n+                if (IsMetaprojTargetPath(projectTargetInstance.Value.FullPath))\n+                {\n+                    isMetaprojTarget = true;\n+                    isFromNuget = false;\n+                    isCustom = false;\n+                }\n+                else\n+                {\n+                    isMetaprojTarget = false;\n+                    isFromNuget = FileClassifier.Shared.IsInNugetCache(projectTargetInstance.Value.FullPath);\n+                    isCustom = !FileClassifier.Shared.IsBuiltInLogic(projectTargetInstance.Value.FullPath) ||\n+                               // add the isFromNuget to condition - to prevent double checking of nonnuget package\n+                               (isFromNuget && FileClassifier.Shared.IsMicrosoftPackageInNugetCache(projectTargetInstance.Value.FullPath));\n+                }\n+\n+                collector.AddTarget(",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      }
    ]
  }
}