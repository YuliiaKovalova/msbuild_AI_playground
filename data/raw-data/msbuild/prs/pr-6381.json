{
  "number": 6381,
  "title": "Optimize logging by moving message importance checks earlier",
  "body": "Fixes #5992 \r\n\r\n### Context\r\n\r\nSome tasks spend a lot of time producing detailed log messages that end up going nowhere when building on the command line with Normal or Minimum verbosity. The goal of this PR is to expose an API for tasks to call to answer the question _\"Are log messages of a given importance going to be consumed by a logger or should I not bother doing the work to create the output and skip calling `LogMessage` altogether?\"_\r\n\r\n### Changes Made\r\n\r\nAdded a public method named `LogsMessagesOfImportance` on `TaskLoggingHelper` to answer the question above. This PR focuses on command line scenarios such as `dotnet build` but the logic could be easily used/extended to work with 3rd party loggers (in IDEs for example) if we introduce a mechanism by which loggers promise to ignore too verbose messages. The solution presented herein is a bolt-on, making minimum changes to the existing logging infra. Third party loggers are assumed to be potentially logging everything so if at least one such logger is registered, the optimization is disabled.\r\n\r\nThe new method is used internally by `TaskLoggingHelper` and by the otherwise spammy RAR task.\r\n\r\n### Testing\r\n\r\nExisting and new unit tests, manual verification on command line as well as in Visual Studio.\r\n\r\nPerformance testing has shown ~18 ms improvement in RAR run-time alone when building a single project with `dotnet build`.\r\n\r\n### Notes\r\n\r\nThis PR also introduces a new class `EngineServices` to serve as a replacement for the `IBuildEngineN` interfaces.",
  "state": "MERGED",
  "createdAt": "2021-04-28T20:56:15Z",
  "updatedAt": "2021-08-05T11:57:13Z",
  "closedAt": "2021-08-05T11:57:10Z",
  "mergedAt": "2021-08-05T11:57:10Z",
  "additions": 520,
  "deletions": 59,
  "changedFiles": 25,
  "headRefName": "5992-aggressive-verbosity-checks",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "rainersigwald"
      }
    ]
  },
  "labels": [
    "Area: Performance",
    "Area: Logging",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "5eae5d5fac94a02c93e949668c86c7bb1d98562d",
          "message": "Enable CreateForwardingLoggerRecord in /m:1 builds with forced out-of-proc execution",
          "committedDate": "2021-08-02T09:55:40Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e29276d0ec5e7c3606b61c571da3b3b1107225ae",
          "message": "Introduce IBuildEngineInternal",
          "committedDate": "2021-08-02T09:55:40Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b415d4d744d14c92195fd6d720df1afd28b2d404",
          "message": "Factor ImportanceToMinimumVerbosity out of Serial and Parallel console logger",
          "committedDate": "2021-08-02T09:55:40Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "990ee07867dc4100ce36abe32d0d1584081b5f73",
          "message": "Introduce GetMinimumMessageImportance on ConsoleLogger and ConfigurableForwardingLogger",
          "committedDate": "2021-08-02T09:55:40Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5303502444cd6abf19366472f22d0bd95db42994",
          "message": "Introduce LoggingService.MinimumRequiredMessageImportance",
          "committedDate": "2021-08-02T09:55:40Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5de1796245a06fbacc7401879fde8973df1d3e7",
          "message": "Introduce TaskLoggingHelper.ShouldLogMessage",
          "committedDate": "2021-08-02T09:55:40Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "73858441a717f875bd7465896426dad1d2e51f17",
          "message": "Make RAR use ShouldLogMessage",
          "committedDate": "2021-08-02T09:55:41Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dd7924d613e3c87da775119d38c6c821a9662340",
          "message": "Add unit tests",
          "committedDate": "2021-08-02T09:55:41Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5a3997b9122d02fcfbca51c9255446eceb426f43",
          "message": "PR feedback: Use switch expression in UpdateMinimumMessageImportance",
          "committedDate": "2021-08-02T09:55:41Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b21abfaddb263c80cf5713a37094672fe6573705",
          "message": "PR feedback: Kill IBuildEngineInternal, use class with virtual methods instead",
          "committedDate": "2021-08-02T09:55:41Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "14f5576685fcd1dd70fe4ae3fca2f93f6a29423b",
          "message": "Make BuildEngineInterfaceImpl serializable to work in cross-domain scenarios",
          "committedDate": "2021-08-02T09:55:41Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5c6e16553b0e0cdc42b871075becbdd80aad3c3b",
          "message": "Don't require IBuildEngine10 in all build engine implementations",
          "committedDate": "2021-08-02T09:55:41Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "24b4dec5e3feaaa4cd11c9bb79060e60969bf980",
          "message": "PR feedback: Rename MinimumRequiredMessageImportance to LogsMessagesOfImportance",
          "committedDate": "2021-08-02T09:55:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a42b39faefebba5f416c5760c4810afc53a24542",
          "message": "Rename ShouldLogMessage to LogsMessagesOfImportance",
          "committedDate": "2021-08-02T09:55:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e06cd263739401fe36e47bb86e0c7c620682096c",
          "message": "Disable the optimization when TaskHost is remoted to another AD",
          "committedDate": "2021-08-02T09:55:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ddbaa1a0552196c72955d406d45cb39e240e8e66",
          "message": "PR feedback: Fix the capacity of _forwardingTable",
          "committedDate": "2021-08-02T09:55:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "483924f07185f935d37fc83100c2e5c5ba864e11",
          "message": "Add Version to BuildEngineInterface",
          "committedDate": "2021-08-02T09:55:43Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "25084f9fe3c3b70fcc9a13d456777ebda4ee72df",
          "message": "Add BuildEngineInterface version bump check to CI",
          "committedDate": "2021-08-02T09:55:43Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3e0d105733ebcce62fc8037d3663cdd3f3ccf894",
          "message": "Use a target branch environment variable instead of hard-coding main",
          "committedDate": "2021-08-02T09:55:43Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d7abbbb21be9051830552649e269890d50402336",
          "message": "Fix merge conflicts",
          "committedDate": "2021-08-02T09:58:02Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aefc16f0981480272c6fa743a044c3079f1477b6",
          "message": "PR feedback: Comment 'MessageImportance.High - 1'",
          "committedDate": "2021-08-02T11:18:53Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bdf6b18c82148f1039bad37bff99268a19ecfc95",
          "message": "PR feedback: Comment distributed logger registration",
          "committedDate": "2021-08-02T11:24:58Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6c6573db49d0094858efa310ebec8f4b13481597",
          "message": "Rename BuildEngineInterface -> EngineServices",
          "committedDate": "2021-08-05T09:25:46Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Do you think we should tack on a fix for https://github.com/dotnet/msbuild/issues/6305 (expose LogTaskInputs to tasks) in this PR or separately?\r\n\r\nIt's very similar in nature and should be easy to add if we're modifying the build engine interface anyway.\r\nHere's the prototype I made: https://github.com/dotnet/msbuild/commit/1011f1771ff1460bfebb74210de8469339cfca35\r\n\r\nOf course use the different API but the intention is the same.",
        "createdAt": "2021-04-29T21:52:35Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "> Do you think we should tack on a fix for #6305 (expose LogTaskInputs to tasks) in this PR or separately?\r\n> \r\n> It's very similar in nature and should be easy to add if we're modifying the build engine interface anyway.\r\n> Here's the prototype I made: [1011f17](https://github.com/dotnet/msbuild/commit/1011f1771ff1460bfebb74210de8469339cfca35)\r\n> \r\n> Of course use the different API but the intention is the same.\r\n\r\nThe effects and solutions seem similar, but the problems they're trying to solve feel different enough to me that I'd slightly prefer them in separate PRs. One tries to eliminate unnecessary abortive attempts at logging messages, and the other eliminates duplicate log messages by fixing a prior bug. I don't mind if you want to add it here, though, and I think both are good improvements.",
        "createdAt": "2021-04-29T22:11:03Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I'm just not sure what's the good design here, I guess it's up to you guys to decide on one. It involves how we plan to evolve IBuildEngine* in the future.",
        "createdAt": "2021-04-29T22:51:16Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I still have to address a few comments but I wanted to get the new `BuildEngineInterface` out to get feedback. This is the new mechanism to evolve the build engine API. Instead of adding a new COM-like `IBuildEngineN` interface in each release, we stop at `IBuildEngine10` that lets the caller get a reference to an abstract class, which I believe was the agreement in previous discussions on this topic.",
        "createdAt": "2021-05-21T20:57:41Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "I wasn't paying much attention, but a reminder that I'm still super interested in exposing LogTaskInputs to tasks, so RAR can turn off its custom logging if we're logging all inputs anyway: https://github.com/dotnet/msbuild/issues/6305\r\n\r\nWhatever design we come up with for IBuildEngine*, please keep the scenario ^^ in mind as well. Pretty much please stick `bool LogTaskInputs { get; }` on there somewhere so tasks can access.\r\n\r\nNot saying it should be a part of this PR though!\r\n\r\nThanks!",
        "createdAt": "2021-05-24T20:00:13Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Will definitely do, @KirillOsenkov. Likely as a separate PR.",
        "createdAt": "2021-05-26T13:18:40Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "<samp>\nPull request contains merge conflicts.<br>\r\n\n</samp>",
        "createdAt": "2021-05-28T19:46:44Z",
        "author": {
          "login": "azure-pipelines"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "MessageImportance minimumImportance = switch (innerLogger)...",
              "createdAt": "2021-04-29T20:53:10Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -1542,10 +1561,71 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)\n                 InternalLoggerException.Throw(e, null, \"FatalErrorWhileInitializingLogger\", true, logger.GetType().Name);\n             }\n \n+            // Update the minimum guaranteed message importance based on the newly added logger.\n+            UpdateMinimumMessageImportance(logger);\n+\n             // Keep track of the loggers so they can be unregistered later on\n             _loggers.Add(logger);\n         }\n \n+        /// <summary>\n+        /// Updates <see cref=\"_minimumRequiredMessageImportance\"/> based on the given <paramref name=\"logger\"/>.\n+        /// </summary>\n+        /// <param name=\"logger\">The newly registered logger.</param>\n+        /// <remarks>\n+        /// This method contains knowledge about several logger classes used by MSBuild. The goal is to optimize common scenarios,\n+        /// such as building on the command line with normal or minimum verbosity. If the user registers an external custom logger,\n+        /// we will fall back to \"minimum importance\" == Low because we don't know how the logger processes messages, therefore we\n+        /// must feed it everything.\n+        /// </remarks>\n+        private void UpdateMinimumMessageImportance(ILogger logger)\n+        {\n+            var innerLogger = (logger is Evaluation.ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;\n+\n+            MessageImportance minimumImportance;\n+            if (innerLogger is Build.Logging.ConsoleLogger consoleLogger)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Done, thank you!",
              "createdAt": "2021-05-21T20:44:37Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -1542,10 +1561,71 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)\n                 InternalLoggerException.Throw(e, null, \"FatalErrorWhileInitializingLogger\", true, logger.GetType().Name);\n             }\n \n+            // Update the minimum guaranteed message importance based on the newly added logger.\n+            UpdateMinimumMessageImportance(logger);\n+\n             // Keep track of the loggers so they can be unregistered later on\n             _loggers.Add(logger);\n         }\n \n+        /// <summary>\n+        /// Updates <see cref=\"_minimumRequiredMessageImportance\"/> based on the given <paramref name=\"logger\"/>.\n+        /// </summary>\n+        /// <param name=\"logger\">The newly registered logger.</param>\n+        /// <remarks>\n+        /// This method contains knowledge about several logger classes used by MSBuild. The goal is to optimize common scenarios,\n+        /// such as building on the command line with normal or minimum verbosity. If the user registers an external custom logger,\n+        /// we will fall back to \"minimum importance\" == Low because we don't know how the logger processes messages, therefore we\n+        /// must feed it everything.\n+        /// </remarks>\n+        private void UpdateMinimumMessageImportance(ILogger logger)\n+        {\n+            var innerLogger = (logger is Evaluation.ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;\n+\n+            MessageImportance minimumImportance;\n+            if (innerLogger is Build.Logging.ConsoleLogger consoleLogger)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could this break someone if they set the MSBUILDNOINPROCNODE flag partway through the build? I vaguely remember a case similar to that.",
              "createdAt": "2021-04-29T20:57:19Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -33,12 +34,13 @@ internal class TaskHost :\n #if FEATURE_APPDOMAIN\n         MarshalByRefObject,\n #endif\n+        IBuildEngineInternal,\n         IBuildEngine9\n     {\n         /// <summary>\n         /// True if the \"secret\" environment variable MSBUILDNOINPROCNODE is set.\n         /// </summary>\n-        private static bool s_onlyUseOutOfProcNodes = Environment.GetEnvironmentVariable(\"MSBUILDNOINPROCNODE\") == \"1\";\n+        private static bool s_onlyUseOutOfProcNodes = Traits.Instance.ForceOutOfProcBuildExecution;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "As with many escape hatches, we may get into an interesting state if different processes run with different environment variables. I don't think this change is making much of a difference, though, as we're still reading the value from the current process, potentially at a different time. To break something, there would have to be an entity setting the variable on the current running process which is very unlikely.\r\n\r\nThe ultimate fix would be to take a snapshot of the relevant environment variables in the main node, and either make them part of the handshake (connect only to nodes running with the same variables), or be sending them with requests (to avoid reading them in remote nodes altogether). Honestly, it looks like an overkill.",
              "createdAt": "2021-05-24T12:59:30Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -33,12 +34,13 @@ internal class TaskHost :\n #if FEATURE_APPDOMAIN\n         MarshalByRefObject,\n #endif\n+        IBuildEngineInternal,\n         IBuildEngine9\n     {\n         /// <summary>\n         /// True if the \"secret\" environment variable MSBUILDNOINPROCNODE is set.\n         /// </summary>\n-        private static bool s_onlyUseOutOfProcNodes = Environment.GetEnvironmentVariable(\"MSBUILDNOINPROCNODE\") == \"1\";\n+        private static bool s_onlyUseOutOfProcNodes = Traits.Instance.ForceOutOfProcBuildExecution;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Found the bug I was thinking of:\r\nhttps://devdiv.visualstudio.com/DevDiv/_workitems/edit/1197992\r\nI'm not sure we should support this sort of thing, but felt I should call it out.",
              "createdAt": "2021-05-24T14:13:02Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -33,12 +34,13 @@ internal class TaskHost :\n #if FEATURE_APPDOMAIN\n         MarshalByRefObject,\n #endif\n+        IBuildEngineInternal,\n         IBuildEngine9\n     {\n         /// <summary>\n         /// True if the \"secret\" environment variable MSBUILDNOINPROCNODE is set.\n         /// </summary>\n-        private static bool s_onlyUseOutOfProcNodes = Environment.GetEnvironmentVariable(\"MSBUILDNOINPROCNODE\") == \"1\";\n+        private static bool s_onlyUseOutOfProcNodes = Traits.Instance.ForceOutOfProcBuildExecution;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Oh, wow, if we [backported a fix for this](https://github.com/dotnet/msbuild/pull/5764) in the past, let's definitely not change the behavior. I'll revert the change. Thank you!",
              "createdAt": "2021-05-24T14:33:27Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -33,12 +34,13 @@ internal class TaskHost :\n #if FEATURE_APPDOMAIN\n         MarshalByRefObject,\n #endif\n+        IBuildEngineInternal,\n         IBuildEngine9\n     {\n         /// <summary>\n         /// True if the \"secret\" environment variable MSBUILDNOINPROCNODE is set.\n         /// </summary>\n-        private static bool s_onlyUseOutOfProcNodes = Environment.GetEnvironmentVariable(\"MSBUILDNOINPROCNODE\") == \"1\";\n+        private static bool s_onlyUseOutOfProcNodes = Traits.Instance.ForceOutOfProcBuildExecution;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Did we decide we wanted to go forward with this internal IBuildEngine? I'm in favor, but I wasn't clear there was a definitive agreement.",
              "createdAt": "2021-04-29T21:02:33Z",
              "path": "src/Framework/IBuildEngineInternal.cs",
              "diffHunk": "@@ -0,0 +1,20 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///\n+    /// </summary>\n+    internal interface IBuildEngineInternal",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I've removed it and introduced the ultimate `IBuildEngine10` which exposes a new versioning mechanism.",
              "createdAt": "2021-05-21T20:45:42Z",
              "path": "src/Framework/IBuildEngineInternal.cs",
              "diffHunk": "@@ -0,0 +1,20 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///\n+    /// </summary>\n+    internal interface IBuildEngineInternal",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Isn't it more fluent to have users call it like `if (BuildEngine.LogsMessagesOfImporance(MessageImportance.Low)) {/*log low importance message*/}`? Or a shorter ``if (BuildEngine.IsLogging(MessageImportance.Low)) {/*log low importance message*/}``",
              "createdAt": "2021-05-04T18:36:42Z",
              "path": "src/Framework/IBuildEngineInternal.cs",
              "diffHunk": "@@ -0,0 +1,20 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///\n+    /// </summary>\n+    internal interface IBuildEngineInternal\n+    {\n+        /// <summary>\n+        /// Returns the minimum message importance not guaranteed to be ignored by registered loggers.\n+        /// </summary>\n+        /// <remarks>\n+        /// Example: If we know that no logger is interested in MessageImportance.Low, this property returns\n+        /// MessageImportance.Normal. If loggers may consume any messages, this property returns MessageImportance.Low.\n+        /// </remarks>\n+        MessageImportance MinimumRequiredMessageImportance { get; }",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I've turned it into a method as suggested: `bool LogsMessagesOfImportance(MessageImportance importance)`, thank you!",
              "createdAt": "2021-05-24T13:52:49Z",
              "path": "src/Framework/IBuildEngineInternal.cs",
              "diffHunk": "@@ -0,0 +1,20 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    ///\n+    /// </summary>\n+    internal interface IBuildEngineInternal\n+    {\n+        /// <summary>\n+        /// Returns the minimum message importance not guaranteed to be ignored by registered loggers.\n+        /// </summary>\n+        /// <remarks>\n+        /// Example: If we know that no logger is interested in MessageImportance.Low, this property returns\n+        /// MessageImportance.Normal. If loggers may consume any messages, this property returns MessageImportance.Low.\n+        /// </remarks>\n+        MessageImportance MinimumRequiredMessageImportance { get; }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: can use `<inheritdoc/>` to avoid copy pasting the supertype's doc",
              "createdAt": "2021-05-04T18:41:35Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -867,6 +868,11 @@ internal void ReleaseAllCores()\n             }\n         }\n \n+        /// <summary>\n+        /// Returns the minimum message importance not guaranteed to be ignored by registered loggers.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Thank you, I didn't know this tag existed.",
              "createdAt": "2021-05-21T20:48:16Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -867,6 +868,11 @@ internal void ReleaseAllCores()\n             }\n         }\n \n+        /// <summary>\n+        /// Returns the minimum message importance not guaranteed to be ignored by registered loggers.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This would best reside somewhere else (LoggingService?) if we were to support third party loggers, right?",
              "createdAt": "2021-05-04T18:45:18Z",
              "path": "src/Build/Logging/BaseConsoleLogger.cs",
              "diffHunk": "@@ -329,6 +329,33 @@ internal void IsRunningWithCharacterFileType()\n         /// </summary>\n         internal bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity) => Verbosity >= checkVerbosity;\n \n+        /// <summary>\n+        /// Returns the minimum logger verbosity required to log a message with the given importance.\n+        /// </summary>\n+        /// <param name=\"importance\">The message importance.</param>\n+        /// <param name=\"lightenText\">True if the message should be rendered using lighter colored text.</param>\n+        /// <returns>The logger verbosity required to log a message of the given <paramref name=\"importance\"/>.</returns>\n+        internal static LoggerVerbosity ImportanceToMinimumVerbosity(MessageImportance importance, out bool lightenText)",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I wonder if supporting 3rd party loggers wouldn't require extending the contract between MSBuild and loggers where the logger would indicate its verbosity directly in terms of `MessageImportance`. Just like they choose if they're interested in, say, `BuildStarted` and `BuildFinished` today, they would also say they want messages only with the given importance.\r\n\r\nIt's true that we may want to expose a helper with a default mapping between verbosity and importance but ultimately it is up to the logger what exactly it chooses to log.",
              "createdAt": "2021-05-24T13:25:21Z",
              "path": "src/Build/Logging/BaseConsoleLogger.cs",
              "diffHunk": "@@ -329,6 +329,33 @@ internal void IsRunningWithCharacterFileType()\n         /// </summary>\n         internal bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity) => Verbosity >= checkVerbosity;\n \n+        /// <summary>\n+        /// Returns the minimum logger verbosity required to log a message with the given importance.\n+        /// </summary>\n+        /// <param name=\"importance\">The message importance.</param>\n+        /// <param name=\"lightenText\">True if the message should be rendered using lighter colored text.</param>\n+        /// <returns>The logger verbosity required to log a message of the given <paramref name=\"importance\"/>.</returns>\n+        internal static LoggerVerbosity ImportanceToMinimumVerbosity(MessageImportance importance, out bool lightenText)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would it make sense to implement the static GetMinimumMessageImportance and ImportanceToMinimumVerbosity as extension methods on the enums instead? Should it really depend on the loggers how these two enums get mapped between themselves?",
              "createdAt": "2021-05-04T18:52:58Z",
              "path": "src/Build/Logging/ConsoleLogger.cs",
              "diffHunk": "@@ -477,6 +475,30 @@ public void CustomEventHandler(object sender, CustomBuildEventArgs e)\n             _consoleLogger.CustomEventHandler(sender, e);\n         }\n \n+        /// <summary>\n+        /// Returns the minimum importance of messages logged by this logger.\n+        /// </summary>\n+        /// <returns>\n+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)\n+        /// if this logger does not log messages of any importance.\n+        /// </returns>\n+        internal MessageImportance GetMinimumMessageImportance()\n+        {\n+            if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Low, out _))",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Adding an extension method is a great idea. Same as the other comment, I think it makes sense to do when we expose the concept of minimum message importance to external loggers.",
              "createdAt": "2021-05-24T13:37:12Z",
              "path": "src/Build/Logging/ConsoleLogger.cs",
              "diffHunk": "@@ -477,6 +475,30 @@ public void CustomEventHandler(object sender, CustomBuildEventArgs e)\n             _consoleLogger.CustomEventHandler(sender, e);\n         }\n \n+        /// <summary>\n+        /// Returns the minimum importance of messages logged by this logger.\n+        /// </summary>\n+        /// <returns>\n+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)\n+        /// if this logger does not log messages of any importance.\n+        /// </returns>\n+        internal MessageImportance GetMinimumMessageImportance()\n+        {\n+            if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Low, out _))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't this be placed on IBuildEngine instead, to support all `ITask` subtypes to use it? Only `Task` subtypes get the `TaskLoggingHelper`",
              "createdAt": "2021-05-04T19:00:44Z",
              "path": "ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs",
              "diffHunk": "@@ -434,6 +434,7 @@ public partial class TaskLoggingHelper : System.MarshalByRefObject\n         public void LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) { }\n         public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }\n         public void MarkAsInactive() { }\n+        public bool ShouldLogMessage(Microsoft.Build.Framework.MessageImportance importance) { throw null; }",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I've been thinking, should we just expose the verbosity from the engine, and have an extension method ShouldLogMessage that reads that verbosity and compares with the one the task passes in?",
              "createdAt": "2021-05-12T04:10:37Z",
              "path": "ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs",
              "diffHunk": "@@ -434,6 +434,7 @@ public partial class TaskLoggingHelper : System.MarshalByRefObject\n         public void LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) { }\n         public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }\n         public void MarkAsInactive() { }\n+        public bool ShouldLogMessage(Microsoft.Build.Framework.MessageImportance importance) { throw null; }",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "We would still have to look at verbosity in the logger, since you could attach multiple loggers with different verbosities.\r\n\r\nFinding the maximum verbosity of any logger and revealing it through this ShouldLogMessage method seems about the best we can do.",
              "createdAt": "2021-05-12T16:04:09Z",
              "path": "ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs",
              "diffHunk": "@@ -434,6 +434,7 @@ public partial class TaskLoggingHelper : System.MarshalByRefObject\n         public void LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) { }\n         public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }\n         public void MarkAsInactive() { }\n+        public bool ShouldLogMessage(Microsoft.Build.Framework.MessageImportance importance) { throw null; }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I have exposed it on `IBuildEngine` (specifically through `IBuildEngine10` -> `BuildEngineInterface` interface) and left it on `TaskLoggingHelper` as well for convenience.",
              "createdAt": "2021-05-24T13:51:07Z",
              "path": "ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs",
              "diffHunk": "@@ -434,6 +434,7 @@ public partial class TaskLoggingHelper : System.MarshalByRefObject\n         public void LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) { }\n         public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }\n         public void MarkAsInactive() { }\n+        public bool ShouldLogMessage(Microsoft.Build.Framework.MessageImportance importance) { throw null; }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Verify (maybe via reflection?) that it exists?I don't think it's critical in this case, but it would be necessary for any later additions to EngineInterface.",
              "createdAt": "2021-05-21T20:54:43Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -235,9 +235,19 @@ public virtual string GetResourceMessage(string resourceName)\n             string resourceString = FormatResourceString(resourceName, null);\n             return resourceString;\n         }\n-#endregion\n+        #endregion\n+\n+        #region Message logging methods\n \n-#region Message logging methods\n+        /// <summary>\n+        /// Returns true if a message of given importance should be logged because it is possible that a logger consuming it exists.\n+        /// </summary>\n+        /// <param name=\"importance\">The importance to check.</param>\n+        /// <returns>True if messages of the given importance should be logged, false if it's guaranteed that such messages would be ignored.</returns>\n+        public bool ShouldLogMessage(MessageImportance importance)\n+        {\n+            return importance <= ((IBuildEngine10)BuildEngine).EngineInterface.MinimumRequiredMessageImportance;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This I'm not sure is necessary. In the previous model trying to cast to `IBuildEngineN` would never gracefully fail, as the type would fail to bind at JIT time should MSBuild be older than what the caller was built against.\r\n\r\nIn other words, I don't think \"light-up\" should be the goal here because it never worked.",
              "createdAt": "2021-05-21T21:01:09Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -235,9 +235,19 @@ public virtual string GetResourceMessage(string resourceName)\n             string resourceString = FormatResourceString(resourceName, null);\n             return resourceString;\n         }\n-#endregion\n+        #endregion\n+\n+        #region Message logging methods\n \n-#region Message logging methods\n+        /// <summary>\n+        /// Returns true if a message of given importance should be logged because it is possible that a logger consuming it exists.\n+        /// </summary>\n+        /// <param name=\"importance\">The importance to check.</param>\n+        /// <returns>True if messages of the given importance should be logged, false if it's guaranteed that such messages would be ignored.</returns>\n+        public bool ShouldLogMessage(MessageImportance importance)\n+        {\n+            return importance <= ((IBuildEngine10)BuildEngine).EngineInterface.MinimumRequiredMessageImportance;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "As discussed, light-up **is** a goal and will be implemented by exposing a version prop.",
              "createdAt": "2021-05-28T12:19:30Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -235,9 +235,19 @@ public virtual string GetResourceMessage(string resourceName)\n             string resourceString = FormatResourceString(resourceName, null);\n             return resourceString;\n         }\n-#endregion\n+        #endregion\n+\n+        #region Message logging methods\n \n-#region Message logging methods\n+        /// <summary>\n+        /// Returns true if a message of given importance should be logged because it is possible that a logger consuming it exists.\n+        /// </summary>\n+        /// <param name=\"importance\">The importance to check.</param>\n+        /// <returns>True if messages of the given importance should be logged, false if it's guaranteed that such messages would be ignored.</returns>\n+        public bool ShouldLogMessage(MessageImportance importance)\n+        {\n+            return importance <= ((IBuildEngine10)BuildEngine).EngineInterface.MinimumRequiredMessageImportance;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If the values for this table are always 0 or 1, why a dictionary rather than a set? Also, at initialization time, size of 17 would make more sense than 15.",
              "createdAt": "2021-05-24T17:36:05Z",
              "path": "src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs",
              "diffHunk": "@@ -258,6 +258,30 @@ private void SetForwardingBasedOnVerbosity()\n             }\n         }\n \n+        /// <summary>\n+        /// Returns the minimum importance of messages logged by this logger.\n+        /// </summary>\n+        /// <returns>\n+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)\n+        /// if this logger does not log messages of any importance.\n+        /// </returns>\n+        internal MessageImportance GetMinimumMessageImportance()\n+        {\n+            if (_forwardingTable[LowMessageEventDescription] == 1)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Ah, I believe that this code was originally written before `HashSet<T>` existed. Is now a good time to fix it? I vote for yes!",
              "createdAt": "2021-05-26T13:33:49Z",
              "path": "src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs",
              "diffHunk": "@@ -258,6 +258,30 @@ private void SetForwardingBasedOnVerbosity()\n             }\n         }\n \n+        /// <summary>\n+        /// Returns the minimum importance of messages logged by this logger.\n+        /// </summary>\n+        /// <returns>\n+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)\n+        /// if this logger does not log messages of any importance.\n+        /// </returns>\n+        internal MessageImportance GetMinimumMessageImportance()\n+        {\n+            if (_forwardingTable[LowMessageEventDescription] == 1)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I was wrong, it actually distinguishes between having the value of 0 and not being in the dictionary:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/9d419252d876a6f30366c3ce22ec7249391c1f02/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs#L132-L136\r\n\r\nI'll fix only the capacity.",
              "createdAt": "2021-05-26T14:06:47Z",
              "path": "src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs",
              "diffHunk": "@@ -258,6 +258,30 @@ private void SetForwardingBasedOnVerbosity()\n             }\n         }\n \n+        /// <summary>\n+        /// Returns the minimum importance of messages logged by this logger.\n+        /// </summary>\n+        /// <returns>\n+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)\n+        /// if this logger does not log messages of any importance.\n+        /// </returns>\n+        internal MessageImportance GetMinimumMessageImportance()\n+        {\n+            if (_forwardingTable[LowMessageEventDescription] == 1)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why does this (and equivalent) have to be after the checks?",
              "createdAt": "2021-05-24T18:53:32Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -279,6 +290,10 @@ public void LogMessage(MessageImportance importance, string message, params obje\n                 ResourceUtilities.FormatString(message, messageArgs);\n             }\n #endif\n+            if (!LogsMessagesOfImportance(importance))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I didn't like the idea of parameters being validated conditionally. The caller should be getting the same behavior regardless of whether the log output was swallowed or not. I understand it is at the expense of performance but the impact is negligible and it prevent bugs where something breaks only when building at high enough log verbosity.",
              "createdAt": "2021-05-26T13:27:35Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -279,6 +290,10 @@ public void LogMessage(MessageImportance importance, string message, params obje\n                 ResourceUtilities.FormatString(message, messageArgs);\n             }\n #endif\n+            if (!LogsMessagesOfImportance(importance))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "That's reasonable. I was thinking that this only partially validates the input anyway, which might save some people without saving everyone, which could be confusing, but the more errors prevented the better.",
              "createdAt": "2021-05-26T14:07:37Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -279,6 +290,10 @@ public void LogMessage(MessageImportance importance, string message, params obje\n                 ResourceUtilities.FormatString(message, messageArgs);\n             }\n #endif\n+            if (!LogsMessagesOfImportance(importance))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nDoes this have to be abstract? Only method is virtual.",
              "createdAt": "2021-05-24T18:58:56Z",
              "path": "src/Framework/BuildEngineInterface.cs",
              "diffHunk": "@@ -0,0 +1,30 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Exposes build engine functionality that was made available in newer versions of MSBuild.\n+    /// </summary>\n+    /// <remarks>\n+    /// Make all members virtual but not abstract, ensuring that implementations can override them and external implementations\n+    /// won't break when the class is extended with new members. This base implementation should be throwing <see cref=\"NotImplementedException\"/>.\n+    /// </remarks>\n+    [Serializable]\n+    public abstract class BuildEngineInterface",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I really want to make it clear that the class is intended only for subclassing. New'ing up a class which does nothing but throw would not be useful.",
              "createdAt": "2021-05-26T13:29:36Z",
              "path": "src/Framework/BuildEngineInterface.cs",
              "diffHunk": "@@ -0,0 +1,30 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Exposes build engine functionality that was made available in newer versions of MSBuild.\n+    /// </summary>\n+    /// <remarks>\n+    /// Make all members virtual but not abstract, ensuring that implementations can override them and external implementations\n+    /// won't break when the class is extended with new members. This base implementation should be throwing <see cref=\"NotImplementedException\"/>.\n+    /// </remarks>\n+    [Serializable]\n+    public abstract class BuildEngineInterface",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "note to self when reviewing: Mentioned offline: naming here. Alternate proposal in a linked bug?",
              "createdAt": "2021-06-14T15:46:37Z",
              "path": "src/Framework/BuildEngineInterface.cs",
              "diffHunk": "@@ -0,0 +1,41 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Exposes build engine functionality that was made available in newer versions of MSBuild.\n+    /// </summary>\n+    /// <remarks>\n+    /// Make all members virtual but not abstract, ensuring that implementations can override them and external implementations\n+    /// won't break when the class is extended with new members. This base implementation should be throwing <see cref=\"NotImplementedException\"/>.\n+    /// </remarks>\n+    [Serializable]\n+    public abstract class BuildEngineInterface",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yep, `EngineServices`. Or maybe `BuildEngineServices`.",
              "createdAt": "2021-06-14T15:59:08Z",
              "path": "src/Framework/BuildEngineInterface.cs",
              "diffHunk": "@@ -0,0 +1,41 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Exposes build engine functionality that was made available in newer versions of MSBuild.\n+    /// </summary>\n+    /// <remarks>\n+    /// Make all members virtual but not abstract, ensuring that implementations can override them and external implementations\n+    /// won't break when the class is extended with new members. This base implementation should be throwing <see cref=\"NotImplementedException\"/>.\n+    /// </remarks>\n+    [Serializable]\n+    public abstract class BuildEngineInterface",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "`BuildEngineBase`?",
              "createdAt": "2021-08-02T15:26:32Z",
              "path": "src/Framework/BuildEngineInterface.cs",
              "diffHunk": "@@ -0,0 +1,41 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Exposes build engine functionality that was made available in newer versions of MSBuild.\n+    /// </summary>\n+    /// <remarks>\n+    /// Make all members virtual but not abstract, ensuring that implementations can override them and external implementations\n+    /// won't break when the class is extended with new members. This base implementation should be throwing <see cref=\"NotImplementedException\"/>.\n+    /// </remarks>\n+    [Serializable]\n+    public abstract class BuildEngineInterface",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Intersecting my and Rainer's preferences, it looks like the winning option is `EngineServices` and we would also be fine with `BuildEngineInterface` (or just `EngineInterface`). @Forgind, please let me know if you feel strongly about your proposal or the runner-up. If not, I'll proceed with renaming to `EngineServices` and mark the PR for merge. Thank you! ",
              "createdAt": "2021-08-04T11:25:40Z",
              "path": "src/Framework/BuildEngineInterface.cs",
              "diffHunk": "@@ -0,0 +1,41 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Exposes build engine functionality that was made available in newer versions of MSBuild.\n+    /// </summary>\n+    /// <remarks>\n+    /// Make all members virtual but not abstract, ensuring that implementations can override them and external implementations\n+    /// won't break when the class is extended with new members. This base implementation should be throwing <see cref=\"NotImplementedException\"/>.\n+    /// </remarks>\n+    [Serializable]\n+    public abstract class BuildEngineInterface",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    throw \"##vso[task.logissue type=error;sourcepath=src/Framework/BuildEngineInterface.cs] Detected changes in Framework\\BuildEngineInterface.cs without a version bump.  \" +\r\n```\r\n\r\nNot sure if this helps the GitHub annotations without a line number but it shouldn't hurt.",
              "createdAt": "2021-07-27T21:05:32Z",
              "path": "eng/build.ps1",
              "diffHunk": "@@ -151,11 +151,23 @@ function Set-OptProfVariables() {\n function Check-EditedFiles() {\n   # Log VSTS errors for changed lines\n   git --no-pager diff HEAD --unified=0 --no-color --exit-code | ForEach-Object { \"##vso[task.logissue type=error] $_\" }\n-  if($LASTEXITCODE -ne 0) {\n+  if ($LASTEXITCODE -ne 0) {\n     throw \"##vso[task.logissue type=error] After building, there are changed files.  Please build locally and include these changes in your pull request.\"\n   }\n }\n \n+function Check-RequiredVersionBumps() {\n+  # Log VSTS errors for missing required version bumps\n+  $versionLineChanged = $false\n+  git --no-pager diff --unified --no-color --exit-code -w origin/$env:SYSTEM_PULLREQUEST_TARGETBRANCH HEAD src\\Framework\\BuildEngineInterface.cs `\n+    | Select-String -Pattern \"int Version =\" | ForEach-Object -process { $versionLineChanged = $true }\n+  if (($LASTEXITCODE -ne 0) -and (-not $versionLineChanged)) {\n+    throw \"##vso[task.logissue type=error] Detected changes in Framework\\BuildEngineInterface.cs without a version bump.  \" +",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Applied, thank you.",
              "createdAt": "2021-08-02T10:06:17Z",
              "path": "eng/build.ps1",
              "diffHunk": "@@ -151,11 +151,23 @@ function Set-OptProfVariables() {\n function Check-EditedFiles() {\n   # Log VSTS errors for changed lines\n   git --no-pager diff HEAD --unified=0 --no-color --exit-code | ForEach-Object { \"##vso[task.logissue type=error] $_\" }\n-  if($LASTEXITCODE -ne 0) {\n+  if ($LASTEXITCODE -ne 0) {\n     throw \"##vso[task.logissue type=error] After building, there are changed files.  Please build locally and include these changes in your pull request.\"\n   }\n }\n \n+function Check-RequiredVersionBumps() {\n+  # Log VSTS errors for missing required version bumps\n+  $versionLineChanged = $false\n+  git --no-pager diff --unified --no-color --exit-code -w origin/$env:SYSTEM_PULLREQUEST_TARGETBRANCH HEAD src\\Framework\\BuildEngineInterface.cs `\n+    | Select-String -Pattern \"int Version =\" | ForEach-Object -process { $versionLineChanged = $true }\n+  if (($LASTEXITCODE -ne 0) -and (-not $versionLineChanged)) {\n+    throw \"##vso[task.logissue type=error] Detected changes in Framework\\BuildEngineInterface.cs without a version bump.  \" +",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not sure I understand the need for this member, can you elaborate?",
              "createdAt": "2021-07-27T21:09:34Z",
              "path": "src/Framework/BuildEngineInterface.cs",
              "diffHunk": "@@ -0,0 +1,41 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Exposes build engine functionality that was made available in newer versions of MSBuild.\n+    /// </summary>\n+    /// <remarks>\n+    /// Make all members virtual but not abstract, ensuring that implementations can override them and external implementations\n+    /// won't break when the class is extended with new members. This base implementation should be throwing <see cref=\"NotImplementedException\"/>.\n+    /// </remarks>\n+    [Serializable]\n+    public abstract class BuildEngineInterface\n+    {\n+        /// <summary>\n+        /// Initial version with LogsMessagesOfImportance() as the only exposed member.\n+        /// </summary>\n+        public const int Version1 = 1;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "The idea is that the versioning history will be captured in these constants. I know it's lame but having the `Version` prop return 5 is not super readable without describing how it is different from 4. And while digging this information from git history would work for us internally, we should also have something in the external doc as this is public API.",
              "createdAt": "2021-08-02T10:16:05Z",
              "path": "src/Framework/BuildEngineInterface.cs",
              "diffHunk": "@@ -0,0 +1,41 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Exposes build engine functionality that was made available in newer versions of MSBuild.\n+    /// </summary>\n+    /// <remarks>\n+    /// Make all members virtual but not abstract, ensuring that implementations can override them and external implementations\n+    /// won't break when the class is extended with new members. This base implementation should be throwing <see cref=\"NotImplementedException\"/>.\n+    /// </remarks>\n+    [Serializable]\n+    public abstract class BuildEngineInterface\n+    {\n+        /// <summary>\n+        /// Initial version with LogsMessagesOfImportance() as the only exposed member.\n+        /// </summary>\n+        public const int Version1 = 1;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Not sure I understand this; comment?",
              "createdAt": "2021-07-27T21:13:14Z",
              "path": "src/Build/Logging/ConsoleLogger.cs",
              "diffHunk": "@@ -477,6 +475,30 @@ public void CustomEventHandler(object sender, CustomBuildEventArgs e)\n             _consoleLogger.CustomEventHandler(sender, e);\n         }\n \n+        /// <summary>\n+        /// Returns the minimum importance of messages logged by this logger.\n+        /// </summary>\n+        /// <returns>\n+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)\n+        /// if this logger does not log messages of any importance.\n+        /// </returns>\n+        internal MessageImportance GetMinimumMessageImportance()\n+        {\n+            if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Low, out _))\n+            {\n+                return MessageImportance.Low;\n+            }\n+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Normal, out _))\n+            {\n+                return MessageImportance.Normal;\n+            }\n+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.High, out _))\n+            {\n+                return MessageImportance.High;\n+            }\n+            return MessageImportance.High - 1;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It is explained in the method doc-comment, I've added an inline comment right here also.\r\n\r\nI was debating adding an internal constant with this value but have a hard time coming up with a good name (and type where to declare it for that matter). It's basically a value representing the minimum message importance logged by quiet loggers, i.e. it's the non-existent \"higher than high\".",
              "createdAt": "2021-08-02T11:43:06Z",
              "path": "src/Build/Logging/ConsoleLogger.cs",
              "diffHunk": "@@ -477,6 +475,30 @@ public void CustomEventHandler(object sender, CustomBuildEventArgs e)\n             _consoleLogger.CustomEventHandler(sender, e);\n         }\n \n+        /// <summary>\n+        /// Returns the minimum importance of messages logged by this logger.\n+        /// </summary>\n+        /// <returns>\n+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)\n+        /// if this logger does not log messages of any importance.\n+        /// </returns>\n+        internal MessageImportance GetMinimumMessageImportance()\n+        {\n+            if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Low, out _))\n+            {\n+                return MessageImportance.Low;\n+            }\n+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Normal, out _))\n+            {\n+                return MessageImportance.Normal;\n+            }\n+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.High, out _))\n+            {\n+                return MessageImportance.High;\n+            }\n+            return MessageImportance.High - 1;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Critical?",
              "createdAt": "2021-08-02T16:09:45Z",
              "path": "src/Build/Logging/ConsoleLogger.cs",
              "diffHunk": "@@ -477,6 +475,30 @@ public void CustomEventHandler(object sender, CustomBuildEventArgs e)\n             _consoleLogger.CustomEventHandler(sender, e);\n         }\n \n+        /// <summary>\n+        /// Returns the minimum importance of messages logged by this logger.\n+        /// </summary>\n+        /// <returns>\n+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)\n+        /// if this logger does not log messages of any importance.\n+        /// </returns>\n+        internal MessageImportance GetMinimumMessageImportance()\n+        {\n+            if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Low, out _))\n+            {\n+                return MessageImportance.Low;\n+            }\n+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Normal, out _))\n+            {\n+                return MessageImportance.Normal;\n+            }\n+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.High, out _))\n+            {\n+                return MessageImportance.High;\n+            }\n+            return MessageImportance.High - 1;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That would be the name if it was a real MessageImportance value but it is just a marker saying \"not interested in messages regardless of importance\".",
              "createdAt": "2021-08-03T07:43:14Z",
              "path": "src/Build/Logging/ConsoleLogger.cs",
              "diffHunk": "@@ -477,6 +475,30 @@ public void CustomEventHandler(object sender, CustomBuildEventArgs e)\n             _consoleLogger.CustomEventHandler(sender, e);\n         }\n \n+        /// <summary>\n+        /// Returns the minimum importance of messages logged by this logger.\n+        /// </summary>\n+        /// <returns>\n+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)\n+        /// if this logger does not log messages of any importance.\n+        /// </returns>\n+        internal MessageImportance GetMinimumMessageImportance()\n+        {\n+            if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Low, out _))\n+            {\n+                return MessageImportance.Low;\n+            }\n+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Normal, out _))\n+            {\n+                return MessageImportance.Normal;\n+            }\n+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.High, out _))\n+            {\n+                return MessageImportance.High;\n+            }\n+            return MessageImportance.High - 1;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            /// No logging verbosity optimization in TaskHost nodes.\r\n```\r\n\r\n? We should still apply it to worker nodes in the distributed-logger scenario, right?",
              "createdAt": "2021-07-27T21:23:22Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -492,6 +492,22 @@ public void ReleaseCores(int coresToRelease)\n         }\n \n         #endregion\n+\n+        #region IBuildEngine10 Members\n+\n+        [Serializable]\n+        private sealed class BuildEngineInterfaceImpl : BuildEngineInterface\n+        {\n+            /// <summary>\n+            /// No logging verbosity optimization in OOP nodes.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "That's right, fixed, thank you!",
              "createdAt": "2021-08-02T10:06:48Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -492,6 +492,22 @@ public void ReleaseCores(int coresToRelease)\n         }\n \n         #endregion\n+\n+        #region IBuildEngine10 Members\n+\n+        [Serializable]\n+        private sealed class BuildEngineInterfaceImpl : BuildEngineInterface\n+        {\n+            /// <summary>\n+            /// No logging verbosity optimization in OOP nodes.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Not sure I understand this. Can you elaborate?",
              "createdAt": "2021-07-27T21:24:52Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3133,7 +3133,7 @@ private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, L\n                 LoggerVerbosity defaultFileLoggerVerbosity = LoggerVerbosity.Detailed;\n                 fileLogger.Verbosity = defaultFileLoggerVerbosity;\n \n-                if (cpuCount == 1)\n+                if (cpuCount == 1 && Environment.GetEnvironmentVariable(\"MSBUILDNOINPROCNODE\") != \"1\")",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I've added a comment. This is fixing a minor pre-existing perf bug where we assumed that `cpuCount == 1` means that we won't be moving logs from another process.",
              "createdAt": "2021-08-02T11:45:14Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3133,7 +3133,7 @@ private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, L\n                 LoggerVerbosity defaultFileLoggerVerbosity = LoggerVerbosity.Detailed;\n                 fileLogger.Verbosity = defaultFileLoggerVerbosity;\n \n-                if (cpuCount == 1)\n+                if (cpuCount == 1 && Environment.GetEnvironmentVariable(\"MSBUILDNOINPROCNODE\") != \"1\")",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a case when it won't be an `IBuildEngine10` internally?",
              "createdAt": "2021-07-27T21:26:03Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -235,9 +235,20 @@ public virtual string GetResourceMessage(string resourceName)\n             string resourceString = FormatResourceString(resourceName, null);\n             return resourceString;\n         }\n-#endregion\n+        #endregion\n+\n+        #region Message logging methods\n \n-#region Message logging methods\n+        /// <summary>\n+        /// Returns true if a message of given importance should be logged because it is possible that a logger consuming it exists.\n+        /// </summary>\n+        /// <param name=\"importance\">The importance to check.</param>\n+        /// <returns>True if messages of the given importance should be logged, false if it's guaranteed that such messages would be ignored.</returns>\n+        public bool LogsMessagesOfImportance(MessageImportance importance)\n+        {\n+            return BuildEngine is not IBuildEngine10 buildEngine10\n+                || buildEngine10.EngineInterface.LogsMessagesOfImportance(importance);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes, `OutOfProcTaskHostNode` implements only `IBuildEngine3` when building as the 3.5 task host. Also, several mock implementations used in tests don't implement all `IBuildEngine` interfaces.",
              "createdAt": "2021-08-02T11:36:58Z",
              "path": "src/Shared/TaskLoggingHelper.cs",
              "diffHunk": "@@ -235,9 +235,20 @@ public virtual string GetResourceMessage(string resourceName)\n             string resourceString = FormatResourceString(resourceName, null);\n             return resourceString;\n         }\n-#endregion\n+        #endregion\n+\n+        #region Message logging methods\n \n-#region Message logging methods\n+        /// <summary>\n+        /// Returns true if a message of given importance should be logged because it is possible that a logger consuming it exists.\n+        /// </summary>\n+        /// <param name=\"importance\">The importance to check.</param>\n+        /// <returns>True if messages of the given importance should be logged, false if it's guaranteed that such messages would be ignored.</returns>\n+        public bool LogsMessagesOfImportance(MessageImportance importance)\n+        {\n+            return BuildEngine is not IBuildEngine10 buildEngine10\n+                || buildEngine10.EngineInterface.LogsMessagesOfImportance(importance);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                // If the logger is not on our allowlist, there are no importance guarantees. Fall back to \"any importance\".\r\n```\r\n\r\n(Yes, PoliCheck runs in my brain \ud83d\ude22)",
              "createdAt": "2021-07-27T21:28:22Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -1542,10 +1561,57 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)\n                 InternalLoggerException.Throw(e, null, \"FatalErrorWhileInitializingLogger\", true, logger.GetType().Name);\n             }\n \n+            // Update the minimum guaranteed message importance based on the newly added logger.\n+            UpdateMinimumMessageImportance(logger);\n+\n             // Keep track of the loggers so they can be unregistered later on\n             _loggers.Add(logger);\n         }\n \n+        /// <summary>\n+        /// Updates <see cref=\"_minimumRequiredMessageImportance\"/> based on the given <paramref name=\"logger\"/>.\n+        /// </summary>\n+        /// <param name=\"logger\">The newly registered logger.</param>\n+        /// <remarks>\n+        /// This method contains knowledge about several logger classes used by MSBuild. The goal is to optimize common scenarios,\n+        /// such as building on the command line with normal or minimum verbosity. If the user registers an external custom logger,\n+        /// we will fall back to \"minimum importance\" == Low because we don't know how the logger processes messages, therefore we\n+        /// must feed it everything.\n+        /// </remarks>\n+        private void UpdateMinimumMessageImportance(ILogger logger)\n+        {\n+            var innerLogger = (logger is Evaluation.ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;\n+\n+            MessageImportance? minimumImportance = innerLogger switch\n+            {\n+                Build.Logging.ConsoleLogger consoleLogger => consoleLogger.GetMinimumMessageImportance(),\n+                Build.Logging.ConfigurableForwardingLogger forwardingLogger => forwardingLogger.GetMinimumMessageImportance(),\n+\n+                // Central forwarding loggers are used in worker nodes if logging verbosity could not be optimized, i.e. in cases\n+                // where we must log everything. They can be ignored in inproc nodes.\n+                CentralForwardingLogger => (_nodeId > 1 ? MessageImportance.Low : null),\n+\n+                // The null logger has no effect on minimum verbosity.\n+                Execution.BuildManager.NullLogger => null,\n+\n+                // If the logger is not on our whitelist, there are no importance guarantees. Fall back to \"any importance\".",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Applied, thank you.",
              "createdAt": "2021-08-02T10:06:03Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -1542,10 +1561,57 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)\n                 InternalLoggerException.Throw(e, null, \"FatalErrorWhileInitializingLogger\", true, logger.GetType().Name);\n             }\n \n+            // Update the minimum guaranteed message importance based on the newly added logger.\n+            UpdateMinimumMessageImportance(logger);\n+\n             // Keep track of the loggers so they can be unregistered later on\n             _loggers.Add(logger);\n         }\n \n+        /// <summary>\n+        /// Updates <see cref=\"_minimumRequiredMessageImportance\"/> based on the given <paramref name=\"logger\"/>.\n+        /// </summary>\n+        /// <param name=\"logger\">The newly registered logger.</param>\n+        /// <remarks>\n+        /// This method contains knowledge about several logger classes used by MSBuild. The goal is to optimize common scenarios,\n+        /// such as building on the command line with normal or minimum verbosity. If the user registers an external custom logger,\n+        /// we will fall back to \"minimum importance\" == Low because we don't know how the logger processes messages, therefore we\n+        /// must feed it everything.\n+        /// </remarks>\n+        private void UpdateMinimumMessageImportance(ILogger logger)\n+        {\n+            var innerLogger = (logger is Evaluation.ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;\n+\n+            MessageImportance? minimumImportance = innerLogger switch\n+            {\n+                Build.Logging.ConsoleLogger consoleLogger => consoleLogger.GetMinimumMessageImportance(),\n+                Build.Logging.ConfigurableForwardingLogger forwardingLogger => forwardingLogger.GetMinimumMessageImportance(),\n+\n+                // Central forwarding loggers are used in worker nodes if logging verbosity could not be optimized, i.e. in cases\n+                // where we must log everything. They can be ignored in inproc nodes.\n+                CentralForwardingLogger => (_nodeId > 1 ? MessageImportance.Low : null),\n+\n+                // The null logger has no effect on minimum verbosity.\n+                Execution.BuildManager.NullLogger => null,\n+\n+                // If the logger is not on our whitelist, there are no importance guarantees. Fall back to \"any importance\".",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}