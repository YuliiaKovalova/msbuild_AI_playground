{
  "number": 5663,
  "title": "Optimize string building and interning",
  "body": "### Overview\r\n\r\nThis PR addresses the following issues:\r\n\r\n1. The current version of string interning takes a custom `IInternable` interface as its input. Since most implementations of the interface are structs, the code is duplicated at run-time using generics to prevent boxing: `void SomeFunction<T>(T internable) where T : IInternable`.\r\n2. It's been pointed out that `IInternable` is functionally equivalent to `ReadOnlySpan<char>`. `IInternable` needs a separate and manually authored implementation for each kind of input, whereas `ReadOnlySpan<char>` comes from BCL for free. We are currently missing a wrapper over `char *, length`, for example.\r\n3. One of the string-like datatypes implementing `IInternable` is our `StringBuilder` wrapper. Interning iterates over the candidate string linearly, hashing its contents and comparing it with already interned strings. For `StringBuilder` this operation is O(N^2) because of its internal representation and the lack of an efficient enumerator.\r\n4. Most uses of `StringBuilder` in MSBuild are \"append-only\" where the resulting string is composed by concatenating a series of string fragments representable with `ReadOnlySpan<char>` or `ReadOnlyMemory<char>`. This usage pattern allocates 2x the length of the resulting string - one copy lives in the `StringBuilder`'s internal char array(s) and the other is created as part of the `ToString()` call.\r\n\r\nIntroduced in this change is a new type named `SpanBasedStringBuilder`, serving as an efficient `StringBuilder`-like builder. Also provided is a static class named `Strings` with functionality to intern an arbitrary `ReadOnlySpan<char>`.\r\n\r\na) Interning read-only character spans\r\nMakes it possible to intern a string, substring, character array/sub-array, char *, or any other `ReadOnlySpan<char>`. The advantage over first creating the desired `System.String` and then interning it is that it does away with the ephemeral `System.String` allocation in the case where the string already is in the intern table.\r\n\r\n```C#\r\nvar str = Strings.WeakIntern(\"semicolon;delimited\".AsSpan(0, 8));\r\nConsole.WriteLine(str); // prints \"semicolon\"\r\n```\r\n\r\nMemory characteristics of the above snippet:\r\n- The WeakIntern() call does not allocate if the string \"semicolon\" already exists in the intern table,\r\n- The call allocates the string and a small overhead if the string is not yet in the intern table.\r\n\r\nb) An internable `StringBuilder`.\r\nCompensates for the fact that `System.Text.StringBuilder` cannot be represented with one `ReadOnlySpan<char>` and that it does not provide a linear-time character enumeration. The usage pattern is similar to that of a `StringBuilder` but it does not allocate O(N) bytes where N is the intermediate string length, but rather allocates only spans describing its constituent pieces. Note that in degenerated cases this may be worse than O(N) so make sure it's used only where it's actually helping.\r\n\r\n```C#\r\nusing var str = Strings.GetSpanBasedStringBuilder();\r\nstr.Append(\"semicolon\");\r\nstr.Append(\";\");\r\nstr.Append(\"delimited\");\r\nConsole.WriteLine(str.ToString()); // prints \"semicolon;delimited\"\r\n```\r\n\r\nMemory characteristics of the above snippet:\r\n- `SpanBasedStringBuilder` instances are pooled so in the expected case the GetSpanBasedStringBuilder() call does not allocate,\r\n- `SpanBasedStringBuilder` holds a List of span descriptors on the GC heap, the size is O(S) where S is the number of spans (in this example 3),\r\n- The `Append()` calls do not allocate memory unless they need to resize the List of span descriptors,\r\n- The `ToString()` call does not allocate the string \"semicolon;delimited\" if it already exists in the intern table.\r\n\r\n### Code structure\r\n- `ReuseableStringBuilder` is simplified as it no longer supports interning (going forward most of its uses should be replaced with `SpanBasedStringBuilder`),\r\n- All uses of `ReusableStringBuilder` that used interning are converted to `SpanBasedStringBuilder`,\r\n- All string/substring/char array interning is converted to `Strings.WeakIntern()`,\r\n- `IInternable`, `WeakStringCache`, `OpportunisticIntern` are all deleted and the functionality moved to a new library called `StringTools`,\r\n- `StringTools` is built for three targets: .NET Standard, .NET Framework 4, and .NET Framework 3.5 to be used in MSBuildTaskHost, and as usual, the 3.5 implementation is rather simplified as we're fine with sub-optimal performance,\r\n\r\nNote that no effort has been made to convert other uses of `ReuseableStringBuilder` and `StringBuilder` to `SpanBasedStringBuilder`. The expectation is that there are many opportunities to eliminate ephemeral allocations and it should be done in separate PRs.\r\n\r\n### To-do\r\n- [x] Run an experimental VS insertion\r\n- [x] Measure performance impact by profiling project evaluation",
  "state": "MERGED",
  "createdAt": "2020-08-19T16:02:16Z",
  "updatedAt": "2021-01-21T08:10:48Z",
  "closedAt": "2021-01-21T08:09:15Z",
  "mergedAt": "2021-01-21T08:09:15Z",
  "additions": 2361,
  "deletions": 2211,
  "changedFiles": 56,
  "headRefName": "switch-interner-to-span",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "5fbc164ed9f8ce440cfecafaa879ac6341db57ec",
          "message": "Add the StringTools library project",
          "committedDate": "2021-01-20T21:19:15Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c319a63df71a815f9862cdaf2237d65525aea429",
          "message": "Add the StringTools.UnitTests project",
          "committedDate": "2021-01-20T21:19:15Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1c879601c5fc151f1bbb01b33a162a823588b5e2",
          "message": "Add the StringTools.Benchmark project",
          "committedDate": "2021-01-20T21:33:54Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "16f2a0f0609f3532291f7df651bd2c2d9c44c8b0",
          "message": "Add StringTools* projects to solution files",
          "committedDate": "2021-01-20T21:34:05Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "df6d15ba3b5f4ec75be156b812e2808949565fa8",
          "message": "Update packaging and deployment files",
          "committedDate": "2021-01-20T21:34:05Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f166d2da51c07db5d51731f222cfd57335042467",
          "message": "Add project references to StringTools",
          "committedDate": "2021-01-20T21:34:05Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "62f7c45ec90bbed472ceeb06181f0f08ab999935",
          "message": "Enable StringTools diagnostics",
          "committedDate": "2021-01-20T21:34:05Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e0cf0879b0c9962516a8c2a2b6da356c17c9d8ff",
          "message": "Use StringTools in Build/Construction, Definition, Globbing, Instance",
          "committedDate": "2021-01-20T21:34:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "41c75de5214c9f19ca5118750e71ae55b3e5dfcc",
          "message": "Use StringTools in Build/Evaluation",
          "committedDate": "2021-01-20T21:34:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8125b71443692db6db873eabd4b078a667aa93ce",
          "message": "Use StringTools in Tasks",
          "committedDate": "2021-01-20T21:34:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "40c716bee401beac9a6c35b3d9d860f99903ec7c",
          "message": "Use StringTools in Shared",
          "committedDate": "2021-01-20T21:34:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ce305446bb2559ea3f5d9679bce8f317e0dd0cd5",
          "message": "Remove interning support from ReuseableStringBuilder",
          "committedDate": "2021-01-20T21:34:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3b09c1d111aae107979490f911ad673380ffd8c4",
          "message": "Remove old interning code tests",
          "committedDate": "2021-01-20T21:34:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "580e481f57907860b5f9d8247cd64633b961e456",
          "message": "Remove old interning code",
          "committedDate": "2021-01-20T21:34:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Checks failed due to #5506\r\n",
        "createdAt": "2020-08-28T10:06:12Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2020-08-28T10:06:18Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2020-08-28T10:06:26Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "> <Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\nAdding a new MSBuild assembly will cause a bit of propagation pain to all the tools that have hard coded lists with all the msbuild assemblies, like Microsoft.Build.Locator.\r\n\r\n---\r\nRefers to: src/StringTools/StringTools.csproj:1 in e1846cc. [](commit_id = e1846cc9030617acf5ed1af077bd4820b794f30f, deletion_comment = False)",
        "createdAt": "2020-09-10T03:09:36Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "> Adding a new MSBuild assembly will cause a bit of propagation pain to all the tools that have hard coded lists with all the msbuild assemblies, like Microsoft.Build.Locator.\r\n\r\nWe have added several dependent .dll's recently so I was under the assumption that it is not a super disruptive change.\r\n- System.Text.Json.dll for solution filter support,\r\n- StreamJsonRpc.dll & friends for modern IPC serialization.\r\n\r\nIn case of this library it is unfortunately not possible to statically link it into MSBuild as sharing it among all components in the process is an explicit goal. I am curious to learn more about the implications of adding a dependency.",
        "createdAt": "2020-09-10T14:04:21Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": ">I am curious to learn more about the implications of adding a dependency.\r\n\r\nAs far as I'm aware:\r\n- code that hard codes msbuild assemblies will potentially need updating (like [here](https://github.com/microsoft/MSBuildLocator/blob/ed4fce73f2f946c08f7ecf6f2a9cb64b056003f5/src/MSBuildLocator/MSBuildLocator.cs#L22-L28) or [here](https://github.com/microsoft/BuildXL/blob/45407251608694485f9e22ff9e3fbb3d17449381/Public/Src/Tools/Tool.MsBuildGraphBuilder/MsBuildAssemblyLoader.cs#L61-L72))\r\n- [app.config](https://github.com/dotnet/msbuild/blob/c7790e1ed37c2e6cb4fc38e76c06ed1fb15d3148/src/MSBuild/app.config#L15-L42) probably needs a new redirect\r\n- update all the packages we ship",
        "createdAt": "2020-09-10T17:58:46Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "@danmosemsft may I ask you to take a look at the StringTools library introduced in this PR? This is the library to be published and used by multiple components running in the devenv process that we recently agreed would initially live in the msbuild repo. Thank you!",
        "createdAt": "2020-09-10T21:24:08Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "@ladipro thanks for sharing. I will try to look but maybe not today. \r\n\r\nIt sounds like the idea is that this would be a generic interning service for any managed code in VS? \r\n\r\nAs you know there are countless strategies one could use, from the PR it's only possible to review for correctness and not be confident about the approach. I would expect you plan to measure (in MSBuild and VS) and iterate up the wazoo. Including with non MSBuild consumers.\r\n\r\ncc @jkotas in case he is interested in your strategies. Glad you are tackling this!",
        "createdAt": "2020-09-10T21:51:27Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "This is the kind of thing @AArnott may be interested in.",
        "createdAt": "2020-09-11T00:57:16Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "> It sounds like the idea is that this would be a generic interning service for any managed code in VS?\r\n\r\nYes. Still debating whether it needs to be a formal VS \"service\" but it's going to be at least a regular library. In the MSBuild (and I'm guessing also Roslyn) case, the same code runs out-of-proc as well as in-proc so it's convenient to simply link against a library and then automatically get process-wide string sharing, be it the devenv process or an out-of-proc worker.\r\n\r\n>As you know there are countless strategies one could use, from the PR it's only possible to review for correctness and not be confident about the approach. I would expect you plan to measure (in MSBuild and VS) and iterate up the wazoo. Including with non MSBuild consumers.\r\n\r\nThat's the idea. I'm starting with MSBuild and will then consume the library from other places as well. Nothing is set in stone and there are likely going to be adjustments, although the core `ReadOnlySpan<char> -> string` interning function is likely going to stay the way it is - it is super simple and should cover most scenarios.",
        "createdAt": "2020-09-14T14:33:27Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "I have finally updated the PR and made it ready for final review. Thank you for bearing with me and for the great feedback so far. Notable changes since the last round:\r\n\r\n1. Hardcoded strings are gone. I took measurements without hardcoded strings, with hardcoded strings as they currently exist in the codebase, and with hardcoded strings tailored for a specific scenario (i.e. hardcoding top N strings seen when building a project).\r\n  -- The strings currently in the main branch are not helping. Total time spent interning is actually ~1% worse.\r\n  -- Hardcoding the *right* strings can make things better (by about 1%, interestingly) but the set of *right* strings varies across projects being built. Strings that make one project 1% faster may make little effect on another project or even make it slower. Btw, the most frequently interned strings are not `\"true\"`, `\"false\"`, `\"==\"` but rather things like `\"$(MSBuildProjectDirectory)\"`, `\"@(ReferencePath->'%(ReferenceAssembly)')\"`, and `\"$([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))\"`.\r\n\r\n   All in all, 1% of string interning cost (not build cost!) is definitely not worth the added complexity and maintenance cost.\r\n\r\n2. `SpanBasedStringBuilder` pooling is now done trivially with a thread-static variable rather than with `ObjectPool`. MSBuild does not have code where a given thread would need to hold on to multiple builders at the same time. It's always: 1. Get a builder, 2. Append to it, 3. `ToString()` it. 4. Dispose of it. This makes pooling faster and eliminates the dependency on `Microsoft.Extensions.ObjectPool`.\r\n\r\nI've added a simple microbenchmark comparing\r\n- Appending to a regular `StringBuilder` and interning the result of `ToString()`.\r\n- Appending to `SpanBasedStringBuilder` and getting the resulting string with `ToString()` (which has interning built in).\r\nAs expected, the results vary wildly depending on how exactly the appending is done - how many strings of what length.\r\n\r\nComposing the result out of 1 string with 64 characters is about a wash between the two, both on cache hit (string already interned) and cache miss (string seen for the first time).\r\nIn the degenerate case composing the result out of 1 string 1 character long, the regular SB is faster by about 40% on hit and 20% on miss (~200 ns difference in both cases).\r\nOn the other end of the spectrum, composing the result out of 16 strings 512 characters each, `SpanBasedStringBuilder` is faster by 15% on hit and by 10% on miss.\r\n\r\nIn all cases, though, `SpanBasedStringBuilder` is zero-alloc on hit whereas the regular `StringBuilder` allocates the ephemeral string in `ToString`. I'll run a macro-benchmark to quantifying the impact on project evaluation.\r\n\r\n@rainersigwald, may I ask you to take a look. Thank you!",
        "createdAt": "2020-12-16T11:02:31Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "I have squashed the changes into a reasonable number of commits for easier review.",
        "createdAt": "2021-01-05T12:53:53Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "I've benchmarked project evaluation with and without these changes. I have measured evaluation of our own Microsoft.Build.Framework.csproj and of an empty .NET Core console project. Both wall-clock time and memory allocations have improved.\r\n\r\n- Memory got better by 0.5% and 2.5%, respectively. These are exact numbers reported by BenchmarkDotNet.\r\n- Time got better by 1% and 6%, respectively. Within error margin so low-confidence numbers, although they correlate with memory nicely.",
        "createdAt": "2021-01-07T16:53:42Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2021-01-20T16:48:10Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2021-01-20T16:48:21Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "Visual Studio insertion with this change will require manual tweaks. ",
        "createdAt": "2021-01-21T08:10:48Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: import StringTools namespace.",
              "createdAt": "2020-09-10T03:10:27Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -405,7 +405,7 @@ public void BeginBuild(BuildParameters parameters)\n \n                 if (BuildParameters.DumpOpportunisticInternStats)\n                 {\n-                    OpportunisticIntern.Instance.EnableStatisticsGathering();\n+                    StringTools.StringTools.EnableDiagnostics();",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Done. Also renamed the `StringTools` class because a type named `StringTools` in a namespace named `StringTools` is only causing issues.",
              "createdAt": "2020-09-14T14:17:54Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -405,7 +405,7 @@ public void BeginBuild(BuildParameters parameters)\n \n                 if (BuildParameters.DumpOpportunisticInternStats)\n                 {\n-                    OpportunisticIntern.Instance.EnableStatisticsGathering();\n+                    StringTools.StringTools.EnableDiagnostics();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Didn't reach StringTools yet, but `RopeBuilder` does not sound descriptive at all. Is it some established pattern / algorithm that I never head about? By its name I assume it takes multiple sequencey things and somehow weaves them together :)\r\nOn the other hand the name is cute, I like it, could get used to it.",
              "createdAt": "2020-09-10T03:14:45Z",
              "path": "src/Build/Construction/Solution/SolutionProjectGenerator.cs",
              "diffHunk": "@@ -1097,8 +1100,11 @@ private static string GetConfigurationAndPlatformPropertiesString(ProjectConfigu\n         /// </summary>\n         private static string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration)\n         {\n-            string directProjectProperties = OpportunisticIntern.InternStringIfPossible(String.Join(\";\", GetConfigurationAndPlatformPropertiesString(projectConfiguration), SolutionProperties));\n-            return directProjectProperties;\n+            using RopeBuilder directProjectProperties = ST.GetRopeBuilder();",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "On a darker note, it's also indicative of how we feel sometimes when reading the msbuild code base. The name makes sense more and more :)\r\n\r\n---\r\nIn reply to: [486037469](https://github.com/dotnet/msbuild/pull/5663#discussion_r486037469) [](ancestors = 486037469)",
              "createdAt": "2020-09-10T03:35:50Z",
              "path": "src/Build/Construction/Solution/SolutionProjectGenerator.cs",
              "diffHunk": "@@ -1097,8 +1100,11 @@ private static string GetConfigurationAndPlatformPropertiesString(ProjectConfigu\n         /// </summary>\n         private static string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration)\n         {\n-            string directProjectProperties = OpportunisticIntern.InternStringIfPossible(String.Join(\";\", GetConfigurationAndPlatformPropertiesString(projectConfiguration), SolutionProperties));\n-            return directProjectProperties;\n+            using RopeBuilder directProjectProperties = ST.GetRopeBuilder();",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Haven't looked but guessing it's this: https://en.wikipedia.org/wiki/Rope_(data_structure)",
              "createdAt": "2020-09-10T07:56:26Z",
              "path": "src/Build/Construction/Solution/SolutionProjectGenerator.cs",
              "diffHunk": "@@ -1097,8 +1100,11 @@ private static string GetConfigurationAndPlatformPropertiesString(ProjectConfigu\n         /// </summary>\n         private static string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration)\n         {\n-            string directProjectProperties = OpportunisticIntern.InternStringIfPossible(String.Join(\";\", GetConfigurationAndPlatformPropertiesString(projectConfiguration), SolutionProperties));\n-            return directProjectProperties;\n+            using RopeBuilder directProjectProperties = ST.GetRopeBuilder();",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "Yes, it's a rope, although a simple one since we don't need operations that would make it a tree. We basically just append strings to the end. I want to have the API (informally) reviewed before merging so it is possible that we'll end up with a different name.",
              "createdAt": "2020-09-10T12:53:30Z",
              "path": "src/Build/Construction/Solution/SolutionProjectGenerator.cs",
              "diffHunk": "@@ -1097,8 +1100,11 @@ private static string GetConfigurationAndPlatformPropertiesString(ProjectConfigu\n         /// </summary>\n         private static string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration)\n         {\n-            string directProjectProperties = OpportunisticIntern.InternStringIfPossible(String.Join(\";\", GetConfigurationAndPlatformPropertiesString(projectConfiguration), SolutionProperties));\n-            return directProjectProperties;\n+            using RopeBuilder directProjectProperties = ST.GetRopeBuilder();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Renamed to `SpanBasedStringBuilder`.",
              "createdAt": "2020-09-14T14:18:28Z",
              "path": "src/Build/Construction/Solution/SolutionProjectGenerator.cs",
              "diffHunk": "@@ -1097,8 +1100,11 @@ private static string GetConfigurationAndPlatformPropertiesString(ProjectConfigu\n         /// </summary>\n         private static string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration)\n         {\n-            string directProjectProperties = OpportunisticIntern.InternStringIfPossible(String.Join(\";\", GetConfigurationAndPlatformPropertiesString(projectConfiguration), SolutionProperties));\n-            return directProjectProperties;\n+            using RopeBuilder directProjectProperties = ST.GetRopeBuilder();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This could be called in a static Project constructor right? To make it more clear that it's a static, once in a process thing.",
              "createdAt": "2020-09-10T03:23:33Z",
              "path": "src/Build/Definition/Project.cs",
              "diffHunk": "@@ -109,6 +109,7 @@ internal Project(ProjectCollection projectCollection, ProjectLink link)\n             ProjectCollection = projectCollection;\n             implementationInternal = new ProjectLinkInternalNotImplemented();\n             implementation = link;\n+            StringToolsHost.Initialize();",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Indeed, I've moved it to the static ctor, thanks!",
              "createdAt": "2020-09-10T13:56:47Z",
              "path": "src/Build/Definition/Project.cs",
              "diffHunk": "@@ -109,6 +109,7 @@ internal Project(ProjectCollection projectCollection, ProjectLink link)\n             ProjectCollection = projectCollection;\n             implementationInternal = new ProjectLinkInternalNotImplemented();\n             implementation = link;\n+            StringToolsHost.Initialize();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Don't you also have to add the StringTools assembly in here? Unless it's integrated in its referencing assemblies",
              "createdAt": "2020-09-10T03:40:41Z",
              "path": "src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec",
              "diffHunk": "@@ -32,6 +32,7 @@\n     <file src=\"$X86BinPath$/System.Memory.dll\" target=\"v15.0/bin\" />\n     <file src=\"$X86BinPath$/System.Text.Json.dll\" target=\"v15.0/bin\" />\n     <file src=\"$X86BinPath$/Microsoft.Bcl.AsyncInterfaces.dll\" target=\"v15.0/bin\" />\n+    <file src=\"$X86BinPath$/Microsoft.Extensions.ObjectPool.dll\" target=\"v15.0/bin\" />",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Thanks, fixed! I have yet to verify the whole thing with an exp insertion. It is likely that more packaging-related issues will surface.",
              "createdAt": "2020-09-10T13:54:51Z",
              "path": "src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec",
              "diffHunk": "@@ -32,6 +32,7 @@\n     <file src=\"$X86BinPath$/System.Memory.dll\" target=\"v15.0/bin\" />\n     <file src=\"$X86BinPath$/System.Text.Json.dll\" target=\"v15.0/bin\" />\n     <file src=\"$X86BinPath$/Microsoft.Bcl.AsyncInterfaces.dll\" target=\"v15.0/bin\" />\n+    <file src=\"$X86BinPath$/Microsoft.Extensions.ObjectPool.dll\" target=\"v15.0/bin\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Add StringTools as well?",
              "createdAt": "2020-09-10T03:41:03Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -40,6 +40,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all\n   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all\n   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all\n+  file source=$(X86BinPath)Microsoft.Extensions.ObjectPool.dll vs.file.ngenArchitecture=all",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Thanks, done!",
              "createdAt": "2020-09-10T13:53:25Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -40,6 +40,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all\n   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all\n   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all\n+  file source=$(X86BinPath)Microsoft.Extensions.ObjectPool.dll vs.file.ngenArchitecture=all",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why the hardcoded encoding?",
              "createdAt": "2020-09-10T03:46:20Z",
              "path": "src/Shared/InterningBinaryReader.cs",
              "diffHunk": "@@ -40,15 +40,15 @@ internal class InterningBinaryReader : BinaryReader\n         /// Comment about constructing.\n         /// </summary>\n         private InterningBinaryReader(Stream input, Buffer buffer)\n-            : base(input, buffer.Encoding)\n+            : base(input, Encoding.UTF8)",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "It was already hardcoded before, just in a more convoluted way, presumably due to a perf concern. I've simplified the code a tiny bit.",
              "createdAt": "2020-09-10T12:56:25Z",
              "path": "src/Shared/InterningBinaryReader.cs",
              "diffHunk": "@@ -40,15 +40,15 @@ internal class InterningBinaryReader : BinaryReader\n         /// Comment about constructing.\n         /// </summary>\n         private InterningBinaryReader(Stream input, Buffer buffer)\n-            : base(input, buffer.Encoding)\n+            : base(input, Encoding.UTF8)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "As I understand it, Ropes is a well understood structure that is a balanced tree. I would avoid using the term for a list of spans. SpanCollection? SpanOfCharList? ",
              "createdAt": "2020-09-11T01:14:40Z",
              "path": "src/StringTools/RopeBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for intermediate strings) and\n+    /// time (no need to copy characters to intermediate strings).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"StringTools.GetRopeBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class RopeBuilder : IDisposable",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "Renamed to `SpanBasedStringBuilder`. The name is a bit longer but I want to make it clear that it is supposed to be functionally analogous to `StringBuilder`.",
              "createdAt": "2020-09-14T14:21:54Z",
              "path": "src/StringTools/RopeBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for intermediate strings) and\n+    /// time (no need to copy characters to intermediate strings).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"StringTools.GetRopeBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class RopeBuilder : IDisposable",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You can use the built in Trim() method. eg https://apisof.net/catalog/System.MemoryExtensions.Trim%3CT%3E(Span%3CT%3E,T)",
              "createdAt": "2020-09-11T01:23:07Z",
              "path": "src/StringTools/RopeBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for intermediate strings) and\n+    /// time (no need to copy characters to intermediate strings).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"StringTools.GetRopeBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class RopeBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the RopeBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new RopeBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public RopeBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty RopeBuilder with the given expected number of spans.\n+        /// </summary>\n+        public RopeBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the RopeBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            StringTools.ReturnRopeBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;\n+                }\n+                if (!_spans[spanIdx].IsEmpty)\n+                {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Removes trailing white-space characters from the string.\n+        /// </summary>\n+        public void TrimEnd()\n+        {\n+            for (int spanIdx = _spans.Count - 1; spanIdx >= 0; spanIdx--)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = span.Length - 1;\n+                while (i >= 0 && char.IsWhiteSpace(span[i]))",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "`Trim()` is not available on the Framework version of `ReadOnlyMemory` unfortunately and running `.Span.Trim()` and then slicing the `ReadOnlyMemory` according to the trimmed span is almost twice as slow compared to what I have here. Unless there's a better way that has comparable performance I'd say it's better to keep this implementation but I'll defer to your opinion.",
              "createdAt": "2020-09-14T10:31:50Z",
              "path": "src/StringTools/RopeBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for intermediate strings) and\n+    /// time (no need to copy characters to intermediate strings).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"StringTools.GetRopeBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class RopeBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the RopeBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new RopeBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public RopeBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty RopeBuilder with the given expected number of spans.\n+        /// </summary>\n+        public RopeBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the RopeBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            StringTools.ReturnRopeBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;\n+                }\n+                if (!_spans[spanIdx].IsEmpty)\n+                {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Removes trailing white-space characters from the string.\n+        /// </summary>\n+        public void TrimEnd()\n+        {\n+            for (int spanIdx = _spans.Count - 1; spanIdx >= 0; spanIdx--)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = span.Length - 1;\n+                while (i >= 0 && char.IsWhiteSpace(span[i]))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This callback scheme is a complexity it would be good to avoid. The decision to hard code a lookup for short well known strings was based on measurements a long time ago, and also in a context where there was no callback involved. I suggest to rip it out and do your measurements with no strings propopulated. You can look at the stats dump you have built in to see which strings are very common (they may have changed since this list was chosen). Then you can decide whether the data suggests they need special handling. If they do that you might not choose the same callback-and-switch scheme but something else.",
              "createdAt": "2020-09-11T01:27:18Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,232 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class StringTools\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_ropeBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<RopeBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new RopeBuilder with the default capacity.\n+            /// </summary>\n+            public RopeBuilder Create()\n+            {\n+                return new RopeBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(RopeBuilder ropeBuilder)\n+            {\n+                if (ropeBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    ropeBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of RopeBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<RopeBuilder> s_ropeBuilderPool =\n+            new DefaultObjectPool<RopeBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);\n+#endif\n+\n+        /// <summary>\n+        /// An array of callbacks to be called for each string being interned.\n+        /// </summary>\n+        private static volatile TryInternStringDelegate[] s_internStringCallbacks = new TryInternStringDelegate[0];\n+\n+        /// <summary>\n+        /// A lock protecting writes to <see cref=\"s_internStringCallbacks\"/>.\n+        /// </summary>\n+        private static object s_locker = new object();\n+\n+\n+        #region Public methods\n+\n+        /// <summary>\n+        /// Interns the given string if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The string to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(string str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+\n+#if !NET35\n+        /// <summary>\n+        /// Interns the given readonly character span if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The character span to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(ReadOnlySpan<char> str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+#endif\n+\n+        /// <summary>\n+        /// Returns a new or recycled <see cref=\"RopeBuilder\"/>.\n+        /// </summary>\n+        /// <returns>The RopeBuilder.</returns>\n+        /// <remarks>\n+        /// Call <see cref=\"IDisposable.Dispose\"/> on the returned instance to recycle it.\n+        /// </remarks>\n+        public static RopeBuilder GetRopeBuilder()\n+        {\n+#if NET35\n+            return new RopeBuilder();\n+#else\n+            return s_ropeBuilderPool.Get();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Adds a callback to be called when a string is being interned.\n+        /// </summary>\n+        /// <param name=\"callback\">The callback to add.</param>\n+        /// <remarks>\n+        /// Use this to implement custom interning for some strings. The callback has access to the string being interned\n+        /// via the <see cref=\"InternableString\"/> representation and can override the default behavior by returning a custom\n+        /// string.\n+        /// </remarks>\n+        public static void RegisterStringInterningCallback(TryInternStringDelegate callback)",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "That's a great point. The callback used by MSBuild has both \"positive\" and \"negative\" strings and I was more worried about the latter, i.e. strings that must not be interned. It doesn't look like we actually depend on this in any way, though, and it's probably just a left-over from a logic removed long ago.\r\n\r\nI'll take detailed measurements and will get back on the value of hardcoded strings. Thank you!",
              "createdAt": "2020-09-14T10:56:12Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,232 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class StringTools\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_ropeBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<RopeBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new RopeBuilder with the default capacity.\n+            /// </summary>\n+            public RopeBuilder Create()\n+            {\n+                return new RopeBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(RopeBuilder ropeBuilder)\n+            {\n+                if (ropeBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    ropeBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of RopeBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<RopeBuilder> s_ropeBuilderPool =\n+            new DefaultObjectPool<RopeBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);\n+#endif\n+\n+        /// <summary>\n+        /// An array of callbacks to be called for each string being interned.\n+        /// </summary>\n+        private static volatile TryInternStringDelegate[] s_internStringCallbacks = new TryInternStringDelegate[0];\n+\n+        /// <summary>\n+        /// A lock protecting writes to <see cref=\"s_internStringCallbacks\"/>.\n+        /// </summary>\n+        private static object s_locker = new object();\n+\n+\n+        #region Public methods\n+\n+        /// <summary>\n+        /// Interns the given string if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The string to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(string str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+\n+#if !NET35\n+        /// <summary>\n+        /// Interns the given readonly character span if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The character span to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(ReadOnlySpan<char> str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+#endif\n+\n+        /// <summary>\n+        /// Returns a new or recycled <see cref=\"RopeBuilder\"/>.\n+        /// </summary>\n+        /// <returns>The RopeBuilder.</returns>\n+        /// <remarks>\n+        /// Call <see cref=\"IDisposable.Dispose\"/> on the returned instance to recycle it.\n+        /// </remarks>\n+        public static RopeBuilder GetRopeBuilder()\n+        {\n+#if NET35\n+            return new RopeBuilder();\n+#else\n+            return s_ropeBuilderPool.Get();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Adds a callback to be called when a string is being interned.\n+        /// </summary>\n+        /// <param name=\"callback\">The callback to add.</param>\n+        /// <remarks>\n+        /// Use this to implement custom interning for some strings. The callback has access to the string being interned\n+        /// via the <see cref=\"InternableString\"/> representation and can override the default behavior by returning a custom\n+        /// string.\n+        /// </remarks>\n+        public static void RegisterStringInterningCallback(TryInternStringDelegate callback)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I have removed the callback, you were right that hardcoded strings were not helping. Thank you!",
              "createdAt": "2020-12-15T11:19:42Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,232 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class StringTools\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_ropeBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<RopeBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new RopeBuilder with the default capacity.\n+            /// </summary>\n+            public RopeBuilder Create()\n+            {\n+                return new RopeBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(RopeBuilder ropeBuilder)\n+            {\n+                if (ropeBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    ropeBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of RopeBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<RopeBuilder> s_ropeBuilderPool =\n+            new DefaultObjectPool<RopeBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);\n+#endif\n+\n+        /// <summary>\n+        /// An array of callbacks to be called for each string being interned.\n+        /// </summary>\n+        private static volatile TryInternStringDelegate[] s_internStringCallbacks = new TryInternStringDelegate[0];\n+\n+        /// <summary>\n+        /// A lock protecting writes to <see cref=\"s_internStringCallbacks\"/>.\n+        /// </summary>\n+        private static object s_locker = new object();\n+\n+\n+        #region Public methods\n+\n+        /// <summary>\n+        /// Interns the given string if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The string to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(string str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+\n+#if !NET35\n+        /// <summary>\n+        /// Interns the given readonly character span if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The character span to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(ReadOnlySpan<char> str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+#endif\n+\n+        /// <summary>\n+        /// Returns a new or recycled <see cref=\"RopeBuilder\"/>.\n+        /// </summary>\n+        /// <returns>The RopeBuilder.</returns>\n+        /// <remarks>\n+        /// Call <see cref=\"IDisposable.Dispose\"/> on the returned instance to recycle it.\n+        /// </remarks>\n+        public static RopeBuilder GetRopeBuilder()\n+        {\n+#if NET35\n+            return new RopeBuilder();\n+#else\n+            return s_ropeBuilderPool.Get();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Adds a callback to be called when a string is being interned.\n+        /// </summary>\n+        /// <param name=\"callback\">The callback to add.</param>\n+        /// <remarks>\n+        /// Use this to implement custom interning for some strings. The callback has access to the string being interned\n+        /// via the <see cref=\"InternableString\"/> representation and can override the default behavior by returning a custom\n+        /// string.\n+        /// </remarks>\n+        public static void RegisterStringInterningCallback(TryInternStringDelegate callback)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Ideally this class should be subsumed by the RopeBuilder right? Worth adding a class comment saying that?",
              "createdAt": "2020-09-11T16:02:14Z",
              "path": "src/Shared/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -17,19 +17,13 @@ namespace Microsoft.Build.Shared\n     /// <remarks>\n     /// You can add any properties or methods on the real StringBuilder that are needed.\n     /// </remarks>\n-    internal sealed class ReuseableStringBuilder : IDisposable, IInternable",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Done, thanks!",
              "createdAt": "2020-09-14T14:36:07Z",
              "path": "src/Shared/ReuseableStringBuilder.cs",
              "diffHunk": "@@ -17,19 +17,13 @@ namespace Microsoft.Build.Shared\n     /// <remarks>\n     /// You can add any properties or methods on the real StringBuilder that are needed.\n     /// </remarks>\n-    internal sealed class ReuseableStringBuilder : IDisposable, IInternable",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It might be reasonable to finally replace this with a .slnf.",
              "createdAt": "2020-09-14T23:45:49Z",
              "path": "MSBuild.Dev.sln",
              "diffHunk": "@@ -1,7 +1,7 @@\n \ufeff\n Microsoft Visual Studio Solution File, Format Version 12.00\n-# Visual Studio 15",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you need to add this to MSBuildLocator and lists of our assemblies in VS?",
              "createdAt": "2020-09-14T23:46:38Z",
              "path": "MSBuild.Dev.sln",
              "diffHunk": "@@ -33,6 +33,12 @@ Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Microsoft.Build.Utilities.U\n EndProject\n Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Xunit.NetCore.Extensions\", \"src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj\", \"{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}\"\n EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"StringTools\", \"src\\StringTools\\StringTools.csproj\", \"{69FB7694-47E3-45B2-868C-8C3ECB69A947}\"",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes to both. VS is handled here and with additional changes in the corresponding insertion. MSBuildLocator will be made aware of the new assembly later.",
              "createdAt": "2020-12-01T12:51:06Z",
              "path": "MSBuild.Dev.sln",
              "diffHunk": "@@ -33,6 +33,12 @@ Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Microsoft.Build.Utilities.U\n EndProject\n Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Xunit.NetCore.Extensions\", \"src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj\", \"{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}\"\n EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"StringTools\", \"src\\StringTools\\StringTools.csproj\", \"{69FB7694-47E3-45B2-868C-8C3ECB69A947}\"",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm surprised changes like this make it more efficient. Do you have numbers on that?",
              "createdAt": "2020-09-14T23:55:48Z",
              "path": "src/Build/Construction/Solution/SolutionProjectGenerator.cs",
              "diffHunk": "@@ -1097,8 +1099,11 @@ private static string GetConfigurationAndPlatformPropertiesString(ProjectConfigu\n         /// </summary>\n         private static string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration)\n         {\n-            string directProjectProperties = OpportunisticIntern.InternStringIfPossible(String.Join(\";\", GetConfigurationAndPlatformPropertiesString(projectConfiguration), SolutionProperties));\n-            return directProjectProperties;\n+            using SpanBasedStringBuilder directProjectProperties = Strings.GetSpanBasedStringBuilder();\n+            directProjectProperties.Append(GetConfigurationAndPlatformPropertiesString(projectConfiguration));\n+            directProjectProperties.Append(\";\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "You're right, this is overkill. The advantage of doing it this way is that it's zero-alloc in case the resulting string has already been interned. But it costs significantly more time otherwise and is less readable so I've reverted it, thanks!",
              "createdAt": "2020-11-30T14:02:39Z",
              "path": "src/Build/Construction/Solution/SolutionProjectGenerator.cs",
              "diffHunk": "@@ -1097,8 +1099,11 @@ private static string GetConfigurationAndPlatformPropertiesString(ProjectConfigu\n         /// </summary>\n         private static string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration)\n         {\n-            string directProjectProperties = OpportunisticIntern.InternStringIfPossible(String.Join(\";\", GetConfigurationAndPlatformPropertiesString(projectConfiguration), SolutionProperties));\n-            return directProjectProperties;\n+            using SpanBasedStringBuilder directProjectProperties = Strings.GetSpanBasedStringBuilder();\n+            directProjectProperties.Append(GetConfigurationAndPlatformPropertiesString(projectConfiguration));\n+            directProjectProperties.Append(\";\");",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why doesn't this allocate a new string?",
              "createdAt": "2020-09-15T16:45:09Z",
              "path": "src/Shared/StringToolsHost.cs",
              "diffHunk": "@@ -0,0 +1,130 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Diagnostics;\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.StringTools;\n+\n+namespace Microsoft.Build\n+{\n+    internal static class StringToolsHost\n+    {\n+        private static bool s_isInitialized = false;\n+\n+        public static void Initialize()\n+        {\n+            if (!s_isInitialized)\n+            {\n+                // RegisterStringInterningCallback is thread-safe and idempotent so no need to worry about potentially getting here multiple times.\n+                Strings.RegisterStringInterningCallback(TryMatchHardcodedStrings);\n+                s_isInitialized = true;\n+            }\n+        }\n+\n+        private static bool TryInternHardcodedString(ref InternableString candidate, string str, ref string interned)\n+        {\n+            Debug.Assert(candidate.Length == str.Length);\n+\n+            if (candidate.StartsWithStringByOrdinalComparison(str))\n+            {\n+                interned = str;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Try to match the candidate with small number of hardcoded interned string literals.\n+        /// The return value indicates how the string was interned (if at all).\n+        /// </summary>\n+        /// <returns>\n+        /// True if the candidate matched a hardcoded literal or should not be interned, false otherwise.\n+        /// </returns>\n+        private static bool TryMatchHardcodedStrings(ref InternableString candidate, out string interned)\n+        {\n+            int length = candidate.Length;\n+            interned = null;\n+\n+            // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.\n+            if (length == 2)\n+            {\n+                if (candidate[1] == '#')\n+                {\n+                    if (candidate[0] == 'C')\n+                    {\n+                        interned = \"C#\";",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "String literals are pre-allocated by the runtime and don't cost anything at execution time. Using a literal like this just means that the variable is assigned an object reference - there is no allocation. Strings are even interned by the runtime so if you use the literal `\"C#\"` in multiple places in the code, they will all refer to the one pre-allocated instance.",
              "createdAt": "2020-11-30T14:10:38Z",
              "path": "src/Shared/StringToolsHost.cs",
              "diffHunk": "@@ -0,0 +1,130 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Diagnostics;\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.StringTools;\n+\n+namespace Microsoft.Build\n+{\n+    internal static class StringToolsHost\n+    {\n+        private static bool s_isInitialized = false;\n+\n+        public static void Initialize()\n+        {\n+            if (!s_isInitialized)\n+            {\n+                // RegisterStringInterningCallback is thread-safe and idempotent so no need to worry about potentially getting here multiple times.\n+                Strings.RegisterStringInterningCallback(TryMatchHardcodedStrings);\n+                s_isInitialized = true;\n+            }\n+        }\n+\n+        private static bool TryInternHardcodedString(ref InternableString candidate, string str, ref string interned)\n+        {\n+            Debug.Assert(candidate.Length == str.Length);\n+\n+            if (candidate.StartsWithStringByOrdinalComparison(str))\n+            {\n+                interned = str;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Try to match the candidate with small number of hardcoded interned string literals.\n+        /// The return value indicates how the string was interned (if at all).\n+        /// </summary>\n+        /// <returns>\n+        /// True if the candidate matched a hardcoded literal or should not be interned, false otherwise.\n+        /// </returns>\n+        private static bool TryMatchHardcodedStrings(ref InternableString candidate, out string interned)\n+        {\n+            int length = candidate.Length;\n+            interned = null;\n+\n+            // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.\n+            if (length == 2)\n+            {\n+                if (candidate[1] == '#')\n+                {\n+                    if (candidate[0] == 'C')\n+                    {\n+                        interned = \"C#\";",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why StartsWith rather than Equals?",
              "createdAt": "2020-09-15T16:46:11Z",
              "path": "src/Shared/StringToolsHost.cs",
              "diffHunk": "@@ -0,0 +1,130 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Diagnostics;\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.StringTools;\n+\n+namespace Microsoft.Build\n+{\n+    internal static class StringToolsHost\n+    {\n+        private static bool s_isInitialized = false;\n+\n+        public static void Initialize()\n+        {\n+            if (!s_isInitialized)\n+            {\n+                // RegisterStringInterningCallback is thread-safe and idempotent so no need to worry about potentially getting here multiple times.\n+                Strings.RegisterStringInterningCallback(TryMatchHardcodedStrings);\n+                s_isInitialized = true;\n+            }\n+        }\n+\n+        private static bool TryInternHardcodedString(ref InternableString candidate, string str, ref string interned)\n+        {\n+            Debug.Assert(candidate.Length == str.Length);\n+\n+            if (candidate.StartsWithStringByOrdinalComparison(str))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This was supporting strings starting with `\"MSBuildProjectInstance\"` which were previously hardcoded to **not** be interned. They are unique so if they are really created only once, it is true that interning them is a wasted effort. In this case the effect was negligible and not worth the added complexity, so hardcoded strings, both positive and negative, were removed. If an app/component using `StringTools` doesn't wish to intern certain strings, it should simply not run them through the `Intern` method.\r\n\r\nI have converted this method to `Equals`. Thank you!",
              "createdAt": "2020-12-15T11:16:54Z",
              "path": "src/Shared/StringToolsHost.cs",
              "diffHunk": "@@ -0,0 +1,130 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Diagnostics;\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.StringTools;\n+\n+namespace Microsoft.Build\n+{\n+    internal static class StringToolsHost\n+    {\n+        private static bool s_isInitialized = false;\n+\n+        public static void Initialize()\n+        {\n+            if (!s_isInitialized)\n+            {\n+                // RegisterStringInterningCallback is thread-safe and idempotent so no need to worry about potentially getting here multiple times.\n+                Strings.RegisterStringInterningCallback(TryMatchHardcodedStrings);\n+                s_isInitialized = true;\n+            }\n+        }\n+\n+        private static bool TryInternHardcodedString(ref InternableString candidate, string str, ref string interned)\n+        {\n+            Debug.Assert(candidate.Length == str.Length);\n+\n+            if (candidate.StartsWithStringByOrdinalComparison(str))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Add `''==''`?",
              "createdAt": "2020-09-15T16:47:55Z",
              "path": "src/Shared/StringToolsHost.cs",
              "diffHunk": "@@ -0,0 +1,130 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Diagnostics;\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.StringTools;\n+\n+namespace Microsoft.Build\n+{\n+    internal static class StringToolsHost\n+    {\n+        private static bool s_isInitialized = false;\n+\n+        public static void Initialize()\n+        {\n+            if (!s_isInitialized)\n+            {\n+                // RegisterStringInterningCallback is thread-safe and idempotent so no need to worry about potentially getting here multiple times.\n+                Strings.RegisterStringInterningCallback(TryMatchHardcodedStrings);\n+                s_isInitialized = true;\n+            }\n+        }\n+\n+        private static bool TryInternHardcodedString(ref InternableString candidate, string str, ref string interned)\n+        {\n+            Debug.Assert(candidate.Length == str.Length);\n+\n+            if (candidate.StartsWithStringByOrdinalComparison(str))\n+            {\n+                interned = str;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Try to match the candidate with small number of hardcoded interned string literals.\n+        /// The return value indicates how the string was interned (if at all).\n+        /// </summary>\n+        /// <returns>\n+        /// True if the candidate matched a hardcoded literal or should not be interned, false otherwise.\n+        /// </returns>\n+        private static bool TryMatchHardcodedStrings(ref InternableString candidate, out string interned)\n+        {\n+            int length = candidate.Length;\n+            interned = null;\n+\n+            // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.\n+            if (length == 2)\n+            {\n+                if (candidate[1] == '#')\n+                {\n+                    if (candidate[0] == 'C')\n+                    {\n+                        interned = \"C#\";\n+                        return true;\n+                    }\n+\n+                    if (candidate[0] == 'F')\n+                    {\n+                        interned = \"F#\";\n+                        return true;\n+                    }\n+                }\n+\n+                if (candidate[0] == 'V' && candidate[1] == 'B')\n+                {\n+                    interned = \"VB\";\n+                    return true;\n+                }\n+            }\n+            else if (length == 4)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"TRUE\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"True\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Copy\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"true\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"v4.0\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            else if (length == 5)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"FALSE\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"false\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Debug\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Build\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Win32\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            else if (length == 6)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"''!=''\", ref interned) ||",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Hardcoded strings are not supported anymore, this code is gone.",
              "createdAt": "2020-12-15T10:41:14Z",
              "path": "src/Shared/StringToolsHost.cs",
              "diffHunk": "@@ -0,0 +1,130 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Diagnostics;\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.StringTools;\n+\n+namespace Microsoft.Build\n+{\n+    internal static class StringToolsHost\n+    {\n+        private static bool s_isInitialized = false;\n+\n+        public static void Initialize()\n+        {\n+            if (!s_isInitialized)\n+            {\n+                // RegisterStringInterningCallback is thread-safe and idempotent so no need to worry about potentially getting here multiple times.\n+                Strings.RegisterStringInterningCallback(TryMatchHardcodedStrings);\n+                s_isInitialized = true;\n+            }\n+        }\n+\n+        private static bool TryInternHardcodedString(ref InternableString candidate, string str, ref string interned)\n+        {\n+            Debug.Assert(candidate.Length == str.Length);\n+\n+            if (candidate.StartsWithStringByOrdinalComparison(str))\n+            {\n+                interned = str;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Try to match the candidate with small number of hardcoded interned string literals.\n+        /// The return value indicates how the string was interned (if at all).\n+        /// </summary>\n+        /// <returns>\n+        /// True if the candidate matched a hardcoded literal or should not be interned, false otherwise.\n+        /// </returns>\n+        private static bool TryMatchHardcodedStrings(ref InternableString candidate, out string interned)\n+        {\n+            int length = candidate.Length;\n+            interned = null;\n+\n+            // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.\n+            if (length == 2)\n+            {\n+                if (candidate[1] == '#')\n+                {\n+                    if (candidate[0] == 'C')\n+                    {\n+                        interned = \"C#\";\n+                        return true;\n+                    }\n+\n+                    if (candidate[0] == 'F')\n+                    {\n+                        interned = \"F#\";\n+                        return true;\n+                    }\n+                }\n+\n+                if (candidate[0] == 'V' && candidate[1] == 'B')\n+                {\n+                    interned = \"VB\";\n+                    return true;\n+                }\n+            }\n+            else if (length == 4)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"TRUE\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"True\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Copy\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"true\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"v4.0\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            else if (length == 5)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"FALSE\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"false\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Debug\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Build\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Win32\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            else if (length == 6)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"''!=''\", ref interned) ||",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nice! Are there any other common examples?",
              "createdAt": "2020-09-15T16:50:13Z",
              "path": "src/Shared/StringToolsHost.cs",
              "diffHunk": "@@ -0,0 +1,130 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Diagnostics;\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.StringTools;\n+\n+namespace Microsoft.Build\n+{\n+    internal static class StringToolsHost\n+    {\n+        private static bool s_isInitialized = false;\n+\n+        public static void Initialize()\n+        {\n+            if (!s_isInitialized)\n+            {\n+                // RegisterStringInterningCallback is thread-safe and idempotent so no need to worry about potentially getting here multiple times.\n+                Strings.RegisterStringInterningCallback(TryMatchHardcodedStrings);\n+                s_isInitialized = true;\n+            }\n+        }\n+\n+        private static bool TryInternHardcodedString(ref InternableString candidate, string str, ref string interned)\n+        {\n+            Debug.Assert(candidate.Length == str.Length);\n+\n+            if (candidate.StartsWithStringByOrdinalComparison(str))\n+            {\n+                interned = str;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Try to match the candidate with small number of hardcoded interned string literals.\n+        /// The return value indicates how the string was interned (if at all).\n+        /// </summary>\n+        /// <returns>\n+        /// True if the candidate matched a hardcoded literal or should not be interned, false otherwise.\n+        /// </returns>\n+        private static bool TryMatchHardcodedStrings(ref InternableString candidate, out string interned)\n+        {\n+            int length = candidate.Length;\n+            interned = null;\n+\n+            // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.\n+            if (length == 2)\n+            {\n+                if (candidate[1] == '#')\n+                {\n+                    if (candidate[0] == 'C')\n+                    {\n+                        interned = \"C#\";\n+                        return true;\n+                    }\n+\n+                    if (candidate[0] == 'F')\n+                    {\n+                        interned = \"F#\";\n+                        return true;\n+                    }\n+                }\n+\n+                if (candidate[0] == 'V' && candidate[1] == 'B')\n+                {\n+                    interned = \"VB\";\n+                    return true;\n+                }\n+            }\n+            else if (length == 4)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"TRUE\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"True\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Copy\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"true\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"v4.0\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            else if (length == 5)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"FALSE\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"false\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Debug\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Build\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Win32\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            else if (length == 6)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"''!=''\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"AnyCPU\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            else if (length == 7)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"Library\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"MSBuild\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Release\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            // see Microsoft.Build.BackEnd.BuildRequestConfiguration.CreateUniqueGlobalProperty\n+            else if (length > MSBuildConstants.MSBuildDummyGlobalPropertyHeader.Length &&\n+                    candidate.StartsWithStringByOrdinalComparison(MSBuildConstants.MSBuildDummyGlobalPropertyHeader))\n+            {\n+                // don't want to leak unique strings into the cache\n+                interned = null;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This code was removed, I feel bad for not responding to your question earlier.",
              "createdAt": "2020-12-15T11:21:50Z",
              "path": "src/Shared/StringToolsHost.cs",
              "diffHunk": "@@ -0,0 +1,130 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Diagnostics;\n+\n+using Microsoft.Build.Shared;\n+using Microsoft.StringTools;\n+\n+namespace Microsoft.Build\n+{\n+    internal static class StringToolsHost\n+    {\n+        private static bool s_isInitialized = false;\n+\n+        public static void Initialize()\n+        {\n+            if (!s_isInitialized)\n+            {\n+                // RegisterStringInterningCallback is thread-safe and idempotent so no need to worry about potentially getting here multiple times.\n+                Strings.RegisterStringInterningCallback(TryMatchHardcodedStrings);\n+                s_isInitialized = true;\n+            }\n+        }\n+\n+        private static bool TryInternHardcodedString(ref InternableString candidate, string str, ref string interned)\n+        {\n+            Debug.Assert(candidate.Length == str.Length);\n+\n+            if (candidate.StartsWithStringByOrdinalComparison(str))\n+            {\n+                interned = str;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Try to match the candidate with small number of hardcoded interned string literals.\n+        /// The return value indicates how the string was interned (if at all).\n+        /// </summary>\n+        /// <returns>\n+        /// True if the candidate matched a hardcoded literal or should not be interned, false otherwise.\n+        /// </returns>\n+        private static bool TryMatchHardcodedStrings(ref InternableString candidate, out string interned)\n+        {\n+            int length = candidate.Length;\n+            interned = null;\n+\n+            // Each of the hard-coded small strings below showed up in a profile run with considerable duplication in memory.\n+            if (length == 2)\n+            {\n+                if (candidate[1] == '#')\n+                {\n+                    if (candidate[0] == 'C')\n+                    {\n+                        interned = \"C#\";\n+                        return true;\n+                    }\n+\n+                    if (candidate[0] == 'F')\n+                    {\n+                        interned = \"F#\";\n+                        return true;\n+                    }\n+                }\n+\n+                if (candidate[0] == 'V' && candidate[1] == 'B')\n+                {\n+                    interned = \"VB\";\n+                    return true;\n+                }\n+            }\n+            else if (length == 4)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"TRUE\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"True\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Copy\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"true\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"v4.0\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            else if (length == 5)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"FALSE\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"false\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Debug\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Build\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Win32\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            else if (length == 6)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"''!=''\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"AnyCPU\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            else if (length == 7)\n+            {\n+                if (TryInternHardcodedString(ref candidate, \"Library\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"MSBuild\", ref interned) ||\n+                    TryInternHardcodedString(ref candidate, \"Release\", ref interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            // see Microsoft.Build.BackEnd.BuildRequestConfiguration.CreateUniqueGlobalProperty\n+            else if (length > MSBuildConstants.MSBuildDummyGlobalPropertyHeader.Length &&\n+                    candidate.StartsWithStringByOrdinalComparison(MSBuildConstants.MSBuildDummyGlobalPropertyHeader))\n+            {\n+                // don't want to leak unique strings into the cache\n+                interned = null;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you think it would be better to detect trying to add an empty span to spans and just not add it? Makes this simpler.",
              "createdAt": "2020-09-15T17:03:29Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Not adding empty spans sounds reasonable, done. If spans are guaranteed non-empty, the enumerator can lose one `if` when moving to the next span. I don't think it's worth adding the invariant, especially since maintaining the invariant comes with a cost also. I'll keep as is for now.",
              "createdAt": "2020-12-04T10:01:17Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nI'd inline AddSpan and make this call Append(string, int, int) with defaults.",
              "createdAt": "2020-09-15T17:09:22Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Done.",
              "createdAt": "2020-12-04T10:03:12Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You cannot change this to a foreach loop because then you'd be modifying it as you enumerate over it, correct?",
              "createdAt": "2020-09-15T17:18:01Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I need the current index to modify the list so rather than a `foreach` + counting the index I believe it's more natural to have a `for` loop and use the same index variable for reading and writing.",
              "createdAt": "2020-12-04T10:05:58Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Did you consider making _spans either a LinkedList (with a head and tail pointer) or a circular array with an explicit start position? Either would make it cleaner to just remove any empty spans at the beginning of the list, which might save a tiny amount of time looking them over here and also makes it reasonable to maintain the invariant that no span in _spans is empty.\r\n\r\nThe advantage of the LinkedList is that, like the array-based List, it's implemented for you, and you don't have to worry about resizing the array. The advantage of the circular array is that there's no overhead, but you might have to implement it yourself. (Or, in practice, I'd be happy making it, since I love data structures \ud83d\ude04 )",
              "createdAt": "2020-09-15T17:24:26Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;\n+                }\n+                if (!_spans[spanIdx].IsEmpty)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I like the idea. Both `LinkedList` and a circular array look like good options. `LinkedList` can efficiently remove from the middle if we ever support `Remove`. I'd have to keep a pool of nodes, though, to avoid unnecessary allocations. I'll measure and get back to this.",
              "createdAt": "2020-12-04T10:11:01Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;\n+                }\n+                if (!_spans[spanIdx].IsEmpty)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "What were the results of this, and would it be helpful if I made one of them?",
              "createdAt": "2020-12-17T15:53:43Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;\n+                }\n+                if (!_spans[spanIdx].IsEmpty)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I'm tracking this as low-pri given that we support only `Append` for now. I think it would make sense to revisit when we add more operations. If you have time and want to benchmark other data structures, I'm not going to object .. although there are other areas that likely have sub-optimal implementation that's hurting us more - for example the hash code computation in `InternableString.GetHashCode`.",
              "createdAt": "2020-12-18T13:57:55Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;\n+                }\n+                if (!_spans[spanIdx].IsEmpty)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you think anyone would want a TrimSpans method that trims each span in _spans?",
              "createdAt": "2020-09-15T17:25:35Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;\n+                }\n+                if (!_spans[spanIdx].IsEmpty)\n+                {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Removes trailing white-space characters from the string.\n+        /// </summary>\n+        public void TrimEnd()\n+        {\n+            for (int spanIdx = _spans.Count - 1; spanIdx >= 0; spanIdx--)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = span.Length - 1;\n+                while (i >= 0 && char.IsWhiteSpace(span[i]))\n+                {\n+                    i--;\n+                }\n+                if (i + 1 < span.Length)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(0, i + 1);\n+                    Length -= span.Length - (i + 1);\n+                }\n+                if (!_spans[spanIdx].IsEmpty)\n+                {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Removes leading and trailing white-space characters from the string.\n+        /// </summary>\n+        public void Trim()",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I can imagine adding such a convenience method but haven't seen the need yet. We could also possibly expose `Append(ReadOnlyMemory<char>)` to make it easier for the caller to trim before appending.",
              "createdAt": "2020-12-01T12:59:16Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;\n+                }\n+                if (!_spans[spanIdx].IsEmpty)\n+                {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Removes trailing white-space characters from the string.\n+        /// </summary>\n+        public void TrimEnd()\n+        {\n+            for (int spanIdx = _spans.Count - 1; spanIdx >= 0; spanIdx--)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = span.Length - 1;\n+                while (i >= 0 && char.IsWhiteSpace(span[i]))\n+                {\n+                    i--;\n+                }\n+                if (i + 1 < span.Length)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(0, i + 1);\n+                    Length -= span.Length - (i + 1);\n+                }\n+                if (!_spans[spanIdx].IsEmpty)\n+                {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Removes leading and trailing white-space characters from the string.\n+        /// </summary>\n+        public void Trim()",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd expect:\r\n- if the first X spans are empty, it removes them from the beginning of the span list. If all spans contain whitespace it leaves the span list empty\r\n- it slices the first non empty span\r\n\r\nThe current method seems to trim all the left spans up until the first non white space one, but does not remove the empty ones. Or is it not a big issue to leave the empty spans? Removing them does not seem to bring any benefits, just perf penalty.",
              "createdAt": "2020-09-17T00:49:55Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Same goes for TrimEnd.",
              "createdAt": "2020-09-17T00:53:06Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Span list is array-based, so that would be very expensive. One of my (unsent) comments would propose a way to do that cheaply.",
              "createdAt": "2020-09-17T00:57:05Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It depends on the way `SpanBasedStringBuilder` is used. For the typical \"call `Append` a few times followed by `ToString`\" the overhead of removing empty spans may not be worth the savings because there's just a few passes over the string that can benefit from this and then the entire thing is released. I'll experiment with this suggestion using a microbenchmark.",
              "createdAt": "2020-12-04T10:15:44Z",
              "path": "src/StringTools/SpanBasedStringBuilder.cs",
              "diffHunk": "@@ -0,0 +1,253 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A StringBuilder replacement that keeps a list of <see cref=\"ReadOnlyMemory{T}\"/> spans making up the intermediate string rather\n+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)\n+    /// and time (no need to copy characters to the intermediate string).\n+    /// </summary>\n+    /// <remarks>\n+    /// The <see cref=\"ToString\"/> method tries to intern the resulting string without even allocating it if it's already interned.\n+    /// Use <see cref=\"Strings.GetSpanBasedStringBuilder\"/> to take advantage of pooling to eliminate allocation overhead of this class.\n+    /// </remarks>\n+    public class SpanBasedStringBuilder : IDisposable\n+    {\n+        /// <summary>\n+        /// Enumerator for the top-level class. Enumerates characters of the string.\n+        /// </summary>\n+        public struct Enumerator\n+        {\n+            /// <summary>\n+            /// The spans being enumerated.\n+            /// </summary>\n+            private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+            /// <summary>\n+            /// Index of the current span.\n+            /// </summary>\n+            private int _spanIndex;\n+\n+            /// <summary>\n+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.\n+            /// </summary>\n+            private int _charIndex;\n+\n+            internal Enumerator(List<ReadOnlyMemory<char>> spans)\n+            {\n+                _spans = spans;\n+                _spanIndex = 0;\n+                _charIndex = -1;\n+            }\n+\n+            /// <summary>\n+            /// Returns the current character.\n+            /// </summary>\n+            public readonly char Current\n+            {\n+                get\n+                {\n+                    ReadOnlyMemory<char> span = _spans[_spanIndex];\n+                    return span.Span[_charIndex];\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Moves to the next character.\n+            /// </summary>\n+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>\n+            public bool MoveNext()\n+            {\n+                int newCharIndex = _charIndex + 1;\n+                while (_spanIndex < _spans.Count)\n+                {\n+                    if (newCharIndex < _spans[_spanIndex].Length)\n+                    {\n+                        _charIndex = newCharIndex;\n+                        return true;\n+                    }\n+                    _spanIndex++;\n+                    newCharIndex = 0;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Spans making up the rope.\n+        /// </summary>\n+        private readonly List<ReadOnlyMemory<char>> _spans;\n+\n+        /// <summary>\n+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.\n+        /// </summary>\n+        internal List<ReadOnlyMemory<char>> Spans => _spans;\n+\n+        /// <summary>\n+        /// Constructs a new SpanBasedStringBuilder containing the given string.\n+        /// </summary>\n+        /// <param name=\"str\">The string to wrap, must be non-null.</param>\n+        public SpanBasedStringBuilder(string str)\n+            : this()\n+        {\n+            if (str == null)\n+            {\n+                throw new ArgumentNullException(nameof(str));\n+            }\n+            Append(str);\n+        }\n+\n+        /// <summary>\n+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.\n+        /// </summary>\n+        public SpanBasedStringBuilder(int capacity = 4)\n+        {\n+            _spans = new List<ReadOnlyMemory<char>>(capacity);\n+            Length = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets the length of the string.\n+        /// </summary>\n+        public int Length { get; private set; }\n+\n+        /// <summary>\n+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.\n+        /// </summary>\n+        public int Capacity => _spans.Capacity;\n+\n+        /// <summary>\n+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.\n+        /// </summary>\n+        /// <returns>The enumerator.</returns>\n+        public Enumerator GetEnumerator()\n+        {\n+            return new Enumerator(_spans);\n+        }\n+\n+        /// <summary>\n+        /// Converts this instance to a System.String while first searching for a match in the intern table.\n+        /// </summary>\n+        /// <remarks>\n+        /// May allocate depending on whether the string has already been interned.\n+        /// </remarks>\n+        public override string ToString()\n+        {\n+            return new InternableString(this).ToString();\n+        }\n+\n+        /// <summary>\n+        /// Releases this instance.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            Strings.ReturnSpanBasedStringBuilder(this);\n+        }\n+\n+        #region Public mutating methods\n+\n+        /// <summary>\n+        /// Appends a string.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        public void Append(string value)\n+        {\n+            AddSpan(value.AsMemory());\n+        }\n+\n+        /// <summary>\n+        /// Appends a substring.\n+        /// </summary>\n+        /// <param name=\"value\">The string to append.</param>\n+        /// <param name=\"startIndex\">The start index of the substring within <paramref name=\"value\"/> to append.</param>\n+        /// <param name=\"count\">The length of the substring to append.</param>\n+        public void Append(string value, int startIndex, int count)\n+        {\n+            AddSpan(value.AsMemory(startIndex, count));\n+        }\n+\n+        /// <summary>\n+        /// Removes leading white-space characters from the string.\n+        /// </summary>\n+        public void TrimStart()\n+        {\n+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)\n+            {\n+                ReadOnlySpan<char> span = _spans[spanIdx].Span;\n+                int i = 0;\n+                while (i < span.Length && char.IsWhiteSpace(span[i]))\n+                {\n+                    i++;\n+                }\n+                if (i > 0)\n+                {\n+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);\n+                    Length -= i;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`IInternable` was able to represent any string like structure whereas `InternableString` only works with spans. The assumption is that any string like structure that msbuild wants to intern should be convertible to a span, which as far as I can tell is a pretty good assumption.",
              "createdAt": "2020-09-17T01:24:43Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -0,0 +1,343 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Represents a string that can be converted to System.String with interning, i.e. by returning an existing string if it has been seen before\n+    /// and is still tracked in the intern table.\n+    /// </summary>\n+    /// <remarks>\n+    /// The structure is public because it's exposed via the <see cref=\"TryInternStringDelegate\"/> callback. It's a mutable struct and should\n+    /// generally not be used directly from outside of the library.\n+    /// </remarks>\n+    public ref struct InternableString",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm a little confused about when someone should use InternableString vs. SpanBasedStringBuilder. Since they have some similarities in their implementation, some of my comments there might also apply here.",
              "createdAt": "2020-09-17T16:15:07Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -0,0 +1,343 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Represents a string that can be converted to System.String with interning, i.e. by returning an existing string if it has been seen before\n+    /// and is still tracked in the intern table.\n+    /// </summary>\n+    /// <remarks>\n+    /// The structure is public because it's exposed via the <see cref=\"TryInternStringDelegate\"/> callback. It's a mutable struct and should\n+    /// generally not be used directly from outside of the library.\n+    /// </remarks>\n+    public ref struct InternableString\n+    {",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "You're right, it was confusing. The only reason `InternableString` was exposed was to pass it to the intern callback. Now that the callback is gone, the type can be internal and not part of the public surface. Thanks!",
              "createdAt": "2020-12-15T11:27:57Z",
              "path": "src/StringTools/InternableString.cs",
              "diffHunk": "@@ -0,0 +1,343 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Represents a string that can be converted to System.String with interning, i.e. by returning an existing string if it has been seen before\n+    /// and is still tracked in the intern table.\n+    /// </summary>\n+    /// <remarks>\n+    /// The structure is public because it's exposed via the <see cref=\"TryInternStringDelegate\"/> callback. It's a mutable struct and should\n+    /// generally not be used directly from outside of the library.\n+    /// </remarks>\n+    public ref struct InternableString\n+    {",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this class be static?",
              "createdAt": "2020-09-17T16:17:01Z",
              "path": "src/StringTools/OpportunisticIntern.cs",
              "diffHunk": "@@ -0,0 +1,295 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Interns strings by holding weak references.\n+    /// </summary>\n+    internal sealed class OpportunisticIntern : IDisposable",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This code is gone now. I believe it was implemented like this (state in instance fields + a static `Instance` getter) for testability, i.e. all state can be easily reset by re-creating the singleton instance.",
              "createdAt": "2020-12-15T11:53:30Z",
              "path": "src/StringTools/OpportunisticIntern.cs",
              "diffHunk": "@@ -0,0 +1,295 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Interns strings by holding weak references.\n+    /// </summary>\n+    internal sealed class OpportunisticIntern : IDisposable",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should all these strings be localized?",
              "createdAt": "2020-09-17T16:18:42Z",
              "path": "src/StringTools/OpportunisticIntern.cs",
              "diffHunk": "@@ -0,0 +1,295 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Interns strings by holding weak references.\n+    /// </summary>\n+    internal sealed class OpportunisticIntern : IDisposable\n+    {\n+        /// <summary>\n+        /// The singleton instance of OpportunisticIntern.\n+        /// </summary>\n+        private static OpportunisticIntern _instance = new OpportunisticIntern();\n+        internal static OpportunisticIntern Instance => _instance;\n+\n+        /// <summary>\n+        /// The interner implementation in use.\n+        /// </summary>\n+        private WeakStringCacheInterner _interner;\n+\n+        private OpportunisticIntern()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: false);\n+        }\n+\n+        /// <summary>\n+        /// Recreates the singleton instance based on the current environment (test only).\n+        /// </summary>\n+        internal static void ResetForTests()\n+        {\n+            _instance.Dispose();\n+            _instance = new OpportunisticIntern();\n+        }\n+\n+        /// <summary>\n+        /// Turn on statistics gathering.\n+        /// </summary>\n+        internal void EnableStatisticsGathering()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: true);\n+        }\n+\n+        /// <summary>\n+        /// Intern the given internable.\n+        /// </summary>\n+        internal string InternableToString(ref InternableString candidate)\n+        {\n+            if (candidate.Length == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            string result = _interner.InterningToString(ref candidate);\n+#if DEBUG\n+            string expected = candidate.ExpensiveConvertToString();\n+            if (!String.Equals(result, expected))\n+            {\n+                throw new InvalidOperationException(String.Format(\"Interned string {0} should have been {1}\", result, expected));\n+            }\n+#endif\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Returns a string with human-readable statistics. Make sure to call <see cref=\"EnableStatisticsGathering\"/> beforehand.\n+        /// </summary>\n+        internal string FormatStatistics()\n+        {\n+            return _interner.FormatStatistics();\n+        }\n+\n+        /// <summary>\n+        /// Releases all strings from the underlying intern table.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            _interner.Dispose();\n+        }\n+\n+        /// <summary>\n+        /// Implements interning based on a WeakStringCache.\n+        /// </summary>\n+        private class WeakStringCacheInterner : IDisposable\n+        {\n+            /// <summary>\n+            /// Enumerates the possible interning results.\n+            /// </summary>\n+            private enum InternResult\n+            {\n+                MatchedHardcodedString,\n+                FoundInWeakStringCache,\n+                AddedToWeakStringCache,\n+                RejectedFromInterning\n+            }\n+\n+            /// <summary>\n+            /// The cache to keep strings in.\n+            /// </summary>\n+            private readonly WeakStringCache _weakStringCache = new WeakStringCache();\n+\n+#region Statistics\n+            /// <summary>\n+            /// Whether or not to gather statistics.\n+            /// </summary>\n+            private readonly bool _gatherStatistics;\n+\n+            /// <summary>\n+            /// Number of times interning with hardcoded string literals worked.\n+            /// </summary>\n+            private int _hardcodedInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path found the string in the cache.\n+            /// </summary>\n+            private int _regularInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path added the string to the cache.\n+            /// </summary>\n+            private int _regularInternMisses;\n+\n+            /// <summary>\n+            /// Number of times interning wasn't attempted.\n+            /// </summary>\n+            private int _rejectedStrings;\n+\n+            /// <summary>\n+            /// Total number of strings eliminated by interning.\n+            /// </summary>\n+            private int _internEliminatedStrings;\n+\n+            /// <summary>\n+            /// Total number of chars eliminated across all strings.\n+            /// </summary>\n+            private int _internEliminatedChars;\n+\n+            /// <summary>\n+            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been\n+            /// seen. The higher the number the better the payoff if the string had been hardcoded.\n+            /// </summary>\n+            private Dictionary<string, int> _missedHardcodedStrings;\n+\n+#endregion\n+\n+            public WeakStringCacheInterner(bool gatherStatistics)\n+            {\n+                if (gatherStatistics)\n+                {\n+                    _missedHardcodedStrings = new Dictionary<string, int>();\n+                }\n+                _gatherStatistics = gatherStatistics;\n+            }\n+\n+            /// <summary>\n+            /// Intern the given internable.\n+            /// </summary>\n+            public string InterningToString(ref InternableString candidate)\n+            {\n+                if (_gatherStatistics)\n+                {\n+                    return InternWithStatistics(ref candidate);\n+                }\n+                else\n+                {\n+                    TryIntern(ref candidate, out string result);\n+                    return result;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns a string with human-readable statistics.\n+            /// </summary>\n+            public string FormatStatistics()\n+            {\n+                StringBuilder result = new StringBuilder(1024);\n+\n+                string title = \"Opportunistic Intern\";\n+\n+                if (_gatherStatistics)\n+                {\n+                    result.AppendLine(string.Format(\"\\n{0}{1}{0}\", new string('=', 41 - (title.Length / 2)), title));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Hits\", _hardcodedInternHits, \"hits\"));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "For debug output behind an undocumented environment variable I vote for no. There are many places in the codebase producing non-localized debug output, for example `DumpSchedulerState`.",
              "createdAt": "2020-12-15T11:57:49Z",
              "path": "src/StringTools/OpportunisticIntern.cs",
              "diffHunk": "@@ -0,0 +1,295 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Interns strings by holding weak references.\n+    /// </summary>\n+    internal sealed class OpportunisticIntern : IDisposable\n+    {\n+        /// <summary>\n+        /// The singleton instance of OpportunisticIntern.\n+        /// </summary>\n+        private static OpportunisticIntern _instance = new OpportunisticIntern();\n+        internal static OpportunisticIntern Instance => _instance;\n+\n+        /// <summary>\n+        /// The interner implementation in use.\n+        /// </summary>\n+        private WeakStringCacheInterner _interner;\n+\n+        private OpportunisticIntern()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: false);\n+        }\n+\n+        /// <summary>\n+        /// Recreates the singleton instance based on the current environment (test only).\n+        /// </summary>\n+        internal static void ResetForTests()\n+        {\n+            _instance.Dispose();\n+            _instance = new OpportunisticIntern();\n+        }\n+\n+        /// <summary>\n+        /// Turn on statistics gathering.\n+        /// </summary>\n+        internal void EnableStatisticsGathering()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: true);\n+        }\n+\n+        /// <summary>\n+        /// Intern the given internable.\n+        /// </summary>\n+        internal string InternableToString(ref InternableString candidate)\n+        {\n+            if (candidate.Length == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            string result = _interner.InterningToString(ref candidate);\n+#if DEBUG\n+            string expected = candidate.ExpensiveConvertToString();\n+            if (!String.Equals(result, expected))\n+            {\n+                throw new InvalidOperationException(String.Format(\"Interned string {0} should have been {1}\", result, expected));\n+            }\n+#endif\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Returns a string with human-readable statistics. Make sure to call <see cref=\"EnableStatisticsGathering\"/> beforehand.\n+        /// </summary>\n+        internal string FormatStatistics()\n+        {\n+            return _interner.FormatStatistics();\n+        }\n+\n+        /// <summary>\n+        /// Releases all strings from the underlying intern table.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            _interner.Dispose();\n+        }\n+\n+        /// <summary>\n+        /// Implements interning based on a WeakStringCache.\n+        /// </summary>\n+        private class WeakStringCacheInterner : IDisposable\n+        {\n+            /// <summary>\n+            /// Enumerates the possible interning results.\n+            /// </summary>\n+            private enum InternResult\n+            {\n+                MatchedHardcodedString,\n+                FoundInWeakStringCache,\n+                AddedToWeakStringCache,\n+                RejectedFromInterning\n+            }\n+\n+            /// <summary>\n+            /// The cache to keep strings in.\n+            /// </summary>\n+            private readonly WeakStringCache _weakStringCache = new WeakStringCache();\n+\n+#region Statistics\n+            /// <summary>\n+            /// Whether or not to gather statistics.\n+            /// </summary>\n+            private readonly bool _gatherStatistics;\n+\n+            /// <summary>\n+            /// Number of times interning with hardcoded string literals worked.\n+            /// </summary>\n+            private int _hardcodedInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path found the string in the cache.\n+            /// </summary>\n+            private int _regularInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path added the string to the cache.\n+            /// </summary>\n+            private int _regularInternMisses;\n+\n+            /// <summary>\n+            /// Number of times interning wasn't attempted.\n+            /// </summary>\n+            private int _rejectedStrings;\n+\n+            /// <summary>\n+            /// Total number of strings eliminated by interning.\n+            /// </summary>\n+            private int _internEliminatedStrings;\n+\n+            /// <summary>\n+            /// Total number of chars eliminated across all strings.\n+            /// </summary>\n+            private int _internEliminatedChars;\n+\n+            /// <summary>\n+            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been\n+            /// seen. The higher the number the better the payoff if the string had been hardcoded.\n+            /// </summary>\n+            private Dictionary<string, int> _missedHardcodedStrings;\n+\n+#endregion\n+\n+            public WeakStringCacheInterner(bool gatherStatistics)\n+            {\n+                if (gatherStatistics)\n+                {\n+                    _missedHardcodedStrings = new Dictionary<string, int>();\n+                }\n+                _gatherStatistics = gatherStatistics;\n+            }\n+\n+            /// <summary>\n+            /// Intern the given internable.\n+            /// </summary>\n+            public string InterningToString(ref InternableString candidate)\n+            {\n+                if (_gatherStatistics)\n+                {\n+                    return InternWithStatistics(ref candidate);\n+                }\n+                else\n+                {\n+                    TryIntern(ref candidate, out string result);\n+                    return result;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns a string with human-readable statistics.\n+            /// </summary>\n+            public string FormatStatistics()\n+            {\n+                StringBuilder result = new StringBuilder(1024);\n+\n+                string title = \"Opportunistic Intern\";\n+\n+                if (_gatherStatistics)\n+                {\n+                    result.AppendLine(string.Format(\"\\n{0}{1}{0}\", new string('=', 41 - (title.Length / 2)), title));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Hits\", _hardcodedInternHits, \"hits\"));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What if there are under 15?\r\n\r\nAnd where did 15 come from?\r\n\r\nAnd should the Where come before the Take?",
              "createdAt": "2020-09-17T16:20:07Z",
              "path": "src/StringTools/OpportunisticIntern.cs",
              "diffHunk": "@@ -0,0 +1,295 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Interns strings by holding weak references.\n+    /// </summary>\n+    internal sealed class OpportunisticIntern : IDisposable\n+    {\n+        /// <summary>\n+        /// The singleton instance of OpportunisticIntern.\n+        /// </summary>\n+        private static OpportunisticIntern _instance = new OpportunisticIntern();\n+        internal static OpportunisticIntern Instance => _instance;\n+\n+        /// <summary>\n+        /// The interner implementation in use.\n+        /// </summary>\n+        private WeakStringCacheInterner _interner;\n+\n+        private OpportunisticIntern()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: false);\n+        }\n+\n+        /// <summary>\n+        /// Recreates the singleton instance based on the current environment (test only).\n+        /// </summary>\n+        internal static void ResetForTests()\n+        {\n+            _instance.Dispose();\n+            _instance = new OpportunisticIntern();\n+        }\n+\n+        /// <summary>\n+        /// Turn on statistics gathering.\n+        /// </summary>\n+        internal void EnableStatisticsGathering()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: true);\n+        }\n+\n+        /// <summary>\n+        /// Intern the given internable.\n+        /// </summary>\n+        internal string InternableToString(ref InternableString candidate)\n+        {\n+            if (candidate.Length == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            string result = _interner.InterningToString(ref candidate);\n+#if DEBUG\n+            string expected = candidate.ExpensiveConvertToString();\n+            if (!String.Equals(result, expected))\n+            {\n+                throw new InvalidOperationException(String.Format(\"Interned string {0} should have been {1}\", result, expected));\n+            }\n+#endif\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Returns a string with human-readable statistics. Make sure to call <see cref=\"EnableStatisticsGathering\"/> beforehand.\n+        /// </summary>\n+        internal string FormatStatistics()\n+        {\n+            return _interner.FormatStatistics();\n+        }\n+\n+        /// <summary>\n+        /// Releases all strings from the underlying intern table.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            _interner.Dispose();\n+        }\n+\n+        /// <summary>\n+        /// Implements interning based on a WeakStringCache.\n+        /// </summary>\n+        private class WeakStringCacheInterner : IDisposable\n+        {\n+            /// <summary>\n+            /// Enumerates the possible interning results.\n+            /// </summary>\n+            private enum InternResult\n+            {\n+                MatchedHardcodedString,\n+                FoundInWeakStringCache,\n+                AddedToWeakStringCache,\n+                RejectedFromInterning\n+            }\n+\n+            /// <summary>\n+            /// The cache to keep strings in.\n+            /// </summary>\n+            private readonly WeakStringCache _weakStringCache = new WeakStringCache();\n+\n+#region Statistics\n+            /// <summary>\n+            /// Whether or not to gather statistics.\n+            /// </summary>\n+            private readonly bool _gatherStatistics;\n+\n+            /// <summary>\n+            /// Number of times interning with hardcoded string literals worked.\n+            /// </summary>\n+            private int _hardcodedInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path found the string in the cache.\n+            /// </summary>\n+            private int _regularInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path added the string to the cache.\n+            /// </summary>\n+            private int _regularInternMisses;\n+\n+            /// <summary>\n+            /// Number of times interning wasn't attempted.\n+            /// </summary>\n+            private int _rejectedStrings;\n+\n+            /// <summary>\n+            /// Total number of strings eliminated by interning.\n+            /// </summary>\n+            private int _internEliminatedStrings;\n+\n+            /// <summary>\n+            /// Total number of chars eliminated across all strings.\n+            /// </summary>\n+            private int _internEliminatedChars;\n+\n+            /// <summary>\n+            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been\n+            /// seen. The higher the number the better the payoff if the string had been hardcoded.\n+            /// </summary>\n+            private Dictionary<string, int> _missedHardcodedStrings;\n+\n+#endregion\n+\n+            public WeakStringCacheInterner(bool gatherStatistics)\n+            {\n+                if (gatherStatistics)\n+                {\n+                    _missedHardcodedStrings = new Dictionary<string, int>();\n+                }\n+                _gatherStatistics = gatherStatistics;\n+            }\n+\n+            /// <summary>\n+            /// Intern the given internable.\n+            /// </summary>\n+            public string InterningToString(ref InternableString candidate)\n+            {\n+                if (_gatherStatistics)\n+                {\n+                    return InternWithStatistics(ref candidate);\n+                }\n+                else\n+                {\n+                    TryIntern(ref candidate, out string result);\n+                    return result;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns a string with human-readable statistics.\n+            /// </summary>\n+            public string FormatStatistics()\n+            {\n+                StringBuilder result = new StringBuilder(1024);\n+\n+                string title = \"Opportunistic Intern\";\n+\n+                if (_gatherStatistics)\n+                {\n+                    result.AppendLine(string.Format(\"\\n{0}{1}{0}\", new string('=', 41 - (title.Length / 2)), title));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Hits\", _hardcodedInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Rejects\", _rejectedStrings, \"rejects\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Hits\", _regularInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Misses\", _regularInternMisses, \"misses\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Strings*\", _internEliminatedStrings, \"strings\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Chars\", _internEliminatedChars, \"chars\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Estimated Eliminated Bytes\", _internEliminatedChars * 2, \"bytes\"));\n+                    result.AppendLine(\"Elimination assumes that strings provided were unique objects.\");\n+                    result.AppendLine(\"|---------------------------------------------------------------------------------|\");\n+\n+                    IEnumerable<string> topMissingHardcodedString =\n+                        _missedHardcodedStrings\n+                        .OrderByDescending(kv => kv.Value * kv.Key.Length)\n+                        .Take(15)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> What if there are under 15?\r\n\r\nThen everything will be returned. From `Enumerable.Take<>` docs:\r\n_If count exceeds the number of elements in source, all elements of source are returned._\r\n\r\n> And where did 15 come from?\r\n\r\nJust an arbitrary number to make the output reasonable in size. I copied this from the old code.\r\n\r\n> And should the Where come before the Take?\r\n\r\nYes, it makes more sense that way. Fixed!",
              "createdAt": "2020-12-15T12:40:51Z",
              "path": "src/StringTools/OpportunisticIntern.cs",
              "diffHunk": "@@ -0,0 +1,295 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Interns strings by holding weak references.\n+    /// </summary>\n+    internal sealed class OpportunisticIntern : IDisposable\n+    {\n+        /// <summary>\n+        /// The singleton instance of OpportunisticIntern.\n+        /// </summary>\n+        private static OpportunisticIntern _instance = new OpportunisticIntern();\n+        internal static OpportunisticIntern Instance => _instance;\n+\n+        /// <summary>\n+        /// The interner implementation in use.\n+        /// </summary>\n+        private WeakStringCacheInterner _interner;\n+\n+        private OpportunisticIntern()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: false);\n+        }\n+\n+        /// <summary>\n+        /// Recreates the singleton instance based on the current environment (test only).\n+        /// </summary>\n+        internal static void ResetForTests()\n+        {\n+            _instance.Dispose();\n+            _instance = new OpportunisticIntern();\n+        }\n+\n+        /// <summary>\n+        /// Turn on statistics gathering.\n+        /// </summary>\n+        internal void EnableStatisticsGathering()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: true);\n+        }\n+\n+        /// <summary>\n+        /// Intern the given internable.\n+        /// </summary>\n+        internal string InternableToString(ref InternableString candidate)\n+        {\n+            if (candidate.Length == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            string result = _interner.InterningToString(ref candidate);\n+#if DEBUG\n+            string expected = candidate.ExpensiveConvertToString();\n+            if (!String.Equals(result, expected))\n+            {\n+                throw new InvalidOperationException(String.Format(\"Interned string {0} should have been {1}\", result, expected));\n+            }\n+#endif\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Returns a string with human-readable statistics. Make sure to call <see cref=\"EnableStatisticsGathering\"/> beforehand.\n+        /// </summary>\n+        internal string FormatStatistics()\n+        {\n+            return _interner.FormatStatistics();\n+        }\n+\n+        /// <summary>\n+        /// Releases all strings from the underlying intern table.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            _interner.Dispose();\n+        }\n+\n+        /// <summary>\n+        /// Implements interning based on a WeakStringCache.\n+        /// </summary>\n+        private class WeakStringCacheInterner : IDisposable\n+        {\n+            /// <summary>\n+            /// Enumerates the possible interning results.\n+            /// </summary>\n+            private enum InternResult\n+            {\n+                MatchedHardcodedString,\n+                FoundInWeakStringCache,\n+                AddedToWeakStringCache,\n+                RejectedFromInterning\n+            }\n+\n+            /// <summary>\n+            /// The cache to keep strings in.\n+            /// </summary>\n+            private readonly WeakStringCache _weakStringCache = new WeakStringCache();\n+\n+#region Statistics\n+            /// <summary>\n+            /// Whether or not to gather statistics.\n+            /// </summary>\n+            private readonly bool _gatherStatistics;\n+\n+            /// <summary>\n+            /// Number of times interning with hardcoded string literals worked.\n+            /// </summary>\n+            private int _hardcodedInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path found the string in the cache.\n+            /// </summary>\n+            private int _regularInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path added the string to the cache.\n+            /// </summary>\n+            private int _regularInternMisses;\n+\n+            /// <summary>\n+            /// Number of times interning wasn't attempted.\n+            /// </summary>\n+            private int _rejectedStrings;\n+\n+            /// <summary>\n+            /// Total number of strings eliminated by interning.\n+            /// </summary>\n+            private int _internEliminatedStrings;\n+\n+            /// <summary>\n+            /// Total number of chars eliminated across all strings.\n+            /// </summary>\n+            private int _internEliminatedChars;\n+\n+            /// <summary>\n+            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been\n+            /// seen. The higher the number the better the payoff if the string had been hardcoded.\n+            /// </summary>\n+            private Dictionary<string, int> _missedHardcodedStrings;\n+\n+#endregion\n+\n+            public WeakStringCacheInterner(bool gatherStatistics)\n+            {\n+                if (gatherStatistics)\n+                {\n+                    _missedHardcodedStrings = new Dictionary<string, int>();\n+                }\n+                _gatherStatistics = gatherStatistics;\n+            }\n+\n+            /// <summary>\n+            /// Intern the given internable.\n+            /// </summary>\n+            public string InterningToString(ref InternableString candidate)\n+            {\n+                if (_gatherStatistics)\n+                {\n+                    return InternWithStatistics(ref candidate);\n+                }\n+                else\n+                {\n+                    TryIntern(ref candidate, out string result);\n+                    return result;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns a string with human-readable statistics.\n+            /// </summary>\n+            public string FormatStatistics()\n+            {\n+                StringBuilder result = new StringBuilder(1024);\n+\n+                string title = \"Opportunistic Intern\";\n+\n+                if (_gatherStatistics)\n+                {\n+                    result.AppendLine(string.Format(\"\\n{0}{1}{0}\", new string('=', 41 - (title.Length / 2)), title));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Hits\", _hardcodedInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Rejects\", _rejectedStrings, \"rejects\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Hits\", _regularInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Misses\", _regularInternMisses, \"misses\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Strings*\", _internEliminatedStrings, \"strings\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Chars\", _internEliminatedChars, \"chars\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Estimated Eliminated Bytes\", _internEliminatedChars * 2, \"bytes\"));\n+                    result.AppendLine(\"Elimination assumes that strings provided were unique objects.\");\n+                    result.AppendLine(\"|---------------------------------------------------------------------------------|\");\n+\n+                    IEnumerable<string> topMissingHardcodedString =\n+                        _missedHardcodedStrings\n+                        .OrderByDescending(kv => kv.Value * kv.Key.Length)\n+                        .Take(15)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "tiny nit:\r\n```suggestion\r\n                    if (internResult == InternResult.FoundInWeakStringCache || internResult == InternResult.AddedToWeakStringCache)\r\n```",
              "createdAt": "2020-09-17T16:23:56Z",
              "path": "src/StringTools/OpportunisticIntern.cs",
              "diffHunk": "@@ -0,0 +1,295 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Interns strings by holding weak references.\n+    /// </summary>\n+    internal sealed class OpportunisticIntern : IDisposable\n+    {\n+        /// <summary>\n+        /// The singleton instance of OpportunisticIntern.\n+        /// </summary>\n+        private static OpportunisticIntern _instance = new OpportunisticIntern();\n+        internal static OpportunisticIntern Instance => _instance;\n+\n+        /// <summary>\n+        /// The interner implementation in use.\n+        /// </summary>\n+        private WeakStringCacheInterner _interner;\n+\n+        private OpportunisticIntern()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: false);\n+        }\n+\n+        /// <summary>\n+        /// Recreates the singleton instance based on the current environment (test only).\n+        /// </summary>\n+        internal static void ResetForTests()\n+        {\n+            _instance.Dispose();\n+            _instance = new OpportunisticIntern();\n+        }\n+\n+        /// <summary>\n+        /// Turn on statistics gathering.\n+        /// </summary>\n+        internal void EnableStatisticsGathering()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: true);\n+        }\n+\n+        /// <summary>\n+        /// Intern the given internable.\n+        /// </summary>\n+        internal string InternableToString(ref InternableString candidate)\n+        {\n+            if (candidate.Length == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            string result = _interner.InterningToString(ref candidate);\n+#if DEBUG\n+            string expected = candidate.ExpensiveConvertToString();\n+            if (!String.Equals(result, expected))\n+            {\n+                throw new InvalidOperationException(String.Format(\"Interned string {0} should have been {1}\", result, expected));\n+            }\n+#endif\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Returns a string with human-readable statistics. Make sure to call <see cref=\"EnableStatisticsGathering\"/> beforehand.\n+        /// </summary>\n+        internal string FormatStatistics()\n+        {\n+            return _interner.FormatStatistics();\n+        }\n+\n+        /// <summary>\n+        /// Releases all strings from the underlying intern table.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            _interner.Dispose();\n+        }\n+\n+        /// <summary>\n+        /// Implements interning based on a WeakStringCache.\n+        /// </summary>\n+        private class WeakStringCacheInterner : IDisposable\n+        {\n+            /// <summary>\n+            /// Enumerates the possible interning results.\n+            /// </summary>\n+            private enum InternResult\n+            {\n+                MatchedHardcodedString,\n+                FoundInWeakStringCache,\n+                AddedToWeakStringCache,\n+                RejectedFromInterning\n+            }\n+\n+            /// <summary>\n+            /// The cache to keep strings in.\n+            /// </summary>\n+            private readonly WeakStringCache _weakStringCache = new WeakStringCache();\n+\n+#region Statistics\n+            /// <summary>\n+            /// Whether or not to gather statistics.\n+            /// </summary>\n+            private readonly bool _gatherStatistics;\n+\n+            /// <summary>\n+            /// Number of times interning with hardcoded string literals worked.\n+            /// </summary>\n+            private int _hardcodedInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path found the string in the cache.\n+            /// </summary>\n+            private int _regularInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path added the string to the cache.\n+            /// </summary>\n+            private int _regularInternMisses;\n+\n+            /// <summary>\n+            /// Number of times interning wasn't attempted.\n+            /// </summary>\n+            private int _rejectedStrings;\n+\n+            /// <summary>\n+            /// Total number of strings eliminated by interning.\n+            /// </summary>\n+            private int _internEliminatedStrings;\n+\n+            /// <summary>\n+            /// Total number of chars eliminated across all strings.\n+            /// </summary>\n+            private int _internEliminatedChars;\n+\n+            /// <summary>\n+            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been\n+            /// seen. The higher the number the better the payoff if the string had been hardcoded.\n+            /// </summary>\n+            private Dictionary<string, int> _missedHardcodedStrings;\n+\n+#endregion\n+\n+            public WeakStringCacheInterner(bool gatherStatistics)\n+            {\n+                if (gatherStatistics)\n+                {\n+                    _missedHardcodedStrings = new Dictionary<string, int>();\n+                }\n+                _gatherStatistics = gatherStatistics;\n+            }\n+\n+            /// <summary>\n+            /// Intern the given internable.\n+            /// </summary>\n+            public string InterningToString(ref InternableString candidate)\n+            {\n+                if (_gatherStatistics)\n+                {\n+                    return InternWithStatistics(ref candidate);\n+                }\n+                else\n+                {\n+                    TryIntern(ref candidate, out string result);\n+                    return result;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns a string with human-readable statistics.\n+            /// </summary>\n+            public string FormatStatistics()\n+            {\n+                StringBuilder result = new StringBuilder(1024);\n+\n+                string title = \"Opportunistic Intern\";\n+\n+                if (_gatherStatistics)\n+                {\n+                    result.AppendLine(string.Format(\"\\n{0}{1}{0}\", new string('=', 41 - (title.Length / 2)), title));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Hits\", _hardcodedInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Rejects\", _rejectedStrings, \"rejects\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Hits\", _regularInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Misses\", _regularInternMisses, \"misses\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Strings*\", _internEliminatedStrings, \"strings\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Chars\", _internEliminatedChars, \"chars\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Estimated Eliminated Bytes\", _internEliminatedChars * 2, \"bytes\"));\n+                    result.AppendLine(\"Elimination assumes that strings provided were unique objects.\");\n+                    result.AppendLine(\"|---------------------------------------------------------------------------------|\");\n+\n+                    IEnumerable<string> topMissingHardcodedString =\n+                        _missedHardcodedStrings\n+                        .OrderByDescending(kv => kv.Value * kv.Key.Length)\n+                        .Take(15)\n+                        .Where(kv => kv.Value > 1)\n+                        .Select(kv => string.Format(CultureInfo.InvariantCulture, \"({1} instances x each {2} chars)\\n{0}\", kv.Key, kv.Value, kv.Key.Length));\n+\n+                    result.AppendLine(string.Format(\"##########Top Missing Hardcoded Strings:  \\n{0} \", string.Join(\"\\n==============\\n\", topMissingHardcodedString.ToArray())));\n+                    result.AppendLine();\n+\n+                    WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();\n+                    result.AppendLine(\"WeakStringCache statistics:\");\n+                    result.AppendLine(string.Format(\"String count live/collected/total = {0}/{1}/{2}\", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount));\n+                }\n+                else\n+                {\n+                    result.Append(title);\n+                    result.AppendLine(\" - EnableStatisticsGathering() has not been called\");\n+                }\n+\n+                return result.ToString();\n+            }\n+\n+            /// <summary>\n+            /// Try to intern the string.\n+            /// The return value indicates the how the string was interned (if at all).\n+            /// </summary>\n+            private InternResult TryIntern(ref InternableString candidate, out string interned)\n+            {\n+                // First, try the interning callbacks.\n+                if (Strings.CallStringInterningCallbacks(ref candidate, out interned))\n+                {\n+                    // Either matched a hardcoded string or is explicitly not to be interned.\n+                    if (interned != null)\n+                    {\n+                        return InternResult.MatchedHardcodedString;\n+                    }\n+                    interned = candidate.ExpensiveConvertToString();\n+                    return InternResult.RejectedFromInterning;\n+                }\n+\n+                interned = _weakStringCache.GetOrCreateEntry(ref candidate, out bool cacheHit);\n+                return cacheHit ? InternResult.FoundInWeakStringCache : InternResult.AddedToWeakStringCache;\n+            }\n+\n+            /// <summary>\n+            /// Version of Intern that gathers statistics\n+            /// </summary>\n+            private string InternWithStatistics(ref InternableString candidate)\n+            {\n+                lock (_missedHardcodedStrings)\n+                {\n+                    InternResult internResult = TryIntern(ref candidate, out string result);\n+\n+                    switch (internResult)\n+                    {\n+                        case InternResult.MatchedHardcodedString:\n+                            _hardcodedInternHits++;\n+                            break;\n+                        case InternResult.FoundInWeakStringCache:\n+                            _regularInternHits++;\n+                            break;\n+                        case InternResult.AddedToWeakStringCache:\n+                            _regularInternMisses++;\n+                            break;\n+                        case InternResult.RejectedFromInterning:\n+                            _rejectedStrings++;\n+                            break;\n+                    }\n+\n+                    if (internResult != InternResult.MatchedHardcodedString && internResult != InternResult.RejectedFromInterning)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Done thanks!",
              "createdAt": "2020-11-30T14:03:11Z",
              "path": "src/StringTools/OpportunisticIntern.cs",
              "diffHunk": "@@ -0,0 +1,295 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Interns strings by holding weak references.\n+    /// </summary>\n+    internal sealed class OpportunisticIntern : IDisposable\n+    {\n+        /// <summary>\n+        /// The singleton instance of OpportunisticIntern.\n+        /// </summary>\n+        private static OpportunisticIntern _instance = new OpportunisticIntern();\n+        internal static OpportunisticIntern Instance => _instance;\n+\n+        /// <summary>\n+        /// The interner implementation in use.\n+        /// </summary>\n+        private WeakStringCacheInterner _interner;\n+\n+        private OpportunisticIntern()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: false);\n+        }\n+\n+        /// <summary>\n+        /// Recreates the singleton instance based on the current environment (test only).\n+        /// </summary>\n+        internal static void ResetForTests()\n+        {\n+            _instance.Dispose();\n+            _instance = new OpportunisticIntern();\n+        }\n+\n+        /// <summary>\n+        /// Turn on statistics gathering.\n+        /// </summary>\n+        internal void EnableStatisticsGathering()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: true);\n+        }\n+\n+        /// <summary>\n+        /// Intern the given internable.\n+        /// </summary>\n+        internal string InternableToString(ref InternableString candidate)\n+        {\n+            if (candidate.Length == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            string result = _interner.InterningToString(ref candidate);\n+#if DEBUG\n+            string expected = candidate.ExpensiveConvertToString();\n+            if (!String.Equals(result, expected))\n+            {\n+                throw new InvalidOperationException(String.Format(\"Interned string {0} should have been {1}\", result, expected));\n+            }\n+#endif\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Returns a string with human-readable statistics. Make sure to call <see cref=\"EnableStatisticsGathering\"/> beforehand.\n+        /// </summary>\n+        internal string FormatStatistics()\n+        {\n+            return _interner.FormatStatistics();\n+        }\n+\n+        /// <summary>\n+        /// Releases all strings from the underlying intern table.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            _interner.Dispose();\n+        }\n+\n+        /// <summary>\n+        /// Implements interning based on a WeakStringCache.\n+        /// </summary>\n+        private class WeakStringCacheInterner : IDisposable\n+        {\n+            /// <summary>\n+            /// Enumerates the possible interning results.\n+            /// </summary>\n+            private enum InternResult\n+            {\n+                MatchedHardcodedString,\n+                FoundInWeakStringCache,\n+                AddedToWeakStringCache,\n+                RejectedFromInterning\n+            }\n+\n+            /// <summary>\n+            /// The cache to keep strings in.\n+            /// </summary>\n+            private readonly WeakStringCache _weakStringCache = new WeakStringCache();\n+\n+#region Statistics\n+            /// <summary>\n+            /// Whether or not to gather statistics.\n+            /// </summary>\n+            private readonly bool _gatherStatistics;\n+\n+            /// <summary>\n+            /// Number of times interning with hardcoded string literals worked.\n+            /// </summary>\n+            private int _hardcodedInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path found the string in the cache.\n+            /// </summary>\n+            private int _regularInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path added the string to the cache.\n+            /// </summary>\n+            private int _regularInternMisses;\n+\n+            /// <summary>\n+            /// Number of times interning wasn't attempted.\n+            /// </summary>\n+            private int _rejectedStrings;\n+\n+            /// <summary>\n+            /// Total number of strings eliminated by interning.\n+            /// </summary>\n+            private int _internEliminatedStrings;\n+\n+            /// <summary>\n+            /// Total number of chars eliminated across all strings.\n+            /// </summary>\n+            private int _internEliminatedChars;\n+\n+            /// <summary>\n+            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been\n+            /// seen. The higher the number the better the payoff if the string had been hardcoded.\n+            /// </summary>\n+            private Dictionary<string, int> _missedHardcodedStrings;\n+\n+#endregion\n+\n+            public WeakStringCacheInterner(bool gatherStatistics)\n+            {\n+                if (gatherStatistics)\n+                {\n+                    _missedHardcodedStrings = new Dictionary<string, int>();\n+                }\n+                _gatherStatistics = gatherStatistics;\n+            }\n+\n+            /// <summary>\n+            /// Intern the given internable.\n+            /// </summary>\n+            public string InterningToString(ref InternableString candidate)\n+            {\n+                if (_gatherStatistics)\n+                {\n+                    return InternWithStatistics(ref candidate);\n+                }\n+                else\n+                {\n+                    TryIntern(ref candidate, out string result);\n+                    return result;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns a string with human-readable statistics.\n+            /// </summary>\n+            public string FormatStatistics()\n+            {\n+                StringBuilder result = new StringBuilder(1024);\n+\n+                string title = \"Opportunistic Intern\";\n+\n+                if (_gatherStatistics)\n+                {\n+                    result.AppendLine(string.Format(\"\\n{0}{1}{0}\", new string('=', 41 - (title.Length / 2)), title));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Hits\", _hardcodedInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Rejects\", _rejectedStrings, \"rejects\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Hits\", _regularInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Misses\", _regularInternMisses, \"misses\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Strings*\", _internEliminatedStrings, \"strings\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Chars\", _internEliminatedChars, \"chars\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Estimated Eliminated Bytes\", _internEliminatedChars * 2, \"bytes\"));\n+                    result.AppendLine(\"Elimination assumes that strings provided were unique objects.\");\n+                    result.AppendLine(\"|---------------------------------------------------------------------------------|\");\n+\n+                    IEnumerable<string> topMissingHardcodedString =\n+                        _missedHardcodedStrings\n+                        .OrderByDescending(kv => kv.Value * kv.Key.Length)\n+                        .Take(15)\n+                        .Where(kv => kv.Value > 1)\n+                        .Select(kv => string.Format(CultureInfo.InvariantCulture, \"({1} instances x each {2} chars)\\n{0}\", kv.Key, kv.Value, kv.Key.Length));\n+\n+                    result.AppendLine(string.Format(\"##########Top Missing Hardcoded Strings:  \\n{0} \", string.Join(\"\\n==============\\n\", topMissingHardcodedString.ToArray())));\n+                    result.AppendLine();\n+\n+                    WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();\n+                    result.AppendLine(\"WeakStringCache statistics:\");\n+                    result.AppendLine(string.Format(\"String count live/collected/total = {0}/{1}/{2}\", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount));\n+                }\n+                else\n+                {\n+                    result.Append(title);\n+                    result.AppendLine(\" - EnableStatisticsGathering() has not been called\");\n+                }\n+\n+                return result.ToString();\n+            }\n+\n+            /// <summary>\n+            /// Try to intern the string.\n+            /// The return value indicates the how the string was interned (if at all).\n+            /// </summary>\n+            private InternResult TryIntern(ref InternableString candidate, out string interned)\n+            {\n+                // First, try the interning callbacks.\n+                if (Strings.CallStringInterningCallbacks(ref candidate, out interned))\n+                {\n+                    // Either matched a hardcoded string or is explicitly not to be interned.\n+                    if (interned != null)\n+                    {\n+                        return InternResult.MatchedHardcodedString;\n+                    }\n+                    interned = candidate.ExpensiveConvertToString();\n+                    return InternResult.RejectedFromInterning;\n+                }\n+\n+                interned = _weakStringCache.GetOrCreateEntry(ref candidate, out bool cacheHit);\n+                return cacheHit ? InternResult.FoundInWeakStringCache : InternResult.AddedToWeakStringCache;\n+            }\n+\n+            /// <summary>\n+            /// Version of Intern that gathers statistics\n+            /// </summary>\n+            private string InternWithStatistics(ref InternableString candidate)\n+            {\n+                lock (_missedHardcodedStrings)\n+                {\n+                    InternResult internResult = TryIntern(ref candidate, out string result);\n+\n+                    switch (internResult)\n+                    {\n+                        case InternResult.MatchedHardcodedString:\n+                            _hardcodedInternHits++;\n+                            break;\n+                        case InternResult.FoundInWeakStringCache:\n+                            _regularInternHits++;\n+                            break;\n+                        case InternResult.AddedToWeakStringCache:\n+                            _regularInternMisses++;\n+                            break;\n+                        case InternResult.RejectedFromInterning:\n+                            _rejectedStrings++;\n+                            break;\n+                    }\n+\n+                    if (internResult != InternResult.MatchedHardcodedString && internResult != InternResult.RejectedFromInterning)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does the lock need to be over this whole section or just the if statement below?",
              "createdAt": "2020-09-17T16:26:53Z",
              "path": "src/StringTools/OpportunisticIntern.cs",
              "diffHunk": "@@ -0,0 +1,295 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Interns strings by holding weak references.\n+    /// </summary>\n+    internal sealed class OpportunisticIntern : IDisposable\n+    {\n+        /// <summary>\n+        /// The singleton instance of OpportunisticIntern.\n+        /// </summary>\n+        private static OpportunisticIntern _instance = new OpportunisticIntern();\n+        internal static OpportunisticIntern Instance => _instance;\n+\n+        /// <summary>\n+        /// The interner implementation in use.\n+        /// </summary>\n+        private WeakStringCacheInterner _interner;\n+\n+        private OpportunisticIntern()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: false);\n+        }\n+\n+        /// <summary>\n+        /// Recreates the singleton instance based on the current environment (test only).\n+        /// </summary>\n+        internal static void ResetForTests()\n+        {\n+            _instance.Dispose();\n+            _instance = new OpportunisticIntern();\n+        }\n+\n+        /// <summary>\n+        /// Turn on statistics gathering.\n+        /// </summary>\n+        internal void EnableStatisticsGathering()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: true);\n+        }\n+\n+        /// <summary>\n+        /// Intern the given internable.\n+        /// </summary>\n+        internal string InternableToString(ref InternableString candidate)\n+        {\n+            if (candidate.Length == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            string result = _interner.InterningToString(ref candidate);\n+#if DEBUG\n+            string expected = candidate.ExpensiveConvertToString();\n+            if (!String.Equals(result, expected))\n+            {\n+                throw new InvalidOperationException(String.Format(\"Interned string {0} should have been {1}\", result, expected));\n+            }\n+#endif\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Returns a string with human-readable statistics. Make sure to call <see cref=\"EnableStatisticsGathering\"/> beforehand.\n+        /// </summary>\n+        internal string FormatStatistics()\n+        {\n+            return _interner.FormatStatistics();\n+        }\n+\n+        /// <summary>\n+        /// Releases all strings from the underlying intern table.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            _interner.Dispose();\n+        }\n+\n+        /// <summary>\n+        /// Implements interning based on a WeakStringCache.\n+        /// </summary>\n+        private class WeakStringCacheInterner : IDisposable\n+        {\n+            /// <summary>\n+            /// Enumerates the possible interning results.\n+            /// </summary>\n+            private enum InternResult\n+            {\n+                MatchedHardcodedString,\n+                FoundInWeakStringCache,\n+                AddedToWeakStringCache,\n+                RejectedFromInterning\n+            }\n+\n+            /// <summary>\n+            /// The cache to keep strings in.\n+            /// </summary>\n+            private readonly WeakStringCache _weakStringCache = new WeakStringCache();\n+\n+#region Statistics\n+            /// <summary>\n+            /// Whether or not to gather statistics.\n+            /// </summary>\n+            private readonly bool _gatherStatistics;\n+\n+            /// <summary>\n+            /// Number of times interning with hardcoded string literals worked.\n+            /// </summary>\n+            private int _hardcodedInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path found the string in the cache.\n+            /// </summary>\n+            private int _regularInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path added the string to the cache.\n+            /// </summary>\n+            private int _regularInternMisses;\n+\n+            /// <summary>\n+            /// Number of times interning wasn't attempted.\n+            /// </summary>\n+            private int _rejectedStrings;\n+\n+            /// <summary>\n+            /// Total number of strings eliminated by interning.\n+            /// </summary>\n+            private int _internEliminatedStrings;\n+\n+            /// <summary>\n+            /// Total number of chars eliminated across all strings.\n+            /// </summary>\n+            private int _internEliminatedChars;\n+\n+            /// <summary>\n+            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been\n+            /// seen. The higher the number the better the payoff if the string had been hardcoded.\n+            /// </summary>\n+            private Dictionary<string, int> _missedHardcodedStrings;\n+\n+#endregion\n+\n+            public WeakStringCacheInterner(bool gatherStatistics)\n+            {\n+                if (gatherStatistics)\n+                {\n+                    _missedHardcodedStrings = new Dictionary<string, int>();\n+                }\n+                _gatherStatistics = gatherStatistics;\n+            }\n+\n+            /// <summary>\n+            /// Intern the given internable.\n+            /// </summary>\n+            public string InterningToString(ref InternableString candidate)\n+            {\n+                if (_gatherStatistics)\n+                {\n+                    return InternWithStatistics(ref candidate);\n+                }\n+                else\n+                {\n+                    TryIntern(ref candidate, out string result);\n+                    return result;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns a string with human-readable statistics.\n+            /// </summary>\n+            public string FormatStatistics()\n+            {\n+                StringBuilder result = new StringBuilder(1024);\n+\n+                string title = \"Opportunistic Intern\";\n+\n+                if (_gatherStatistics)\n+                {\n+                    result.AppendLine(string.Format(\"\\n{0}{1}{0}\", new string('=', 41 - (title.Length / 2)), title));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Hits\", _hardcodedInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Rejects\", _rejectedStrings, \"rejects\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Hits\", _regularInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Misses\", _regularInternMisses, \"misses\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Strings*\", _internEliminatedStrings, \"strings\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Chars\", _internEliminatedChars, \"chars\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Estimated Eliminated Bytes\", _internEliminatedChars * 2, \"bytes\"));\n+                    result.AppendLine(\"Elimination assumes that strings provided were unique objects.\");\n+                    result.AppendLine(\"|---------------------------------------------------------------------------------|\");\n+\n+                    IEnumerable<string> topMissingHardcodedString =\n+                        _missedHardcodedStrings\n+                        .OrderByDescending(kv => kv.Value * kv.Key.Length)\n+                        .Take(15)\n+                        .Where(kv => kv.Value > 1)\n+                        .Select(kv => string.Format(CultureInfo.InvariantCulture, \"({1} instances x each {2} chars)\\n{0}\", kv.Key, kv.Value, kv.Key.Length));\n+\n+                    result.AppendLine(string.Format(\"##########Top Missing Hardcoded Strings:  \\n{0} \", string.Join(\"\\n==============\\n\", topMissingHardcodedString.ToArray())));\n+                    result.AppendLine();\n+\n+                    WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();\n+                    result.AppendLine(\"WeakStringCache statistics:\");\n+                    result.AppendLine(string.Format(\"String count live/collected/total = {0}/{1}/{2}\", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount));\n+                }\n+                else\n+                {\n+                    result.Append(title);\n+                    result.AppendLine(\" - EnableStatisticsGathering() has not been called\");\n+                }\n+\n+                return result.ToString();\n+            }\n+\n+            /// <summary>\n+            /// Try to intern the string.\n+            /// The return value indicates the how the string was interned (if at all).\n+            /// </summary>\n+            private InternResult TryIntern(ref InternableString candidate, out string interned)\n+            {\n+                // First, try the interning callbacks.\n+                if (Strings.CallStringInterningCallbacks(ref candidate, out interned))\n+                {\n+                    // Either matched a hardcoded string or is explicitly not to be interned.\n+                    if (interned != null)\n+                    {\n+                        return InternResult.MatchedHardcodedString;\n+                    }\n+                    interned = candidate.ExpensiveConvertToString();\n+                    return InternResult.RejectedFromInterning;\n+                }\n+\n+                interned = _weakStringCache.GetOrCreateEntry(ref candidate, out bool cacheHit);\n+                return cacheHit ? InternResult.FoundInWeakStringCache : InternResult.AddedToWeakStringCache;\n+            }\n+\n+            /// <summary>\n+            /// Version of Intern that gathers statistics\n+            /// </summary>\n+            private string InternWithStatistics(ref InternableString candidate)\n+            {\n+                lock (_missedHardcodedStrings)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This code has moved but I believe that your question still applies. In the current version of the code the lock protects several fields: `_regularInternHits`, `_regularInternMisses`, `_internCallCountsByString`, `_internEliminatedStrings`, `_internEliminatedChars`. Integer fields could be accessed lock-free with interlocked operations but given that we're also mutating a dictionary, it's easier to put everything under one lock. The code is used only for gathering statistics for debugging so it's not super perf sensitive.",
              "createdAt": "2020-12-15T12:01:35Z",
              "path": "src/StringTools/OpportunisticIntern.cs",
              "diffHunk": "@@ -0,0 +1,295 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using System.Linq;\n+using System.Text;\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// Interns strings by holding weak references.\n+    /// </summary>\n+    internal sealed class OpportunisticIntern : IDisposable\n+    {\n+        /// <summary>\n+        /// The singleton instance of OpportunisticIntern.\n+        /// </summary>\n+        private static OpportunisticIntern _instance = new OpportunisticIntern();\n+        internal static OpportunisticIntern Instance => _instance;\n+\n+        /// <summary>\n+        /// The interner implementation in use.\n+        /// </summary>\n+        private WeakStringCacheInterner _interner;\n+\n+        private OpportunisticIntern()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: false);\n+        }\n+\n+        /// <summary>\n+        /// Recreates the singleton instance based on the current environment (test only).\n+        /// </summary>\n+        internal static void ResetForTests()\n+        {\n+            _instance.Dispose();\n+            _instance = new OpportunisticIntern();\n+        }\n+\n+        /// <summary>\n+        /// Turn on statistics gathering.\n+        /// </summary>\n+        internal void EnableStatisticsGathering()\n+        {\n+            _interner = new WeakStringCacheInterner(gatherStatistics: true);\n+        }\n+\n+        /// <summary>\n+        /// Intern the given internable.\n+        /// </summary>\n+        internal string InternableToString(ref InternableString candidate)\n+        {\n+            if (candidate.Length == 0)\n+            {\n+                return string.Empty;\n+            }\n+\n+            string result = _interner.InterningToString(ref candidate);\n+#if DEBUG\n+            string expected = candidate.ExpensiveConvertToString();\n+            if (!String.Equals(result, expected))\n+            {\n+                throw new InvalidOperationException(String.Format(\"Interned string {0} should have been {1}\", result, expected));\n+            }\n+#endif\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Returns a string with human-readable statistics. Make sure to call <see cref=\"EnableStatisticsGathering\"/> beforehand.\n+        /// </summary>\n+        internal string FormatStatistics()\n+        {\n+            return _interner.FormatStatistics();\n+        }\n+\n+        /// <summary>\n+        /// Releases all strings from the underlying intern table.\n+        /// </summary>\n+        public void Dispose()\n+        {\n+            _interner.Dispose();\n+        }\n+\n+        /// <summary>\n+        /// Implements interning based on a WeakStringCache.\n+        /// </summary>\n+        private class WeakStringCacheInterner : IDisposable\n+        {\n+            /// <summary>\n+            /// Enumerates the possible interning results.\n+            /// </summary>\n+            private enum InternResult\n+            {\n+                MatchedHardcodedString,\n+                FoundInWeakStringCache,\n+                AddedToWeakStringCache,\n+                RejectedFromInterning\n+            }\n+\n+            /// <summary>\n+            /// The cache to keep strings in.\n+            /// </summary>\n+            private readonly WeakStringCache _weakStringCache = new WeakStringCache();\n+\n+#region Statistics\n+            /// <summary>\n+            /// Whether or not to gather statistics.\n+            /// </summary>\n+            private readonly bool _gatherStatistics;\n+\n+            /// <summary>\n+            /// Number of times interning with hardcoded string literals worked.\n+            /// </summary>\n+            private int _hardcodedInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path found the string in the cache.\n+            /// </summary>\n+            private int _regularInternHits;\n+\n+            /// <summary>\n+            /// Number of times the regular interning path added the string to the cache.\n+            /// </summary>\n+            private int _regularInternMisses;\n+\n+            /// <summary>\n+            /// Number of times interning wasn't attempted.\n+            /// </summary>\n+            private int _rejectedStrings;\n+\n+            /// <summary>\n+            /// Total number of strings eliminated by interning.\n+            /// </summary>\n+            private int _internEliminatedStrings;\n+\n+            /// <summary>\n+            /// Total number of chars eliminated across all strings.\n+            /// </summary>\n+            private int _internEliminatedChars;\n+\n+            /// <summary>\n+            /// Maps strings that went though the regular (i.e. not hardcoded) interning path to the number of times they have been\n+            /// seen. The higher the number the better the payoff if the string had been hardcoded.\n+            /// </summary>\n+            private Dictionary<string, int> _missedHardcodedStrings;\n+\n+#endregion\n+\n+            public WeakStringCacheInterner(bool gatherStatistics)\n+            {\n+                if (gatherStatistics)\n+                {\n+                    _missedHardcodedStrings = new Dictionary<string, int>();\n+                }\n+                _gatherStatistics = gatherStatistics;\n+            }\n+\n+            /// <summary>\n+            /// Intern the given internable.\n+            /// </summary>\n+            public string InterningToString(ref InternableString candidate)\n+            {\n+                if (_gatherStatistics)\n+                {\n+                    return InternWithStatistics(ref candidate);\n+                }\n+                else\n+                {\n+                    TryIntern(ref candidate, out string result);\n+                    return result;\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Returns a string with human-readable statistics.\n+            /// </summary>\n+            public string FormatStatistics()\n+            {\n+                StringBuilder result = new StringBuilder(1024);\n+\n+                string title = \"Opportunistic Intern\";\n+\n+                if (_gatherStatistics)\n+                {\n+                    result.AppendLine(string.Format(\"\\n{0}{1}{0}\", new string('=', 41 - (title.Length / 2)), title));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Hits\", _hardcodedInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Hardcoded Rejects\", _rejectedStrings, \"rejects\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Hits\", _regularInternHits, \"hits\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"WeakStringCache Misses\", _regularInternMisses, \"misses\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Strings*\", _internEliminatedStrings, \"strings\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Eliminated Chars\", _internEliminatedChars, \"chars\"));\n+                    result.AppendLine(string.Format(\"||{0,50}|{1,20:N0}|{2,8}|\", \"Estimated Eliminated Bytes\", _internEliminatedChars * 2, \"bytes\"));\n+                    result.AppendLine(\"Elimination assumes that strings provided were unique objects.\");\n+                    result.AppendLine(\"|---------------------------------------------------------------------------------|\");\n+\n+                    IEnumerable<string> topMissingHardcodedString =\n+                        _missedHardcodedStrings\n+                        .OrderByDescending(kv => kv.Value * kv.Key.Length)\n+                        .Take(15)\n+                        .Where(kv => kv.Value > 1)\n+                        .Select(kv => string.Format(CultureInfo.InvariantCulture, \"({1} instances x each {2} chars)\\n{0}\", kv.Key, kv.Value, kv.Key.Length));\n+\n+                    result.AppendLine(string.Format(\"##########Top Missing Hardcoded Strings:  \\n{0} \", string.Join(\"\\n==============\\n\", topMissingHardcodedString.ToArray())));\n+                    result.AppendLine();\n+\n+                    WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();\n+                    result.AppendLine(\"WeakStringCache statistics:\");\n+                    result.AppendLine(string.Format(\"String count live/collected/total = {0}/{1}/{2}\", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount));\n+                }\n+                else\n+                {\n+                    result.Append(title);\n+                    result.AppendLine(\" - EnableStatisticsGathering() has not been called\");\n+                }\n+\n+                return result.ToString();\n+            }\n+\n+            /// <summary>\n+            /// Try to intern the string.\n+            /// The return value indicates the how the string was interned (if at all).\n+            /// </summary>\n+            private InternResult TryIntern(ref InternableString candidate, out string interned)\n+            {\n+                // First, try the interning callbacks.\n+                if (Strings.CallStringInterningCallbacks(ref candidate, out interned))\n+                {\n+                    // Either matched a hardcoded string or is explicitly not to be interned.\n+                    if (interned != null)\n+                    {\n+                        return InternResult.MatchedHardcodedString;\n+                    }\n+                    interned = candidate.ExpensiveConvertToString();\n+                    return InternResult.RejectedFromInterning;\n+                }\n+\n+                interned = _weakStringCache.GetOrCreateEntry(ref candidate, out bool cacheHit);\n+                return cacheHit ? InternResult.FoundInWeakStringCache : InternResult.AddedToWeakStringCache;\n+            }\n+\n+            /// <summary>\n+            /// Version of Intern that gathers statistics\n+            /// </summary>\n+            private string InternWithStatistics(ref InternableString candidate)\n+            {\n+                lock (_missedHardcodedStrings)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why this check?",
              "createdAt": "2020-09-17T16:30:20Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class Strings\n+\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_stringBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<SpanBasedStringBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new SpanBasedStringBuilder with the default capacity.\n+            /// </summary>\n+            public SpanBasedStringBuilder Create()\n+            {\n+                return new SpanBasedStringBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(SpanBasedStringBuilder stringBuilder)\n+            {\n+                if (stringBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The idea was to not return the builder to the pool if it was excessively large. The idea is that if the object is unlikely to be needed again, it is better to throw it away than to keep it forever. I have removed this check, thanks!",
              "createdAt": "2020-12-16T09:17:42Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class Strings\n+\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_stringBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<SpanBasedStringBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new SpanBasedStringBuilder with the default capacity.\n+            /// </summary>\n+            public SpanBasedStringBuilder Create()\n+            {\n+                return new SpanBasedStringBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(SpanBasedStringBuilder stringBuilder)\n+            {\n+                if (stringBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would you mind explaining every part of this?\r\n\r\nAlso, nit:\r\n```suggestion\r\n        private static volatile TryInternStringDelegate[] s_internStringCallbacks = Array.Empty<TryInterStringDelegate>();\r\n```",
              "createdAt": "2020-09-17T16:33:17Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class Strings\n+\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_stringBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<SpanBasedStringBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new SpanBasedStringBuilder with the default capacity.\n+            /// </summary>\n+            public SpanBasedStringBuilder Create()\n+            {\n+                return new SpanBasedStringBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(SpanBasedStringBuilder stringBuilder)\n+            {\n+                if (stringBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    stringBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of SpanBasedStringBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<SpanBasedStringBuilder> s_stringBuilderPool =\n+            new DefaultObjectPool<SpanBasedStringBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);\n+#endif\n+\n+        /// <summary>\n+        /// An array of callbacks to be called for each string being interned.\n+        /// </summary>\n+        private static volatile TryInternStringDelegate[] s_internStringCallbacks = new TryInternStringDelegate[0];",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Actually, should this be an array? I didn't see anywhere that you used it without looking at every element, and you sometimes add to the end. Maybe a LinkedList? Arrays have less overhead, but a LinkedList might be faster...",
              "createdAt": "2020-09-17T16:46:51Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class Strings\n+\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_stringBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<SpanBasedStringBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new SpanBasedStringBuilder with the default capacity.\n+            /// </summary>\n+            public SpanBasedStringBuilder Create()\n+            {\n+                return new SpanBasedStringBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(SpanBasedStringBuilder stringBuilder)\n+            {\n+                if (stringBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    stringBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of SpanBasedStringBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<SpanBasedStringBuilder> s_stringBuilderPool =\n+            new DefaultObjectPool<SpanBasedStringBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);\n+#endif\n+\n+        /// <summary>\n+        /// An array of callbacks to be called for each string being interned.\n+        /// </summary>\n+        private static volatile TryInternStringDelegate[] s_internStringCallbacks = new TryInternStringDelegate[0];",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I wanted a data structure that can be read in a lock-free fashion. Since writes are expected to be super rare, I went with the simplest type - an immutable array. Readers get a reference to the array and read it lock-free because no writer is modifying the array once published into the static. Only writers have to synchronize between them so they don't step on each other toes. Done with a lock here, could be a loop with an interlocked exchange as well. Also note the `volatile` modifier which ensures that the contents of the array is visible to other threads when a writer does `s_internStringCallbacks =`.\r\n\r\nBut maybe all this is moot if, as Dan suggested, we don't need this callback mechanism at all. I am going to measure this shortly.",
              "createdAt": "2020-11-30T14:40:15Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class Strings\n+\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_stringBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<SpanBasedStringBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new SpanBasedStringBuilder with the default capacity.\n+            /// </summary>\n+            public SpanBasedStringBuilder Create()\n+            {\n+                return new SpanBasedStringBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(SpanBasedStringBuilder stringBuilder)\n+            {\n+                if (stringBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    stringBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of SpanBasedStringBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<SpanBasedStringBuilder> s_stringBuilderPool =\n+            new DefaultObjectPool<SpanBasedStringBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);\n+#endif\n+\n+        /// <summary>\n+        /// An array of callbacks to be called for each string being interned.\n+        /// </summary>\n+        private static volatile TryInternStringDelegate[] s_internStringCallbacks = new TryInternStringDelegate[0];",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Environment.ProcessorCount is the often-unreliable processor count, right?",
              "createdAt": "2020-09-17T16:35:18Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class Strings\n+\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_stringBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<SpanBasedStringBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new SpanBasedStringBuilder with the default capacity.\n+            /// </summary>\n+            public SpanBasedStringBuilder Create()\n+            {\n+                return new SpanBasedStringBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(SpanBasedStringBuilder stringBuilder)\n+            {\n+                if (stringBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    stringBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of SpanBasedStringBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<SpanBasedStringBuilder> s_stringBuilderPool =\n+            new DefaultObjectPool<SpanBasedStringBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I have ultimately decided against using `ObjectPool` in the first version of the library. The builders are now pooled in a `[ThreadStatic]` field, so one per thread which is makes them fast to get and return, and perfectly fine for MSBuild (suspecting ought to be enough for everybody).\r\n\r\n`Environment.ProcessorCount` was meant to be a heuristic on the number of concurrent users but it makes potentially incorrect assumptions.",
              "createdAt": "2020-12-16T09:15:27Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class Strings\n+\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_stringBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<SpanBasedStringBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new SpanBasedStringBuilder with the default capacity.\n+            /// </summary>\n+            public SpanBasedStringBuilder Create()\n+            {\n+                return new SpanBasedStringBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(SpanBasedStringBuilder stringBuilder)\n+            {\n+                if (stringBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    stringBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of SpanBasedStringBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<SpanBasedStringBuilder> s_stringBuilderPool =\n+            new DefaultObjectPool<SpanBasedStringBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "tiny nit:\r\n```suggestion\r\n            s_internStringCallbacks = Array.Empty<TryInternStringDelegate>();\r\n```",
              "createdAt": "2020-09-17T16:47:19Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class Strings\n+\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_stringBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<SpanBasedStringBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new SpanBasedStringBuilder with the default capacity.\n+            /// </summary>\n+            public SpanBasedStringBuilder Create()\n+            {\n+                return new SpanBasedStringBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(SpanBasedStringBuilder stringBuilder)\n+            {\n+                if (stringBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    stringBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of SpanBasedStringBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<SpanBasedStringBuilder> s_stringBuilderPool =\n+            new DefaultObjectPool<SpanBasedStringBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);\n+#endif\n+\n+        /// <summary>\n+        /// An array of callbacks to be called for each string being interned.\n+        /// </summary>\n+        private static volatile TryInternStringDelegate[] s_internStringCallbacks = new TryInternStringDelegate[0];\n+\n+        /// <summary>\n+        /// A lock protecting writes to <see cref=\"s_internStringCallbacks\"/>.\n+        /// </summary>\n+        private static object s_locker = new object();\n+\n+\n+        #region Public methods\n+\n+        /// <summary>\n+        /// Interns the given string if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The string to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(string str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+\n+#if !NET35\n+        /// <summary>\n+        /// Interns the given readonly character span if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The character span to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(ReadOnlySpan<char> str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+#endif\n+\n+        /// <summary>\n+        /// Returns a new or recycled <see cref=\"SpanBasedStringBuilder\"/>.\n+        /// </summary>\n+        /// <returns>The SpanBasedStringBuilder.</returns>\n+        /// <remarks>\n+        /// Call <see cref=\"IDisposable.Dispose\"/> on the returned instance to recycle it.\n+        /// </remarks>\n+        public static SpanBasedStringBuilder GetSpanBasedStringBuilder()\n+        {\n+#if NET35\n+            return new SpanBasedStringBuilder();\n+#else\n+            return s_stringBuilderPool.Get();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Adds a callback to be called when a string is being interned.\n+        /// </summary>\n+        /// <param name=\"callback\">The callback to add.</param>\n+        /// <remarks>\n+        /// Use this to implement custom interning for some strings. The callback has access to the string being interned\n+        /// via the <see cref=\"InternableString\"/> representation and can override the default behavior by returning a custom\n+        /// string.\n+        /// </remarks>\n+        public static void RegisterStringInterningCallback(TryInternStringDelegate callback)\n+        {\n+            lock (s_locker)\n+            {\n+                if (!s_internStringCallbacks.Any(existingCallback => existingCallback == callback))\n+                {\n+                    TryInternStringDelegate[] newInternStringCallback = new TryInternStringDelegate[s_internStringCallbacks.Length + 1];\n+                    s_internStringCallbacks.CopyTo(newInternStringCallback, 0);\n+                    newInternStringCallback[s_internStringCallbacks.Length] = callback;\n+\n+                    s_internStringCallbacks = newInternStringCallback;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Removes a callback previously added with <see cref=\"RegisterStringInterningCallback\"/>.\n+        /// </summary>\n+        /// <param name=\"callback\">The callback to remove.</param>\n+        public static void UnregisterStringInterningCallback(TryInternStringDelegate callback)\n+        {\n+            lock (s_locker)\n+            {\n+                s_internStringCallbacks = s_internStringCallbacks.Where(existingCallback => existingCallback != callback).ToArray();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Enables diagnostics in the interner. Call <see cref=\"CreateDiagnosticReport\"/> to retrieve the diagnostic data.\n+        /// </summary>\n+        public static void EnableDiagnostics()\n+        {\n+            OpportunisticIntern.Instance.EnableStatisticsGathering();\n+        }\n+\n+        /// <summary>\n+        /// Retrieves the diagnostic data describing the current state of the interner. Make sure to call <see cref=\"EnableDiagnostics\"/> beforehand.\n+        /// </summary>\n+        public static string CreateDiagnosticReport()\n+        {\n+            StringBuilder callbackReport = new StringBuilder();\n+            callbackReport.AppendFormat(\"{0} with {1} string interning callbacks registered\", nameof(Strings), s_internStringCallbacks.Length);\n+            callbackReport.AppendLine();\n+\n+            return callbackReport.ToString() + OpportunisticIntern.Instance.FormatStatistics();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Returns a <see cref=\"SpanBasedStringBuilder\"/> instance back to the pool if possible.\n+        /// </summary>\n+        /// <param name=\"stringBuilder\">The instance to return.</param>\n+        internal static void ReturnSpanBasedStringBuilder(SpanBasedStringBuilder stringBuilder)\n+        {\n+            if (stringBuilder == null)\n+            {\n+                throw new ArgumentNullException(nameof(stringBuilder));\n+            }\n+#if !NET35\n+            s_stringBuilderPool.Return(stringBuilder);\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Calls interning callbacks in sequence until one return true.\n+        /// </summary>\n+        /// <param name=\"candidate\">The candidate internable string to invoke the callbacks with.</param>\n+        /// <param name=\"interned\">The resulting string.</param>\n+        /// <returns></returns>\n+        internal static bool CallStringInterningCallbacks(ref InternableString candidate, out string interned)\n+        {\n+            // We can read s_internStringCallbacks lock-less because it's declared volatile and RegisterStringInterningCallback\n+            // and UnregisterStringInterningCallback write the field after initializing its content.\n+            TryInternStringDelegate[] callbacks = s_internStringCallbacks;\n+            foreach (TryInternStringDelegate callback in callbacks)\n+            {\n+                if (callback(ref candidate, out interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            interned = null;\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Resets the registered callbacks for testing purposes.\n+        /// </summary>\n+        internal static void ResetForTests()\n+        {\n+            s_internStringCallbacks = new TryInternStringDelegate[0];",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Can't do this because the code has to compile against .NET Framework 3.5 where `Array.Empty<>` does not exist yet.",
              "createdAt": "2020-11-30T14:05:22Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class Strings\n+\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_stringBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<SpanBasedStringBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new SpanBasedStringBuilder with the default capacity.\n+            /// </summary>\n+            public SpanBasedStringBuilder Create()\n+            {\n+                return new SpanBasedStringBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(SpanBasedStringBuilder stringBuilder)\n+            {\n+                if (stringBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    stringBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of SpanBasedStringBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<SpanBasedStringBuilder> s_stringBuilderPool =\n+            new DefaultObjectPool<SpanBasedStringBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);\n+#endif\n+\n+        /// <summary>\n+        /// An array of callbacks to be called for each string being interned.\n+        /// </summary>\n+        private static volatile TryInternStringDelegate[] s_internStringCallbacks = new TryInternStringDelegate[0];\n+\n+        /// <summary>\n+        /// A lock protecting writes to <see cref=\"s_internStringCallbacks\"/>.\n+        /// </summary>\n+        private static object s_locker = new object();\n+\n+\n+        #region Public methods\n+\n+        /// <summary>\n+        /// Interns the given string if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The string to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(string str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+\n+#if !NET35\n+        /// <summary>\n+        /// Interns the given readonly character span if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The character span to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(ReadOnlySpan<char> str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+#endif\n+\n+        /// <summary>\n+        /// Returns a new or recycled <see cref=\"SpanBasedStringBuilder\"/>.\n+        /// </summary>\n+        /// <returns>The SpanBasedStringBuilder.</returns>\n+        /// <remarks>\n+        /// Call <see cref=\"IDisposable.Dispose\"/> on the returned instance to recycle it.\n+        /// </remarks>\n+        public static SpanBasedStringBuilder GetSpanBasedStringBuilder()\n+        {\n+#if NET35\n+            return new SpanBasedStringBuilder();\n+#else\n+            return s_stringBuilderPool.Get();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Adds a callback to be called when a string is being interned.\n+        /// </summary>\n+        /// <param name=\"callback\">The callback to add.</param>\n+        /// <remarks>\n+        /// Use this to implement custom interning for some strings. The callback has access to the string being interned\n+        /// via the <see cref=\"InternableString\"/> representation and can override the default behavior by returning a custom\n+        /// string.\n+        /// </remarks>\n+        public static void RegisterStringInterningCallback(TryInternStringDelegate callback)\n+        {\n+            lock (s_locker)\n+            {\n+                if (!s_internStringCallbacks.Any(existingCallback => existingCallback == callback))\n+                {\n+                    TryInternStringDelegate[] newInternStringCallback = new TryInternStringDelegate[s_internStringCallbacks.Length + 1];\n+                    s_internStringCallbacks.CopyTo(newInternStringCallback, 0);\n+                    newInternStringCallback[s_internStringCallbacks.Length] = callback;\n+\n+                    s_internStringCallbacks = newInternStringCallback;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Removes a callback previously added with <see cref=\"RegisterStringInterningCallback\"/>.\n+        /// </summary>\n+        /// <param name=\"callback\">The callback to remove.</param>\n+        public static void UnregisterStringInterningCallback(TryInternStringDelegate callback)\n+        {\n+            lock (s_locker)\n+            {\n+                s_internStringCallbacks = s_internStringCallbacks.Where(existingCallback => existingCallback != callback).ToArray();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Enables diagnostics in the interner. Call <see cref=\"CreateDiagnosticReport\"/> to retrieve the diagnostic data.\n+        /// </summary>\n+        public static void EnableDiagnostics()\n+        {\n+            OpportunisticIntern.Instance.EnableStatisticsGathering();\n+        }\n+\n+        /// <summary>\n+        /// Retrieves the diagnostic data describing the current state of the interner. Make sure to call <see cref=\"EnableDiagnostics\"/> beforehand.\n+        /// </summary>\n+        public static string CreateDiagnosticReport()\n+        {\n+            StringBuilder callbackReport = new StringBuilder();\n+            callbackReport.AppendFormat(\"{0} with {1} string interning callbacks registered\", nameof(Strings), s_internStringCallbacks.Length);\n+            callbackReport.AppendLine();\n+\n+            return callbackReport.ToString() + OpportunisticIntern.Instance.FormatStatistics();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Returns a <see cref=\"SpanBasedStringBuilder\"/> instance back to the pool if possible.\n+        /// </summary>\n+        /// <param name=\"stringBuilder\">The instance to return.</param>\n+        internal static void ReturnSpanBasedStringBuilder(SpanBasedStringBuilder stringBuilder)\n+        {\n+            if (stringBuilder == null)\n+            {\n+                throw new ArgumentNullException(nameof(stringBuilder));\n+            }\n+#if !NET35\n+            s_stringBuilderPool.Return(stringBuilder);\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Calls interning callbacks in sequence until one return true.\n+        /// </summary>\n+        /// <param name=\"candidate\">The candidate internable string to invoke the callbacks with.</param>\n+        /// <param name=\"interned\">The resulting string.</param>\n+        /// <returns></returns>\n+        internal static bool CallStringInterningCallbacks(ref InternableString candidate, out string interned)\n+        {\n+            // We can read s_internStringCallbacks lock-less because it's declared volatile and RegisterStringInterningCallback\n+            // and UnregisterStringInterningCallback write the field after initializing its content.\n+            TryInternStringDelegate[] callbacks = s_internStringCallbacks;\n+            foreach (TryInternStringDelegate callback in callbacks)\n+            {\n+                if (callback(ref candidate, out interned))\n+                {\n+                    return true;\n+                }\n+            }\n+            interned = null;\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Resets the registered callbacks for testing purposes.\n+        /// </summary>\n+        internal static void ResetForTests()\n+        {\n+            s_internStringCallbacks = new TryInternStringDelegate[0];",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            return callbacks.Any(callback => TryInternStringDelegate(callback, out interned));\r\n```\r\n? Might change the value of interned, so you'd have to account for that when using it. (You already do, for now.)",
              "createdAt": "2020-09-17T16:50:39Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class Strings\n+\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_stringBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<SpanBasedStringBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new SpanBasedStringBuilder with the default capacity.\n+            /// </summary>\n+            public SpanBasedStringBuilder Create()\n+            {\n+                return new SpanBasedStringBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(SpanBasedStringBuilder stringBuilder)\n+            {\n+                if (stringBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    stringBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of SpanBasedStringBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<SpanBasedStringBuilder> s_stringBuilderPool =\n+            new DefaultObjectPool<SpanBasedStringBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);\n+#endif\n+\n+        /// <summary>\n+        /// An array of callbacks to be called for each string being interned.\n+        /// </summary>\n+        private static volatile TryInternStringDelegate[] s_internStringCallbacks = new TryInternStringDelegate[0];\n+\n+        /// <summary>\n+        /// A lock protecting writes to <see cref=\"s_internStringCallbacks\"/>.\n+        /// </summary>\n+        private static object s_locker = new object();\n+\n+\n+        #region Public methods\n+\n+        /// <summary>\n+        /// Interns the given string if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The string to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(string str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+\n+#if !NET35\n+        /// <summary>\n+        /// Interns the given readonly character span if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The character span to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(ReadOnlySpan<char> str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+#endif\n+\n+        /// <summary>\n+        /// Returns a new or recycled <see cref=\"SpanBasedStringBuilder\"/>.\n+        /// </summary>\n+        /// <returns>The SpanBasedStringBuilder.</returns>\n+        /// <remarks>\n+        /// Call <see cref=\"IDisposable.Dispose\"/> on the returned instance to recycle it.\n+        /// </remarks>\n+        public static SpanBasedStringBuilder GetSpanBasedStringBuilder()\n+        {\n+#if NET35\n+            return new SpanBasedStringBuilder();\n+#else\n+            return s_stringBuilderPool.Get();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Adds a callback to be called when a string is being interned.\n+        /// </summary>\n+        /// <param name=\"callback\">The callback to add.</param>\n+        /// <remarks>\n+        /// Use this to implement custom interning for some strings. The callback has access to the string being interned\n+        /// via the <see cref=\"InternableString\"/> representation and can override the default behavior by returning a custom\n+        /// string.\n+        /// </remarks>\n+        public static void RegisterStringInterningCallback(TryInternStringDelegate callback)\n+        {\n+            lock (s_locker)\n+            {\n+                if (!s_internStringCallbacks.Any(existingCallback => existingCallback == callback))\n+                {\n+                    TryInternStringDelegate[] newInternStringCallback = new TryInternStringDelegate[s_internStringCallbacks.Length + 1];\n+                    s_internStringCallbacks.CopyTo(newInternStringCallback, 0);\n+                    newInternStringCallback[s_internStringCallbacks.Length] = callback;\n+\n+                    s_internStringCallbacks = newInternStringCallback;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Removes a callback previously added with <see cref=\"RegisterStringInterningCallback\"/>.\n+        /// </summary>\n+        /// <param name=\"callback\">The callback to remove.</param>\n+        public static void UnregisterStringInterningCallback(TryInternStringDelegate callback)\n+        {\n+            lock (s_locker)\n+            {\n+                s_internStringCallbacks = s_internStringCallbacks.Where(existingCallback => existingCallback != callback).ToArray();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Enables diagnostics in the interner. Call <see cref=\"CreateDiagnosticReport\"/> to retrieve the diagnostic data.\n+        /// </summary>\n+        public static void EnableDiagnostics()\n+        {\n+            OpportunisticIntern.Instance.EnableStatisticsGathering();\n+        }\n+\n+        /// <summary>\n+        /// Retrieves the diagnostic data describing the current state of the interner. Make sure to call <see cref=\"EnableDiagnostics\"/> beforehand.\n+        /// </summary>\n+        public static string CreateDiagnosticReport()\n+        {\n+            StringBuilder callbackReport = new StringBuilder();\n+            callbackReport.AppendFormat(\"{0} with {1} string interning callbacks registered\", nameof(Strings), s_internStringCallbacks.Length);\n+            callbackReport.AppendLine();\n+\n+            return callbackReport.ToString() + OpportunisticIntern.Instance.FormatStatistics();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Returns a <see cref=\"SpanBasedStringBuilder\"/> instance back to the pool if possible.\n+        /// </summary>\n+        /// <param name=\"stringBuilder\">The instance to return.</param>\n+        internal static void ReturnSpanBasedStringBuilder(SpanBasedStringBuilder stringBuilder)\n+        {\n+            if (stringBuilder == null)\n+            {\n+                throw new ArgumentNullException(nameof(stringBuilder));\n+            }\n+#if !NET35\n+            s_stringBuilderPool.Return(stringBuilder);\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Calls interning callbacks in sequence until one return true.\n+        /// </summary>\n+        /// <param name=\"candidate\">The candidate internable string to invoke the callbacks with.</param>\n+        /// <param name=\"interned\">The resulting string.</param>\n+        /// <returns></returns>\n+        internal static bool CallStringInterningCallbacks(ref InternableString candidate, out string interned)\n+        {\n+            // We can read s_internStringCallbacks lock-less because it's declared volatile and RegisterStringInterningCallback\n+            // and UnregisterStringInterningCallback write the field after initializing its content.\n+            TryInternStringDelegate[] callbacks = s_internStringCallbacks;\n+            foreach (TryInternStringDelegate callback in callbacks)\n+            {\n+                if (callback(ref candidate, out interned))\n+                {\n+                    return true;\n+                }\n+            }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This code is gone, no more hardcoded strings.",
              "createdAt": "2020-12-15T10:40:40Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+#if !NET35\n+using Microsoft.Extensions.ObjectPool;\n+#endif\n+\n+namespace Microsoft.StringTools\n+{\n+    /// <summary>\n+    /// A callback type to register with the library. The library will invoke this callback in registration order until\n+    /// true is returned. If no callback returns true, the library will fall back to its default interning logic.\n+    /// </summary>\n+    /// <param name=\"internableString\">The string to be interned.</param>\n+    /// <param name=\"result\">The interned string. Set to null and return true if the string should not be interned.</param>\n+    /// <returns>True if the <paramref name=\"internableString\" /> was handled by the callback.</returns>\n+    public delegate bool TryInternStringDelegate(ref InternableString internableString, out string result);\n+\n+    public static class Strings\n+\n+    {\n+#if !NET35\n+        /// <summary>\n+        /// IPooledObjectPolicy used by <cref see=\"s_stringBuilderPool\"/>.\n+        /// </summary>\n+        private class PooledObjectPolicy : IPooledObjectPolicy<SpanBasedStringBuilder>\n+        {\n+            /// <summary>\n+            /// No need to retain excessively long builders forever.\n+            /// </summary>\n+            private const int MAX_RETAINED_BUILDER_CAPACITY = 1000;\n+\n+            /// <summary>\n+            /// Creates a new SpanBasedStringBuilder with the default capacity.\n+            /// </summary>\n+            public SpanBasedStringBuilder Create()\n+            {\n+                return new SpanBasedStringBuilder();\n+            }\n+\n+            /// <summary>\n+            /// Returns a builder to the pool unless it's excessively long.\n+            /// </summary>\n+            public bool Return(SpanBasedStringBuilder stringBuilder)\n+            {\n+                if (stringBuilder.Capacity <= MAX_RETAINED_BUILDER_CAPACITY)\n+                {\n+                    stringBuilder.Clear();\n+                    return true;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// A pool of SpanBasedStringBuilders as we don't want to be allocating every time a new one is requested.\n+        /// </summary>\n+        private static DefaultObjectPool<SpanBasedStringBuilder> s_stringBuilderPool =\n+            new DefaultObjectPool<SpanBasedStringBuilder>(new PooledObjectPolicy(), Environment.ProcessorCount);\n+#endif\n+\n+        /// <summary>\n+        /// An array of callbacks to be called for each string being interned.\n+        /// </summary>\n+        private static volatile TryInternStringDelegate[] s_internStringCallbacks = new TryInternStringDelegate[0];\n+\n+        /// <summary>\n+        /// A lock protecting writes to <see cref=\"s_internStringCallbacks\"/>.\n+        /// </summary>\n+        private static object s_locker = new object();\n+\n+\n+        #region Public methods\n+\n+        /// <summary>\n+        /// Interns the given string if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The string to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(string str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+\n+#if !NET35\n+        /// <summary>\n+        /// Interns the given readonly character span if possible.\n+        /// </summary>\n+        /// <param name=\"str\">The character span to intern.</param>\n+        /// <returns>The interned string equal to <paramref name=\"str\"/>.</returns>\n+        /// <remarks>\n+        /// <see cref=\"TryInternStringDelegate\"/> callbacks registered via <see cref=\"RegisterStringInterningCallback\"/> are called\n+        /// in registration order to check if custom interning is desired. If no callback returns true, the default interner based\n+        /// on weak GC handles is used.\n+        /// </remarks>\n+        public static string TryIntern(ReadOnlySpan<char> str)\n+        {\n+            InternableString internableString = new InternableString(str);\n+            return OpportunisticIntern.Instance.InternableToString(ref internableString);\n+        }\n+#endif\n+\n+        /// <summary>\n+        /// Returns a new or recycled <see cref=\"SpanBasedStringBuilder\"/>.\n+        /// </summary>\n+        /// <returns>The SpanBasedStringBuilder.</returns>\n+        /// <remarks>\n+        /// Call <see cref=\"IDisposable.Dispose\"/> on the returned instance to recycle it.\n+        /// </remarks>\n+        public static SpanBasedStringBuilder GetSpanBasedStringBuilder()\n+        {\n+#if NET35\n+            return new SpanBasedStringBuilder();\n+#else\n+            return s_stringBuilderPool.Get();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Adds a callback to be called when a string is being interned.\n+        /// </summary>\n+        /// <param name=\"callback\">The callback to add.</param>\n+        /// <remarks>\n+        /// Use this to implement custom interning for some strings. The callback has access to the string being interned\n+        /// via the <see cref=\"InternableString\"/> representation and can override the default behavior by returning a custom\n+        /// string.\n+        /// </remarks>\n+        public static void RegisterStringInterningCallback(TryInternStringDelegate callback)\n+        {\n+            lock (s_locker)\n+            {\n+                if (!s_internStringCallbacks.Any(existingCallback => existingCallback == callback))\n+                {\n+                    TryInternStringDelegate[] newInternStringCallback = new TryInternStringDelegate[s_internStringCallbacks.Length + 1];\n+                    s_internStringCallbacks.CopyTo(newInternStringCallback, 0);\n+                    newInternStringCallback[s_internStringCallbacks.Length] = callback;\n+\n+                    s_internStringCallbacks = newInternStringCallback;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Removes a callback previously added with <see cref=\"RegisterStringInterningCallback\"/>.\n+        /// </summary>\n+        /// <param name=\"callback\">The callback to remove.</param>\n+        public static void UnregisterStringInterningCallback(TryInternStringDelegate callback)\n+        {\n+            lock (s_locker)\n+            {\n+                s_internStringCallbacks = s_internStringCallbacks.Where(existingCallback => existingCallback != callback).ToArray();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Enables diagnostics in the interner. Call <see cref=\"CreateDiagnosticReport\"/> to retrieve the diagnostic data.\n+        /// </summary>\n+        public static void EnableDiagnostics()\n+        {\n+            OpportunisticIntern.Instance.EnableStatisticsGathering();\n+        }\n+\n+        /// <summary>\n+        /// Retrieves the diagnostic data describing the current state of the interner. Make sure to call <see cref=\"EnableDiagnostics\"/> beforehand.\n+        /// </summary>\n+        public static string CreateDiagnosticReport()\n+        {\n+            StringBuilder callbackReport = new StringBuilder();\n+            callbackReport.AppendFormat(\"{0} with {1} string interning callbacks registered\", nameof(Strings), s_internStringCallbacks.Length);\n+            callbackReport.AppendLine();\n+\n+            return callbackReport.ToString() + OpportunisticIntern.Instance.FormatStatistics();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Returns a <see cref=\"SpanBasedStringBuilder\"/> instance back to the pool if possible.\n+        /// </summary>\n+        /// <param name=\"stringBuilder\">The instance to return.</param>\n+        internal static void ReturnSpanBasedStringBuilder(SpanBasedStringBuilder stringBuilder)\n+        {\n+            if (stringBuilder == null)\n+            {\n+                throw new ArgumentNullException(nameof(stringBuilder));\n+            }\n+#if !NET35\n+            s_stringBuilderPool.Return(stringBuilder);\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Calls interning callbacks in sequence until one return true.\n+        /// </summary>\n+        /// <param name=\"candidate\">The candidate internable string to invoke the callbacks with.</param>\n+        /// <param name=\"interned\">The resulting string.</param>\n+        /// <returns></returns>\n+        internal static bool CallStringInterningCallbacks(ref InternableString candidate, out string interned)\n+        {\n+            // We can read s_internStringCallbacks lock-less because it's declared volatile and RegisterStringInterningCallback\n+            // and UnregisterStringInterningCallback write the field after initializing its content.\n+            TryInternStringDelegate[] callbacks = s_internStringCallbacks;\n+            foreach (TryInternStringDelegate callback in callbacks)\n+            {\n+                if (callback(ref candidate, out interned))\n+                {\n+                    return true;\n+                }\n+            }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Did you mean to do this?",
              "createdAt": "2020-09-20T05:19:02Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1,4 +1,5 @@\n-\ufeff// Copyright (c) Microsoft. All rights reserved.\n+\ufeff\n+// Copyright (c) Microsoft. All rights reserved.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Good catch, reverted!",
              "createdAt": "2020-11-30T13:58:37Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1,4 +1,5 @@\n-\ufeff// Copyright (c) Microsoft. All rights reserved.\n+\ufeff\n+// Copyright (c) Microsoft. All rights reserved.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why do it this way instead of appending in the else?",
              "createdAt": "2020-09-20T05:32:05Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -645,68 +644,89 @@ private static string[] ExtractFunctionArguments(IElementLocation elementLocatio\n \n             List<string> arguments = new List<string>();\n \n-            // With the reuseable string builder, there's no particular need to initialize the length as it will already have grown.\n-            using (var argumentBuilder = new ReuseableStringBuilder())\n+            SpanBasedStringBuilder argumentBuilder = Strings.GetSpanBasedStringBuilder();\n+            int? argumentStartIndex = null;\n+\n+            try\n             {\n-                unsafe\n+                // Iterate over the contents of the arguments extracting the\n+                // the individual arguments as we go\n+                for (int n = 0; n < argumentsContentLength; n++)\n                 {\n-                    fixed (char* argumentsContent = argumentsString)\n+                    // We found a property expression.. skip over all of it.\n+                    if ((n < argumentsContentLength - 1) && (argumentsString[n] == '$' && argumentsString[n + 1] == '('))\n                     {\n-                        // Iterate over the contents of the arguments extracting the\n-                        // the individual arguments as we go\n-                        for (int n = 0; n < argumentsContentLength; n++)\n-                        {\n-                            // We found a property expression.. skip over all of it.\n-                            if ((n < argumentsContentLength - 1) && (argumentsContent[n] == '$' && argumentsContent[n + 1] == '('))\n-                            {\n-                                int nestedPropertyStart = n;\n-                                n += 2; // skip over the opening '$('\n-\n-                                // Scan for the matching closing bracket, skipping any nested ones\n-                                n = ScanForClosingParenthesis(argumentsString, n);\n+                        int nestedPropertyStart = n;\n+                        n += 2; // skip over the opening '$('\n \n-                                if (n == -1)\n-                                {\n-                                    ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedParenthesis\"));\n-                                }\n+                        // Scan for the matching closing bracket, skipping any nested ones\n+                        n = ScanForClosingParenthesis(argumentsString, n);\n \n-                                argumentBuilder.Append(argumentsString, nestedPropertyStart, (n - nestedPropertyStart) + 1);\n-                            }\n-                            else if (argumentsContent[n] == '`' || argumentsContent[n] == '\"' || argumentsContent[n] == '\\'')\n-                            {\n-                                int quoteStart = n;\n-                                n++; // skip over the opening quote\n+                        if (n == -1)\n+                        {\n+                            ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedParenthesis\"));\n+                        }\n \n-                                n = ScanForClosingQuote(argumentsString[quoteStart], argumentsString, n);\n+                        if (argumentStartIndex.HasValue)\n+                        {\n+                            argumentBuilder.Append(argumentsString, argumentStartIndex.Value, nestedPropertyStart - argumentStartIndex.Value);\n+                            argumentStartIndex = null;\n+                        }\n+                        argumentBuilder.Append(argumentsString, nestedPropertyStart, (n - nestedPropertyStart) + 1);\n+                    }\n+                    else if (argumentsString[n] == '`' || argumentsString[n] == '\"' || argumentsString[n] == '\\'')\n+                    {\n+                        int quoteStart = n;\n+                        n++; // skip over the opening quote\n \n-                                if (n == -1)\n-                                {\n-                                    ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedQuote\"));\n-                                }\n+                        n = ScanForClosingQuote(argumentsString[quoteStart], argumentsString, n);\n \n-                                argumentBuilder.Append(argumentsString, quoteStart, (n - quoteStart) + 1);\n-                            }\n-                            else if (argumentsContent[n] == ',')\n-                            {\n-                                // We have reached the end of the current argument, go ahead and add it\n-                                // to our list\n-                                AddArgument(arguments, argumentBuilder);\n+                        if (n == -1)\n+                        {\n+                            ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedQuote\"));\n+                        }\n \n-                                // Clear out the argument builder ready for the next argument\n-                                argumentBuilder.Remove(0, argumentBuilder.Length);\n-                            }\n-                            else\n-                            {\n-                                argumentBuilder.Append(argumentsContent[n]);\n-                            }\n+                        if (argumentStartIndex.HasValue)\n+                        {\n+                            argumentBuilder.Append(argumentsString, argumentStartIndex.Value, quoteStart - argumentStartIndex.Value);\n+                            argumentStartIndex = null;\n                         }\n+                        argumentBuilder.Append(argumentsString, quoteStart, (n - quoteStart) + 1);\n                     }\n+                    else if (argumentsString[n] == ',')\n+                    {\n+                        if (argumentStartIndex.HasValue)\n+                        {\n+                            argumentBuilder.Append(argumentsString, argumentStartIndex.Value, n - argumentStartIndex.Value);\n+                            argumentStartIndex = null;\n+                        }\n+\n+                        // We have reached the end of the current argument, go ahead and add it\n+                        // to our list\n+                        AddArgument(arguments, argumentBuilder);\n+\n+                        // Clear out the argument builder ready for the next argument\n+                        argumentBuilder.Clear();\n+                    }\n+                    else\n+                    {\n+                        argumentStartIndex ??= n;\n+                    }\n+                }\n+\n+                if (argumentStartIndex.HasValue)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The original code was appending to the `argumentBuilder` character by character. With the new data structure this would be inefficient so now it keeps track of the start of the current argument and appends the entire substring when it finds its end. This `if` statement is handling the case where the argument's last character is the last character of the input string so we don't detect the end inside the loop.",
              "createdAt": "2020-12-01T12:45:39Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -645,68 +644,89 @@ private static string[] ExtractFunctionArguments(IElementLocation elementLocatio\n \n             List<string> arguments = new List<string>();\n \n-            // With the reuseable string builder, there's no particular need to initialize the length as it will already have grown.\n-            using (var argumentBuilder = new ReuseableStringBuilder())\n+            SpanBasedStringBuilder argumentBuilder = Strings.GetSpanBasedStringBuilder();\n+            int? argumentStartIndex = null;\n+\n+            try\n             {\n-                unsafe\n+                // Iterate over the contents of the arguments extracting the\n+                // the individual arguments as we go\n+                for (int n = 0; n < argumentsContentLength; n++)\n                 {\n-                    fixed (char* argumentsContent = argumentsString)\n+                    // We found a property expression.. skip over all of it.\n+                    if ((n < argumentsContentLength - 1) && (argumentsString[n] == '$' && argumentsString[n + 1] == '('))\n                     {\n-                        // Iterate over the contents of the arguments extracting the\n-                        // the individual arguments as we go\n-                        for (int n = 0; n < argumentsContentLength; n++)\n-                        {\n-                            // We found a property expression.. skip over all of it.\n-                            if ((n < argumentsContentLength - 1) && (argumentsContent[n] == '$' && argumentsContent[n + 1] == '('))\n-                            {\n-                                int nestedPropertyStart = n;\n-                                n += 2; // skip over the opening '$('\n-\n-                                // Scan for the matching closing bracket, skipping any nested ones\n-                                n = ScanForClosingParenthesis(argumentsString, n);\n+                        int nestedPropertyStart = n;\n+                        n += 2; // skip over the opening '$('\n \n-                                if (n == -1)\n-                                {\n-                                    ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedParenthesis\"));\n-                                }\n+                        // Scan for the matching closing bracket, skipping any nested ones\n+                        n = ScanForClosingParenthesis(argumentsString, n);\n \n-                                argumentBuilder.Append(argumentsString, nestedPropertyStart, (n - nestedPropertyStart) + 1);\n-                            }\n-                            else if (argumentsContent[n] == '`' || argumentsContent[n] == '\"' || argumentsContent[n] == '\\'')\n-                            {\n-                                int quoteStart = n;\n-                                n++; // skip over the opening quote\n+                        if (n == -1)\n+                        {\n+                            ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedParenthesis\"));\n+                        }\n \n-                                n = ScanForClosingQuote(argumentsString[quoteStart], argumentsString, n);\n+                        if (argumentStartIndex.HasValue)\n+                        {\n+                            argumentBuilder.Append(argumentsString, argumentStartIndex.Value, nestedPropertyStart - argumentStartIndex.Value);\n+                            argumentStartIndex = null;\n+                        }\n+                        argumentBuilder.Append(argumentsString, nestedPropertyStart, (n - nestedPropertyStart) + 1);\n+                    }\n+                    else if (argumentsString[n] == '`' || argumentsString[n] == '\"' || argumentsString[n] == '\\'')\n+                    {\n+                        int quoteStart = n;\n+                        n++; // skip over the opening quote\n \n-                                if (n == -1)\n-                                {\n-                                    ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedQuote\"));\n-                                }\n+                        n = ScanForClosingQuote(argumentsString[quoteStart], argumentsString, n);\n \n-                                argumentBuilder.Append(argumentsString, quoteStart, (n - quoteStart) + 1);\n-                            }\n-                            else if (argumentsContent[n] == ',')\n-                            {\n-                                // We have reached the end of the current argument, go ahead and add it\n-                                // to our list\n-                                AddArgument(arguments, argumentBuilder);\n+                        if (n == -1)\n+                        {\n+                            ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedQuote\"));\n+                        }\n \n-                                // Clear out the argument builder ready for the next argument\n-                                argumentBuilder.Remove(0, argumentBuilder.Length);\n-                            }\n-                            else\n-                            {\n-                                argumentBuilder.Append(argumentsContent[n]);\n-                            }\n+                        if (argumentStartIndex.HasValue)\n+                        {\n+                            argumentBuilder.Append(argumentsString, argumentStartIndex.Value, quoteStart - argumentStartIndex.Value);\n+                            argumentStartIndex = null;\n                         }\n+                        argumentBuilder.Append(argumentsString, quoteStart, (n - quoteStart) + 1);\n                     }\n+                    else if (argumentsString[n] == ',')\n+                    {\n+                        if (argumentStartIndex.HasValue)\n+                        {\n+                            argumentBuilder.Append(argumentsString, argumentStartIndex.Value, n - argumentStartIndex.Value);\n+                            argumentStartIndex = null;\n+                        }\n+\n+                        // We have reached the end of the current argument, go ahead and add it\n+                        // to our list\n+                        AddArgument(arguments, argumentBuilder);\n+\n+                        // Clear out the argument builder ready for the next argument\n+                        argumentBuilder.Clear();\n+                    }\n+                    else\n+                    {\n+                        argumentStartIndex ??= n;\n+                    }\n+                }\n+\n+                if (argumentStartIndex.HasValue)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Had a very similar question. Comment this?",
              "createdAt": "2021-01-12T17:25:49Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -645,68 +644,89 @@ private static string[] ExtractFunctionArguments(IElementLocation elementLocatio\n \n             List<string> arguments = new List<string>();\n \n-            // With the reuseable string builder, there's no particular need to initialize the length as it will already have grown.\n-            using (var argumentBuilder = new ReuseableStringBuilder())\n+            SpanBasedStringBuilder argumentBuilder = Strings.GetSpanBasedStringBuilder();\n+            int? argumentStartIndex = null;\n+\n+            try\n             {\n-                unsafe\n+                // Iterate over the contents of the arguments extracting the\n+                // the individual arguments as we go\n+                for (int n = 0; n < argumentsContentLength; n++)\n                 {\n-                    fixed (char* argumentsContent = argumentsString)\n+                    // We found a property expression.. skip over all of it.\n+                    if ((n < argumentsContentLength - 1) && (argumentsString[n] == '$' && argumentsString[n + 1] == '('))\n                     {\n-                        // Iterate over the contents of the arguments extracting the\n-                        // the individual arguments as we go\n-                        for (int n = 0; n < argumentsContentLength; n++)\n-                        {\n-                            // We found a property expression.. skip over all of it.\n-                            if ((n < argumentsContentLength - 1) && (argumentsContent[n] == '$' && argumentsContent[n + 1] == '('))\n-                            {\n-                                int nestedPropertyStart = n;\n-                                n += 2; // skip over the opening '$('\n-\n-                                // Scan for the matching closing bracket, skipping any nested ones\n-                                n = ScanForClosingParenthesis(argumentsString, n);\n+                        int nestedPropertyStart = n;\n+                        n += 2; // skip over the opening '$('\n \n-                                if (n == -1)\n-                                {\n-                                    ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedParenthesis\"));\n-                                }\n+                        // Scan for the matching closing bracket, skipping any nested ones\n+                        n = ScanForClosingParenthesis(argumentsString, n);\n \n-                                argumentBuilder.Append(argumentsString, nestedPropertyStart, (n - nestedPropertyStart) + 1);\n-                            }\n-                            else if (argumentsContent[n] == '`' || argumentsContent[n] == '\"' || argumentsContent[n] == '\\'')\n-                            {\n-                                int quoteStart = n;\n-                                n++; // skip over the opening quote\n+                        if (n == -1)\n+                        {\n+                            ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedParenthesis\"));\n+                        }\n \n-                                n = ScanForClosingQuote(argumentsString[quoteStart], argumentsString, n);\n+                        if (argumentStartIndex.HasValue)\n+                        {\n+                            argumentBuilder.Append(argumentsString, argumentStartIndex.Value, nestedPropertyStart - argumentStartIndex.Value);\n+                            argumentStartIndex = null;\n+                        }\n+                        argumentBuilder.Append(argumentsString, nestedPropertyStart, (n - nestedPropertyStart) + 1);\n+                    }\n+                    else if (argumentsString[n] == '`' || argumentsString[n] == '\"' || argumentsString[n] == '\\'')\n+                    {\n+                        int quoteStart = n;\n+                        n++; // skip over the opening quote\n \n-                                if (n == -1)\n-                                {\n-                                    ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedQuote\"));\n-                                }\n+                        n = ScanForClosingQuote(argumentsString[quoteStart], argumentsString, n);\n \n-                                argumentBuilder.Append(argumentsString, quoteStart, (n - quoteStart) + 1);\n-                            }\n-                            else if (argumentsContent[n] == ',')\n-                            {\n-                                // We have reached the end of the current argument, go ahead and add it\n-                                // to our list\n-                                AddArgument(arguments, argumentBuilder);\n+                        if (n == -1)\n+                        {\n+                            ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedQuote\"));\n+                        }\n \n-                                // Clear out the argument builder ready for the next argument\n-                                argumentBuilder.Remove(0, argumentBuilder.Length);\n-                            }\n-                            else\n-                            {\n-                                argumentBuilder.Append(argumentsContent[n]);\n-                            }\n+                        if (argumentStartIndex.HasValue)\n+                        {\n+                            argumentBuilder.Append(argumentsString, argumentStartIndex.Value, quoteStart - argumentStartIndex.Value);\n+                            argumentStartIndex = null;\n                         }\n+                        argumentBuilder.Append(argumentsString, quoteStart, (n - quoteStart) + 1);\n                     }\n+                    else if (argumentsString[n] == ',')\n+                    {\n+                        if (argumentStartIndex.HasValue)\n+                        {\n+                            argumentBuilder.Append(argumentsString, argumentStartIndex.Value, n - argumentStartIndex.Value);\n+                            argumentStartIndex = null;\n+                        }\n+\n+                        // We have reached the end of the current argument, go ahead and add it\n+                        // to our list\n+                        AddArgument(arguments, argumentBuilder);\n+\n+                        // Clear out the argument builder ready for the next argument\n+                        argumentBuilder.Clear();\n+                    }\n+                    else\n+                    {\n+                        argumentStartIndex ??= n;\n+                    }\n+                }\n+\n+                if (argumentStartIndex.HasValue)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you think it would make sense to add an overload for chars?",
              "createdAt": "2020-09-20T05:37:31Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1318,51 +1334,53 @@ internal static string ConvertToString(object valueToConvert)\n                     {\n                         convertedString = (string)valueToConvert;\n                     }\n-                    else if (valueToConvert is IDictionary)\n+                    else if (valueToConvert is IDictionary dictionary)\n                     {\n                         // If the return type is an IDictionary, then we convert this to\n                         // a semi-colon delimited set of A=B pairs.\n                         // Key and Value are converted to string and escaped\n-                        IDictionary dictionary = valueToConvert as IDictionary;\n-                        using (var builder = new ReuseableStringBuilder())\n+                        if (dictionary.Count > 0)\n                         {\n+                            using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();\n+\n                             foreach (DictionaryEntry entry in dictionary)\n                             {\n                                 if (builder.Length > 0)\n                                 {\n-                                    builder.Append(';');",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "In this first iteration I'd like to keep it simple and support only real spans. Making a span out of a character is problematic. `ch.ToString().AsSpan()` allocates so that's a no-go. Maybe the caller could pass the character by-ref so it could be converted to span without allocating, or the `SpanBasedStringBuilder` could keep a list of chars in addition to the list of spans but it feels like it would start defeating the purpose. Good question, though.",
              "createdAt": "2020-11-30T15:42:21Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -1318,51 +1334,53 @@ internal static string ConvertToString(object valueToConvert)\n                     {\n                         convertedString = (string)valueToConvert;\n                     }\n-                    else if (valueToConvert is IDictionary)\n+                    else if (valueToConvert is IDictionary dictionary)\n                     {\n                         // If the return type is an IDictionary, then we convert this to\n                         // a semi-colon delimited set of A=B pairs.\n                         // Key and Value are converted to string and escaped\n-                        IDictionary dictionary = valueToConvert as IDictionary;\n-                        using (var builder = new ReuseableStringBuilder())\n+                        if (dictionary.Count > 0)\n                         {\n+                            using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();\n+\n                             foreach (DictionaryEntry entry in dictionary)\n                             {\n                                 if (builder.Length > 0)\n                                 {\n-                                    builder.Append(';');",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is TestAssemblyInfo causing problems in the new tests?",
              "createdAt": "2020-09-20T05:40:33Z",
              "path": "src/Directory.Build.targets",
              "diffHunk": "@@ -57,7 +57,7 @@\n     <!-- Don't localize unit test projects -->\n     <PackageReference Remove=\"XliffTasks\" />\n \n-    <Compile Include=\"$(RepoRoot)src\\Shared\\UnitTests\\TestAssemblyInfo.cs\" />\n+    <Compile Include=\"$(RepoRoot)src\\Shared\\UnitTests\\TestAssemblyInfo.cs\" Condition=\"'$(IsLibraryTestProject)' != 'true'\" />",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Including `TestAssemblyInfo` makes the tests depend on `src\\Xunit.NetCore.Extensions` which I want to avoid because I want the new library (and its tests) build in as vanilla environment as possible. In the future the library will likely move elsewhere so the fewer dependencies the better.",
              "createdAt": "2020-11-30T13:55:50Z",
              "path": "src/Directory.Build.targets",
              "diffHunk": "@@ -57,7 +57,7 @@\n     <!-- Don't localize unit test projects -->\n     <PackageReference Remove=\"XliffTasks\" />\n \n-    <Compile Include=\"$(RepoRoot)src\\Shared\\UnitTests\\TestAssemblyInfo.cs\" />\n+    <Compile Include=\"$(RepoRoot)src\\Shared\\UnitTests\\TestAssemblyInfo.cs\" Condition=\"'$(IsLibraryTestProject)' != 'true'\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Doesn't this allocate a bunch of little semicolons? I'm thinking it might be more efficient (and easier to understand) to use String.Join(\";\", propertyNameValuePair.Value) and only worry about interning it afterwards.",
              "createdAt": "2020-09-20T05:57:08Z",
              "path": "src/Shared/PropertyParser.cs",
              "diffHunk": "@@ -163,9 +162,22 @@ internal static bool GetTableWithEscaping(TaskLoggingHelper log, string paramete\n                 // needs to pass onto the engine.\n                 log?.LogMessageFromText(parameterName, MessageImportance.Low);\n \n+                using SpanBasedStringBuilder stringBuilder = Strings.GetSpanBasedStringBuilder();\n                 foreach (PropertyNameValuePair propertyNameValuePair in finalPropertiesList)\n                 {\n-                    string propertyValue = OpportunisticIntern.StringBuilderToString(propertyNameValuePair.Value);\n+                    stringBuilder.Clear();\n+                    bool needsSemicolon = false;\n+                    foreach (string valueFragment in propertyNameValuePair.Value)\n+                    {\n+                        if (needsSemicolon)\n+                        {\n+                            stringBuilder.Append(\";\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Looking at your other comments, I'm guessing \";\" was pre-allocated (once) by the runtime. Trying to get the hang of that \ud83d\ude04 ",
              "createdAt": "2020-11-30T15:36:34Z",
              "path": "src/Shared/PropertyParser.cs",
              "diffHunk": "@@ -163,9 +162,22 @@ internal static bool GetTableWithEscaping(TaskLoggingHelper log, string paramete\n                 // needs to pass onto the engine.\n                 log?.LogMessageFromText(parameterName, MessageImportance.Low);\n \n+                using SpanBasedStringBuilder stringBuilder = Strings.GetSpanBasedStringBuilder();\n                 foreach (PropertyNameValuePair propertyNameValuePair in finalPropertiesList)\n                 {\n-                    string propertyValue = OpportunisticIntern.StringBuilderToString(propertyNameValuePair.Value);\n+                    stringBuilder.Clear();\n+                    bool needsSemicolon = false;\n+                    foreach (string valueFragment in propertyNameValuePair.Value)\n+                    {\n+                        if (needsSemicolon)\n+                        {\n+                            stringBuilder.Append(\";\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Exactly! Although whether this entire method is now faster than it would be with `String.Join()` (for typical inputs) is an excellent question that deserves careful measurements.",
              "createdAt": "2020-11-30T15:44:44Z",
              "path": "src/Shared/PropertyParser.cs",
              "diffHunk": "@@ -163,9 +162,22 @@ internal static bool GetTableWithEscaping(TaskLoggingHelper log, string paramete\n                 // needs to pass onto the engine.\n                 log?.LogMessageFromText(parameterName, MessageImportance.Low);\n \n+                using SpanBasedStringBuilder stringBuilder = Strings.GetSpanBasedStringBuilder();\n                 foreach (PropertyNameValuePair propertyNameValuePair in finalPropertiesList)\n                 {\n-                    string propertyValue = OpportunisticIntern.StringBuilderToString(propertyNameValuePair.Value);\n+                    stringBuilder.Clear();\n+                    bool needsSemicolon = false;\n+                    foreach (string valueFragment in propertyNameValuePair.Value)\n+                    {\n+                        if (needsSemicolon)\n+                        {\n+                            stringBuilder.Append(\";\");",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "What was the conclusion on whether this was more efficient than String.Join()?",
              "createdAt": "2020-12-17T00:15:57Z",
              "path": "src/Shared/PropertyParser.cs",
              "diffHunk": "@@ -163,9 +162,22 @@ internal static bool GetTableWithEscaping(TaskLoggingHelper log, string paramete\n                 // needs to pass onto the engine.\n                 log?.LogMessageFromText(parameterName, MessageImportance.Low);\n \n+                using SpanBasedStringBuilder stringBuilder = Strings.GetSpanBasedStringBuilder();\n                 foreach (PropertyNameValuePair propertyNameValuePair in finalPropertiesList)\n                 {\n-                    string propertyValue = OpportunisticIntern.StringBuilderToString(propertyNameValuePair.Value);\n+                    stringBuilder.Clear();\n+                    bool needsSemicolon = false;\n+                    foreach (string valueFragment in propertyNameValuePair.Value)\n+                    {\n+                        if (needsSemicolon)\n+                        {\n+                            stringBuilder.Append(\";\");",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a way to ensure they go down the hardcoded path?",
              "createdAt": "2020-09-20T15:03:02Z",
              "path": "src/StringTools.UnitTests/OpportunisticIntern_Tests.cs",
              "diffHunk": "@@ -0,0 +1,142 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#if NET35_UNITTEST\n+extern alias StringToolsNet35;\n+#endif\n+\n+using Shouldly;\n+using Xunit;\n+\n+#if NET35_UNITTEST\n+using StringToolsNet35::System;\n+using StringToolsNet35::Microsoft.StringTools;\n+#else\n+using System;\n+#endif\n+\n+namespace Microsoft.StringTools.Tests\n+{\n+    public class OpportunisticInternTestBase\n+    {\n+        private static bool IsInternable(ref InternableString internable)\n+        {\n+            string i1 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            string i2 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            i1.ShouldBe(i2); // No matter what, the same string value should return.\n+            return System.Object.ReferenceEquals(i1, i2);\n+        }\n+\n+        private static void AssertInternable(ref InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeTrue();\n+        }\n+\n+        private static string AssertInternable(char[] ch, int startIndex, int count)\n+        {\n+            var target = new InternableString(ch.AsSpan(startIndex, count));\n+            AssertInternable(ref target);\n+            target.Length.ShouldBe(count);\n+\n+            return target.ExpensiveConvertToString();\n+        }\n+\n+        private static void AssertInternable(string value)\n+        {\n+            AssertInternable(value.ToCharArray(), 0, value.ToCharArray().Length);\n+        }\n+\n+        private static void AssertNotInternable(InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeFalse();\n+        }\n+\n+        private static void AssertNotInternable(char[] ch)\n+        {\n+            AssertNotInternable(new InternableString(ch.AsSpan(0, ch.Length)));\n+        }\n+\n+        protected static void AssertNotInternable(string value)\n+        {\n+            AssertNotInternable(value.ToCharArray());\n+        }\n+\n+        /// <summary>\n+        /// Test interning segment of char array\n+        /// </summary>\n+        [Fact]\n+        public void SubArray()\n+        {\n+            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e' }, 1, 4);\n+            result.ShouldBe(\"true\");\n+        }\n+\n+        /// <summary>\n+        /// Test interning segment of char array\n+        /// </summary>\n+        [Fact]\n+        public void SubArray2()\n+        {\n+            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e', 'x' }, 1, 4);\n+            result.ShouldBe(\"true\");\n+        }\n+\n+        /// <summary>\n+        /// This is the list of hard-coded interns. They should report interned even though they are too small for normal interning.\n+        /// </summary>\n+        [Fact]\n+        public void KnownInternableTinyStrings()\n+        {\n+            AssertInternable(\"C#\");\n+            AssertInternable(\"F#\");\n+            AssertInternable(\"VB\");\n+            AssertInternable(\"True\");\n+            AssertInternable(\"TRUE\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "We could tell by reading the interning stats but I'll first verify that there is value to hardcoding at all. Thanks.",
              "createdAt": "2020-11-30T14:51:29Z",
              "path": "src/StringTools.UnitTests/OpportunisticIntern_Tests.cs",
              "diffHunk": "@@ -0,0 +1,142 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#if NET35_UNITTEST\n+extern alias StringToolsNet35;\n+#endif\n+\n+using Shouldly;\n+using Xunit;\n+\n+#if NET35_UNITTEST\n+using StringToolsNet35::System;\n+using StringToolsNet35::Microsoft.StringTools;\n+#else\n+using System;\n+#endif\n+\n+namespace Microsoft.StringTools.Tests\n+{\n+    public class OpportunisticInternTestBase\n+    {\n+        private static bool IsInternable(ref InternableString internable)\n+        {\n+            string i1 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            string i2 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            i1.ShouldBe(i2); // No matter what, the same string value should return.\n+            return System.Object.ReferenceEquals(i1, i2);\n+        }\n+\n+        private static void AssertInternable(ref InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeTrue();\n+        }\n+\n+        private static string AssertInternable(char[] ch, int startIndex, int count)\n+        {\n+            var target = new InternableString(ch.AsSpan(startIndex, count));\n+            AssertInternable(ref target);\n+            target.Length.ShouldBe(count);\n+\n+            return target.ExpensiveConvertToString();\n+        }\n+\n+        private static void AssertInternable(string value)\n+        {\n+            AssertInternable(value.ToCharArray(), 0, value.ToCharArray().Length);\n+        }\n+\n+        private static void AssertNotInternable(InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeFalse();\n+        }\n+\n+        private static void AssertNotInternable(char[] ch)\n+        {\n+            AssertNotInternable(new InternableString(ch.AsSpan(0, ch.Length)));\n+        }\n+\n+        protected static void AssertNotInternable(string value)\n+        {\n+            AssertNotInternable(value.ToCharArray());\n+        }\n+\n+        /// <summary>\n+        /// Test interning segment of char array\n+        /// </summary>\n+        [Fact]\n+        public void SubArray()\n+        {\n+            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e' }, 1, 4);\n+            result.ShouldBe(\"true\");\n+        }\n+\n+        /// <summary>\n+        /// Test interning segment of char array\n+        /// </summary>\n+        [Fact]\n+        public void SubArray2()\n+        {\n+            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e', 'x' }, 1, 4);\n+            result.ShouldBe(\"true\");\n+        }\n+\n+        /// <summary>\n+        /// This is the list of hard-coded interns. They should report interned even though they are too small for normal interning.\n+        /// </summary>\n+        [Fact]\n+        public void KnownInternableTinyStrings()\n+        {\n+            AssertInternable(\"C#\");\n+            AssertInternable(\"F#\");\n+            AssertInternable(\"VB\");\n+            AssertInternable(\"True\");\n+            AssertInternable(\"TRUE\");",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I have completely deleted this file, together with the hardcoded string support.",
              "createdAt": "2020-12-15T10:40:11Z",
              "path": "src/StringTools.UnitTests/OpportunisticIntern_Tests.cs",
              "diffHunk": "@@ -0,0 +1,142 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#if NET35_UNITTEST\n+extern alias StringToolsNet35;\n+#endif\n+\n+using Shouldly;\n+using Xunit;\n+\n+#if NET35_UNITTEST\n+using StringToolsNet35::System;\n+using StringToolsNet35::Microsoft.StringTools;\n+#else\n+using System;\n+#endif\n+\n+namespace Microsoft.StringTools.Tests\n+{\n+    public class OpportunisticInternTestBase\n+    {\n+        private static bool IsInternable(ref InternableString internable)\n+        {\n+            string i1 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            string i2 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            i1.ShouldBe(i2); // No matter what, the same string value should return.\n+            return System.Object.ReferenceEquals(i1, i2);\n+        }\n+\n+        private static void AssertInternable(ref InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeTrue();\n+        }\n+\n+        private static string AssertInternable(char[] ch, int startIndex, int count)\n+        {\n+            var target = new InternableString(ch.AsSpan(startIndex, count));\n+            AssertInternable(ref target);\n+            target.Length.ShouldBe(count);\n+\n+            return target.ExpensiveConvertToString();\n+        }\n+\n+        private static void AssertInternable(string value)\n+        {\n+            AssertInternable(value.ToCharArray(), 0, value.ToCharArray().Length);\n+        }\n+\n+        private static void AssertNotInternable(InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeFalse();\n+        }\n+\n+        private static void AssertNotInternable(char[] ch)\n+        {\n+            AssertNotInternable(new InternableString(ch.AsSpan(0, ch.Length)));\n+        }\n+\n+        protected static void AssertNotInternable(string value)\n+        {\n+            AssertNotInternable(value.ToCharArray());\n+        }\n+\n+        /// <summary>\n+        /// Test interning segment of char array\n+        /// </summary>\n+        [Fact]\n+        public void SubArray()\n+        {\n+            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e' }, 1, 4);\n+            result.ShouldBe(\"true\");\n+        }\n+\n+        /// <summary>\n+        /// Test interning segment of char array\n+        /// </summary>\n+        [Fact]\n+        public void SubArray2()\n+        {\n+            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e', 'x' }, 1, 4);\n+            result.ShouldBe(\"true\");\n+        }\n+\n+        /// <summary>\n+        /// This is the list of hard-coded interns. They should report interned even though they are too small for normal interning.\n+        /// </summary>\n+        [Fact]\n+        public void KnownInternableTinyStrings()\n+        {\n+            AssertInternable(\"C#\");\n+            AssertInternable(\"F#\");\n+            AssertInternable(\"VB\");\n+            AssertInternable(\"True\");\n+            AssertInternable(\"TRUE\");",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe add a check that the return value equals `value`?",
              "createdAt": "2020-09-20T15:04:59Z",
              "path": "src/StringTools.UnitTests/OpportunisticIntern_Tests.cs",
              "diffHunk": "@@ -0,0 +1,142 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#if NET35_UNITTEST\n+extern alias StringToolsNet35;\n+#endif\n+\n+using Shouldly;\n+using Xunit;\n+\n+#if NET35_UNITTEST\n+using StringToolsNet35::System;\n+using StringToolsNet35::Microsoft.StringTools;\n+#else\n+using System;\n+#endif\n+\n+namespace Microsoft.StringTools.Tests\n+{\n+    public class OpportunisticInternTestBase\n+    {\n+        private static bool IsInternable(ref InternableString internable)\n+        {\n+            string i1 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            string i2 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            i1.ShouldBe(i2); // No matter what, the same string value should return.\n+            return System.Object.ReferenceEquals(i1, i2);\n+        }\n+\n+        private static void AssertInternable(ref InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeTrue();\n+        }\n+\n+        private static string AssertInternable(char[] ch, int startIndex, int count)\n+        {\n+            var target = new InternableString(ch.AsSpan(startIndex, count));\n+            AssertInternable(ref target);\n+            target.Length.ShouldBe(count);\n+\n+            return target.ExpensiveConvertToString();\n+        }\n+\n+        private static void AssertInternable(string value)\n+        {\n+            AssertInternable(value.ToCharArray(), 0, value.ToCharArray().Length);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Sure, done!",
              "createdAt": "2020-11-30T14:51:44Z",
              "path": "src/StringTools.UnitTests/OpportunisticIntern_Tests.cs",
              "diffHunk": "@@ -0,0 +1,142 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#if NET35_UNITTEST\n+extern alias StringToolsNet35;\n+#endif\n+\n+using Shouldly;\n+using Xunit;\n+\n+#if NET35_UNITTEST\n+using StringToolsNet35::System;\n+using StringToolsNet35::Microsoft.StringTools;\n+#else\n+using System;\n+#endif\n+\n+namespace Microsoft.StringTools.Tests\n+{\n+    public class OpportunisticInternTestBase\n+    {\n+        private static bool IsInternable(ref InternableString internable)\n+        {\n+            string i1 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            string i2 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            i1.ShouldBe(i2); // No matter what, the same string value should return.\n+            return System.Object.ReferenceEquals(i1, i2);\n+        }\n+\n+        private static void AssertInternable(ref InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeTrue();\n+        }\n+\n+        private static string AssertInternable(char[] ch, int startIndex, int count)\n+        {\n+            var target = new InternableString(ch.AsSpan(startIndex, count));\n+            AssertInternable(ref target);\n+            target.Length.ShouldBe(count);\n+\n+            return target.ExpensiveConvertToString();\n+        }\n+\n+        private static void AssertInternable(string value)\n+        {\n+            AssertInternable(value.ToCharArray(), 0, value.ToCharArray().Length);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe a test that two strings that were initialized at different points come out to the same reference when interned if they happen to be identical with one (different) string between them that comes out to a different reference?\r\n\r\nLike:\r\n```\r\nstring foo = \"bar\";\r\nstring quux = \"qux\";\r\nstring baz = \"bar\";\r\nReferenceNotEquals(foo, baz); // Have to make them longer for this to be true?\r\nfoo = AssertInternable(foo); // Pretending it returns the string\r\nquux = AssertInternable(quux);\r\nbaz = AssertInternable(baz);\r\nReferenceEquals(foo, baz);\r\nReferenceNotEquals(baz, quux);\r\n```\r\n?",
              "createdAt": "2020-09-20T15:06:03Z",
              "path": "src/StringTools.UnitTests/OpportunisticIntern_Tests.cs",
              "diffHunk": "@@ -0,0 +1,142 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#if NET35_UNITTEST\n+extern alias StringToolsNet35;\n+#endif\n+\n+using Shouldly;\n+using Xunit;\n+\n+#if NET35_UNITTEST\n+using StringToolsNet35::System;\n+using StringToolsNet35::Microsoft.StringTools;\n+#else\n+using System;\n+#endif\n+\n+namespace Microsoft.StringTools.Tests\n+{\n+    public class OpportunisticInternTestBase\n+    {\n+        private static bool IsInternable(ref InternableString internable)\n+        {\n+            string i1 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            string i2 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            i1.ShouldBe(i2); // No matter what, the same string value should return.\n+            return System.Object.ReferenceEquals(i1, i2);\n+        }\n+\n+        private static void AssertInternable(ref InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeTrue();\n+        }\n+\n+        private static string AssertInternable(char[] ch, int startIndex, int count)\n+        {\n+            var target = new InternableString(ch.AsSpan(startIndex, count));\n+            AssertInternable(ref target);\n+            target.Length.ShouldBe(count);\n+\n+            return target.ExpensiveConvertToString();\n+        }\n+\n+        private static void AssertInternable(string value)\n+        {\n+            AssertInternable(value.ToCharArray(), 0, value.ToCharArray().Length);\n+        }\n+\n+        private static void AssertNotInternable(InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeFalse();\n+        }\n+\n+        private static void AssertNotInternable(char[] ch)\n+        {\n+            AssertNotInternable(new InternableString(ch.AsSpan(0, ch.Length)));\n+        }\n+\n+        protected static void AssertNotInternable(string value)\n+        {\n+            AssertNotInternable(value.ToCharArray());\n+        }\n+\n+        /// <summary>\n+        /// Test interning segment of char array\n+        /// </summary>\n+        [Fact]\n+        public void SubArray()\n+        {\n+            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e' }, 1, 4);\n+            result.ShouldBe(\"true\");\n+        }\n+\n+        /// <summary>\n+        /// Test interning segment of char array\n+        /// </summary>\n+        [Fact]\n+        public void SubArray2()\n+        {\n+            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e', 'x' }, 1, 4);\n+            result.ShouldBe(\"true\");\n+        }\n+\n+        /// <summary>\n+        /// This is the list of hard-coded interns. They should report interned even though they are too small for normal interning.\n+        /// </summary>\n+        [Fact]\n+        public void KnownInternableTinyStrings()\n+        {\n+            AssertInternable(\"C#\");\n+            AssertInternable(\"F#\");\n+            AssertInternable(\"VB\");\n+            AssertInternable(\"True\");\n+            AssertInternable(\"TRUE\");\n+            AssertInternable(\"Copy\");\n+            AssertInternable(\"v4.0\");\n+            AssertInternable(\"true\");\n+            AssertInternable(\"FALSE\");\n+            AssertInternable(\"false\");\n+            AssertInternable(\"Debug\");\n+            AssertInternable(\"Build\");\n+            AssertInternable(\"''!=''\");\n+            AssertInternable(\"AnyCPU\");\n+            AssertInternable(\"Library\");\n+            AssertInternable(\"MSBuild\");\n+            AssertInternable(\"Release\");\n+            AssertInternable(\"ResolveAssemblyReference\");\n+        }\n+\n+        /// <summary>\n+        /// Test a set of strings that are similar to each other\n+        /// </summary>\n+        [Fact]\n+        public void InternableDifferingOnlyByNthCharacter()\n+        {\n+            string test = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890!@#$%^&*()_+ABCDEFGHIJKLMNOPQRSTUVabcdefghijklmnopqrstuvwxyz0150\";\n+            for (int i = 0; i < test.Length; ++i)\n+            {\n+                string mutated = test.Substring(0, i) + \" \" + test.Substring(i + 1);\n+                AssertInternable(mutated);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Test The empty string\n+        /// </summary>\n+        [Fact]\n+        public void StringDotEmpty()\n+        {\n+            AssertInternable(string.Empty);\n+        }\n+\n+        /// <summary>\n+        /// Test an empty string.\n+        /// </summary>\n+        [Fact]\n+        public void DoubleDoubleQuotes()\n+        {",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`foo` and `baz` in your code snipped are going to be the exact same instance thanks to runtime string interning so the first `ReferenceNotEquals` does not hold, regardless of how long the string is. I believe that a test like you're suggesting - passing two different references to the same contents and verifying that interning them results in the same reference - already exists in `WeakStringCache_Tests`.",
              "createdAt": "2020-11-30T15:18:25Z",
              "path": "src/StringTools.UnitTests/OpportunisticIntern_Tests.cs",
              "diffHunk": "@@ -0,0 +1,142 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#if NET35_UNITTEST\n+extern alias StringToolsNet35;\n+#endif\n+\n+using Shouldly;\n+using Xunit;\n+\n+#if NET35_UNITTEST\n+using StringToolsNet35::System;\n+using StringToolsNet35::Microsoft.StringTools;\n+#else\n+using System;\n+#endif\n+\n+namespace Microsoft.StringTools.Tests\n+{\n+    public class OpportunisticInternTestBase\n+    {\n+        private static bool IsInternable(ref InternableString internable)\n+        {\n+            string i1 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            string i2 = OpportunisticIntern.Instance.InternableToString(ref internable);\n+            i1.ShouldBe(i2); // No matter what, the same string value should return.\n+            return System.Object.ReferenceEquals(i1, i2);\n+        }\n+\n+        private static void AssertInternable(ref InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeTrue();\n+        }\n+\n+        private static string AssertInternable(char[] ch, int startIndex, int count)\n+        {\n+            var target = new InternableString(ch.AsSpan(startIndex, count));\n+            AssertInternable(ref target);\n+            target.Length.ShouldBe(count);\n+\n+            return target.ExpensiveConvertToString();\n+        }\n+\n+        private static void AssertInternable(string value)\n+        {\n+            AssertInternable(value.ToCharArray(), 0, value.ToCharArray().Length);\n+        }\n+\n+        private static void AssertNotInternable(InternableString internable)\n+        {\n+            IsInternable(ref internable).ShouldBeFalse();\n+        }\n+\n+        private static void AssertNotInternable(char[] ch)\n+        {\n+            AssertNotInternable(new InternableString(ch.AsSpan(0, ch.Length)));\n+        }\n+\n+        protected static void AssertNotInternable(string value)\n+        {\n+            AssertNotInternable(value.ToCharArray());\n+        }\n+\n+        /// <summary>\n+        /// Test interning segment of char array\n+        /// </summary>\n+        [Fact]\n+        public void SubArray()\n+        {\n+            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e' }, 1, 4);\n+            result.ShouldBe(\"true\");\n+        }\n+\n+        /// <summary>\n+        /// Test interning segment of char array\n+        /// </summary>\n+        [Fact]\n+        public void SubArray2()\n+        {\n+            var result = AssertInternable(new char[] { 'a', 't', 'r', 'u', 'e', 'x' }, 1, 4);\n+            result.ShouldBe(\"true\");\n+        }\n+\n+        /// <summary>\n+        /// This is the list of hard-coded interns. They should report interned even though they are too small for normal interning.\n+        /// </summary>\n+        [Fact]\n+        public void KnownInternableTinyStrings()\n+        {\n+            AssertInternable(\"C#\");\n+            AssertInternable(\"F#\");\n+            AssertInternable(\"VB\");\n+            AssertInternable(\"True\");\n+            AssertInternable(\"TRUE\");\n+            AssertInternable(\"Copy\");\n+            AssertInternable(\"v4.0\");\n+            AssertInternable(\"true\");\n+            AssertInternable(\"FALSE\");\n+            AssertInternable(\"false\");\n+            AssertInternable(\"Debug\");\n+            AssertInternable(\"Build\");\n+            AssertInternable(\"''!=''\");\n+            AssertInternable(\"AnyCPU\");\n+            AssertInternable(\"Library\");\n+            AssertInternable(\"MSBuild\");\n+            AssertInternable(\"Release\");\n+            AssertInternable(\"ResolveAssemblyReference\");\n+        }\n+\n+        /// <summary>\n+        /// Test a set of strings that are similar to each other\n+        /// </summary>\n+        [Fact]\n+        public void InternableDifferingOnlyByNthCharacter()\n+        {\n+            string test = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890!@#$%^&*()_+ABCDEFGHIJKLMNOPQRSTUVabcdefghijklmnopqrstuvwxyz0150\";\n+            for (int i = 0; i < test.Length; ++i)\n+            {\n+                string mutated = test.Substring(0, i) + \" \" + test.Substring(i + 1);\n+                AssertInternable(mutated);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Test The empty string\n+        /// </summary>\n+        [Fact]\n+        public void StringDotEmpty()\n+        {\n+            AssertInternable(string.Empty);\n+        }\n+\n+        /// <summary>\n+        /// Test an empty string.\n+        /// </summary>\n+        [Fact]\n+        public void DoubleDoubleQuotes()\n+        {",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't know if this is possible, but SpanBasedStringBuilder and SpanBasedStringBuilder.Simple are supposed to work the same, right? Is there a way to parameterize a test class and invoke the exact same tests with each?",
              "createdAt": "2020-09-20T15:12:18Z",
              "path": "src/StringTools.UnitTests/SpanBasedStringBuilder.Simple_Tests.cs",
              "diffHunk": "@@ -0,0 +1,142 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#if NET35_UNITTEST\n+extern alias StringToolsNet35;\n+#endif\n+\n+using System.Collections.Generic;\n+\n+using Shouldly;\n+using Xunit;\n+\n+#if NET35_UNITTEST\n+using StringToolsNet35::Microsoft.StringTools;\n+#endif\n+\n+namespace Microsoft.StringTools.Tests",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes! With just a few more #ifdef's there can be only one SpanBasedStringBuilder_Tests.cs running against both 3.5 and full implementations. I am really glad that you took the time to review this PR, thank you. Fixed.",
              "createdAt": "2020-12-01T12:48:48Z",
              "path": "src/StringTools.UnitTests/SpanBasedStringBuilder.Simple_Tests.cs",
              "diffHunk": "@@ -0,0 +1,142 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#if NET35_UNITTEST\n+extern alias StringToolsNet35;\n+#endif\n+\n+using System.Collections.Generic;\n+\n+using Shouldly;\n+using Xunit;\n+\n+#if NET35_UNITTEST\n+using StringToolsNet35::Microsoft.StringTools;\n+#endif\n+\n+namespace Microsoft.StringTools.Tests",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It would be nice to have some sort of a performance test. I have a feeling that isn't easily doable here, but it would be nice.",
              "createdAt": "2020-09-20T15:31:15Z",
              "path": "src/StringTools.UnitTests/SpanBasedStringBuilder_Tests.cs",
              "diffHunk": "@@ -0,0 +1,158 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.StringTools.Tests\n+{\n+    public class SpanBasedStringBuilder_Tests\n+    {\n+        private SpanBasedStringBuilder MakeSpanBasedStringBuilder(InterningTestData.TestDatum datum, bool appendSubStrings = false)\n+        {\n+            bool wrapFirstFragment = datum.Fragments.Length > 0 && datum.Fragments[0] != null;\n+\n+            SpanBasedStringBuilder stringBuilder = wrapFirstFragment\n+                ? new SpanBasedStringBuilder(datum.Fragments[0])\n+                : new SpanBasedStringBuilder();\n+\n+            for (int i = 1; i < datum.Fragments.Length; i++)\n+            {\n+                if (appendSubStrings)\n+                {\n+                    int index = datum.Fragments[i].Length / 2;\n+                    stringBuilder.Append(datum.Fragments[i], 0, index);\n+                    stringBuilder.Append(datum.Fragments[i], index, datum.Fragments[i].Length - index);\n+                }\n+                else\n+                {\n+                    stringBuilder.Append(datum.Fragments[i]);\n+                }\n+            }\n+            return stringBuilder;\n+        }\n+\n+        public static IEnumerable<object[]> TestData => InterningTestData.TestData;\n+        public static IEnumerable<object[]> TestDataForTrim => InterningTestData.TestDataForTrim;\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void LengthReturnsLength(InterningTestData.TestDatum datum)\n+        {\n+            MakeSpanBasedStringBuilder(datum).Length.ShouldBe(datum.Length);\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void EnumeratorEnumeratesCharacters(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);\n+            int index = 0;\n+            foreach (char ch in stringBuilder)\n+            {\n+                ch.ShouldBe(datum[index]);\n+                index++;\n+            }\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void IndexerReturnsCharacters(InterningTestData.TestDatum datum)\n+        {\n+            InternableString internableString = new InternableString(MakeSpanBasedStringBuilder(datum));\n+            int length = datum.Length;\n+            for (int index = 0; index < length; index++)\n+            {\n+                internableString[index].ShouldBe(datum[index]);\n+            }\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void StartsWithStringByOrdinalComparisonReturnsExpectedValue(InterningTestData.TestDatum datum)\n+        {\n+            InternableString internableString = new InternableString(MakeSpanBasedStringBuilder(datum));\n+            internableString.StartsWithStringByOrdinalComparison(string.Empty).ShouldBeTrue();\n+\n+            string substr = datum.Fragments[0] ?? string.Empty;\n+            internableString.StartsWithStringByOrdinalComparison(substr).ShouldBeTrue();\n+            internableString.StartsWithStringByOrdinalComparison(substr.Substring(0, substr.Length / 2)).ShouldBeTrue();\n+\n+            if (datum.Fragments.Length > 1)\n+            {\n+                substr += datum.Fragments[1];\n+                internableString.StartsWithStringByOrdinalComparison(substr).ShouldBeTrue();\n+                internableString.StartsWithStringByOrdinalComparison(substr.Substring(0, substr.Length - datum.Fragments[1].Length / 2)).ShouldBeTrue();\n+\n+                internableString.StartsWithStringByOrdinalComparison(datum.ToString()).ShouldBeTrue();\n+            }\n+\n+            internableString.StartsWithStringByOrdinalComparison(\"Things\").ShouldBeFalse();\n+        }\n+\n+        [Fact]\n+        public void ReferenceEqualsReturnsExpectedValue()\n+        {\n+            string str = \"Test\";\n+            InternableString internableString = new InternableString(str);\n+            internableString.ReferenceEquals(str).ShouldBeTrue();\n+            internableString = new InternableString(new string(str.ToCharArray()));\n+            internableString.ReferenceEquals(str).ShouldBeFalse();\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void AppendAppendsString(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum, false);\n+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString());\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void AppendAppendsSubstring(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum, true);\n+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString());\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestDataForTrim))]\n+        public void TrimStartRemovesLeadingWhiteSpace(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);\n+            stringBuilder.TrimStart();\n+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString().TrimStart());\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestDataForTrim))]\n+        public void TrimEndRemovesTrailingWhiteSpace(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);\n+            stringBuilder.TrimEnd();\n+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString().TrimEnd());\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestDataForTrim))]\n+        public void TrimRemovesLeadingAndTrailingWhiteSpace(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);\n+            stringBuilder.Trim();\n+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString().Trim());\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void ClearRemovesAllCharacters(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);\n+            stringBuilder.Clear();\n+            stringBuilder.Length.ShouldBe(0);\n+            stringBuilder.GetEnumerator().MoveNext().ShouldBeFalse();\n+        }\n+    }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I have added a BenchmarkDotNet-based project to the solution.",
              "createdAt": "2020-12-15T12:43:15Z",
              "path": "src/StringTools.UnitTests/SpanBasedStringBuilder_Tests.cs",
              "diffHunk": "@@ -0,0 +1,158 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.StringTools.Tests\n+{\n+    public class SpanBasedStringBuilder_Tests\n+    {\n+        private SpanBasedStringBuilder MakeSpanBasedStringBuilder(InterningTestData.TestDatum datum, bool appendSubStrings = false)\n+        {\n+            bool wrapFirstFragment = datum.Fragments.Length > 0 && datum.Fragments[0] != null;\n+\n+            SpanBasedStringBuilder stringBuilder = wrapFirstFragment\n+                ? new SpanBasedStringBuilder(datum.Fragments[0])\n+                : new SpanBasedStringBuilder();\n+\n+            for (int i = 1; i < datum.Fragments.Length; i++)\n+            {\n+                if (appendSubStrings)\n+                {\n+                    int index = datum.Fragments[i].Length / 2;\n+                    stringBuilder.Append(datum.Fragments[i], 0, index);\n+                    stringBuilder.Append(datum.Fragments[i], index, datum.Fragments[i].Length - index);\n+                }\n+                else\n+                {\n+                    stringBuilder.Append(datum.Fragments[i]);\n+                }\n+            }\n+            return stringBuilder;\n+        }\n+\n+        public static IEnumerable<object[]> TestData => InterningTestData.TestData;\n+        public static IEnumerable<object[]> TestDataForTrim => InterningTestData.TestDataForTrim;\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void LengthReturnsLength(InterningTestData.TestDatum datum)\n+        {\n+            MakeSpanBasedStringBuilder(datum).Length.ShouldBe(datum.Length);\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void EnumeratorEnumeratesCharacters(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);\n+            int index = 0;\n+            foreach (char ch in stringBuilder)\n+            {\n+                ch.ShouldBe(datum[index]);\n+                index++;\n+            }\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void IndexerReturnsCharacters(InterningTestData.TestDatum datum)\n+        {\n+            InternableString internableString = new InternableString(MakeSpanBasedStringBuilder(datum));\n+            int length = datum.Length;\n+            for (int index = 0; index < length; index++)\n+            {\n+                internableString[index].ShouldBe(datum[index]);\n+            }\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void StartsWithStringByOrdinalComparisonReturnsExpectedValue(InterningTestData.TestDatum datum)\n+        {\n+            InternableString internableString = new InternableString(MakeSpanBasedStringBuilder(datum));\n+            internableString.StartsWithStringByOrdinalComparison(string.Empty).ShouldBeTrue();\n+\n+            string substr = datum.Fragments[0] ?? string.Empty;\n+            internableString.StartsWithStringByOrdinalComparison(substr).ShouldBeTrue();\n+            internableString.StartsWithStringByOrdinalComparison(substr.Substring(0, substr.Length / 2)).ShouldBeTrue();\n+\n+            if (datum.Fragments.Length > 1)\n+            {\n+                substr += datum.Fragments[1];\n+                internableString.StartsWithStringByOrdinalComparison(substr).ShouldBeTrue();\n+                internableString.StartsWithStringByOrdinalComparison(substr.Substring(0, substr.Length - datum.Fragments[1].Length / 2)).ShouldBeTrue();\n+\n+                internableString.StartsWithStringByOrdinalComparison(datum.ToString()).ShouldBeTrue();\n+            }\n+\n+            internableString.StartsWithStringByOrdinalComparison(\"Things\").ShouldBeFalse();\n+        }\n+\n+        [Fact]\n+        public void ReferenceEqualsReturnsExpectedValue()\n+        {\n+            string str = \"Test\";\n+            InternableString internableString = new InternableString(str);\n+            internableString.ReferenceEquals(str).ShouldBeTrue();\n+            internableString = new InternableString(new string(str.ToCharArray()));\n+            internableString.ReferenceEquals(str).ShouldBeFalse();\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void AppendAppendsString(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum, false);\n+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString());\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void AppendAppendsSubstring(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum, true);\n+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString());\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestDataForTrim))]\n+        public void TrimStartRemovesLeadingWhiteSpace(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);\n+            stringBuilder.TrimStart();\n+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString().TrimStart());\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestDataForTrim))]\n+        public void TrimEndRemovesTrailingWhiteSpace(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);\n+            stringBuilder.TrimEnd();\n+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString().TrimEnd());\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestDataForTrim))]\n+        public void TrimRemovesLeadingAndTrailingWhiteSpace(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);\n+            stringBuilder.Trim();\n+            new InternableString(stringBuilder).ExpensiveConvertToString().ShouldBe(datum.ToString().Trim());\n+        }\n+\n+        [Theory]\n+        [MemberData(nameof(TestData))]\n+        public void ClearRemovesAllCharacters(InterningTestData.TestDatum datum)\n+        {\n+            SpanBasedStringBuilder stringBuilder = MakeSpanBasedStringBuilder(datum);\n+            stringBuilder.Clear();\n+            stringBuilder.Length.ShouldBe(0);\n+            stringBuilder.GetEnumerator().MoveNext().ShouldBeFalse();\n+        }\n+    }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\ud83d\udc4d \r\n\r\nI really like this test.",
              "createdAt": "2020-09-20T15:34:20Z",
              "path": "src/StringTools.UnitTests/StringTools_Tests.cs",
              "diffHunk": "@@ -0,0 +1,107 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#if NET35_UNITTEST\n+extern alias StringToolsNet35;\n+#endif\n+\n+using System;\n+using System.Linq;\n+using System.Runtime.CompilerServices;\n+using System.Text;\n+\n+using Shouldly;\n+using Xunit;\n+\n+#if NET35_UNITTEST\n+using StringToolsNet35::Microsoft.StringTools;\n+using Shouldly.Configuration;\n+#else\n+using Microsoft.StringTools;\n+#endif\n+\n+namespace Microsoft.StringTools.Tests\n+{\n+    public class StringTools_Tests\n+    {\n+        private const string HardcodedInternedString = \"Hello\";\n+        private const string HardcodedNonInternedString = \"World\";\n+\n+        public StringTools_Tests()\n+        {\n+            Strings.ResetForTests();\n+        }\n+\n+        [Fact]\n+        public void CallsRegisteredStringInterningCallback()\n+        {\n+            int callbackCallCounter = 0;\n+\n+            TryInternStringDelegate callback = (ref InternableString internableString, out string result) =>\n+            {\n+                callbackCallCounter++;\n+                if (internableString.StartsWithStringByOrdinalComparison(HardcodedInternedString))\n+                {\n+                    result = HardcodedInternedString;\n+                    return true;\n+                }\n+                if (internableString.StartsWithStringByOrdinalComparison(HardcodedNonInternedString))\n+                {\n+                    result = null;\n+                    return true;\n+                }\n+                result = null;\n+                return false;\n+            };\n+\n+            Strings.RegisterStringInterningCallback(callback);\n+\n+            InternableString internedString = new InternableString(new string(HardcodedInternedString.ToCharArray()));\n+            internedString.ToString().ShouldBeSameAs(HardcodedInternedString);\n+\n+            InternableString nonInternedString = new InternableString(new string(HardcodedNonInternedString.ToCharArray()));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit re naming, `Strings.Intern(xyz)` might be easily confused (or mistyped) for `String.Intern(xyz)` which is rather different and would cause a leak.",
              "createdAt": "2020-12-16T22:48:59Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,100 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.StringTools\n+{\n+    public static class Strings",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "Agreed. I have renamed the method to `WeakIntern`.",
              "createdAt": "2020-12-18T13:07:33Z",
              "path": "src/StringTools/StringTools.cs",
              "diffHunk": "@@ -0,0 +1,100 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.StringTools\n+{\n+    public static class Strings",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Copyright header? And would it be useful to let this be more general (within MSBuild) than StringTools.Benchmark?",
              "createdAt": "2020-12-17T00:21:03Z",
              "path": "src/StringTools.Benchmark/Program.cs",
              "diffHunk": "@@ -0,0 +1,12 @@\n+using BenchmarkDotNet.Running;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Added the header, thanks! I want `StringTools` to have its own benchmark project to keep the library as self-contained as possible. Nothing should be preventing us from introducing benchmarks for other parts of MSBuild, however. As long as they are run by devs ad-hoc, it's super straightforward. If we wanted to collect and further process the results as part of CI/CD, it would likely require some infra investments to make it happen.",
              "createdAt": "2020-12-18T13:19:06Z",
              "path": "src/StringTools.Benchmark/Program.cs",
              "diffHunk": "@@ -0,0 +1,12 @@\n+using BenchmarkDotNet.Running;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this something we'd tweak regularly?",
              "createdAt": "2020-12-17T00:21:32Z",
              "path": "MSBuild.Dev.sln",
              "diffHunk": "@@ -33,6 +33,14 @@ Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Microsoft.Build.Utilities.U\n EndProject\n Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Xunit.NetCore.Extensions\", \"src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj\", \"{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}\"\n EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"StringTools\", \"src\\StringTools\\StringTools.csproj\", \"{69FB7694-47E3-45B2-868C-8C3ECB69A947}\"\n+EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"StringTools.UnitTests\", \"src\\StringTools.UnitTests\\StringTools.UnitTests.csproj\", \"{C5F63473-F239-414A-9B0F-EF3541B68478}\"\n+EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"StringTools.UnitTests.net35\", \"src\\StringTools.UnitTests\\StringTools.UnitTests.net35.csproj\", \"{65F34646-E645-469C-8260-00EF1EDB36A6}\"\n+EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"StringTools.Benchmark\", \"src\\StringTools.Benchmark\\StringTools.Benchmark.csproj\", \"{721B1B8A-2CA0-4175-A5D8-90E046188CE3}\"",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I agree with you that we should add a .slnf and delete `MSBuild.Dev.sln` so there's only one solution file to update. I think it should be done in a separate PR. If you're asking about tweaking the `StringTools.Benchmark` project itself and not adding it to the solution, I believe it shouldn't be that much different from unit tests, i.e. it is likely going to be continually tweaked and extended as needed.",
              "createdAt": "2020-12-18T13:12:45Z",
              "path": "MSBuild.Dev.sln",
              "diffHunk": "@@ -33,6 +33,14 @@ Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Microsoft.Build.Utilities.U\n EndProject\n Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Xunit.NetCore.Extensions\", \"src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj\", \"{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}\"\n EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"StringTools\", \"src\\StringTools\\StringTools.csproj\", \"{69FB7694-47E3-45B2-868C-8C3ECB69A947}\"\n+EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"StringTools.UnitTests\", \"src\\StringTools.UnitTests\\StringTools.UnitTests.csproj\", \"{C5F63473-F239-414A-9B0F-EF3541B68478}\"\n+EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"StringTools.UnitTests.net35\", \"src\\StringTools.UnitTests\\StringTools.UnitTests.net35.csproj\", \"{65F34646-E645-469C-8260-00EF1EDB36A6}\"\n+EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"StringTools.Benchmark\", \"src\\StringTools.Benchmark\\StringTools.Benchmark.csproj\", \"{721B1B8A-2CA0-4175-A5D8-90E046188CE3}\"",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What does this do?",
              "createdAt": "2020-12-17T00:27:05Z",
              "path": "src/StringTools.UnitTests/StringTools.UnitTests.csproj",
              "diffHunk": "@@ -0,0 +1,38 @@\n+\ufeff<Project Sdk=\"Microsoft.NET.Sdk\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n+  <PropertyGroup>\n+    <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>\n+    <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>\n+    \n+    <IsPackable>false</IsPackable>\n+\n+    <AssemblyName>StringTools.UnitTests</AssemblyName>\n+    <IsTestProject>true</IsTestProject>\n+    <IsLibraryTestProject>true</IsLibraryTestProject>\n+  </PropertyGroup>\n+\n+  <ItemGroup>\n+    <PackageReference Include=\"Shouldly\" />\n+  </ItemGroup>\n+\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\StringTools\\StringTools.csproj\" />\n+  </ItemGroup>\n+\n+  <ItemGroup>\n+    <Service Include=\"{82a7f48d-3b50-4b1e-b82e-3ada8210c358}\" />",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It's present in all unit test projects, I just copied it over. According to https://github.com/microsoft/vstest/issues/472, it's a relic of the past and not needed anymore. I have removed it, thanks!",
              "createdAt": "2020-12-18T13:23:50Z",
              "path": "src/StringTools.UnitTests/StringTools.UnitTests.csproj",
              "diffHunk": "@@ -0,0 +1,38 @@\n+\ufeff<Project Sdk=\"Microsoft.NET.Sdk\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n+  <PropertyGroup>\n+    <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>\n+    <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>\n+    \n+    <IsPackable>false</IsPackable>\n+\n+    <AssemblyName>StringTools.UnitTests</AssemblyName>\n+    <IsTestProject>true</IsTestProject>\n+    <IsLibraryTestProject>true</IsLibraryTestProject>\n+  </PropertyGroup>\n+\n+  <ItemGroup>\n+    <PackageReference Include=\"Shouldly\" />\n+  </ItemGroup>\n+\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\StringTools\\StringTools.csproj\" />\n+  </ItemGroup>\n+\n+  <ItemGroup>\n+    <Service Include=\"{82a7f48d-3b50-4b1e-b82e-3ada8210c358}\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}