{
  "number": 8494,
  "title": "Document references peculiarities",
  "body": "Relates to:\r\n #4795\r\n #8405 \r\n\r\n### Context\r\n\r\nDocumenting some aspect of tailoring behavior of references. Capturing as well resolution/workarounds for the listed comunity reported issues",
  "state": "MERGED",
  "createdAt": "2023-02-23T17:07:26Z",
  "updatedAt": "2023-04-23T07:55:44Z",
  "closedAt": "2023-04-23T07:55:44Z",
  "mergedAt": "2023-04-23T07:55:44Z",
  "additions": 267,
  "deletions": 2,
  "changedFiles": 2,
  "headRefName": "doc/dependencies-behavior",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Documentation",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "aa7b9c88712a767660e9d17a122623af0b330d36",
          "message": "Document references peculiarities",
          "committedDate": "2023-02-23T17:10:14Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "84e0f6ac567ad88cb58d0fdd0a1f68c1e1dc6772",
          "message": "Update documentation/wiki/Controlling-Dependencies-Behavior.md\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-03-02T14:07:48Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "krivanek.j@hotmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4edf77f777dda952740c02a556275762c9c881b8",
          "message": "Incorporated PR review feedback",
          "committedDate": "2023-03-02T15:09:35Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59e729009166da646359be165d16c72f8fdaee6e",
          "message": "Fix samples formatting",
          "committedDate": "2023-03-24T16:17:41Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5ff294222c8d2e0f6fd5688e5b08a6f7243292cd",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-03-28T07:36:21Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2431f9d3c15dc7179e045b8da8a70d9745648f1e",
          "message": "Clarify the documentation based on feedback",
          "committedDate": "2023-03-28T11:56:10Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6455a760a2760e96d93fb3f8384df8b669952b09",
          "message": "Reflect PR suggestions",
          "committedDate": "2023-04-21T15:41:38Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "I think it's worth being consistent and calling these \"References\" instead of \"dependencies\".",
              "createdAt": "2023-02-27T18:11:05Z",
              "path": "documentation/README.md",
              "diffHunk": "@@ -39,6 +39,7 @@ The folder contains collection of docs and references for MSBuild, detailed info\n ### Problems?\n \n * [Rebuilding when nothing changed](wiki/Rebuilding-when-nothing-changed.md)\n+* [Controling Dependencies Behavior](wiki/Controlling-Dependencies-Behavior.md)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nMSBuild recognizes a [few types of dependencies](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\r\n```",
              "createdAt": "2023-02-27T18:11:46Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I draw a distinction between \"SDK-style\" projects (use _an_ SDK, are loaded in the CPS-based project system) and \".NET SDK projects\" (specifically use the .NET SDK). This has been lost on many but I can stick to it in this repo :)\r\n\r\n```suggestion\r\nIn [.NET SDK projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.\r\n```",
              "createdAt": "2023-02-27T18:13:00Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "An opportunity to use GitHub's built in [Mermaid](https://mermaid.js.org/) support!\r\n\r\n```suggestion\r\n```mermaid\r\nflowchart LR\r\n    Service[Service Layer] --> Repository\r\n    Repository[Repository Layer] --> Domain[Domain Layer]\r\n``````",
              "createdAt": "2023-02-27T18:16:16Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.\n+\n+This can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```\n+ ---------------       ------------------       --------------\n+| Service Layer | --> | Repository Layer | --> | Domain Model |\n+ ---------------       ------------------       --------------",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Unfortunately this is kind of a bad example; the C# compiler _should_ see the full closure of dependencies in any case--and as analyzers and nullability analysis increase, is getting more persnickety about this. At some point in the future this type of library reference may be _required_ to be transitive--but all of the MSBuild stuff and motivations will stay good.",
              "createdAt": "2023-02-27T18:18:45Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.\n+\n+This can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```\n+ ---------------       ------------------       --------------\n+| Service Layer | --> | Repository Layer | --> | Domain Model |\n+ ---------------       ------------------       --------------\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+\t<LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+\t<DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+\t// This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+\t// private Domain.PersonTable _tbl;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Does this still feel as bad example after this https://github.com/dotnet/msbuild/pull/8494#discussion_r1123256483?",
              "createdAt": "2023-03-02T15:14:52Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.\n+\n+This can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```\n+ ---------------       ------------------       --------------\n+| Service Layer | --> | Repository Layer | --> | Domain Model |\n+ ---------------       ------------------       --------------\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+\t<LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+\t<DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+\t// This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+\t// private Domain.PersonTable _tbl;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Probably worth a note on the mechanics of this:\r\n\r\n1. MSBuild itself doesn't know anything about it.\r\n2. At NuGet restore time, NuGet sees the graph of project dependencies and puts information about it into `project.assets.json`.\r\n3. At build time, before `ResolveProjectReferences`, an SDK task will read the assets file and synthesize `ProjectReference` items\r\n4. _Then_ MSBuild sees the transitive references as direct references.",
              "createdAt": "2023-02-27T18:20:48Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I think this also suggests moving this section below the NuGet section, so you don't have to introduce the assets file concepts? But no strong feeling.",
              "createdAt": "2023-02-27T18:21:12Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I attempted to capture the info in a new section https://github.com/dotnet/msbuild/pull/8494/files#diff-b5dec84f84d1f113f1c8d8369daf2a8b4958736d3e02764f3bfbd42e42c4a917R5-R13 - I'd appreaciate review of it, if that is accurate and makes sense",
              "createdAt": "2023-03-02T15:11:20Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nBy default the above mentioned dependency types are copied to the build output directory during the build (provided the target failed [up-to-date check](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/incremental-builds?view=vs-2015&redirectedfrom=MSDN#output-inference) and run). There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).\r\n```\r\n\r\nI might also cut the up-to-date check thing; it should be irrelevant here.",
              "createdAt": "2023-02-27T18:22:53Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.\n+\n+This can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```\n+ ---------------       ------------------       --------------\n+| Service Layer | --> | Repository Layer | --> | Domain Model |\n+ ---------------       ------------------       --------------\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+\t<LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+\t<DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+\t// This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+\t// private Domain.PersonTable _tbl;\n+}\n+```\n+\n+## Access to transitive package references\n+\n+The transitive access to dependencies works by default for package dependencies as well. This can be opted out via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets))\n+\n+*Example*:\n+\n+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This prevents the reference to be available to referencing types. -->\n+\t\t<PrivateAssets>compile</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+Then our `Service Layer` would have access to `newtonsoft.json` (unless opted out via `PrivateAssets=compile`):\n+\n+```csharp\n+namespace Service;\n+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.\n+//using Newtonsoft.Json;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+}\n+```\n+\n+## Not copying dependencies to output\n+\n+By default the above mentioned dependency types are being copied to build output directory during the build (provided the target failed [up-to-date check](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/incremental-builds?view=vs-2015&redirectedfrom=MSDN#output-inference) and run). There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nOverriding this logic depends on the type of the reference.\r\n```",
              "createdAt": "2023-02-27T18:23:05Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.\n+\n+This can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```\n+ ---------------       ------------------       --------------\n+| Service Layer | --> | Repository Layer | --> | Domain Model |\n+ ---------------       ------------------       --------------\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+\t<LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+\t<DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+\t// This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+\t// private Domain.PersonTable _tbl;\n+}\n+```\n+\n+## Access to transitive package references\n+\n+The transitive access to dependencies works by default for package dependencies as well. This can be opted out via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets))\n+\n+*Example*:\n+\n+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This prevents the reference to be available to referencing types. -->\n+\t\t<PrivateAssets>compile</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+Then our `Service Layer` would have access to `newtonsoft.json` (unless opted out via `PrivateAssets=compile`):\n+\n+```csharp\n+namespace Service;\n+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.\n+//using Newtonsoft.Json;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+}\n+```\n+\n+## Not copying dependencies to output\n+\n+By default the above mentioned dependency types are being copied to build output directory during the build (provided the target failed [up-to-date check](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/incremental-builds?view=vs-2015&redirectedfrom=MSDN#output-inference) and run). There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).\n+\n+Overriding this logic depends on a type of dependency.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't understand this, can you elaborate?",
              "createdAt": "2023-02-27T18:24:05Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.\n+\n+This can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```\n+ ---------------       ------------------       --------------\n+| Service Layer | --> | Repository Layer | --> | Domain Model |\n+ ---------------       ------------------       --------------\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+\t<LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+\t<DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+\t// This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+\t// private Domain.PersonTable _tbl;\n+}\n+```\n+\n+## Access to transitive package references\n+\n+The transitive access to dependencies works by default for package dependencies as well. This can be opted out via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets))\n+\n+*Example*:\n+\n+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This prevents the reference to be available to referencing types. -->\n+\t\t<PrivateAssets>compile</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+Then our `Service Layer` would have access to `newtonsoft.json` (unless opted out via `PrivateAssets=compile`):\n+\n+```csharp\n+namespace Service;\n+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.\n+//using Newtonsoft.Json;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+}\n+```\n+\n+## Not copying dependencies to output\n+\n+By default the above mentioned dependency types are being copied to build output directory during the build (provided the target failed [up-to-date check](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/incremental-builds?view=vs-2015&redirectedfrom=MSDN#output-inference) and run). There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).\n+\n+Overriding this logic depends on a type of dependency.\n+\n+### Not copying Assembly Reference\n+\n+Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):\n+\n+```xml\n+<ItemGroup>\n+  <Reference Include=\"mydll\">\n+    <HintPath>..\\somepath\\mydll.dll</HintPath>\n+    <!-- This indicates that the reference should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </Reference>\n+</ItemGroup>\n+```\n+\n+### Not copying PackageReference\n+\n+Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:\n+\n+**Not copying package dependency to the immediate output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->\n+\t\t<IncludeAssets>compile</IncludeAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency to the downstream dependants output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- The dependency is copied to output folder in current referencing project, \n+           but it's not copied to output folder of projects referencing current project. -->\n+\t\t<PrivateAssets>all</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency from the upstream dependencies:**\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->\n+    <ExcludeAssets>all</ExcludeAssets>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+### Not copying ProjectReference\n+\n+The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This indicates that the referenced project output should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+**Note:** There is possible need to explicitly specify `_GetChildProjectCopyToPublishDirectoryItems=false` to opt-out copying of project dependencies when builiding through [`MSBuilt` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) ([source](https://github.com/dotnet/msbuild/issues/4795#issuecomment-669885298))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This was taken from the linked issue comment.\r\n\r\nHowever it's too specific and I have not verified the real reason for this - so cutting this",
              "createdAt": "2023-03-02T14:16:20Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.\n+\n+This can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```\n+ ---------------       ------------------       --------------\n+| Service Layer | --> | Repository Layer | --> | Domain Model |\n+ ---------------       ------------------       --------------\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+\t<LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+\t<DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+\t// This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+\t// private Domain.PersonTable _tbl;\n+}\n+```\n+\n+## Access to transitive package references\n+\n+The transitive access to dependencies works by default for package dependencies as well. This can be opted out via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets))\n+\n+*Example*:\n+\n+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This prevents the reference to be available to referencing types. -->\n+\t\t<PrivateAssets>compile</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+Then our `Service Layer` would have access to `newtonsoft.json` (unless opted out via `PrivateAssets=compile`):\n+\n+```csharp\n+namespace Service;\n+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.\n+//using Newtonsoft.Json;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+}\n+```\n+\n+## Not copying dependencies to output\n+\n+By default the above mentioned dependency types are being copied to build output directory during the build (provided the target failed [up-to-date check](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/incremental-builds?view=vs-2015&redirectedfrom=MSDN#output-inference) and run). There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).\n+\n+Overriding this logic depends on a type of dependency.\n+\n+### Not copying Assembly Reference\n+\n+Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):\n+\n+```xml\n+<ItemGroup>\n+  <Reference Include=\"mydll\">\n+    <HintPath>..\\somepath\\mydll.dll</HintPath>\n+    <!-- This indicates that the reference should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </Reference>\n+</ItemGroup>\n+```\n+\n+### Not copying PackageReference\n+\n+Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:\n+\n+**Not copying package dependency to the immediate output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->\n+\t\t<IncludeAssets>compile</IncludeAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency to the downstream dependants output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- The dependency is copied to output folder in current referencing project, \n+           but it's not copied to output folder of projects referencing current project. -->\n+\t\t<PrivateAssets>all</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency from the upstream dependencies:**\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->\n+    <ExcludeAssets>all</ExcludeAssets>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+### Not copying ProjectReference\n+\n+The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This indicates that the referenced project output should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+**Note:** There is possible need to explicitly specify `_GetChildProjectCopyToPublishDirectoryItems=false` to opt-out copying of project dependencies when builiding through [`MSBuilt` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) ([source](https://github.com/dotnet/msbuild/issues/4795#issuecomment-669885298))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Worth mentioning _why_? Which is that `ReferenceOutputAssembly` applies to the \"primary output\" which is the DLL, but continues to respect the Content/None settings that may transitively copy through the project reference. And for a .NET Core exe project, that includes the apphost .exe and other related files.",
              "createdAt": "2023-02-27T18:31:33Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.\n+\n+This can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```\n+ ---------------       ------------------       --------------\n+| Service Layer | --> | Repository Layer | --> | Domain Model |\n+ ---------------       ------------------       --------------\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+\t<LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+\t<DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+\t// This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+\t// private Domain.PersonTable _tbl;\n+}\n+```\n+\n+## Access to transitive package references\n+\n+The transitive access to dependencies works by default for package dependencies as well. This can be opted out via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets))\n+\n+*Example*:\n+\n+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This prevents the reference to be available to referencing types. -->\n+\t\t<PrivateAssets>compile</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+Then our `Service Layer` would have access to `newtonsoft.json` (unless opted out via `PrivateAssets=compile`):\n+\n+```csharp\n+namespace Service;\n+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.\n+//using Newtonsoft.Json;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+}\n+```\n+\n+## Not copying dependencies to output\n+\n+By default the above mentioned dependency types are being copied to build output directory during the build (provided the target failed [up-to-date check](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/incremental-builds?view=vs-2015&redirectedfrom=MSDN#output-inference) and run). There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).\n+\n+Overriding this logic depends on a type of dependency.\n+\n+### Not copying Assembly Reference\n+\n+Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):\n+\n+```xml\n+<ItemGroup>\n+  <Reference Include=\"mydll\">\n+    <HintPath>..\\somepath\\mydll.dll</HintPath>\n+    <!-- This indicates that the reference should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </Reference>\n+</ItemGroup>\n+```\n+\n+### Not copying PackageReference\n+\n+Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:\n+\n+**Not copying package dependency to the immediate output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->\n+\t\t<IncludeAssets>compile</IncludeAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency to the downstream dependants output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- The dependency is copied to output folder in current referencing project, \n+           but it's not copied to output folder of projects referencing current project. -->\n+\t\t<PrivateAssets>all</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency from the upstream dependencies:**\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->\n+    <ExcludeAssets>all</ExcludeAssets>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+### Not copying ProjectReference\n+\n+The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This indicates that the referenced project output should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+**Note:** There is possible need to explicitly specify `_GetChildProjectCopyToPublishDirectoryItems=false` to opt-out copying of project dependencies when builiding through [`MSBuilt` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) ([source](https://github.com/dotnet/msbuild/issues/4795#issuecomment-669885298))\n+\n+## ProjectReference without accessibility and copying to output\n+\n+In a specific scenarios we might want to indicate that specific project should be built prior our project but said project should not be reference accessible nor its output copied to current project output. This can be helpful for build time only dependencies - projects defining behavior that is going to be used as build step of a current project.\n+\n+Such a behavior can be achived with [`ReferenceOutputAssembly` metadata](https://learn.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference):\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This indicates that the referenced project should not be referenced in code and output should not be copied to output folder. \n+         This way we basically only indicate the build order.\n+    -->\n+    <ReferenceOutputAssembly>false</ReferenceOutputAssembly>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+**Note:** This technique doesn't fully work when referencing project with executable output type (`<OutputType>Exe</OutputType>`) - in such case the types defined within the project still cannot be referenced, however output is copied to the current project output folder. In that case we need to combine (or replace) the `ReferenceOutputAssembly` metadata with `Private` metadata - [as described above](#not-copying-projectreference).",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not sure I understand this. Is it something like \"once the first-level reference with overridden TF is hit, its references get normal TF resolution\", so you might get different TFs on a transitive reference and have them both build?",
              "createdAt": "2023-02-27T22:10:54Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.\n+\n+This can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```\n+ ---------------       ------------------       --------------\n+| Service Layer | --> | Repository Layer | --> | Domain Model |\n+ ---------------       ------------------       --------------\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+\t<LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+\t<DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+\t// This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+\t// private Domain.PersonTable _tbl;\n+}\n+```\n+\n+## Access to transitive package references\n+\n+The transitive access to dependencies works by default for package dependencies as well. This can be opted out via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets))\n+\n+*Example*:\n+\n+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This prevents the reference to be available to referencing types. -->\n+\t\t<PrivateAssets>compile</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+Then our `Service Layer` would have access to `newtonsoft.json` (unless opted out via `PrivateAssets=compile`):\n+\n+```csharp\n+namespace Service;\n+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.\n+//using Newtonsoft.Json;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+}\n+```\n+\n+## Not copying dependencies to output\n+\n+By default the above mentioned dependency types are being copied to build output directory during the build (provided the target failed [up-to-date check](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/incremental-builds?view=vs-2015&redirectedfrom=MSDN#output-inference) and run). There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).\n+\n+Overriding this logic depends on a type of dependency.\n+\n+### Not copying Assembly Reference\n+\n+Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):\n+\n+```xml\n+<ItemGroup>\n+  <Reference Include=\"mydll\">\n+    <HintPath>..\\somepath\\mydll.dll</HintPath>\n+    <!-- This indicates that the reference should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </Reference>\n+</ItemGroup>\n+```\n+\n+### Not copying PackageReference\n+\n+Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:\n+\n+**Not copying package dependency to the immediate output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->\n+\t\t<IncludeAssets>compile</IncludeAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency to the downstream dependants output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- The dependency is copied to output folder in current referencing project, \n+           but it's not copied to output folder of projects referencing current project. -->\n+\t\t<PrivateAssets>all</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency from the upstream dependencies:**\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->\n+    <ExcludeAssets>all</ExcludeAssets>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+### Not copying ProjectReference\n+\n+The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This indicates that the referenced project output should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+**Note:** There is possible need to explicitly specify `_GetChildProjectCopyToPublishDirectoryItems=false` to opt-out copying of project dependencies when builiding through [`MSBuilt` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) ([source](https://github.com/dotnet/msbuild/issues/4795#issuecomment-669885298))\n+\n+## ProjectReference without accessibility and copying to output\n+\n+In a specific scenarios we might want to indicate that specific project should be built prior our project but said project should not be reference accessible nor its output copied to current project output. This can be helpful for build time only dependencies - projects defining behavior that is going to be used as build step of a current project.\n+\n+Such a behavior can be achived with [`ReferenceOutputAssembly` metadata](https://learn.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference):\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This indicates that the referenced project should not be referenced in code and output should not be copied to output folder. \n+         This way we basically only indicate the build order.\n+    -->\n+    <ReferenceOutputAssembly>false</ReferenceOutputAssembly>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+**Note:** This technique doesn't fully work when referencing project with executable output type (`<OutputType>Exe</OutputType>`) - in such case the types defined within the project still cannot be referenced, however output is copied to the current project output folder. In that case we need to combine (or replace) the `ReferenceOutputAssembly` metadata with `Private` metadata - [as described above](#not-copying-projectreference).\n+\n+## Forcing TargetFramework of a referenced multitargeted project\n+\n+Consider agaoin our previous [Onion architecture example](#OnionArchSample), but now the individual projects will be [multitargeted](https://learn.microsoft.com/en-us/nuget/create-packages/multiple-target-frameworks-project-file). \n+\n+Repository Layer:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFrameworks>netstandard2.0;net48</TargetFrameworks>\n+  </PropertyGroup>\n+\n+  <ItemGroup Condition=\"'$(TargetFramework)' == 'net48'\">\n+    <ProjectReference Include=\"..\\Domain-net48\\Domain-net48.csproj\" />\n+    <PackageReference Include=\"System.Text.Json\" Version=\"7.0.2\" />\n+  </ItemGroup>\n+\n+  <ItemGroup Condition=\"'$(TargetFramework)' == 'netstandard2.0'\">\n+    <ProjectReference Include=\"..\\Domain-netstd20\\Domain-netstd20.csproj\" />\n+    <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+  </ItemGroup>\n+</Project>\n+```\n+\n+And it's going to be referenced by Service Layer:\n+\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <OutputType>Exe</OutputType>\n+    <TargetFrameworks>net48;netstandard2.0</TargetFrameworks>\n+  </PropertyGroup>\n+\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\"  />\n+  </ItemGroup>\n+</Project>\n+```\n+\n+Building the Service Layer will create output folders for `net7` and `net48`:\n+\n+```\n+net48\n+ |---- Repository.dll (targeted for net48)\n+ |---- Domain-net48.dll\n+ |---- System.Text.Json.dll\n+\n+net7\n+ |---- Repository.dll (targeted for netstandard2.0)\n+ |---- Domain-netstd20.dll\n+ |---- Newtonsoft.Json.dll \n+```\n+\n+Would we want to reference the netstandard version of the Repository Layer in our Service Layer - we can force the reference chain via `SetTargetFramework` metadata on `ProjectReference` item:\n+\n+```xml\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" SetTargetFramework=\"TargetFramework=netstandard2.0\" />\n+  </ItemGroup>\n+```\n+\n+**Notes:** \n+\n+This will properly enforce the framework for the dependency chain. The output folder will contain proper version of the direct dependency - Repository Layer. The transitive dependencies might overbuild, and output folder of current project (Service Layer) might contain both versions of the transitive project dependency (Domain-net48.dll and Domain-netstd20.dll). This limitation can be workarounded by switching of the transitive project dependencies via `DisableTransitiveProjectReferences` (same as shown in [Access to transitive project references](#access-to-transitive-project-references))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Based on this and above feedback I attempted to reformulate this: https://github.com/dotnet/msbuild/pull/8494/files#diff-b5dec84f84d1f113f1c8d8369daf2a8b4958736d3e02764f3bfbd42e42c4a917R243-R246\r\n\r\nReview would be appreciate - to make sure it's accurate and understandable",
              "createdAt": "2023-03-02T15:12:32Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,239 @@\n+# Controlling dependencies behavior\n+\n+MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+\n+## Access to transitive project references\n+\n+In [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) MSBuild by default makes all transitive `ProjectReference`s accessible as if they were direct dependencies.\n+\n+This can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```\n+ ---------------       ------------------       --------------\n+| Service Layer | --> | Repository Layer | --> | Domain Model |\n+ ---------------       ------------------       --------------\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+\t<LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+\t<DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+\t// This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+\t// private Domain.PersonTable _tbl;\n+}\n+```\n+\n+## Access to transitive package references\n+\n+The transitive access to dependencies works by default for package dependencies as well. This can be opted out via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets))\n+\n+*Example*:\n+\n+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This prevents the reference to be available to referencing types. -->\n+\t\t<PrivateAssets>compile</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+Then our `Service Layer` would have access to `newtonsoft.json` (unless opted out via `PrivateAssets=compile`):\n+\n+```csharp\n+namespace Service;\n+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.\n+//using Newtonsoft.Json;\n+\t\n+public class PersonsAccessor\n+{\n+\tprivate Repository.Persona _persona;\n+}\n+```\n+\n+## Not copying dependencies to output\n+\n+By default the above mentioned dependency types are being copied to build output directory during the build (provided the target failed [up-to-date check](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/incremental-builds?view=vs-2015&redirectedfrom=MSDN#output-inference) and run). There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).\n+\n+Overriding this logic depends on a type of dependency.\n+\n+### Not copying Assembly Reference\n+\n+Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):\n+\n+```xml\n+<ItemGroup>\n+  <Reference Include=\"mydll\">\n+    <HintPath>..\\somepath\\mydll.dll</HintPath>\n+    <!-- This indicates that the reference should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </Reference>\n+</ItemGroup>\n+```\n+\n+### Not copying PackageReference\n+\n+Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:\n+\n+**Not copying package dependency to the immediate output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->\n+\t\t<IncludeAssets>compile</IncludeAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency to the downstream dependants output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- The dependency is copied to output folder in current referencing project, \n+           but it's not copied to output folder of projects referencing current project. -->\n+\t\t<PrivateAssets>all</PrivateAssets>\n+\t</PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency from the upstream dependencies:**\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->\n+    <ExcludeAssets>all</ExcludeAssets>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+### Not copying ProjectReference\n+\n+The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This indicates that the referenced project output should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+**Note:** There is possible need to explicitly specify `_GetChildProjectCopyToPublishDirectoryItems=false` to opt-out copying of project dependencies when builiding through [`MSBuilt` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) ([source](https://github.com/dotnet/msbuild/issues/4795#issuecomment-669885298))\n+\n+## ProjectReference without accessibility and copying to output\n+\n+In a specific scenarios we might want to indicate that specific project should be built prior our project but said project should not be reference accessible nor its output copied to current project output. This can be helpful for build time only dependencies - projects defining behavior that is going to be used as build step of a current project.\n+\n+Such a behavior can be achived with [`ReferenceOutputAssembly` metadata](https://learn.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference):\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This indicates that the referenced project should not be referenced in code and output should not be copied to output folder. \n+         This way we basically only indicate the build order.\n+    -->\n+    <ReferenceOutputAssembly>false</ReferenceOutputAssembly>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+**Note:** This technique doesn't fully work when referencing project with executable output type (`<OutputType>Exe</OutputType>`) - in such case the types defined within the project still cannot be referenced, however output is copied to the current project output folder. In that case we need to combine (or replace) the `ReferenceOutputAssembly` metadata with `Private` metadata - [as described above](#not-copying-projectreference).\n+\n+## Forcing TargetFramework of a referenced multitargeted project\n+\n+Consider agaoin our previous [Onion architecture example](#OnionArchSample), but now the individual projects will be [multitargeted](https://learn.microsoft.com/en-us/nuget/create-packages/multiple-target-frameworks-project-file). \n+\n+Repository Layer:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFrameworks>netstandard2.0;net48</TargetFrameworks>\n+  </PropertyGroup>\n+\n+  <ItemGroup Condition=\"'$(TargetFramework)' == 'net48'\">\n+    <ProjectReference Include=\"..\\Domain-net48\\Domain-net48.csproj\" />\n+    <PackageReference Include=\"System.Text.Json\" Version=\"7.0.2\" />\n+  </ItemGroup>\n+\n+  <ItemGroup Condition=\"'$(TargetFramework)' == 'netstandard2.0'\">\n+    <ProjectReference Include=\"..\\Domain-netstd20\\Domain-netstd20.csproj\" />\n+    <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+  </ItemGroup>\n+</Project>\n+```\n+\n+And it's going to be referenced by Service Layer:\n+\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <OutputType>Exe</OutputType>\n+    <TargetFrameworks>net48;netstandard2.0</TargetFrameworks>\n+  </PropertyGroup>\n+\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\"  />\n+  </ItemGroup>\n+</Project>\n+```\n+\n+Building the Service Layer will create output folders for `net7` and `net48`:\n+\n+```\n+net48\n+ |---- Repository.dll (targeted for net48)\n+ |---- Domain-net48.dll\n+ |---- System.Text.Json.dll\n+\n+net7\n+ |---- Repository.dll (targeted for netstandard2.0)\n+ |---- Domain-netstd20.dll\n+ |---- Newtonsoft.Json.dll \n+```\n+\n+Would we want to reference the netstandard version of the Repository Layer in our Service Layer - we can force the reference chain via `SetTargetFramework` metadata on `ProjectReference` item:\n+\n+```xml\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" SetTargetFramework=\"TargetFramework=netstandard2.0\" />\n+  </ItemGroup>\n+```\n+\n+**Notes:** \n+\n+This will properly enforce the framework for the dependency chain. The output folder will contain proper version of the direct dependency - Repository Layer. The transitive dependencies might overbuild, and output folder of current project (Service Layer) might contain both versions of the transitive project dependency (Domain-net48.dll and Domain-netstd20.dll). This limitation can be workarounded by switching of the transitive project dependencies via `DisableTransitiveProjectReferences` (same as shown in [Access to transitive project references](#access-to-transitive-project-references))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nSDK build tasks require existence of this file (hence the infamous `Assets file <path>\\project.assets.json not found` if the MSBuild.exe is run without prior restore operation). It is used to reconstruct the `ProjectReference`s and create `Reference` items for the content of `PackageReference`s for the project and make them available to the rest of the build. For this reason MSBuild and compiler by default sees those transitive references as if they were direct references.\r\n```",
              "createdAt": "2023-03-24T16:31:38Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -1,23 +1,31 @@\n-# Controlling dependencies behavior\n+# Controlling references behavior\n \n-MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.\n \n-## Access to transitive project references\n+## .NET SDK projects and access to transitive references\n+\n+For [.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) restore operation by default makes all transitive references accessible as if they were direct references.\n+\n+This is required by the compiler and analyzers to be able to properly inspect the whole dependency or/and inheritance chain of types when deciding about particular checks.\n+\n+It is facilitated via `project.assets.json` file created by NuGet client during the restore operation. This file captures the whole transitive closure of the project dependency tree.\n+\n+SDK build tasks require existence of this file (hence the infamous `Assets file <path>\\project.assets.json not found` if the MSBuild.exe is run without prior restore operation). It is used to reconstruct the `ProjectReference`s and `PackageReference`s for the project and pass them to MSBuild. For this reason MSBuild and compiler by default sees those transitive references as if they were direct references.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Technically the _full_ closure isn't required by the compiler today, but the compiler team wishes it was, and new analysis can cause not-required-today assembly references to be required tomorrow.",
              "createdAt": "2023-03-24T16:32:42Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -1,23 +1,31 @@\n-# Controlling dependencies behavior\n+# Controlling references behavior\n \n-MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.\n \n-## Access to transitive project references\n+## .NET SDK projects and access to transitive references\n+\n+For [.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) restore operation by default makes all transitive references accessible as if they were direct references.\n+\n+This is required by the compiler and analyzers to be able to properly inspect the whole dependency or/and inheritance chain of types when deciding about particular checks.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Good point.  I reworded (required by -> provided for), to prevent incorrect statement.",
              "createdAt": "2023-03-28T11:57:16Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -1,23 +1,31 @@\n-# Controlling dependencies behavior\n+# Controlling references behavior\n \n-MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.\n \n-## Access to transitive project references\n+## .NET SDK projects and access to transitive references\n+\n+For [.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) restore operation by default makes all transitive references accessible as if they were direct references.\n+\n+This is required by the compiler and analyzers to be able to properly inspect the whole dependency or/and inheritance chain of types when deciding about particular checks.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n[.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) by default make all transitive references accessible as if they were direct references.\r\n```",
              "createdAt": "2023-03-24T16:33:16Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -1,23 +1,31 @@\n-# Controlling dependencies behavior\n+# Controlling references behavior\n \n-MSBuild recognizes [few types of dependencies](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the dependencies workings - transitive dependencies resolution, multitargeted references resolution, copying dependencies to output directory.\n+MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.\n \n-## Access to transitive project references\n+## .NET SDK projects and access to transitive references\n+\n+For [.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) restore operation by default makes all transitive references accessible as if they were direct references.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there actually a way to reference a package and not its transitive closure? `PrivateAssets` affects only things that reference you, so you would have to change the package you want to reference.",
              "createdAt": "2023-03-24T16:41:22Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -42,15 +50,15 @@ namespace Service;\n \t\n public class PersonsAccessor\n {\n-\tprivate Repository.Persona _persona;\n-\t// This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n-\t// private Domain.PersonTable _tbl;\n+    private Repository.Persona _persona;\n+    // This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+    // private Domain.PersonTable _tbl;\n }\n ```\n \n ## Access to transitive package references\n \n-The transitive access to dependencies works by default for package dependencies as well. This can be opted out via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets))\n+The transitive access to references works by default for package references as well. This can be opted out via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Correct. It was ment so in the example, but the description was very unclear and ambiguous.\r\n\r\nI attempted to clarify it and explicitly call out the behavior.",
              "createdAt": "2023-03-28T11:57:32Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -42,15 +50,15 @@ namespace Service;\n \t\n public class PersonsAccessor\n {\n-\tprivate Repository.Persona _persona;\n-\t// This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n-\t// private Domain.PersonTable _tbl;\n+    private Repository.Persona _persona;\n+    // This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+    // private Domain.PersonTable _tbl;\n }\n ```\n \n ## Access to transitive package references\n \n-The transitive access to dependencies works by default for package dependencies as well. This can be opted out via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets))\n+The transitive access to references works by default for package references as well. This can be opted out via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nWe are now able to influence access to `newtonsoft.json` and its dependencies (would there be any) in the `Repository Layer`, but we can prevent it from propagating to `Service Layer`.\r\n```\r\n\r\n?",
              "createdAt": "2023-04-17T18:40:04Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,262 @@\n+# Controlling references behavior\n+\n+MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.\n+\n+## .NET SDK projects and access to transitive references\n+\n+[.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) by default make all transitive references accessible as if they were direct references.\n+\n+This is provided for the compiler and analyzers to be able to properly inspect the whole dependency or/and inheritance chain of types when deciding about particular checks.\n+\n+It is facilitated via `project.assets.json` file created by NuGet client during the restore operation. This file captures the whole transitive closure of the project dependency tree.\n+\n+SDK build tasks require existence of this file (hence the infamous `Assets file <path>\\project.assets.json not found` if the MSBuild.exe is run without prior restore operation). It is used to reconstruct the `ProjectReference`s and create `Reference` items for the content of `PackageReference`s for the project and make them available to the rest of the build. For this reason MSBuild and compiler by default sees those transitive references as if they were direct references.\n+\n+## Access to transitive project references\n+\n+Above described behavior can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out for `ProjectReference`s via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```mermaid\n+flowchart LR\n+    Service[Service Layer] --> Repository\n+    Repository[Repository Layer] --> Domain[Domain Layer]\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+    <LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+    private Repository.Persona _persona;\n+    // This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+    // private Domain.PersonTable _tbl;\n+}\n+```\n+\n+## Access to transitive package references\n+\n+The transitive access to references works by default for package references as well. This can be opted out for referencing projects via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)).\n+\n+When using this metadatum - the access to the package, its dirrect and transitive dependencies is **not** restricted for the project declaring the refenerence on the package in its `Project` element. It is restricted for the projects referencing the project (or package) that specified the `PackageRegerence` with the `PrivateAssets` metadatum.\n+\n+*Example*:\n+\n+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:\n+\n+```mermaid\n+flowchart LR\n+    Service[Service Layer] --> Repository\n+    Repository[Repository Layer] --> newtonsoft.json[newtonsoft.json]\n+```\n+\n+We are not able to influence access to `newtonsoft.json` and its dependencies (would there be any) in the `Repository Layer`, but we can prevent it from propagating to `Service Layer`.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Worth mentioning that this is because the metadata is inherited to the point where it becomes an `@(Reference)` and then that logic takes over?",
              "createdAt": "2023-04-17T18:41:59Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,262 @@\n+# Controlling references behavior\n+\n+MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.\n+\n+## .NET SDK projects and access to transitive references\n+\n+[.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) by default make all transitive references accessible as if they were direct references.\n+\n+This is provided for the compiler and analyzers to be able to properly inspect the whole dependency or/and inheritance chain of types when deciding about particular checks.\n+\n+It is facilitated via `project.assets.json` file created by NuGet client during the restore operation. This file captures the whole transitive closure of the project dependency tree.\n+\n+SDK build tasks require existence of this file (hence the infamous `Assets file <path>\\project.assets.json not found` if the MSBuild.exe is run without prior restore operation). It is used to reconstruct the `ProjectReference`s and create `Reference` items for the content of `PackageReference`s for the project and make them available to the rest of the build. For this reason MSBuild and compiler by default sees those transitive references as if they were direct references.\n+\n+## Access to transitive project references\n+\n+Above described behavior can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out for `ProjectReference`s via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```mermaid\n+flowchart LR\n+    Service[Service Layer] --> Repository\n+    Repository[Repository Layer] --> Domain[Domain Layer]\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+    <LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+    private Repository.Persona _persona;\n+    // This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+    // private Domain.PersonTable _tbl;\n+}\n+```\n+\n+## Access to transitive package references\n+\n+The transitive access to references works by default for package references as well. This can be opted out for referencing projects via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)).\n+\n+When using this metadatum - the access to the package, its dirrect and transitive dependencies is **not** restricted for the project declaring the refenerence on the package in its `Project` element. It is restricted for the projects referencing the project (or package) that specified the `PackageRegerence` with the `PrivateAssets` metadatum.\n+\n+*Example*:\n+\n+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:\n+\n+```mermaid\n+flowchart LR\n+    Service[Service Layer] --> Repository\n+    Repository[Repository Layer] --> newtonsoft.json[newtonsoft.json]\n+```\n+\n+We are not able to influence access to `newtonsoft.json` and its dependencies (would there be any) in the `Repository Layer`, but we can prevent it from propagating to `Service Layer`.\n+\n+`Repository Layer`:\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This prevents the reference to be available to referencing types. -->\n+    <PrivateAssets>compile</PrivateAssets>\n+  </PackageReference>\n+</ItemGroup>\n+```\n+\n+Unless opted out via `PrivateAssets=compile`, our `Service Layer` would have access to `newtonsoft.json`:\n+\n+```csharp\n+namespace Service;\n+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.\n+//using Newtonsoft.Json;\n+\t\n+public class PersonsAccessor\n+{\n+    private Repository.Persona _persona;\n+}\n+```\n+\n+**Notes:**\n+   `PrivateAssets` metadatum (and it's counterparts `IncludeAssets` and `ExcludeAssets`) is applicable to `PackageReference` and controls exposure of dependencies to the consuming projects, not the current project. It is currently not possible to prevent access to package references from within directly referencing project - this is purely decision of the package itself (as it can define it's dependencies as `PrivateAssets`).\n+\n+## Not copying dependencies to output\n+\n+By default the above mentioned dependency types are copied to the build output directory during the build. There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).\n+\n+Overriding this logic depends on the type of the dependency.\n+\n+### Not copying Assembly Reference\n+\n+Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):\n+\n+```xml\n+<ItemGroup>\n+  <Reference Include=\"mydll\">\n+    <HintPath>..\\somepath\\mydll.dll</HintPath>\n+    <!-- This indicates that the reference should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </Reference>\n+</ItemGroup>\n+```\n+\n+### Not copying PackageReference\n+\n+Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:\n+\n+**Not copying package dependency to the immediate output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->\n+    <IncludeAssets>compile</IncludeAssets>\n+  </PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency to the downstream dependants output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- The dependency is copied to output folder in current referencing project, \n+           but it's not copied to output folder of projects referencing current project. -->\n+    <PrivateAssets>all</PrivateAssets>\n+  </PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency from the upstream dependencies:**\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->\n+    <ExcludeAssets>all</ExcludeAssets>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+### Not copying ProjectReference\n+\n+The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nShould we want to reference the netstandard version of the Repository Layer in our Service Layer - we can force the reference chain via `SetTargetFramework` metadata on `ProjectReference` item:\r\n```",
              "createdAt": "2023-04-17T18:43:01Z",
              "path": "documentation/wiki/Controlling-Dependencies-Behavior.md",
              "diffHunk": "@@ -0,0 +1,262 @@\n+# Controlling references behavior\n+\n+MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.\n+\n+## .NET SDK projects and access to transitive references\n+\n+[.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) by default make all transitive references accessible as if they were direct references.\n+\n+This is provided for the compiler and analyzers to be able to properly inspect the whole dependency or/and inheritance chain of types when deciding about particular checks.\n+\n+It is facilitated via `project.assets.json` file created by NuGet client during the restore operation. This file captures the whole transitive closure of the project dependency tree.\n+\n+SDK build tasks require existence of this file (hence the infamous `Assets file <path>\\project.assets.json not found` if the MSBuild.exe is run without prior restore operation). It is used to reconstruct the `ProjectReference`s and create `Reference` items for the content of `PackageReference`s for the project and make them available to the rest of the build. For this reason MSBuild and compiler by default sees those transitive references as if they were direct references.\n+\n+## Access to transitive project references\n+\n+Above described behavior can lead to easy unintentional breaking out of layering architecture separation. \n+\n+This behavior can be opted-out for `ProjectReference`s via `DisableTransitiveProjectReferences` property on the referencing project.\n+\n+<a name=\"OnionArchSample\"></a>*Example*:\n+\n+Let's imagine an `Onion Architecture` design:\n+\n+```mermaid\n+flowchart LR\n+    Service[Service Layer] --> Repository\n+    Repository[Repository Layer] --> Domain[Domain Layer]\n+```\n+\n+Service Layer definition:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <TargetFramework>net48</TargetFramework>\n+    <LangVersion>10</LangVersion>\n+    <!-- This prevents referencing types from transitive project references. -->\n+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>\n+  </PropertyGroup>\n+</Project>\n+```\n+\n+```csharp\n+namespace Service;\n+\t\n+public class PersonsAccessor\n+{\n+    private Repository.Persona _persona;\n+    // This is allowed unless DisableTransitiveProjectReferences=true is passed into build.\n+    // private Domain.PersonTable _tbl;\n+}\n+```\n+\n+## Access to transitive package references\n+\n+The transitive access to references works by default for package references as well. This can be opted out for referencing projects via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)).\n+\n+When using this metadatum - the access to the package, its dirrect and transitive dependencies is **not** restricted for the project declaring the refenerence on the package in its `Project` element. It is restricted for the projects referencing the project (or package) that specified the `PackageRegerence` with the `PrivateAssets` metadatum.\n+\n+*Example*:\n+\n+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:\n+\n+```mermaid\n+flowchart LR\n+    Service[Service Layer] --> Repository\n+    Repository[Repository Layer] --> newtonsoft.json[newtonsoft.json]\n+```\n+\n+We are not able to influence access to `newtonsoft.json` and its dependencies (would there be any) in the `Repository Layer`, but we can prevent it from propagating to `Service Layer`.\n+\n+`Repository Layer`:\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This prevents the reference to be available to referencing types. -->\n+    <PrivateAssets>compile</PrivateAssets>\n+  </PackageReference>\n+</ItemGroup>\n+```\n+\n+Unless opted out via `PrivateAssets=compile`, our `Service Layer` would have access to `newtonsoft.json`:\n+\n+```csharp\n+namespace Service;\n+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.\n+//using Newtonsoft.Json;\n+\t\n+public class PersonsAccessor\n+{\n+    private Repository.Persona _persona;\n+}\n+```\n+\n+**Notes:**\n+   `PrivateAssets` metadatum (and it's counterparts `IncludeAssets` and `ExcludeAssets`) is applicable to `PackageReference` and controls exposure of dependencies to the consuming projects, not the current project. It is currently not possible to prevent access to package references from within directly referencing project - this is purely decision of the package itself (as it can define it's dependencies as `PrivateAssets`).\n+\n+## Not copying dependencies to output\n+\n+By default the above mentioned dependency types are copied to the build output directory during the build. There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).\n+\n+Overriding this logic depends on the type of the dependency.\n+\n+### Not copying Assembly Reference\n+\n+Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):\n+\n+```xml\n+<ItemGroup>\n+  <Reference Include=\"mydll\">\n+    <HintPath>..\\somepath\\mydll.dll</HintPath>\n+    <!-- This indicates that the reference should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </Reference>\n+</ItemGroup>\n+```\n+\n+### Not copying PackageReference\n+\n+Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:\n+\n+**Not copying package dependency to the immediate output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->\n+    <IncludeAssets>compile</IncludeAssets>\n+  </PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency to the downstream dependants output folder:**\n+\n+```xml\n+<ItemGroup>\n+  <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+    <!-- The dependency is copied to output folder in current referencing project, \n+           but it's not copied to output folder of projects referencing current project. -->\n+    <PrivateAssets>all</PrivateAssets>\n+  </PackageReference>\n+</ItemGroup>\n+```\n+\n+**Not copying package dependency from the upstream dependencies:**\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->\n+    <ExcludeAssets>all</ExcludeAssets>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+### Not copying ProjectReference\n+\n+The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This indicates that the referenced project output should not be copied to output folder. -->\n+    <Private>false</Private>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+## ProjectReference without accessibility and copying to output\n+\n+In a specific scenarios we might want to indicate that specific project should be built prior our project but said project should not be reference accessible nor its output copied to current project output. This can be helpful for build time only dependencies - projects defining behavior that is going to be used as build step of a current project.\n+\n+Such a behavior can be achived with [`ReferenceOutputAssembly` metadata](https://learn.microsoft.com/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference):\n+\n+```xml\n+<ItemGroup>\n+  <ProjectReference Include=\"../somepath/MyProj.csproj\">\n+    <!-- This indicates that the referenced project should not be referenced in code and output should not be copied to output folder. \n+         This way we basically only indicate the build order.\n+    -->\n+    <ReferenceOutputAssembly>false</ReferenceOutputAssembly>\n+  </ProjectReference>\n+</ItemGroup>\n+```\n+\n+**Note:** This technique has possibly unexpected behavior when referencing project with executable output type (`<OutputType>Exe</OutputType>`) - in such case the output assembly (`.dll`) is still not copied and referenced (as the metadatum name implies) and hence the types defined within the project cannot be referenced, however other supplementary output (added as `content` or `none`) is copied to the current project output folder (for .NET Core this includes `deps.json`, `runtimeconfig.json` and mainly `<app>.exe`). In that case we can combine (or replace) the `ReferenceOutputAssembly` metadata with `Private` metadata - [as described above](#not-copying-projectreference). More details on this case [here](https://github.com/dotnet/msbuild/issues/4795#issuecomment-1442390297)\n+\n+## Forcing TargetFramework of a referenced multitargeted project\n+\n+Consider agaoin our previous [Onion architecture example](#OnionArchSample), but now the individual projects will be [multitargeted](https://learn.microsoft.com/nuget/create-packages/multiple-target-frameworks-project-file). \n+\n+Repository Layer:\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <TargetFrameworks>netstandard2.0;net48</TargetFrameworks>\n+  </PropertyGroup>\n+\n+  <ItemGroup Condition=\"'$(TargetFramework)' == 'net48'\">\n+    <ProjectReference Include=\"..\\Domain-net48\\Domain-net48.csproj\" />\n+    <PackageReference Include=\"System.Text.Json\" Version=\"7.0.2\" />\n+  </ItemGroup>\n+\n+  <ItemGroup Condition=\"'$(TargetFramework)' == 'netstandard2.0'\">\n+    <ProjectReference Include=\"..\\Domain-netstd20\\Domain-netstd20.csproj\" />\n+    <PackageReference Include=\"newtonsoft.json\" Version=\"13.0.1\">\n+  </ItemGroup>\n+</Project>\n+```\n+\n+And it's going to be referenced by Service Layer:\n+\n+\n+```xml\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+  <PropertyGroup>\n+    <OutputType>Exe</OutputType>\n+    <TargetFrameworks>net48;netstandard2.0</TargetFrameworks>\n+  </PropertyGroup>\n+\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\Repository\\Repository.csproj\"  />\n+  </ItemGroup>\n+</Project>\n+```\n+\n+Building the Service Layer will create output folders for `net7` and `net48`:\n+\n+```\n+net48\n+ |---- Repository.dll (targeted for net48)\n+ |---- Domain-net48.dll\n+ |---- System.Text.Json.dll\n+\n+net7\n+ |---- Repository.dll (targeted for netstandard2.0)\n+ |---- Domain-netstd20.dll\n+ |---- Newtonsoft.Json.dll \n+```\n+\n+Would we want to reference the netstandard version of the Repository Layer in our Service Layer - we can force the reference chain via `SetTargetFramework` metadata on `ProjectReference` item:",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}