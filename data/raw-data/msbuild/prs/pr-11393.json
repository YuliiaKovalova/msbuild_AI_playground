{
  "number": 11393,
  "title": "Support launching net taskhost - initial implementation",
  "body": "Partially Fixes https://github.com/dotnet/msbuild/issues/11331\r\n\r\nTo test the feature, setup these env variables:\r\n`MSBuildToolsDirectoryNET` = e.g. \"C:\\msbuild\\msbuild_yk\\msbuild\\artifacts\\bin\\bootstrap\\core\"\r\n`MSBuildAssemblyDirectory` = e.g. \"C:\\msbuild\\msbuild_yk\\msbuild\\artifacts\\bin\\bootstrap\\core\\sdk\\9.0.203\"\r\n\r\nKeep in mind, due to current handshake mechanism,  only matching (or adjusted with this change) version of sdk can be launched.\r\n\r\nThe tests are commented because we don't expect them to run now for NET runtime. There is a separate task to cover this functionality.\r\n",
  "state": "OPEN",
  "createdAt": "2025-02-05T13:43:01Z",
  "updatedAt": "2025-06-02T13:12:15Z",
  "closedAt": null,
  "mergedAt": null,
  "additions": 309,
  "deletions": 169,
  "changedFiles": 22,
  "headRefName": "dev/ykovalova/support_launching_net_taskhost",
  "isDraft": false,
  "author": {
    "login": "YuliiaKovalova"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "YuliiaKovalova"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "cd3ef65ce3cd5f0b74e1c6a6be20b1cf8555ba84",
          "message": "Bump to 9.0.100-rc.2.24474.11",
          "committedDate": "2024-10-09T17:56:23Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c1ebe41ce6ed3041c7492db1ce28f2f62cc30d2b",
          "message": "Merge branch 'dotnet:main' into main",
          "committedDate": "2024-10-15T13:34:02Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f840c14b54b6f9acb9fa2d5d2fe94728f811dad0",
          "message": "Merge branch 'dotnet:main' into main",
          "committedDate": "2024-10-23T13:02:48Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d3eff6e8c2536b8b9f8ba440d09334e540f1605d",
          "message": "Merge branch 'dotnet:main' into main",
          "committedDate": "2024-10-29T10:41:56Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5791ace836d751ed07de3a4d7ce1f93ecbfe1adf",
          "message": "Merge branch 'dotnet:main' into main",
          "committedDate": "2024-12-16T13:44:11Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6a24f4c24b791b6581e4498f1d4b954106a423a7",
          "message": "Merge branch 'dotnet:main' into main",
          "committedDate": "2025-01-07T10:32:11Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "35f93e1cb668a9e310f8b4e60c9f8d304f711ade",
          "message": "Merge branch 'dotnet:main' into main",
          "committedDate": "2025-03-03T10:20:07Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "97c5286230ad60b0888e6a5d58b08eb44e00d23e",
          "message": "Merge branch 'dotnet:main' into main",
          "committedDate": "2025-05-22T10:00:38Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "86dacaa37092c7a12d6f23fac9175db972cfd110",
          "message": "Merge branch 'dotnet:main' into main",
          "committedDate": "2025-05-27T13:39:25Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "17589bbbe0bc149e15209dcd8a2ae886af49ca06",
          "message": "merge with main",
          "committedDate": "2025-05-29T15:14:37Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "151e820c1064ed14d6dd88709b0d71efe83255e9",
          "message": "fix review comments",
          "committedDate": "2025-06-02T12:52:59Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eaf463daa328809574eba843e96e6069a886fad0",
          "message": "update access modifier",
          "committedDate": "2025-06-02T12:55:25Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "[ExampleNetTask.zip](https://github.com/user-attachments/files/18673573/ExampleNetTask.zip)\r\n",
        "createdAt": "2025-02-05T14:17:25Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: this won't be an exe on non-Windows platforms",
              "createdAt": "2025-02-12T15:12:44Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs",
              "diffHunk": "@@ -385,12 +390,9 @@ internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostConte\n                 {\n                     s_msbuildName = Environment.GetEnvironmentVariable(\"MSBUILD_EXE_NAME\");\n \n-                    if (s_msbuildName == null)\n-                    {\n-                        s_msbuildName = (hostContext & HandshakeOptions.NET) == HandshakeOptions.NET\n-                            ? \"MSBuild.dll\"\n+                    s_msbuildName ??= (hostContext & HandshakeOptions.NET) == HandshakeOptions.NET\n+                            ? \"dotnet.exe\"",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "future/question: I think longer-term we want to try and run the SDK resolver to get the path to dotnet, right?",
              "createdAt": "2025-02-12T15:13:52Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs",
              "diffHunk": "@@ -445,40 +449,43 @@ internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostCo\n \n                 toolPath = s_pathToX32Clr2;\n             }\n-            else if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64)\n+            else if (IsHandshakeOptionEnabled(HandshakeOptions.X64) && !IsHandshakeOptionEnabled(HandshakeOptions.NET))\n             {\n-                if (s_pathToX64Clr4 == null)\n-                {\n-                    s_pathToX64Clr4 = s_baseTaskHostPath64;\n-                }\n+                s_pathToX64Clr4 ??= s_baseTaskHostPath64;\n \n                 toolPath = s_pathToX64Clr4;\n             }\n-            else if ((hostContext & HandshakeOptions.Arm64) == HandshakeOptions.Arm64)\n+            else if (IsHandshakeOptionEnabled(HandshakeOptions.Arm64))\n             {\n-                if (s_pathToArm64Clr4 == null)\n-                {\n-                    s_pathToArm64Clr4 = s_baseTaskHostPathArm64;\n-                }\n+                s_pathToArm64Clr4 ??= s_baseTaskHostPathArm64;\n \n                 toolPath = s_pathToArm64Clr4;\n             }\n-            else\n+            else if (IsHandshakeOptionEnabled(HandshakeOptions.NET))\n             {\n-                if (s_pathToX32Clr4 == null)\n+                // if we want some flexibility in the future, we can add a new environment variable for this.\n+                var envTaskHostPathNet = Environment.GetEnvironmentVariable(\"DOTNET_HOST_PATH\");",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "yes, but in this initial PR we agreed to rely on env variable",
              "createdAt": "2025-02-13T13:51:09Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs",
              "diffHunk": "@@ -445,40 +449,43 @@ internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostCo\n \n                 toolPath = s_pathToX32Clr2;\n             }\n-            else if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64)\n+            else if (IsHandshakeOptionEnabled(HandshakeOptions.X64) && !IsHandshakeOptionEnabled(HandshakeOptions.NET))\n             {\n-                if (s_pathToX64Clr4 == null)\n-                {\n-                    s_pathToX64Clr4 = s_baseTaskHostPath64;\n-                }\n+                s_pathToX64Clr4 ??= s_baseTaskHostPath64;\n \n                 toolPath = s_pathToX64Clr4;\n             }\n-            else if ((hostContext & HandshakeOptions.Arm64) == HandshakeOptions.Arm64)\n+            else if (IsHandshakeOptionEnabled(HandshakeOptions.Arm64))\n             {\n-                if (s_pathToArm64Clr4 == null)\n-                {\n-                    s_pathToArm64Clr4 = s_baseTaskHostPathArm64;\n-                }\n+                s_pathToArm64Clr4 ??= s_baseTaskHostPathArm64;\n \n                 toolPath = s_pathToArm64Clr4;\n             }\n-            else\n+            else if (IsHandshakeOptionEnabled(HandshakeOptions.NET))\n             {\n-                if (s_pathToX32Clr4 == null)\n+                // if we want some flexibility in the future, we can add a new environment variable for this.\n+                var envTaskHostPathNet = Environment.GetEnvironmentVariable(\"DOTNET_HOST_PATH\");",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "the rest of these arguments (node reuse/priority) should be applied to the .NET-host command line too, right?",
              "createdAt": "2025-02-12T15:15:01Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs",
              "diffHunk": "@@ -536,24 +543,33 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor\n                 return false;\n             }\n \n-            // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we\n-            // want to start up an MSBuild task host node.\n-            string commandLineArgs = $\" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority} \";\n-\n-            string msbuildLocation = GetMSBuildLocationFromHostContext(hostContext);\n+            (string msbuildExecutable, string msbuildAssemblyLocation) = GetMSBuildLocationFromHostContext(hostContext);\n \n             // we couldn't even figure out the location we're trying to launch ... just go ahead and fail.\n-            if (msbuildLocation == null)\n+            if (msbuildExecutable == null)\n             {\n                 return false;\n             }\n \n-            CommunicationsUtilities.Trace(\"For a host context of {0}, spawning executable from {1}.\", hostContext.ToString(), msbuildLocation ?? \"MSBuild.exe\");\n+            string commandLineArgs;\n+            if (msbuildAssemblyLocation != null)\n+            {\n+                // For dotnet.exe, the dll path must come first, then -- to separate application arguments\n+                commandLineArgs = $\"\\\"{msbuildAssemblyLocation}\\\" -- /nodemode:2 \";\n+            }\n+            else\n+            {\n+                // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we\n+                // want to start up an MSBuild task host node.\n+                commandLineArgs = $\"/nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority}\";",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "not sure\r\n@rainersigwald could you clarify this point, please?",
              "createdAt": "2025-02-12T15:28:31Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs",
              "diffHunk": "@@ -536,24 +543,33 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor\n                 return false;\n             }\n \n-            // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we\n-            // want to start up an MSBuild task host node.\n-            string commandLineArgs = $\" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority} \";\n-\n-            string msbuildLocation = GetMSBuildLocationFromHostContext(hostContext);\n+            (string msbuildExecutable, string msbuildAssemblyLocation) = GetMSBuildLocationFromHostContext(hostContext);\n \n             // we couldn't even figure out the location we're trying to launch ... just go ahead and fail.\n-            if (msbuildLocation == null)\n+            if (msbuildExecutable == null)\n             {\n                 return false;\n             }\n \n-            CommunicationsUtilities.Trace(\"For a host context of {0}, spawning executable from {1}.\", hostContext.ToString(), msbuildLocation ?? \"MSBuild.exe\");\n+            string commandLineArgs;\n+            if (msbuildAssemblyLocation != null)\n+            {\n+                // For dotnet.exe, the dll path must come first, then -- to separate application arguments\n+                commandLineArgs = $\"\\\"{msbuildAssemblyLocation}\\\" -- /nodemode:2 \";\n+            }\n+            else\n+            {\n+                // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we\n+                // want to start up an MSBuild task host node.\n+                commandLineArgs = $\"/nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority}\";",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Yes, they should.",
              "createdAt": "2025-05-30T16:45:45Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs",
              "diffHunk": "@@ -536,24 +543,33 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor\n                 return false;\n             }\n \n-            // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we\n-            // want to start up an MSBuild task host node.\n-            string commandLineArgs = $\" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority} \";\n-\n-            string msbuildLocation = GetMSBuildLocationFromHostContext(hostContext);\n+            (string msbuildExecutable, string msbuildAssemblyLocation) = GetMSBuildLocationFromHostContext(hostContext);\n \n             // we couldn't even figure out the location we're trying to launch ... just go ahead and fail.\n-            if (msbuildLocation == null)\n+            if (msbuildExecutable == null)\n             {\n                 return false;\n             }\n \n-            CommunicationsUtilities.Trace(\"For a host context of {0}, spawning executable from {1}.\", hostContext.ToString(), msbuildLocation ?? \"MSBuild.exe\");\n+            string commandLineArgs;\n+            if (msbuildAssemblyLocation != null)\n+            {\n+                // For dotnet.exe, the dll path must come first, then -- to separate application arguments\n+                commandLineArgs = $\"\\\"{msbuildAssemblyLocation}\\\" -- /nodemode:2 \";\n+            }\n+            else\n+            {\n+                // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we\n+                // want to start up an MSBuild task host node.\n+                commandLineArgs = $\"/nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority}\";",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@rainersigwald , it's a question for you when you will review :)",
              "createdAt": "2025-02-14T16:58:25Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -332,11 +332,13 @@ public bool InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket bat\n                 return false;\n             }\n \n-            string realTaskAssemblyLoaction = TaskInstance.GetType().Assembly.Location;\n-            if (!string.IsNullOrWhiteSpace(realTaskAssemblyLoaction) &&\n-                realTaskAssemblyLoaction != _taskFactoryWrapper.TaskFactoryLoadedType.Path)\n+            // TODO ask why for net task host it returns false net472\\MSBuild\\Current\\Bin\\Microsoft.Build.dll instead of path to a custom task.\n+            // Interestingly TaskInstance._taskType contains the correct path.",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "I think that's because `TaskHostTask` is always going to be a type loaded from the currently running code--but it _wraps_ a task from some other assembly, which is what we actually care about for this message, right?. Looks like a preexisting bug where we log this for all TaskHostTasks.",
              "createdAt": "2025-05-30T17:23:57Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -332,11 +332,13 @@ public bool InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket bat\n                 return false;\n             }\n \n-            string realTaskAssemblyLoaction = TaskInstance.GetType().Assembly.Location;\n-            if (!string.IsNullOrWhiteSpace(realTaskAssemblyLoaction) &&\n-                realTaskAssemblyLoaction != _taskFactoryWrapper.TaskFactoryLoadedType.Path)\n+            // TODO ask why for net task host it returns false net472\\MSBuild\\Current\\Bin\\Microsoft.Build.dll instead of path to a custom task.\n+            // Interestingly TaskInstance._taskType contains the correct path.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The syntax used to initialize _versionHandshakeGroup is invalid; use a proper collection initializer such as 'new List<string> { \"fileVersionMajor\", \"fileVersionMinor\", \"fileVersionBuild\", \"fileVersionPrivate\" }'.\n```suggestion\n        private readonly IList<string> _versionHandshakeGroup = new List<string> { \"fileVersionMajor\", \"fileVersionMinor\", \"fileVersionBuild\", \"fileVersionPrivate\" };\n```",
              "createdAt": "2025-04-03T09:15:26Z",
              "path": "src/Shared/NodeEndpointOutOfProcBase.cs",
              "diffHunk": "@@ -115,6 +116,11 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint\n         /// </summary>\n         private BinaryWriter _binaryWriter;\n \n+        /// <summary>\n+        /// The set of property names from handshake responsible for node version./>\n+        /// </summary>\n+        private readonly IList<string> _versionHandshakeGroup = [\"fileVersionMajor\", \"fileVersionMinor\", \"fileVersionBuild\", \"fileVersionPrivate\"];\n+",
              "author": {
                "login": "copilot-pull-request-reviewer"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "[nitpick] The property name 'msbuildExcutable' appears to be misspelled; consider renaming it to 'msbuildExecutable' for clarity.\n```suggestion\n            string msbuildLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(requiredContext).msbuildExecutable ??\n```",
              "createdAt": "2025-04-03T09:15:26Z",
              "path": "src/Build/Instance/TaskFactories/TaskHostTask.cs",
              "diffHunk": "@@ -569,7 +570,7 @@ private void HandleLoggedMessage(LogMessagePacket logMessagePacket)\n         /// </summary>\n         private void LogErrorUnableToCreateTaskHost(HandshakeOptions requiredContext, string runtime, string architecture, NodeFailedToLaunchException e)\n         {\n-            string msbuildLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(requiredContext) ??\n+            string msbuildLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(requiredContext).msbuildExcutable ??",
              "author": {
                "login": "copilot-pull-request-reviewer"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think I understand this change, why are they full-framework-only?",
              "createdAt": "2025-05-30T16:26:17Z",
              "path": "src/Build.UnitTests/BackEnd/BuildManager_Tests.cs",
              "diffHunk": "@@ -1725,7 +1725,7 @@ public void CancelledBuildWithDelay40_WithThreatSwap()\n         /// A canceled build which waits for the task to get started before canceling.  Because it is a 12.0 task, we should\n         /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly.\n         /// </summary>\n-        [Fact]\n+        [WindowsFullFrameworkOnlyFact]",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe a quick comment about why this is returning the tuples?",
              "createdAt": "2025-05-30T16:40:15Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -125,24 +141,18 @@ protected Handshake(HandshakeOptions nodeType, bool includeSessionId)\n         }\n \n         // This is used as a key, so it does not need to be human readable.\n-        public override string ToString()\n-        {\n-            return $\"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}\";\n-        }\n-\n-        public virtual int[] RetrieveHandshakeComponents()\n-        {\n-            return\n-            [\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)\n-            ];\n-        }\n+        public override string ToString() => String.Format(\"{0} {1} {2} {3} {4} {5} {6}\", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);\n+\n+        public virtual KeyValuePair<string, int>[] RetrieveHandshakeComponents() =>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Actually, what if we made it a class with named fields and a custom `ToString()` instead, I feel like that'd be clearer.",
              "createdAt": "2025-05-30T17:38:05Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -125,24 +141,18 @@ protected Handshake(HandshakeOptions nodeType, bool includeSessionId)\n         }\n \n         // This is used as a key, so it does not need to be human readable.\n-        public override string ToString()\n-        {\n-            return $\"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}\";\n-        }\n-\n-        public virtual int[] RetrieveHandshakeComponents()\n-        {\n-            return\n-            [\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)\n-            ];\n-        }\n+        public override string ToString() => String.Format(\"{0} {1} {2} {3} {4} {5} {6}\", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);\n+\n+        public virtual KeyValuePair<string, int>[] RetrieveHandshakeComponents() =>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "done",
              "createdAt": "2025-06-02T13:12:14Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -125,24 +141,18 @@ protected Handshake(HandshakeOptions nodeType, bool includeSessionId)\n         }\n \n         // This is used as a key, so it does not need to be human readable.\n-        public override string ToString()\n-        {\n-            return $\"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}\";\n-        }\n-\n-        public virtual int[] RetrieveHandshakeComponents()\n-        {\n-            return\n-            [\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),\n-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)\n-            ];\n-        }\n+        public override string ToString() => String.Format(\"{0} {1} {2} {3} {4} {5} {6}\", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);\n+\n+        public virtual KeyValuePair<string, int>[] RetrieveHandshakeComponents() =>",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this fire on the net-to-net taskhost use, like if you use `TaskHostFactory` in `dotnet build`? If so, should it?",
              "createdAt": "2025-05-30T16:41:16Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -106,15 +108,29 @@ protected Handshake(HandshakeOptions nodeType, bool includeSessionId)\n             CommunicationsUtilities.Trace(\"Building handshake for node type {0}, (version {1}): options {2}.\", nodeType, handshakeVersion, options);\n \n             string handshakeSalt = Environment.GetEnvironmentVariable(\"MSBUILDNODEHANDSHAKESALT\");\n-            CommunicationsUtilities.Trace(\"Handshake salt is {0}\", handshakeSalt);\n-            string toolsDirectory = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;\n+            CommunicationsUtilities.Trace(\"Handshake salt is \" + handshakeSalt);\n+            bool isNetTaskHost = (nodeType & HandshakeOptions.NET) == HandshakeOptions.NET;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think I get this.",
              "createdAt": "2025-05-30T16:42:20Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -106,15 +108,29 @@ protected Handshake(HandshakeOptions nodeType, bool includeSessionId)\n             CommunicationsUtilities.Trace(\"Building handshake for node type {0}, (version {1}): options {2}.\", nodeType, handshakeVersion, options);\n \n             string handshakeSalt = Environment.GetEnvironmentVariable(\"MSBUILDNODEHANDSHAKESALT\");\n-            CommunicationsUtilities.Trace(\"Handshake salt is {0}\", handshakeSalt);\n-            string toolsDirectory = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;\n+            CommunicationsUtilities.Trace(\"Handshake salt is \" + handshakeSalt);\n+            bool isNetTaskHost = (nodeType & HandshakeOptions.NET) == HandshakeOptions.NET;\n+            string toolsDirectory = isNetTaskHost\n+                ? BuildEnvironmentHelper.Instance.MSBuildAssemblyDirectory\n+                : BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It comes from https://github.com/dotnet/msbuild/blob/17589bbbe0bc149e15209dcd8a2ae886af49ca06/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs#L476\r\n\r\nfor msbuild.exe it's constructed here: https://github.com/dotnet/msbuild/blob/585b8739176cab9b428d90ecb50d5361763ed68e/src/Shared/BuildEnvironmentHelper.cs#L604 \r\nit's very different of the receiving end",
              "createdAt": "2025-06-02T09:57:13Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -106,15 +108,29 @@ protected Handshake(HandshakeOptions nodeType, bool includeSessionId)\n             CommunicationsUtilities.Trace(\"Building handshake for node type {0}, (version {1}): options {2}.\", nodeType, handshakeVersion, options);\n \n             string handshakeSalt = Environment.GetEnvironmentVariable(\"MSBUILDNODEHANDSHAKESALT\");\n-            CommunicationsUtilities.Trace(\"Handshake salt is {0}\", handshakeSalt);\n-            string toolsDirectory = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;\n+            CommunicationsUtilities.Trace(\"Handshake salt is \" + handshakeSalt);\n+            bool isNetTaskHost = (nodeType & HandshakeOptions.NET) == HandshakeOptions.NET;\n+            string toolsDirectory = isNetTaskHost\n+                ? BuildEnvironmentHelper.Instance.MSBuildAssemblyDirectory\n+                : BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "it's from dotnet.exe\r\n<img width=\"737\" alt=\"{7BF1B8DE-55E3-41D7-9D98-D9A08CEEB5A8}\" src=\"https://github.com/user-attachments/assets/621793e3-f0e2-4b6a-9406-04ec50f2087a\" />\r\n\r\nand from msbuild.exe\r\n<img width=\"1359\" alt=\"{A5DED011-ADE5-44A8-8A3B-E2CC99DB5E4A}\" src=\"https://github.com/user-attachments/assets/0fca5848-a4af-4f4c-b7a9-47928d68314f\" />\r\n",
              "createdAt": "2025-06-02T11:50:23Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -106,15 +108,29 @@ protected Handshake(HandshakeOptions nodeType, bool includeSessionId)\n             CommunicationsUtilities.Trace(\"Building handshake for node type {0}, (version {1}): options {2}.\", nodeType, handshakeVersion, options);\n \n             string handshakeSalt = Environment.GetEnvironmentVariable(\"MSBUILDNODEHANDSHAKESALT\");\n-            CommunicationsUtilities.Trace(\"Handshake salt is {0}\", handshakeSalt);\n-            string toolsDirectory = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;\n+            CommunicationsUtilities.Trace(\"Handshake salt is \" + handshakeSalt);\n+            bool isNetTaskHost = (nodeType & HandshakeOptions.NET) == HandshakeOptions.NET;\n+            string toolsDirectory = isNetTaskHost\n+                ? BuildEnvironmentHelper.Instance.MSBuildAssemblyDirectory\n+                : BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this temporary until #11543? If so please comment that. If not, I don't think I understand how this is a \"build environment\" concept.",
              "createdAt": "2025-05-30T16:43:57Z",
              "path": "src/Shared/BuildEnvironmentHelper.cs",
              "diffHunk": "@@ -662,6 +664,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA\n         /// </summary>\n         internal string MSBuildToolsDirectoryArm64 { get; }\n \n+        /// <summary>\n+        /// Path to the NET tools directory.\n+        /// </summary>\n+        internal string MSBuildToolsDirectoryNET { get; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "there is also this https://github.com/dotnet/msbuild/blob/585b8739176cab9b428d90ecb50d5361763ed68e/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs#L51-L55 for path to executing dotnet.exe",
              "createdAt": "2025-05-30T19:12:10Z",
              "path": "src/Shared/BuildEnvironmentHelper.cs",
              "diffHunk": "@@ -662,6 +664,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA\n         /// </summary>\n         internal string MSBuildToolsDirectoryArm64 { get; }\n \n+        /// <summary>\n+        /// Path to the NET tools directory.\n+        /// </summary>\n+        internal string MSBuildToolsDirectoryNET { get; }",
              "author": {
                "login": "kasperk81"
              }
            },
            {
              "body": "https://learn.microsoft.com/dotnet/core/tools/dotnet-environment-variables#dotnet_host_path",
              "createdAt": "2025-05-30T19:16:24Z",
              "path": "src/Shared/BuildEnvironmentHelper.cs",
              "diffHunk": "@@ -662,6 +664,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA\n         /// </summary>\n         internal string MSBuildToolsDirectoryArm64 { get; }\n \n+        /// <summary>\n+        /// Path to the NET tools directory.\n+        /// </summary>\n+        internal string MSBuildToolsDirectoryNET { get; }",
              "author": {
                "login": "kasperk81"
              }
            },
            {
              "body": "Ours has to be fairly substantially different because we can't rely on being in an environment that sets a good `DOTNET_HOST_PATH` (for example when we're running inside Visual Studio).\r\n\r\nThis part is going to change a lot before the final version.",
              "createdAt": "2025-05-30T19:48:19Z",
              "path": "src/Shared/BuildEnvironmentHelper.cs",
              "diffHunk": "@@ -662,6 +664,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA\n         /// </summary>\n         internal string MSBuildToolsDirectoryArm64 { get; }\n \n+        /// <summary>\n+        /// Path to the NET tools directory.\n+        /// </summary>\n+        internal string MSBuildToolsDirectoryNET { get; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "> for example when we're running inside Visual Studio\r\n\r\nbtw DOTNET_HOST_PATH is also set in VS for SDK projects, but not for netfx projects. maybe adding it for probe \"if available, use it\" makes sense at some level?",
              "createdAt": "2025-05-30T20:13:15Z",
              "path": "src/Shared/BuildEnvironmentHelper.cs",
              "diffHunk": "@@ -662,6 +664,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA\n         /// </summary>\n         internal string MSBuildToolsDirectoryArm64 { get; }\n \n+        /// <summary>\n+        /// Path to the NET tools directory.\n+        /// </summary>\n+        internal string MSBuildToolsDirectoryNET { get; }",
              "author": {
                "login": "kasperk81"
              }
            },
            {
              "body": "I don't see that behavior, what makes you say that?\r\n\r\nTo test I added a target to a template .NET project:\r\n\r\n```xml\r\n\t<Target Name=\"LogHostPath\" BeforeTargets=\"BeforeBuild\">\r\n\t\t<Warning Text=\"DOTNET_HOST_PATH is $(DOTNET_HOST_PATH)\" />\r\n\t</Target>\r\n```",
              "createdAt": "2025-05-30T20:46:08Z",
              "path": "src/Shared/BuildEnvironmentHelper.cs",
              "diffHunk": "@@ -662,6 +664,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA\n         /// </summary>\n         internal string MSBuildToolsDirectoryArm64 { get; }\n \n+        /// <summary>\n+        /// Path to the NET tools directory.\n+        /// </summary>\n+        internal string MSBuildToolsDirectoryNET { get; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "ops it goes like this:\r\n\r\n```xml\r\n\t<Target Name=\"LogHostPath\" BeforeTargets=\"BeforeBuild\">\r\n\t\t<Warning Text=\"DOTNET_HOST_PATH is $(DOTNET_HOST_PATH)\" Condition=\"'$(DOTNET_HOST_PATH)' != ''\" />\r\n\t\t<Warning Text=\"NetCoreRoot is $(NetCoreRoot)\\dotnet.exe\" Condition=\"'$(DOTNET_HOST_PATH)' == ''\" />\r\n\t</Target>\r\n```",
              "createdAt": "2025-05-30T21:23:49Z",
              "path": "src/Shared/BuildEnvironmentHelper.cs",
              "diffHunk": "@@ -662,6 +664,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA\n         /// </summary>\n         internal string MSBuildToolsDirectoryArm64 { get; }\n \n+        /// <summary>\n+        /// Path to the NET tools directory.\n+        /// </summary>\n+        internal string MSBuildToolsDirectoryNET { get; }",
              "author": {
                "login": "kasperk81"
              }
            },
            {
              "body": "Ah, yes--that's helpful for the `dotnet.exe` path but insufficient to get the path to `MSBuild.dll`, which needs some additional data that we set in https://github.com/dotnet/sdk/pull/45364.",
              "createdAt": "2025-05-30T21:43:28Z",
              "path": "src/Shared/BuildEnvironmentHelper.cs",
              "diffHunk": "@@ -662,6 +664,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA\n         /// </summary>\n         internal string MSBuildToolsDirectoryArm64 { get; }\n \n+        /// <summary>\n+        /// Path to the NET tools directory.\n+        /// </summary>\n+        internal string MSBuildToolsDirectoryNET { get; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes, later dotnet.exe will be resolved from DOTNET_EXPERIMENTAL_HOST_PATH",
              "createdAt": "2025-06-02T09:58:15Z",
              "path": "src/Shared/BuildEnvironmentHelper.cs",
              "diffHunk": "@@ -662,6 +664,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA\n         /// </summary>\n         internal string MSBuildToolsDirectoryArm64 { get; }\n \n+        /// <summary>\n+        /// Path to the NET tools directory.\n+        /// </summary>\n+        internal string MSBuildToolsDirectoryNET { get; }",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't see this `--` in our existing core-to-core process launches; is it really necessary?",
              "createdAt": "2025-05-30T17:07:37Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs",
              "diffHunk": "@@ -546,24 +545,33 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor\n                 return false;\n             }\n \n-            // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we\n-            // want to start up an MSBuild task host node.\n-            string commandLineArgs = $\" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority} \";\n-\n-            string msbuildLocation = GetMSBuildLocationFromHostContext(hostContext);\n+            (string msbuildExecutable, string msbuildAssemblyLocation) = GetMSBuildLocationFromHostContext(hostContext);\n \n             // we couldn't even figure out the location we're trying to launch ... just go ahead and fail.\n-            if (msbuildLocation == null)\n+            if (msbuildExecutable == null)\n             {\n                 return false;\n             }\n \n-            CommunicationsUtilities.Trace(\"For a host context of {0}, spawning executable from {1}.\", hostContext.ToString(), msbuildLocation ?? \"MSBuild.exe\");\n+            string commandLineArgs;\n+            if (msbuildAssemblyLocation != null)\n+            {\n+                // For dotnet.exe, the dll path must come first, then -- to separate application arguments\n+                commandLineArgs = $\"\\\"{msbuildAssemblyLocation}\\\" -- /nodemode:2 \";",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "In fact in general this feels like it overlaps with stuff we are already doing elsewhere, e.g. in `NodeLauncher.cs`.",
              "createdAt": "2025-05-30T17:12:55Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs",
              "diffHunk": "@@ -546,24 +545,33 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor\n                 return false;\n             }\n \n-            // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we\n-            // want to start up an MSBuild task host node.\n-            string commandLineArgs = $\" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority} \";\n-\n-            string msbuildLocation = GetMSBuildLocationFromHostContext(hostContext);\n+            (string msbuildExecutable, string msbuildAssemblyLocation) = GetMSBuildLocationFromHostContext(hostContext);\n \n             // we couldn't even figure out the location we're trying to launch ... just go ahead and fail.\n-            if (msbuildLocation == null)\n+            if (msbuildExecutable == null)\n             {\n                 return false;\n             }\n \n-            CommunicationsUtilities.Trace(\"For a host context of {0}, spawning executable from {1}.\", hostContext.ToString(), msbuildLocation ?? \"MSBuild.exe\");\n+            string commandLineArgs;\n+            if (msbuildAssemblyLocation != null)\n+            {\n+                // For dotnet.exe, the dll path must come first, then -- to separate application arguments\n+                commandLineArgs = $\"\\\"{msbuildAssemblyLocation}\\\" -- /nodemode:2 \";",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nittiest nit: IMO it's still a \"new MSBuild process\" even if it's hosted in a `dotnet.exe`.",
              "createdAt": "2025-05-30T17:13:24Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -38,12 +38,12 @@ public void ShutdownComponent()\n         public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)\n         {\n             // Disable MSBuild server for a child process.\n-            // In case of starting msbuild server it prevents an infinite recurson. In case of starting msbuild node we also do not want this variable to be set.\n+            // In case of starting msbuild server it prevents an infinite recursion. In case of starting msbuild node we also do not want this variable to be set.\n             return DisableMSBuildServer(() => StartInternal(msbuildLocation, commandLineArgs));\n         }\n \n         /// <summary>\n-        /// Creates a new MSBuild process\n+        /// Creates new MSBuild or dotnet process.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd like these to remain a warning--I don't want unused stuff pushed to main.",
              "createdAt": "2025-05-30T17:39:03Z",
              "path": ".editorconfig",
              "diffHunk": "@@ -298,6 +298,12 @@ dotnet_diagnostic.IDE0048.severity = suggestion\n # Member name can be simplified\n dotnet_diagnostic.IDE0049.severity = suggestion\n \n+# Remove unused private member\n+dotnet_diagnostic.IDE0051.severity = suggestion\n+\n+# Remove unread private member\n+dotnet_diagnostic.IDE0052.severity = suggestion",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I am doing this one in #11887.",
              "createdAt": "2025-05-30T17:39:16Z",
              "path": ".editorconfig",
              "diffHunk": "@@ -428,6 +434,9 @@ dotnet_diagnostic.IDE0073.severity = error\n # Use 'System.Threading.Lock'\n dotnet_diagnostic.IDE0330.severity = suggestion\n \n+# Use implicitly typed lambda\n+dotnet_diagnostic.IDE0350.severity = suggestion",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "not actually important but while I generally like this syntax for short methods, using it for a constructor feels extremely icky to me . . .",
              "createdAt": "2025-05-30T17:40:06Z",
              "path": "src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs",
              "diffHunk": "@@ -21,12 +23,9 @@ public sealed class TaskHostFactory_Tests\n     {\n         private ITestOutputHelper _output;\n \n-        public TaskHostFactory_Tests(ITestOutputHelper testOutputHelper)\n-        {\n-            _output = testOutputHelper;\n-        }\n+        public TaskHostFactory_Tests(ITestOutputHelper testOutputHelper) => _output = testOutputHelper;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Ah, I think these are breaking because the current code breaks `TaskHostFactory` on core. Try building this project with your bootstrap SDK:\r\n\r\n```xml\r\n<Project>\r\n  <UsingTask\r\n        TaskName=\"Message\"\r\n        TaskFactory=\"TaskHostFactory\"\r\n        AssemblyFile=\"$(MSBuildToolsPath)\\Microsoft.Build.Tasks.Core.dll\" />\r\n  <Target Name=\"Build\">\r\n    <Message Text=\"Building the project...\" />\r\n  </Target>\r\n</Project>\r\n```\r\n\r\nI get \r\n\r\n```\r\n     1>Using \"Message\" task from assembly \"S:\\msbuild\\artifacts\\bin\\bootstrap\\core\\sdk\\9.0.203\\Microsoft.Build.Tasks.Core.dll\".\r\n       Task \"Message\"\r\n         Task assembly was loaded from 'S:\\msbuild\\artifacts\\bin\\bootstrap\\core\\sdk\\9.0.203\\Microsoft.Build.dll' while the desired location was 'S:\\msbuild\\artifacts\\bin\\bootstrap\\core\\sdk\\9.0.203\\Microsoft.B\r\n         uild.Tasks.Core.dll'.\r\n         Launching task \"Message\" from assembly \"S:\\msbuild\\artifacts\\bin\\bootstrap\\core\\sdk\\9.0.203\\Microsoft.Build.Tasks.Core.dll\" in an external task host with a runtime of \"NET\" and a process architecture\r\n          of \"x64\".\r\nProcess terminated. Assertion failed.\r\nCannot acquire required number of nodes.\r\nSystem.AggregateException: One or more errors occurred. (Build was canceled. MSBuild.exe could not be launched as a child node as it could not be found at the location \"dotnet.exe\". If necessary, specify the correct location in the BuildParameters, or with the MSBUILD_EXE_PATH environment variable.)\r\n ---> Microsoft.Build.Exceptions.BuildAbortedException: Build was canceled. MSBuild.exe could not be launched as a child node as it could not be found at the location \"dotnet.exe\". If necessary, specify the correct location in the BuildParameters, or with the MSBUILD_EXE_PATH environment variable.\r\n   at Microsoft.Build.BackEnd.NodeLauncher.StartInternal(String msbuildLocation, String commandLineArgs) in s:\\msbuild\\src\\Build\\BackEnd\\Components\\Communications\\NodeLauncher.cs:line 55\r\n   at Microsoft.Build.BackEnd.NodeLauncher.<>c__DisplayClass3_0.<Start>b__0() in s:\\msbuild\\src\\Build\\BackEnd\\Components\\Communications\\NodeLauncher.cs:line 42\r\n   at Microsoft.Build.BackEnd.NodeLauncher.DisableMSBuildServer(Func`1 func) in s:\\msbuild\\src\\Build\\BackEnd\\Components\\Communications\\NodeLauncher.cs:line 203\r\n   at Microsoft.Build.BackEnd.NodeLauncher.Start(String msbuildLocation, String commandLineArgs, Int32 nodeId) in s:\\msbuild\\src\\Build\\BackEnd\\Components\\Communications\\NodeLauncher.cs:line 42\r\n   at Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.<>c__DisplayClass14_0.<GetNodes>g__StartNewNode|2(Int32 nodeId) in s:\\msbuild\\src\\Build\\BackEnd\\Components\\Communications\\NodeProviderOutOfProcBase.cs:line 338\r\n   at Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.<>c__DisplayClass14_0.<GetNodes>b__0(Int32 nodeId) in s:\\msbuild\\src\\Build\\BackEnd\\Components\\Communications\\NodeProviderOutOfProcBase.cs:line 246\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Build.Framework.InternalErrorException.LaunchDebugger(String message, String innerMessage) in s:\\msbuild\\src\\Framework\\InternalErrorException.cs:line 134\r\n   at Microsoft.Build.Framework.InternalErrorException.ConsiderDebuggerLaunch(String message, Exception innerException) in s:\\msbuild\\src\\Framework\\InternalErrorException.cs:line 125\r\n   at Microsoft.Build.Framework.InternalErrorException..ctor(String message, Exception innerException, Boolean calledFromDeserialization) in s:\\msbuild\\src\\Framework\\InternalErrorException.cs:line 68\r\n   at Microsoft.Build.Framework.InternalErrorException..ctor(String message, Exception innerException) in s:\\msbuild\\src\\Framework\\InternalErrorException.cs:line 49\r\n   at Microsoft.Build.Shared.ErrorUtilities.ThrowInternalError(String message, Exception innerException, Object[] args) in s:\\msbuild\\src\\Shared\\ErrorUtilities.cs:line 69\r\n   at Microsoft.Build.BackEnd.NodeProviderOutOfProcBase.GetNodes(String msbuildLocation, String commandLineArgs, Int32 nextNodeId, INodePacketFactory factory, Handshake hostHandshake, NodeContextCreatedDelegate createNode, NodeContextTerminateDelegate terminateNode, Int32 numberOfNodesToCreate) in s:\\msbuild\\src\\Build\\BackEnd\\Components\\Communications\\NodeProviderOutOfProcBase.cs:line 260\r\n```",
              "createdAt": "2025-05-30T17:42:08Z",
              "path": "src/Build.UnitTests/Instance/TaskItem_Tests.cs",
              "diffHunk": "@@ -288,7 +288,7 @@ public void Escaping1()\n         /// <summary>\n         /// Flushing an item through a task run in the task host also should not mess up special characters on the metadata.\n         /// </summary>\n-        [Fact]\n+        [WindowsFullFrameworkOnlyFact]",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "With #11543 I get a slightly more graceful exception but it still fails:\r\n\r\n```\r\nS:\\play\\netcoretaskhost_playground\\foo.proj(7,5): error MSB4216: Could not run the \"Message\" task because MSBuild could not create or connect to a task host with runtime \"NET\" and architecture \"x64\".\r\n       Please ensure that (1) the requested runtime and/or architecture are available on the machine, and (2) that the required executable \"MSBuild.exe\" exists and can be run.\r\n```",
              "createdAt": "2025-05-30T18:57:00Z",
              "path": "src/Build.UnitTests/Instance/TaskItem_Tests.cs",
              "diffHunk": "@@ -288,7 +288,7 @@ public void Escaping1()\n         /// <summary>\n         /// Flushing an item through a task run in the task host also should not mess up special characters on the metadata.\n         /// </summary>\n-        [Fact]\n+        [WindowsFullFrameworkOnlyFact]",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}