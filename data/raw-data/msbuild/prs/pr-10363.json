{
  "number": 10363,
  "title": "Cleanup and refactoring",
  "body": "Refactoring of src/Framework/IEventSource.cs: -100 lines of duplicated code\r\nSmall refactoring of src/Shared/LogMessagePacketBase.cs: -100 lines of code\r\n\r\nrelated to: https://github.com/dotnet/msbuild/pull/10307",
  "state": "CLOSED",
  "createdAt": "2024-07-12T13:32:16Z",
  "updatedAt": "2024-08-30T15:47:02Z",
  "closedAt": "2024-08-30T15:47:02Z",
  "mergedAt": null,
  "additions": 72,
  "deletions": 305,
  "changedFiles": 2,
  "headRefName": "dev/ykovalova/refactoring",
  "isDraft": false,
  "author": {
    "login": "YuliiaKovalova"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "f892c5c641507f76e5272603c1a3969a7a93169d",
          "message": "cleanup and refactoring",
          "committedDate": "2024-07-12T13:19:55Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0dae4b653ef7332d6aa7bd162fa6c682ad309e0a",
          "message": "cleanup and refactor of LogMessagePacketBase",
          "committedDate": "2024-07-12T13:27:08Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "50d1f28cfe5f8eb88d0c3b9680b2f9b2604fe145",
          "message": "remove extra changes",
          "committedDate": "2024-07-12T13:31:17Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c665936ef054ff424f06e599715a68a5f1452b11",
          "message": "remove extra changes",
          "committedDate": "2024-07-12T13:34:21Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7bf961299960abbd82718d5649180dd469566157",
          "message": "Update LogMessagePacketBase.cs",
          "committedDate": "2024-07-12T18:21:12Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "54f0222c3119ba8bc6caaef94a3841e0cd71f8aa",
          "message": "undo extra change",
          "committedDate": "2024-07-15T08:50:50Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "It will be removed from TaskHost in the connected PR",
              "createdAt": "2024-07-12T13:35:09Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -889,8 +769,7 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even\n         }\n \n         /// <summary>\n-        /// Serializes EnvironmentVariableRead Event argument to the stream. Does not work properly on TaskHosts due to BuildEventContext serialization not being\n-        /// enabled on TaskHosts, but that shouldn't matter, as this should never be called from a TaskHost anyway.\n+        /// Serializes EnvironmentVariableRead Event argument to the stream.",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Open to opinion, but this refactor actually feels less clean to me. It adds a lot of delegate overhead, and the saved lines are almost all either from comments or from taking multiple lines and putting them end-to-end. Furthermore, EnsureSingleSubscription doesn't actually ensure anything; it just calls the two methods in a preset order. If I were to call EnsureSingleSubscription(h => eventSource.ErrorRaised += h, h => eventSource.ErrorRaised -= h, handler), for instance, it would compile fine but do the wrong thing.",
              "createdAt": "2024-07-12T14:26:24Z",
              "path": "src/Framework/IEventSource.cs",
              "diffHunk": "@@ -171,158 +172,44 @@ public interface IEventSource\n     public static class EventSourceExtensions\n     {\n         /// <summary>\n-        /// Helper method ensuring single deduplicated subscription to the <see cref=\"IEventSource.MessageRaised\"/> event.\n+        /// Helper method ensuring single deduplicated subscription to the event.\n         /// </summary>\n-        /// <param name=\"eventSource\"></param>\n+        /// <param name=\"removeHandler\"></param>\n+        /// <param name=\"addHandler\"></param>\n         /// <param name=\"handler\">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>\n-        public static void HandleMessageRaised(this IEventSource eventSource, BuildMessageEventHandler handler)\n+        private static void EnsureSingleSubscription<TEventHandler>(Action<TEventHandler> removeHandler, Action<TEventHandler> addHandler, TEventHandler handler)\n+            where TEventHandler : Delegate\n         {\n-            eventSource.MessageRaised -= handler;\n-            eventSource.MessageRaised += handler;\n+            removeHandler(handler);\n+            addHandler(handler);\n         }\n \n-        /// <summary>\n-        /// Helper method ensuring single deduplicated subscription to the <see cref=\"IEventSource.ErrorRaised\"/> event.\n-        /// </summary>\n-        /// <param name=\"eventSource\"></param>\n-        /// <param name=\"handler\">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>\n-        public static void HandleErrorRaised(this IEventSource eventSource, BuildErrorEventHandler handler)\n-        {\n-            eventSource.ErrorRaised -= handler;\n-            eventSource.ErrorRaised += handler;\n-        }\n+        public static void HandleMessageRaised(this IEventSource eventSource, BuildMessageEventHandler handler) => EnsureSingleSubscription(h => eventSource.MessageRaised -= h, h => eventSource.MessageRaised += h,  handler);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The idea was to shorten a code duplication, because of the listed methods do same and repetitive thing.\r\n\r\nLet's hear others.",
              "createdAt": "2024-07-12T18:16:14Z",
              "path": "src/Framework/IEventSource.cs",
              "diffHunk": "@@ -171,158 +172,44 @@ public interface IEventSource\n     public static class EventSourceExtensions\n     {\n         /// <summary>\n-        /// Helper method ensuring single deduplicated subscription to the <see cref=\"IEventSource.MessageRaised\"/> event.\n+        /// Helper method ensuring single deduplicated subscription to the event.\n         /// </summary>\n-        /// <param name=\"eventSource\"></param>\n+        /// <param name=\"removeHandler\"></param>\n+        /// <param name=\"addHandler\"></param>\n         /// <param name=\"handler\">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>\n-        public static void HandleMessageRaised(this IEventSource eventSource, BuildMessageEventHandler handler)\n+        private static void EnsureSingleSubscription<TEventHandler>(Action<TEventHandler> removeHandler, Action<TEventHandler> addHandler, TEventHandler handler)\n+            where TEventHandler : Delegate\n         {\n-            eventSource.MessageRaised -= handler;\n-            eventSource.MessageRaised += handler;\n+            removeHandler(handler);\n+            addHandler(handler);\n         }\n \n-        /// <summary>\n-        /// Helper method ensuring single deduplicated subscription to the <see cref=\"IEventSource.ErrorRaised\"/> event.\n-        /// </summary>\n-        /// <param name=\"eventSource\"></param>\n-        /// <param name=\"handler\">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>\n-        public static void HandleErrorRaised(this IEventSource eventSource, BuildErrorEventHandler handler)\n-        {\n-            eventSource.ErrorRaised -= handler;\n-            eventSource.ErrorRaised += handler;\n-        }\n+        public static void HandleMessageRaised(this IEventSource eventSource, BuildMessageEventHandler handler) => EnsureSingleSubscription(h => eventSource.MessageRaised -= h, h => eventSource.MessageRaised += h,  handler);",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "I still feel it's an improvement - as it more explicitly expresses the intent of the code (ensuring single subscription).\r\n\r\nIn the code size and typo risk it's same (not decreasing nor increasing). So as a grant total it feels as improvement",
              "createdAt": "2024-07-15T09:04:58Z",
              "path": "src/Framework/IEventSource.cs",
              "diffHunk": "@@ -171,158 +172,44 @@ public interface IEventSource\n     public static class EventSourceExtensions\n     {\n         /// <summary>\n-        /// Helper method ensuring single deduplicated subscription to the <see cref=\"IEventSource.MessageRaised\"/> event.\n+        /// Helper method ensuring single deduplicated subscription to the event.\n         /// </summary>\n-        /// <param name=\"eventSource\"></param>\n+        /// <param name=\"removeHandler\"></param>\n+        /// <param name=\"addHandler\"></param>\n         /// <param name=\"handler\">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>\n-        public static void HandleMessageRaised(this IEventSource eventSource, BuildMessageEventHandler handler)\n+        private static void EnsureSingleSubscription<TEventHandler>(Action<TEventHandler> removeHandler, Action<TEventHandler> addHandler, TEventHandler handler)\n+            where TEventHandler : Delegate\n         {\n-            eventSource.MessageRaised -= handler;\n-            eventSource.MessageRaised += handler;\n+            removeHandler(handler);\n+            addHandler(handler);\n         }\n \n-        /// <summary>\n-        /// Helper method ensuring single deduplicated subscription to the <see cref=\"IEventSource.ErrorRaised\"/> event.\n-        /// </summary>\n-        /// <param name=\"eventSource\"></param>\n-        /// <param name=\"handler\">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>\n-        public static void HandleErrorRaised(this IEventSource eventSource, BuildErrorEventHandler handler)\n-        {\n-            eventSource.ErrorRaised -= handler;\n-            eventSource.ErrorRaised += handler;\n-        }\n+        public static void HandleMessageRaised(this IEventSource eventSource, BuildMessageEventHandler handler) => EnsureSingleSubscription(h => eventSource.MessageRaised -= h, h => eventSource.MessageRaised += h,  handler);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Though much leaner but not clear. Also, error prone as mentioned by @Forgind! This could be a candidate for Source Generators!",
              "createdAt": "2024-07-26T17:51:41Z",
              "path": "src/Framework/IEventSource.cs",
              "diffHunk": "@@ -171,158 +172,44 @@ public interface IEventSource\n     public static class EventSourceExtensions\n     {\n         /// <summary>\n-        /// Helper method ensuring single deduplicated subscription to the <see cref=\"IEventSource.MessageRaised\"/> event.\n+        /// Helper method ensuring single deduplicated subscription to the event.\n         /// </summary>\n-        /// <param name=\"eventSource\"></param>\n+        /// <param name=\"removeHandler\"></param>\n+        /// <param name=\"addHandler\"></param>\n         /// <param name=\"handler\">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>\n-        public static void HandleMessageRaised(this IEventSource eventSource, BuildMessageEventHandler handler)\n+        private static void EnsureSingleSubscription<TEventHandler>(Action<TEventHandler> removeHandler, Action<TEventHandler> addHandler, TEventHandler handler)\n+            where TEventHandler : Delegate\n         {\n-            eventSource.MessageRaised -= handler;\n-            eventSource.MessageRaised += handler;\n+            removeHandler(handler);\n+            addHandler(handler);\n         }\n \n-        /// <summary>\n-        /// Helper method ensuring single deduplicated subscription to the <see cref=\"IEventSource.ErrorRaised\"/> event.\n-        /// </summary>\n-        /// <param name=\"eventSource\"></param>\n-        /// <param name=\"handler\">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>\n-        public static void HandleErrorRaised(this IEventSource eventSource, BuildErrorEventHandler handler)\n-        {\n-            eventSource.ErrorRaised -= handler;\n-            eventSource.ErrorRaised += handler;\n-        }\n+        public static void HandleMessageRaised(this IEventSource eventSource, BuildMessageEventHandler handler) => EnsureSingleSubscription(h => eventSource.MessageRaised -= h, h => eventSource.MessageRaised += h,  handler);",
              "author": {
                "login": "Nirmal4G"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Adding a big dictionary here is an extra allocation. I'd rather just see a switch statement like:\r\n```C#\r\nreturn eventType switch {\r\n    BuildMessageEventArgs => LoggingEventType.BuildMessageEvent,\r\n    TaskCommandLineEventArgs => LoggingEventType.TaskCommandLineEvent,\r\n    ...\r\n    _ => LoggingEventType.CustomEvent\r\n};",
              "createdAt": "2024-07-12T14:30:15Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -667,171 +711,7 @@ private BuildEventArgs GetBuildEventArgFromId()\n         private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)\n         {\n             Type eventType = eventArg.GetType();\n-            if (eventType == typeof(BuildMessageEventArgs))\n-            {\n-                return LoggingEventType.BuildMessageEvent;\n-            }\n-            else if (eventType == typeof(TaskCommandLineEventArgs))\n-            {\n-                return LoggingEventType.TaskCommandLineEvent;\n-            }\n-#if !TASKHOST\n-            else if (eventType == typeof(TaskParameterEventArgs))\n-            {\n-                return LoggingEventType.TaskParameterEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(ProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectFinishedEvent;\n-            }\n-\n-#if !TASKHOST\n-            else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectEvaluationStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationStartedEvent;\n-            }\n-            else if (eventType == typeof(ProjectImportedEventArgs))\n-            {\n-                return LoggingEventType.ProjectImportedEvent;\n-            }\n-            else if (eventType == typeof(TargetSkippedEventArgs))\n-            {\n-                return LoggingEventType.TargetSkipped;\n-            }\n-            else if (eventType == typeof(TelemetryEventArgs))\n-            {\n-                return LoggingEventType.Telemetry;\n-            }\n-            else if (eventType == typeof(AssemblyLoadBuildEventArgs))\n-            {\n-                return LoggingEventType.AssemblyLoadEvent;\n-            }\n-            else if (eventType == typeof(ExtendedCustomBuildEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCustomEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildErrorEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildErrorEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildWarningEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildWarningEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(CriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.CriticalBuildMessage;\n-            }\n-            else if (eventType == typeof(ExtendedCriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCriticalBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(MetaprojectGeneratedEventArgs))\n-            {\n-                return LoggingEventType.MetaprojectGenerated;\n-            }\n-            else if (eventType == typeof(PropertyInitialValueSetEventArgs))\n-            {\n-                return LoggingEventType.PropertyInitialValueSet;\n-            }\n-            else if (eventType == typeof(PropertyReassignmentEventArgs))\n-            {\n-                return LoggingEventType.PropertyReassignment;\n-            }\n-            else if (eventType == typeof(UninitializedPropertyReadEventArgs))\n-            {\n-                return LoggingEventType.UninitializedPropertyRead;\n-            }\n-            else if (eventType == typeof(GeneratedFileUsedEventArgs))\n-            {\n-                return LoggingEventType.GeneratedFileUsedEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultMessage))\n-            {\n-                return LoggingEventType.BuildCheckMessageEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultWarning))\n-            {\n-                return LoggingEventType.BuildCheckWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultError))\n-            {\n-                return LoggingEventType.BuildCheckErrorEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckAcquisitionEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckAcquisitionEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckTracingEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckTracingEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(TargetStartedEventArgs))\n-            {\n-                return LoggingEventType.TargetStartedEvent;\n-            }\n-            else if (eventType == typeof(TargetFinishedEventArgs))\n-            {\n-                return LoggingEventType.TargetFinishedEvent;\n-            }\n-            else if (eventType == typeof(TaskStartedEventArgs))\n-            {\n-                return LoggingEventType.TaskStartedEvent;\n-            }\n-            else if (eventType == typeof(TaskFinishedEventArgs))\n-            {\n-                return LoggingEventType.TaskFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildFinishedEventArgs))\n-            {\n-                return LoggingEventType.BuildFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildStartedEventArgs))\n-            {\n-                return LoggingEventType.BuildStartedEvent;\n-            }\n-            else if (eventType == typeof(BuildWarningEventArgs))\n-            {\n-                return LoggingEventType.BuildWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildErrorEventArgs))\n-            {\n-                return LoggingEventType.BuildErrorEvent;\n-            }\n-            else if (eventType == typeof(EnvironmentVariableReadEventArgs))\n-            {\n-                return LoggingEventType.EnvironmentVariableReadEvent;\n-            }\n-            else if (eventType == typeof(ResponseFileUsedEventArgs))\n-            {\n-                return LoggingEventType.ResponseFileUsedEvent;\n-            }\n-            else\n-            {\n-                return LoggingEventType.CustomEvent;\n-            }\n+            return EventTypeToLoggingEventTypeMap.TryGetValue(eventType, out var loggingEventType) ? loggingEventType : LoggingEventType.CustomEvent;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "A single static dictionary (ideally `FrozenDictionary` on net9) allocation isn't something I'd worry about. The switch is nice and clear but does appear (at least at the moment: https://github.com/dotnet/runtime/issues/12260) to compile down to a [linear list of checks](https://sharplab.io/#v2:EYLgHgbALAPgAgJgIwFgBQcDMACR2DC2A3utmbjnEgAzYCyAFAEICGAzgKbbACUxp5QXADs3bGwDuASwAuAYwAW/NINXkAIkmwBeAHzYARJoMAaAWsHqEO/UYSnzFsupx7DLhyqcaoN91E9vDQBWPyNgwKDsdQgwmMig9VE3I2EE73UADjjM9Kd1AE44gryLAH0wgH5q0rIAXwBuRzr0FrR0LFxrVk5iNo7Ka01sEGweriI2zrwrEbH2CanB6JxR8b6BrujfNYWNjGX1UN3eyc2Z2JPF86HRK/3poez7s4Otwrn1yaA=).\r\n\r\nUsing a dictionary here seems like it'd be reasonable for > 10 types: https://github.com/dotnet/runtime/issues/12260#issuecomment-473691570",
              "createdAt": "2024-07-12T19:29:08Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -667,171 +711,7 @@ private BuildEventArgs GetBuildEventArgFromId()\n         private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)\n         {\n             Type eventType = eventArg.GetType();\n-            if (eventType == typeof(BuildMessageEventArgs))\n-            {\n-                return LoggingEventType.BuildMessageEvent;\n-            }\n-            else if (eventType == typeof(TaskCommandLineEventArgs))\n-            {\n-                return LoggingEventType.TaskCommandLineEvent;\n-            }\n-#if !TASKHOST\n-            else if (eventType == typeof(TaskParameterEventArgs))\n-            {\n-                return LoggingEventType.TaskParameterEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(ProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectFinishedEvent;\n-            }\n-\n-#if !TASKHOST\n-            else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectEvaluationStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationStartedEvent;\n-            }\n-            else if (eventType == typeof(ProjectImportedEventArgs))\n-            {\n-                return LoggingEventType.ProjectImportedEvent;\n-            }\n-            else if (eventType == typeof(TargetSkippedEventArgs))\n-            {\n-                return LoggingEventType.TargetSkipped;\n-            }\n-            else if (eventType == typeof(TelemetryEventArgs))\n-            {\n-                return LoggingEventType.Telemetry;\n-            }\n-            else if (eventType == typeof(AssemblyLoadBuildEventArgs))\n-            {\n-                return LoggingEventType.AssemblyLoadEvent;\n-            }\n-            else if (eventType == typeof(ExtendedCustomBuildEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCustomEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildErrorEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildErrorEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildWarningEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildWarningEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(CriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.CriticalBuildMessage;\n-            }\n-            else if (eventType == typeof(ExtendedCriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCriticalBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(MetaprojectGeneratedEventArgs))\n-            {\n-                return LoggingEventType.MetaprojectGenerated;\n-            }\n-            else if (eventType == typeof(PropertyInitialValueSetEventArgs))\n-            {\n-                return LoggingEventType.PropertyInitialValueSet;\n-            }\n-            else if (eventType == typeof(PropertyReassignmentEventArgs))\n-            {\n-                return LoggingEventType.PropertyReassignment;\n-            }\n-            else if (eventType == typeof(UninitializedPropertyReadEventArgs))\n-            {\n-                return LoggingEventType.UninitializedPropertyRead;\n-            }\n-            else if (eventType == typeof(GeneratedFileUsedEventArgs))\n-            {\n-                return LoggingEventType.GeneratedFileUsedEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultMessage))\n-            {\n-                return LoggingEventType.BuildCheckMessageEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultWarning))\n-            {\n-                return LoggingEventType.BuildCheckWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultError))\n-            {\n-                return LoggingEventType.BuildCheckErrorEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckAcquisitionEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckAcquisitionEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckTracingEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckTracingEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(TargetStartedEventArgs))\n-            {\n-                return LoggingEventType.TargetStartedEvent;\n-            }\n-            else if (eventType == typeof(TargetFinishedEventArgs))\n-            {\n-                return LoggingEventType.TargetFinishedEvent;\n-            }\n-            else if (eventType == typeof(TaskStartedEventArgs))\n-            {\n-                return LoggingEventType.TaskStartedEvent;\n-            }\n-            else if (eventType == typeof(TaskFinishedEventArgs))\n-            {\n-                return LoggingEventType.TaskFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildFinishedEventArgs))\n-            {\n-                return LoggingEventType.BuildFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildStartedEventArgs))\n-            {\n-                return LoggingEventType.BuildStartedEvent;\n-            }\n-            else if (eventType == typeof(BuildWarningEventArgs))\n-            {\n-                return LoggingEventType.BuildWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildErrorEventArgs))\n-            {\n-                return LoggingEventType.BuildErrorEvent;\n-            }\n-            else if (eventType == typeof(EnvironmentVariableReadEventArgs))\n-            {\n-                return LoggingEventType.EnvironmentVariableReadEvent;\n-            }\n-            else if (eventType == typeof(ResponseFileUsedEventArgs))\n-            {\n-                return LoggingEventType.ResponseFileUsedEvent;\n-            }\n-            else\n-            {\n-                return LoggingEventType.CustomEvent;\n-            }\n+            return EventTypeToLoggingEventTypeMap.TryGetValue(eventType, out var loggingEventType) ? loggingEventType : LoggingEventType.CustomEvent;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It looks like jkotas suggested a hashtable. Not a big difference between that and a dictionary for this application, though, as far as I know.",
              "createdAt": "2024-07-12T20:11:27Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -667,171 +711,7 @@ private BuildEventArgs GetBuildEventArgFromId()\n         private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)\n         {\n             Type eventType = eventArg.GetType();\n-            if (eventType == typeof(BuildMessageEventArgs))\n-            {\n-                return LoggingEventType.BuildMessageEvent;\n-            }\n-            else if (eventType == typeof(TaskCommandLineEventArgs))\n-            {\n-                return LoggingEventType.TaskCommandLineEvent;\n-            }\n-#if !TASKHOST\n-            else if (eventType == typeof(TaskParameterEventArgs))\n-            {\n-                return LoggingEventType.TaskParameterEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(ProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectFinishedEvent;\n-            }\n-\n-#if !TASKHOST\n-            else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectEvaluationStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationStartedEvent;\n-            }\n-            else if (eventType == typeof(ProjectImportedEventArgs))\n-            {\n-                return LoggingEventType.ProjectImportedEvent;\n-            }\n-            else if (eventType == typeof(TargetSkippedEventArgs))\n-            {\n-                return LoggingEventType.TargetSkipped;\n-            }\n-            else if (eventType == typeof(TelemetryEventArgs))\n-            {\n-                return LoggingEventType.Telemetry;\n-            }\n-            else if (eventType == typeof(AssemblyLoadBuildEventArgs))\n-            {\n-                return LoggingEventType.AssemblyLoadEvent;\n-            }\n-            else if (eventType == typeof(ExtendedCustomBuildEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCustomEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildErrorEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildErrorEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildWarningEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildWarningEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(CriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.CriticalBuildMessage;\n-            }\n-            else if (eventType == typeof(ExtendedCriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCriticalBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(MetaprojectGeneratedEventArgs))\n-            {\n-                return LoggingEventType.MetaprojectGenerated;\n-            }\n-            else if (eventType == typeof(PropertyInitialValueSetEventArgs))\n-            {\n-                return LoggingEventType.PropertyInitialValueSet;\n-            }\n-            else if (eventType == typeof(PropertyReassignmentEventArgs))\n-            {\n-                return LoggingEventType.PropertyReassignment;\n-            }\n-            else if (eventType == typeof(UninitializedPropertyReadEventArgs))\n-            {\n-                return LoggingEventType.UninitializedPropertyRead;\n-            }\n-            else if (eventType == typeof(GeneratedFileUsedEventArgs))\n-            {\n-                return LoggingEventType.GeneratedFileUsedEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultMessage))\n-            {\n-                return LoggingEventType.BuildCheckMessageEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultWarning))\n-            {\n-                return LoggingEventType.BuildCheckWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultError))\n-            {\n-                return LoggingEventType.BuildCheckErrorEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckAcquisitionEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckAcquisitionEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckTracingEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckTracingEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(TargetStartedEventArgs))\n-            {\n-                return LoggingEventType.TargetStartedEvent;\n-            }\n-            else if (eventType == typeof(TargetFinishedEventArgs))\n-            {\n-                return LoggingEventType.TargetFinishedEvent;\n-            }\n-            else if (eventType == typeof(TaskStartedEventArgs))\n-            {\n-                return LoggingEventType.TaskStartedEvent;\n-            }\n-            else if (eventType == typeof(TaskFinishedEventArgs))\n-            {\n-                return LoggingEventType.TaskFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildFinishedEventArgs))\n-            {\n-                return LoggingEventType.BuildFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildStartedEventArgs))\n-            {\n-                return LoggingEventType.BuildStartedEvent;\n-            }\n-            else if (eventType == typeof(BuildWarningEventArgs))\n-            {\n-                return LoggingEventType.BuildWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildErrorEventArgs))\n-            {\n-                return LoggingEventType.BuildErrorEvent;\n-            }\n-            else if (eventType == typeof(EnvironmentVariableReadEventArgs))\n-            {\n-                return LoggingEventType.EnvironmentVariableReadEvent;\n-            }\n-            else if (eventType == typeof(ResponseFileUsedEventArgs))\n-            {\n-                return LoggingEventType.ResponseFileUsedEvent;\n-            }\n-            else\n-            {\n-                return LoggingEventType.CustomEvent;\n-            }\n+            return EventTypeToLoggingEventTypeMap.TryGetValue(eventType, out var loggingEventType) ? loggingEventType : LoggingEventType.CustomEvent;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I guess the other half of this is asking what the real goal of this change is, since I think switch statements are always beautiful, and I don't imagine this is a perf bottleneck",
              "createdAt": "2024-07-12T20:13:17Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -667,171 +711,7 @@ private BuildEventArgs GetBuildEventArgFromId()\n         private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)\n         {\n             Type eventType = eventArg.GetType();\n-            if (eventType == typeof(BuildMessageEventArgs))\n-            {\n-                return LoggingEventType.BuildMessageEvent;\n-            }\n-            else if (eventType == typeof(TaskCommandLineEventArgs))\n-            {\n-                return LoggingEventType.TaskCommandLineEvent;\n-            }\n-#if !TASKHOST\n-            else if (eventType == typeof(TaskParameterEventArgs))\n-            {\n-                return LoggingEventType.TaskParameterEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(ProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectFinishedEvent;\n-            }\n-\n-#if !TASKHOST\n-            else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectEvaluationStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationStartedEvent;\n-            }\n-            else if (eventType == typeof(ProjectImportedEventArgs))\n-            {\n-                return LoggingEventType.ProjectImportedEvent;\n-            }\n-            else if (eventType == typeof(TargetSkippedEventArgs))\n-            {\n-                return LoggingEventType.TargetSkipped;\n-            }\n-            else if (eventType == typeof(TelemetryEventArgs))\n-            {\n-                return LoggingEventType.Telemetry;\n-            }\n-            else if (eventType == typeof(AssemblyLoadBuildEventArgs))\n-            {\n-                return LoggingEventType.AssemblyLoadEvent;\n-            }\n-            else if (eventType == typeof(ExtendedCustomBuildEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCustomEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildErrorEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildErrorEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildWarningEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildWarningEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(CriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.CriticalBuildMessage;\n-            }\n-            else if (eventType == typeof(ExtendedCriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCriticalBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(MetaprojectGeneratedEventArgs))\n-            {\n-                return LoggingEventType.MetaprojectGenerated;\n-            }\n-            else if (eventType == typeof(PropertyInitialValueSetEventArgs))\n-            {\n-                return LoggingEventType.PropertyInitialValueSet;\n-            }\n-            else if (eventType == typeof(PropertyReassignmentEventArgs))\n-            {\n-                return LoggingEventType.PropertyReassignment;\n-            }\n-            else if (eventType == typeof(UninitializedPropertyReadEventArgs))\n-            {\n-                return LoggingEventType.UninitializedPropertyRead;\n-            }\n-            else if (eventType == typeof(GeneratedFileUsedEventArgs))\n-            {\n-                return LoggingEventType.GeneratedFileUsedEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultMessage))\n-            {\n-                return LoggingEventType.BuildCheckMessageEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultWarning))\n-            {\n-                return LoggingEventType.BuildCheckWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultError))\n-            {\n-                return LoggingEventType.BuildCheckErrorEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckAcquisitionEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckAcquisitionEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckTracingEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckTracingEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(TargetStartedEventArgs))\n-            {\n-                return LoggingEventType.TargetStartedEvent;\n-            }\n-            else if (eventType == typeof(TargetFinishedEventArgs))\n-            {\n-                return LoggingEventType.TargetFinishedEvent;\n-            }\n-            else if (eventType == typeof(TaskStartedEventArgs))\n-            {\n-                return LoggingEventType.TaskStartedEvent;\n-            }\n-            else if (eventType == typeof(TaskFinishedEventArgs))\n-            {\n-                return LoggingEventType.TaskFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildFinishedEventArgs))\n-            {\n-                return LoggingEventType.BuildFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildStartedEventArgs))\n-            {\n-                return LoggingEventType.BuildStartedEvent;\n-            }\n-            else if (eventType == typeof(BuildWarningEventArgs))\n-            {\n-                return LoggingEventType.BuildWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildErrorEventArgs))\n-            {\n-                return LoggingEventType.BuildErrorEvent;\n-            }\n-            else if (eventType == typeof(EnvironmentVariableReadEventArgs))\n-            {\n-                return LoggingEventType.EnvironmentVariableReadEvent;\n-            }\n-            else if (eventType == typeof(ResponseFileUsedEventArgs))\n-            {\n-                return LoggingEventType.ResponseFileUsedEvent;\n-            }\n-            else\n-            {\n-                return LoggingEventType.CustomEvent;\n-            }\n+            return EventTypeToLoggingEventTypeMap.TryGetValue(eventType, out var loggingEventType) ? loggingEventType : LoggingEventType.CustomEvent;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The primary objective was to simplify the lengthy and difficult-to-read if/else statements in the method. Regarding the use of switch statements or dictionaries, could you please share your thoughts on the current implementation? If you have any concerns, I would appreciate hearing your reasoning.",
              "createdAt": "2024-07-15T11:15:01Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -667,171 +711,7 @@ private BuildEventArgs GetBuildEventArgFromId()\n         private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)\n         {\n             Type eventType = eventArg.GetType();\n-            if (eventType == typeof(BuildMessageEventArgs))\n-            {\n-                return LoggingEventType.BuildMessageEvent;\n-            }\n-            else if (eventType == typeof(TaskCommandLineEventArgs))\n-            {\n-                return LoggingEventType.TaskCommandLineEvent;\n-            }\n-#if !TASKHOST\n-            else if (eventType == typeof(TaskParameterEventArgs))\n-            {\n-                return LoggingEventType.TaskParameterEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(ProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectFinishedEvent;\n-            }\n-\n-#if !TASKHOST\n-            else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectEvaluationStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationStartedEvent;\n-            }\n-            else if (eventType == typeof(ProjectImportedEventArgs))\n-            {\n-                return LoggingEventType.ProjectImportedEvent;\n-            }\n-            else if (eventType == typeof(TargetSkippedEventArgs))\n-            {\n-                return LoggingEventType.TargetSkipped;\n-            }\n-            else if (eventType == typeof(TelemetryEventArgs))\n-            {\n-                return LoggingEventType.Telemetry;\n-            }\n-            else if (eventType == typeof(AssemblyLoadBuildEventArgs))\n-            {\n-                return LoggingEventType.AssemblyLoadEvent;\n-            }\n-            else if (eventType == typeof(ExtendedCustomBuildEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCustomEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildErrorEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildErrorEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildWarningEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildWarningEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(CriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.CriticalBuildMessage;\n-            }\n-            else if (eventType == typeof(ExtendedCriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCriticalBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(MetaprojectGeneratedEventArgs))\n-            {\n-                return LoggingEventType.MetaprojectGenerated;\n-            }\n-            else if (eventType == typeof(PropertyInitialValueSetEventArgs))\n-            {\n-                return LoggingEventType.PropertyInitialValueSet;\n-            }\n-            else if (eventType == typeof(PropertyReassignmentEventArgs))\n-            {\n-                return LoggingEventType.PropertyReassignment;\n-            }\n-            else if (eventType == typeof(UninitializedPropertyReadEventArgs))\n-            {\n-                return LoggingEventType.UninitializedPropertyRead;\n-            }\n-            else if (eventType == typeof(GeneratedFileUsedEventArgs))\n-            {\n-                return LoggingEventType.GeneratedFileUsedEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultMessage))\n-            {\n-                return LoggingEventType.BuildCheckMessageEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultWarning))\n-            {\n-                return LoggingEventType.BuildCheckWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultError))\n-            {\n-                return LoggingEventType.BuildCheckErrorEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckAcquisitionEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckAcquisitionEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckTracingEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckTracingEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(TargetStartedEventArgs))\n-            {\n-                return LoggingEventType.TargetStartedEvent;\n-            }\n-            else if (eventType == typeof(TargetFinishedEventArgs))\n-            {\n-                return LoggingEventType.TargetFinishedEvent;\n-            }\n-            else if (eventType == typeof(TaskStartedEventArgs))\n-            {\n-                return LoggingEventType.TaskStartedEvent;\n-            }\n-            else if (eventType == typeof(TaskFinishedEventArgs))\n-            {\n-                return LoggingEventType.TaskFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildFinishedEventArgs))\n-            {\n-                return LoggingEventType.BuildFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildStartedEventArgs))\n-            {\n-                return LoggingEventType.BuildStartedEvent;\n-            }\n-            else if (eventType == typeof(BuildWarningEventArgs))\n-            {\n-                return LoggingEventType.BuildWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildErrorEventArgs))\n-            {\n-                return LoggingEventType.BuildErrorEvent;\n-            }\n-            else if (eventType == typeof(EnvironmentVariableReadEventArgs))\n-            {\n-                return LoggingEventType.EnvironmentVariableReadEvent;\n-            }\n-            else if (eventType == typeof(ResponseFileUsedEventArgs))\n-            {\n-                return LoggingEventType.ResponseFileUsedEvent;\n-            }\n-            else\n-            {\n-                return LoggingEventType.CustomEvent;\n-            }\n+            return EventTypeToLoggingEventTypeMap.TryGetValue(eventType, out var loggingEventType) ? loggingEventType : LoggingEventType.CustomEvent;",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "It sounds like rainersigwald likes it better, so I don't have any real concerns. I still prefer a switch, but either is fine.",
              "createdAt": "2024-07-16T00:02:07Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -667,171 +711,7 @@ private BuildEventArgs GetBuildEventArgFromId()\n         private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)\n         {\n             Type eventType = eventArg.GetType();\n-            if (eventType == typeof(BuildMessageEventArgs))\n-            {\n-                return LoggingEventType.BuildMessageEvent;\n-            }\n-            else if (eventType == typeof(TaskCommandLineEventArgs))\n-            {\n-                return LoggingEventType.TaskCommandLineEvent;\n-            }\n-#if !TASKHOST\n-            else if (eventType == typeof(TaskParameterEventArgs))\n-            {\n-                return LoggingEventType.TaskParameterEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(ProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectStartedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectStartedEvent;\n-            }\n-            else if (eventType == typeof(ExternalProjectFinishedEventArgs))\n-            {\n-                return LoggingEventType.ExternalProjectFinishedEvent;\n-            }\n-\n-#if !TASKHOST\n-            else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationFinishedEvent;\n-            }\n-            else if (eventType == typeof(ProjectEvaluationStartedEventArgs))\n-            {\n-                return LoggingEventType.ProjectEvaluationStartedEvent;\n-            }\n-            else if (eventType == typeof(ProjectImportedEventArgs))\n-            {\n-                return LoggingEventType.ProjectImportedEvent;\n-            }\n-            else if (eventType == typeof(TargetSkippedEventArgs))\n-            {\n-                return LoggingEventType.TargetSkipped;\n-            }\n-            else if (eventType == typeof(TelemetryEventArgs))\n-            {\n-                return LoggingEventType.Telemetry;\n-            }\n-            else if (eventType == typeof(AssemblyLoadBuildEventArgs))\n-            {\n-                return LoggingEventType.AssemblyLoadEvent;\n-            }\n-            else if (eventType == typeof(ExtendedCustomBuildEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCustomEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildErrorEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildErrorEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildWarningEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildWarningEvent;\n-            }\n-            else if (eventType == typeof(ExtendedBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(CriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.CriticalBuildMessage;\n-            }\n-            else if (eventType == typeof(ExtendedCriticalBuildMessageEventArgs))\n-            {\n-                return LoggingEventType.ExtendedCriticalBuildMessageEvent;\n-            }\n-            else if (eventType == typeof(MetaprojectGeneratedEventArgs))\n-            {\n-                return LoggingEventType.MetaprojectGenerated;\n-            }\n-            else if (eventType == typeof(PropertyInitialValueSetEventArgs))\n-            {\n-                return LoggingEventType.PropertyInitialValueSet;\n-            }\n-            else if (eventType == typeof(PropertyReassignmentEventArgs))\n-            {\n-                return LoggingEventType.PropertyReassignment;\n-            }\n-            else if (eventType == typeof(UninitializedPropertyReadEventArgs))\n-            {\n-                return LoggingEventType.UninitializedPropertyRead;\n-            }\n-            else if (eventType == typeof(GeneratedFileUsedEventArgs))\n-            {\n-                return LoggingEventType.GeneratedFileUsedEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultMessage))\n-            {\n-                return LoggingEventType.BuildCheckMessageEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultWarning))\n-            {\n-                return LoggingEventType.BuildCheckWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckResultError))\n-            {\n-                return LoggingEventType.BuildCheckErrorEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckAcquisitionEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckAcquisitionEvent;\n-            }\n-            else if (eventType == typeof(BuildCheckTracingEventArgs))\n-            {\n-                return LoggingEventType.BuildCheckTracingEvent;\n-            }\n-#endif\n-            else if (eventType == typeof(TargetStartedEventArgs))\n-            {\n-                return LoggingEventType.TargetStartedEvent;\n-            }\n-            else if (eventType == typeof(TargetFinishedEventArgs))\n-            {\n-                return LoggingEventType.TargetFinishedEvent;\n-            }\n-            else if (eventType == typeof(TaskStartedEventArgs))\n-            {\n-                return LoggingEventType.TaskStartedEvent;\n-            }\n-            else if (eventType == typeof(TaskFinishedEventArgs))\n-            {\n-                return LoggingEventType.TaskFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildFinishedEventArgs))\n-            {\n-                return LoggingEventType.BuildFinishedEvent;\n-            }\n-            else if (eventType == typeof(BuildStartedEventArgs))\n-            {\n-                return LoggingEventType.BuildStartedEvent;\n-            }\n-            else if (eventType == typeof(BuildWarningEventArgs))\n-            {\n-                return LoggingEventType.BuildWarningEvent;\n-            }\n-            else if (eventType == typeof(BuildErrorEventArgs))\n-            {\n-                return LoggingEventType.BuildErrorEvent;\n-            }\n-            else if (eventType == typeof(EnvironmentVariableReadEventArgs))\n-            {\n-                return LoggingEventType.EnvironmentVariableReadEvent;\n-            }\n-            else if (eventType == typeof(ResponseFileUsedEventArgs))\n-            {\n-                return LoggingEventType.ResponseFileUsedEvent;\n-            }\n-            else\n-            {\n-                return LoggingEventType.CustomEvent;\n-            }\n+            return EventTypeToLoggingEventTypeMap.TryGetValue(eventType, out var loggingEventType) ? loggingEventType : LoggingEventType.CustomEvent;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why not use `nameof` instead?",
              "createdAt": "2024-07-26T16:43:13Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -271,6 +271,51 @@ internal abstract class LogMessagePacketBase : INodePacket\n         /// </summary>\n         private static HashSet<string> s_customEventsLoaded = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n \n+        private static readonly Dictionary<Type, LoggingEventType> EventTypeToLoggingEventTypeMap = new()\n+        {\n+             { typeof(BuildMessageEventArgs), LoggingEventType.BuildMessageEvent },",
              "author": {
                "login": "Nirmal4G"
              }
            }
          ]
        }
      }
    ]
  }
}