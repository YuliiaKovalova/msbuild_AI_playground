{
  "number": 10237,
  "title": "Wire up the properties reading/writing via loggingContexts",
  "body": "Contributes towards #9883\r\n\r\n### Context\r\nThis is 2nd from sequence of 3 changesets delivering the \"Undefined Property Used\" BuildCheck\r\nThis changeset wires the property read and write info to the buildcheck. The data are being sent via the `LoggingContext`->`LoggingService`->`BuildCheck` chain - so that we can easily add a reroute that will perform `LoggingContext`->`LoggingService`->`BuildEventArgs remoting to the central node` ->`BuildCheck`\r\n\r\nThe actuall check is not part of this changeset - it'll be delivered subsequently\r\n\r\n\r\n### Changes Made\r\n * Imposing nullable checks on touched code\r\n * Making sure `BuildEventContext` is allways initialized in `LoggingService`\r\n * Extended the LoggingContecxt and LoggingService internal contract so that they can serve as sinks for build execution produced data\r\n * Wired the property reads and writes data from engine to LoggingContext\r\n * Wired the property reads and writes data from LoggingService to BuildCheck\r\n * Wiring of eventing in BuildCheck\r\n\r\n### Design documentation\r\n(part of this PR)\r\n\r\nhttps://github.com/dotnet/msbuild/blob/proto/buildcheck-properties-wiring/documentation/specs/proposed/BuildCheck-Architecture.md#sourcing-unexposed-data-from-within-execution\r\n\r\n\r\n### Notes\r\n\r\n* No actual functionality yet\r\n* We still have singletons - The lifetime management is not yet part of this effort - will be resolved via separate work: https://github.com/orgs/dotnet/projects/373/views/7?pane=issue&itemId=62513427\r\n* I'm going to produce small write-up or/and diagram for our arch doc to ilustrate the envisioned mechanics\r\n* This PR will likely be in several conflicts with https://github.com/dotnet/msbuild/pull/10224 - I'm up for resolving those in the remaining PR upon approving any of these two PRs (FYI @surayya-MS)\r\n",
  "state": "MERGED",
  "createdAt": "2024-06-13T13:04:41Z",
  "updatedAt": "2024-07-25T17:37:57Z",
  "closedAt": "2024-07-25T17:37:55Z",
  "mergedAt": "2024-07-25T17:37:55Z",
  "additions": 703,
  "deletions": 165,
  "changedFiles": 44,
  "headRefName": "proto/buildcheck-properties-wiring",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "e7bb6cadc14d9a48f04b6bbdfadde83af6aeefe1",
          "message": "Wire up the properties reading/writing via loggingContexts",
          "committedDate": "2024-06-13T12:56:33Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3e0e76fbeb36fd5a4325f182f78a72e68dbd5163",
          "message": "Fix null ref",
          "committedDate": "2024-06-13T14:40:56Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4ce8bd6cb51dac69876135d2048cbce5bbe87e4b",
          "message": "Document the envisioned data flow",
          "committedDate": "2024-06-13T15:06:27Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "53f3fc41c5e4c6b95c6c8d397f1163c4f25e4cab",
          "message": "Fix shouldly nullref",
          "committedDate": "2024-06-13T15:40:31Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a366f465252a2f95b8cb9c5595561d1a45eeb43d",
          "message": "Move the evaluation start log",
          "committedDate": "2024-06-13T16:17:22Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "db609672bd9b3af1e18878f89798c2af2b540ca1",
          "message": "Merge branch 'main' into proto/buildcheck-properties-wiring",
          "committedDate": "2024-07-02T16:19:39Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8dbd500da2ebeda93465917a902ff7cfe3ffbff2",
          "message": "In progress post-merge changes",
          "committedDate": "2024-07-03T09:29:58Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1f84024d454e895016f0f05288f0326b8cf7cbd8",
          "message": "merge from main",
          "committedDate": "2024-07-04T11:04:20Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9616ea3144fa901f06c1ed2ca7675f30bfa771c3",
          "message": "resolved conflicts;\nchanged namespace to Microsoft.Build.Experimental.BuildCheck.Infrastructure for new interfaces",
          "committedDate": "2024-07-04T11:59:46Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "902347a941ffd8ae8febdcbc9d4e55b325c65a4a",
          "message": "Revert \"In progress post-merge changes\"\n\nThis reverts commit 8dbd500da2ebeda93465917a902ff7cfe3ffbff2.",
          "committedDate": "2024-07-04T12:00:11Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f253796bd5556d19864610e6d7add54a8899501e",
          "message": "resolve conflicts",
          "committedDate": "2024-07-04T12:02:59Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dd73119b2b6a90587feab293150d48d0122d4ce0",
          "message": "merge from main",
          "committedDate": "2024-07-04T12:10:21Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0cbb32bc45cc7c06c1f27b6209d411df37ed3037",
          "message": "Avoiding allocations cost on a hot path",
          "committedDate": "2024-07-08T14:10:53Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "65eab0871794333714177f1a263be89047fcd0ea",
          "message": "Update documentation/specs/proposed/BuildCheck-Architecture.md\n\nCo-authored-by: AR-May <67507805+AR-May@users.noreply.github.com>",
          "committedDate": "2024-07-08T14:14:36Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1a869128bc8c1975168907ef0eb065e23adfb487",
          "message": "Address PR comments",
          "committedDate": "2024-07-08T14:24:57Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d37fa445c3716447435951987f613021080a0c93",
          "message": "Merge branch 'proto/buildcheck-properties-wiring' of https://github.com/dotnet/msbuild into proto/buildcheck-properties-wiring",
          "committedDate": "2024-07-08T14:25:08Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6ace4ab0e663e95926a7ab3afdf7ba92ffdd8ef5",
          "message": "Update documentation/specs/proposed/BuildCheck-Architecture.md\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2024-07-23T11:15:05Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "663874c77cd77591f590cb0fbe548f0a128a0d89",
          "message": "Rename handler",
          "committedDate": "2024-07-23T11:51:00Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "95c23c831cb1394a098a41f9791ca9dcf93795d4",
          "message": "Add comments",
          "committedDate": "2024-07-23T11:55:01Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59c061146ccd6b185277de22778c03c4ab479a64",
          "message": "Merge branch 'proto/buildcheck-properties-wiring' of https://github.com/dotnet/msbuild into proto/buildcheck-properties-wiring",
          "committedDate": "2024-07-23T16:42:56Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "34c0a94fc8cf11733ce253cda82a099c3805ff97",
          "message": "Merge branch 'main' into proto/buildcheck-properties-wiring",
          "committedDate": "2024-07-23T16:47:01Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4be3dc1b00040cbdc218b2feb6d90fe3916b1cb5",
          "message": "Adding The ProjectInstanceId to the OM",
          "committedDate": "2024-07-23T17:33:53Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2077197f3ccbe03312f4a365db5b30c8ec983356",
          "message": "Improve naming",
          "committedDate": "2024-07-25T09:36:55Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7c824e64be70e122629b08fe40742f3121592efc",
          "message": "Merge branch 'main' into proto/buildcheck-properties-wiring",
          "committedDate": "2024-07-25T09:37:00Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0574c5202aca367b56226869bf5d2637d28beb0e",
          "message": "Fix projectPath keeping",
          "committedDate": "2024-07-25T12:05:45Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fa52462e66a78458a64667e5c5f58dc112ad0a3c",
          "message": "Comment out the ProjectConfigurationId",
          "committedDate": "2024-07-25T12:11:56Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "42e4e53497e7afccdc524df8a2ef8c8169e05bb0",
          "message": "Fix unused param",
          "committedDate": "2024-07-25T13:44:24Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2daebbba08b10efe21bfc25141224f4f37a7cb17",
          "message": "Allow compat break for experimental API",
          "committedDate": "2024-07-25T14:35:52Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59188ecbe79f1df84a4b6524c62c175fdacdd694",
          "message": "Merge branch 'main' into proto/buildcheck-properties-wiring",
          "committedDate": "2024-07-25T14:58:07Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I'll need to do another round, over the changes. Thank you! ",
        "createdAt": "2024-07-02T15:27:30Z",
        "author": {
          "login": "f-alizada"
        }
      },
      {
        "body": "Btw. there are heavy conflicts with current main - so I'm currently going through a bit of refactoring",
        "createdAt": "2024-07-02T17:49:53Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Exp VS insertion: https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequest/562854",
        "createdAt": "2024-07-08T05:28:15Z",
        "author": {
          "login": "JanKrivanek"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "[learning] Could you please specify the reason of changing that? From my understanding the result should be the same and output message as well. \r\n",
              "createdAt": "2024-07-02T14:54:26Z",
              "path": "src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs",
              "diffHunk": "@@ -148,7 +149,7 @@ public void ProjectShouldHaveValidEvaluationIdDuringEvaluation()\n                             var eventEvaluationId = args.BuildEventContext.EvaluationId;\n \n                             eventEvaluationId.ShouldNotBe(BuildEventContext.InvalidEvaluationId);\n-                            project.LastEvaluationId.ShouldBe(eventEvaluationId);\n+                            project.LastEvaluationId.Should().Be(eventEvaluationId);",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "I hit an internal bug of Shouldly (some internal comparer was null and null ref exception was thrown during this assertion), that I didn't have time to prepare simplified repro and file a bug - but I simply changed to FluentAssertions",
              "createdAt": "2024-07-04T12:20:22Z",
              "path": "src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs",
              "diffHunk": "@@ -148,7 +149,7 @@ public void ProjectShouldHaveValidEvaluationIdDuringEvaluation()\n                             var eventEvaluationId = args.BuildEventContext.EvaluationId;\n \n                             eventEvaluationId.ShouldNotBe(BuildEventContext.InvalidEvaluationId);\n-                            project.LastEvaluationId.ShouldBe(eventEvaluationId);\n+                            project.LastEvaluationId.Should().Be(eventEvaluationId);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a actual case when the BuildCheck Manager instance called but the projecr is unknown? \r\n",
              "createdAt": "2024-07-02T15:13:30Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs",
              "diffHunk": "@@ -376,8 +382,28 @@ public void FinalizeProcessing(LoggingContext loggingContext)\n             loggingContext.LogBuildEvent(analyzerEventArg);\n         }\n \n+        private readonly ConcurrentDictionary<int, string> _projectsByContextId = new();\n+        private string GetProjectFullPath(BuildEventContext buildEventContext)\n+        {\n+            const string defaultProjectFullPath = \"Unknown_Project\";",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "There are cases where some analysis interesting events happen out of context of any project evaluation/build.\r\nExample: Property reads is an event we want to analyze. But there are property reads that can happen even before any build starts (during resolving global toolset, MSBuild uses well known properties to locate the install location of toolsets)",
              "createdAt": "2024-07-04T12:18:43Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs",
              "diffHunk": "@@ -376,8 +382,28 @@ public void FinalizeProcessing(LoggingContext loggingContext)\n             loggingContext.LogBuildEvent(analyzerEventArg);\n         }\n \n+        private readonly ConcurrentDictionary<int, string> _projectsByContextId = new();\n+        private string GetProjectFullPath(BuildEventContext buildEventContext)\n+        {\n+            const string defaultProjectFullPath = \"Unknown_Project\";",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I believe this will be resolved by the mergin main back, is it correct? ",
              "createdAt": "2024-07-02T15:15:07Z",
              "path": "src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs",
              "diffHunk": "@@ -7,11 +7,13 @@\n using System.Text;\n using System.Threading.Tasks;\n using Microsoft.Build.BackEnd;\n-using Microsoft.Build.Experimental.BuildCheck;\n+using Microsoft.Build.BuildCheck.Infrastructure;",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "I fixed this. New classes are now in `Microsoft.Build.Experimental.BuildCheck.Infrastructure` namespace",
              "createdAt": "2024-07-04T12:04:13Z",
              "path": "src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs",
              "diffHunk": "@@ -7,11 +7,13 @@\n using System.Text;\n using System.Threading.Tasks;\n using Microsoft.Build.BackEnd;\n-using Microsoft.Build.Experimental.BuildCheck;\n+using Microsoft.Build.BuildCheck.Infrastructure;",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: put these interfaces and structs in separate files. Also, would be nice to do same for `BuildCheckManagerProvider.cs`",
              "createdAt": "2024-07-04T12:25:02Z",
              "path": "src/Build/BuildCheck/Infrastructure/IBuildEngineDataConsumer.cs",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+\n+internal readonly record struct PropertyReadInfo(\n+    string PropertyName,\n+    int StartIndex,\n+    int EndIndex,\n+    IMsBuildElementLocation ElementLocation,\n+    bool IsUninitialized,\n+    PropertyReadContext PropertyReadContext);\n+\n+/// <summary>\n+/// \n+/// </summary>\n+/// <param name=\"PropertyName\">Name of the property.</param>\n+/// <param name=\"IsEmpty\">Was any value written? (E.g. if we set propA with value propB, while propB is undefined - the isEmpty will be true)</param>\n+/// <param name=\"ElementLocation\">Location of the property write</param>\n+internal readonly record struct PropertyWriteInfo(\n+    string PropertyName,\n+    bool IsEmpty,\n+    IMsBuildElementLocation? ElementLocation);\n+\n+/// <summary>\n+/// Consumer of the data from the build engine.\n+/// Currently, this is used to send data for analysis to the BuildCheck.\n+/// In the future we can multiplex the data to other consumers (e.g. copilot).\n+/// </summary>\n+internal interface IBuildEngineDataConsumer",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nTo simplify the switch between 'in-node direct data' and 'properly remoted data that can be exposed via public OM' we will internaly expose execution data consuming interface - that will be implemented by `LoggingService` as well as BuildCheck infrastructure. This way we can have a simple toggle logic in `LoggingService` that will either forward data to BuildCheck infrastructure (in-proc) or translate them to appropriate `BuildEventArgs` and send them via logging infrastructure.\r\n```",
              "createdAt": "2024-07-04T15:50:50Z",
              "path": "documentation/specs/proposed/BuildCheck-Architecture.md",
              "diffHunk": "@@ -31,6 +31,22 @@ The actual OM exposed to users will be translating/mapping/proxying the underlyi\n ### Sourcing unexposed data from within execution\n \n For agility we'll be able to source internal data during the evaluation and/or execution directly from the build engine, without the `BuildEventArgs` exposure.\n+\n+To simplify the switch between 'in-node direct data' and 'properly remoted data that can be exposed via public OM' we will internaly expose execution data consuming interface - that will be implemented by `LoggingService` as well as BuildCheck infrastructure. This way we can have a simple toggle logic in `LoggingService` that will either forward data to BuildCheck infrastructure (in-proc) or trnaslate them to appropriate `BuildEventArgs` and send them via logging infrastructure.",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: missing summary",
              "createdAt": "2024-07-08T09:00:28Z",
              "path": "src/Build/BuildCheck/Infrastructure/IBuildEngineDataConsumer.cs",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+\n+internal readonly record struct PropertyReadInfo(\n+    string PropertyName,\n+    int StartIndex,\n+    int EndIndex,\n+    IMsBuildElementLocation ElementLocation,\n+    bool IsUninitialized,\n+    PropertyReadContext PropertyReadContext);\n+\n+/// <summary>\n+/// ",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Question: Since this file is shared, can we instead of making this interface public add this file to the project where it is needed?",
              "createdAt": "2024-07-08T10:44:58Z",
              "path": "src/Shared/IElementLocation.cs",
              "diffHunk": "@@ -7,15 +7,16 @@\n \n namespace Microsoft.Build.Shared\n {\n+    internal interface IElementLocation : IMsBuildElementLocation, ITranslatable { }\n+\n     /// <summary>\n     /// Represents the location information for error reporting purposes.  This is normally used to\n     /// associate a run-time error with the original XML.\n     /// This is not used for arbitrary errors from tasks, which store location in a BuildXXXXEventArgs.\n     /// All implementations should be IMMUTABLE.\n-    /// This is not public because the current implementation only provides correct data for unedited projects.\n-    /// DO NOT make it public without considering a solution to this problem.\n+    /// Any editing of the project XML through the MSBuild API's will invalidate locations in that XML until the XML is reloaded.\n     /// </summary>\n-    internal interface IElementLocation : ITranslatable\n+    public interface IMsBuildElementLocation",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "tl;dr;: changed to `internal`\r\n\r\nIt was meant to be public as it is needed in the property read/write OM. But since that OM is internal for now - let's not expose this one either",
              "createdAt": "2024-07-08T14:20:50Z",
              "path": "src/Shared/IElementLocation.cs",
              "diffHunk": "@@ -7,15 +7,16 @@\n \n namespace Microsoft.Build.Shared\n {\n+    internal interface IElementLocation : IMsBuildElementLocation, ITranslatable { }\n+\n     /// <summary>\n     /// Represents the location information for error reporting purposes.  This is normally used to\n     /// associate a run-time error with the original XML.\n     /// This is not used for arbitrary errors from tasks, which store location in a BuildXXXXEventArgs.\n     /// All implementations should be IMMUTABLE.\n-    /// This is not public because the current implementation only provides correct data for unedited projects.\n-    /// DO NOT make it public without considering a solution to this problem.\n+    /// Any editing of the project XML through the MSBuild API's will invalidate locations in that XML until the XML is reloaded.\n     /// </summary>\n-    internal interface IElementLocation : ITranslatable\n+    public interface IMsBuildElementLocation",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Question: I feel like processing property reads/writes in the logging service as a part of API is not a great option. Can't we send an event and then process them in the build check infrastructure?",
              "createdAt": "2024-07-08T10:49:44Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -795,5 +797,11 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)\n         }\n \n         #endregion\n+\n+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "This is intentionall to simplify the switching between 'let's log the data and have BuildCheck consume them as build events' and 'let's consume the data with minimal performance overhead only for the build-in Checks, without exposing it via OM' - which was tried to be explained in the acompanying doc: https://github.com/dotnet/msbuild/pull/10237/files/dd73119b2b6a90587feab293150d48d0122d4ce0#diff-25077216bc2a35e0cdaafbba8e46b1f08ba6957b487e030139291a5f0c544ae5\r\n\r\nPlease have a look on the doc if it feeks it addresses the concern. If not - then let me know if the doc needs to be made more clear, or if you'd want to discuss the design choice",
              "createdAt": "2024-07-08T14:23:21Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -795,5 +797,11 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)\n         }\n \n         #endregion\n+\n+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I think your comment makes it a bit clearer to me than it is written in the docs. I am all for perf gains here. Although, I wonder, maybe instead of exposing the specific functions via the interface, let the logger service to expose a special helper class that will handle these. It might be the `BuildCheckManagerProvider` or a new helper class. I am concerned that for different small hooks that we will need to have in the code for all future build-in analyzers we will have separate small functions like those in multiple places. I want these hooks/functions to be concentrated in a build check related class, for them to be on a correct level of abstraction.\r\n\r\nHowever, this is thinking about future. I am ok with current code given that this is an internal class, and we can refactor it at any time.",
              "createdAt": "2024-07-08T15:47:33Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -795,5 +797,11 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)\n         }\n \n         #endregion\n+\n+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Gotcha - makes sense! And that's how it was meant as well :-)\r\n\r\nhttps://github.com/dotnet/msbuild/pull/10237/files#diff-12416749bc50c91e9746f77619c776d29683fd083b7964f3758d8671f7787a57R59\r\n\r\n```\r\n    internal interface ILoggingService : IBuildComponent, IBuildEngineDataRouter\r\n    {\r\n(...)\r\n\r\n        /// <summary>\r\n        /// Router of the build engine runtime execution information.\r\n        /// </summary>\r\n        IBuildEngineDataRouter BuildEngineDataRouter { get; }\r\n```\r\n\r\nThis is what callers access on the ILoggingService in order to route the data.\r\nIt's just that currently the methods implementing this interface are members of the LoggingService - but in future they can be freely separated into separate class, without breaking any internal code contracts",
              "createdAt": "2024-07-08T16:27:20Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -795,5 +797,11 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)\n         }\n \n         #endregion\n+\n+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Ah, that makes sense!",
              "createdAt": "2024-07-09T06:57:32Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -795,5 +797,11 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)\n         }\n \n         #endregion\n+\n+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nTo simplify the switch between 'in-node direct data' and 'properly remoted data that can be exposed via public OM' we will internally expose execution data consuming interface - that will be implemented by `LoggingService` as well as BuildCheck infrastructure. This way we can have a simple toggle logic in `LoggingService` that will either forward data to BuildCheck infrastructure (in-proc) or translate them to appropriate `BuildEventArgs` and send them via logging infrastructure.\r\n```",
              "createdAt": "2024-07-22T20:01:27Z",
              "path": "documentation/specs/proposed/BuildCheck-Architecture.md",
              "diffHunk": "@@ -31,6 +31,22 @@ The actual OM exposed to users will be translating/mapping/proxying the underlyi\n ### Sourcing unexposed data from within execution\n \n For agility we'll be able to source internal data during the evaluation and/or execution directly from the build engine, without the `BuildEventArgs` exposure.\n+\n+To simplify the switch between 'in-node direct data' and 'properly remoted data that can be exposed via public OM' we will internaly expose execution data consuming interface - that will be implemented by `LoggingService` as well as BuildCheck infrastructure. This way we can have a simple toggle logic in `LoggingService` that will either forward data to BuildCheck infrastructure (in-proc) or translate them to appropriate `BuildEventArgs` and send them via logging infrastructure.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does the `record` here buy us anything, since we're still manually doing fields and such?",
              "createdAt": "2024-07-22T20:10:49Z",
              "path": "src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs",
              "diffHunk": "@@ -15,7 +15,11 @@ namespace Microsoft.Build.Experimental.BuildCheck;\n /// <summary>\n /// <see cref=\"IAnalysisContext\"/> that uses <see cref=\"ILoggingService\"/> to dispatch.\n /// </summary>\n-internal class AnalysisLoggingContext : IAnalysisContext\n+/// <remarks>\n+/// Making this a record struct to avoid allocations (unless called through interface - which leads to boxing).\n+/// This is wanted since this can be used in a hot path (of property reads and writes)\n+/// </remarks>\n+internal readonly record struct AnalysisLoggingContext : IAnalysisContext",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It's mainly to avoid (or better say postpone) allocations when passing data from build execution engine - untill it's decided whether any diagnostics will actually use the data.\r\n\r\nSpecifically here: https://github.com/dotnet/msbuild/pull/10237/files#diff-7de9562a624a633b107b17a69555c5ad62fa40481e12921281e1afd375d997d0R319\r\n\r\n```\r\n        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo)\r\n            => _loggingService.BuildEngineDataRouter.ProcessPropertyRead(\r\n                    propertyReadInfo,\r\n                    new AnalysisLoggingContext(_loggingService, BuildEventContext));\r\n```",
              "createdAt": "2024-07-23T11:18:10Z",
              "path": "src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs",
              "diffHunk": "@@ -15,7 +15,11 @@ namespace Microsoft.Build.Experimental.BuildCheck;\n /// <summary>\n /// <see cref=\"IAnalysisContext\"/> that uses <see cref=\"ILoggingService\"/> to dispatch.\n /// </summary>\n-internal class AnalysisLoggingContext : IAnalysisContext\n+/// <remarks>\n+/// Making this a record struct to avoid allocations (unless called through interface - which leads to boxing).\n+/// This is wanted since this can be used in a hot path (of property reads and writes)\n+/// </remarks>\n+internal readonly record struct AnalysisLoggingContext : IAnalysisContext",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Oh I misunderstood the question  yeah no need to be a record, just struct - fixing..",
              "createdAt": "2024-07-23T16:52:29Z",
              "path": "src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs",
              "diffHunk": "@@ -15,7 +15,11 @@ namespace Microsoft.Build.Experimental.BuildCheck;\n /// <summary>\n /// <see cref=\"IAnalysisContext\"/> that uses <see cref=\"ILoggingService\"/> to dispatch.\n /// </summary>\n-internal class AnalysisLoggingContext : IAnalysisContext\n+/// <remarks>\n+/// Making this a record struct to avoid allocations (unless called through interface - which leads to boxing).\n+/// This is wanted since this can be used in a hot path (of property reads and writes)\n+/// </remarks>\n+internal readonly record struct AnalysisLoggingContext : IAnalysisContext",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: why is this named `HandleEndProjectRequest` instead of `HandleProjectFinishedEvent`?",
              "createdAt": "2024-07-22T20:11:32Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs",
              "diffHunk": "@@ -32,7 +32,7 @@ internal class BuildCheckBuildEventHandler\n             { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs)e) },\n             { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs)e) },\n             { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },\n-            { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => _buildCheckManager.EndProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },\n+            { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => HandleEndProjectRequest((ProjectFinishedEventArgs)e) },",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Having path here strikes me as odd. How do we disambiguate between the same project in two different sets of global properties? Should it be a project id?",
              "createdAt": "2024-07-22T20:14:47Z",
              "path": "src/Build/BuildCheck/OM/PropertyReadData.cs",
              "diffHunk": "@@ -0,0 +1,51 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck;\n+\n+/// <summary>\n+/// Information about property being accessed - whether during evaluation or build.\n+/// </summary>\n+internal class PropertyReadData(\n+    string projectFilePath,",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This is a good point!\r\n\r\nWe mainly use project full path - for a buildcheck infra (to configure checks, to form the diagnostic message). But we should most likely surface the project context id in the OM for the Check authors (as well as ourselves) - to allow proper events attributing and grouping...\r\n\r\nI'm looking into this now...",
              "createdAt": "2024-07-23T11:26:15Z",
              "path": "src/Build/BuildCheck/OM/PropertyReadData.cs",
              "diffHunk": "@@ -0,0 +1,51 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Experimental.BuildCheck;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck;\n+\n+/// <summary>\n+/// Information about property being accessed - whether during evaluation or build.\n+/// </summary>\n+internal class PropertyReadData(\n+    string projectFilePath,",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "No project-instance context here?",
              "createdAt": "2024-07-22T20:15:55Z",
              "path": "src/Build/BuildCheck/Infrastructure/InternalOM/PropertyWriteInfo.cs",
              "diffHunk": "@@ -0,0 +1,17 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+\n+/// <summary>\n+/// Bag of information for a performed property write.\n+/// </summary>\n+/// <param name=\"PropertyName\">Name of the property.</param>\n+/// <param name=\"IsEmpty\">Was any value written? (E.g. if we set propA with value propB, while propB is undefined - the isEmpty will be true)</param>\n+/// <param name=\"ElementLocation\">Location of the property write</param>\n+internal readonly record struct PropertyWriteInfo(",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It is attached separately as `AnalysisContext` - and then passed to `PropertyWriteData` OM",
              "createdAt": "2024-07-23T11:24:18Z",
              "path": "src/Build/BuildCheck/Infrastructure/InternalOM/PropertyWriteInfo.cs",
              "diffHunk": "@@ -0,0 +1,17 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+\n+/// <summary>\n+/// Bag of information for a performed property write.\n+/// </summary>\n+/// <param name=\"PropertyName\">Name of the property.</param>\n+/// <param name=\"IsEmpty\">Was any value written? (E.g. if we set propA with value propB, while propB is undefined - the isEmpty will be true)</param>\n+/// <param name=\"ElementLocation\">Location of the property write</param>\n+internal readonly record struct PropertyWriteInfo(",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It's not obvious to me from this file what `StartIndex`/`EndIndex` mean here. Elaborate please?",
              "createdAt": "2024-07-22T20:16:35Z",
              "path": "src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs",
              "diffHunk": "@@ -0,0 +1,24 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+\n+/// <summary>\n+/// Bag of information for a performed property read.\n+/// </summary>\n+/// <param name=\"PropertyName\"></param>\n+/// <param name=\"StartIndex\"></param>\n+/// <param name=\"EndIndex\"></param>\n+/// <param name=\"ElementLocation\"></param>\n+/// <param name=\"IsUninitialized\"></param>\n+/// <param name=\"PropertyReadContext\"></param>\n+internal readonly record struct PropertyReadInfo(\n+    string PropertyName,\n+    int StartIndex,\n+    int EndIndex,",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "xml doc comments added",
              "createdAt": "2024-07-23T11:55:11Z",
              "path": "src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs",
              "diffHunk": "@@ -0,0 +1,24 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;\n+\n+/// <summary>\n+/// Bag of information for a performed property read.\n+/// </summary>\n+/// <param name=\"PropertyName\"></param>\n+/// <param name=\"StartIndex\"></param>\n+/// <param name=\"EndIndex\"></param>\n+/// <param name=\"ElementLocation\"></param>\n+/// <param name=\"IsUninitialized\"></param>\n+/// <param name=\"PropertyReadContext\"></param>\n+internal readonly record struct PropertyReadInfo(\n+    string PropertyName,\n+    int StartIndex,\n+    int EndIndex,",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't get it and would appreciate some elaboration.",
              "createdAt": "2024-07-22T21:20:32Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs",
              "diffHunk": "@@ -381,10 +386,30 @@ public void FinalizeProcessing(LoggingContext loggingContext)\n             loggingContext.LogBuildEvent(analyzerEventArg);\n         }\n \n+        private readonly ConcurrentDictionary<int, string> _projectsByContextId = new();\n+        private string GetProjectFullPath(BuildEventContext buildEventContext)\n+        {\n+            const string defaultProjectFullPath = \"Unknown_Project\";\n+\n+            if (_projectsByContextId.TryGetValue(buildEventContext.ProjectContextId, out string? projectFullPath))\n+            {\n+                return projectFullPath;\n+            }\n+            else if (buildEventContext.ProjectContextId == BuildEventContext.InvalidProjectContextId &&\n+                     _projectsByContextId.Count == 1)\n+            {\n+                // The coalescing is for a rare possibility of a race where other thread removed the item.\n+                // We currently do not support multiple projects in parallel in a single node anyway.\n+                return _projectsByContextId.FirstOrDefault().Value ?? defaultProjectFullPath;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Yeah, extracting the path here still feels wrong to me.",
              "createdAt": "2024-07-22T21:27:46Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs",
              "diffHunk": "@@ -412,8 +438,35 @@ public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, Build\n         {\n         }\n \n-        public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)\n+        public void EndProjectRequest(\n+            BuildCheckDataSource buildCheckDataSource,\n+            IAnalysisContext analysisContext,\n+            string projectFullPath)\n+        {\n+            _buildEventsProcessor.ProcessProjectDone(analysisContext, projectFullPath);\n+            _projectsByContextId.TryRemove(analysisContext.BuildEventContext.ProjectContextId, out _);\n+        }\n+\n+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)\n         {\n+            if (!_buildCheckCentralContext.HasPropertyReadActions)\n+            {\n+                return;\n+            }\n+\n+            PropertyReadData propertyReadData = new(GetProjectFullPath(analysisContext.BuildEventContext), propertyReadInfo);\n+            _buildEventsProcessor.ProcessPropertyRead(propertyReadData, analysisContext);\n+        }\n+\n+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext analysisContext)\n+        {\n+            if (!_buildCheckCentralContext.HasPropertyWriteActions)\n+            {\n+                return;\n+            }\n+\n+            PropertyWriteData propertyWriteData = new(GetProjectFullPath(analysisContext.BuildEventContext), propertyWriteInfo);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This is for infra - it needs to know path for configuration. Based on the context id it fetches the path.\r\n\r\nI'm not seeing the concern - maybe a quick sync is needed on this? :-)",
              "createdAt": "2024-07-23T11:30:29Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs",
              "diffHunk": "@@ -412,8 +438,35 @@ public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, Build\n         {\n         }\n \n-        public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)\n+        public void EndProjectRequest(\n+            BuildCheckDataSource buildCheckDataSource,\n+            IAnalysisContext analysisContext,\n+            string projectFullPath)\n+        {\n+            _buildEventsProcessor.ProcessProjectDone(analysisContext, projectFullPath);\n+            _projectsByContextId.TryRemove(analysisContext.BuildEventContext.ProjectContextId, out _);\n+        }\n+\n+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)\n         {\n+            if (!_buildCheckCentralContext.HasPropertyReadActions)\n+            {\n+                return;\n+            }\n+\n+            PropertyReadData propertyReadData = new(GetProjectFullPath(analysisContext.BuildEventContext), propertyReadInfo);\n+            _buildEventsProcessor.ProcessPropertyRead(propertyReadData, analysisContext);\n+        }\n+\n+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext analysisContext)\n+        {\n+            if (!_buildCheckCentralContext.HasPropertyWriteActions)\n+            {\n+                return;\n+            }\n+\n+            PropertyWriteData propertyWriteData = new(GetProjectFullPath(analysisContext.BuildEventContext), propertyWriteInfo);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "As agreed - file path is still needed. The ProjectInstanceId will as well be added",
              "createdAt": "2024-07-23T17:29:55Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs",
              "diffHunk": "@@ -412,8 +438,35 @@ public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, Build\n         {\n         }\n \n-        public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)\n+        public void EndProjectRequest(\n+            BuildCheckDataSource buildCheckDataSource,\n+            IAnalysisContext analysisContext,\n+            string projectFullPath)\n+        {\n+            _buildEventsProcessor.ProcessProjectDone(analysisContext, projectFullPath);\n+            _projectsByContextId.TryRemove(analysisContext.BuildEventContext.ProjectContextId, out _);\n+        }\n+\n+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)\n         {\n+            if (!_buildCheckCentralContext.HasPropertyReadActions)\n+            {\n+                return;\n+            }\n+\n+            PropertyReadData propertyReadData = new(GetProjectFullPath(analysisContext.BuildEventContext), propertyReadInfo);\n+            _buildEventsProcessor.ProcessPropertyRead(propertyReadData, analysisContext);\n+        }\n+\n+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext analysisContext)\n+        {\n+            if (!_buildCheckCentralContext.HasPropertyWriteActions)\n+            {\n+                return;\n+            }\n+\n+            PropertyWriteData propertyWriteData = new(GetProjectFullPath(analysisContext.BuildEventContext), propertyWriteInfo);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}