{
  "number": 5699,
  "title": "RAR as a Service: Transfer and execution ",
  "body": "This PR closes #5556 and #5557.\r\n\r\nWhen this PR is closed it will provide functionality to delegate work to RAR node (implemented by #5555). \r\n\r\nIn this PR I provide necessary functionality to delegate work of RAR task to RAR node.\r\n\r\nI have added code mostly into  `src\\Tasks\\ResolveAssemblyReferences\\`:\r\n**Client**\r\nContains all logic for client to construct connection and to delegate work.\r\n**Contract**\r\nDTOs and interface which client expects server to have.\r\n**Formatters**\r\nCustom written formatters, so we don't wait for them to be constructed dynamically, which adds extra cost to 1st request.\r\n**Server**\r\nServer side logic for handling connection\r\n**Services**\r\nLogic used during execution of RAR task. In future, there should be added caching layer, etc.\r\n",
  "state": "CLOSED",
  "createdAt": "2020-09-02T06:31:41Z",
  "updatedAt": "2021-01-08T12:22:01Z",
  "closedAt": "2021-01-08T12:07:54Z",
  "mergedAt": null,
  "additions": 1996,
  "deletions": 158,
  "changedFiles": 38,
  "headRefName": "rarAsService/transfer",
  "isDraft": false,
  "author": {
    "login": "ostorc"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "ea48eaad4a89549611f6011e46c3706c77a20ac4",
          "message": "RAR Input",
          "committedDate": "2020-08-17T08:15:56Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f3f4fa1c323dbd203dc904392d214274ad37bf2e",
          "message": "Contract finalization\n\nTODO: Logs are serialized in not optimal way. Find better solution",
          "committedDate": "2020-08-21T11:11:00Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "30650da5a8a823764567f5b420220184d55ed0ec",
          "message": "Node shutdown from comandline via cancelation token",
          "committedDate": "2020-08-21T11:11:59Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b4689a7183d1e3781e669d45b25f9e6187052b2c",
          "message": "Generilize api from NamedPipeClientStream to Stream",
          "committedDate": "2020-08-21T11:12:36Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "adfbb86b6e8d9cf40bd141032ef87e07ad6c44dd",
          "message": "Merge branch 'rarAsService/node' into rarAsService/transfer",
          "committedDate": "2020-08-21T11:14:45Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f70b26d9adf80594f5addced7e190a16b78d5547",
          "message": "Refactoring",
          "committedDate": "2020-08-25T09:13:15Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6752388337c4cc9231aec211bb3c6379aa7cf987",
          "message": "Basic tests for RAR transfer",
          "committedDate": "2020-08-25T09:18:08Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d87881836d2be3ff0b793cedf2c8348ece4fae79",
          "message": "WIP",
          "committedDate": "2020-08-26T15:42:58Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9bb7883ed41630c9a7ad18b0f749688b6f32561e",
          "message": "Merge branch 'rarAsService/node'",
          "committedDate": "2020-08-26T17:23:50Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ade41d8110a2994e3b4d12db7bf4a6f2105afba2",
          "message": "WIP",
          "committedDate": "2020-08-30T10:16:47Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c56d61a633094bbc2db3f7e1992305113d928223",
          "message": "Merge branch 'rarAsService/node' into rarAsService/transfer",
          "committedDate": "2020-08-31T17:13:02Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7022a2f707a573c372f3f7f94975561d53ed3559",
          "message": "Add node expiration timeout",
          "committedDate": "2020-08-31T19:50:02Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ce11fa44f325f76908f682fce57926be5ca48bf8",
          "message": "Merge branch 'rarAsService/node' into rarAsService/transfer",
          "committedDate": "2020-09-01T11:27:14Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8675b69ae0afbabbdc38ec3a3de42a7ae8fa5554",
          "message": "Merge branch 'master' into rarAsService/transfer",
          "committedDate": "2020-09-01T12:48:23Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ba70b3e5eba68bcecb87bcef27e44ec1171f7441",
          "message": "WIP",
          "committedDate": "2020-09-01T18:29:36Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "995b9d39468310b99703707e11715bc057968ce6",
          "message": "Tests update",
          "committedDate": "2020-09-10T09:19:20Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "75cd9f8feda0a4ab11679aef5216afb09c182ab8",
          "message": "Formatters",
          "committedDate": "2020-09-10T09:19:53Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "03ace9c7b10bc5bbe920c87cf52a7720db0984c3",
          "message": "Relative path to absolute path delegate",
          "committedDate": "2020-09-10T13:03:25Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "578c71a0c7a00bc9c7cc86fa9d6f1ff236167a24",
          "message": "WIP",
          "committedDate": "2020-09-10T14:35:40Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c660352d93239c7800bbf16b663ae1668a83d1c0",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2020-09-10T14:46:16Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "storc.1998@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3505f724a0931471bbe90ce7a6d567a80c0c80b5",
          "message": "Ref and other things",
          "committedDate": "2020-09-10T14:49:17Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "04ae1d11a7e03555fa0cc221b171850102fbb46b",
          "message": "Merge",
          "committedDate": "2020-09-10T14:53:23Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ca44b6ab5349801c8875ae6e2672cb3c4d9e8466",
          "message": "Build fix",
          "committedDate": "2020-09-10T15:23:32Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d678b4c9e7571cc08f9a3b707de3cbb6da8631e5",
          "message": "Fix test",
          "committedDate": "2020-09-10T15:39:15Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dd64b8e3d856262e2c677ab2bf6209b8e70e6b17",
          "message": "Remove get rooted path from unnecessary files",
          "committedDate": "2020-09-10T16:06:59Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "70328bf8e398cd8ec71a735284a5a9bfd385fd84",
          "message": "Build fix",
          "committedDate": "2020-09-10T16:07:36Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9f52aba35bc3d6a640f88dfddca9d33912dc00b3",
          "message": "Comments fix",
          "committedDate": "2020-09-10T16:10:38Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "40d1d51da64eff35916ccaa2ce65adda33bc4a9a",
          "message": "Fix build",
          "committedDate": "2020-09-10T16:25:42Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "72b6e8a72c93da9832cda679029bc3d7146bf794",
          "message": "Build fix #2",
          "committedDate": "2020-09-10T16:39:58Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a3bb1f9094bf0192cb516ecf2cae0108be2c295a",
          "message": "PR comments",
          "committedDate": "2020-09-11T15:27:59Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "49341d92f5b4a40a89f90b1e62257435c557111e",
          "message": "Merge remote-tracking branch 'ms/master' into rarAsService/transfer",
          "committedDate": "2020-09-11T16:25:54Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "30f52af8b52072b8ac740e1b74c6d2ae46ce3f64",
          "message": "Merge remote-tracking branch 'ms/master' into rarAsService/transfer",
          "committedDate": "2020-09-15T11:12:42Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "37329208b8db706d4ba8b1b18fd971478b2450e0",
          "message": "PR comments and refacttoring",
          "committedDate": "2020-09-17T18:01:42Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5f501a67eae154404c5ae1c8dc8ab8d28a104043",
          "message": "Remove unnecessary reference",
          "committedDate": "2020-09-17T18:04:15Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "92a49656f276e05ba78323e01ef88025f48af3b9",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2020-09-21T17:06:06Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "storc.1998@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "414616b70a5a177e8b966859261916fb104448a7",
          "message": "PR comments",
          "committedDate": "2020-09-21T17:18:01Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0185da04eca37e04287bbdaa7190b685d4558566",
          "message": "Formatter redo and some PR comments changes",
          "committedDate": "2020-09-23T20:12:30Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "72b498d2ccb78f04794e464ca4c5f0ac780b8277",
          "message": "Simplify name",
          "committedDate": "2020-09-23T20:17:18Z",
          "author": {
            "name": "Ond\u0159ej \u0160torc",
            "email": "t-ostorc@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "/azp run",
        "createdAt": "2020-09-10T17:41:29Z",
        "author": {
          "login": "ostorc"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2020-09-10T17:41:38Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "We'll submit a fresh set of PRs as we reboot the RAR service effort. We'll be looking at this PR and the reverted #5613 for inspiration but it can be closed now.",
        "createdAt": "2021-01-08T12:07:54Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks like a breaking change. Same for other similar types of changes.",
              "createdAt": "2020-09-02T22:18:39Z",
              "path": "src/Framework/BuildErrorEventArgs.cs",
              "diffHunk": "@@ -212,7 +212,7 @@ public BuildErrorEventArgs\n         /// <summary>\n         /// Default constructor\n         /// </summary>\n-        protected BuildErrorEventArgs()",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Without having looked at them, are all of these necessary?",
              "createdAt": "2020-09-02T22:18:55Z",
              "path": "ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -2166,6 +2166,163 @@ public partial interface IVbcHostObjectFreeThreaded\n         bool Compile();\n     }\n }\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract\n+{\n+    [MessagePack.MessagePackObjectAttribute(false)]\n+    public sealed partial class ReadOnlyTaskItem : Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2\n+    {\n+        public ReadOnlyTaskItem(string itemSpec) { }\n+        [MessagePack.IgnoreMemberAttribute]\n+        public string EvaluatedIncludeEscaped { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(0)]\n+        public string ItemSpec { get { throw null; } set { } }\n+        [MessagePack.IgnoreMemberAttribute]\n+        public int MetadataCount { get { throw null; } set { } }\n+        [MessagePack.IgnoreMemberAttribute]\n+        public System.Collections.ICollection MetadataNames { get { throw null; } }\n+        [MessagePack.KeyAttribute(1)]\n+        public System.Collections.Generic.Dictionary<string, string> MetadataNameToValue { get { throw null; } set { } }\n+        public System.Collections.IDictionary CloneCustomMetadata() { throw null; }\n+        public System.Collections.IDictionary CloneCustomMetadataEscaped() { throw null; }\n+        public void CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) { }\n+        public string GetMetadata(string metadataName) { throw null; }\n+        public string GetMetadataValueEscaped(string metadataName) { throw null; }\n+        public void RemoveMetadata(string metadataName) { }\n+        public void SetMetadata(string metadataName, string metadataValue) { }\n+        public void SetMetadataValueLiteral(string metadataName, string metadataValue) { }\n+    }\n+    [MessagePack.MessagePackObjectAttribute(false)]\n+    public sealed partial class ResolveAssemblyReferenceRequest\n+    {\n+        public ResolveAssemblyReferenceRequest() { }\n+        [MessagePack.KeyAttribute(0)]\n+        public string[] AllowedAssemblyExtensions { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(1)]\n+        public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(2)]\n+        public string AppConfigFile { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(3)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] Assemblies { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(4)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] AssemblyFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(5)]\n+        public bool AutoUnify { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(6)]\n+        public string[] CandidateAssemblyFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(7)]\n+        public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(8)]\n+        public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(9)]\n+        public bool FindDependencies { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(10)]\n+        public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(11)]\n+        public bool FindRelatedFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(12)]\n+        public bool FindSatellites { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(13)]\n+        public bool FindSerializationAssemblies { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(14)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(15)]\n+        public string[] FullFrameworkFolders { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(16)]\n+        public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(17)]\n+        public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(18)]\n+        public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(19)]\n+        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(20)]\n+        public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(21)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(22)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblyTables { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(23)]\n+        public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(24)]\n+        public string ProfileName { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(25)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedSDKReferences { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(26)]\n+        public string[] SearchPaths { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(27)]\n+        public bool Silent { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(28)]\n+        public string StateFile { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(29)]\n+        public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(30)]\n+        public string TargetedRuntimeVersion { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(31)]\n+        public string[] TargetFrameworkDirectories { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(32)]\n+        public string TargetFrameworkMoniker { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(33)]\n+        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(34)]\n+        public string[] TargetFrameworkSubsets { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(35)]\n+        public string TargetFrameworkVersion { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(36)]\n+        public string TargetProcessorArchitecture { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(37)]\n+        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(38)]\n+        public bool UseResolveAssemblyReferenceService { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(39)]\n+        public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }\n+    }\n+    [MessagePack.MessagePackObjectAttribute(false)]\n+    public sealed partial class ResolveAssemblyReferenceResponse\n+    {\n+        public ResolveAssemblyReferenceResponse() { }\n+        [MessagePack.KeyAttribute(0)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] CopyLocalFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(1)]\n+        public string DependsOnNETStandard { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(2)]\n+        public string DependsOnSystemRuntime { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(3)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FilesWritten { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(4)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] RelatedFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(5)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedDependencyFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(6)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(7)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SatelliteFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(8)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ScatterFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(9)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SerializationAssemblyFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(10)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SuggestedRedirects { get { throw null; } set { } }\n+    }\n+    [MessagePack.MessagePackObjectAttribute(false)]\n+    public sealed partial class ResolveAssemblyReferenceResult\n+    {\n+        public ResolveAssemblyReferenceResult() { }\n+        [MessagePack.KeyAttribute(4)]\n+        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildErrorEventArgs> BuildErrorEvents { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(5)]\n+        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildMessageEventArgs> BuildMessageEvents { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(6)]\n+        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildWarningEventArgs> BuildWarningEvents { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(3)]",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Removed",
              "createdAt": "2020-09-17T18:02:21Z",
              "path": "ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -2166,6 +2166,163 @@ public partial interface IVbcHostObjectFreeThreaded\n         bool Compile();\n     }\n }\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract\n+{\n+    [MessagePack.MessagePackObjectAttribute(false)]\n+    public sealed partial class ReadOnlyTaskItem : Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2\n+    {\n+        public ReadOnlyTaskItem(string itemSpec) { }\n+        [MessagePack.IgnoreMemberAttribute]\n+        public string EvaluatedIncludeEscaped { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(0)]\n+        public string ItemSpec { get { throw null; } set { } }\n+        [MessagePack.IgnoreMemberAttribute]\n+        public int MetadataCount { get { throw null; } set { } }\n+        [MessagePack.IgnoreMemberAttribute]\n+        public System.Collections.ICollection MetadataNames { get { throw null; } }\n+        [MessagePack.KeyAttribute(1)]\n+        public System.Collections.Generic.Dictionary<string, string> MetadataNameToValue { get { throw null; } set { } }\n+        public System.Collections.IDictionary CloneCustomMetadata() { throw null; }\n+        public System.Collections.IDictionary CloneCustomMetadataEscaped() { throw null; }\n+        public void CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) { }\n+        public string GetMetadata(string metadataName) { throw null; }\n+        public string GetMetadataValueEscaped(string metadataName) { throw null; }\n+        public void RemoveMetadata(string metadataName) { }\n+        public void SetMetadata(string metadataName, string metadataValue) { }\n+        public void SetMetadataValueLiteral(string metadataName, string metadataValue) { }\n+    }\n+    [MessagePack.MessagePackObjectAttribute(false)]\n+    public sealed partial class ResolveAssemblyReferenceRequest\n+    {\n+        public ResolveAssemblyReferenceRequest() { }\n+        [MessagePack.KeyAttribute(0)]\n+        public string[] AllowedAssemblyExtensions { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(1)]\n+        public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(2)]\n+        public string AppConfigFile { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(3)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] Assemblies { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(4)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] AssemblyFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(5)]\n+        public bool AutoUnify { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(6)]\n+        public string[] CandidateAssemblyFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(7)]\n+        public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(8)]\n+        public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(9)]\n+        public bool FindDependencies { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(10)]\n+        public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(11)]\n+        public bool FindRelatedFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(12)]\n+        public bool FindSatellites { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(13)]\n+        public bool FindSerializationAssemblies { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(14)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(15)]\n+        public string[] FullFrameworkFolders { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(16)]\n+        public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(17)]\n+        public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(18)]\n+        public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(19)]\n+        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(20)]\n+        public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(21)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(22)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblyTables { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(23)]\n+        public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(24)]\n+        public string ProfileName { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(25)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedSDKReferences { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(26)]\n+        public string[] SearchPaths { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(27)]\n+        public bool Silent { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(28)]\n+        public string StateFile { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(29)]\n+        public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(30)]\n+        public string TargetedRuntimeVersion { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(31)]\n+        public string[] TargetFrameworkDirectories { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(32)]\n+        public string TargetFrameworkMoniker { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(33)]\n+        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(34)]\n+        public string[] TargetFrameworkSubsets { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(35)]\n+        public string TargetFrameworkVersion { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(36)]\n+        public string TargetProcessorArchitecture { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(37)]\n+        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(38)]\n+        public bool UseResolveAssemblyReferenceService { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(39)]\n+        public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }\n+    }\n+    [MessagePack.MessagePackObjectAttribute(false)]\n+    public sealed partial class ResolveAssemblyReferenceResponse\n+    {\n+        public ResolveAssemblyReferenceResponse() { }\n+        [MessagePack.KeyAttribute(0)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] CopyLocalFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(1)]\n+        public string DependsOnNETStandard { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(2)]\n+        public string DependsOnSystemRuntime { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(3)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FilesWritten { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(4)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] RelatedFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(5)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedDependencyFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(6)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(7)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SatelliteFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(8)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ScatterFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(9)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SerializationAssemblyFiles { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(10)]\n+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SuggestedRedirects { get { throw null; } set { } }\n+    }\n+    [MessagePack.MessagePackObjectAttribute(false)]\n+    public sealed partial class ResolveAssemblyReferenceResult\n+    {\n+        public ResolveAssemblyReferenceResult() { }\n+        [MessagePack.KeyAttribute(4)]\n+        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildErrorEventArgs> BuildErrorEvents { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(5)]\n+        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildMessageEventArgs> BuildMessageEvents { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(6)]\n+        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildWarningEventArgs> BuildWarningEvents { get { throw null; } set { } }\n+        [MessagePack.KeyAttribute(3)]",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Copyright header * all new files",
              "createdAt": "2020-09-02T22:21:21Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/BaseComparer.cs",
              "diffHunk": "@@ -0,0 +1,24 @@\n+\ufeffusing System;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\ny != null should be captured by the above case.",
              "createdAt": "2020-09-02T22:23:23Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/RARRequestComparer.cs",
              "diffHunk": "@@ -0,0 +1,71 @@\n+\ufeffusing Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+\n+    internal class RARRequestComparer\n+        : BaseComparer<ResolveAssemblyReferenceRequest>\n+    {\n+        internal static IEqualityComparer<ResolveAssemblyReferenceRequest> Instance { get; } = new RARRequestComparer();\n+\n+        private static readonly IEqualityComparer<string> StringEqualityComparer = StringComparer.InvariantCulture;\n+\n+        private RARRequestComparer() { }\n+\n+        public override bool Equals(ResolveAssemblyReferenceRequest x, ResolveAssemblyReferenceRequest y)\n+        {\n+            // Same reference or null\n+            if (x == y)\n+                return true;\n+\n+            if (x == null || y == null)\n+                return false;\n+\n+            bool fieldsEqual = y != null &&",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm tempted to suggest using reflection to avoid having to enumerate all of these, but that would be slower...\r\n\ud83d\ude22 ",
              "createdAt": "2020-09-02T22:31:08Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/RARRequestComparer.cs",
              "diffHunk": "@@ -0,0 +1,71 @@\n+\ufeffusing Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+\n+    internal class RARRequestComparer\n+        : BaseComparer<ResolveAssemblyReferenceRequest>\n+    {\n+        internal static IEqualityComparer<ResolveAssemblyReferenceRequest> Instance { get; } = new RARRequestComparer();\n+\n+        private static readonly IEqualityComparer<string> StringEqualityComparer = StringComparer.InvariantCulture;\n+\n+        private RARRequestComparer() { }\n+\n+        public override bool Equals(ResolveAssemblyReferenceRequest x, ResolveAssemblyReferenceRequest y)\n+        {\n+            // Same reference or null\n+            if (x == y)\n+                return true;\n+\n+            if (x == null || y == null)\n+                return false;\n+\n+            bool fieldsEqual = y != null &&\n+                   x.AppConfigFile == y.AppConfigFile &&\n+                   x.AutoUnify == y.AutoUnify &&\n+                   x.CopyLocalDependenciesWhenParentReferenceInGac == y.CopyLocalDependenciesWhenParentReferenceInGac &&\n+                   x.DoNotCopyLocalIfInGac == y.DoNotCopyLocalIfInGac &&\n+                   x.FindDependencies == y.FindDependencies &&\n+                   x.FindDependenciesOfExternallyResolvedReferences == y.FindDependenciesOfExternallyResolvedReferences &&\n+                   x.FindRelatedFiles == y.FindRelatedFiles &&\n+                   x.FindSatellites == y.FindSatellites &&\n+                   x.FindSerializationAssemblies == y.FindSerializationAssemblies &&\n+                   x.IgnoreDefaultInstalledAssemblySubsetTables == y.IgnoreDefaultInstalledAssemblySubsetTables &&\n+                   x.IgnoreDefaultInstalledAssemblyTables == y.IgnoreDefaultInstalledAssemblyTables &&\n+                   x.IgnoreTargetFrameworkAttributeVersionMismatch == y.IgnoreTargetFrameworkAttributeVersionMismatch &&\n+                   x.IgnoreVersionForFrameworkReferences == y.IgnoreVersionForFrameworkReferences &&",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Actually, would that be a problem? This is in a test file, so speed isn't critical.",
              "createdAt": "2020-09-02T22:33:12Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/RARRequestComparer.cs",
              "diffHunk": "@@ -0,0 +1,71 @@\n+\ufeffusing Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+\n+    internal class RARRequestComparer\n+        : BaseComparer<ResolveAssemblyReferenceRequest>\n+    {\n+        internal static IEqualityComparer<ResolveAssemblyReferenceRequest> Instance { get; } = new RARRequestComparer();\n+\n+        private static readonly IEqualityComparer<string> StringEqualityComparer = StringComparer.InvariantCulture;\n+\n+        private RARRequestComparer() { }\n+\n+        public override bool Equals(ResolveAssemblyReferenceRequest x, ResolveAssemblyReferenceRequest y)\n+        {\n+            // Same reference or null\n+            if (x == y)\n+                return true;\n+\n+            if (x == null || y == null)\n+                return false;\n+\n+            bool fieldsEqual = y != null &&\n+                   x.AppConfigFile == y.AppConfigFile &&\n+                   x.AutoUnify == y.AutoUnify &&\n+                   x.CopyLocalDependenciesWhenParentReferenceInGac == y.CopyLocalDependenciesWhenParentReferenceInGac &&\n+                   x.DoNotCopyLocalIfInGac == y.DoNotCopyLocalIfInGac &&\n+                   x.FindDependencies == y.FindDependencies &&\n+                   x.FindDependenciesOfExternallyResolvedReferences == y.FindDependenciesOfExternallyResolvedReferences &&\n+                   x.FindRelatedFiles == y.FindRelatedFiles &&\n+                   x.FindSatellites == y.FindSatellites &&\n+                   x.FindSerializationAssemblies == y.FindSerializationAssemblies &&\n+                   x.IgnoreDefaultInstalledAssemblySubsetTables == y.IgnoreDefaultInstalledAssemblySubsetTables &&\n+                   x.IgnoreDefaultInstalledAssemblyTables == y.IgnoreDefaultInstalledAssemblyTables &&\n+                   x.IgnoreTargetFrameworkAttributeVersionMismatch == y.IgnoreTargetFrameworkAttributeVersionMismatch &&\n+                   x.IgnoreVersionForFrameworkReferences == y.IgnoreVersionForFrameworkReferences &&",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This code was moved to the service, so I will stick with the hardcoded approach",
              "createdAt": "2020-09-14T08:38:51Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/RARRequestComparer.cs",
              "diffHunk": "@@ -0,0 +1,71 @@\n+\ufeffusing Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+\n+    internal class RARRequestComparer\n+        : BaseComparer<ResolveAssemblyReferenceRequest>\n+    {\n+        internal static IEqualityComparer<ResolveAssemblyReferenceRequest> Instance { get; } = new RARRequestComparer();\n+\n+        private static readonly IEqualityComparer<string> StringEqualityComparer = StringComparer.InvariantCulture;\n+\n+        private RARRequestComparer() { }\n+\n+        public override bool Equals(ResolveAssemblyReferenceRequest x, ResolveAssemblyReferenceRequest y)\n+        {\n+            // Same reference or null\n+            if (x == y)\n+                return true;\n+\n+            if (x == null || y == null)\n+                return false;\n+\n+            bool fieldsEqual = y != null &&\n+                   x.AppConfigFile == y.AppConfigFile &&\n+                   x.AutoUnify == y.AutoUnify &&\n+                   x.CopyLocalDependenciesWhenParentReferenceInGac == y.CopyLocalDependenciesWhenParentReferenceInGac &&\n+                   x.DoNotCopyLocalIfInGac == y.DoNotCopyLocalIfInGac &&\n+                   x.FindDependencies == y.FindDependencies &&\n+                   x.FindDependenciesOfExternallyResolvedReferences == y.FindDependenciesOfExternallyResolvedReferences &&\n+                   x.FindRelatedFiles == y.FindRelatedFiles &&\n+                   x.FindSatellites == y.FindSatellites &&\n+                   x.FindSerializationAssemblies == y.FindSerializationAssemblies &&\n+                   x.IgnoreDefaultInstalledAssemblySubsetTables == y.IgnoreDefaultInstalledAssemblySubsetTables &&\n+                   x.IgnoreDefaultInstalledAssemblyTables == y.IgnoreDefaultInstalledAssemblyTables &&\n+                   x.IgnoreTargetFrameworkAttributeVersionMismatch == y.IgnoreTargetFrameworkAttributeVersionMismatch &&\n+                   x.IgnoreVersionForFrameworkReferences == y.IgnoreVersionForFrameworkReferences &&",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's the difference between a \"result\" and a \"response\"?",
              "createdAt": "2020-09-02T22:34:05Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/RARResultComparer.cs",
              "diffHunk": "@@ -0,0 +1,30 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+    internal class RARResultComparer : BaseComparer<ResolveAssemblyReferenceResult>\n+    {\n+        public static IEqualityComparer<ResolveAssemblyReferenceResult> Instance { get; } = new RARResultComparer();\n+\n+        public override bool Equals(ResolveAssemblyReferenceResult x, ResolveAssemblyReferenceResult y)\n+        {\n+            if (x == y)\n+                return true;\n+\n+            if (x == null || y == null)\n+                return false;\n+\n+            return x.TaskResult == y.TaskResult &&",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Result is composed of: TaskResult (failed or not), event logs and extracted output parameters from RAR tasks (response). ",
              "createdAt": "2020-09-03T08:41:04Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/RARResultComparer.cs",
              "diffHunk": "@@ -0,0 +1,30 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+    internal class RARResultComparer : BaseComparer<ResolveAssemblyReferenceResult>\n+    {\n+        public static IEqualityComparer<ResolveAssemblyReferenceResult> Instance { get; } = new RARResultComparer();\n+\n+        public override bool Equals(ResolveAssemblyReferenceResult x, ResolveAssemblyReferenceResult y)\n+        {\n+            if (x == y)\n+                return true;\n+\n+            if (x == null || y == null)\n+                return false;\n+\n+            return x.TaskResult == y.TaskResult &&",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't be commented out code like this in the final version.",
              "createdAt": "2020-09-02T22:34:36Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ReadOnlyTaskItemComparer.cs",
              "diffHunk": "@@ -0,0 +1,28 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+    internal class ReadOnlyTaskItemComparer : BaseComparer<ReadOnlyTaskItem>\n+    {\n+        internal static IEqualityComparer<ReadOnlyTaskItem> Instance { get; } = new ReadOnlyTaskItemComparer();\n+        private ReadOnlyTaskItemComparer() { }\n+\n+        public override bool Equals(ReadOnlyTaskItem x, ReadOnlyTaskItem y)\n+        {\n+            // Same reference or null\n+            if (x == y)\n+                return true;\n+\n+            return\n+                //EqualityComparer<ICollection>.Default.Equals(x.MetadataNames.Count, y.MetadataNames) &&",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: shouldly wherever possible",
              "createdAt": "2020-09-02T22:35:47Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs",
              "diffHunk": "@@ -0,0 +1,132 @@\n+\ufeffusing MessagePack;\n+using MessagePack.Resolvers;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Client;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;\n+using Microsoft.Build.Utilities;\n+using Nerdbank.Streams;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.IO.Pipelines;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Reflection;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Xunit;\n+\n+using Task = System.Threading.Tasks.Task;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+    public sealed class ResolveAssemblyReferenceAsAService_Tests\n+    {\n+        [Fact]\n+        public void EnsureInputPropertiesMatch()\n+        {\n+            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n+                .Where(p => !p.GetCustomAttributes(typeof(OutputAttribute), true).Any()).Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+            string[] inputProperties = typeof(ResolveAssemblyReferenceTaskInput).GetProperties().Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+\n+            Assert.Equal(rarInputProperties.Length, inputProperties.Length);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nfor boolean parameter, specify parameter name",
              "createdAt": "2020-09-02T22:36:56Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs",
              "diffHunk": "@@ -0,0 +1,132 @@\n+\ufeffusing MessagePack;\n+using MessagePack.Resolvers;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Client;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;\n+using Microsoft.Build.Utilities;\n+using Nerdbank.Streams;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.IO.Pipelines;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Reflection;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Xunit;\n+\n+using Task = System.Threading.Tasks.Task;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+    public sealed class ResolveAssemblyReferenceAsAService_Tests\n+    {\n+        [Fact]\n+        public void EnsureInputPropertiesMatch()\n+        {\n+            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n+                .Where(p => !p.GetCustomAttributes(typeof(OutputAttribute), true).Any()).Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Some people don't like using this much linq, but I love it. \u2764\ufe0f ",
              "createdAt": "2020-09-02T22:37:46Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs",
              "diffHunk": "@@ -0,0 +1,132 @@\n+\ufeffusing MessagePack;\n+using MessagePack.Resolvers;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Client;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;\n+using Microsoft.Build.Utilities;\n+using Nerdbank.Streams;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.IO.Pipelines;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Reflection;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Xunit;\n+\n+using Task = System.Threading.Tasks.Task;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+    public sealed class ResolveAssemblyReferenceAsAService_Tests\n+    {\n+        [Fact]\n+        public void EnsureInputPropertiesMatch()\n+        {\n+            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n        /// Execute task. This method is intended to be used from a RAR as a Service node.\r\n```",
              "createdAt": "2020-09-02T22:44:31Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3032,6 +3161,54 @@ public override bool Execute()\n             );\n         }\n \n+        private void LogEvents(IEnumerable<LazyFormattedBuildEventArgs> buildEventArgs)\n+        {\n+            if (buildEventArgs == null)\n+            {\n+                return;\n+            }\n+\n+            foreach (LazyFormattedBuildEventArgs buildEvent in buildEventArgs)\n+            {\n+                switch (buildEvent)\n+                {\n+                    case CustomBuildEventArgs customBuildEvent:\n+                        BuildEngine.LogCustomEvent(customBuildEvent);\n+                        break;\n+                    case BuildErrorEventArgs buildErrorEvent:\n+                        BuildEngine.LogErrorEvent(buildErrorEvent);\n+                        break;\n+                    case BuildMessageEventArgs buildMessageEvent:\n+                        BuildEngine.LogMessageEvent(buildMessageEvent);\n+                        break;\n+                    case BuildWarningEventArgs buildWarningEvent:\n+                        BuildEngine.LogWarningEvent(buildWarningEvent);\n+                        break;\n+                    default:\n+                        ErrorUtilities.ThrowInternalError(\"Unexpected build event\"); \n+                        break;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Execute task. This metod is intended to use from RAR as a Service node",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "tiny nit:\r\n```suggestion\r\n        /// <returns>If task was executed successfully</returns>\r\n```",
              "createdAt": "2020-09-02T22:45:01Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3032,6 +3161,54 @@ public override bool Execute()\n             );\n         }\n \n+        private void LogEvents(IEnumerable<LazyFormattedBuildEventArgs> buildEventArgs)\n+        {\n+            if (buildEventArgs == null)\n+            {\n+                return;\n+            }\n+\n+            foreach (LazyFormattedBuildEventArgs buildEvent in buildEventArgs)\n+            {\n+                switch (buildEvent)\n+                {\n+                    case CustomBuildEventArgs customBuildEvent:\n+                        BuildEngine.LogCustomEvent(customBuildEvent);\n+                        break;\n+                    case BuildErrorEventArgs buildErrorEvent:\n+                        BuildEngine.LogErrorEvent(buildErrorEvent);\n+                        break;\n+                    case BuildMessageEventArgs buildMessageEvent:\n+                        BuildEngine.LogMessageEvent(buildMessageEvent);\n+                        break;\n+                    case BuildWarningEventArgs buildWarningEvent:\n+                        BuildEngine.LogWarningEvent(buildWarningEvent);\n+                        break;\n+                    default:\n+                        ErrorUtilities.ThrowInternalError(\"Unexpected build event\"); \n+                        break;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Execute task. This metod is intended to use from RAR as a Service node\n+        /// </summary>\n+        /// <param name=\"input\">Required input to the task</param>\n+        /// <returns>If tasks was executed successfully</returns>",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "To make sure I understand:\r\nThe idea is that you can (via an escape hatch) run RAR as it currently does or from a RAR node. This method only gets called if it's run from a RAR node\u2014it's essentially a wrapper over the parameter-less Execute() that gets called when it's run as it is now. Is that correct?",
              "createdAt": "2020-09-02T22:46:19Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3032,6 +3161,54 @@ public override bool Execute()\n             );\n         }\n \n+        private void LogEvents(IEnumerable<LazyFormattedBuildEventArgs> buildEventArgs)\n+        {\n+            if (buildEventArgs == null)\n+            {\n+                return;\n+            }\n+\n+            foreach (LazyFormattedBuildEventArgs buildEvent in buildEventArgs)\n+            {\n+                switch (buildEvent)\n+                {\n+                    case CustomBuildEventArgs customBuildEvent:\n+                        BuildEngine.LogCustomEvent(customBuildEvent);\n+                        break;\n+                    case BuildErrorEventArgs buildErrorEvent:\n+                        BuildEngine.LogErrorEvent(buildErrorEvent);\n+                        break;\n+                    case BuildMessageEventArgs buildMessageEvent:\n+                        BuildEngine.LogMessageEvent(buildMessageEvent);\n+                        break;\n+                    case BuildWarningEventArgs buildWarningEvent:\n+                        BuildEngine.LogWarningEvent(buildWarningEvent);\n+                        break;\n+                    default:\n+                        ErrorUtilities.ThrowInternalError(\"Unexpected build event\"); \n+                        break;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Execute task. This metod is intended to use from RAR as a Service node\n+        /// </summary>\n+        /// <param name=\"input\">Required input to the task</param>\n+        /// <returns>If tasks was executed successfully</returns>\n+        internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceTaskInput input)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentNull(input, nameof(input));\n+\n+            // Prepare environment\n+            ResolveAssemblyReferenceInput = input;\n+            // Since this method should be run from RAR node, we prevent it from creating loop.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That is the idea.",
              "createdAt": "2020-09-03T08:32:55Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3032,6 +3161,54 @@ public override bool Execute()\n             );\n         }\n \n+        private void LogEvents(IEnumerable<LazyFormattedBuildEventArgs> buildEventArgs)\n+        {\n+            if (buildEventArgs == null)\n+            {\n+                return;\n+            }\n+\n+            foreach (LazyFormattedBuildEventArgs buildEvent in buildEventArgs)\n+            {\n+                switch (buildEvent)\n+                {\n+                    case CustomBuildEventArgs customBuildEvent:\n+                        BuildEngine.LogCustomEvent(customBuildEvent);\n+                        break;\n+                    case BuildErrorEventArgs buildErrorEvent:\n+                        BuildEngine.LogErrorEvent(buildErrorEvent);\n+                        break;\n+                    case BuildMessageEventArgs buildMessageEvent:\n+                        BuildEngine.LogMessageEvent(buildMessageEvent);\n+                        break;\n+                    case BuildWarningEventArgs buildWarningEvent:\n+                        BuildEngine.LogWarningEvent(buildWarningEvent);\n+                        break;\n+                    default:\n+                        ErrorUtilities.ThrowInternalError(\"Unexpected build event\"); \n+                        break;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Execute task. This metod is intended to use from RAR as a Service node\n+        /// </summary>\n+        /// <param name=\"input\">Required input to the task</param>\n+        /// <returns>If tasks was executed successfully</returns>\n+        internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceTaskInput input)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentNull(input, nameof(input));\n+\n+            // Prepare environment\n+            ResolveAssemblyReferenceInput = input;\n+            // Since this method should be run from RAR node, we prevent it from creating loop.",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why throw NotImplementedException rather than just not having a setter?",
              "createdAt": "2020-09-02T22:49:01Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs",
              "diffHunk": "@@ -0,0 +1,130 @@\n+\ufeffusing MessagePack;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using System.Windows;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract\n+{\n+    [MessagePackObject]\n+    public sealed class ReadOnlyTaskItem : ITaskItem2\n+    {\n+        [IgnoreMember]\n+        public ICollection MetadataNames { get; }\n+\n+        [IgnoreMember]\n+        public int MetadataCount { get; set; }\n+\n+        [Key(0)]\n+        public string ItemSpec { get; set; }\n+\n+        [Key(1)]\n+        public Dictionary<string, string> MetadataNameToValue { get; set; }\n+\n+      \n+        [IgnoreMember]\n+        public string EvaluatedIncludeEscaped\n+        {\n+            get => EscapingUtilities.UnescapeAll(ItemSpec);\n+\n+            set => throw new NotImplementedException();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Oh, never mind. It's because ITaskItem2 has it.",
              "createdAt": "2020-09-02T22:52:01Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs",
              "diffHunk": "@@ -0,0 +1,130 @@\n+\ufeffusing MessagePack;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using System.Windows;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract\n+{\n+    [MessagePackObject]\n+    public sealed class ReadOnlyTaskItem : ITaskItem2\n+    {\n+        [IgnoreMember]\n+        public ICollection MetadataNames { get; }\n+\n+        [IgnoreMember]\n+        public int MetadataCount { get; set; }\n+\n+        [Key(0)]\n+        public string ItemSpec { get; set; }\n+\n+        [Key(1)]\n+        public Dictionary<string, string> MetadataNameToValue { get; set; }\n+\n+      \n+        [IgnoreMember]\n+        public string EvaluatedIncludeEscaped\n+        {\n+            get => EscapingUtilities.UnescapeAll(ItemSpec);\n+\n+            set => throw new NotImplementedException();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I might check to make sure this is considered secure enough.",
              "createdAt": "2020-09-02T22:56:00Z",
              "path": "src/Tasks/ResolveAssemblyReferences/LazyFromattedBuildEventArgsFormatter.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using MessagePack;\n+using MessagePack.Formatters;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Nerdbank.Streams;\n+using System;\n+using System.Buffers;\n+using System.ComponentModel;\n+using System.IO;\n+using System.Reflection;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences\n+{\n+    internal abstract class BuildEventArgsFormatter<TArg> : IMessagePackFormatter<TArg> where TArg : BuildEventArgs\n+    {\n+        private static int? _clrVersion = null;\n+        private static int ClrVersion\n+        {\n+            get\n+            {\n+                if (!_clrVersion.HasValue)\n+                {\n+                    _clrVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version.Major;\n+                }\n+                return _clrVersion.Value;\n+            }\n+        }\n+\n+        public static IMessagePackFormatter<BuildErrorEventArgs> ErrorFormatter { get; } = new BuildError();\n+        public static IMessagePackFormatter<BuildWarningEventArgs> WarningFormatter { get; } = new BuildWarning();\n+        public static IMessagePackFormatter<BuildMessageEventArgs> MessageFormatter { get; } = new BuildMessage();\n+        public static IMessagePackFormatter<CustomBuildEventArgs> CustomFormatter { get; } = new Custom();\n+\n+\n+        public TArg Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+        {\n+            ReadOnlySequence<byte>? buffer = reader.ReadBytes();\n+\n+            if (!buffer.HasValue)\n+                return null;\n+            try\n+            {\n+                BinaryReader binaryReader = new BinaryReader(buffer.Value.AsStream());\n+                TArg arg = GetEventArgInstance();\n+                arg.CreateFromStream(binaryReader, int.MaxValue);\n+                return arg;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+        }\n+\n+        public void Serialize(ref MessagePackWriter writer, TArg value, MessagePackSerializerOptions options)\n+        {\n+            if (value is null)\n+            {\n+                writer.Write((byte[])null);\n+                return;\n+            }\n+\n+            using MemoryStream stream = new MemoryStream();\n+            using BinaryWriter binaryWriter = new BinaryWriter(stream);\n+\n+            value.WriteToStream(binaryWriter);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Changed",
              "createdAt": "2020-09-14T08:40:13Z",
              "path": "src/Tasks/ResolveAssemblyReferences/LazyFromattedBuildEventArgsFormatter.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using MessagePack;\n+using MessagePack.Formatters;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Nerdbank.Streams;\n+using System;\n+using System.Buffers;\n+using System.ComponentModel;\n+using System.IO;\n+using System.Reflection;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences\n+{\n+    internal abstract class BuildEventArgsFormatter<TArg> : IMessagePackFormatter<TArg> where TArg : BuildEventArgs\n+    {\n+        private static int? _clrVersion = null;\n+        private static int ClrVersion\n+        {\n+            get\n+            {\n+                if (!_clrVersion.HasValue)\n+                {\n+                    _clrVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version.Major;\n+                }\n+                return _clrVersion.Value;\n+            }\n+        }\n+\n+        public static IMessagePackFormatter<BuildErrorEventArgs> ErrorFormatter { get; } = new BuildError();\n+        public static IMessagePackFormatter<BuildWarningEventArgs> WarningFormatter { get; } = new BuildWarning();\n+        public static IMessagePackFormatter<BuildMessageEventArgs> MessageFormatter { get; } = new BuildMessage();\n+        public static IMessagePackFormatter<CustomBuildEventArgs> CustomFormatter { get; } = new Custom();\n+\n+\n+        public TArg Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+        {\n+            ReadOnlySequence<byte>? buffer = reader.ReadBytes();\n+\n+            if (!buffer.HasValue)\n+                return null;\n+            try\n+            {\n+                BinaryReader binaryReader = new BinaryReader(buffer.Value.AsStream());\n+                TArg arg = GetEventArgInstance();\n+                arg.CreateFromStream(binaryReader, int.MaxValue);\n+                return arg;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+        }\n+\n+        public void Serialize(ref MessagePackWriter writer, TArg value, MessagePackSerializerOptions options)\n+        {\n+            if (value is null)\n+            {\n+                writer.Write((byte[])null);\n+                return;\n+            }\n+\n+            using MemoryStream stream = new MemoryStream();\n+            using BinaryWriter binaryWriter = new BinaryWriter(stream);\n+\n+            value.WriteToStream(binaryWriter);",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks a little like magic...",
              "createdAt": "2020-09-02T22:56:46Z",
              "path": "src/Tasks/ResolveAssemblyReferences/LazyFromattedBuildEventArgsFormatter.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using MessagePack;\n+using MessagePack.Formatters;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Nerdbank.Streams;\n+using System;\n+using System.Buffers;\n+using System.ComponentModel;\n+using System.IO;\n+using System.Reflection;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences\n+{\n+    internal abstract class BuildEventArgsFormatter<TArg> : IMessagePackFormatter<TArg> where TArg : BuildEventArgs\n+    {\n+        private static int? _clrVersion = null;\n+        private static int ClrVersion\n+        {\n+            get\n+            {\n+                if (!_clrVersion.HasValue)\n+                {\n+                    _clrVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version.Major;\n+                }\n+                return _clrVersion.Value;\n+            }\n+        }\n+\n+        public static IMessagePackFormatter<BuildErrorEventArgs> ErrorFormatter { get; } = new BuildError();\n+        public static IMessagePackFormatter<BuildWarningEventArgs> WarningFormatter { get; } = new BuildWarning();\n+        public static IMessagePackFormatter<BuildMessageEventArgs> MessageFormatter { get; } = new BuildMessage();\n+        public static IMessagePackFormatter<CustomBuildEventArgs> CustomFormatter { get; } = new Custom();\n+\n+\n+        public TArg Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+        {\n+            ReadOnlySequence<byte>? buffer = reader.ReadBytes();\n+\n+            if (!buffer.HasValue)\n+                return null;\n+            try\n+            {\n+                BinaryReader binaryReader = new BinaryReader(buffer.Value.AsStream());\n+                TArg arg = GetEventArgInstance();\n+                arg.CreateFromStream(binaryReader, int.MaxValue);\n+                return arg;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+        }\n+\n+        public void Serialize(ref MessagePackWriter writer, TArg value, MessagePackSerializerOptions options)\n+        {\n+            if (value is null)\n+            {\n+                writer.Write((byte[])null);\n+                return;\n+            }\n+\n+            using MemoryStream stream = new MemoryStream();\n+            using BinaryWriter binaryWriter = new BinaryWriter(stream);\n+\n+            value.WriteToStream(binaryWriter);\n+            writer.Write(stream.ToArray());\n+        }\n+\n+        protected abstract TArg GetEventArgInstance();\n+\n+        private class Custom : IMessagePackFormatter<CustomBuildEventArgs>\n+        {\n+            private static IMessagePackFormatter<ExternalProjectFinishedEventArgs> ExternalProjectFinishedFormatter = new ExternalProjectFinished();\n+            private static IMessagePackFormatter<ExternalProjectStartedEventArgs> ExternalProjectStartedFormatter = new ExternalProjectStarted();\n+\n+            public CustomBuildEventArgs Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+            {\n+                ushort formatter = reader.ReadUInt16();\n+\n+                switch (formatter)\n+                {\n+                    case 1:",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "At first look yes. But I need to be able to know what type I am deserializing. I will add comment which expalins this code.",
              "createdAt": "2020-09-03T08:34:42Z",
              "path": "src/Tasks/ResolveAssemblyReferences/LazyFromattedBuildEventArgsFormatter.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using MessagePack;\n+using MessagePack.Formatters;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Nerdbank.Streams;\n+using System;\n+using System.Buffers;\n+using System.ComponentModel;\n+using System.IO;\n+using System.Reflection;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences\n+{\n+    internal abstract class BuildEventArgsFormatter<TArg> : IMessagePackFormatter<TArg> where TArg : BuildEventArgs\n+    {\n+        private static int? _clrVersion = null;\n+        private static int ClrVersion\n+        {\n+            get\n+            {\n+                if (!_clrVersion.HasValue)\n+                {\n+                    _clrVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version.Major;\n+                }\n+                return _clrVersion.Value;\n+            }\n+        }\n+\n+        public static IMessagePackFormatter<BuildErrorEventArgs> ErrorFormatter { get; } = new BuildError();\n+        public static IMessagePackFormatter<BuildWarningEventArgs> WarningFormatter { get; } = new BuildWarning();\n+        public static IMessagePackFormatter<BuildMessageEventArgs> MessageFormatter { get; } = new BuildMessage();\n+        public static IMessagePackFormatter<CustomBuildEventArgs> CustomFormatter { get; } = new Custom();\n+\n+\n+        public TArg Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+        {\n+            ReadOnlySequence<byte>? buffer = reader.ReadBytes();\n+\n+            if (!buffer.HasValue)\n+                return null;\n+            try\n+            {\n+                BinaryReader binaryReader = new BinaryReader(buffer.Value.AsStream());\n+                TArg arg = GetEventArgInstance();\n+                arg.CreateFromStream(binaryReader, int.MaxValue);\n+                return arg;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+        }\n+\n+        public void Serialize(ref MessagePackWriter writer, TArg value, MessagePackSerializerOptions options)\n+        {\n+            if (value is null)\n+            {\n+                writer.Write((byte[])null);\n+                return;\n+            }\n+\n+            using MemoryStream stream = new MemoryStream();\n+            using BinaryWriter binaryWriter = new BinaryWriter(stream);\n+\n+            value.WriteToStream(binaryWriter);\n+            writer.Write(stream.ToArray());\n+        }\n+\n+        protected abstract TArg GetEventArgInstance();\n+\n+        private class Custom : IMessagePackFormatter<CustomBuildEventArgs>\n+        {\n+            private static IMessagePackFormatter<ExternalProjectFinishedEventArgs> ExternalProjectFinishedFormatter = new ExternalProjectFinished();\n+            private static IMessagePackFormatter<ExternalProjectStartedEventArgs> ExternalProjectStartedFormatter = new ExternalProjectStarted();\n+\n+            public CustomBuildEventArgs Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+            {\n+                ushort formatter = reader.ReadUInt16();\n+\n+                switch (formatter)\n+                {\n+                    case 1:",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is this for at this point?",
              "createdAt": "2020-09-02T23:03:45Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceBuildEngine.cs",
              "diffHunk": "@@ -0,0 +1,106 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services\n+{\n+    internal sealed class ResolveAssemblyReferenceBuildEngine : IBuildEngine7",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "RAR task needs to have supplied an IBuildEngine to it. Through it communicates with internals of MSBuild. By supplying RAR task this engine I can capture all events from RAR tasks to engine and forward them to the out of proc node.  ",
              "createdAt": "2020-09-03T08:39:21Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceBuildEngine.cs",
              "diffHunk": "@@ -0,0 +1,106 @@\n+\ufeffusing Microsoft.Build.Framework;\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services\n+{\n+    internal sealed class ResolveAssemblyReferenceBuildEngine : IBuildEngine7",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Intentionally commented out? If so, should it be just deleted? If it's not to be deleted, please make sure the comment uses gender neutral language.",
              "createdAt": "2020-09-11T11:56:10Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2020,10 +2020,11 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n \n         internal bool CreateRarNode()\n         {\n-            // If the _buildParametrs is not set, we are in OutOfProc mode, so continue\n-            // Else check if users specified that he want to use multiple nodes, if so use RARaaS\n-            if (_buildParameters?.MaxNodeCount == 1)\n-                return false;\n+            //// If the _buildParametrs is not set, we are in OutOfProc mode, so continue\n+            //// Else check if users specified that he want to use multiple nodes, if so use RARaaS\n+            //if (_buildParameters?.MaxNodeCount == 1)\n+            //    return false;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: A more descriptive name, following the convention established in the previous change? Something like `ResolveAssemblyReferenceServiceRequestStart`?",
              "createdAt": "2020-09-11T12:06:51Z",
              "path": "src/Framework/MSBuildEventSource.cs",
              "diffHunk": "@@ -423,6 +423,18 @@ public void ResolveAssemblyReferenceNodeConnectStop()\n         {\n             WriteEvent(57);\n         }\n+\n+        [Event(58)]\n+        internal void RARaaSStart()",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you please explain why this change is needed? Where does the request to load `Newtonsoft.Json` version <12 come from?",
              "createdAt": "2020-09-11T12:15:26Z",
              "path": "src/MSBuild/app.amd64.config",
              "diffHunk": "@@ -52,6 +52,10 @@\n           <codeBase version=\"16.8.0.0\" href=\"..\\..\\..\\Microsoft\\VC\\v160\\Microsoft.Build.CPPTasks.Common.dll\" />\n         </dependentAssembly>\n \n+        <dependentAssembly>\n+          <assemblyIdentity name=\"Newtonsoft.Json\" culture=\"neutral\" publicKeyToken=\"30ad4fe6b2a6aeed\" />\n+          <bindingRedirect oldVersion=\"0.0.0.0-12.0.0.0\" newVersion=\"12.0.0.0\" />\n+        </dependentAssembly>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I believe @ostorc mentioned in our PR reviews meeting this week that StreamJsonRPC relies on it, but he doesn't actually depend on the part of StreamJsonRPC that depends on Newtonsoft.Json, so we were wondering if we could make an exception in ngen'ing it so that we don't have to.",
              "createdAt": "2020-09-18T21:19:07Z",
              "path": "src/MSBuild/app.amd64.config",
              "diffHunk": "@@ -52,6 +52,10 @@\n           <codeBase version=\"16.8.0.0\" href=\"..\\..\\..\\Microsoft\\VC\\v160\\Microsoft.Build.CPPTasks.Common.dll\" />\n         </dependentAssembly>\n \n+        <dependentAssembly>\n+          <assemblyIdentity name=\"Newtonsoft.Json\" culture=\"neutral\" publicKeyToken=\"30ad4fe6b2a6aeed\" />\n+          <bindingRedirect oldVersion=\"0.0.0.0-12.0.0.0\" newVersion=\"12.0.0.0\" />\n+        </dependentAssembly>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "In this PR https://github.com/microsoft/vs-streamjsonrpc/pull/556 was the unnecessary load of Newtonsoft.Json removed, so when the version with this change is out, we will be able to remove this dangerous lines.",
              "createdAt": "2020-09-22T09:38:13Z",
              "path": "src/MSBuild/app.amd64.config",
              "diffHunk": "@@ -52,6 +52,10 @@\n           <codeBase version=\"16.8.0.0\" href=\"..\\..\\..\\Microsoft\\VC\\v160\\Microsoft.Build.CPPTasks.Common.dll\" />\n         </dependentAssembly>\n \n+        <dependentAssembly>\n+          <assemblyIdentity name=\"Newtonsoft.Json\" culture=\"neutral\" publicKeyToken=\"30ad4fe6b2a6aeed\" />\n+          <bindingRedirect oldVersion=\"0.0.0.0-12.0.0.0\" newVersion=\"12.0.0.0\" />\n+        </dependentAssembly>",
              "author": {
                "login": "ostorc"
              }
            },
            {
              "body": "Unfortunately, that didn't solve the issue. Issue #5752 will solve that.  ",
              "createdAt": "2020-09-23T21:59:13Z",
              "path": "src/MSBuild/app.amd64.config",
              "diffHunk": "@@ -52,6 +52,10 @@\n           <codeBase version=\"16.8.0.0\" href=\"..\\..\\..\\Microsoft\\VC\\v160\\Microsoft.Build.CPPTasks.Common.dll\" />\n         </dependentAssembly>\n \n+        <dependentAssembly>\n+          <assemblyIdentity name=\"Newtonsoft.Json\" culture=\"neutral\" publicKeyToken=\"30ad4fe6b2a6aeed\" />\n+          <bindingRedirect oldVersion=\"0.0.0.0-12.0.0.0\" newVersion=\"12.0.0.0\" />\n+        </dependentAssembly>",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Extra empty lines.",
              "createdAt": "2020-09-11T12:16:23Z",
              "path": "src/Shared/UnitTests/MockEngine.cs",
              "diffHunk": "@@ -486,5 +488,22 @@ public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime life\n             _objectCache.TryRemove(key, out object obj);\n             return obj;\n         }\n+\n+",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed.",
              "createdAt": "2020-09-11T14:02:53Z",
              "path": "src/Shared/UnitTests/MockEngine.cs",
              "diffHunk": "@@ -486,5 +488,22 @@ public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime life\n             _objectCache.TryRemove(key, out object obj);\n             return obj;\n         }\n+\n+",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: You can call `.ShouldContain()` on the entire collection, no need to iterate yourself. Also, what are the properties in `inputProperties` \\ `rarInputProperties`, i.e. why isn't this a test for collection equality?",
              "createdAt": "2020-09-11T12:26:49Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs",
              "diffHunk": "@@ -0,0 +1,123 @@\n+\ufeffusing MessagePack;\n+using MessagePack.Resolvers;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Client;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests;\n+using Microsoft.Build.Utilities;\n+using Nerdbank.Streams;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.IO.Pipelines;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Reflection;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Task = System.Threading.Tasks.Task;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+    public sealed class ResolveAssemblyReferenceAsAService_Tests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceAsAService_Tests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        [Fact]\n+        public void EnsureInputPropertiesMatch()\n+        {\n+            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n+                .Where(p => !p.GetCustomAttributes(typeof(OutputAttribute), inherit: true).Any()).Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+            string[] inputProperties = typeof(ResolveAssemblyReferenceTaskInput).GetProperties().Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+\n+            foreach (var item in rarInputProperties)\n+            {\n+                inputProperties.ShouldContain(item);\n+            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "In the data which we need to send to RARaaS can be some additional information. So I want to check here, that at least the API of RAR task is included",
              "createdAt": "2020-09-14T09:09:02Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs",
              "diffHunk": "@@ -0,0 +1,123 @@\n+\ufeffusing MessagePack;\n+using MessagePack.Resolvers;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Client;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests;\n+using Microsoft.Build.Utilities;\n+using Nerdbank.Streams;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.IO.Pipelines;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Reflection;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Task = System.Threading.Tasks.Task;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+    public sealed class ResolveAssemblyReferenceAsAService_Tests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceAsAService_Tests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        [Fact]\n+        public void EnsureInputPropertiesMatch()\n+        {\n+            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n+                .Where(p => !p.GetCustomAttributes(typeof(OutputAttribute), inherit: true).Any()).Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+            string[] inputProperties = typeof(ResolveAssemblyReferenceTaskInput).GetProperties().Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+\n+            foreach (var item in rarInputProperties)\n+            {\n+                inputProperties.ShouldContain(item);\n+            }",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo `Transfered`.",
              "createdAt": "2020-09-11T12:27:26Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs",
              "diffHunk": "@@ -0,0 +1,123 @@\n+\ufeffusing MessagePack;\n+using MessagePack.Resolvers;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Client;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests;\n+using Microsoft.Build.Utilities;\n+using Nerdbank.Streams;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.IO.Pipelines;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Reflection;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Task = System.Threading.Tasks.Task;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+    public sealed class ResolveAssemblyReferenceAsAService_Tests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceAsAService_Tests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        [Fact]\n+        public void EnsureInputPropertiesMatch()\n+        {\n+            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n+                .Where(p => !p.GetCustomAttributes(typeof(OutputAttribute), inherit: true).Any()).Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+            string[] inputProperties = typeof(ResolveAssemblyReferenceTaskInput).GetProperties().Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+\n+            foreach (var item in rarInputProperties)\n+            {\n+                inputProperties.ShouldContain(item);\n+            }\n+        }\n+\n+        [Fact]\n+        public void EnsureOutputPropertiesMatch()\n+        {\n+            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n+                .Where(p => p.GetCustomAttributes(typeof(OutputAttribute), true).Any()).Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+            string[] inputProperties = typeof(ResolveAssemblyReferenceTaskOutput).GetProperties().Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+\n+            foreach (var item in rarInputProperties)\n+            {\n+                inputProperties.ShouldContain(item);\n+            }\n+        }\n+\n+        [Fact]\n+        public void TransferedRequestEquals()",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Extra empty line.",
              "createdAt": "2020-09-11T12:28:31Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs",
              "diffHunk": "@@ -0,0 +1,123 @@\n+\ufeffusing MessagePack;\n+using MessagePack.Resolvers;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Client;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests;\n+using Microsoft.Build.Utilities;\n+using Nerdbank.Streams;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.IO.Pipelines;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Reflection;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Task = System.Threading.Tasks.Task;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+    public sealed class ResolveAssemblyReferenceAsAService_Tests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceAsAService_Tests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        [Fact]\n+        public void EnsureInputPropertiesMatch()\n+        {\n+            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n+                .Where(p => !p.GetCustomAttributes(typeof(OutputAttribute), inherit: true).Any()).Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+            string[] inputProperties = typeof(ResolveAssemblyReferenceTaskInput).GetProperties().Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+\n+            foreach (var item in rarInputProperties)\n+            {\n+                inputProperties.ShouldContain(item);\n+            }\n+        }\n+\n+        [Fact]\n+        public void EnsureOutputPropertiesMatch()\n+        {\n+            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n+                .Where(p => p.GetCustomAttributes(typeof(OutputAttribute), true).Any()).Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+            string[] inputProperties = typeof(ResolveAssemblyReferenceTaskOutput).GetProperties().Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+\n+            foreach (var item in rarInputProperties)\n+            {\n+                inputProperties.ShouldContain(item);\n+            }\n+        }\n+\n+        [Fact]\n+        public void TransferedRequestEquals()\n+        {\n+            ITaskItem[] assemblyNames = new TaskItem[]\n+            {\n+                new TaskItem(\"DependsOnEverettSystem, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=feedbeadbadcadbe\")\n+            };\n+\n+            ResolveAssemblyReference rar = new ResolveAssemblyReference\n+            {\n+                Assemblies = assemblyNames\n+            };\n+\n+            MessagePackSerializerOptions options = MessagePackSerializerOptions.Standard.WithResolver(ResolveAssemlyReferneceResolver.Instance);\n+\n+            ResolveAssemblyReferenceRequest request = new ResolveAssemblyReferenceRequest(rar.ResolveAssemblyReferenceInput);\n+            byte[] data = MessagePackSerializer.Serialize(request, options);\n+\n+            ResolveAssemblyReferenceRequest requestDes = MessagePackSerializer.Deserialize<ResolveAssemblyReferenceRequest>(data, options);\n+\n+            ResolveAssemblyReferenceComparer.CompareInput(request, requestDes).ShouldBeTrue();\n+        }\n+",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed.",
              "createdAt": "2020-09-17T18:06:56Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs",
              "diffHunk": "@@ -0,0 +1,123 @@\n+\ufeffusing MessagePack;\n+using MessagePack.Resolvers;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Client;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests;\n+using Microsoft.Build.Utilities;\n+using Nerdbank.Streams;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.IO.Pipelines;\n+using System.IO.Pipes;\n+using System.Linq;\n+using System.Reflection;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Xunit;\n+using Xunit.Abstractions;\n+using Task = System.Threading.Tasks.Task;\n+\n+namespace Microsoft.Build.Tasks.UnitTests.AssemblyDependency\n+{\n+    public sealed class ResolveAssemblyReferenceAsAService_Tests : ResolveAssemblyReferenceTestFixture\n+    {\n+        public ResolveAssemblyReferenceAsAService_Tests(ITestOutputHelper output) : base(output)\n+        {\n+        }\n+\n+        [Fact]\n+        public void EnsureInputPropertiesMatch()\n+        {\n+            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n+                .Where(p => !p.GetCustomAttributes(typeof(OutputAttribute), inherit: true).Any()).Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+            string[] inputProperties = typeof(ResolveAssemblyReferenceTaskInput).GetProperties().Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+\n+            foreach (var item in rarInputProperties)\n+            {\n+                inputProperties.ShouldContain(item);\n+            }\n+        }\n+\n+        [Fact]\n+        public void EnsureOutputPropertiesMatch()\n+        {\n+            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)\n+                .Where(p => p.GetCustomAttributes(typeof(OutputAttribute), true).Any()).Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+            string[] inputProperties = typeof(ResolveAssemblyReferenceTaskOutput).GetProperties().Select(p => $\"{p.PropertyType.FullName}.{p.Name}\").ToArray();\n+\n+            foreach (var item in rarInputProperties)\n+            {\n+                inputProperties.ShouldContain(item);\n+            }\n+        }\n+\n+        [Fact]\n+        public void TransferedRequestEquals()\n+        {\n+            ITaskItem[] assemblyNames = new TaskItem[]\n+            {\n+                new TaskItem(\"DependsOnEverettSystem, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=feedbeadbadcadbe\")\n+            };\n+\n+            ResolveAssemblyReference rar = new ResolveAssemblyReference\n+            {\n+                Assemblies = assemblyNames\n+            };\n+\n+            MessagePackSerializerOptions options = MessagePackSerializerOptions.Standard.WithResolver(ResolveAssemlyReferneceResolver.Instance);\n+\n+            ResolveAssemblyReferenceRequest request = new ResolveAssemblyReferenceRequest(rar.ResolveAssemblyReferenceInput);\n+            byte[] data = MessagePackSerializer.Serialize(request, options);\n+\n+            ResolveAssemblyReferenceRequest requestDes = MessagePackSerializer.Deserialize<ResolveAssemblyReferenceRequest>(data, options);\n+\n+            ResolveAssemblyReferenceComparer.CompareInput(request, requestDes).ShouldBeTrue();\n+        }\n+",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Extra empty line.",
              "createdAt": "2020-09-11T12:31:43Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -2971,6 +2980,43 @@ public enum RARSimulationMode\n             LoadAndBuildProject = LoadProject | BuildProject\n         }\n \n+        private class RarHandler : IResolveAssemblyReferenceTaskHandler\n+        {\n+            public void Dispose()\n+            {\n+            }\n+\n+            public Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenceRequest input, CancellationToken cancellationToken = default)\n+            {\n+                return System.Threading.Tasks.Task.FromResult(Execute(input));\n+",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`UseRARaaS` is hardcoded to `false` so this condition will never hold.",
              "createdAt": "2020-09-11T12:37:10Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -2984,6 +3030,24 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC\n \n             bool succeeded = false;\n \n+            bool usingRarService = UseRARaaS;\n+            System.Threading.Tasks.Task serverTask = null;\n+            Stream clientStream = null, serverStream = null;\n+            if (usingRarService)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "No it will never be. But it allows for now to switch between mode of execution of RAR task tests, without extensive editing of code.",
              "createdAt": "2020-09-11T14:10:29Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -2984,6 +3030,24 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC\n \n             bool succeeded = false;\n \n+            bool usingRarService = UseRARaaS;\n+            System.Threading.Tasks.Task serverTask = null;\n+            Stream clientStream = null, serverStream = null;\n+            if (usingRarService)",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Unintentional whitespace change?",
              "createdAt": "2020-09-11T12:41:27Z",
              "path": "src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs",
              "diffHunk": "@@ -23,9 +23,9 @@ internal class CandidateAssemblyFilesResolver : Resolver\n         /// Construct.\n         /// </summary>\n         /// <param name=\"candidateAssemblyFiles\">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>\n-        /// <param name=\"searchPathElement\">The corresponding element from the search path.</param>\n-        /// <param name=\"getAssemblyName\">Delegate that gets the assembly name.</param>\n-        /// <param name=\"fileExists\">Delegate that returns if the file exists.</param>\n+        /// <param name=\"searchPathElement\">The corresponding element from the search path.</param>\t    \n+        /// <param name=\"getAssemblyName\">Delegate that gets the assembly name.</param>\t        \n+        /// <param name=\"fileExists\">Delegate that returns if the file exists.</param>\t        ",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Badly formatted comment.",
              "createdAt": "2020-09-11T12:43:43Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -186,6 +188,7 @@ internal sealed class ReferenceTable\n         /// <param name=\"assemblyMetadataCache\">Cache of metadata already read from paths.</param>\n         /// <param name=\"allowedAssemblyExtensions\"></param>\n         /// <param name=\"getRuntimeVersion\"></param>\n+        /// /// <param name=\"getRootedPath\">Get absolute path from relative one.</param>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you please explain why logging is split into warnings / messages / error / etc. when `LogEvents` has a per-item switch? Does this mean that all warnings are reported before all messages and those in turn before all errors?",
              "createdAt": "2020-09-11T13:25:53Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3006,7 +3137,15 @@ public override bool Execute()\n                 if (connected)\n                 {\n                     // Client is connected to the RAR node, we can execute RAR task remotely\n-                    // return client.Execute(); // TODO: Let it do something.\n+                    MSBuildEventSource.Log.RARaaSStart();\n+                    ResolveAssemblyReferenceResult result = client.Execute(ResolveAssemblyReferenceInput);\n+                    MSBuildEventSource.Log.RARaaSStop();\n+                    ResolveAssemblyReferenceOutput = result.Output;\n+                    LogEvents(result.BuildWarningEvents);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Missing space after `if`.",
              "createdAt": "2020-09-11T13:27:31Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3032,6 +3171,82 @@ public override bool Execute()\n             );\n         }\n \n+        private void LogEvents(IEnumerable<LazyFormattedBuildEventArgs> buildEventArgs)\n+        {\n+            if (buildEventArgs == null)\n+            {\n+                return;\n+            }\n+\n+            foreach (LazyFormattedBuildEventArgs buildEvent in buildEventArgs)\n+            {\n+                switch (buildEvent)\n+                {\n+                    case CustomBuildEventArgs customBuildEvent:\n+                        BuildEngine.LogCustomEvent(customBuildEvent);\n+                        break;\n+                    case BuildErrorEventArgs buildErrorEvent:\n+                        BuildEngine.LogErrorEvent(buildErrorEvent);\n+                        break;\n+                    case BuildMessageEventArgs buildMessageEvent:\n+                        BuildEngine.LogMessageEvent(buildMessageEvent);\n+                        break;\n+                    case BuildWarningEventArgs buildWarningEvent:\n+                        BuildEngine.LogWarningEvent(buildWarningEvent);\n+                        break;\n+                    default:\n+                        ErrorUtilities.ThrowInternalError(\"Unexpected build event\"); \n+                        break;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Execute task. This method is intended to be used from a RAR as a Service node.\n+        /// </summary>\n+        /// <param name=\"input\">Required input to the task</param>\n+        /// <returns>If task was executed successfully</returns>\n+        internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceTaskInput input)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentNull(input, nameof(input));\n+\n+            // Prepare environment\n+            ResolveAssemblyReferenceInput = input;\n+            // Since this method should be run from RAR node, we prevent it from creating loop.\n+            UseResolveAssemblyReferenceService = false;\n+\n+            bool result = Execute\n+            (\n+                new FileExists(p => FileUtilities.FileExistsNoThrow(p)),\n+                new DirectoryExists(p => FileUtilities.DirectoryExistsNoThrow(p)),\n+                new GetDirectories(Directory.GetDirectories),\n+                new GetAssemblyName(AssemblyNameExtension.GetAssemblyNameEx),\n+                new GetAssemblyMetadata(AssemblyInformation.GetAssemblyMetadata),\n+#if FEATURE_WIN32_REGISTRY\n+                new GetRegistrySubKeyNames(RegistryHelper.GetSubKeyNames),\n+                new GetRegistrySubKeyDefaultValue(RegistryHelper.GetDefaultValue),\n+#endif\n+                new GetLastWriteTime(NativeMethodsShared.GetLastWriteFileUtcTime),\n+                new GetAssemblyRuntimeVersion(AssemblyInformation.GetRuntimeVersion),\n+#if FEATURE_WIN32_REGISTRY\n+                new OpenBaseKey(RegistryHelper.OpenBaseKey),\n+#endif\n+                new GetAssemblyPathInGac(GetAssemblyPathInGac),\n+                new IsWinMDFile(AssemblyInformation.IsWinMDFile),\n+                new ReadMachineTypeFromPEHeader(ReferenceTable.ReadMachineTypeFromPEHeader),\n+                (path) =>\n+                {\n+                    if(Path.IsPathRooted(path))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Remove?",
              "createdAt": "2020-09-11T13:28:15Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -995,7 +1010,8 @@\n     <PackageReference Include=\"System.Collections.Immutable\" />\n     <PackageReference Include=\"System.Resources.Extensions\" />\n     <PackageReference Include=\"StreamJsonRpc\" />\n-    <PackageReference Include=\"Newtonsoft.Json\" />\n+    <PackageReference Include=\"MessagePack\" />\n+    <!--<PackageReference Include=\"Newtonsoft.Json\" />-->",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed.",
              "createdAt": "2020-09-17T18:06:21Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -995,7 +1010,8 @@\n     <PackageReference Include=\"System.Collections.Immutable\" />\n     <PackageReference Include=\"System.Resources.Extensions\" />\n     <PackageReference Include=\"StreamJsonRpc\" />\n-    <PackageReference Include=\"Newtonsoft.Json\" />\n+    <PackageReference Include=\"MessagePack\" />\n+    <!--<PackageReference Include=\"Newtonsoft.Json\" />-->",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is the cast guaranteed to work?",
              "createdAt": "2020-09-11T13:32:56Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract\n+{\n+    internal sealed class ReadOnlyTaskItem\n+    {\n+        public string ItemSpec { get; set; }\n+\n+        public Dictionary<string, string> MetadataNameToValue { get; set; }\n+\n+        public ReadOnlyTaskItem(string itemSpec)\n+        {\n+            ItemSpec = itemSpec;\n+            MetadataNameToValue = new Dictionary<string, string>();\n+        }\n+\n+        public ReadOnlyTaskItem(string itemSpec, IDictionary metadata)\n+        {\n+            ItemSpec = itemSpec;\n+            MetadataNameToValue = new Dictionary<string, string>((IDictionary<string, string>)metadata);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed",
              "createdAt": "2020-09-17T18:03:16Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract\n+{\n+    internal sealed class ReadOnlyTaskItem\n+    {\n+        public string ItemSpec { get; set; }\n+\n+        public Dictionary<string, string> MetadataNameToValue { get; set; }\n+\n+        public ReadOnlyTaskItem(string itemSpec)\n+        {\n+            ItemSpec = itemSpec;\n+            MetadataNameToValue = new Dictionary<string, string>();\n+        }\n+\n+        public ReadOnlyTaskItem(string itemSpec, IDictionary metadata)\n+        {\n+            ItemSpec = itemSpec;\n+            MetadataNameToValue = new Dictionary<string, string>((IDictionary<string, string>)metadata);",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this file auto-generated? Why is this class commented out? Thanks!",
              "createdAt": "2020-09-11T13:36:05Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs",
              "diffHunk": "@@ -0,0 +1,634 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using MessagePack;\n+using MessagePack.Formatters;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences\n+{\n+    internal sealed class BuildEventArgsFormatter\n+        : IMessagePackFormatter<BuildErrorEventArgs>, IMessagePackFormatter<BuildWarningEventArgs>, IMessagePackFormatter<BuildMessageEventArgs>,\n+         IMessagePackFormatter<CustomBuildEventArgs>, IMessagePackFormatter<ExternalProjectStartedEventArgs>, IMessagePackFormatter<ExternalProjectFinishedEventArgs>\n+    {\n+\n+        internal static readonly IMessagePackFormatter Instance = new BuildEventArgsFormatter();\n+\n+        private BuildEventArgsFormatter() { }\n+\n+        BuildWarningEventArgs IMessagePackFormatter<BuildWarningEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+        {\n+            if (reader.TryReadNil())\n+            {\n+                return null;\n+            }\n+\n+            options.Security.DepthStep(ref reader);\n+            int length = reader.ReadArrayHeader();\n+            string message = null;\n+            string helpKeyword = null;\n+            string senderName = null;\n+            int columnNumber = default;\n+            int endColumnNumber = default;\n+            int endLineNumber = default;\n+            int lineNumber = default;\n+            string code = default;\n+            string file = default;\n+            string subCategory = default;\n+\n+            for (int key = 0; key < length; key++)\n+            {\n+                switch (key)\n+                {\n+                    case 0:\n+                        message = reader.ReadString();\n+                        break;\n+                    case 1:\n+                        helpKeyword = reader.ReadString();\n+                        break;\n+                    case 2:\n+                        senderName = reader.ReadString();\n+                        break;\n+                    case 3:\n+                        columnNumber = reader.ReadInt32();\n+                        break;\n+                    case 4:\n+                        endColumnNumber = reader.ReadInt32();\n+                        break;\n+                    case 5:\n+                        endLineNumber = reader.ReadInt32();\n+                        break;\n+                    case 6:\n+                        lineNumber = reader.ReadInt32();\n+                        break;\n+                    case 7:\n+                        code = reader.ReadString();\n+                        break;\n+                    case 8:\n+                        file = reader.ReadString();\n+                        break;\n+                    case 9:\n+                        subCategory = reader.ReadString();\n+                        break;\n+                    default:\n+                        reader.Skip();\n+                        break;\n+                }\n+            }\n+\n+\n+            BuildWarningEventArgs buildEvent =\n+                new BuildWarningEventArgs(\n+                        subCategory,\n+                        code,\n+                        file,\n+                        lineNumber,\n+                        columnNumber,\n+                        endLineNumber,\n+                        endColumnNumber,\n+                        message,\n+                        helpKeyword,\n+                        senderName);\n+\n+            reader.Depth--;\n+\n+            return buildEvent;\n+        }\n+\n+        void IMessagePackFormatter<BuildWarningEventArgs>.Serialize(ref MessagePackWriter writer, BuildWarningEventArgs value, MessagePackSerializerOptions options)\n+        {\n+            if (value == null)\n+            {\n+                writer.WriteNil();\n+                return;\n+            }\n+\n+            writer.WriteArrayHeader(10);\n+            writer.Write(value.Message);\n+            writer.Write(value.HelpKeyword);\n+            writer.Write(value.SenderName);\n+            writer.Write(value.ColumnNumber);\n+            writer.Write(value.EndColumnNumber);\n+            writer.Write(value.EndLineNumber);\n+            writer.Write(value.LineNumber);\n+            writer.Write(value.Code);\n+            writer.Write(value.File);\n+            writer.Write(value.Subcategory);\n+        }\n+\n+        BuildErrorEventArgs IMessagePackFormatter<BuildErrorEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+        {\n+            if (reader.TryReadNil())\n+            {\n+                return null;\n+            }\n+\n+            options.Security.DepthStep(ref reader);\n+            int length = reader.ReadArrayHeader();\n+            string message = null;\n+            string helpKeyword = null;\n+            string senderName = null;\n+            int columnNumber = default;\n+            int endColumnNumber = default;\n+            int endLineNumber = default;\n+            int lineNumber = default;\n+            string code = default;\n+            string file = default;\n+            string subCategory = default;\n+\n+            for (int key = 0; key < length; key++)\n+            {\n+                switch (key)\n+                {\n+                    case 0:\n+                        message = reader.ReadString();\n+                        break;\n+                    case 1:\n+                        helpKeyword = reader.ReadString();\n+                        break;\n+                    case 2:\n+                        senderName = reader.ReadString();\n+                        break;\n+                    case 3:\n+                        columnNumber = reader.ReadInt32();\n+                        break;\n+                    case 4:\n+                        endColumnNumber = reader.ReadInt32();\n+                        break;\n+                    case 5:\n+                        endLineNumber = reader.ReadInt32();\n+                        break;\n+                    case 6:\n+                        lineNumber = reader.ReadInt32();\n+                        break;\n+                    case 7:\n+                        code = reader.ReadString();\n+                        break;\n+                    case 8:\n+                        file = reader.ReadString();\n+                        break;\n+                    case 9:\n+                        subCategory = reader.ReadString();\n+                        break;\n+                    default:\n+                        reader.Skip();\n+                        break;\n+                }\n+            }\n+\n+            BuildErrorEventArgs buildEvent =\n+                new BuildErrorEventArgs(\n+                        subCategory,\n+                        code,\n+                        file,\n+                        lineNumber,\n+                        columnNumber,\n+                        endLineNumber,\n+                        endColumnNumber,\n+                        message,\n+                        helpKeyword,\n+                        senderName);\n+            reader.Depth--;\n+\n+            return buildEvent;\n+        }\n+\n+\n+        void IMessagePackFormatter<BuildErrorEventArgs>.Serialize(ref MessagePackWriter writer, BuildErrorEventArgs value, MessagePackSerializerOptions options)\n+        {\n+            if (value == null)\n+            {\n+                writer.WriteNil();\n+                return;\n+            }\n+\n+            writer.WriteArrayHeader(10);\n+            writer.Write(value.Message);\n+            writer.Write(value.HelpKeyword);\n+            writer.Write(value.SenderName);\n+            writer.Write(value.ColumnNumber);\n+            writer.Write(value.EndColumnNumber);\n+            writer.Write(value.EndLineNumber);\n+            writer.Write(value.LineNumber);\n+            writer.Write(value.Code);\n+            writer.Write(value.File);\n+            writer.Write(value.Subcategory);\n+        }\n+\n+        BuildMessageEventArgs IMessagePackFormatter<BuildMessageEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+        {\n+            if (reader.TryReadNil())\n+            {\n+                return null;\n+            }\n+\n+            options.Security.DepthStep(ref reader);\n+            int length = reader.ReadArrayHeader();\n+            string message = null;\n+            string helpKeyword = null;\n+            string senderName = null;\n+            int columnNumber = default;\n+            int endColumnNumber = default;\n+            int endLineNumber = default;\n+            int lineNumber = default;\n+            string code = default;\n+            string file = default;\n+            string subCategory = default;\n+            int importance = default;\n+\n+            for (int key = 0; key < length; key++)\n+            {\n+                switch (key)\n+                {\n+                    case 0:\n+                        message = reader.ReadString();\n+                        break;\n+                    case 1:\n+                        helpKeyword = reader.ReadString();\n+                        break;\n+                    case 2:\n+                        senderName = reader.ReadString();\n+                        break;\n+                    case 3:\n+                        columnNumber = reader.ReadInt32();\n+                        break;\n+                    case 4:\n+                        endColumnNumber = reader.ReadInt32();\n+                        break;\n+                    case 5:\n+                        endLineNumber = reader.ReadInt32();\n+                        break;\n+                    case 6:\n+                        lineNumber = reader.ReadInt32();\n+                        break;\n+                    case 7:\n+                        code = reader.ReadString();\n+                        break;\n+                    case 8:\n+                        file = reader.ReadString();\n+                        break;\n+                    case 9:\n+                        subCategory = reader.ReadString();\n+                        break;\n+                    case 10:\n+                        importance = reader.ReadInt32();\n+                        break;\n+                    default:\n+                        reader.Skip();\n+                        break;\n+                }\n+            }\n+\n+            BuildMessageEventArgs buildEvent =\n+               new BuildMessageEventArgs(\n+                       subCategory,\n+                       code,\n+                       file,\n+                       lineNumber,\n+                       columnNumber,\n+                       endLineNumber,\n+                       endColumnNumber,\n+                       message,\n+                       helpKeyword,\n+                       senderName,\n+                       (MessageImportance)importance);\n+            reader.Depth--;\n+\n+            return buildEvent;\n+        }\n+\n+        void IMessagePackFormatter<BuildMessageEventArgs>.Serialize(ref MessagePackWriter writer, BuildMessageEventArgs value, MessagePackSerializerOptions options)\n+        {\n+            if (value == null)\n+            {\n+                writer.WriteNil();\n+                return;\n+            }\n+\n+            int importance = (int)value.Importance;\n+\n+            writer.WriteArrayHeader(11);\n+            writer.Write(value.Message);\n+            writer.Write(value.HelpKeyword);\n+            writer.Write(value.SenderName);\n+            writer.Write(value.ColumnNumber);\n+            writer.Write(value.EndColumnNumber);\n+            writer.Write(value.EndLineNumber);\n+            writer.Write(value.LineNumber);\n+            writer.Write(value.Code);\n+            writer.Write(value.File);\n+            writer.Write(value.Subcategory);\n+            writer.Write(importance);\n+        }\n+\n+        CustomBuildEventArgs IMessagePackFormatter<CustomBuildEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+        {\n+            if (reader.TryReadNil())\n+            {\n+                return null;\n+            }\n+\n+            int customType = reader.ReadInt32();\n+\n+            switch (customType)\n+            {\n+                case 1:\n+                    return (this as IMessagePackFormatter<ExternalProjectStartedEventArgs>).Deserialize(ref reader, options);\n+                case 2:\n+                    return (this as IMessagePackFormatter<ExternalProjectFinishedEventArgs>).Deserialize(ref reader, options);\n+                default:\n+                    ErrorUtilities.ThrowInternalError(\"Unexpected formatter id\");\n+                    return null;\n+            }\n+        }\n+\n+        void IMessagePackFormatter<CustomBuildEventArgs>.Serialize(ref MessagePackWriter writer, CustomBuildEventArgs value, MessagePackSerializerOptions options)\n+        {\n+            if (value == null)\n+            {\n+                writer.WriteNil();\n+                return;\n+            }\n+\n+            int customType = value switch\n+            {\n+                ExternalProjectStartedEventArgs _ => 1,\n+                ExternalProjectFinishedEventArgs _ => 2,\n+                _ => 0\n+            };\n+\n+            writer.WriteInt32(customType);\n+\n+            switch (customType)\n+            {\n+                case 1:\n+                    (this as IMessagePackFormatter<ExternalProjectStartedEventArgs>).Serialize(ref writer, value as ExternalProjectStartedEventArgs, options);\n+                    break;\n+                case 2:\n+                    (this as IMessagePackFormatter<ExternalProjectFinishedEventArgs>).Serialize(ref writer, value as ExternalProjectFinishedEventArgs, options);\n+                    break;\n+                default:\n+                    ErrorUtilities.ThrowInternalError(\"Unexpected formatter id\");\n+                    break;\n+            }\n+        }\n+\n+        ExternalProjectStartedEventArgs IMessagePackFormatter<ExternalProjectStartedEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+        {\n+            if (reader.TryReadNil())\n+            {\n+                return null;\n+            }\n+\n+            options.Security.DepthStep(ref reader);\n+            int length = reader.ReadArrayHeader();\n+            string message = null;\n+            string helpKeyword = null;\n+            string senderName = null;\n+            string projectFile = default;\n+            string targetNames = default;\n+\n+            for (int key = 0; key < length; key++)\n+            {\n+                switch (key)\n+                {\n+                    case 0:\n+                        message = reader.ReadString();\n+                        break;\n+                    case 1:\n+                        helpKeyword = reader.ReadString();\n+                        break;\n+                    case 2:\n+                        senderName = reader.ReadString();\n+                        break;\n+                    case 3:\n+                        projectFile = reader.ReadString();\n+                        break;\n+                    case 4:\n+                        targetNames = reader.ReadString();\n+                        break;\n+                    default:\n+                        reader.Skip();\n+                        break;\n+                }\n+            }\n+\n+            ExternalProjectStartedEventArgs buildEvent =\n+               new ExternalProjectStartedEventArgs(\n+                       message,\n+                       helpKeyword,\n+                       senderName,\n+                       projectFile,\n+                       targetNames);\n+            reader.Depth--;\n+\n+            return buildEvent;\n+        }\n+\n+        void IMessagePackFormatter<ExternalProjectStartedEventArgs>.Serialize(ref MessagePackWriter writer, ExternalProjectStartedEventArgs value, MessagePackSerializerOptions options)\n+        {\n+            if (value == null)\n+            {\n+                writer.WriteNil();\n+                return;\n+            }\n+\n+            writer.WriteArrayHeader(5);\n+            writer.Write(value.Message);\n+            writer.Write(value.HelpKeyword);\n+            writer.Write(value.SenderName);\n+            writer.Write(value.ProjectFile);\n+            writer.Write(value.TargetNames);\n+        }\n+\n+        ExternalProjectFinishedEventArgs IMessagePackFormatter<ExternalProjectFinishedEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n+        {\n+            if (reader.TryReadNil())\n+            {\n+                return null;\n+            }\n+\n+            options.Security.DepthStep(ref reader);\n+            int length = reader.ReadArrayHeader();\n+            string message = null;\n+            string helpKeyword = null;\n+            string senderName = null;\n+            string projectFile = default;\n+            bool succeeded = default;\n+\n+            for (int key = 0; key < length; key++)\n+            {\n+                switch (key)\n+                {\n+                    case 0:\n+                        message = reader.ReadString();\n+                        break;\n+                    case 1:\n+                        helpKeyword = reader.ReadString();\n+                        break;\n+                    case 2:\n+                        senderName = reader.ReadString();\n+                        break;\n+                    case 3:\n+                        projectFile = reader.ReadString();\n+                        break;\n+                    case 4:\n+                        succeeded = reader.ReadBoolean();\n+                        break;\n+                    default:\n+                        reader.Skip();\n+                        break;\n+                }\n+            }\n+\n+            ExternalProjectFinishedEventArgs buildEvent =\n+               new ExternalProjectFinishedEventArgs(\n+                       message,\n+                       helpKeyword,\n+                       senderName,\n+                       projectFile,\n+                       succeeded);\n+            reader.Depth--;\n+\n+            return buildEvent;\n+        }\n+\n+        void IMessagePackFormatter<ExternalProjectFinishedEventArgs>.Serialize(ref MessagePackWriter writer, ExternalProjectFinishedEventArgs value, MessagePackSerializerOptions options)\n+        {\n+            if (value == null)\n+            {\n+                writer.WriteNil();\n+                return;\n+            }\n+\n+            writer.WriteArrayHeader(5);\n+            writer.Write(value.Message);\n+            writer.Write(value.HelpKeyword);\n+            writer.Write(value.SenderName);\n+            writer.Write(value.ProjectFile);\n+            writer.Write(value.Succeeded);\n+        }\n+\n+\n+        //private abstract class Formatter<TArg> : IMessagePackFormatter<TArg> where TArg : BuildEventArgs",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Typos in file name.",
              "createdAt": "2020-09-11T13:37:29Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -350,10 +350,25 @@\n     <Compile Include=\"ResourceHandling\\*.cs\" />\n     <Compile Include=\"ResolveAssemblyReferences\\Client\\RarClient.cs\" />\n     <Compile Include=\"ResolveAssemblyReferences\\Contract\\IResolveAssemblyReferenceTaskHandler.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ResolveAssemblyReferenceResult.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ReadOnlyTaskItem.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ResolveAssemblyReferenceRequest.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ResolveAssemblyReferenceResponse.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ResolveAssemblyReferenceTaskInput.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ResolveAssemblyReferenceTaskOutput.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Formatters\\BuildEventArgsFormatter.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Formatters\\ReadOnlyTaskItemFormatter.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Formatters\\ResolveAssemblyReferenceRequestFormatter.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Formatters\\ResolveAssemblyReferenceResponseFormatter.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Formatters\\ResolveAssemblyReferenceResultFormatter.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\ResolveAssemlyReferneceResolver.cs\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `y != null` is already checked on line 18.",
              "createdAt": "2020-09-11T13:40:39Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs",
              "diffHunk": "@@ -0,0 +1,187 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services\n+{\n+    internal static class ResolveAssemblyReferenceComparer\n+    {\n+        internal static bool CompareInput(ResolveAssemblyReferenceRequest x, ResolveAssemblyReferenceRequest y)\n+        {\n+            if (x == y)\n+            {\n+                return true;\n+            }\n+\n+            if (x == null || y == null)\n+            {\n+                return false;\n+            }\n+\n+            bool fieldsEqual = y != null &&",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Have you considered using `Enumerable.SequenceEqual()`?",
              "createdAt": "2020-09-11T13:42:43Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs",
              "diffHunk": "@@ -0,0 +1,187 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services\n+{\n+    internal static class ResolveAssemblyReferenceComparer\n+    {\n+        internal static bool CompareInput(ResolveAssemblyReferenceRequest x, ResolveAssemblyReferenceRequest y)\n+        {\n+            if (x == y)\n+            {\n+                return true;\n+            }\n+\n+            if (x == null || y == null)\n+            {\n+                return false;\n+            }\n+\n+            bool fieldsEqual = y != null &&\n+                   x.AppConfigFile == y.AppConfigFile &&\n+                   x.AutoUnify == y.AutoUnify &&\n+                   x.CopyLocalDependenciesWhenParentReferenceInGac == y.CopyLocalDependenciesWhenParentReferenceInGac &&\n+                   x.DoNotCopyLocalIfInGac == y.DoNotCopyLocalIfInGac &&\n+                   x.FindDependencies == y.FindDependencies &&\n+                   x.FindDependenciesOfExternallyResolvedReferences == y.FindDependenciesOfExternallyResolvedReferences &&\n+                   x.FindRelatedFiles == y.FindRelatedFiles &&\n+                   x.FindSatellites == y.FindSatellites &&\n+                   x.FindSerializationAssemblies == y.FindSerializationAssemblies &&\n+                   x.IgnoreDefaultInstalledAssemblySubsetTables == y.IgnoreDefaultInstalledAssemblySubsetTables &&\n+                   x.IgnoreDefaultInstalledAssemblyTables == y.IgnoreDefaultInstalledAssemblyTables &&\n+                   x.IgnoreTargetFrameworkAttributeVersionMismatch == y.IgnoreTargetFrameworkAttributeVersionMismatch &&\n+                   x.IgnoreVersionForFrameworkReferences == y.IgnoreVersionForFrameworkReferences &&\n+                   x.ProfileName == y.ProfileName &&\n+                   x.Silent == y.Silent &&\n+                   x.StateFile == y.StateFile &&\n+                   x.SupportsBindingRedirectGeneration == y.SupportsBindingRedirectGeneration &&\n+                   x.TargetedRuntimeVersion == y.TargetedRuntimeVersion &&\n+                   x.TargetFrameworkMoniker == y.TargetFrameworkMoniker &&\n+                   x.TargetFrameworkMonikerDisplayName == y.TargetFrameworkMonikerDisplayName &&\n+                   x.TargetFrameworkVersion == y.TargetFrameworkVersion &&\n+                   x.TargetProcessorArchitecture == y.TargetProcessorArchitecture &&\n+                   x.UnresolveFrameworkAssembliesFromHigherFrameworks == y.UnresolveFrameworkAssembliesFromHigherFrameworks &&\n+                   x.UseResolveAssemblyReferenceService == y.UseResolveAssemblyReferenceService &&\n+                   x.WarnOrErrorOnTargetArchitectureMismatch == y.WarnOrErrorOnTargetArchitectureMismatch &&\n+                   x.CurrentPath == y.CurrentPath;\n+\n+            return fieldsEqual &&\n+                   AreStringListsEqual(x.AllowedAssemblyExtensions, y.AllowedAssemblyExtensions) &&\n+                   AreStringListsEqual(x.AllowedRelatedFileExtensions, y.AllowedRelatedFileExtensions) &&\n+                   AreTaskItemListsEqual(x.Assemblies, y.Assemblies) &&\n+                   AreTaskItemListsEqual(x.AssemblyFiles, y.AssemblyFiles) &&\n+                   AreStringListsEqual(x.CandidateAssemblyFiles, y.CandidateAssemblyFiles) &&\n+                   AreTaskItemListsEqual(x.FullFrameworkAssemblyTables, y.FullFrameworkAssemblyTables) &&\n+                   AreStringListsEqual(x.FullFrameworkFolders, y.FullFrameworkFolders) &&\n+                   AreStringListsEqual(x.FullTargetFrameworkSubsetNames, y.FullTargetFrameworkSubsetNames) &&\n+                   AreTaskItemListsEqual(x.InstalledAssemblySubsetTables, y.InstalledAssemblySubsetTables) &&\n+                   AreTaskItemListsEqual(x.InstalledAssemblyTables, y.InstalledAssemblyTables) &&\n+                   AreStringListsEqual(x.LatestTargetFrameworkDirectories, y.LatestTargetFrameworkDirectories) &&\n+                   AreTaskItemListsEqual(x.ResolvedSDKReferences, y.ResolvedSDKReferences) &&\n+                   AreStringListsEqual(x.SearchPaths, y.SearchPaths) &&\n+                   AreStringListsEqual(x.TargetFrameworkDirectories, y.TargetFrameworkDirectories) &&\n+                   AreStringListsEqual(x.TargetFrameworkSubsets, y.TargetFrameworkSubsets);\n+        }\n+\n+        internal static bool CompareOutput(ResolveAssemblyReferenceResponse x, ResolveAssemblyReferenceResponse y)\n+        {\n+            if (x == y)\n+            {\n+                return true;\n+            }\n+\n+            if (x == null || y == null)\n+            {\n+                return false;\n+            }\n+\n+            return x.DependsOnNETStandard == y.DependsOnNETStandard &&\n+                   x.DependsOnSystemRuntime == y.DependsOnSystemRuntime &&\n+                   AreTaskItemListsEqual(x.CopyLocalFiles, y.CopyLocalFiles) &&\n+                   AreTaskItemListsEqual(x.FilesWritten, y.FilesWritten) &&\n+                   AreTaskItemListsEqual(x.RelatedFiles, y.RelatedFiles) &&\n+                   AreTaskItemListsEqual(x.ResolvedDependencyFiles, y.ResolvedDependencyFiles) &&\n+                   AreTaskItemListsEqual(x.ResolvedFiles, y.ResolvedFiles) &&\n+                   AreTaskItemListsEqual(x.SatelliteFiles, y.SatelliteFiles) &&\n+                   AreTaskItemListsEqual(x.ScatterFiles, y.ScatterFiles) &&\n+                   AreTaskItemListsEqual(x.SerializationAssemblyFiles, y.SerializationAssemblyFiles) &&\n+                   AreTaskItemListsEqual(x.SuggestedRedirects, y.SuggestedRedirects); \n+            //&&\n+            //       AreTaskItemListsEqual(x.Assemblies, y.Assemblies) &&\n+            //       AreTaskItemListsEqual(x.AssemblyFiles, y.AssemblyFiles);\n+        }\n+\n+        private static bool AreStringListsEqual(string[] x, string[] y)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "In my first version I used it, but that required strings array to be not null, so I decided to go with this approach.",
              "createdAt": "2020-09-17T18:05:39Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs",
              "diffHunk": "@@ -0,0 +1,187 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services\n+{\n+    internal static class ResolveAssemblyReferenceComparer\n+    {\n+        internal static bool CompareInput(ResolveAssemblyReferenceRequest x, ResolveAssemblyReferenceRequest y)\n+        {\n+            if (x == y)\n+            {\n+                return true;\n+            }\n+\n+            if (x == null || y == null)\n+            {\n+                return false;\n+            }\n+\n+            bool fieldsEqual = y != null &&\n+                   x.AppConfigFile == y.AppConfigFile &&\n+                   x.AutoUnify == y.AutoUnify &&\n+                   x.CopyLocalDependenciesWhenParentReferenceInGac == y.CopyLocalDependenciesWhenParentReferenceInGac &&\n+                   x.DoNotCopyLocalIfInGac == y.DoNotCopyLocalIfInGac &&\n+                   x.FindDependencies == y.FindDependencies &&\n+                   x.FindDependenciesOfExternallyResolvedReferences == y.FindDependenciesOfExternallyResolvedReferences &&\n+                   x.FindRelatedFiles == y.FindRelatedFiles &&\n+                   x.FindSatellites == y.FindSatellites &&\n+                   x.FindSerializationAssemblies == y.FindSerializationAssemblies &&\n+                   x.IgnoreDefaultInstalledAssemblySubsetTables == y.IgnoreDefaultInstalledAssemblySubsetTables &&\n+                   x.IgnoreDefaultInstalledAssemblyTables == y.IgnoreDefaultInstalledAssemblyTables &&\n+                   x.IgnoreTargetFrameworkAttributeVersionMismatch == y.IgnoreTargetFrameworkAttributeVersionMismatch &&\n+                   x.IgnoreVersionForFrameworkReferences == y.IgnoreVersionForFrameworkReferences &&\n+                   x.ProfileName == y.ProfileName &&\n+                   x.Silent == y.Silent &&\n+                   x.StateFile == y.StateFile &&\n+                   x.SupportsBindingRedirectGeneration == y.SupportsBindingRedirectGeneration &&\n+                   x.TargetedRuntimeVersion == y.TargetedRuntimeVersion &&\n+                   x.TargetFrameworkMoniker == y.TargetFrameworkMoniker &&\n+                   x.TargetFrameworkMonikerDisplayName == y.TargetFrameworkMonikerDisplayName &&\n+                   x.TargetFrameworkVersion == y.TargetFrameworkVersion &&\n+                   x.TargetProcessorArchitecture == y.TargetProcessorArchitecture &&\n+                   x.UnresolveFrameworkAssembliesFromHigherFrameworks == y.UnresolveFrameworkAssembliesFromHigherFrameworks &&\n+                   x.UseResolveAssemblyReferenceService == y.UseResolveAssemblyReferenceService &&\n+                   x.WarnOrErrorOnTargetArchitectureMismatch == y.WarnOrErrorOnTargetArchitectureMismatch &&\n+                   x.CurrentPath == y.CurrentPath;\n+\n+            return fieldsEqual &&\n+                   AreStringListsEqual(x.AllowedAssemblyExtensions, y.AllowedAssemblyExtensions) &&\n+                   AreStringListsEqual(x.AllowedRelatedFileExtensions, y.AllowedRelatedFileExtensions) &&\n+                   AreTaskItemListsEqual(x.Assemblies, y.Assemblies) &&\n+                   AreTaskItemListsEqual(x.AssemblyFiles, y.AssemblyFiles) &&\n+                   AreStringListsEqual(x.CandidateAssemblyFiles, y.CandidateAssemblyFiles) &&\n+                   AreTaskItemListsEqual(x.FullFrameworkAssemblyTables, y.FullFrameworkAssemblyTables) &&\n+                   AreStringListsEqual(x.FullFrameworkFolders, y.FullFrameworkFolders) &&\n+                   AreStringListsEqual(x.FullTargetFrameworkSubsetNames, y.FullTargetFrameworkSubsetNames) &&\n+                   AreTaskItemListsEqual(x.InstalledAssemblySubsetTables, y.InstalledAssemblySubsetTables) &&\n+                   AreTaskItemListsEqual(x.InstalledAssemblyTables, y.InstalledAssemblyTables) &&\n+                   AreStringListsEqual(x.LatestTargetFrameworkDirectories, y.LatestTargetFrameworkDirectories) &&\n+                   AreTaskItemListsEqual(x.ResolvedSDKReferences, y.ResolvedSDKReferences) &&\n+                   AreStringListsEqual(x.SearchPaths, y.SearchPaths) &&\n+                   AreStringListsEqual(x.TargetFrameworkDirectories, y.TargetFrameworkDirectories) &&\n+                   AreStringListsEqual(x.TargetFrameworkSubsets, y.TargetFrameworkSubsets);\n+        }\n+\n+        internal static bool CompareOutput(ResolveAssemblyReferenceResponse x, ResolveAssemblyReferenceResponse y)\n+        {\n+            if (x == y)\n+            {\n+                return true;\n+            }\n+\n+            if (x == null || y == null)\n+            {\n+                return false;\n+            }\n+\n+            return x.DependsOnNETStandard == y.DependsOnNETStandard &&\n+                   x.DependsOnSystemRuntime == y.DependsOnSystemRuntime &&\n+                   AreTaskItemListsEqual(x.CopyLocalFiles, y.CopyLocalFiles) &&\n+                   AreTaskItemListsEqual(x.FilesWritten, y.FilesWritten) &&\n+                   AreTaskItemListsEqual(x.RelatedFiles, y.RelatedFiles) &&\n+                   AreTaskItemListsEqual(x.ResolvedDependencyFiles, y.ResolvedDependencyFiles) &&\n+                   AreTaskItemListsEqual(x.ResolvedFiles, y.ResolvedFiles) &&\n+                   AreTaskItemListsEqual(x.SatelliteFiles, y.SatelliteFiles) &&\n+                   AreTaskItemListsEqual(x.ScatterFiles, y.ScatterFiles) &&\n+                   AreTaskItemListsEqual(x.SerializationAssemblyFiles, y.SerializationAssemblyFiles) &&\n+                   AreTaskItemListsEqual(x.SuggestedRedirects, y.SuggestedRedirects); \n+            //&&\n+            //       AreTaskItemListsEqual(x.Assemblies, y.Assemblies) &&\n+            //       AreTaskItemListsEqual(x.AssemblyFiles, y.AssemblyFiles);\n+        }\n+\n+        private static bool AreStringListsEqual(string[] x, string[] y)",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Same here: This could be implemented with `Enumerable.SequenceEqual()` with a custom equality comparer.",
              "createdAt": "2020-09-11T13:43:48Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs",
              "diffHunk": "@@ -0,0 +1,187 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services\n+{\n+    internal static class ResolveAssemblyReferenceComparer\n+    {\n+        internal static bool CompareInput(ResolveAssemblyReferenceRequest x, ResolveAssemblyReferenceRequest y)\n+        {\n+            if (x == y)\n+            {\n+                return true;\n+            }\n+\n+            if (x == null || y == null)\n+            {\n+                return false;\n+            }\n+\n+            bool fieldsEqual = y != null &&\n+                   x.AppConfigFile == y.AppConfigFile &&\n+                   x.AutoUnify == y.AutoUnify &&\n+                   x.CopyLocalDependenciesWhenParentReferenceInGac == y.CopyLocalDependenciesWhenParentReferenceInGac &&\n+                   x.DoNotCopyLocalIfInGac == y.DoNotCopyLocalIfInGac &&\n+                   x.FindDependencies == y.FindDependencies &&\n+                   x.FindDependenciesOfExternallyResolvedReferences == y.FindDependenciesOfExternallyResolvedReferences &&\n+                   x.FindRelatedFiles == y.FindRelatedFiles &&\n+                   x.FindSatellites == y.FindSatellites &&\n+                   x.FindSerializationAssemblies == y.FindSerializationAssemblies &&\n+                   x.IgnoreDefaultInstalledAssemblySubsetTables == y.IgnoreDefaultInstalledAssemblySubsetTables &&\n+                   x.IgnoreDefaultInstalledAssemblyTables == y.IgnoreDefaultInstalledAssemblyTables &&\n+                   x.IgnoreTargetFrameworkAttributeVersionMismatch == y.IgnoreTargetFrameworkAttributeVersionMismatch &&\n+                   x.IgnoreVersionForFrameworkReferences == y.IgnoreVersionForFrameworkReferences &&\n+                   x.ProfileName == y.ProfileName &&\n+                   x.Silent == y.Silent &&\n+                   x.StateFile == y.StateFile &&\n+                   x.SupportsBindingRedirectGeneration == y.SupportsBindingRedirectGeneration &&\n+                   x.TargetedRuntimeVersion == y.TargetedRuntimeVersion &&\n+                   x.TargetFrameworkMoniker == y.TargetFrameworkMoniker &&\n+                   x.TargetFrameworkMonikerDisplayName == y.TargetFrameworkMonikerDisplayName &&\n+                   x.TargetFrameworkVersion == y.TargetFrameworkVersion &&\n+                   x.TargetProcessorArchitecture == y.TargetProcessorArchitecture &&\n+                   x.UnresolveFrameworkAssembliesFromHigherFrameworks == y.UnresolveFrameworkAssembliesFromHigherFrameworks &&\n+                   x.UseResolveAssemblyReferenceService == y.UseResolveAssemblyReferenceService &&\n+                   x.WarnOrErrorOnTargetArchitectureMismatch == y.WarnOrErrorOnTargetArchitectureMismatch &&\n+                   x.CurrentPath == y.CurrentPath;\n+\n+            return fieldsEqual &&\n+                   AreStringListsEqual(x.AllowedAssemblyExtensions, y.AllowedAssemblyExtensions) &&\n+                   AreStringListsEqual(x.AllowedRelatedFileExtensions, y.AllowedRelatedFileExtensions) &&\n+                   AreTaskItemListsEqual(x.Assemblies, y.Assemblies) &&\n+                   AreTaskItemListsEqual(x.AssemblyFiles, y.AssemblyFiles) &&\n+                   AreStringListsEqual(x.CandidateAssemblyFiles, y.CandidateAssemblyFiles) &&\n+                   AreTaskItemListsEqual(x.FullFrameworkAssemblyTables, y.FullFrameworkAssemblyTables) &&\n+                   AreStringListsEqual(x.FullFrameworkFolders, y.FullFrameworkFolders) &&\n+                   AreStringListsEqual(x.FullTargetFrameworkSubsetNames, y.FullTargetFrameworkSubsetNames) &&\n+                   AreTaskItemListsEqual(x.InstalledAssemblySubsetTables, y.InstalledAssemblySubsetTables) &&\n+                   AreTaskItemListsEqual(x.InstalledAssemblyTables, y.InstalledAssemblyTables) &&\n+                   AreStringListsEqual(x.LatestTargetFrameworkDirectories, y.LatestTargetFrameworkDirectories) &&\n+                   AreTaskItemListsEqual(x.ResolvedSDKReferences, y.ResolvedSDKReferences) &&\n+                   AreStringListsEqual(x.SearchPaths, y.SearchPaths) &&\n+                   AreStringListsEqual(x.TargetFrameworkDirectories, y.TargetFrameworkDirectories) &&\n+                   AreStringListsEqual(x.TargetFrameworkSubsets, y.TargetFrameworkSubsets);\n+        }\n+\n+        internal static bool CompareOutput(ResolveAssemblyReferenceResponse x, ResolveAssemblyReferenceResponse y)\n+        {\n+            if (x == y)\n+            {\n+                return true;\n+            }\n+\n+            if (x == null || y == null)\n+            {\n+                return false;\n+            }\n+\n+            return x.DependsOnNETStandard == y.DependsOnNETStandard &&\n+                   x.DependsOnSystemRuntime == y.DependsOnSystemRuntime &&\n+                   AreTaskItemListsEqual(x.CopyLocalFiles, y.CopyLocalFiles) &&\n+                   AreTaskItemListsEqual(x.FilesWritten, y.FilesWritten) &&\n+                   AreTaskItemListsEqual(x.RelatedFiles, y.RelatedFiles) &&\n+                   AreTaskItemListsEqual(x.ResolvedDependencyFiles, y.ResolvedDependencyFiles) &&\n+                   AreTaskItemListsEqual(x.ResolvedFiles, y.ResolvedFiles) &&\n+                   AreTaskItemListsEqual(x.SatelliteFiles, y.SatelliteFiles) &&\n+                   AreTaskItemListsEqual(x.ScatterFiles, y.ScatterFiles) &&\n+                   AreTaskItemListsEqual(x.SerializationAssemblyFiles, y.SerializationAssemblyFiles) &&\n+                   AreTaskItemListsEqual(x.SuggestedRedirects, y.SuggestedRedirects); \n+            //&&\n+            //       AreTaskItemListsEqual(x.Assemblies, y.Assemblies) &&\n+            //       AreTaskItemListsEqual(x.AssemblyFiles, y.AssemblyFiles);\n+        }\n+\n+        private static bool AreStringListsEqual(string[] x, string[] y)\n+        {\n+            if (x == y)\n+            {\n+                return true;\n+            }\n+\n+            if (x == null || y == null)\n+            {\n+                return false;\n+            }\n+\n+            if (x.Length != y.Length)\n+            {\n+                return false;\n+            }\n+\n+            for (int i = 0; i < x.Length; i++)\n+            {\n+                if (x[i] != y[i])\n+                {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        private static bool AreTaskItemListsEqual(ReadOnlyTaskItem[] x, ReadOnlyTaskItem[] y)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Same as above + additional work with custom equality comparer",
              "createdAt": "2020-09-17T18:06:07Z",
              "path": "src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs",
              "diffHunk": "@@ -0,0 +1,187 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+\n+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services\n+{\n+    internal static class ResolveAssemblyReferenceComparer\n+    {\n+        internal static bool CompareInput(ResolveAssemblyReferenceRequest x, ResolveAssemblyReferenceRequest y)\n+        {\n+            if (x == y)\n+            {\n+                return true;\n+            }\n+\n+            if (x == null || y == null)\n+            {\n+                return false;\n+            }\n+\n+            bool fieldsEqual = y != null &&\n+                   x.AppConfigFile == y.AppConfigFile &&\n+                   x.AutoUnify == y.AutoUnify &&\n+                   x.CopyLocalDependenciesWhenParentReferenceInGac == y.CopyLocalDependenciesWhenParentReferenceInGac &&\n+                   x.DoNotCopyLocalIfInGac == y.DoNotCopyLocalIfInGac &&\n+                   x.FindDependencies == y.FindDependencies &&\n+                   x.FindDependenciesOfExternallyResolvedReferences == y.FindDependenciesOfExternallyResolvedReferences &&\n+                   x.FindRelatedFiles == y.FindRelatedFiles &&\n+                   x.FindSatellites == y.FindSatellites &&\n+                   x.FindSerializationAssemblies == y.FindSerializationAssemblies &&\n+                   x.IgnoreDefaultInstalledAssemblySubsetTables == y.IgnoreDefaultInstalledAssemblySubsetTables &&\n+                   x.IgnoreDefaultInstalledAssemblyTables == y.IgnoreDefaultInstalledAssemblyTables &&\n+                   x.IgnoreTargetFrameworkAttributeVersionMismatch == y.IgnoreTargetFrameworkAttributeVersionMismatch &&\n+                   x.IgnoreVersionForFrameworkReferences == y.IgnoreVersionForFrameworkReferences &&\n+                   x.ProfileName == y.ProfileName &&\n+                   x.Silent == y.Silent &&\n+                   x.StateFile == y.StateFile &&\n+                   x.SupportsBindingRedirectGeneration == y.SupportsBindingRedirectGeneration &&\n+                   x.TargetedRuntimeVersion == y.TargetedRuntimeVersion &&\n+                   x.TargetFrameworkMoniker == y.TargetFrameworkMoniker &&\n+                   x.TargetFrameworkMonikerDisplayName == y.TargetFrameworkMonikerDisplayName &&\n+                   x.TargetFrameworkVersion == y.TargetFrameworkVersion &&\n+                   x.TargetProcessorArchitecture == y.TargetProcessorArchitecture &&\n+                   x.UnresolveFrameworkAssembliesFromHigherFrameworks == y.UnresolveFrameworkAssembliesFromHigherFrameworks &&\n+                   x.UseResolveAssemblyReferenceService == y.UseResolveAssemblyReferenceService &&\n+                   x.WarnOrErrorOnTargetArchitectureMismatch == y.WarnOrErrorOnTargetArchitectureMismatch &&\n+                   x.CurrentPath == y.CurrentPath;\n+\n+            return fieldsEqual &&\n+                   AreStringListsEqual(x.AllowedAssemblyExtensions, y.AllowedAssemblyExtensions) &&\n+                   AreStringListsEqual(x.AllowedRelatedFileExtensions, y.AllowedRelatedFileExtensions) &&\n+                   AreTaskItemListsEqual(x.Assemblies, y.Assemblies) &&\n+                   AreTaskItemListsEqual(x.AssemblyFiles, y.AssemblyFiles) &&\n+                   AreStringListsEqual(x.CandidateAssemblyFiles, y.CandidateAssemblyFiles) &&\n+                   AreTaskItemListsEqual(x.FullFrameworkAssemblyTables, y.FullFrameworkAssemblyTables) &&\n+                   AreStringListsEqual(x.FullFrameworkFolders, y.FullFrameworkFolders) &&\n+                   AreStringListsEqual(x.FullTargetFrameworkSubsetNames, y.FullTargetFrameworkSubsetNames) &&\n+                   AreTaskItemListsEqual(x.InstalledAssemblySubsetTables, y.InstalledAssemblySubsetTables) &&\n+                   AreTaskItemListsEqual(x.InstalledAssemblyTables, y.InstalledAssemblyTables) &&\n+                   AreStringListsEqual(x.LatestTargetFrameworkDirectories, y.LatestTargetFrameworkDirectories) &&\n+                   AreTaskItemListsEqual(x.ResolvedSDKReferences, y.ResolvedSDKReferences) &&\n+                   AreStringListsEqual(x.SearchPaths, y.SearchPaths) &&\n+                   AreStringListsEqual(x.TargetFrameworkDirectories, y.TargetFrameworkDirectories) &&\n+                   AreStringListsEqual(x.TargetFrameworkSubsets, y.TargetFrameworkSubsets);\n+        }\n+\n+        internal static bool CompareOutput(ResolveAssemblyReferenceResponse x, ResolveAssemblyReferenceResponse y)\n+        {\n+            if (x == y)\n+            {\n+                return true;\n+            }\n+\n+            if (x == null || y == null)\n+            {\n+                return false;\n+            }\n+\n+            return x.DependsOnNETStandard == y.DependsOnNETStandard &&\n+                   x.DependsOnSystemRuntime == y.DependsOnSystemRuntime &&\n+                   AreTaskItemListsEqual(x.CopyLocalFiles, y.CopyLocalFiles) &&\n+                   AreTaskItemListsEqual(x.FilesWritten, y.FilesWritten) &&\n+                   AreTaskItemListsEqual(x.RelatedFiles, y.RelatedFiles) &&\n+                   AreTaskItemListsEqual(x.ResolvedDependencyFiles, y.ResolvedDependencyFiles) &&\n+                   AreTaskItemListsEqual(x.ResolvedFiles, y.ResolvedFiles) &&\n+                   AreTaskItemListsEqual(x.SatelliteFiles, y.SatelliteFiles) &&\n+                   AreTaskItemListsEqual(x.ScatterFiles, y.ScatterFiles) &&\n+                   AreTaskItemListsEqual(x.SerializationAssemblyFiles, y.SerializationAssemblyFiles) &&\n+                   AreTaskItemListsEqual(x.SuggestedRedirects, y.SuggestedRedirects); \n+            //&&\n+            //       AreTaskItemListsEqual(x.Assemblies, y.Assemblies) &&\n+            //       AreTaskItemListsEqual(x.AssemblyFiles, y.AssemblyFiles);\n+        }\n+\n+        private static bool AreStringListsEqual(string[] x, string[] y)\n+        {\n+            if (x == y)\n+            {\n+                return true;\n+            }\n+\n+            if (x == null || y == null)\n+            {\n+                return false;\n+            }\n+\n+            if (x.Length != y.Length)\n+            {\n+                return false;\n+            }\n+\n+            for (int i = 0; i < x.Length; i++)\n+            {\n+                if (x[i] != y[i])\n+                {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        private static bool AreTaskItemListsEqual(ReadOnlyTaskItem[] x, ReadOnlyTaskItem[] y)",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Typo in file name.",
              "createdAt": "2020-09-11T13:44:30Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -350,10 +350,25 @@\n     <Compile Include=\"ResourceHandling\\*.cs\" />\n     <Compile Include=\"ResolveAssemblyReferences\\Client\\RarClient.cs\" />\n     <Compile Include=\"ResolveAssemblyReferences\\Contract\\IResolveAssemblyReferenceTaskHandler.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ResolveAssemblyReferenceResult.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ReadOnlyTaskItem.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ResolveAssemblyReferenceRequest.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ResolveAssemblyReferenceResponse.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ResolveAssemblyReferenceTaskInput.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Contract\\ResolveAssemblyReferenceTaskOutput.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Formatters\\BuildEventArgsFormatter.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Formatters\\ReadOnlyTaskItemFormatter.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Formatters\\ResolveAssemblyReferenceRequestFormatter.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Formatters\\ResolveAssemblyReferenceResponseFormatter.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Formatters\\ResolveAssemblyReferenceResultFormatter.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\ResolveAssemlyReferneceResolver.cs\" />\n     <Compile Include=\"ResolveAssemblyReferences\\RpcUtils.cs\" />\n     <Compile Include=\"ResolveAssemblyReferences\\Server\\RarController.cs\" />\n-    <Compile Include=\"ResolveAssemblyReferences\\Services\\RarTaskHandler.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Services\\ResolveAssemblyReferenceBuildEngine.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Services\\ResolveAssemblyReferenceComparer.cs\" />\n     <Compile Include=\"ResolveAssemblyReferences\\Server\\ServerMutex.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Services\\ResolveAssemblyReferenceHandler.cs\" />\n+    <Compile Include=\"ResolveAssemblyReferences\\Services\\ResolveAssemlyReferenceCacheHandler.cs\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why this change?",
              "createdAt": "2020-09-17T18:34:58Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2020,11 +2020,6 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n \n         internal bool CreateRarNode()\n         {\n-            // If the _buildParametrs is not set, we are in OutOfProc mode, so continue\n-            // Else check if users specified that he want to use multiple nodes, if so use RARaaS\n-            if (_buildParameters?.MaxNodeCount == 1)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I have realized that, when user opt into this feature, than it doesn't really matter if he runs only on one node.  And in future, if he opts-out of this feature, then the same scenario.",
              "createdAt": "2020-09-23T17:20:59Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2020,11 +2020,6 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n \n         internal bool CreateRarNode()\n         {\n-            // If the _buildParametrs is not set, we are in OutOfProc mode, so continue\n-            // Else check if users specified that he want to use multiple nodes, if so use RARaaS\n-            if (_buildParameters?.MaxNodeCount == 1)",
              "author": {
                "login": "ostorc"
              }
            },
            {
              "body": "Why? If I specify that I only want one node, I don't want you starting up a normal worker node or a RAR node.",
              "createdAt": "2020-09-23T18:05:23Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2020,11 +2020,6 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n \n         internal bool CreateRarNode()\n         {\n-            // If the _buildParametrs is not set, we are in OutOfProc mode, so continue\n-            // Else check if users specified that he want to use multiple nodes, if so use RARaaS\n-            if (_buildParameters?.MaxNodeCount == 1)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Ok, reverted.",
              "createdAt": "2020-09-23T20:12:46Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2020,11 +2020,6 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n \n         internal bool CreateRarNode()\n         {\n-            // If the _buildParametrs is not set, we are in OutOfProc mode, so continue\n-            // Else check if users specified that he want to use multiple nodes, if so use RARaaS\n-            if (_buildParameters?.MaxNodeCount == 1)",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What exception(s) do you expect here? If you're just trying to prevent it from throwing any other kind of error, this might be the right time to throw an internal error.",
              "createdAt": "2020-09-18T21:14:11Z",
              "path": "src/Build/BackEnd/Node/RarNode.cs",
              "diffHunk": "@@ -60,7 +60,11 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except\n                 // - node lifetime expires\n                 index = Task.WaitAny(new Task[] { msBuildShutdown, rarTask }, cts.Token);\n             }\n-            catch (OperationCanceledException e)\n+            catch (OperationCanceledException)\n+            {\n+                return NodeEngineShutdownReason.BuildComplete;\n+            }\n+            catch (Exception e)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I though that preferred way was to exit node without exception and return Error as result and set the shutdownException. But sure can throw internal error instead. What do you think?",
              "createdAt": "2020-09-22T09:26:11Z",
              "path": "src/Build/BackEnd/Node/RarNode.cs",
              "diffHunk": "@@ -60,7 +60,11 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except\n                 // - node lifetime expires\n                 index = Task.WaitAny(new Task[] { msBuildShutdown, rarTask }, cts.Token);\n             }\n-            catch (OperationCanceledException e)\n+            catch (OperationCanceledException)\n+            {\n+                return NodeEngineShutdownReason.BuildComplete;\n+            }\n+            catch (Exception e)",
              "author": {
                "login": "ostorc"
              }
            },
            {
              "body": "I might've been wrong. Let me go check.",
              "createdAt": "2020-09-22T15:10:36Z",
              "path": "src/Build/BackEnd/Node/RarNode.cs",
              "diffHunk": "@@ -60,7 +60,11 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except\n                 // - node lifetime expires\n                 index = Task.WaitAny(new Task[] { msBuildShutdown, rarTask }, cts.Token);\n             }\n-            catch (OperationCanceledException e)\n+            catch (OperationCanceledException)\n+            {\n+                return NodeEngineShutdownReason.BuildComplete;\n+            }\n+            catch (Exception e)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Looks like we do sometimes swallow an error, sometimes without even shutting down, just going idle instead. We do log that and make a dump, though, which might be helpful? I don't know how likely this is to be a pain point; if it is, we'd want that.",
              "createdAt": "2020-09-22T15:18:50Z",
              "path": "src/Build/BackEnd/Node/RarNode.cs",
              "diffHunk": "@@ -60,7 +60,11 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except\n                 // - node lifetime expires\n                 index = Task.WaitAny(new Task[] { msBuildShutdown, rarTask }, cts.Token);\n             }\n-            catch (OperationCanceledException e)\n+            catch (OperationCanceledException)\n+            {\n+                return NodeEngineShutdownReason.BuildComplete;\n+            }\n+            catch (Exception e)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "If we crash, we should crash, so the Watson crash-reporting system sees it and routes the results back to us to follow up on. Check out #5544 for the newest way to do this at the top level.",
              "createdAt": "2020-09-22T17:17:51Z",
              "path": "src/Build/BackEnd/Node/RarNode.cs",
              "diffHunk": "@@ -60,7 +60,11 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except\n                 // - node lifetime expires\n                 index = Task.WaitAny(new Task[] { msBuildShutdown, rarTask }, cts.Token);\n             }\n-            catch (OperationCanceledException e)\n+            catch (OperationCanceledException)\n+            {\n+                return NodeEngineShutdownReason.BuildComplete;\n+            }\n+            catch (Exception e)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Removed handling of unexpected exceptions. Will leave to top level handler.",
              "createdAt": "2020-09-23T17:24:39Z",
              "path": "src/Build/BackEnd/Node/RarNode.cs",
              "diffHunk": "@@ -60,7 +60,11 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except\n                 // - node lifetime expires\n                 index = Task.WaitAny(new Task[] { msBuildShutdown, rarTask }, cts.Token);\n             }\n-            catch (OperationCanceledException e)\n+            catch (OperationCanceledException)\n+            {\n+                return NodeEngineShutdownReason.BuildComplete;\n+            }\n+            catch (Exception e)",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you think it would make sense here to include the request/response?",
              "createdAt": "2020-09-18T21:17:10Z",
              "path": "src/Framework/MSBuildEventSource.cs",
              "diffHunk": "@@ -423,6 +423,18 @@ public void ResolveAssemblyReferenceNodeConnectStop()\n         {\n             WriteEvent(57);\n         }\n+\n+        [Event(58)]\n+        internal void ResolveAssemblyReferenceServiceRequestStart()",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Not sure what you mean. Include content of the request?",
              "createdAt": "2020-09-21T16:26:28Z",
              "path": "src/Framework/MSBuildEventSource.cs",
              "diffHunk": "@@ -423,6 +423,18 @@ public void ResolveAssemblyReferenceNodeConnectStop()\n         {\n             WriteEvent(57);\n         }\n+\n+        [Event(58)]\n+        internal void ResolveAssemblyReferenceServiceRequestStart()",
              "author": {
                "login": "ostorc"
              }
            },
            {
              "body": "If I remember correctly, ETW events can take an arbitrary object as a parameter, and then it would show up (stringified? not sure) in the trace when you look at it later. It might be helpful if something goes wrong, and we want to see whether the inputs were wrong, RAR did something wrong, or the outputs were used incorrectly afterwards. It does make it slower and larger, though, so it might not be justified.",
              "createdAt": "2020-09-21T16:54:36Z",
              "path": "src/Framework/MSBuildEventSource.cs",
              "diffHunk": "@@ -423,6 +423,18 @@ public void ResolveAssemblyReferenceNodeConnectStop()\n         {\n             WriteEvent(57);\n         }\n+\n+        [Event(58)]\n+        internal void ResolveAssemblyReferenceServiceRequestStart()",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That would be a _lot_ larger. I don't think it's a good idea.",
              "createdAt": "2020-09-22T16:50:35Z",
              "path": "src/Framework/MSBuildEventSource.cs",
              "diffHunk": "@@ -423,6 +423,18 @@ public void ResolveAssemblyReferenceNodeConnectStop()\n         {\n             WriteEvent(57);\n         }\n+\n+        [Event(58)]\n+        internal void ResolveAssemblyReferenceServiceRequestStart()",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is about as opaque as it gets. Since you call this exact line multiple times, maybe factor it out into a single factory?",
              "createdAt": "2020-09-18T21:21:53Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs",
              "diffHunk": "@@ -6775,7 +6775,7 @@ public void ReferenceTableDependentItemsInBlackList3()\n         [Fact]\n         public void ReferenceTableDependentItemsInBlackList4()\n         {\n-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null,\n+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "copyright header",
              "createdAt": "2020-09-18T21:22:20Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs",
              "diffHunk": "@@ -0,0 +1,160 @@\n+\ufeffusing MessagePack;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Most of the test files which I saw doesn't have it, but sure will add it.",
              "createdAt": "2020-09-21T16:28:51Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs",
              "diffHunk": "@@ -0,0 +1,160 @@\n+\ufeffusing MessagePack;",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nCan you put this with the other two Microsoft.Build.Tasks.ResolveAssemblyReferences?",
              "createdAt": "2020-09-18T21:25:28Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -15,11 +15,22 @@\n using Xunit;\n using Xunit.Abstractions;\n using Shouldly;\n+using Nerdbank.Streams;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;\n+using System.Threading.Tasks;\n+using System.Threading;\n+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this need to be fully qualified? What is it confused with?",
              "createdAt": "2020-09-18T21:26:25Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -2971,6 +2980,36 @@ public enum RARSimulationMode\n             LoadAndBuildProject = LoadProject | BuildProject\n         }\n \n+        private class RarHandler : IResolveAssemblyReferenceTaskHandler\n+        {\n+            public void Dispose()\n+            {\n+            }\n+\n+            public Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenceRequest input, CancellationToken cancellationToken = default)\n+            {\n+                return System.Threading.Tasks.Task.FromResult(Execute(input));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "With Task from Microsoft.Build.Utilities, fixed by adding using statement",
              "createdAt": "2020-09-21T16:41:09Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs",
              "diffHunk": "@@ -2971,6 +2980,36 @@ public enum RARSimulationMode\n             LoadAndBuildProject = LoadProject | BuildProject\n         }\n \n+        private class RarHandler : IResolveAssemblyReferenceTaskHandler\n+        {\n+            public void Dispose()\n+            {\n+            }\n+\n+            public Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenceRequest input, CancellationToken cancellationToken = default)\n+            {\n+                return System.Threading.Tasks.Task.FromResult(Execute(input));",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I kinda liked the previous comments better.",
              "createdAt": "2020-09-18T21:35:22Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs",
              "diffHunk": "@@ -15,10 +15,10 @@ internal class AssemblyFoldersResolver : Resolver\n         /// <summary>\n         /// Construct.\n         /// </summary>\n-        /// <param name=\"searchPathElement\">The corresponding element from the search path.</param>\n-        /// <param name=\"getAssemblyName\">Delegate that gets the assembly name.</param>\n-        /// <param name=\"fileExists\">Delegate that returns if the file exists.</param>\n-        /// <param name=\"getRuntimeVersion\">Delegate that returns the clr runtime version for the file.</param>\n+        /// <param name=\"searchPathElement\">The search path element.</param>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Sorry about this. I haven't merged it properly",
              "createdAt": "2020-09-21T17:09:43Z",
              "path": "src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs",
              "diffHunk": "@@ -15,10 +15,10 @@ internal class AssemblyFoldersResolver : Resolver\n         /// <summary>\n         /// Construct.\n         /// </summary>\n-        /// <param name=\"searchPathElement\">The corresponding element from the search path.</param>\n-        /// <param name=\"getAssemblyName\">Delegate that gets the assembly name.</param>\n-        /// <param name=\"fileExists\">Delegate that returns if the file exists.</param>\n-        /// <param name=\"getRuntimeVersion\">Delegate that returns the clr runtime version for the file.</param>\n+        /// <param name=\"searchPathElement\">The search path element.</param>",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "That's a lot of lines and easy to get wrong. Can we match them individually or have something that automatically loops through the parameters?",
              "createdAt": "2020-09-18T21:41:09Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -920,6 +921,133 @@ public String DependsOnNETStandard\n             private set;\n         }\n \n+        internal ResolveAssemblyReferenceRequest ResolveAssemblyReferenceInput",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I have added test to cover this. We have test which check that all public properties are in `ResolveAssemblyReferenceRequest` and with this new one, we should be fine, ",
              "createdAt": "2020-09-21T16:55:08Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -920,6 +921,133 @@ public String DependsOnNETStandard\n             private set;\n         }\n \n+        internal ResolveAssemblyReferenceRequest ResolveAssemblyReferenceInput",
              "author": {
                "login": "ostorc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            GetRootedPath getRootedPath = FileUtilities.NormalizePath\r\n        )\r\n        {\r\n```\r\n?",
              "createdAt": "2020-09-18T21:41:59Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1952,9 +2082,13 @@ internal bool Execute\n #endif\n             GetAssemblyPathInGac getAssemblyPathInGac,\n             IsWinMDFile isWinMDFile,\n-            ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader\n+            ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader,\n+            GetRootedPath getRootedPath = null\n         )\n         {\n+            // Make this default option\n+            getRootedPath ??= FileUtilities.NormalizePath;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Not sure, what you mean by this. getRootedPath can be passed as an argument.",
              "createdAt": "2020-09-21T16:56:22Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1952,9 +2082,13 @@ internal bool Execute\n #endif\n             GetAssemblyPathInGac getAssemblyPathInGac,\n             IsWinMDFile isWinMDFile,\n-            ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader\n+            ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader,\n+            GetRootedPath getRootedPath = null\n         )\n         {\n+            // Make this default option\n+            getRootedPath ??= FileUtilities.NormalizePath;",
              "author": {
                "login": "ostorc"
              }
            },
            {
              "body": "Right, so if they provide something, it takes that. Otherwise, you default to null then immediately change that to FileUtilities.NormalizePath, whereas I was suggesting you could default to FileUtilities.NormalizePath and skip the null.",
              "createdAt": "2020-09-21T17:00:09Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1952,9 +2082,13 @@ internal bool Execute\n #endif\n             GetAssemblyPathInGac getAssemblyPathInGac,\n             IsWinMDFile isWinMDFile,\n-            ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader\n+            ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader,\n+            GetRootedPath getRootedPath = null\n         )\n         {\n+            // Make this default option\n+            getRootedPath ??= FileUtilities.NormalizePath;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Oh I have overlooked that in diff. Still I can't use this, since `FileUtilities.NormalizePath` is not compile time constant",
              "createdAt": "2020-09-21T17:22:17Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1952,9 +2082,13 @@ internal bool Execute\n #endif\n             GetAssemblyPathInGac getAssemblyPathInGac,\n             IsWinMDFile isWinMDFile,\n-            ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader\n+            ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader,\n+            GetRootedPath getRootedPath = null\n         )\n         {\n+            // Make this default option\n+            getRootedPath ??= FileUtilities.NormalizePath;",
              "author": {
                "login": "ostorc"
              }
            },
            {
              "body": "Good point",
              "createdAt": "2020-09-21T17:57:21Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1952,9 +2082,13 @@ internal bool Execute\n #endif\n             GetAssemblyPathInGac getAssemblyPathInGac,\n             IsWinMDFile isWinMDFile,\n-            ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader\n+            ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader,\n+            GetRootedPath getRootedPath = null\n         )\n         {\n+            // Make this default option\n+            getRootedPath ??= FileUtilities.NormalizePath;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-09-18T21:42:35Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3018,7 +3153,16 @@ public override bool Execute()\n                 if (connected)\n                 {\n                     // Client is connected to the RAR node, we can execute RAR task remotely\n-                    // return client.Execute(); // TODO: Let it do something.\n+                    MSBuildEventSource.Log.ResolveAssemblyReferenceServiceRequestStart();\n+                    ResolveAssemblyReferenceResult result = client.Execute(ResolveAssemblyReferenceInput);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                path => FileUtilities.NormalizePath(Path.IsPathRooted(path) ? string.Empty : input.CurrentPath, path)\r\n```",
              "createdAt": "2020-09-18T22:03:34Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3044,6 +3188,82 @@ public override bool Execute()\n             );\n         }\n \n+        private void LogEvents(IEnumerable<BuildEventArgs> buildEventArgs)\n+        {\n+            if (buildEventArgs == null)\n+            {\n+                return;\n+            }\n+\n+            foreach (LazyFormattedBuildEventArgs buildEvent in buildEventArgs)\n+            {\n+                switch (buildEvent)\n+                {\n+                    case CustomBuildEventArgs customBuildEvent:\n+                        BuildEngine.LogCustomEvent(customBuildEvent);\n+                        break;\n+                    case BuildErrorEventArgs buildErrorEvent:\n+                        BuildEngine.LogErrorEvent(buildErrorEvent);\n+                        break;\n+                    case BuildMessageEventArgs buildMessageEvent:\n+                        BuildEngine.LogMessageEvent(buildMessageEvent);\n+                        break;\n+                    case BuildWarningEventArgs buildWarningEvent:\n+                        BuildEngine.LogWarningEvent(buildWarningEvent);\n+                        break;\n+                    default:\n+                        ErrorUtilities.ThrowInternalError(\"Unexpected build event\"); \n+                        break;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Execute task. This method is intended to be used from a RAR as a Service node.\n+        /// </summary>\n+        /// <param name=\"input\">Required input to the task</param>\n+        /// <returns>If task was executed successfully</returns>\n+        internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceRequest input)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentNull(input, nameof(input));\n+\n+            // Prepare environment\n+            ResolveAssemblyReferenceInput = input;\n+            // Since this method should be run from RAR node, we prevent it from creating loop.\n+            UseResolveAssemblyReferenceService = false;\n+\n+            bool result = Execute\n+            (\n+                new FileExists(p => FileUtilities.FileExistsNoThrow(p)),\n+                new DirectoryExists(p => FileUtilities.DirectoryExistsNoThrow(p)),\n+                new GetDirectories(Directory.GetDirectories),\n+                new GetAssemblyName(AssemblyNameExtension.GetAssemblyNameEx),\n+                new GetAssemblyMetadata(AssemblyInformation.GetAssemblyMetadata),\n+#if FEATURE_WIN32_REGISTRY\n+                new GetRegistrySubKeyNames(RegistryHelper.GetSubKeyNames),\n+                new GetRegistrySubKeyDefaultValue(RegistryHelper.GetDefaultValue),\n+#endif\n+                new GetLastWriteTime(NativeMethodsShared.GetLastWriteFileUtcTime),\n+                new GetAssemblyRuntimeVersion(AssemblyInformation.GetRuntimeVersion),\n+#if FEATURE_WIN32_REGISTRY\n+                new OpenBaseKey(RegistryHelper.OpenBaseKey),\n+#endif\n+                new GetAssemblyPathInGac(GetAssemblyPathInGac),\n+                new IsWinMDFile(AssemblyInformation.IsWinMDFile),\n+                new ReadMachineTypeFromPEHeader(ReferenceTable.ReadMachineTypeFromPEHeader),\n+                (path) =>\n+                {\n+                    if (Path.IsPathRooted(path))\n+                    {\n+                        return FileUtilities.NormalizePath(path);\n+                    }\n+\n+                    return FileUtilities.NormalizePath(input.CurrentPath, path);\n+                }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}