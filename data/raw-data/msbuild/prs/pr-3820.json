{
  "number": 3820,
  "title": "Static Graph: Add the ability to hook ProjectInstance creation to allow creation of Projects first",
  "body": "Note name change from Project to ProjectInstance for previously existing public API. Can restore old name Project and make new addition something like 'UnevaluatedProject' if downstream consumers might be affected.\r\n",
  "state": "MERGED",
  "createdAt": "2018-10-03T17:07:33Z",
  "updatedAt": "2021-10-12T00:01:19Z",
  "closedAt": "2018-10-23T21:33:52Z",
  "mergedAt": "2018-10-23T21:33:52Z",
  "additions": 285,
  "deletions": 41,
  "changedFiles": 19,
  "headRefName": "dev/erikma/ProjectInGraph",
  "isDraft": false,
  "author": {
    "login": "erikmav"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Static Graph"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "c3f8ea536a48a260f33be075d75a2f12e90ccb32",
          "message": "Static Graph: Add the ability for a caller to create Projects as well as ProjectInstances\nUse a factory method callback that allows hooking ProjectInstance creation for external build engines.",
          "committedDate": "2018-10-23T20:48:37Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a4f565c9d5b885c2c78c447d2b1ff2112f65a497",
          "message": "Minor spelling/grammar fix",
          "committedDate": "2018-10-23T20:48:37Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eb94a57b83893b072a9885a5a588078102aad6f1",
          "message": "Fix malformed StrBegin in resx files.",
          "committedDate": "2018-10-23T20:48:37Z",
          "author": {
            "name": "Erik Mavrinac",
            "email": "erikmav@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@dotnet-bot test msbuild-pr\r\n",
        "createdAt": "2018-10-03T22:56:52Z",
        "author": {
          "login": "erikmav"
        }
      },
      {
        "body": "@erikma any idea why it's pulling in some extra commits?",
        "createdAt": "2018-10-04T20:44:38Z",
        "author": {
          "login": "AndyGerlicher"
        }
      },
      {
        "body": "I think he rebased on mater instead of exp/net472 :)",
        "createdAt": "2018-10-04T20:46:42Z",
        "author": {
          "login": "dfederm"
        }
      },
      {
        "body": "Yeah, looks like it was based on master then re-rebased back to net472. We must do some history manipulation before merge.",
        "createdAt": "2018-10-04T20:56:29Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Couldn't figure out a good way to rebase, so reverted the 2 master commits that made their way into history. And yes it was a mistaken rebase onto master before net472.",
        "createdAt": "2018-10-04T21:19:57Z",
        "author": {
          "login": "erikmav"
        }
      },
      {
        "body": "Having to expose this level of flags is making the API here pretty complicated. I think I'd rather switch the graph API back to `Project` (unconditionally), exposing `DefaultTargets` there (which was why it got switched over). If in the future we hit memory-related problems that are best solved by keeping a graph of `ProjectInstance` we can do something then.",
        "createdAt": "2018-10-04T21:43:03Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Hmm. Downstream consumers need ProjectInstance anyway because of EvaluateCondition. EvalCond needs more work as well even on ProjInstance - in my backlog - since BuildPrediction is jumping hoops trying to duplicate work that MSBuild can do already but was never exposed publicly.\r\n\r\nThis API surface is as complicated as the MSBuild publi  API itself... as soon as you get into the choice of whether to expose Project (per the original one-pager which I had used for BuildPrediction initially) or ProjInstance, you end up in a conundrum, since both are really needed, conditionally.\r\n\r\nIn this PR I backed out pure 'conditionally' since there is no way to not specify ProjInstance, as ProjInstance stuff is needed in the graph API generation logic. I could re-surface that work, it's in this branch's history, but it looked difficult to get all the info needed to make just Project work either.\r\n\r\nWhat I'm saying is that MSBuild has a duality here, and we have to embrace it, for good or ill.\r\n\r\n2. \r\n",
        "createdAt": "2018-10-04T22:40:36Z",
        "author": {
          "login": "erikmav"
        }
      },
      {
        "body": "@rainersigwald Should I abandon this PR? Is a change going into master to change to Project as noted above?",
        "createdAt": "2018-10-08T23:39:54Z",
        "author": {
          "login": "erikmav"
        }
      },
      {
        "body": "Ugh, rebased master again instead of net472. New push pending to rebase properly and remove master commits from history",
        "createdAt": "2018-10-17T00:06:05Z",
        "author": {
          "login": "erikmav"
        }
      },
      {
        "body": "@rainersigwald Removed most comment spelling and grammar fixes and R# stuff. Shall I issue a new PR off of net472 to clear the history, or is this sufficient?",
        "createdAt": "2018-10-23T19:33:51Z",
        "author": {
          "login": "erikmav"
        }
      },
      {
        "body": "No need to do a new PR that won't help. Just need to rebase correctly so we can merge the PR (not squash).",
        "createdAt": "2018-10-23T19:37:04Z",
        "author": {
          "login": "AndyGerlicher"
        }
      },
      {
        "body": "Adjusted history to create an API update commit",
        "createdAt": "2018-10-23T20:07:30Z",
        "author": {
          "login": "erikmav"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "We probably want this as a Flags I'd guess? Maybe something like...\r\n```\r\n[Flags]\r\npublic enum ProjectGraphCreationSettings\r\n{\r\n  None = 0,\r\n  CreateProjectInstance = 1,\r\n  CreateProject = 2,\r\n}\r\n```",
              "createdAt": "2018-10-03T17:16:35Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -73,6 +73,27 @@ public ProjectGraph(string entryProjectFile)\n             string entryProjectFile,\n             IDictionary<string, string> globalProperties,\n             ProjectCollection projectCollection)\n+            : this(entryProjectFile, globalProperties, projectCollection, false)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Constructs a graph starting from the given project file, evaluating with the provided global properties and the provided project collection.\n+        /// </summary>\n+        /// <param name=\"entryProjectFile\">The project file to use as the entry point in constructing the graph</param>\n+        /// <param name=\"globalProperties\">The global properties to use for all projects. May be null, in which case the containing project collection's global properties will be used.</param>\n+        /// <param name=\"projectCollection\">The collection with which all projects in the graph should be associated. May not be null.</param>\n+        /// <param name=\"exposeProjects\">\n+        /// When false, only <see cref=\"Microsoft.Build.Execution.ProjectInstance\"/> instances are exposed\n+        /// from the graph. When true, the more memory and time expensive full <see cref=\"Microsoft.Build.Evaluation.Project\"/>s\n+        /// are also produced. Typically Projects are not needed for execution of a graph.\n+        /// </param>\n+        /// <exception cref=\"InvalidProjectFileException\">If the evaluation of any project in the graph fails.</exception>\n+        public ProjectGraph(\n+            string entryProjectFile,\n+            IDictionary<string, string> globalProperties,\n+            ProjectCollection projectCollection,\n+            bool exposeProjects)",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "- `None` would just throw I think.\r\n- `CreateProjectInstance` would be required if you actually wanted to build anything (maybe `GetTargetList` throws if this isn't set?)\r\n- `CreateProject` is just for exposing the `Project`. Not used internally I guess.\r\n- `CreateProjectInstance | CreateProject` is the most expensive thing you could do.\r\n\r\nMaybe a boolean is simpler though since `None` is unusable and `CreateProject` by itself maybe doesn't make a ton of sense. A boolean is less extensible though and easier to be confusing, especially because people don't tend to use it with a named param and just provide `true` as one of the params which loses all context on its own.",
              "createdAt": "2018-10-03T17:21:40Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -73,6 +73,27 @@ public ProjectGraph(string entryProjectFile)\n             string entryProjectFile,\n             IDictionary<string, string> globalProperties,\n             ProjectCollection projectCollection)\n+            : this(entryProjectFile, globalProperties, projectCollection, false)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Constructs a graph starting from the given project file, evaluating with the provided global properties and the provided project collection.\n+        /// </summary>\n+        /// <param name=\"entryProjectFile\">The project file to use as the entry point in constructing the graph</param>\n+        /// <param name=\"globalProperties\">The global properties to use for all projects. May be null, in which case the containing project collection's global properties will be used.</param>\n+        /// <param name=\"projectCollection\">The collection with which all projects in the graph should be associated. May not be null.</param>\n+        /// <param name=\"exposeProjects\">\n+        /// When false, only <see cref=\"Microsoft.Build.Execution.ProjectInstance\"/> instances are exposed\n+        /// from the graph. When true, the more memory and time expensive full <see cref=\"Microsoft.Build.Evaluation.Project\"/>s\n+        /// are also produced. Typically Projects are not needed for execution of a graph.\n+        /// </param>\n+        /// <exception cref=\"InvalidProjectFileException\">If the evaluation of any project in the graph fails.</exception>\n+        public ProjectGraph(\n+            string entryProjectFile,\n+            IDictionary<string, string> globalProperties,\n+            ProjectCollection projectCollection,\n+            bool exposeProjects)",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Given comment below seems like I'll need a flag related to ImmutableWithFastItemLookup anyway.",
              "createdAt": "2018-10-03T18:49:05Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -73,6 +73,27 @@ public ProjectGraph(string entryProjectFile)\n             string entryProjectFile,\n             IDictionary<string, string> globalProperties,\n             ProjectCollection projectCollection)\n+            : this(entryProjectFile, globalProperties, projectCollection, false)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Constructs a graph starting from the given project file, evaluating with the provided global properties and the provided project collection.\n+        /// </summary>\n+        /// <param name=\"entryProjectFile\">The project file to use as the entry point in constructing the graph</param>\n+        /// <param name=\"globalProperties\">The global properties to use for all projects. May be null, in which case the containing project collection's global properties will be used.</param>\n+        /// <param name=\"projectCollection\">The collection with which all projects in the graph should be associated. May not be null.</param>\n+        /// <param name=\"exposeProjects\">\n+        /// When false, only <see cref=\"Microsoft.Build.Execution.ProjectInstance\"/> instances are exposed\n+        /// from the graph. When true, the more memory and time expensive full <see cref=\"Microsoft.Build.Evaluation.Project\"/>s\n+        /// are also produced. Typically Projects are not needed for execution of a graph.\n+        /// </param>\n+        /// <exception cref=\"InvalidProjectFileException\">If the evaluation of any project in the graph fails.</exception>\n+        public ProjectGraph(\n+            string entryProjectFile,\n+            IDictionary<string, string> globalProperties,\n+            ProjectCollection projectCollection,\n+            bool exposeProjects)",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "I don't like the useless surface area exposed by None. How about the default zero value be CreateProjectInstance, with the other flags as additional info? I'll send that in the next push.",
              "createdAt": "2018-10-03T18:50:12Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -73,6 +73,27 @@ public ProjectGraph(string entryProjectFile)\n             string entryProjectFile,\n             IDictionary<string, string> globalProperties,\n             ProjectCollection projectCollection)\n+            : this(entryProjectFile, globalProperties, projectCollection, false)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Constructs a graph starting from the given project file, evaluating with the provided global properties and the provided project collection.\n+        /// </summary>\n+        /// <param name=\"entryProjectFile\">The project file to use as the entry point in constructing the graph</param>\n+        /// <param name=\"globalProperties\">The global properties to use for all projects. May be null, in which case the containing project collection's global properties will be used.</param>\n+        /// <param name=\"projectCollection\">The collection with which all projects in the graph should be associated. May not be null.</param>\n+        /// <param name=\"exposeProjects\">\n+        /// When false, only <see cref=\"Microsoft.Build.Execution.ProjectInstance\"/> instances are exposed\n+        /// from the graph. When true, the more memory and time expensive full <see cref=\"Microsoft.Build.Evaluation.Project\"/>s\n+        /// are also produced. Typically Projects are not needed for execution of a graph.\n+        /// </param>\n+        /// <exception cref=\"InvalidProjectFileException\">If the evaluation of any project in the graph fails.</exception>\n+        public ProjectGraph(\n+            string entryProjectFile,\n+            IDictionary<string, string> globalProperties,\n+            ProjectCollection projectCollection,\n+            bool exposeProjects)",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "That's more of an Enum than a Flags then. Flags should always have a \"None\" (and sometimes an \"All\"). With enums though you'd need distinct, mutually exclusive values.",
              "createdAt": "2018-10-03T18:55:33Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -73,6 +73,27 @@ public ProjectGraph(string entryProjectFile)\n             string entryProjectFile,\n             IDictionary<string, string> globalProperties,\n             ProjectCollection projectCollection)\n+            : this(entryProjectFile, globalProperties, projectCollection, false)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Constructs a graph starting from the given project file, evaluating with the provided global properties and the provided project collection.\n+        /// </summary>\n+        /// <param name=\"entryProjectFile\">The project file to use as the entry point in constructing the graph</param>\n+        /// <param name=\"globalProperties\">The global properties to use for all projects. May be null, in which case the containing project collection's global properties will be used.</param>\n+        /// <param name=\"projectCollection\">The collection with which all projects in the graph should be associated. May not be null.</param>\n+        /// <param name=\"exposeProjects\">\n+        /// When false, only <see cref=\"Microsoft.Build.Execution.ProjectInstance\"/> instances are exposed\n+        /// from the graph. When true, the more memory and time expensive full <see cref=\"Microsoft.Build.Evaluation.Project\"/>s\n+        /// are also produced. Typically Projects are not needed for execution of a graph.\n+        /// </param>\n+        /// <exception cref=\"InvalidProjectFileException\">If the evaluation of any project in the graph fails.</exception>\n+        public ProjectGraph(\n+            string entryProjectFile,\n+            IDictionary<string, string> globalProperties,\n+            ProjectCollection projectCollection,\n+            bool exposeProjects)",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Iterated twice on the flags. Having ProjInstance as a separate option makes no sense, as when I did that and wrote UTs to test it the basic graph generation blew up on its need for ProjectInstance. Then pulled out the PI options and changed None to Default with comments about what defaults are.",
              "createdAt": "2018-10-03T21:06:19Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -73,6 +73,27 @@ public ProjectGraph(string entryProjectFile)\n             string entryProjectFile,\n             IDictionary<string, string> globalProperties,\n             ProjectCollection projectCollection)\n+            : this(entryProjectFile, globalProperties, projectCollection, false)\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Constructs a graph starting from the given project file, evaluating with the provided global properties and the provided project collection.\n+        /// </summary>\n+        /// <param name=\"entryProjectFile\">The project file to use as the entry point in constructing the graph</param>\n+        /// <param name=\"globalProperties\">The global properties to use for all projects. May be null, in which case the containing project collection's global properties will be used.</param>\n+        /// <param name=\"projectCollection\">The collection with which all projects in the graph should be associated. May not be null.</param>\n+        /// <param name=\"exposeProjects\">\n+        /// When false, only <see cref=\"Microsoft.Build.Execution.ProjectInstance\"/> instances are exposed\n+        /// from the graph. When true, the more memory and time expensive full <see cref=\"Microsoft.Build.Evaluation.Project\"/>s\n+        /// are also produced. Typically Projects are not needed for execution of a graph.\n+        /// </param>\n+        /// <exception cref=\"InvalidProjectFileException\">If the evaluation of any project in the graph fails.</exception>\n+        public ProjectGraph(\n+            string entryProjectFile,\n+            IDictionary<string, string> globalProperties,\n+            ProjectCollection projectCollection,\n+            bool exposeProjects)",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This part will conflict badly with #3810; let's let that get in first.",
              "createdAt": "2018-10-03T17:17:05Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);\n+            }\n+            else\n+            {\n+                projectInstance = new ProjectInstance(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+            }\n+\n             var graphNode = new ProjectGraphNode(\n                 project,\n+                projectInstance,\n                 globalProperties);\n             _allParsedProjects.Add(configurationMetadata, graphNode);\n             return graphNode;\n         }\n \n         /// <summary>\n-        /// Load a graph with root node at entryProjectFile\n-        /// Maintain a queue of projects to be processed- each queue item is a key value pair of the project to be evaluated and its parent\n-        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node\n+        /// Load a graph with root node at entryProjectFile.\n+        /// Maintain a queue of projects to be processed - each queue item is a key value pair of the project to be evaluated and its parent.\n+        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node.\n         /// </summary>\n-        private void LoadGraph(string entryProjectFile, ProjectCollection projectCollection, PropertyDictionary<ProjectPropertyInstance> globalProperties)\n+        private void LoadGraph(",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "#3823 covers the rename by itself",
              "createdAt": "2018-10-03T19:18:41Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);\n+            }\n+            else\n+            {\n+                projectInstance = new ProjectInstance(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+            }\n+\n             var graphNode = new ProjectGraphNode(\n                 project,\n+                projectInstance,\n                 globalProperties);\n             _allParsedProjects.Add(configurationMetadata, graphNode);\n             return graphNode;\n         }\n \n         /// <summary>\n-        /// Load a graph with root node at entryProjectFile\n-        /// Maintain a queue of projects to be processed- each queue item is a key value pair of the project to be evaluated and its parent\n-        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node\n+        /// Load a graph with root node at entryProjectFile.\n+        /// Maintain a queue of projects to be processed - each queue item is a key value pair of the project to be evaluated and its parent.\n+        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node.\n         /// </summary>\n-        private void LoadGraph(string entryProjectFile, ProjectCollection projectCollection, PropertyDictionary<ProjectPropertyInstance> globalProperties)\n+        private void LoadGraph(",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "It doesn't need to be a separate PR, just a separate commit in this one.",
              "createdAt": "2018-10-03T19:22:01Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);\n+            }\n+            else\n+            {\n+                projectInstance = new ProjectInstance(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+            }\n+\n             var graphNode = new ProjectGraphNode(\n                 project,\n+                projectInstance,\n                 globalProperties);\n             _allParsedProjects.Add(configurationMetadata, graphNode);\n             return graphNode;\n         }\n \n         /// <summary>\n-        /// Load a graph with root node at entryProjectFile\n-        /// Maintain a queue of projects to be processed- each queue item is a key value pair of the project to be evaluated and its parent\n-        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node\n+        /// Load a graph with root node at entryProjectFile.\n+        /// Maintain a queue of projects to be processed - each queue item is a key value pair of the project to be evaluated and its parent.\n+        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node.\n         /// </summary>\n-        private void LoadGraph(string entryProjectFile, ProjectCollection projectCollection, PropertyDictionary<ProjectPropertyInstance> globalProperties)\n+        private void LoadGraph(",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Hard to separate out now... the rename was automated but in the midst of other edits.",
              "createdAt": "2018-10-03T20:06:21Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);\n+            }\n+            else\n+            {\n+                projectInstance = new ProjectInstance(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+            }\n+\n             var graphNode = new ProjectGraphNode(\n                 project,\n+                projectInstance,\n                 globalProperties);\n             _allParsedProjects.Add(configurationMetadata, graphNode);\n             return graphNode;\n         }\n \n         /// <summary>\n-        /// Load a graph with root node at entryProjectFile\n-        /// Maintain a queue of projects to be processed- each queue item is a key value pair of the project to be evaluated and its parent\n-        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node\n+        /// Load a graph with root node at entryProjectFile.\n+        /// Maintain a queue of projects to be processed - each queue item is a key value pair of the project to be evaluated and its parent.\n+        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node.\n         /// </summary>\n-        private void LoadGraph(string entryProjectFile, ProjectCollection projectCollection, PropertyDictionary<ProjectPropertyInstance> globalProperties)\n+        private void LoadGraph(",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "Rebased in current push as the topmost change",
              "createdAt": "2018-10-03T21:04:46Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);\n+            }\n+            else\n+            {\n+                projectInstance = new ProjectInstance(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+            }\n+\n             var graphNode = new ProjectGraphNode(\n                 project,\n+                projectInstance,\n                 globalProperties);\n             _allParsedProjects.Add(configurationMetadata, graphNode);\n             return graphNode;\n         }\n \n         /// <summary>\n-        /// Load a graph with root node at entryProjectFile\n-        /// Maintain a queue of projects to be processed- each queue item is a key value pair of the project to be evaluated and its parent\n-        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node\n+        /// Load a graph with root node at entryProjectFile.\n+        /// Maintain a queue of projects to be processed - each queue item is a key value pair of the project to be evaluated and its parent.\n+        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node.\n         /// </summary>\n-        private void LoadGraph(string entryProjectFile, ProjectCollection projectCollection, PropertyDictionary<ProjectPropertyInstance> globalProperties)\n+        private void LoadGraph(",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "Rebased to #3810 in next push",
              "createdAt": "2018-10-03T21:30:00Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);\n+            }\n+            else\n+            {\n+                projectInstance = new ProjectInstance(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+            }\n+\n             var graphNode = new ProjectGraphNode(\n                 project,\n+                projectInstance,\n                 globalProperties);\n             _allParsedProjects.Add(configurationMetadata, graphNode);\n             return graphNode;\n         }\n \n         /// <summary>\n-        /// Load a graph with root node at entryProjectFile\n-        /// Maintain a queue of projects to be processed- each queue item is a key value pair of the project to be evaluated and its parent\n-        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node\n+        /// Load a graph with root node at entryProjectFile.\n+        /// Maintain a queue of projects to be processed - each queue item is a key value pair of the project to be evaluated and its parent.\n+        /// Once the project has been evaluated, add a project reference to this evaluated target from the parent node.\n         /// </summary>\n-        private void LoadGraph(string entryProjectFile, ProjectCollection projectCollection, PropertyDictionary<ProjectPropertyInstance> globalProperties)\n+        private void LoadGraph(",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Separate commit for this cleanup please.",
              "createdAt": "2018-10-03T17:20:37Z",
              "path": "src/Build/Instance/ProjectInstance.cs",
              "diffHunk": "@@ -239,8 +238,8 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro\n         /// <returns>A new project instance</returns>\n         public ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)\n         {\n-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, \"projectFile\");\n-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, \"toolsVersion\");\n+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));\n+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not super sure what `ImmutableWithFastItemLookup` does, but it seems like either we should use it in both cases, or we shouldn't use it at all (if it breaks the ability to actually build the project). MSBuild.exe doesn't use this so I suspect it breaks something.",
              "createdAt": "2018-10-03T17:27:38Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "This setting is used in the internal build engine when flattening the Project to a ProjectInstance, for performance reasons. It has two effects in ProjectInstance.cs:\r\n\r\n            var keepEvaluationCache = (settings & ProjectInstanceSettings.ImmutableWithFastItemLookup) == ProjectInstanceSettings.ImmutableWithFastItemLookup;\r\n\r\nThat flag leads to CreateEvaluatedIncludeSnapshotIfRequested() setting _itemsByEvaluatedInclude, which speeds up lookups in GetItemsByItemTypeAndEvaluatedInclude().\r\n\r\nI'd prefer to stick with what is known to work in the internal build engine, but wouldn't mind having this as an additional flag in the proposed option flags noted above.\r\n",
              "createdAt": "2018-10-03T18:45:11Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "My fear is if the flag basically makes it \"parse-only, no target execution\", which would be pretty broken in the general case.\r\n\r\nThe evaluation cache is probably (?) ok. The immutable thing is what I'm mostly afraid of. For example, it seems to imply to me that any property or item being set during target execution would just fail.\r\n\r\nSomeone more familiar with this setting might need to jump in and explain the details of how it effects target execution.",
              "createdAt": "2018-10-03T18:49:27Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "It'd be the normal case by default and opt-in to this behavior with a flag, which would be used in the internal build engine pretty much exclusively AFAICT.",
              "createdAt": "2018-10-03T19:04:25Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "I guess I'm still not following. Keep in mind, this is MSBuild, which is used in other cases than just QuickBuild. This project graph stuff is something that we want QuickBuild to consume, but we're not building it only for QuickBuild. Specifically, if this flag makes it so that you can't have a `Project` and be able to execute targets on it, the VS would not be able to use this API.",
              "createdAt": "2018-10-03T19:24:29Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "If this *were* something we were building specifically for QuickBuild, it would not be in the MSBuild repo.",
              "createdAt": "2018-10-03T19:49:33Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "It is in the public MSBuild API but IIRC was prompted by performance needs of QuickBuild.",
              "createdAt": "2018-10-03T20:09:22Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -203,31 +224,54 @@ public ProjectGraph(string entryProjectFile)\n \n         private ProjectGraphNode CreateNewNode(\n             ConfigurationMetadata configurationMetadata,\n-            ProjectCollection projectCollection)\n+            ProjectCollection projectCollection,\n+            bool exposeProject)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-            var project = new ProjectInstance(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                configurationMetadata.ToolsVersion,\n-                projectCollection);\n+\n+            Project project = null;\n+            ProjectInstance projectInstance;\n+            if (exposeProject)\n+            {\n+                project = new Project(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    configurationMetadata.ToolsVersion,\n+                    projectCollection);\n+                projectInstance = project.CreateProjectInstance(ProjectInstanceSettings.ImmutableWithFastItemLookup);",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`Project` also has evaluated stuff on it though.",
              "createdAt": "2018-10-03T17:28:49Z",
              "path": "src/Build/Graph/ProjectGraphNode.cs",
              "diffHunk": "@@ -27,10 +30,24 @@ public sealed class ProjectGraphNode\n         /// </summary>\n         public IReadOnlyCollection<ProjectGraphNode> ProjectReferences => _projectReferences;\n \n+        /// <summary>\n+        /// Gets a pre-evaluation project represented by this node in the graph.",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: Should this be public? In case callers want to do some stuff but still call the default factory.",
              "createdAt": "2018-10-18T20:19:27Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -303,17 +334,63 @@ public ProjectGraph(IEnumerable<ProjectGraphEntryPoint> entryPoints, ProjectColl\n             return targetLists;\n         }\n \n+        /// <summary>\n+        /// A callback used for constructing a <see cref=\"ProjectInstance\"/> for a specific\n+        /// <see cref=\"ProjectGraphEntryPoint\"/> instance.\n+        /// </summary>\n+        /// <param name=\"projectPath\">The path to the project file to parse.</param>\n+        /// <param name=\"projectCollection\">The <see cref=\"ProjectCollection\"/> context for parsing.</param>\n+        /// <returns>A <see cref=\"ProjectInstance\"/> instance. This value must not be null.</returns>\n+        /// <remarks>\n+        /// The default version of this delegate used by ProjectGraph simply calls the\n+        /// ProjectInstance constructor with information from the parameters. This delegate\n+        /// is provided as a hook to allow scenarios like creating a <see cref=\"Project\"/>\n+        /// instance before converting it to a ProjectInstance for use by the ProjectGraph.\n+        ///\n+        /// The returned ProjectInstance will be stored and provided with the ProjectGraph.\n+        /// If this callback chooses to generate an immutable ProjectInstance, e.g. by\n+        /// using <see cref=\"Project.CreateProjectInstance()\"/> with the flag\n+        /// <see cref=\"ProjectInstanceSettings.Immutable\"/>, the resulting ProjectGraph\n+        /// nodes might not be buildable.\n+        /// </remarks>\n+        public delegate ProjectInstance ProjectInstanceFactoryFunc(\n+            string projectPath,\n+            Dictionary<string, string> globalProperties,\n+            string toolsVersion,\n+            ProjectCollection projectCollection);\n+\n+        internal static ProjectInstance DefaultProjectInstanceFactory(",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I would say no, nobody should need this.",
              "createdAt": "2018-10-18T21:06:14Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -303,17 +334,63 @@ public ProjectGraph(IEnumerable<ProjectGraphEntryPoint> entryPoints, ProjectColl\n             return targetLists;\n         }\n \n+        /// <summary>\n+        /// A callback used for constructing a <see cref=\"ProjectInstance\"/> for a specific\n+        /// <see cref=\"ProjectGraphEntryPoint\"/> instance.\n+        /// </summary>\n+        /// <param name=\"projectPath\">The path to the project file to parse.</param>\n+        /// <param name=\"projectCollection\">The <see cref=\"ProjectCollection\"/> context for parsing.</param>\n+        /// <returns>A <see cref=\"ProjectInstance\"/> instance. This value must not be null.</returns>\n+        /// <remarks>\n+        /// The default version of this delegate used by ProjectGraph simply calls the\n+        /// ProjectInstance constructor with information from the parameters. This delegate\n+        /// is provided as a hook to allow scenarios like creating a <see cref=\"Project\"/>\n+        /// instance before converting it to a ProjectInstance for use by the ProjectGraph.\n+        ///\n+        /// The returned ProjectInstance will be stored and provided with the ProjectGraph.\n+        /// If this callback chooses to generate an immutable ProjectInstance, e.g. by\n+        /// using <see cref=\"Project.CreateProjectInstance()\"/> with the flag\n+        /// <see cref=\"ProjectInstanceSettings.Immutable\"/>, the resulting ProjectGraph\n+        /// nodes might not be buildable.\n+        /// </remarks>\n+        public delegate ProjectInstance ProjectInstanceFactoryFunc(\n+            string projectPath,\n+            Dictionary<string, string> globalProperties,\n+            string toolsVersion,\n+            ProjectCollection projectCollection);\n+\n+        internal static ProjectInstance DefaultProjectInstanceFactory(",
              "author": {
                "login": "AndyGerlicher"
              }
            },
            {
              "body": "I think it might be useful as public too, but we can wait to see how true that is.",
              "createdAt": "2018-10-23T17:31:41Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -303,17 +334,63 @@ public ProjectGraph(IEnumerable<ProjectGraphEntryPoint> entryPoints, ProjectColl\n             return targetLists;\n         }\n \n+        /// <summary>\n+        /// A callback used for constructing a <see cref=\"ProjectInstance\"/> for a specific\n+        /// <see cref=\"ProjectGraphEntryPoint\"/> instance.\n+        /// </summary>\n+        /// <param name=\"projectPath\">The path to the project file to parse.</param>\n+        /// <param name=\"projectCollection\">The <see cref=\"ProjectCollection\"/> context for parsing.</param>\n+        /// <returns>A <see cref=\"ProjectInstance\"/> instance. This value must not be null.</returns>\n+        /// <remarks>\n+        /// The default version of this delegate used by ProjectGraph simply calls the\n+        /// ProjectInstance constructor with information from the parameters. This delegate\n+        /// is provided as a hook to allow scenarios like creating a <see cref=\"Project\"/>\n+        /// instance before converting it to a ProjectInstance for use by the ProjectGraph.\n+        ///\n+        /// The returned ProjectInstance will be stored and provided with the ProjectGraph.\n+        /// If this callback chooses to generate an immutable ProjectInstance, e.g. by\n+        /// using <see cref=\"Project.CreateProjectInstance()\"/> with the flag\n+        /// <see cref=\"ProjectInstanceSettings.Immutable\"/>, the resulting ProjectGraph\n+        /// nodes might not be buildable.\n+        /// </remarks>\n+        public delegate ProjectInstance ProjectInstanceFactoryFunc(\n+            string projectPath,\n+            Dictionary<string, string> globalProperties,\n+            string toolsVersion,\n+            ProjectCollection projectCollection);\n+\n+        internal static ProjectInstance DefaultProjectInstanceFactory(",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Tools version is going away, so we should not include it. It's not part of the public API at all for `ProjectGraph`",
              "createdAt": "2018-10-18T20:52:31Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -303,17 +334,63 @@ public ProjectGraph(IEnumerable<ProjectGraphEntryPoint> entryPoints, ProjectColl\n             return targetLists;\n         }\n \n+        /// <summary>\n+        /// A callback used for constructing a <see cref=\"ProjectInstance\"/> for a specific\n+        /// <see cref=\"ProjectGraphEntryPoint\"/> instance.\n+        /// </summary>\n+        /// <param name=\"projectPath\">The path to the project file to parse.</param>\n+        /// <param name=\"projectCollection\">The <see cref=\"ProjectCollection\"/> context for parsing.</param>\n+        /// <returns>A <see cref=\"ProjectInstance\"/> instance. This value must not be null.</returns>\n+        /// <remarks>\n+        /// The default version of this delegate used by ProjectGraph simply calls the\n+        /// ProjectInstance constructor with information from the parameters. This delegate\n+        /// is provided as a hook to allow scenarios like creating a <see cref=\"Project\"/>\n+        /// instance before converting it to a ProjectInstance for use by the ProjectGraph.\n+        ///\n+        /// The returned ProjectInstance will be stored and provided with the ProjectGraph.\n+        /// If this callback chooses to generate an immutable ProjectInstance, e.g. by\n+        /// using <see cref=\"Project.CreateProjectInstance()\"/> with the flag\n+        /// <see cref=\"ProjectInstanceSettings.Immutable\"/>, the resulting ProjectGraph\n+        /// nodes might not be buildable.\n+        /// </remarks>\n+        public delegate ProjectInstance ProjectInstanceFactoryFunc(\n+            string projectPath,\n+            Dictionary<string, string> globalProperties,\n+            string toolsVersion,",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Also is there a reason to define a delegate instead of using `Func<string, Dictionary<string, string>, ProjectInstance>`? It does seem kind of long.",
              "createdAt": "2018-10-18T21:11:49Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -303,17 +334,63 @@ public ProjectGraph(IEnumerable<ProjectGraphEntryPoint> entryPoints, ProjectColl\n             return targetLists;\n         }\n \n+        /// <summary>\n+        /// A callback used for constructing a <see cref=\"ProjectInstance\"/> for a specific\n+        /// <see cref=\"ProjectGraphEntryPoint\"/> instance.\n+        /// </summary>\n+        /// <param name=\"projectPath\">The path to the project file to parse.</param>\n+        /// <param name=\"projectCollection\">The <see cref=\"ProjectCollection\"/> context for parsing.</param>\n+        /// <returns>A <see cref=\"ProjectInstance\"/> instance. This value must not be null.</returns>\n+        /// <remarks>\n+        /// The default version of this delegate used by ProjectGraph simply calls the\n+        /// ProjectInstance constructor with information from the parameters. This delegate\n+        /// is provided as a hook to allow scenarios like creating a <see cref=\"Project\"/>\n+        /// instance before converting it to a ProjectInstance for use by the ProjectGraph.\n+        ///\n+        /// The returned ProjectInstance will be stored and provided with the ProjectGraph.\n+        /// If this callback chooses to generate an immutable ProjectInstance, e.g. by\n+        /// using <see cref=\"Project.CreateProjectInstance()\"/> with the flag\n+        /// <see cref=\"ProjectInstanceSettings.Immutable\"/>, the resulting ProjectGraph\n+        /// nodes might not be buildable.\n+        /// </remarks>\n+        public delegate ProjectInstance ProjectInstanceFactoryFunc(\n+            string projectPath,\n+            Dictionary<string, string> globalProperties,\n+            string toolsVersion,",
              "author": {
                "login": "AndyGerlicher"
              }
            },
            {
              "body": "@AndyGerlicher I started with Func<> but the param documentation got long, so moved to a delegate declaration to expand param definitions. I recommend staying with this format as squashing it back is pretty ugly.\r\n",
              "createdAt": "2018-10-18T23:14:15Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -303,17 +334,63 @@ public ProjectGraph(IEnumerable<ProjectGraphEntryPoint> entryPoints, ProjectColl\n             return targetLists;\n         }\n \n+        /// <summary>\n+        /// A callback used for constructing a <see cref=\"ProjectInstance\"/> for a specific\n+        /// <see cref=\"ProjectGraphEntryPoint\"/> instance.\n+        /// </summary>\n+        /// <param name=\"projectPath\">The path to the project file to parse.</param>\n+        /// <param name=\"projectCollection\">The <see cref=\"ProjectCollection\"/> context for parsing.</param>\n+        /// <returns>A <see cref=\"ProjectInstance\"/> instance. This value must not be null.</returns>\n+        /// <remarks>\n+        /// The default version of this delegate used by ProjectGraph simply calls the\n+        /// ProjectInstance constructor with information from the parameters. This delegate\n+        /// is provided as a hook to allow scenarios like creating a <see cref=\"Project\"/>\n+        /// instance before converting it to a ProjectInstance for use by the ProjectGraph.\n+        ///\n+        /// The returned ProjectInstance will be stored and provided with the ProjectGraph.\n+        /// If this callback chooses to generate an immutable ProjectInstance, e.g. by\n+        /// using <see cref=\"Project.CreateProjectInstance()\"/> with the flag\n+        /// <see cref=\"ProjectInstanceSettings.Immutable\"/>, the resulting ProjectGraph\n+        /// nodes might not be buildable.\n+        /// </remarks>\n+        public delegate ProjectInstance ProjectInstanceFactoryFunc(\n+            string projectPath,\n+            Dictionary<string, string> globalProperties,\n+            string toolsVersion,",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "@dfederm Set to null? I was strictly copying the original code which sets that value to                 configurationMetadata.ToolsVersion\r\n\r\n\r\n",
              "createdAt": "2018-10-18T23:19:44Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -303,17 +334,63 @@ public ProjectGraph(IEnumerable<ProjectGraphEntryPoint> entryPoints, ProjectColl\n             return targetLists;\n         }\n \n+        /// <summary>\n+        /// A callback used for constructing a <see cref=\"ProjectInstance\"/> for a specific\n+        /// <see cref=\"ProjectGraphEntryPoint\"/> instance.\n+        /// </summary>\n+        /// <param name=\"projectPath\">The path to the project file to parse.</param>\n+        /// <param name=\"projectCollection\">The <see cref=\"ProjectCollection\"/> context for parsing.</param>\n+        /// <returns>A <see cref=\"ProjectInstance\"/> instance. This value must not be null.</returns>\n+        /// <remarks>\n+        /// The default version of this delegate used by ProjectGraph simply calls the\n+        /// ProjectInstance constructor with information from the parameters. This delegate\n+        /// is provided as a hook to allow scenarios like creating a <see cref=\"Project\"/>\n+        /// instance before converting it to a ProjectInstance for use by the ProjectGraph.\n+        ///\n+        /// The returned ProjectInstance will be stored and provided with the ProjectGraph.\n+        /// If this callback chooses to generate an immutable ProjectInstance, e.g. by\n+        /// using <see cref=\"Project.CreateProjectInstance()\"/> with the flag\n+        /// <see cref=\"ProjectInstanceSettings.Immutable\"/>, the resulting ProjectGraph\n+        /// nodes might not be buildable.\n+        /// </remarks>\n+        public delegate ProjectInstance ProjectInstanceFactoryFunc(\n+            string projectPath,\n+            Dictionary<string, string> globalProperties,\n+            string toolsVersion,",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "`ConfigurationMetadata.ToolsVersion` is hardcoded to `MSBuildConstants.CurrentToolsVersion` in this case though: https://github.com/Microsoft/msbuild/blob/exp/net472/src/Build/BackEnd/Shared/ConfigurationMetadata.cs#L49\r\n\r\nNull probably would work too I'd think.",
              "createdAt": "2018-10-18T23:28:14Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -303,17 +334,63 @@ public ProjectGraph(IEnumerable<ProjectGraphEntryPoint> entryPoints, ProjectColl\n             return targetLists;\n         }\n \n+        /// <summary>\n+        /// A callback used for constructing a <see cref=\"ProjectInstance\"/> for a specific\n+        /// <see cref=\"ProjectGraphEntryPoint\"/> instance.\n+        /// </summary>\n+        /// <param name=\"projectPath\">The path to the project file to parse.</param>\n+        /// <param name=\"projectCollection\">The <see cref=\"ProjectCollection\"/> context for parsing.</param>\n+        /// <returns>A <see cref=\"ProjectInstance\"/> instance. This value must not be null.</returns>\n+        /// <remarks>\n+        /// The default version of this delegate used by ProjectGraph simply calls the\n+        /// ProjectInstance constructor with information from the parameters. This delegate\n+        /// is provided as a hook to allow scenarios like creating a <see cref=\"Project\"/>\n+        /// instance before converting it to a ProjectInstance for use by the ProjectGraph.\n+        ///\n+        /// The returned ProjectInstance will be stored and provided with the ProjectGraph.\n+        /// If this callback chooses to generate an immutable ProjectInstance, e.g. by\n+        /// using <see cref=\"Project.CreateProjectInstance()\"/> with the flag\n+        /// <see cref=\"ProjectInstanceSettings.Immutable\"/>, the resulting ProjectGraph\n+        /// nodes might not be buildable.\n+        /// </remarks>\n+        public delegate ProjectInstance ProjectInstanceFactoryFunc(\n+            string projectPath,\n+            Dictionary<string, string> globalProperties,\n+            string toolsVersion,",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Comment should be the bug that needs to get fixed.",
              "createdAt": "2018-10-23T16:28:24Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -28,6 +29,45 @@ public void ConstructWithSingleNode()\n             }\n         }\n \n+        [Fact]\n+        public void ConstructWithSingleNodeWithProjectInstanceFactory()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                TransientTestFile entryProject = CreateProject(env, 1);\n+\n+                bool factoryCalled = false;\n+                var projectGraph = new ProjectGraph(\n+                    entryProject.Path,\n+                    ProjectCollection.GlobalProjectCollection,\n+                    (projectPath, globalProperties, projectCollection) =>\n+                    {\n+                        factoryCalled = true;\n+                        return ProjectGraph.DefaultProjectInstanceFactory(\n+                            projectPath,\n+                            globalProperties,\n+                            projectCollection);\n+                    });\n+                projectGraph.ProjectNodes.Count.ShouldBe(1);\n+                projectGraph.ProjectNodes.First().ProjectInstance.FullPath.ShouldBe(entryProject.Path);\n+                factoryCalled.ShouldBeTrue();\n+            }\n+        }\n+\n+        [Fact(Skip=\"Disabling for now as most recent exp/net472 break exception throwing on graph API\")]",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "which is #3871, thanks for filing @yash256 ",
              "createdAt": "2018-10-23T18:13:12Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -28,6 +29,45 @@ public void ConstructWithSingleNode()\n             }\n         }\n \n+        [Fact]\n+        public void ConstructWithSingleNodeWithProjectInstanceFactory()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                TransientTestFile entryProject = CreateProject(env, 1);\n+\n+                bool factoryCalled = false;\n+                var projectGraph = new ProjectGraph(\n+                    entryProject.Path,\n+                    ProjectCollection.GlobalProjectCollection,\n+                    (projectPath, globalProperties, projectCollection) =>\n+                    {\n+                        factoryCalled = true;\n+                        return ProjectGraph.DefaultProjectInstanceFactory(\n+                            projectPath,\n+                            globalProperties,\n+                            projectCollection);\n+                    });\n+                projectGraph.ProjectNodes.Count.ShouldBe(1);\n+                projectGraph.ProjectNodes.First().ProjectInstance.FullPath.ShouldBe(entryProject.Path);\n+                factoryCalled.ShouldBeTrue();\n+            }\n+        }\n+\n+        [Fact(Skip=\"Disabling for now as most recent exp/net472 break exception throwing on graph API\")]",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}