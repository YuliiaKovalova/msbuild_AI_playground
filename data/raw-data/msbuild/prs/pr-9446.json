{
  "number": 9446,
  "title": "Load NuGet.Frameworks into secondary AppDomain (MSBuild.exe only)",
  "body": "Related to #9303\r\n\r\n### Context\r\n\r\nWe load `NuGet.Frameworks` lazily by path when the project being evaluated calls one of a few property functions that need it. All standard .NET projects use such functionality so this load is executed pretty much always. Since we're loading the assembly by path, the loader is unable to take advantage of the native image and we spend 50-100 ms JITting.\r\n\r\n### Changes Made\r\n\r\nImproved MSBuild.exe startup (or, more precisely, first evaluation) by 50-100 ms by loading `NuGet.Frameworks` into a separate AppDomain using `Assembly.Load`. The AppDomain is set up with the right binding redirects for the loader to load the assembly by strong name and use its native image.\r\n\r\n### Testing\r\n\r\nExperimental insertions.\r\n\r\n### Notes\r\n\r\nThere are several other assemblies that require non-trivial JITting on startup. The reason why we're tackling `NuGet.Frameworks` here are:\r\n- The assembly has no dependencies other than Framework assemblies, so the AD setup is relatively simple.\r\n- The functionality provided by this assembly has simple signatures so the cross-domain call cost is negligible.\r\n- A compatible native image for this assembly already exists.\r\n\r\nOther notes:\r\n- There is no impact on VS or any other MSBuild host because creating ADs may be risky and disruptive. We're changing only MSBuild.exe.\r\n- This PR is about the `NuGet.Frameworks` copy that lives in `{VS-installation}\\Common7\\IDE\\CommonExtensions\\Microsoft\\NuGet`. The MSBuild process may also load SDK-specific copies from paths like `C:\\Program Files\\dotnet\\sdk\\8.0.100\\Sdks\\Microsoft.NET.Sdk\\tools\\net472` which are out of scope here.\r\n\r\nThis is what the AD looks like in SOS:\r\n\r\n```\r\nDomain 2:           000001dff97c7e70\r\nStage:              OPEN\r\nName:               NuGetFrameworkWrapper\r\nAssembly:           000001dff6bac490 [C:\\windows\\Microsoft.Net\\assembly\\GAC_64\\mscorlib\\v4.0_4.0.0.0__b77a5c561934e089\\mscorlib.dll]\r\nAssembly:           000001dff9732960 [C:\\src\\msbuild\\artifacts\\bin\\bootstrap\\net472\\MSBuild\\Current\\Bin\\Microsoft.Build.dll]\r\nAssembly:           000001dff97e2410 [C:\\src\\msbuild\\artifacts\\bin\\bootstrap\\net472\\Common7\\IDE\\CommonExtensions\\Microsoft\\NuGet\\NuGet.Frameworks.dll]\r\nAssembly:           000001dff8de7250 [C:\\windows\\Microsoft.Net\\assembly\\GAC_MSIL\\System.Core\\v4.0_4.0.0.0__b77a5c561934e089\\System.Core.dll]\r\nAssembly:           000001dff8dd6100 [C:\\windows\\Microsoft.Net\\assembly\\GAC_MSIL\\System\\v4.0_4.0.0.0__b77a5c561934e089\\System.dll]\r\nAssembly:           000001dff8e1d9a0 [C:\\windows\\Microsoft.Net\\assembly\\GAC_MSIL\\System.Xml\\v4.0_4.0.0.0__b77a5c561934e089\\System.Xml.dll]\r\n```",
  "state": "MERGED",
  "createdAt": "2023-11-22T13:02:49Z",
  "updatedAt": "2023-12-19T13:47:24Z",
  "closedAt": "2023-12-19T13:47:23Z",
  "mergedAt": "2023-12-19T13:47:23Z",
  "additions": 246,
  "deletions": 59,
  "changedFiles": 21,
  "headRefName": "dont-jit-nuget-frameworks",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "ladipro"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "f0d783536a17a6600ecf8e3b7a7668e2c921577b",
          "message": "Add BuildEnvironment.RunningInMSBuildExe",
          "committedDate": "2023-12-19T08:58:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6201a71e972a952cddc795d7e42c21b08ec64c19",
          "message": "Load NuGet.Frameworks into secondary AppDomain",
          "committedDate": "2023-12-19T08:58:47Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f8c10731a9ee98e42844f1aafe5b263ed16e7742",
          "message": "Don't load by partial name",
          "committedDate": "2023-12-19T08:58:48Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b7fddd8001981ef17bb566815a69e6cbb82fa440",
          "message": "Make NuGetAssemblyNotFound more correct/useful",
          "committedDate": "2023-12-19T08:58:48Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c73b64268cc54c4bdc2299e3bd105bbe981a3709",
          "message": "Extract binding redirects from app.config using prebuild target",
          "committedDate": "2023-12-19T08:58:48Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "64cd0674de21472a3654941653590fed18c131ca",
          "message": "PR feedback: CDATA and generating into obj",
          "committedDate": "2023-12-19T08:58:49Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "50216999fbb579c71672e3cc9720b50fc24d8476",
          "message": "PR feedback: Better clean",
          "committedDate": "2023-12-19T08:58:49Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "> It looks like NuGet.Frameworks is already in the generated devenv.exe.config. Think it'd be possible to detect if we're in the VS process and call LoadWithPartialName there, too?\r\n\r\nPossible, yes. It would require adding a `<qualifyAssembly>` entry in devenv.exe.config and there's a risk that it will break some bind somewhere, especially seeing how many copies of `NuGet.Frameworks` are distributed with VS. I'll get a VS PR started to get feedback from VS folks, thank you!",
        "createdAt": "2023-11-29T13:53:22Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "`/var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/MSBuildTemprunner/tmp978e7f4aeded4134b8c890ce3647427b.exec.cmd: line 2:  2237 Segmentation fault: 11`\r\n\r\nhttps://dev.azure.com/dnceng-public/public/_build/results?buildId=504097&view=logs&j=0ddb6181-8b1d-5386-35d2-ca21a772cde8&t=a36a8187-bb52-5aa3-80a2-ccc76a822779&l=212\r\n",
        "createdAt": "2023-12-19T09:43:11Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2023-12-19T09:43:22Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2023-12-19T09:43:31Z",
        "author": {
          "login": "azure-pipelines"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This could alternatively be done by reading the configuration of the current AD from MSBuild.exe.config, inserting the NuGet.Frameworks-related entries, and converting the whole thing to bytes to be passed to `AppDomainSetup.SetConfigurationBytes`. It would be more robust at expense of performance as it would be manipulating a much larger config and doing I/O to read the config file off disk. I'm curious what reviewers think.",
              "createdAt": "2023-11-22T13:08:39Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Can we use `\"\"\"` verbatim string here to get rid of double quotation?\r\n\r\nOtherwise - I'm not superexcited having this baked into the code, but looking on the MSBuild config, this section changes rarely. So the performance tradeoff is acceptable from my point of view.\r\n\r\nI'm just thinking if this code and MSBuild/app.config should have comments cross-mentioning each other (in case there would be some need for change)",
              "createdAt": "2023-11-28T19:01:05Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Great point about `\"\"\"`! We could use a source generator to build the string from app.config at build time. If we don't eliminate it completely per [Rainer's comment](https://github.com/dotnet/msbuild/pull/9446#discussion_r1408352134).",
              "createdAt": "2023-11-29T13:40:29Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I wouldn't use a Roslyn source generator for this, but a script in a prebuild step could be pretty nice . . . if it ever changes and causes problems.",
              "createdAt": "2023-11-29T15:10:22Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Can you elaborate on the reasons why you suggest a pre-build step instead of a source generator? Curious if it's because we currently have no generators so the barrier to introduce the first one wouldn't be justified, or if it's not the right tool for this use case.",
              "createdAt": "2023-11-30T12:43:11Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Three main reasons:\r\n\r\n1. It's just not necessary--the inputs to the generation don't include any source code.\r\n2. incrementality: while there are incremental source generators, getting to that point still means you have to run the compiler. Do it in a separate target and let the compiler not be invoked in more situations\r\n3. It's still not a great experience to have a source generator built in the same repo as its use.",
              "createdAt": "2023-11-30T17:15:26Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I've added the functionality as a custom target calling `XmlPeek` to extract the binding redirect from app.config. And it uses raw string literals (`\"\"\"`) too!",
              "createdAt": "2023-12-05T21:41:41Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I have not found this to have a measurable perf impact.",
              "createdAt": "2023-11-22T13:11:26Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -211,9 +211,15 @@ private static void HandleConfigurationException(Exception ex)\n         /// MSBuild no longer runs any arbitrary code (tasks or loggers) on the main thread, so it never needs the\n         /// main thread to be in an STA. Accordingly, to avoid ambiguity, we explicitly use the [MTAThread] attribute.\n         /// This doesn't actually do any work unless COM interop occurs for some reason.\n+        /// We use the MultiDomainHost loader policy because we may create secondary AppDomains and need NGEN images\n+        /// for Framework / GACed assemblies to be loaded domain neutral so their native images can be used.\n+        /// See <see cref=\"NuGetFrameworkWrapper\"/>.\n         /// </remarks>\n         /// <returns>0 on success, 1 on failure</returns>\n         [MTAThread]\n+#if FEATURE_APPDOMAIN\n+        [LoaderOptimization(LoaderOptimization.MultiDomainHost)]",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What if the exception here happens due to different reason (e.g. some subtle code bug)?\r\n\r\nShould we maybe log a low-pri message with exception info?",
              "createdAt": "2023-11-28T18:46:15Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n+  <configuration>\n+    <runtime>\n+      <DisableFXClosureWalk enabled=\"\"true\"\" />\n+      <DeferFXClosureWalk enabled=\"\"true\"\" />\n+      <assemblyBinding xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\">\n+        {\n+            (Environment.Is64BitProcess\n+                ? @\"<dependentAssembly>\n+                      <assemblyIdentity name=\"\"Microsoft.Build\"\" culture=\"\"neutral\"\" publicKeyToken=\"\"b03f5f7f11d50a3a\"\" />\n+                      <bindingRedirect oldVersion=\"\"0.0.0.0-99.9.9.9\"\" newVersion=\"\"15.1.0.0\"\" />\n+                      <codeBase version=\"\"15.1.0.0\"\" href=\"\"..\\Microsoft.Build.dll\"\"/>\n+                    </dependentAssembly>\"\n+\n+                : @\"<dependentAssembly>\n+                      <assemblyIdentity name=\"\"Microsoft.Build\"\" culture=\"\"neutral\"\" publicKeyToken=\"\"b03f5f7f11d50a3a\"\" />\n+                      <bindingRedirect oldVersion=\"\"0.0.0.0-99.9.9.9\"\" newVersion=\"\"15.1.0.0\"\" />\n+                    </dependentAssembly>\"\n+             )\n+        }\n+        <dependentAssembly>\n+          <assemblyIdentity name=\"\"{NuGetFrameworksAssemblyName}\"\" publicKeyToken=\"\"{publicKeyTokenString}\"\" culture=\"\"{assemblyName.CultureName}\"\" />\n+          <codeBase version=\"\"{assemblyName.Version}\"\" href=\"\"{assemblyPath}\"\" />\n+        </dependentAssembly>\n+        <qualifyAssembly partialName=\"\"{NuGetFrameworksAssemblyName}\"\" fullName=\"\"{assemblyName.FullName}\"\" />\n+      </assemblyBinding>\n+    </runtime>\n+  </configuration>\";\n+\n+            AppDomainSetup appDomainSetup = AppDomain.CurrentDomain.SetupInformation;\n+            appDomainSetup.SetConfigurationBytes(Encoding.UTF8.GetBytes(configuration));\n+            return appDomainSetup;\n+        }\n+#endif\n+\n+        public static NuGetFrameworkWrapper CreateInstance()\n+        {\n+            // Resolve the location of the NuGet.Frameworks assembly\n+            string assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?\n+                Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, \"Common7\", \"IDE\", \"CommonExtensions\", \"Microsoft\", \"NuGet\") :\n+                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;\n+\n+            bool isLoadedInSeparateAppDomain = false;\n+            NuGetFrameworkWrapper instance = null;\n+            try\n+            {\n+#if FEATURE_APPDOMAIN\n+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) && BuildEnvironmentHelper.Instance.RunningInMSBuildExe)\n+                {\n+                    // If we are running in MSBuild.exe we can load the assembly into a separate AppDomain. Loading into an AD with\n+                    // Assembly.Load enables the runtime to bind to the native image, eliminating some non-trivial JITting cost.\n+                    AppDomainSetup appDomainSetup = CreateAppDomainSetup(assemblyDirectory);\n+                    if (appDomainSetup != null)\n+                    {\n+                        AppDomain appDomain = AppDomain.CreateDomain(nameof(NuGetFrameworkWrapper), null, appDomainSetup);\n+                        instance = (NuGetFrameworkWrapper)appDomain.CreateInstanceAndUnwrap(Assembly.GetExecutingAssembly().FullName, typeof(NuGetFrameworkWrapper).FullName);\n+                        isLoadedInSeparateAppDomain = true;\n+                    }\n+                }\n+#endif\n+                instance ??= new NuGetFrameworkWrapper();\n+                instance.Initialize(assemblyDirectory, useAssemblyLoad: isLoadedInSeparateAppDomain);\n+\n+                return instance;\n+            }\n+            catch\n+            {\n+                throw new InternalErrorException(string.Format(AssemblyResources.GetString(\"NuGetAssemblyNotFound\"), assemblyDirectory));",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "This exception will fail the build so I don't think a build message would be helpful. Agreed that the current exception message is not great. At minimum, we should construct it with an inner exception with details. Thank you!",
              "createdAt": "2023-11-29T13:46:22Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n+  <configuration>\n+    <runtime>\n+      <DisableFXClosureWalk enabled=\"\"true\"\" />\n+      <DeferFXClosureWalk enabled=\"\"true\"\" />\n+      <assemblyBinding xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\">\n+        {\n+            (Environment.Is64BitProcess\n+                ? @\"<dependentAssembly>\n+                      <assemblyIdentity name=\"\"Microsoft.Build\"\" culture=\"\"neutral\"\" publicKeyToken=\"\"b03f5f7f11d50a3a\"\" />\n+                      <bindingRedirect oldVersion=\"\"0.0.0.0-99.9.9.9\"\" newVersion=\"\"15.1.0.0\"\" />\n+                      <codeBase version=\"\"15.1.0.0\"\" href=\"\"..\\Microsoft.Build.dll\"\"/>\n+                    </dependentAssembly>\"\n+\n+                : @\"<dependentAssembly>\n+                      <assemblyIdentity name=\"\"Microsoft.Build\"\" culture=\"\"neutral\"\" publicKeyToken=\"\"b03f5f7f11d50a3a\"\" />\n+                      <bindingRedirect oldVersion=\"\"0.0.0.0-99.9.9.9\"\" newVersion=\"\"15.1.0.0\"\" />\n+                    </dependentAssembly>\"\n+             )\n+        }\n+        <dependentAssembly>\n+          <assemblyIdentity name=\"\"{NuGetFrameworksAssemblyName}\"\" publicKeyToken=\"\"{publicKeyTokenString}\"\" culture=\"\"{assemblyName.CultureName}\"\" />\n+          <codeBase version=\"\"{assemblyName.Version}\"\" href=\"\"{assemblyPath}\"\" />\n+        </dependentAssembly>\n+        <qualifyAssembly partialName=\"\"{NuGetFrameworksAssemblyName}\"\" fullName=\"\"{assemblyName.FullName}\"\" />\n+      </assemblyBinding>\n+    </runtime>\n+  </configuration>\";\n+\n+            AppDomainSetup appDomainSetup = AppDomain.CurrentDomain.SetupInformation;\n+            appDomainSetup.SetConfigurationBytes(Encoding.UTF8.GetBytes(configuration));\n+            return appDomainSetup;\n+        }\n+#endif\n+\n+        public static NuGetFrameworkWrapper CreateInstance()\n+        {\n+            // Resolve the location of the NuGet.Frameworks assembly\n+            string assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?\n+                Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, \"Common7\", \"IDE\", \"CommonExtensions\", \"Microsoft\", \"NuGet\") :\n+                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;\n+\n+            bool isLoadedInSeparateAppDomain = false;\n+            NuGetFrameworkWrapper instance = null;\n+            try\n+            {\n+#if FEATURE_APPDOMAIN\n+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) && BuildEnvironmentHelper.Instance.RunningInMSBuildExe)\n+                {\n+                    // If we are running in MSBuild.exe we can load the assembly into a separate AppDomain. Loading into an AD with\n+                    // Assembly.Load enables the runtime to bind to the native image, eliminating some non-trivial JITting cost.\n+                    AppDomainSetup appDomainSetup = CreateAppDomainSetup(assemblyDirectory);\n+                    if (appDomainSetup != null)\n+                    {\n+                        AppDomain appDomain = AppDomain.CreateDomain(nameof(NuGetFrameworkWrapper), null, appDomainSetup);\n+                        instance = (NuGetFrameworkWrapper)appDomain.CreateInstanceAndUnwrap(Assembly.GetExecutingAssembly().FullName, typeof(NuGetFrameworkWrapper).FullName);\n+                        isLoadedInSeparateAppDomain = true;\n+                    }\n+                }\n+#endif\n+                instance ??= new NuGetFrameworkWrapper();\n+                instance.Initialize(assemblyDirectory, useAssemblyLoad: isLoadedInSeparateAppDomain);\n+\n+                return instance;\n+            }\n+            catch\n+            {\n+                throw new InternalErrorException(string.Format(AssemblyResources.GetString(\"NuGetAssemblyNotFound\"), assemblyDirectory));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed by tweaking the message and passing inner exception.",
              "createdAt": "2023-11-30T10:42:46Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n+  <configuration>\n+    <runtime>\n+      <DisableFXClosureWalk enabled=\"\"true\"\" />\n+      <DeferFXClosureWalk enabled=\"\"true\"\" />\n+      <assemblyBinding xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\">\n+        {\n+            (Environment.Is64BitProcess\n+                ? @\"<dependentAssembly>\n+                      <assemblyIdentity name=\"\"Microsoft.Build\"\" culture=\"\"neutral\"\" publicKeyToken=\"\"b03f5f7f11d50a3a\"\" />\n+                      <bindingRedirect oldVersion=\"\"0.0.0.0-99.9.9.9\"\" newVersion=\"\"15.1.0.0\"\" />\n+                      <codeBase version=\"\"15.1.0.0\"\" href=\"\"..\\Microsoft.Build.dll\"\"/>\n+                    </dependentAssembly>\"\n+\n+                : @\"<dependentAssembly>\n+                      <assemblyIdentity name=\"\"Microsoft.Build\"\" culture=\"\"neutral\"\" publicKeyToken=\"\"b03f5f7f11d50a3a\"\" />\n+                      <bindingRedirect oldVersion=\"\"0.0.0.0-99.9.9.9\"\" newVersion=\"\"15.1.0.0\"\" />\n+                    </dependentAssembly>\"\n+             )\n+        }\n+        <dependentAssembly>\n+          <assemblyIdentity name=\"\"{NuGetFrameworksAssemblyName}\"\" publicKeyToken=\"\"{publicKeyTokenString}\"\" culture=\"\"{assemblyName.CultureName}\"\" />\n+          <codeBase version=\"\"{assemblyName.Version}\"\" href=\"\"{assemblyPath}\"\" />\n+        </dependentAssembly>\n+        <qualifyAssembly partialName=\"\"{NuGetFrameworksAssemblyName}\"\" fullName=\"\"{assemblyName.FullName}\"\" />\n+      </assemblyBinding>\n+    </runtime>\n+  </configuration>\";\n+\n+            AppDomainSetup appDomainSetup = AppDomain.CurrentDomain.SetupInformation;\n+            appDomainSetup.SetConfigurationBytes(Encoding.UTF8.GetBytes(configuration));\n+            return appDomainSetup;\n+        }\n+#endif\n+\n+        public static NuGetFrameworkWrapper CreateInstance()\n+        {\n+            // Resolve the location of the NuGet.Frameworks assembly\n+            string assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?\n+                Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, \"Common7\", \"IDE\", \"CommonExtensions\", \"Microsoft\", \"NuGet\") :\n+                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;\n+\n+            bool isLoadedInSeparateAppDomain = false;\n+            NuGetFrameworkWrapper instance = null;\n+            try\n+            {\n+#if FEATURE_APPDOMAIN\n+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) && BuildEnvironmentHelper.Instance.RunningInMSBuildExe)\n+                {\n+                    // If we are running in MSBuild.exe we can load the assembly into a separate AppDomain. Loading into an AD with\n+                    // Assembly.Load enables the runtime to bind to the native image, eliminating some non-trivial JITting cost.\n+                    AppDomainSetup appDomainSetup = CreateAppDomainSetup(assemblyDirectory);\n+                    if (appDomainSetup != null)\n+                    {\n+                        AppDomain appDomain = AppDomain.CreateDomain(nameof(NuGetFrameworkWrapper), null, appDomainSetup);\n+                        instance = (NuGetFrameworkWrapper)appDomain.CreateInstanceAndUnwrap(Assembly.GetExecutingAssembly().FullName, typeof(NuGetFrameworkWrapper).FullName);\n+                        isLoadedInSeparateAppDomain = true;\n+                    }\n+                }\n+#endif\n+                instance ??= new NuGetFrameworkWrapper();\n+                instance.Initialize(assemblyDirectory, useAssemblyLoad: isLoadedInSeparateAppDomain);\n+\n+                return instance;\n+            }\n+            catch\n+            {\n+                throw new InternalErrorException(string.Format(AssemblyResources.GetString(\"NuGetAssemblyNotFound\"), assemblyDirectory));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it possible to avoid the `Microsoft.Build` redirects by using the app domain only _within_ the `NuGetFrameworkWrapper`, instead of creating that inside the domain too?",
              "createdAt": "2023-11-28T19:56:54Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "We need _an_ MBRO in the app domain to call through. It may as well live in `NuGet.Frameworks`, that's true. It would mean maintaining an internal API made specifically for MSBuild in another repo, and I'm not sure if it's worth the hassle. This part of the code has been relatively stable .. but so have been the binding redirects. I would probably err on the side of simplicity and keep the duplicated redirects here (could be extracted from our app.config using a source generator!). What do you think?",
              "createdAt": "2023-11-29T13:36:36Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Let's go with this and see if there's a reason to change it later.",
              "createdAt": "2023-11-29T14:45:52Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we need the `qualifyAssembly`? Could we instead get the full `AssemblyName` from the file at the known path and use that? That could also avoid the need to change `devenv.exe.config`.",
              "createdAt": "2023-11-29T15:12:06Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n+  <configuration>\n+    <runtime>\n+      <DisableFXClosureWalk enabled=\"\"true\"\" />\n+      <DeferFXClosureWalk enabled=\"\"true\"\" />\n+      <assemblyBinding xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\">\n+        {\n+            (Environment.Is64BitProcess\n+                ? @\"<dependentAssembly>\n+                      <assemblyIdentity name=\"\"Microsoft.Build\"\" culture=\"\"neutral\"\" publicKeyToken=\"\"b03f5f7f11d50a3a\"\" />\n+                      <bindingRedirect oldVersion=\"\"0.0.0.0-99.9.9.9\"\" newVersion=\"\"15.1.0.0\"\" />\n+                      <codeBase version=\"\"15.1.0.0\"\" href=\"\"..\\Microsoft.Build.dll\"\"/>\n+                    </dependentAssembly>\"\n+\n+                : @\"<dependentAssembly>\n+                      <assemblyIdentity name=\"\"Microsoft.Build\"\" culture=\"\"neutral\"\" publicKeyToken=\"\"b03f5f7f11d50a3a\"\" />\n+                      <bindingRedirect oldVersion=\"\"0.0.0.0-99.9.9.9\"\" newVersion=\"\"15.1.0.0\"\" />\n+                    </dependentAssembly>\"\n+             )\n+        }\n+        <dependentAssembly>\n+          <assemblyIdentity name=\"\"{NuGetFrameworksAssemblyName}\"\" publicKeyToken=\"\"{publicKeyTokenString}\"\" culture=\"\"{assemblyName.CultureName}\"\" />\n+          <codeBase version=\"\"{assemblyName.Version}\"\" href=\"\"{assemblyPath}\"\" />\n+        </dependentAssembly>\n+        <qualifyAssembly partialName=\"\"{NuGetFrameworksAssemblyName}\"\" fullName=\"\"{assemblyName.FullName}\"\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "D'oh! For some reason I thought `Assembly.Load` falling back to load-from would only work with partial name, hence my incorrect assumption that `qualifyAssembly` is needed. I have reworked it and it's better altogether - no `qualifyAssembly`, no partial-name loads, `devenv` gets to use the NGEN image as well.",
              "createdAt": "2023-11-30T10:52:31Z",
              "path": "src/Build/Utilities/NuGetFrameworkWrapper.cs",
              "diffHunk": "@@ -133,5 +156,106 @@ public string FilterTargetFrameworks(string incoming, string filter)\n                 });\n             }\n         }\n+\n+#if FEATURE_APPDOMAIN\n+        /// <summary>\n+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.\n+        /// </summary>\n+        public override object InitializeLifetimeService() => null;\n+\n+        private static AppDomainSetup CreateAppDomainSetup(string assemblyDirectory)\n+        {\n+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);\n+            AssemblyName assemblyName;\n+            try\n+            {\n+                assemblyName = AssemblyName.GetAssemblyName(assemblyPath);\n+            }\n+            catch\n+            {\n+                // Return null to fall back to loading into the default AppDomain using LoadFile.\n+                return null;\n+            }\n+\n+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();\n+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);\n+            for (int i = 0; i < publicKeyToken.Length; i++)\n+            {\n+                publicKeyTokenString.Append(publicKeyToken[i].ToString(\"x2\", CultureInfo.InvariantCulture));\n+            }\n+\n+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,\n+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when\n+            // NGENing MSBuild for the native images to be used.\n+            string configuration = $@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>\n+  <configuration>\n+    <runtime>\n+      <DisableFXClosureWalk enabled=\"\"true\"\" />\n+      <DeferFXClosureWalk enabled=\"\"true\"\" />\n+      <assemblyBinding xmlns=\"\"urn:schemas-microsoft-com:asm.v1\"\">\n+        {\n+            (Environment.Is64BitProcess\n+                ? @\"<dependentAssembly>\n+                      <assemblyIdentity name=\"\"Microsoft.Build\"\" culture=\"\"neutral\"\" publicKeyToken=\"\"b03f5f7f11d50a3a\"\" />\n+                      <bindingRedirect oldVersion=\"\"0.0.0.0-99.9.9.9\"\" newVersion=\"\"15.1.0.0\"\" />\n+                      <codeBase version=\"\"15.1.0.0\"\" href=\"\"..\\Microsoft.Build.dll\"\"/>\n+                    </dependentAssembly>\"\n+\n+                : @\"<dependentAssembly>\n+                      <assemblyIdentity name=\"\"Microsoft.Build\"\" culture=\"\"neutral\"\" publicKeyToken=\"\"b03f5f7f11d50a3a\"\" />\n+                      <bindingRedirect oldVersion=\"\"0.0.0.0-99.9.9.9\"\" newVersion=\"\"15.1.0.0\"\" />\n+                    </dependentAssembly>\"\n+             )\n+        }\n+        <dependentAssembly>\n+          <assemblyIdentity name=\"\"{NuGetFrameworksAssemblyName}\"\" publicKeyToken=\"\"{publicKeyTokenString}\"\" culture=\"\"{assemblyName.CultureName}\"\" />\n+          <codeBase version=\"\"{assemblyName.Version}\"\" href=\"\"{assemblyPath}\"\" />\n+        </dependentAssembly>\n+        <qualifyAssembly partialName=\"\"{NuGetFrameworksAssemblyName}\"\" fullName=\"\"{assemblyName.FullName}\"\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You don't have to, but if you want this to look cleaner/more C#y you can stuff it into a property with a CDATA to avoid a bunch of this escaping.",
              "createdAt": "2023-12-05T22:12:39Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -670,4 +671,30 @@\n       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>\n     </EmbeddedResource>\n   </ItemGroup>\n+\n+  <!-- Extract binding redirects for Microsoft.Build from MSBuild.exe.config into a source file -->\n+  <Target Name=\"GenerateAppDomainConfig\" BeforeTargets=\"Build\" Condition=\"'$(FeatureAppDomain)' == 'true'\">\n+    <PropertyGroup>\n+      <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>\n+      <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/ns:dependentAssembly[ns:assemblyIdentity/@name='Microsoft.Build']</BindingRedirectXPath>\n+    </PropertyGroup>\n+\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect32\" />\n+    </XmlPeek>\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.amd64.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect64\" />\n+    </XmlPeek>\n+\n+    <WriteLinesToFile File=\"Utilities\\NuGetFrameworkWrapper.redirects.cs\" Overwrite=\"true\" WriteOnlyWhenDifferent=\"true\" Lines=\"\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+namespace Microsoft.Build.Evaluation%3B;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a reason to prefer to check in the generated file? I would put this in obj\r\n\r\n```suggestion\r\n    <WriteLinesToFile File=\"$(IntermediateOutputPath)NuGetFrameworkWrapper.redirects.cs\" Overwrite=\"true\" WriteOnlyWhenDifferent=\"true\" Lines=\"\r\n```\r\n\r\nand add it to `@(Compile)` and make the target incremental. That's the \"default pattern\" for generated code IMO.",
              "createdAt": "2023-12-05T22:20:02Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -670,4 +671,30 @@\n       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>\n     </EmbeddedResource>\n   </ItemGroup>\n+\n+  <!-- Extract binding redirects for Microsoft.Build from MSBuild.exe.config into a source file -->\n+  <Target Name=\"GenerateAppDomainConfig\" BeforeTargets=\"Build\" Condition=\"'$(FeatureAppDomain)' == 'true'\">\n+    <PropertyGroup>\n+      <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>\n+      <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/ns:dependentAssembly[ns:assemblyIdentity/@name='Microsoft.Build']</BindingRedirectXPath>\n+    </PropertyGroup>\n+\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect32\" />\n+    </XmlPeek>\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.amd64.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect64\" />\n+    </XmlPeek>\n+\n+    <WriteLinesToFile File=\"Utilities\\NuGetFrameworkWrapper.redirects.cs\" Overwrite=\"true\" WriteOnlyWhenDifferent=\"true\" Lines=\"",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "> Is there a reason to prefer to check in the generated file?\r\n\r\nThe motivation for this is that the project would be complete without having to run any kind of build. I guess that was misguided. Looking at the relevant [tutorial](https://learn.microsoft.com/en-us/visualstudio/msbuild/tutorial-custom-task-code-generation), they hook the target to run before `CoreCompile`. Presumably the implied guarantee that it will always run as part of design-time build is sound. I am not sure if the generated file will show in Solution Explorer if it's added to `Compile` in a target but that's just a nice-to-have.\r\n\r\nOK, it's starting to come together for me, thank you for your patience!",
              "createdAt": "2023-12-06T09:12:43Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -670,4 +671,30 @@\n       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>\n     </EmbeddedResource>\n   </ItemGroup>\n+\n+  <!-- Extract binding redirects for Microsoft.Build from MSBuild.exe.config into a source file -->\n+  <Target Name=\"GenerateAppDomainConfig\" BeforeTargets=\"Build\" Condition=\"'$(FeatureAppDomain)' == 'true'\">\n+    <PropertyGroup>\n+      <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>\n+      <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/ns:dependentAssembly[ns:assemblyIdentity/@name='Microsoft.Build']</BindingRedirectXPath>\n+    </PropertyGroup>\n+\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect32\" />\n+    </XmlPeek>\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.amd64.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect64\" />\n+    </XmlPeek>\n+\n+    <WriteLinesToFile File=\"Utilities\\NuGetFrameworkWrapper.redirects.cs\" Overwrite=\"true\" WriteOnlyWhenDifferent=\"true\" Lines=\"",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n      <FileWrites Include=\"$(NuGetFrameworkWrapperRedirects_FilePath)\" />\r\n    </ItemGroup>\r\n```\r\n\r\nThis ensures it gets deleted on `Clean`.",
              "createdAt": "2023-12-06T23:12:50Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -670,4 +670,57 @@\n       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>\n     </EmbeddedResource>\n   </ItemGroup>\n+\n+  <PropertyGroup>\n+    <NuGetFrameworkWrapperRedirects_FilePath>$(IntermediateOutputPath)NuGetFrameworkWrapper.redirects.cs</NuGetFrameworkWrapperRedirects_FilePath>\n+  </PropertyGroup>\n+\n+  <!-- Extract binding redirects for Microsoft.Build from MSBuild.exe.config into a source file -->\n+  <Target Name=\"GenerateAppDomainConfig\"\n+          Inputs=\"..\\MSBuild\\app.config;..\\MSBuild\\app.amd64.config\"\n+          Outputs=\"$(NuGetFrameworkWrapperRedirects_FilePath)\"\n+          BeforeTargets=\"CoreCompile\"\n+          Condition=\"'$(FeatureAppDomain)' == 'true'\">\n+    <PropertyGroup>\n+      <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>\n+      <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/ns:dependentAssembly[ns:assemblyIdentity/@name='Microsoft.Build']</BindingRedirectXPath>\n+    </PropertyGroup>\n+\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect32\" />\n+    </XmlPeek>\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.amd64.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect64\" />\n+    </XmlPeek>\n+\n+    <PropertyGroup>\n+      <NuGetFrameworkWrapperRedirects_Content><![CDATA[\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Evaluation%3B;\n+\n+[System.CodeDom.Compiler.GeneratedCode(\"GenerateAppDomainConfig\", \"1.0\")]\n+internal sealed partial class NuGetFrameworkWrapper\n+{\n+    private const string _bindingRedirect32 = \"\"\";@(BindingRedirect32);\"\"\"%3B;\n+    private const string _bindingRedirect64 = \"\"\";@(BindingRedirect64);\"\"\"%3B;\n+}\n+]]>\n+      </NuGetFrameworkWrapperRedirects_Content>\n+    </PropertyGroup>\n+\n+    <WriteLinesToFile File=\"$(NuGetFrameworkWrapperRedirects_FilePath)\" Overwrite=\"true\" WriteOnlyWhenDifferent=\"true\" Lines=\"$(NuGetFrameworkWrapperRedirects_Content)\" />\n+\n+    <ItemGroup>\n+      <Compile Remove=\"$(NuGetFrameworkWrapperRedirects_FilePath)\" />\n+      <Compile Include=\"$(NuGetFrameworkWrapperRedirects_FilePath)\">\n+        <Link>Utilities\\NuGetFrameworkWrapper.redirects.cs</Link>\n+      </Compile>\n+    </ItemGroup>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Done.",
              "createdAt": "2023-12-07T09:55:24Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -670,4 +670,57 @@\n       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>\n     </EmbeddedResource>\n   </ItemGroup>\n+\n+  <PropertyGroup>\n+    <NuGetFrameworkWrapperRedirects_FilePath>$(IntermediateOutputPath)NuGetFrameworkWrapper.redirects.cs</NuGetFrameworkWrapperRedirects_FilePath>\n+  </PropertyGroup>\n+\n+  <!-- Extract binding redirects for Microsoft.Build from MSBuild.exe.config into a source file -->\n+  <Target Name=\"GenerateAppDomainConfig\"\n+          Inputs=\"..\\MSBuild\\app.config;..\\MSBuild\\app.amd64.config\"\n+          Outputs=\"$(NuGetFrameworkWrapperRedirects_FilePath)\"\n+          BeforeTargets=\"CoreCompile\"\n+          Condition=\"'$(FeatureAppDomain)' == 'true'\">\n+    <PropertyGroup>\n+      <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>\n+      <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/ns:dependentAssembly[ns:assemblyIdentity/@name='Microsoft.Build']</BindingRedirectXPath>\n+    </PropertyGroup>\n+\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect32\" />\n+    </XmlPeek>\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.amd64.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect64\" />\n+    </XmlPeek>\n+\n+    <PropertyGroup>\n+      <NuGetFrameworkWrapperRedirects_Content><![CDATA[\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Evaluation%3B;\n+\n+[System.CodeDom.Compiler.GeneratedCode(\"GenerateAppDomainConfig\", \"1.0\")]\n+internal sealed partial class NuGetFrameworkWrapper\n+{\n+    private const string _bindingRedirect32 = \"\"\";@(BindingRedirect32);\"\"\"%3B;\n+    private const string _bindingRedirect64 = \"\"\";@(BindingRedirect64);\"\"\"%3B;\n+}\n+]]>\n+      </NuGetFrameworkWrapperRedirects_Content>\n+    </PropertyGroup>\n+\n+    <WriteLinesToFile File=\"$(NuGetFrameworkWrapperRedirects_FilePath)\" Overwrite=\"true\" WriteOnlyWhenDifferent=\"true\" Lines=\"$(NuGetFrameworkWrapperRedirects_Content)\" />\n+\n+    <ItemGroup>\n+      <Compile Remove=\"$(NuGetFrameworkWrapperRedirects_FilePath)\" />\n+      <Compile Include=\"$(NuGetFrameworkWrapperRedirects_FilePath)\">\n+        <Link>Utilities\\NuGetFrameworkWrapper.redirects.cs</Link>\n+      </Compile>\n+    </ItemGroup>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This shouldn't be necessary with the FileWrites.",
              "createdAt": "2023-12-06T23:13:16Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -670,4 +670,57 @@\n       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>\n     </EmbeddedResource>\n   </ItemGroup>\n+\n+  <PropertyGroup>\n+    <NuGetFrameworkWrapperRedirects_FilePath>$(IntermediateOutputPath)NuGetFrameworkWrapper.redirects.cs</NuGetFrameworkWrapperRedirects_FilePath>\n+  </PropertyGroup>\n+\n+  <!-- Extract binding redirects for Microsoft.Build from MSBuild.exe.config into a source file -->\n+  <Target Name=\"GenerateAppDomainConfig\"\n+          Inputs=\"..\\MSBuild\\app.config;..\\MSBuild\\app.amd64.config\"\n+          Outputs=\"$(NuGetFrameworkWrapperRedirects_FilePath)\"\n+          BeforeTargets=\"CoreCompile\"\n+          Condition=\"'$(FeatureAppDomain)' == 'true'\">\n+    <PropertyGroup>\n+      <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>\n+      <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/ns:dependentAssembly[ns:assemblyIdentity/@name='Microsoft.Build']</BindingRedirectXPath>\n+    </PropertyGroup>\n+\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect32\" />\n+    </XmlPeek>\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.amd64.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect64\" />\n+    </XmlPeek>\n+\n+    <PropertyGroup>\n+      <NuGetFrameworkWrapperRedirects_Content><![CDATA[\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Evaluation%3B;\n+\n+[System.CodeDom.Compiler.GeneratedCode(\"GenerateAppDomainConfig\", \"1.0\")]\n+internal sealed partial class NuGetFrameworkWrapper\n+{\n+    private const string _bindingRedirect32 = \"\"\";@(BindingRedirect32);\"\"\"%3B;\n+    private const string _bindingRedirect64 = \"\"\";@(BindingRedirect64);\"\"\"%3B;\n+}\n+]]>\n+      </NuGetFrameworkWrapperRedirects_Content>\n+    </PropertyGroup>\n+\n+    <WriteLinesToFile File=\"$(NuGetFrameworkWrapperRedirects_FilePath)\" Overwrite=\"true\" WriteOnlyWhenDifferent=\"true\" Lines=\"$(NuGetFrameworkWrapperRedirects_Content)\" />\n+\n+    <ItemGroup>\n+      <Compile Remove=\"$(NuGetFrameworkWrapperRedirects_FilePath)\" />\n+      <Compile Include=\"$(NuGetFrameworkWrapperRedirects_FilePath)\">\n+        <Link>Utilities\\NuGetFrameworkWrapper.redirects.cs</Link>\n+      </Compile>\n+    </ItemGroup>\n+  </Target>\n+\n+  <Target Name=\"ForceGenerateAppDomainConfigOnRebuild\" AfterTargets=\"CoreClean\">\n+    <Delete Files=\"$(NuGetFrameworkWrapperRedirects_FilePath)\" />\n+  </Target>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Done.",
              "createdAt": "2023-12-07T09:55:35Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -670,4 +670,57 @@\n       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>\n     </EmbeddedResource>\n   </ItemGroup>\n+\n+  <PropertyGroup>\n+    <NuGetFrameworkWrapperRedirects_FilePath>$(IntermediateOutputPath)NuGetFrameworkWrapper.redirects.cs</NuGetFrameworkWrapperRedirects_FilePath>\n+  </PropertyGroup>\n+\n+  <!-- Extract binding redirects for Microsoft.Build from MSBuild.exe.config into a source file -->\n+  <Target Name=\"GenerateAppDomainConfig\"\n+          Inputs=\"..\\MSBuild\\app.config;..\\MSBuild\\app.amd64.config\"\n+          Outputs=\"$(NuGetFrameworkWrapperRedirects_FilePath)\"\n+          BeforeTargets=\"CoreCompile\"\n+          Condition=\"'$(FeatureAppDomain)' == 'true'\">\n+    <PropertyGroup>\n+      <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>\n+      <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/ns:dependentAssembly[ns:assemblyIdentity/@name='Microsoft.Build']</BindingRedirectXPath>\n+    </PropertyGroup>\n+\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect32\" />\n+    </XmlPeek>\n+    <XmlPeek XmlInputPath=\"..\\MSBuild\\app.amd64.config\" Query=\"$(BindingRedirectXPath)\" Namespaces=\"$(BindingRedirectNamespace)\">\n+      <Output TaskParameter=\"Result\" ItemName=\"BindingRedirect64\" />\n+    </XmlPeek>\n+\n+    <PropertyGroup>\n+      <NuGetFrameworkWrapperRedirects_Content><![CDATA[\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Evaluation%3B;\n+\n+[System.CodeDom.Compiler.GeneratedCode(\"GenerateAppDomainConfig\", \"1.0\")]\n+internal sealed partial class NuGetFrameworkWrapper\n+{\n+    private const string _bindingRedirect32 = \"\"\";@(BindingRedirect32);\"\"\"%3B;\n+    private const string _bindingRedirect64 = \"\"\";@(BindingRedirect64);\"\"\"%3B;\n+}\n+]]>\n+      </NuGetFrameworkWrapperRedirects_Content>\n+    </PropertyGroup>\n+\n+    <WriteLinesToFile File=\"$(NuGetFrameworkWrapperRedirects_FilePath)\" Overwrite=\"true\" WriteOnlyWhenDifferent=\"true\" Lines=\"$(NuGetFrameworkWrapperRedirects_Content)\" />\n+\n+    <ItemGroup>\n+      <Compile Remove=\"$(NuGetFrameworkWrapperRedirects_FilePath)\" />\n+      <Compile Include=\"$(NuGetFrameworkWrapperRedirects_FilePath)\">\n+        <Link>Utilities\\NuGetFrameworkWrapper.redirects.cs</Link>\n+      </Compile>\n+    </ItemGroup>\n+  </Target>\n+\n+  <Target Name=\"ForceGenerateAppDomainConfigOnRebuild\" AfterTargets=\"CoreClean\">\n+    <Delete Files=\"$(NuGetFrameworkWrapperRedirects_FilePath)\" />\n+  </Target>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}