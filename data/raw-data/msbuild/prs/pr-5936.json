{
  "number": 5936,
  "title": "Project Cache initial implementation",
  "body": "Ready for review. Start with the [documentation](https://github.com/dotnet/msbuild/pull/5936/files#diff-88d204b4eb83cfa314f40ffb009b52bc107db3a2c1432e454c26e02c86a4e540) which should describe all the big changes here.\r\n\r\nTodos:\r\n- [x] Unit tests\r\n- [x] RPS run\r\n- [ ] Create issue: an async LoggingService misses events logged by `Plugin.EndBuildAsync` when `Plugin.EndBuildAsync` also throws an exception\r\n\r\nIssues addressed in future PRs:\r\n- constrain proxy target builds to inproc nodes, as a perf optimization.\r\n- parent plugin log events under the queried project's logging context so they show nicely in the binlog\r\n- add option to query the plugin against all graph nodes without building anything (cache warmup)\r\n- pipe `MSBuildFileSystem` to the plugin for both graph and non graph scenarios.\r\n\r\nSince it's a bigger PR you might consider using CodeFlow to make it easier to review, it has a chrome extension: https://www.1eswiki.com/wiki/CodeFlow_integration_with_GitHub_Pull_Requests (msft internal link)",
  "state": "MERGED",
  "createdAt": "2020-12-07T00:49:06Z",
  "updatedAt": "2021-01-15T22:34:12Z",
  "closedAt": "2021-01-15T22:34:11Z",
  "mergedAt": "2021-01-15T22:34:11Z",
  "additions": 3631,
  "deletions": 225,
  "changedFiles": 61,
  "headRefName": "projectCache",
  "isDraft": false,
  "author": {
    "login": "cdmihai"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Project Cache"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "9342c992098f0973fd2075e3d8fecc641f46ca6b",
          "message": "Project cache documentation",
          "committedDate": "2021-01-11T21:26:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2d35e8c4eebe87b2db60b3bf52038687ab1dfe2e",
          "message": "Update System.Text.Json",
          "committedDate": "2021-01-11T21:26:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5dd170f8f344420717112ce7ce0a34638b5e045",
          "message": "Item and metadata interfaces allow retrieving metadata\n\nAlso cleanup needless double interface declarations",
          "committedDate": "2021-01-11T21:26:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3a053d5521bc32c4c645511a7bc3c11cb13b50a5",
          "message": "Project cache plugin implementation",
          "committedDate": "2021-01-11T21:26:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3ca8cc630d739a17e6fdea41ac9e9217724c402b",
          "message": "Error if not all nodes define a cache item",
          "committedDate": "2021-01-11T21:26:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c40a18ad5a1afc79c17eff5ca9ccc638990493d6",
          "message": "ProjectCacheDescriptor can be directly given an instance",
          "committedDate": "2021-01-11T21:26:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2f4ca38139d96aec5875b03b7522995eb9e9c8da",
          "message": "Add BuildResult and TargetResult comparison helpers",
          "committedDate": "2021-01-11T21:26:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "357a69c42fd9527135f965e381004ef2fea17adc",
          "message": "Manually add targets instead of Merge\n\nMerge had some failing preconditions that do not apply in this case",
          "committedDate": "2021-01-11T21:26:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "af241b9589a210e479c54f065097ae16b62dee33",
          "message": "Avoid null pointer exception in BuildParameters",
          "committedDate": "2021-01-11T21:26:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e1ed8ca09c60c95dfb833a05cfbc18da5eb0e3a3",
          "message": "Add more error messages and enable nullable references",
          "committedDate": "2021-01-11T21:26:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "71a9bfa8f78c4d7b73257a5df588dc60938155ce",
          "message": "Ensure cache exception get either into a BuildResult or get thrown in EndBuild",
          "committedDate": "2021-01-11T21:26:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2b6b5803d644f83af283d342610512adeb4c1603",
          "message": "Tests",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "060b73e1446cca541d4ca3e3a2371504a82a7fb1",
          "message": "Redistribute Microsoft.Bcl.Hashcode",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "55ff5cd027c3ccee76ccfaa07cabfe6fe57ffd74",
          "message": "ProjectCacheBase -> ProjectCachePluginBase",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3a54fe949cddcef47e548aafd4a8091e85bc62b1",
          "message": "ToString -> GetDetailedDescription",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "69c6e438dc03499e93a263bf47278d6c98f79efe",
          "message": "Feedback",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a34440423a7fc4bd939bf8c5b3154165835f18d4",
          "message": "Feedback\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "70e8be6b42c44a6c14d33f798babebdab5bd8025",
          "message": "Update src/Build/Resources/Strings.resx\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f1b5baff65c3805957aa73b839bdbce8cdd274b7",
          "message": "Feedback",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "87f0af7a2b7827646e50f1bd59a1a522c0ee214c",
          "message": "CacheError -> None",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a7c5f3d1378eb2c3148b3823f9f70cde5c8120f9",
          "message": "Rename mock caches",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "151d47a46912432a36b0f302c961a2f28383d973",
          "message": "feedback",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7e9f57870822f7eec057ec1aaba5f8797a0b6f96",
          "message": "Remove Microsoft.Bcl.HashCode",
          "committedDate": "2021-01-11T21:26:44Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9dcbf63b3bf5107f7f12a28b7badf964c14b6725",
          "message": "Revert \"Update System.Text.Json\"\n\nThis reverts commit 2d35e8c4eebe87b2db60b3bf52038687ab1dfe2e.",
          "committedDate": "2021-01-13T19:19:23Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bd0bcd31b79cfd9f6e44bd13edb3d0cfb377441a",
          "message": "Feedback",
          "committedDate": "2021-01-13T22:44:43Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "/azp run #Resolved",
        "createdAt": "2020-12-29T22:53:59Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp> #Resolved",
        "createdAt": "2020-12-29T22:54:08Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "<samp>\nNo pipelines are associated with this pull request.<br>\r\n\n</samp>",
        "createdAt": "2021-01-04T23:24:24Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2021-01-07T01:29:58Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2021-01-07T01:30:11Z",
        "author": {
          "login": "azure-pipelines"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it worth keeping `CacheError`? I'm thinking of dropping it in favor of just checking `PluginLoggerBase.HasLoggedErrors`. If we keep both, what should the user or msbuild do if the plugin returns `CacheError` but no errors are logged? Seems simpler to just keep one mechanism for signaling errors.",
              "createdAt": "2020-12-08T02:05:29Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Yeah I agree, the way its mostly done is its success unless an error was logged.",
              "createdAt": "2020-12-19T00:00:37Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "+1 for using `PluginLoggerBase.HasLoggedErrors`",
              "createdAt": "2020-12-22T20:24:11Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "K, I'll remove CacheError",
              "createdAt": "2020-12-28T18:20:52Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "So it turns out CacheError may have a good use: when the plugin is queried for a project but it encounters and logs one or more errors, what should the plugin return? It could either return a null CacheResult or a CacheResult of result type CacheError (returning a CacheMiss or CacheNotApplicable doesn't seem a good fit for the error case). But then there's the above ambiguity when a plugin could return CacheError without logging any errors, which I guess could be fine.\r\n\r\nAn alternative is to remove the enum entirely. On cache hits the plugin returns a CacheResult with the build results (or proxy targets and whatnot). On anything else (cache miss, cache not applicable, cache error) the plugin returns a null CacheResult and logs why it couldn't satisfy the request. Worst case we get a plugin that returns null and does not log anything.\r\n\r\nI am inclined now to keep CacheError in order to make the return modes explicit.\r\n\r\nLet me know what you think.",
              "createdAt": "2020-12-29T19:27:40Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I'm slightly more inclined to return null on any failure case. The main question in my mind is whether you'd react differently to CacheMiss, CacheNotApplicable, and CacheError, but the right response, from what I can tell, is to pretend the cache doesn't exist and build normally for all three cases. May as well just have a single \"build everything\" return value.",
              "createdAt": "2020-12-30T17:12:09Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Decided to just replace `CacheError` with a `None` value. Hit, Miss, and NA are domain level concepts that sort of define the meaning of a plugin so I like to have them explicit. Without them, we'd rely on arbitrary plugin implementations on how they express these 3 possibilities, versus MSBuild giving a standardized message for each type of response. Another concrete use case for having them is to enable MSBuild to report the cache hit ratio in the build summary (`hits / (hits + misses)`, need NA to not count them as misses). That's a very useful metric for cacheability health (which, just like perf, is something that tends to degrade over time).",
              "createdAt": "2021-01-04T19:44:56Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Start review here. This method is the entrypoint from where the logic starts diverting when a cache is available.",
              "createdAt": "2020-12-11T17:07:51Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1000,300 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            if (ProjectCacheIsPresent())",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What are the implications here?  Do we need to ship another DLL with MSBuild?",
              "createdAt": "2020-12-18T23:57:01Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -40,6 +40,7 @@\n   </ItemGroup>\n \n   <ItemGroup Condition=\"'$(TargetFrameworkIdentifier)' == '.NETFramework'\">\n+    <PackageReference Include=\"Microsoft.Bcl.HashCode\" />",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "Good catch, it's not already in the VS deployment dir, so I'll add it.",
              "createdAt": "2020-12-28T21:38:33Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -40,6 +40,7 @@\n   </ItemGroup>\n \n   <ItemGroup Condition=\"'$(TargetFrameworkIdentifier)' == '.NETFramework'\">\n+    <PackageReference Include=\"Microsoft.Bcl.HashCode\" />",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: missing space after property name",
              "createdAt": "2020-12-18T23:58:25Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -780,6 +782,14 @@ public string OutputResultsCacheFile\n         /// </summary>\n         public bool LowPriority { get; set; }\n \n+        /// <summary>\n+        /// If set, the BuildManager will query all\n+        /// incoming <see cref=\"BuildSubmission\"/> requests against the specified project cache.\n+        /// Any <see cref=\"GraphBuildSubmission\"/> requests will also use this project cache instead of\n+        /// the potential project caches described in graph node's evaluations.\n+        /// </summary>\n+        public ProjectCacheDescriptor ProjectCacheDescriptor{ get; set; }",
              "author": {
                "login": "jeffkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this needed?  Looks like the only change in this file?",
              "createdAt": "2020-12-18T23:58:50Z",
              "path": "src/Build/BackEnd/BuildManager/BuildSubmission.cs",
              "diffHunk": "@@ -6,6 +6,9 @@\n using Microsoft.Build.BackEnd;\n using Microsoft.Build.Shared;\n using System.Globalization;\n+using Microsoft.Build.BackEnd.Logging;",
              "author": {
                "login": "jeffkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you give a better description here, this is just a requirement of the object, not an explanation as to what it is.",
              "createdAt": "2020-12-18T23:59:40Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheContext.cs",
              "diffHunk": "@@ -0,0 +1,40 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using Microsoft.Build.FileSystem;\n+using Microsoft.Build.Graph;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Either Graph is null, or GraphEntryPoints is null. Not Both.",
              "author": {
                "login": "jeffkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Better description please",
              "createdAt": "2020-12-19T00:01:06Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError\n+    }\n+\n+    /// <summary>\n+    ///     Only cache hits have non null build result information.",
              "author": {
                "login": "jeffkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This should probably be named something like `ProjectCachePluginBase` or something more precise, this name seems too generic to me.",
              "createdAt": "2020-12-19T00:02:46Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheBase.cs",
              "diffHunk": "@@ -0,0 +1,42 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Only one plugin instance can exist for a given BuildManager BeginBuild / EndBuild session.\n+    /// </summary>\n+    public abstract class ProjectCacheBase",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "Yeah, `ProjectCachePluginBase` sounds better.",
              "createdAt": "2020-12-29T00:00:48Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheBase.cs",
              "diffHunk": "@@ -0,0 +1,42 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Only one plugin instance can exist for a given BuildManager BeginBuild / EndBuild session.\n+    /// </summary>\n+    public abstract class ProjectCacheBase",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems like a very expensive method, is it going to be called a lot?",
              "createdAt": "2020-12-19T00:03:38Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs",
              "diffHunk": "@@ -0,0 +1,71 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Graph;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public class ProjectCacheDescriptor\n+    {\n+        public ProjectCacheDescriptor(\n+            string pluginPath,\n+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,\n+            ProjectGraph? projectGraph,\n+            IReadOnlyDictionary<string, string>? pluginSettings = null)\n+        {\n+            ErrorUtilities.VerifyThrowArgument(\n+                (entryPoints == null) ^ (projectGraph == null),\n+                \"EitherEntryPointsOrTheProjectGraphIsSet\");\n+\n+            PluginPath = pluginPath;\n+            EntryPoints = entryPoints;\n+            ProjectGraph = projectGraph;\n+            PluginSettings = pluginSettings ?? new Dictionary<string, string>();\n+        }\n+\n+        /// <summary>\n+        ///     The path to the assembly containing the project cache plugin.\n+        /// </summary>\n+        public string PluginPath { get; }\n+\n+        /// <summary>\n+        ///     The entry points with which the plugin will be initialized.\n+        /// </summary>\n+        public IReadOnlyCollection<ProjectGraphEntryPoint>? EntryPoints { get; }\n+\n+        /// <summary>\n+        ///     The graph with which the plugin will be initialized.\n+        /// </summary>\n+        public ProjectGraph? ProjectGraph { get; }\n+\n+        public IReadOnlyDictionary<string, string> PluginSettings { get; }\n+\n+        public override string ToString()",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "It's only called once when a BuildManager session loads a plugin. I'll give it a different name to avoid having it called by accident.",
              "createdAt": "2020-12-29T00:05:12Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs",
              "diffHunk": "@@ -0,0 +1,71 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Graph;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public class ProjectCacheDescriptor\n+    {\n+        public ProjectCacheDescriptor(\n+            string pluginPath,\n+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,\n+            ProjectGraph? projectGraph,\n+            IReadOnlyDictionary<string, string>? pluginSettings = null)\n+        {\n+            ErrorUtilities.VerifyThrowArgument(\n+                (entryPoints == null) ^ (projectGraph == null),\n+                \"EitherEntryPointsOrTheProjectGraphIsSet\");\n+\n+            PluginPath = pluginPath;\n+            EntryPoints = entryPoints;\n+            ProjectGraph = projectGraph;\n+            PluginSettings = pluginSettings ?? new Dictionary<string, string>();\n+        }\n+\n+        /// <summary>\n+        ///     The path to the assembly containing the project cache plugin.\n+        /// </summary>\n+        public string PluginPath { get; }\n+\n+        /// <summary>\n+        ///     The entry points with which the plugin will be initialized.\n+        /// </summary>\n+        public IReadOnlyCollection<ProjectGraphEntryPoint>? EntryPoints { get; }\n+\n+        /// <summary>\n+        ///     The graph with which the plugin will be initialized.\n+        /// </summary>\n+        public ProjectGraph? ProjectGraph { get; }\n+\n+        public IReadOnlyDictionary<string, string> PluginSettings { get; }\n+\n+        public override string ToString()",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This will throw if there are no types that inherit from ProjectCacheBase, we'll probably want to detect that and log an error rather than an unhandled exception",
              "createdAt": "2020-12-19T00:06:35Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -0,0 +1,207 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Reflection;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.FileSystem;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    internal class ProjectCacheService\n+    {\n+        private readonly BuildManager _buildManager;\n+        private readonly PluginLoggerBase _logger;\n+        private readonly ProjectCacheDescriptor _projectCacheDescriptor;\n+        private readonly CancellationToken _cancellationToken;\n+        private readonly ProjectCacheBase _projectCachePlugin;\n+\n+        private ProjectCacheService(\n+            ProjectCacheBase projectCachePlugin,\n+            BuildManager buildManager,\n+            PluginLoggerBase logger,\n+            ProjectCacheDescriptor projectCacheDescriptor,\n+            CancellationToken cancellationToken)\n+        {\n+            _projectCachePlugin = projectCachePlugin;\n+            _buildManager = buildManager;\n+            _logger = logger;\n+            _projectCacheDescriptor = projectCacheDescriptor;\n+            _cancellationToken = cancellationToken;\n+        }\n+\n+        public static async Task<ProjectCacheService> FromDescriptorAsync(\n+            ProjectCacheDescriptor pluginDescriptor,\n+            BuildManager buildManager,\n+            ILoggingService loggingService,\n+            CancellationToken cancellationToken)\n+        {\n+            var plugin = await Task.Run(() => LoadPluginFromAssembly(pluginDescriptor.PluginPath), cancellationToken)\n+                .ConfigureAwait(false);\n+\n+            // TODO: Detect and use the highest verbosity from all the user defined loggers. That's tricky because right now we can't discern between user set loggers and msbuild's internally added loggers.\n+            var logger = new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService);\n+\n+            await plugin.BeginBuildAsync(\n+                new CacheContext(\n+                    pluginDescriptor.PluginSettings,\n+                    new IFileSystemAdapter(FileSystems.Default),\n+                    pluginDescriptor.ProjectGraph,\n+                    pluginDescriptor.EntryPoints),\n+                // TODO: Detect verbosity from logging service.\n+                logger,\n+                cancellationToken);\n+\n+            if (logger.HasLoggedErrors)\n+            {\n+                throw new Exception(\n+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\"ProjectCacheInitializationFailed\"));\n+            }\n+\n+            return new ProjectCacheService(plugin, buildManager, logger, pluginDescriptor, cancellationToken);\n+        }\n+\n+        private static ProjectCacheBase LoadPluginFromAssembly(string pluginAssemblyPath)\n+        {\n+            var assembly = LoadAssembly(pluginAssemblyPath);\n+\n+            var pluginType = GetTypes<ProjectCacheBase>(assembly).First();",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "Fixed it here https://github.com/dotnet/msbuild/pull/5936/files#diff-ac47163cf1a4ff2fbd79d56e0cf79ce9636b6a8331dfa89dae3fe8d3547f7fb3R109",
              "createdAt": "2020-12-29T00:06:42Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -0,0 +1,207 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Reflection;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.FileSystem;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    internal class ProjectCacheService\n+    {\n+        private readonly BuildManager _buildManager;\n+        private readonly PluginLoggerBase _logger;\n+        private readonly ProjectCacheDescriptor _projectCacheDescriptor;\n+        private readonly CancellationToken _cancellationToken;\n+        private readonly ProjectCacheBase _projectCachePlugin;\n+\n+        private ProjectCacheService(\n+            ProjectCacheBase projectCachePlugin,\n+            BuildManager buildManager,\n+            PluginLoggerBase logger,\n+            ProjectCacheDescriptor projectCacheDescriptor,\n+            CancellationToken cancellationToken)\n+        {\n+            _projectCachePlugin = projectCachePlugin;\n+            _buildManager = buildManager;\n+            _logger = logger;\n+            _projectCacheDescriptor = projectCacheDescriptor;\n+            _cancellationToken = cancellationToken;\n+        }\n+\n+        public static async Task<ProjectCacheService> FromDescriptorAsync(\n+            ProjectCacheDescriptor pluginDescriptor,\n+            BuildManager buildManager,\n+            ILoggingService loggingService,\n+            CancellationToken cancellationToken)\n+        {\n+            var plugin = await Task.Run(() => LoadPluginFromAssembly(pluginDescriptor.PluginPath), cancellationToken)\n+                .ConfigureAwait(false);\n+\n+            // TODO: Detect and use the highest verbosity from all the user defined loggers. That's tricky because right now we can't discern between user set loggers and msbuild's internally added loggers.\n+            var logger = new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService);\n+\n+            await plugin.BeginBuildAsync(\n+                new CacheContext(\n+                    pluginDescriptor.PluginSettings,\n+                    new IFileSystemAdapter(FileSystems.Default),\n+                    pluginDescriptor.ProjectGraph,\n+                    pluginDescriptor.EntryPoints),\n+                // TODO: Detect verbosity from logging service.\n+                logger,\n+                cancellationToken);\n+\n+            if (logger.HasLoggedErrors)\n+            {\n+                throw new Exception(\n+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\"ProjectCacheInitializationFailed\"));\n+            }\n+\n+            return new ProjectCacheService(plugin, buildManager, logger, pluginDescriptor, cancellationToken);\n+        }\n+\n+        private static ProjectCacheBase LoadPluginFromAssembly(string pluginAssemblyPath)\n+        {\n+            var assembly = LoadAssembly(pluginAssemblyPath);\n+\n+            var pluginType = GetTypes<ProjectCacheBase>(assembly).First();",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This sees expensive to form this string for every project, what else should we do here?",
              "createdAt": "2020-12-19T00:08:14Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -0,0 +1,207 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Reflection;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.FileSystem;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    internal class ProjectCacheService\n+    {\n+        private readonly BuildManager _buildManager;\n+        private readonly PluginLoggerBase _logger;\n+        private readonly ProjectCacheDescriptor _projectCacheDescriptor;\n+        private readonly CancellationToken _cancellationToken;\n+        private readonly ProjectCacheBase _projectCachePlugin;\n+\n+        private ProjectCacheService(\n+            ProjectCacheBase projectCachePlugin,\n+            BuildManager buildManager,\n+            PluginLoggerBase logger,\n+            ProjectCacheDescriptor projectCacheDescriptor,\n+            CancellationToken cancellationToken)\n+        {\n+            _projectCachePlugin = projectCachePlugin;\n+            _buildManager = buildManager;\n+            _logger = logger;\n+            _projectCacheDescriptor = projectCacheDescriptor;\n+            _cancellationToken = cancellationToken;\n+        }\n+\n+        public static async Task<ProjectCacheService> FromDescriptorAsync(\n+            ProjectCacheDescriptor pluginDescriptor,\n+            BuildManager buildManager,\n+            ILoggingService loggingService,\n+            CancellationToken cancellationToken)\n+        {\n+            var plugin = await Task.Run(() => LoadPluginFromAssembly(pluginDescriptor.PluginPath), cancellationToken)\n+                .ConfigureAwait(false);\n+\n+            // TODO: Detect and use the highest verbosity from all the user defined loggers. That's tricky because right now we can't discern between user set loggers and msbuild's internally added loggers.\n+            var logger = new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService);\n+\n+            await plugin.BeginBuildAsync(\n+                new CacheContext(\n+                    pluginDescriptor.PluginSettings,\n+                    new IFileSystemAdapter(FileSystems.Default),\n+                    pluginDescriptor.ProjectGraph,\n+                    pluginDescriptor.EntryPoints),\n+                // TODO: Detect verbosity from logging service.\n+                logger,\n+                cancellationToken);\n+\n+            if (logger.HasLoggedErrors)\n+            {\n+                throw new Exception(\n+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\"ProjectCacheInitializationFailed\"));\n+            }\n+\n+            return new ProjectCacheService(plugin, buildManager, logger, pluginDescriptor, cancellationToken);\n+        }\n+\n+        private static ProjectCacheBase LoadPluginFromAssembly(string pluginAssemblyPath)\n+        {\n+            var assembly = LoadAssembly(pluginAssemblyPath);\n+\n+            var pluginType = GetTypes<ProjectCacheBase>(assembly).First();\n+\n+            return (ProjectCacheBase) Activator.CreateInstance(pluginType);\n+\n+            Assembly LoadAssembly(string resolverPath)\n+            {\n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+                return Assembly.LoadFrom(resolverPath);\n+#else\n+                return _loader.LoadFromPath(resolverPath);\n+#endif\n+            }\n+\n+            IEnumerable<Type> GetTypes<T>(Assembly assembly)\n+            {\n+                return assembly.ExportedTypes\n+                    .Select(type => new {type, info = type.GetTypeInfo()})\n+                    .Where(\n+                        t => t.info.IsClass &&\n+                             t.info.IsPublic &&\n+                             !t.info.IsAbstract &&\n+                             typeof(T).IsAssignableFrom(t.type))\n+                    .Select(t => t.type);\n+            }\n+        }\n+\n+#if FEATURE_ASSEMBLYLOADCONTEXT\n+        private static readonly CoreClrAssemblyLoader _loader = new CoreClrAssemblyLoader();\n+#endif\n+\n+        public async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest)\n+        {\n+            // TODO: Parent these logs under the project build event so they appear nested under the project in the binlog viewer.\n+            var queryDescription = $\"{buildRequest.ProjectFullPath}\" +",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "Yes, it's not ideal. I want to leave it as is for now and redo it in a later PR where I tackle more logging issues, like parenting the query messages under their respective `ProjectStartedEventArgs` nodes.",
              "createdAt": "2020-12-29T00:11:38Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -0,0 +1,207 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Reflection;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.FileSystem;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    internal class ProjectCacheService\n+    {\n+        private readonly BuildManager _buildManager;\n+        private readonly PluginLoggerBase _logger;\n+        private readonly ProjectCacheDescriptor _projectCacheDescriptor;\n+        private readonly CancellationToken _cancellationToken;\n+        private readonly ProjectCacheBase _projectCachePlugin;\n+\n+        private ProjectCacheService(\n+            ProjectCacheBase projectCachePlugin,\n+            BuildManager buildManager,\n+            PluginLoggerBase logger,\n+            ProjectCacheDescriptor projectCacheDescriptor,\n+            CancellationToken cancellationToken)\n+        {\n+            _projectCachePlugin = projectCachePlugin;\n+            _buildManager = buildManager;\n+            _logger = logger;\n+            _projectCacheDescriptor = projectCacheDescriptor;\n+            _cancellationToken = cancellationToken;\n+        }\n+\n+        public static async Task<ProjectCacheService> FromDescriptorAsync(\n+            ProjectCacheDescriptor pluginDescriptor,\n+            BuildManager buildManager,\n+            ILoggingService loggingService,\n+            CancellationToken cancellationToken)\n+        {\n+            var plugin = await Task.Run(() => LoadPluginFromAssembly(pluginDescriptor.PluginPath), cancellationToken)\n+                .ConfigureAwait(false);\n+\n+            // TODO: Detect and use the highest verbosity from all the user defined loggers. That's tricky because right now we can't discern between user set loggers and msbuild's internally added loggers.\n+            var logger = new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService);\n+\n+            await plugin.BeginBuildAsync(\n+                new CacheContext(\n+                    pluginDescriptor.PluginSettings,\n+                    new IFileSystemAdapter(FileSystems.Default),\n+                    pluginDescriptor.ProjectGraph,\n+                    pluginDescriptor.EntryPoints),\n+                // TODO: Detect verbosity from logging service.\n+                logger,\n+                cancellationToken);\n+\n+            if (logger.HasLoggedErrors)\n+            {\n+                throw new Exception(\n+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(\"ProjectCacheInitializationFailed\"));\n+            }\n+\n+            return new ProjectCacheService(plugin, buildManager, logger, pluginDescriptor, cancellationToken);\n+        }\n+\n+        private static ProjectCacheBase LoadPluginFromAssembly(string pluginAssemblyPath)\n+        {\n+            var assembly = LoadAssembly(pluginAssemblyPath);\n+\n+            var pluginType = GetTypes<ProjectCacheBase>(assembly).First();\n+\n+            return (ProjectCacheBase) Activator.CreateInstance(pluginType);\n+\n+            Assembly LoadAssembly(string resolverPath)\n+            {\n+#if !FEATURE_ASSEMBLYLOADCONTEXT\n+                return Assembly.LoadFrom(resolverPath);\n+#else\n+                return _loader.LoadFromPath(resolverPath);\n+#endif\n+            }\n+\n+            IEnumerable<Type> GetTypes<T>(Assembly assembly)\n+            {\n+                return assembly.ExportedTypes\n+                    .Select(type => new {type, info = type.GetTypeInfo()})\n+                    .Where(\n+                        t => t.info.IsClass &&\n+                             t.info.IsPublic &&\n+                             !t.info.IsAbstract &&\n+                             typeof(T).IsAssignableFrom(t.type))\n+                    .Select(t => t.type);\n+            }\n+        }\n+\n+#if FEATURE_ASSEMBLYLOADCONTEXT\n+        private static readonly CoreClrAssemblyLoader _loader = new CoreClrAssemblyLoader();\n+#endif\n+\n+        public async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest)\n+        {\n+            // TODO: Parent these logs under the project build event so they appear nested under the project in the binlog viewer.\n+            var queryDescription = $\"{buildRequest.ProjectFullPath}\" +",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "how long do we plan on keeping this in the `Experimental` namespace?",
              "createdAt": "2020-12-22T20:39:26Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -10,7 +10,9 @@\n using Microsoft.Build.BackEnd;\n using Microsoft.Build.Collections;\n using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Experimental.ProjectCache;",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I'd like to keep it at least until we validate it working for two of our internal build accelerators.",
              "createdAt": "2020-12-29T00:14:05Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -10,7 +10,9 @@\n using Microsoft.Build.BackEnd;\n using Microsoft.Build.Collections;\n using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Experimental.ProjectCache;",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Should the summary descriptions be indented?",
              "createdAt": "2020-12-22T20:42:15Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs",
              "diffHunk": "@@ -0,0 +1,31 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Events logged with this logger will get pushed into MSBuild's logging infrastructure.\n+    /// </summary>\n+    public abstract class PluginLoggerBase\n+    {\n+        public PluginLoggerBase(LoggerVerbosity verbosity)\n+        {\n+            Verbosity = verbosity;\n+        }\n+\n+        /// <summary>\n+        ///     See <see cref=\"ILogger.Verbosity\" />",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "That's how the R# formatter did them. Let me know if you want it otherwise.",
              "createdAt": "2020-12-29T00:14:46Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs",
              "diffHunk": "@@ -0,0 +1,31 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Events logged with this logger will get pushed into MSBuild's logging infrastructure.\n+    /// </summary>\n+    public abstract class PluginLoggerBase\n+    {\n+        public PluginLoggerBase(LoggerVerbosity verbosity)\n+        {\n+            Verbosity = verbosity;\n+        }\n+\n+        /// <summary>\n+        ///     See <see cref=\"ILogger.Verbosity\" />",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I'm happy with them as-is.",
              "createdAt": "2020-12-31T19:42:02Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs",
              "diffHunk": "@@ -0,0 +1,31 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Events logged with this logger will get pushed into MSBuild's logging infrastructure.\n+    /// </summary>\n+    public abstract class PluginLoggerBase\n+    {\n+        public PluginLoggerBase(LoggerVerbosity verbosity)\n+        {\n+            Verbosity = verbosity;\n+        }\n+\n+        /// <summary>\n+        ///     See <see cref=\"ILogger.Verbosity\" />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "should we consider interning these generated paths?",
              "createdAt": "2020-12-22T23:58:34Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -1827,23 +1827,25 @@ private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(Proj\n                 return new DisposePluginService(null);\n             }\n \n-            var cacheItems = projectGraph.ProjectNodes\n-                .Select(n => n.ProjectInstance)\n-                .SelectMany(p => p.GetItems(ItemTypeNames.ProjectCachePlugin))\n-                .Select(\n-                    i =>\n-                    {\n-                        var metadataDictionary = i.Metadata.ToDictionary(\n-                            m => ((IKeyed) m).Key,\n-                            m => ((IValued) m).EscapedValue);\n+            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(\n+                n => n,\n+                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)\n+                    .Select(\n+                        i =>\n+                        {\n+                            var metadataDictionary = i.Metadata.ToDictionary(\n+                                m => ((IKeyed) m).Key,\n+                                m => ((IValued) m).EscapedValue);\n \n-                        var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n+                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Common case is for all nodes to define the same plugin, so the same plugin path string will get duplicated. But this method is called at most once per build and after it's done done all the strings will be thrown away and only one will remain so not worth interning in my opinion. ",
              "createdAt": "2020-12-29T18:29:15Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -1827,23 +1827,25 @@ private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(Proj\n                 return new DisposePluginService(null);\n             }\n \n-            var cacheItems = projectGraph.ProjectNodes\n-                .Select(n => n.ProjectInstance)\n-                .SelectMany(p => p.GetItems(ItemTypeNames.ProjectCachePlugin))\n-                .Select(\n-                    i =>\n-                    {\n-                        var metadataDictionary = i.Metadata.ToDictionary(\n-                            m => ((IKeyed) m).Key,\n-                            m => ((IValued) m).EscapedValue);\n+            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(\n+                n => n,\n+                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)\n+                    .Select(\n+                        i =>\n+                        {\n+                            var metadataDictionary = i.Metadata.ToDictionary(\n+                                m => ((IKeyed) m).Key,\n+                                m => ((IValued) m).EscapedValue);\n \n-                        var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n+                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's the purpose of `SelectMany` here?",
              "createdAt": "2020-12-23T00:10:03Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -1827,23 +1827,25 @@ private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(Proj\n                 return new DisposePluginService(null);\n             }\n \n-            var cacheItems = projectGraph.ProjectNodes\n-                .Select(n => n.ProjectInstance)\n-                .SelectMany(p => p.GetItems(ItemTypeNames.ProjectCachePlugin))\n-                .Select(\n-                    i =>\n-                    {\n-                        var metadataDictionary = i.Metadata.ToDictionary(\n-                            m => ((IKeyed) m).Key,\n-                            m => ((IValued) m).EscapedValue);\n+            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(\n+                n => n,\n+                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)\n+                    .Select(\n+                        i =>\n+                        {\n+                            var metadataDictionary = i.Metadata.ToDictionary(\n+                                m => ((IKeyed) m).Key,\n+                                m => ((IValued) m).EscapedValue);\n \n-                        var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n+                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n \n-                        var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n+                            var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n \n-                        return projectCacheItem;\n-                    })\n-                .ToHashSet();\n+                            return projectCacheItem;\n+                        })\n+                    .ToArray());\n+\n+            var cacheItems = nodeToCacheItems.Values.SelectMany(i => i).ToHashSet();",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I'm not sure I follow why the conversion to an array then a hashset, can't the list of items be stored as a hashset to begin with?",
              "createdAt": "2020-12-23T00:18:00Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -1827,23 +1827,25 @@ private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(Proj\n                 return new DisposePluginService(null);\n             }\n \n-            var cacheItems = projectGraph.ProjectNodes\n-                .Select(n => n.ProjectInstance)\n-                .SelectMany(p => p.GetItems(ItemTypeNames.ProjectCachePlugin))\n-                .Select(\n-                    i =>\n-                    {\n-                        var metadataDictionary = i.Metadata.ToDictionary(\n-                            m => ((IKeyed) m).Key,\n-                            m => ((IValued) m).EscapedValue);\n+            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(\n+                n => n,\n+                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)\n+                    .Select(\n+                        i =>\n+                        {\n+                            var metadataDictionary = i.Metadata.ToDictionary(\n+                                m => ((IKeyed) m).Key,\n+                                m => ((IValued) m).EscapedValue);\n \n-                        var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n+                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n \n-                        var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n+                            var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n \n-                        return projectCacheItem;\n-                    })\n-                .ToHashSet();\n+                            return projectCacheItem;\n+                        })\n+                    .ToArray());\n+\n+            var cacheItems = nodeToCacheItems.Values.SelectMany(i => i).ToHashSet();",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "It's inconsequential, I think. Each node can declare zero or more plugins, so first I construct a dictionary from a node to the collection of plugins it declares. But the contract is that there can be a single plugin (path + plugin settings), and all nodes must declare that plugin. So in order to find that single plugin I flatten (SelectMany) the collections of plugins from each node into a single set (ProjectCacheItem implements Equals and GetHashCode to make this correct). I could have skipped the dictionary by flattening everything from the start, but I also want to give a nice error message with all the nodes that may be missing the plugin. And given that this method is not on a hot path, I went with a lot of LINQ :)",
              "createdAt": "2020-12-29T19:02:16Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -1827,23 +1827,25 @@ private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(Proj\n                 return new DisposePluginService(null);\n             }\n \n-            var cacheItems = projectGraph.ProjectNodes\n-                .Select(n => n.ProjectInstance)\n-                .SelectMany(p => p.GetItems(ItemTypeNames.ProjectCachePlugin))\n-                .Select(\n-                    i =>\n-                    {\n-                        var metadataDictionary = i.Metadata.ToDictionary(\n-                            m => ((IKeyed) m).Key,\n-                            m => ((IValued) m).EscapedValue);\n+            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(\n+                n => n,\n+                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)\n+                    .Select(\n+                        i =>\n+                        {\n+                            var metadataDictionary = i.Metadata.ToDictionary(\n+                                m => ((IKeyed) m).Key,\n+                                m => ((IValued) m).EscapedValue);\n \n-                        var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n+                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n \n-                        var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n+                            var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n \n-                        return projectCacheItem;\n-                    })\n-                .ToHashSet();\n+                            return projectCacheItem;\n+                        })\n+                    .ToArray());\n+\n+            var cacheItems = nodeToCacheItems.Values.SelectMany(i => i).ToHashSet();",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I'm not sure I follow everything here. Wouldn't this be union rather than intersection, so wouldn't this find all the plugins declared by any node? How does this help you find the one from all of them? And I'm not sure how I follow how this turns into an error.",
              "createdAt": "2020-12-30T00:53:14Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -1827,23 +1827,25 @@ private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(Proj\n                 return new DisposePluginService(null);\n             }\n \n-            var cacheItems = projectGraph.ProjectNodes\n-                .Select(n => n.ProjectInstance)\n-                .SelectMany(p => p.GetItems(ItemTypeNames.ProjectCachePlugin))\n-                .Select(\n-                    i =>\n-                    {\n-                        var metadataDictionary = i.Metadata.ToDictionary(\n-                            m => ((IKeyed) m).Key,\n-                            m => ((IValued) m).EscapedValue);\n+            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(\n+                n => n,\n+                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)\n+                    .Select(\n+                        i =>\n+                        {\n+                            var metadataDictionary = i.Metadata.ToDictionary(\n+                                m => ((IKeyed) m).Key,\n+                                m => ((IValued) m).EscapedValue);\n \n-                        var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n+                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n \n-                        var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n+                            var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n \n-                        return projectCacheItem;\n-                    })\n-                .ToHashSet();\n+                            return projectCacheItem;\n+                        })\n+                    .ToArray());\n+\n+            var cacheItems = nodeToCacheItems.Values.SelectMany(i => i).ToHashSet();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This part constructs a dictionary from every node to all the declared plugins in that node:\r\nhttps://github.com/cdmihai/msbuild/blob/acb4b7e2e0ffbd4a9df13c6fba11dd6aa5f37944/src/Build/BackEnd/BuildManager/BuildManager.cs#L1866-L1882\r\n\r\nThis part flattens (via SelectMany) all the declared plugins into a single set which removes the duplicates according to the overriden equals and hashcode in [ProjectCacheItem](https://github.com/cdmihai/msbuild/blob/acb4b7e2e0ffbd4a9df13c6fba11dd6aa5f37944/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs#L29-L69).\r\nhttps://github.com/cdmihai/msbuild/blob/acb4b7e2e0ffbd4a9df13c6fba11dd6aa5f37944/src/Build/BackEnd/BuildManager/BuildManager.cs#L1884\r\n\r\nThe set should contain a single item if all nodes declare a single plugin (plugin path + plugin settings).\r\n\r\nError cases:\r\n- set contains more than 1 plugins (error prints all declared plugins)\r\n- set contains a single plugin but there are nodes which do not declare it (error prints all nodes that do not declare the plugin)",
              "createdAt": "2020-12-30T23:08:05Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -1827,23 +1827,25 @@ private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(Proj\n                 return new DisposePluginService(null);\n             }\n \n-            var cacheItems = projectGraph.ProjectNodes\n-                .Select(n => n.ProjectInstance)\n-                .SelectMany(p => p.GetItems(ItemTypeNames.ProjectCachePlugin))\n-                .Select(\n-                    i =>\n-                    {\n-                        var metadataDictionary = i.Metadata.ToDictionary(\n-                            m => ((IKeyed) m).Key,\n-                            m => ((IValued) m).EscapedValue);\n+            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(\n+                n => n,\n+                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)\n+                    .Select(\n+                        i =>\n+                        {\n+                            var metadataDictionary = i.Metadata.ToDictionary(\n+                                m => ((IKeyed) m).Key,\n+                                m => ((IValued) m).EscapedValue);\n \n-                        var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n+                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n \n-                        var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n+                            var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n \n-                        return projectCacheItem;\n-                    })\n-                .ToHashSet();\n+                            return projectCacheItem;\n+                        })\n+                    .ToArray());\n+\n+            var cacheItems = nodeToCacheItems.Values.SelectMany(i => i).ToHashSet();",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Neat! Didn't realize SelectMany also flattened. If I were writing it, I might have said `nodeToCacheItems.Values.Aggregate((x, y) => x.Union(y));`, but I don't think that's better (or worse) than what you currently have.\r\n\r\nI was originally confused in thinking that a given node could declare multiple plugins, and it was ok as long as only one of those was declared by _all_ nodes, but I see that was wrong. Makes more sense now.",
              "createdAt": "2020-12-30T23:55:56Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -1827,23 +1827,25 @@ private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(Proj\n                 return new DisposePluginService(null);\n             }\n \n-            var cacheItems = projectGraph.ProjectNodes\n-                .Select(n => n.ProjectInstance)\n-                .SelectMany(p => p.GetItems(ItemTypeNames.ProjectCachePlugin))\n-                .Select(\n-                    i =>\n-                    {\n-                        var metadataDictionary = i.Metadata.ToDictionary(\n-                            m => ((IKeyed) m).Key,\n-                            m => ((IValued) m).EscapedValue);\n+            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(\n+                n => n,\n+                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)\n+                    .Select(\n+                        i =>\n+                        {\n+                            var metadataDictionary = i.Metadata.ToDictionary(\n+                                m => ((IKeyed) m).Key,\n+                                m => ((IValued) m).EscapedValue);\n \n-                        var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n+                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);\n \n-                        var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n+                            var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);\n \n-                        return projectCacheItem;\n-                    })\n-                .ToHashSet();\n+                            return projectCacheItem;\n+                        })\n+                    .ToArray());\n+\n+            var cacheItems = nodeToCacheItems.Values.SelectMany(i => i).ToHashSet();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\nProject cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\r\n```\r\n\r\n\"assembly-based plugin extension point\" was a little confusing to me. Too many descriptors in a row. Not sure that's fixable.\r\n\r\nDo you think it should be a permalink? I think it's better as-is, since we're more likely to change the documentation than move it, I think? Still thought it worth raising.",
              "createdAt": "2020-12-29T22:06:20Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yea, more likely to update it than to move it. Permalink would freeze it whereas now it shows the latest version which I think that's better.",
              "createdAt": "2020-12-30T23:18:26Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nAs the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.\r\n```\r\n\r\nA lot of people read paragraph-by-paragraph, and ending a paragraph with a suggestion to replace MSBuild might send the wrong message. Also, I don't think an explanation of MSBuild's importance is really relevant here.",
              "createdAt": "2020-12-29T22:13:57Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nVisual Studio is one beneficiary. This plugin inverts dependencies among build systems: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild calls into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\r\n```",
              "createdAt": "2020-12-29T22:25:19Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThis change also simplifies and unifies user experiences. MSBuild works the same from Visual Studio or the command line without dramatically changing how it works.\r\n```",
              "createdAt": "2020-12-29T22:40:21Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n- Tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\r\n```",
              "createdAt": "2020-12-29T22:42:10Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "what returns? the plugin?",
              "createdAt": "2020-12-29T22:43:13Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The format shifts among these bullets, and that makes it kinda confusing.",
              "createdAt": "2020-12-29T22:44:29Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n# High-level design\r\n```",
              "createdAt": "2020-12-29T22:44:39Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "?",
              "createdAt": "2020-12-29T22:52:04Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "bump empty link",
              "createdAt": "2020-12-29T22:52:39Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could we do this eagerly in the background at the end of solution load? Impossible because they'd need to specify the plugin between loading the solution and when this ran?",
              "createdAt": "2020-12-29T23:03:42Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "We need the first build request because that's the first time MSBuild knows about the solution path (set by VS as the `SolutionPath` global property on the build request). The solution path is sent as the  graph entry point to the plugin which can use it to initialize its own static graph. Ideally, at some point, we'll delete this workaround in favor of VS setting BuildParameters.ProjectCacheDescriptor.",
              "createdAt": "2020-12-31T00:17:24Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Does solution load time count as the first build request, then? Since it clearly has to know the solution path as it's loading the solution.",
              "createdAt": "2020-12-31T18:48:49Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "No, the first non design time build request happens when the users triggers a real build.",
              "createdAt": "2020-12-31T19:02:29Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "So at solution load time, we have the solution path so we can load the solution. What's stopping us from kicking off a background process to check for plugins and possibly instantiate it?",
              "createdAt": "2020-12-31T19:49:25Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Being able to easily change VS' solution loading code is what's stopping us :) At some point in the future after we have a high confidence in the plugin APIs we'll attempt that as well.",
              "createdAt": "2020-12-31T21:37:34Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Doesn't this still assume no side-effects?",
              "createdAt": "2020-12-29T23:12:45Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Saving the build results would happen on the builder node (cloudbuild or anybuild builder nodes) which builds a project via msbuild.exe and writes the IO side effects to the cache. Later, when the msbuild plugin retrieves that cache entry, it will also retrieve the serialized BuildResults.",
              "createdAt": "2020-12-31T00:23:55Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How would I pass this?",
              "createdAt": "2020-12-29T23:14:15Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Via this API: https://github.com/cdmihai/msbuild/blob/acb4b7e2e0ffbd4a9df13c6fba11dd6aa5f37944/src/Build/BackEnd/BuildManager/BuildManager.cs#L705",
              "createdAt": "2020-12-31T00:25:00Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\r\n```",
              "createdAt": "2020-12-29T23:15:32Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n+- Logging\n+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n+  - Log messages from querying a project get parented under that project's logging context.\n+  - This is not yet implemented. For now, all plugin log messages do not have a parent event context.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe something extra that lets you specify the path to the entry point(s) on that machine and take that away from other absolute paths?",
              "createdAt": "2020-12-29T23:17:08Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n+- Logging\n+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n+  - Log messages from querying a project get parented under that project's logging context.\n+  - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+# Caveats\n+- Absolute paths circulating through the saved build results\n+  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yea, something like that. The plugin already knows the entry points, so it could rebase all paths when deserializing, but that gets expensive.\r\nIt's only a real issue when plugins will start serializing the build results.",
              "createdAt": "2020-12-31T00:36:25Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n+- Logging\n+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n+  - Log messages from querying a project get parented under that project's logging context.\n+  - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+# Caveats\n+- Absolute paths circulating through the saved build results\n+  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This sounds expensive. Pinging for connection speed and deciding based on that would be faster.",
              "createdAt": "2020-12-29T23:18:01Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n+- Logging\n+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n+  - Log messages from querying a project get parented under that project's logging context.\n+  - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+# Caveats\n+- Absolute paths circulating through the saved build results\n+  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.\n+- Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It's more like speculative execution. The only expensive part is bandwidth flooding with unneeded cache queries. We'll cross this bridge when we get to it. Maybe the simplest solution is to just have the user disable caching on slow connections.",
              "createdAt": "2020-12-31T00:39:53Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n+- Logging\n+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n+  - Log messages from querying a project get parented under that project's logging context.\n+  - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+# Caveats\n+- Absolute paths circulating through the saved build results\n+  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.\n+- Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is more attention to network speeds than I'd expected, so I think I'm missing something. Are the caches normally expected to be off the computer? I would've expected you to build once, for the cache to be created, and for the next time you build/start up VS/etc. to be faster because of it. If it's all off the computer, could it be included as part of downloading?",
              "createdAt": "2020-12-29T23:22:36Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n+- Logging\n+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n+  - Log messages from querying a project get parented under that project's logging context.\n+  - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+# Caveats\n+- Absolute paths circulating through the saved build results\n+  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.\n+- Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.\n+- Inferring what targets to run on each node when using /graph\n+  - Msbuild /graph requires that the [target inference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It's up to each plugin's implementation how it handles this, but generally the cache entries need to be initially downloaded, but after that they get stored in a local cache and reused until they get invalidated by local changes.",
              "createdAt": "2020-12-31T00:43:26Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n+- Logging\n+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n+  - Log messages from querying a project get parented under that project's logging context.\n+  - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+# Caveats\n+- Absolute paths circulating through the saved build results\n+  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.\n+- Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.\n+- Inferring what targets to run on each node when using /graph\n+  - Msbuild /graph requires that the [target inference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n- Enable plugins to work with the just-in-time top down msbuild traversal that msbuild natively does when it's not using `/graph`.\r\n```\r\n\r\nIs this not a common case? It sounds quite valuable to me.",
              "createdAt": "2020-12-29T23:24:58Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n+- Logging\n+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n+  - Log messages from querying a project get parented under that project's logging context.\n+  - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+# Caveats\n+- Absolute paths circulating through the saved build results\n+  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.\n+- Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.\n+- Inferring what targets to run on each node when using /graph\n+  - Msbuild /graph requires that the [target inference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.\n+- Small repos will probably be slower with plugin implementations that access the network. Remote distribution and caching will only be worth it for repos that are large enough.\n+\n+# Future work\n+- On cache misses plugins can build the project with IO monitoring and write to the local cache. As far as we can tell there are two main possibilities:\n+  - plugins build the projects themselves in isolation (without projects building their reference, probably by setting `BuildProjectReferences` to false) by calling msbuild.exe.\n+  - plugins request msbuild to build the projects on special out of proc nodes whose IO system calls can be monitored.\n+\n+# Potential work of dubious value\n+- Allow multiple plugin instances and query them based on some priority, similar to sdk resolvers.\n+- Enable plugins to work with the just in time top down msbuild traversal that msbuild natively does when it's not using `/graph`.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Project caching is more oriented towards very big repos whose teams are willing to invest constant time on maintaining high build cacheability (it constantly degrades as people add more nondeterminism to their build and do other bad things). At those sizes it does not really make sense to not build with a static graph, as that also exposes all the potential parallelism in a build, which starts to get noticeable on large graphs. So the top down traversal is okay mostly for small-ish repos that would probably not benefit very much from caching anyway. So supporting top down is a **lot** of work without clear benefits.",
              "createdAt": "2020-12-31T00:53:39Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n+- Logging\n+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n+  - Log messages from querying a project get parented under that project's logging context.\n+  - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+# Caveats\n+- Absolute paths circulating through the saved build results\n+  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.\n+- Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.\n+- Inferring what targets to run on each node when using /graph\n+  - Msbuild /graph requires that the [target inference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.\n+- Small repos will probably be slower with plugin implementations that access the network. Remote distribution and caching will only be worth it for repos that are large enough.\n+\n+# Future work\n+- On cache misses plugins can build the project with IO monitoring and write to the local cache. As far as we can tell there are two main possibilities:\n+  - plugins build the projects themselves in isolation (without projects building their reference, probably by setting `BuildProjectReferences` to false) by calling msbuild.exe.\n+  - plugins request msbuild to build the projects on special out of proc nodes whose IO system calls can be monitored.\n+\n+# Potential work of dubious value\n+- Allow multiple plugin instances and query them based on some priority, similar to sdk resolvers.\n+- Enable plugins to work with the just in time top down msbuild traversal that msbuild natively does when it's not using `/graph`.",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I like it!",
              "createdAt": "2020-12-29T23:25:49Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -0,0 +1,134 @@\n+- [Summary](#summary)\n+- [Motivation](#motivation)\n+- [Plugin requirements](#plugin-requirements)\n+- [High level design](#high-level-design)\n+- [APIs and calling patterns](#apis-and-calling-patterns)\n+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)\n+  - [From command line](#from-command-line)\n+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)\n+- [Details](#details)\n+- [Caveats](#caveats)\n+- [Future work](#future-work)\n+- [Potential work of dubious value](#potential-work-of-dubious-value)\n+\n+# Summary\n+\n+Project cache is a new assembly based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and / or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).\n+\n+# Motivation\n+\n+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, as a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent and build times get very long. This suggests MSBuild needs to change or get replaced in order to scale.\n+However, many users and tools depend on MSBuild's current APIs and language semantics. This makes MSBuild very hard to significantly change or replace, as it would induce a big cost to users. The project cache plugin allows MSBuild to natively communicate with existing tools that enable build caching and / or distribution but without changing its public API and user interface (too much).\n+\n+For example, it allows Visual Studio builds to benefit from caching and distribution without extensive changes to Visual Studio. The plugin achieves a dependency inversion: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild will call into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.\n+\n+Users also reuse their investment in learning MSBuild's mental models, command line experience, logging formats, etc. Furthermore, user cognitive load is reduced by having the same build experience between Visual Studio and command line. Before, users with access to higher level build engines would use that tool from the command line, but it would have a different experience from the build experience that Visual Studio provided.\n+\n+# Plugin requirements\n+- Respond to MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n+  - the filesystem looks as if the project built\n+  - returns sufficient information that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+- New MSBuild execution mode where it can query the plugin but not build anything.\n+- Do not impose constraints in addition to static graph and the plugin's constraints.\n+\n+# High level design\n+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+- A single plugin is supported (for now).\n+\n+# APIs and calling patterns\n+- Plugin APIs are found [here]().\n+\n+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n+- Users set [BuildParameters.ProjectCacheDescriptor]() which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n+\n+## From command line\n+- Requires /graph. It is the easiest way to implement the plugin:\n+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+- User calls msbuild /graph.\n+- MSBuild constructs the static graph.\n+- The graph builder finds and loads the plugin into the `BuildManager`.\n+  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n+  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n+\n+## From Visual Studio, a temporary workaround\n+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n+  - The workaround logic activates only when MSBuild detects that it's running under VS.\n+  - Plugin discovery\n+    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+  - Plugin usage:\n+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n+\n+# Details\n+- Plugin discovery\n+  - Each project defines an item containing the path to the plugin DLL:\n+```xml\n+<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+```\n+- Plugin acquisition\n+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n+- Defining the \"graph\" when static graph is not available\n+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n+- Returning a valid BuildResult object on cache hits.\n+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+  - Plugins have three options:\n+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.\n+      - Proxy target assumptions:\n+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n+        - They do not mutate state (file system, environment variables, etc).\n+        - They do not MSBuild task call into other projects.\n+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n+    - Best: when the plugins run and cache the build, they tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n+- Configuring plugins\n+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+```xml\n+<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+```\n+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n+  - From command line: `msbuild /graph:NoBuild`\n+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n+- Logging\n+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n+  - Log messages from querying a project get parented under that project's logging context.\n+  - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+# Caveats\n+- Absolute paths circulating through the saved build results\n+  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.\n+- Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.\n+- Inferring what targets to run on each node when using /graph\n+  - Msbuild /graph requires that the [target inference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.\n+- Small repos will probably be slower with plugin implementations that access the network. Remote distribution and caching will only be worth it for repos that are large enough.\n+\n+# Future work\n+- On cache misses plugins can build the project with IO monitoring and write to the local cache. As far as we can tell there are two main possibilities:\n+  - plugins build the projects themselves in isolation (without projects building their reference, probably by setting `BuildProjectReferences` to false) by calling msbuild.exe.\n+  - plugins request msbuild to build the projects on special out of proc nodes whose IO system calls can be monitored.\n+\n+# Potential work of dubious value\n+- Allow multiple plugin instances and query them based on some priority, similar to sdk resolvers.\n+- Enable plugins to work with the just in time top down msbuild traversal that msbuild natively does when it's not using `/graph`.\n+- Extend the project cache API to allow skipping individual targets or tasks instead of entire projects. This would allow for smaller specialized plugins, like plugins that only know to distribute, cache, and skip CSC.exe calls.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you need this? If so, I think we'd have to update VS's version, too.",
              "createdAt": "2020-12-29T23:26:52Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -37,7 +38,7 @@\n     <PackageReference Update=\"System.Security.Permissions\" Version=\"4.7.0\" />\n     <PackageReference Update=\"System.Security.Principal.Windows\" Version=\"4.7.0\" />\n     <PackageReference Update=\"System.Text.Encoding.CodePages\" Version=\"4.0.1\" />\n-    <PackageReference Update=\"System.Text.Json\" Version=\"4.7.0\" />\n+    <PackageReference Update=\"System.Text.Json\" Version=\"4.7.2\" />",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, it breaks quickbuild's plugin because of a forced downstream package downgrade (forgot which one). How does one update VS's version?",
              "createdAt": "2020-12-31T00:55:51Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -37,7 +38,7 @@\n     <PackageReference Update=\"System.Security.Permissions\" Version=\"4.7.0\" />\n     <PackageReference Update=\"System.Security.Principal.Windows\" Version=\"4.7.0\" />\n     <PackageReference Update=\"System.Text.Encoding.CodePages\" Version=\"4.0.1\" />\n-    <PackageReference Update=\"System.Text.Json\" Version=\"4.7.0\" />\n+    <PackageReference Update=\"System.Text.Json\" Version=\"4.7.2\" />",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Turns out VS actually references 4.7.2: https://devdiv.visualstudio.com/DevDiv/_git/VS?path=%2F.corext%2FConfigs%2Fdefault.config&version=GBmain&line=301&lineEnd=302&lineStartColumn=1&lineEndColumn=1&lineStyle=plain&_a=contents\r\n",
              "createdAt": "2021-01-05T19:39:23Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -37,7 +38,7 @@\n     <PackageReference Update=\"System.Security.Permissions\" Version=\"4.7.0\" />\n     <PackageReference Update=\"System.Security.Principal.Windows\" Version=\"4.7.0\" />\n     <PackageReference Update=\"System.Text.Encoding.CodePages\" Version=\"4.0.1\" />\n-    <PackageReference Update=\"System.Text.Json\" Version=\"4.7.0\" />\n+    <PackageReference Update=\"System.Text.Json\" Version=\"4.7.2\" />",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Bonkers! Ok. I guess someone changed it, and I forgot. Makes it easy.",
              "createdAt": "2021-01-05T22:41:08Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -37,7 +38,7 @@\n     <PackageReference Update=\"System.Security.Permissions\" Version=\"4.7.0\" />\n     <PackageReference Update=\"System.Security.Principal.Windows\" Version=\"4.7.0\" />\n     <PackageReference Update=\"System.Text.Encoding.CodePages\" Version=\"4.0.1\" />\n-    <PackageReference Update=\"System.Text.Json\" Version=\"4.7.0\" />\n+    <PackageReference Update=\"System.Text.Json\" Version=\"4.7.2\" />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why do several test classes need this?",
              "createdAt": "2020-12-29T23:27:26Z",
              "path": "src/Build.UnitTests/BackEnd/BuildResult_Tests.cs",
              "diffHunk": "@@ -5,6 +5,7 @@\n using System.Collections.Generic;\n \n using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Engine.UnitTests.TestComparers;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "To access common comparers like the [TaskItemComparer](https://github.com/cdmihai/msbuild/blob/7429f34ab9d7536f6b384ff8e620e89c9e0df7ba/src/Build.UnitTests/TestComparers/TaskItemComparer.cs#L13).",
              "createdAt": "2020-12-31T01:18:23Z",
              "path": "src/Build.UnitTests/BackEnd/BuildResult_Tests.cs",
              "diffHunk": "@@ -5,6 +5,7 @@\n using System.Collections.Generic;\n \n using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Engine.UnitTests.TestComparers;",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this ok? I thought this might deadlock.",
              "createdAt": "2020-12-29T23:39:40Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -751,6 +785,8 @@ public void EndBuild()\n                 // Stop the graph scheduling thread(s)\n                 _graphSchedulingCancellationSource?.Cancel();\n \n+                var projectCacheShutdown = _projectCacheService?.Result.ShutDown();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "How would it deadlock?",
              "createdAt": "2020-12-31T01:19:16Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -751,6 +785,8 @@ public void EndBuild()\n                 // Stop the graph scheduling thread(s)\n                 _graphSchedulingCancellationSource?.Cancel();\n \n+                var projectCacheShutdown = _projectCacheService?.Result.ShutDown();",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I don't remember; I just remember having been told at some point not to use .Result.",
              "createdAt": "2020-12-31T18:26:31Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -751,6 +785,8 @@ public void EndBuild()\n                 // Stop the graph scheduling thread(s)\n                 _graphSchedulingCancellationSource?.Cancel();\n \n+                var projectCacheShutdown = _projectCacheService?.Result.ShutDown();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't care for this change.",
              "createdAt": "2020-12-29T23:52:03Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "What does that mean?",
              "createdAt": "2020-12-31T01:22:14Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I know we don't agree on when you should declare a variable with var, but there are quite a few places in this PR that were rendered very hard to understand by unclear types. You're hiding information that could help me understand this code for no real reason. Furthermore, if something changes, and you accidentally change the type of ProjectInstance, this code will scream at you to fix it\u2014but only if you specify the type. In this case, you changed from specifying a type to not specifying a type with _no other change_, which just hurt. Undo it.",
              "createdAt": "2020-12-31T18:38:58Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please undo",
              "createdAt": "2020-12-29T23:52:32Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't agree with omnisharp here either.",
              "createdAt": "2020-12-29T23:53:07Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't like any of the other type -> var conversions either, or some of omnisharp's other changes, but I'll stop commenting.",
              "createdAt": "2020-12-29T23:53:51Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It feels a little bad to call it a workaround in shipping code.",
              "createdAt": "2020-12-29T23:58:03Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "But it's a good reminder that it is a workaround until we change VS. :)\r\nFeel free to suggest a more meaningful name.",
              "createdAt": "2020-12-31T01:30:46Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "AutomaticallyDetectAndInstantiateProjectCacheService?",
              "createdAt": "2020-12-31T19:07:50Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio?",
              "createdAt": "2020-12-31T21:57:28Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Sounds good to me!",
              "createdAt": "2021-01-04T17:59:47Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe add parentheses to this line for clarity?",
              "createdAt": "2020-12-30T00:01:43Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);\n+\n+                        CacheResult cacheResult = null;\n+                        if (_projectCacheService != null)\n                         {\n-                            tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n-                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            cacheResult = QueryCache(submission, newConfiguration);\n                         }\n \n-                        submission.BuildRequestData.ProjectFullPath = Path.Combine(\n-                            submission.BuildRequestData.ProjectInstance\n-                                .GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue, tempName);\n-                    }\n+                        if (cacheResult == null || cacheResult.ResultType != CacheResultType.CacheHit)\n+                        {\n+                            // Issue the real build request.\n+                            SubmitBuildRequest();\n+                        }\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)\n+                        {\n+                            // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid ProjectInstance serialization).\n+                            // The proxy target results are used as results for the real targets.\n \n-                    // Create/Retrieve a configuration for each request\n-                    BuildRequestConfiguration buildRequestConfiguration =\n-                        new BuildRequestConfiguration(submission.BuildRequestData,\n-                            _buildParameters.DefaultToolsVersion);\n-                    BuildRequestConfiguration matchingConfiguration =\n-                        _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n-                    BuildRequestConfiguration newConfiguration = ResolveConfiguration(buildRequestConfiguration,\n-                        matchingConfiguration,\n-                        submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags\n-                            .ReplaceExistingProjectInstance));\n-\n-                    newConfiguration.ExplicitlyLoaded = true;\n-\n-                    // Now create the build request\n-                    submission.BuildRequest = new BuildRequest(\n-                        submission.SubmissionId,\n-                        BackEnd.BuildRequest.InvalidNodeRequestId,\n-                        newConfiguration.ConfigurationId,\n-                        submission.BuildRequestData.TargetNames,\n-                        submission.BuildRequestData.HostServices,\n-                        BuildEventContext.Invalid,\n-                        null,\n-                        submission.BuildRequestData.Flags,\n-                        submission.BuildRequestData.RequestedProjectState);\n+                            submission.BuildRequest = CreateProxyBuildRequest(\n+                                submission,\n+                                newConfiguration.ConfigurationId,\n+                                cacheResult.ProxyTargets);\n \n-                    if (_shuttingDown)\n-                    {\n-                        // We were already canceled!\n-                        BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n-                        submission.CompleteResults(result);\n-                        submission.CompleteLogging(true);\n-                        CheckSubmissionCompletenessAndRemove(submission);\n-                        return;\n-                    }\n-\n-                    // Submit the build request.\n-                    _workQueue.Post(() =>\n-                    {\n-                        try\n-                        {\n-                            IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                            SubmitBuildRequest();\n                         }\n-                        catch (BuildAbortedException bae)\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)\n                         {\n-                            // We were canceled before we got issued by the work queue.\n-                            var result = new BuildResult(submission.BuildRequest, bae);\n-                            submission.CompleteResults(result);\n-                            submission.CompleteLogging(true);\n-                            CheckSubmissionCompletenessAndRemove(submission);\n+                            // Mark the build submission as complete with the provided results and return.\n+                            var result = new BuildResult(submission.BuildRequest);\n+\n+                            foreach (var targetResult in cacheResult.BuildResult.ResultsByTarget)\n+                            {\n+                                result.AddResultsForTarget(targetResult.Key, targetResult.Value);\n+                            }\n+\n+                            _resultsCache.AddResult(result);\n+                            submission.CompleteLogging(false);\n+                            ReportResultsToSubmission(result);\n                         }\n-                        catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    }\n+                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    {\n+                        HandleExecuteSubmissionException(submission, ex);\n+                        throw;\n+                    }\n+                    catch (Exception ex) when (thisMethodIsAsync)\n+                    {\n+                        OnThreadException(ex);\n+                    }\n+                    void SubmitBuildRequest()\n+                    {\n+                        if (CheckForShutdown())\n                         {\n-                            HandleExecuteSubmissionException(submission, ex);\n+                            return;\n                         }\n-                    });\n+\n+                        _workQueue.Post(\n+                            () =>\n+                            {\n+                                try\n+                                {\n+                                    IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                                }\n+                                catch (BuildAbortedException bae)\n+                                {\n+                                    // We were canceled before we got issued by the work queue.\n+                                    var result = new BuildResult(submission.BuildRequest, bae);\n+                                    submission.CompleteResults(result);\n+                                    submission.CompleteLogging(true);\n+                                    CheckSubmissionCompletenessAndRemove(submission);\n+                                }\n+                                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                                {\n+                                    HandleExecuteSubmissionException(submission, ex);\n+                                }\n+                            });\n+                    }\n                 }\n-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+            }\n+\n+            bool ProjectCacheIsPresent()\n+            {\n+                return _projectCacheService != null ||\n+                       _buildParameters.ProjectCacheDescriptor != null ||\n+                       BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Count > 0;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Other instance of _deadlock?",
              "createdAt": "2020-12-30T00:04:07Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);\n+\n+                        CacheResult cacheResult = null;\n+                        if (_projectCacheService != null)\n                         {\n-                            tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n-                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            cacheResult = QueryCache(submission, newConfiguration);\n                         }\n \n-                        submission.BuildRequestData.ProjectFullPath = Path.Combine(\n-                            submission.BuildRequestData.ProjectInstance\n-                                .GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue, tempName);\n-                    }\n+                        if (cacheResult == null || cacheResult.ResultType != CacheResultType.CacheHit)\n+                        {\n+                            // Issue the real build request.\n+                            SubmitBuildRequest();\n+                        }\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)\n+                        {\n+                            // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid ProjectInstance serialization).\n+                            // The proxy target results are used as results for the real targets.\n \n-                    // Create/Retrieve a configuration for each request\n-                    BuildRequestConfiguration buildRequestConfiguration =\n-                        new BuildRequestConfiguration(submission.BuildRequestData,\n-                            _buildParameters.DefaultToolsVersion);\n-                    BuildRequestConfiguration matchingConfiguration =\n-                        _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n-                    BuildRequestConfiguration newConfiguration = ResolveConfiguration(buildRequestConfiguration,\n-                        matchingConfiguration,\n-                        submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags\n-                            .ReplaceExistingProjectInstance));\n-\n-                    newConfiguration.ExplicitlyLoaded = true;\n-\n-                    // Now create the build request\n-                    submission.BuildRequest = new BuildRequest(\n-                        submission.SubmissionId,\n-                        BackEnd.BuildRequest.InvalidNodeRequestId,\n-                        newConfiguration.ConfigurationId,\n-                        submission.BuildRequestData.TargetNames,\n-                        submission.BuildRequestData.HostServices,\n-                        BuildEventContext.Invalid,\n-                        null,\n-                        submission.BuildRequestData.Flags,\n-                        submission.BuildRequestData.RequestedProjectState);\n+                            submission.BuildRequest = CreateProxyBuildRequest(\n+                                submission,\n+                                newConfiguration.ConfigurationId,\n+                                cacheResult.ProxyTargets);\n \n-                    if (_shuttingDown)\n-                    {\n-                        // We were already canceled!\n-                        BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n-                        submission.CompleteResults(result);\n-                        submission.CompleteLogging(true);\n-                        CheckSubmissionCompletenessAndRemove(submission);\n-                        return;\n-                    }\n-\n-                    // Submit the build request.\n-                    _workQueue.Post(() =>\n-                    {\n-                        try\n-                        {\n-                            IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                            SubmitBuildRequest();\n                         }\n-                        catch (BuildAbortedException bae)\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)\n                         {\n-                            // We were canceled before we got issued by the work queue.\n-                            var result = new BuildResult(submission.BuildRequest, bae);\n-                            submission.CompleteResults(result);\n-                            submission.CompleteLogging(true);\n-                            CheckSubmissionCompletenessAndRemove(submission);\n+                            // Mark the build submission as complete with the provided results and return.\n+                            var result = new BuildResult(submission.BuildRequest);\n+\n+                            foreach (var targetResult in cacheResult.BuildResult.ResultsByTarget)\n+                            {\n+                                result.AddResultsForTarget(targetResult.Key, targetResult.Value);\n+                            }\n+\n+                            _resultsCache.AddResult(result);\n+                            submission.CompleteLogging(false);\n+                            ReportResultsToSubmission(result);\n                         }\n-                        catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    }\n+                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    {\n+                        HandleExecuteSubmissionException(submission, ex);\n+                        throw;\n+                    }\n+                    catch (Exception ex) when (thisMethodIsAsync)\n+                    {\n+                        OnThreadException(ex);\n+                    }\n+                    void SubmitBuildRequest()\n+                    {\n+                        if (CheckForShutdown())\n                         {\n-                            HandleExecuteSubmissionException(submission, ex);\n+                            return;\n                         }\n-                    });\n+\n+                        _workQueue.Post(\n+                            () =>\n+                            {\n+                                try\n+                                {\n+                                    IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                                }\n+                                catch (BuildAbortedException bae)\n+                                {\n+                                    // We were canceled before we got issued by the work queue.\n+                                    var result = new BuildResult(submission.BuildRequest, bae);\n+                                    submission.CompleteResults(result);\n+                                    submission.CompleteLogging(true);\n+                                    CheckSubmissionCompletenessAndRemove(submission);\n+                                }\n+                                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                                {\n+                                    HandleExecuteSubmissionException(submission, ex);\n+                                }\n+                            });\n+                    }\n                 }\n-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+            }\n+\n+            bool ProjectCacheIsPresent()\n+            {\n+                return _projectCacheService != null ||\n+                       _buildParameters.ProjectCacheDescriptor != null ||\n+                       BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Count > 0;\n+            }\n+\n+            bool CheckForShutdown()\n+            {\n+                if (!_shuttingDown)\n                 {\n-                    HandleExecuteSubmissionException(submission, ex);\n+                    return false;\n+                }\n+\n+                // We were already canceled!\n+                var result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n+                submission.CompleteResults(result);\n+                submission.CompleteLogging(true);\n+                CheckSubmissionCompletenessAndRemove(submission);\n+\n+                return true;\n+            }\n+\n+            CacheResult QueryCache(BuildSubmission buildSubmission, BuildRequestConfiguration newConfiguration)\n+            {\n+                ProjectCacheService cacheService = null;\n+\n+                try\n+                {\n+                    cacheService = _projectCacheService.Result;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "How can it deadlock?",
              "createdAt": "2020-12-31T01:32:16Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);\n+\n+                        CacheResult cacheResult = null;\n+                        if (_projectCacheService != null)\n                         {\n-                            tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n-                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            cacheResult = QueryCache(submission, newConfiguration);\n                         }\n \n-                        submission.BuildRequestData.ProjectFullPath = Path.Combine(\n-                            submission.BuildRequestData.ProjectInstance\n-                                .GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue, tempName);\n-                    }\n+                        if (cacheResult == null || cacheResult.ResultType != CacheResultType.CacheHit)\n+                        {\n+                            // Issue the real build request.\n+                            SubmitBuildRequest();\n+                        }\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)\n+                        {\n+                            // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid ProjectInstance serialization).\n+                            // The proxy target results are used as results for the real targets.\n \n-                    // Create/Retrieve a configuration for each request\n-                    BuildRequestConfiguration buildRequestConfiguration =\n-                        new BuildRequestConfiguration(submission.BuildRequestData,\n-                            _buildParameters.DefaultToolsVersion);\n-                    BuildRequestConfiguration matchingConfiguration =\n-                        _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n-                    BuildRequestConfiguration newConfiguration = ResolveConfiguration(buildRequestConfiguration,\n-                        matchingConfiguration,\n-                        submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags\n-                            .ReplaceExistingProjectInstance));\n-\n-                    newConfiguration.ExplicitlyLoaded = true;\n-\n-                    // Now create the build request\n-                    submission.BuildRequest = new BuildRequest(\n-                        submission.SubmissionId,\n-                        BackEnd.BuildRequest.InvalidNodeRequestId,\n-                        newConfiguration.ConfigurationId,\n-                        submission.BuildRequestData.TargetNames,\n-                        submission.BuildRequestData.HostServices,\n-                        BuildEventContext.Invalid,\n-                        null,\n-                        submission.BuildRequestData.Flags,\n-                        submission.BuildRequestData.RequestedProjectState);\n+                            submission.BuildRequest = CreateProxyBuildRequest(\n+                                submission,\n+                                newConfiguration.ConfigurationId,\n+                                cacheResult.ProxyTargets);\n \n-                    if (_shuttingDown)\n-                    {\n-                        // We were already canceled!\n-                        BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n-                        submission.CompleteResults(result);\n-                        submission.CompleteLogging(true);\n-                        CheckSubmissionCompletenessAndRemove(submission);\n-                        return;\n-                    }\n-\n-                    // Submit the build request.\n-                    _workQueue.Post(() =>\n-                    {\n-                        try\n-                        {\n-                            IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                            SubmitBuildRequest();\n                         }\n-                        catch (BuildAbortedException bae)\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)\n                         {\n-                            // We were canceled before we got issued by the work queue.\n-                            var result = new BuildResult(submission.BuildRequest, bae);\n-                            submission.CompleteResults(result);\n-                            submission.CompleteLogging(true);\n-                            CheckSubmissionCompletenessAndRemove(submission);\n+                            // Mark the build submission as complete with the provided results and return.\n+                            var result = new BuildResult(submission.BuildRequest);\n+\n+                            foreach (var targetResult in cacheResult.BuildResult.ResultsByTarget)\n+                            {\n+                                result.AddResultsForTarget(targetResult.Key, targetResult.Value);\n+                            }\n+\n+                            _resultsCache.AddResult(result);\n+                            submission.CompleteLogging(false);\n+                            ReportResultsToSubmission(result);\n                         }\n-                        catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    }\n+                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    {\n+                        HandleExecuteSubmissionException(submission, ex);\n+                        throw;\n+                    }\n+                    catch (Exception ex) when (thisMethodIsAsync)\n+                    {\n+                        OnThreadException(ex);\n+                    }\n+                    void SubmitBuildRequest()\n+                    {\n+                        if (CheckForShutdown())\n                         {\n-                            HandleExecuteSubmissionException(submission, ex);\n+                            return;\n                         }\n-                    });\n+\n+                        _workQueue.Post(\n+                            () =>\n+                            {\n+                                try\n+                                {\n+                                    IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                                }\n+                                catch (BuildAbortedException bae)\n+                                {\n+                                    // We were canceled before we got issued by the work queue.\n+                                    var result = new BuildResult(submission.BuildRequest, bae);\n+                                    submission.CompleteResults(result);\n+                                    submission.CompleteLogging(true);\n+                                    CheckSubmissionCompletenessAndRemove(submission);\n+                                }\n+                                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                                {\n+                                    HandleExecuteSubmissionException(submission, ex);\n+                                }\n+                            });\n+                    }\n                 }\n-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+            }\n+\n+            bool ProjectCacheIsPresent()\n+            {\n+                return _projectCacheService != null ||\n+                       _buildParameters.ProjectCacheDescriptor != null ||\n+                       BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Count > 0;\n+            }\n+\n+            bool CheckForShutdown()\n+            {\n+                if (!_shuttingDown)\n                 {\n-                    HandleExecuteSubmissionException(submission, ex);\n+                    return false;\n+                }\n+\n+                // We were already canceled!\n+                var result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n+                submission.CompleteResults(result);\n+                submission.CompleteLogging(true);\n+                CheckSubmissionCompletenessAndRemove(submission);\n+\n+                return true;\n+            }\n+\n+            CacheResult QueryCache(BuildSubmission buildSubmission, BuildRequestConfiguration newConfiguration)\n+            {\n+                ProjectCacheService cacheService = null;\n+\n+                try\n+                {\n+                    cacheService = _projectCacheService.Result;",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If someone opens a single project rather than a solution, we should be able to use that as an \"entrypoint\" rather than the solution, right? Good fallback?",
              "createdAt": "2020-12-30T00:19:25Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);\n+\n+                        CacheResult cacheResult = null;\n+                        if (_projectCacheService != null)\n                         {\n-                            tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n-                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            cacheResult = QueryCache(submission, newConfiguration);\n                         }\n \n-                        submission.BuildRequestData.ProjectFullPath = Path.Combine(\n-                            submission.BuildRequestData.ProjectInstance\n-                                .GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue, tempName);\n-                    }\n+                        if (cacheResult == null || cacheResult.ResultType != CacheResultType.CacheHit)\n+                        {\n+                            // Issue the real build request.\n+                            SubmitBuildRequest();\n+                        }\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)\n+                        {\n+                            // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid ProjectInstance serialization).\n+                            // The proxy target results are used as results for the real targets.\n \n-                    // Create/Retrieve a configuration for each request\n-                    BuildRequestConfiguration buildRequestConfiguration =\n-                        new BuildRequestConfiguration(submission.BuildRequestData,\n-                            _buildParameters.DefaultToolsVersion);\n-                    BuildRequestConfiguration matchingConfiguration =\n-                        _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n-                    BuildRequestConfiguration newConfiguration = ResolveConfiguration(buildRequestConfiguration,\n-                        matchingConfiguration,\n-                        submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags\n-                            .ReplaceExistingProjectInstance));\n-\n-                    newConfiguration.ExplicitlyLoaded = true;\n-\n-                    // Now create the build request\n-                    submission.BuildRequest = new BuildRequest(\n-                        submission.SubmissionId,\n-                        BackEnd.BuildRequest.InvalidNodeRequestId,\n-                        newConfiguration.ConfigurationId,\n-                        submission.BuildRequestData.TargetNames,\n-                        submission.BuildRequestData.HostServices,\n-                        BuildEventContext.Invalid,\n-                        null,\n-                        submission.BuildRequestData.Flags,\n-                        submission.BuildRequestData.RequestedProjectState);\n+                            submission.BuildRequest = CreateProxyBuildRequest(\n+                                submission,\n+                                newConfiguration.ConfigurationId,\n+                                cacheResult.ProxyTargets);\n \n-                    if (_shuttingDown)\n-                    {\n-                        // We were already canceled!\n-                        BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n-                        submission.CompleteResults(result);\n-                        submission.CompleteLogging(true);\n-                        CheckSubmissionCompletenessAndRemove(submission);\n-                        return;\n-                    }\n-\n-                    // Submit the build request.\n-                    _workQueue.Post(() =>\n-                    {\n-                        try\n-                        {\n-                            IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                            SubmitBuildRequest();\n                         }\n-                        catch (BuildAbortedException bae)\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)\n                         {\n-                            // We were canceled before we got issued by the work queue.\n-                            var result = new BuildResult(submission.BuildRequest, bae);\n-                            submission.CompleteResults(result);\n-                            submission.CompleteLogging(true);\n-                            CheckSubmissionCompletenessAndRemove(submission);\n+                            // Mark the build submission as complete with the provided results and return.\n+                            var result = new BuildResult(submission.BuildRequest);\n+\n+                            foreach (var targetResult in cacheResult.BuildResult.ResultsByTarget)\n+                            {\n+                                result.AddResultsForTarget(targetResult.Key, targetResult.Value);\n+                            }\n+\n+                            _resultsCache.AddResult(result);\n+                            submission.CompleteLogging(false);\n+                            ReportResultsToSubmission(result);\n                         }\n-                        catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    }\n+                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    {\n+                        HandleExecuteSubmissionException(submission, ex);\n+                        throw;\n+                    }\n+                    catch (Exception ex) when (thisMethodIsAsync)\n+                    {\n+                        OnThreadException(ex);\n+                    }\n+                    void SubmitBuildRequest()\n+                    {\n+                        if (CheckForShutdown())\n                         {\n-                            HandleExecuteSubmissionException(submission, ex);\n+                            return;\n                         }\n-                    });\n+\n+                        _workQueue.Post(\n+                            () =>\n+                            {\n+                                try\n+                                {\n+                                    IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                                }\n+                                catch (BuildAbortedException bae)\n+                                {\n+                                    // We were canceled before we got issued by the work queue.\n+                                    var result = new BuildResult(submission.BuildRequest, bae);\n+                                    submission.CompleteResults(result);\n+                                    submission.CompleteLogging(true);\n+                                    CheckSubmissionCompletenessAndRemove(submission);\n+                                }\n+                                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                                {\n+                                    HandleExecuteSubmissionException(submission, ex);\n+                                }\n+                            });\n+                    }\n                 }\n-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+            }\n+\n+            bool ProjectCacheIsPresent()\n+            {\n+                return _projectCacheService != null ||\n+                       _buildParameters.ProjectCacheDescriptor != null ||\n+                       BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Count > 0;\n+            }\n+\n+            bool CheckForShutdown()\n+            {\n+                if (!_shuttingDown)\n                 {\n-                    HandleExecuteSubmissionException(submission, ex);\n+                    return false;\n+                }\n+\n+                // We were already canceled!\n+                var result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n+                submission.CompleteResults(result);\n+                submission.CompleteLogging(true);\n+                CheckSubmissionCompletenessAndRemove(submission);\n+\n+                return true;\n+            }\n+\n+            CacheResult QueryCache(BuildSubmission buildSubmission, BuildRequestConfiguration newConfiguration)\n+            {\n+                ProjectCacheService cacheService = null;\n+\n+                try\n+                {\n+                    cacheService = _projectCacheService.Result;\n+                }\n+                catch\n+                {\n+                    // Set to null so that EndBuild does not try to shut it down and thus rethrow the exception.\n+                    _projectCacheService = null;\n                     throw;\n                 }\n+\n+                // Project cache plugins require an evaluated project. Evaluate the submission if it's by path.\n+                LoadSubmissionProjectIntoConfiguration(buildSubmission, newConfiguration);\n+\n+                var cacheResult = cacheService.GetCacheResultAsync(\n+                        new BuildRequestData(\n+                            newConfiguration.Project,\n+                            buildSubmission.BuildRequestData.TargetNames.ToArray()))\n+                    .GetAwaiter()\n+                    .GetResult();\n+\n+                return cacheResult;\n+            }\n+\n+            static BuildRequest CreateRealBuildRequest(BuildSubmission submission, int configurationId)\n+            {\n+                return new BuildRequest(\n+                    submission.SubmissionId,\n+                    BackEnd.BuildRequest.InvalidNodeRequestId,\n+                    configurationId,\n+                    submission.BuildRequestData.TargetNames,\n+                    submission.BuildRequestData.HostServices,\n+                    BuildEventContext.Invalid,\n+                    null,\n+                    submission.BuildRequestData.Flags,\n+                    submission.BuildRequestData.RequestedProjectState);\n+            }\n+\n+            static BuildRequest CreateProxyBuildRequest(\n+                BuildSubmission submission,\n+                int configurationId,\n+                ProxyTargets proxyTargets)\n+            {\n+                return new BuildRequest(\n+                    submission.SubmissionId,\n+                    BackEnd.BuildRequest.InvalidNodeRequestId,\n+                    configurationId,\n+                    proxyTargets,\n+                    submission.BuildRequestData.HostServices,\n+                    submission.BuildRequestData.Flags,\n+                    submission.BuildRequestData.RequestedProjectState);\n+            }\n+        }\n+\n+        private void InstantiateProjectCacheServiceForVisualStudioWorkaround(\n+            BuildSubmission submission,\n+            BuildRequestConfiguration config)\n+        {\n+            if (BuildEnvironmentHelper.Instance.RunningInVisualStudio &&\n+                ProjectCacheItems.Count > 0 &&\n+                !_projectCacheServiceInstantiatedByVSWorkaround &&\n+                _projectCacheService == null &&\n+                _buildParameters.ProjectCacheDescriptor == null)\n+            {\n+                _projectCacheServiceInstantiatedByVSWorkaround = true;\n+                ErrorUtilities.VerifyThrowInvalidOperation(\n+                    ProjectCacheItems.Count == 1,\n+                    \"OnlyOneCachePluginMustBeSpecified\",\n+                    string.Join(\"; \", ProjectCacheItems.Values.Select(c => c.PluginPath)));\n+\n+                LoadSubmissionProjectIntoConfiguration(submission, config);\n+\n+                if (IsDesignTimeBuild(config.Project))\n+                {\n+                    // Design time builds do not use the project cache.\n+                    return;\n+                }\n+\n+                var solutionPath = config.Project.GetPropertyValue(SolutionProjectGenerator.SolutionPathPropertyName);\n+\n+                ErrorUtilities.VerifyThrow(\n+                    solutionPath != null && !string.IsNullOrWhiteSpace(solutionPath) && solutionPath != \"*Undefined*\",",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Good point. I'll check and see what global properties VS sets in that case.",
              "createdAt": "2020-12-31T01:41:11Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);\n+\n+                        CacheResult cacheResult = null;\n+                        if (_projectCacheService != null)\n                         {\n-                            tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n-                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            cacheResult = QueryCache(submission, newConfiguration);\n                         }\n \n-                        submission.BuildRequestData.ProjectFullPath = Path.Combine(\n-                            submission.BuildRequestData.ProjectInstance\n-                                .GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue, tempName);\n-                    }\n+                        if (cacheResult == null || cacheResult.ResultType != CacheResultType.CacheHit)\n+                        {\n+                            // Issue the real build request.\n+                            SubmitBuildRequest();\n+                        }\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)\n+                        {\n+                            // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid ProjectInstance serialization).\n+                            // The proxy target results are used as results for the real targets.\n \n-                    // Create/Retrieve a configuration for each request\n-                    BuildRequestConfiguration buildRequestConfiguration =\n-                        new BuildRequestConfiguration(submission.BuildRequestData,\n-                            _buildParameters.DefaultToolsVersion);\n-                    BuildRequestConfiguration matchingConfiguration =\n-                        _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n-                    BuildRequestConfiguration newConfiguration = ResolveConfiguration(buildRequestConfiguration,\n-                        matchingConfiguration,\n-                        submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags\n-                            .ReplaceExistingProjectInstance));\n-\n-                    newConfiguration.ExplicitlyLoaded = true;\n-\n-                    // Now create the build request\n-                    submission.BuildRequest = new BuildRequest(\n-                        submission.SubmissionId,\n-                        BackEnd.BuildRequest.InvalidNodeRequestId,\n-                        newConfiguration.ConfigurationId,\n-                        submission.BuildRequestData.TargetNames,\n-                        submission.BuildRequestData.HostServices,\n-                        BuildEventContext.Invalid,\n-                        null,\n-                        submission.BuildRequestData.Flags,\n-                        submission.BuildRequestData.RequestedProjectState);\n+                            submission.BuildRequest = CreateProxyBuildRequest(\n+                                submission,\n+                                newConfiguration.ConfigurationId,\n+                                cacheResult.ProxyTargets);\n \n-                    if (_shuttingDown)\n-                    {\n-                        // We were already canceled!\n-                        BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n-                        submission.CompleteResults(result);\n-                        submission.CompleteLogging(true);\n-                        CheckSubmissionCompletenessAndRemove(submission);\n-                        return;\n-                    }\n-\n-                    // Submit the build request.\n-                    _workQueue.Post(() =>\n-                    {\n-                        try\n-                        {\n-                            IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                            SubmitBuildRequest();\n                         }\n-                        catch (BuildAbortedException bae)\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)\n                         {\n-                            // We were canceled before we got issued by the work queue.\n-                            var result = new BuildResult(submission.BuildRequest, bae);\n-                            submission.CompleteResults(result);\n-                            submission.CompleteLogging(true);\n-                            CheckSubmissionCompletenessAndRemove(submission);\n+                            // Mark the build submission as complete with the provided results and return.\n+                            var result = new BuildResult(submission.BuildRequest);\n+\n+                            foreach (var targetResult in cacheResult.BuildResult.ResultsByTarget)\n+                            {\n+                                result.AddResultsForTarget(targetResult.Key, targetResult.Value);\n+                            }\n+\n+                            _resultsCache.AddResult(result);\n+                            submission.CompleteLogging(false);\n+                            ReportResultsToSubmission(result);\n                         }\n-                        catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    }\n+                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    {\n+                        HandleExecuteSubmissionException(submission, ex);\n+                        throw;\n+                    }\n+                    catch (Exception ex) when (thisMethodIsAsync)\n+                    {\n+                        OnThreadException(ex);\n+                    }\n+                    void SubmitBuildRequest()\n+                    {\n+                        if (CheckForShutdown())\n                         {\n-                            HandleExecuteSubmissionException(submission, ex);\n+                            return;\n                         }\n-                    });\n+\n+                        _workQueue.Post(\n+                            () =>\n+                            {\n+                                try\n+                                {\n+                                    IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                                }\n+                                catch (BuildAbortedException bae)\n+                                {\n+                                    // We were canceled before we got issued by the work queue.\n+                                    var result = new BuildResult(submission.BuildRequest, bae);\n+                                    submission.CompleteResults(result);\n+                                    submission.CompleteLogging(true);\n+                                    CheckSubmissionCompletenessAndRemove(submission);\n+                                }\n+                                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                                {\n+                                    HandleExecuteSubmissionException(submission, ex);\n+                                }\n+                            });\n+                    }\n                 }\n-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+            }\n+\n+            bool ProjectCacheIsPresent()\n+            {\n+                return _projectCacheService != null ||\n+                       _buildParameters.ProjectCacheDescriptor != null ||\n+                       BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Count > 0;\n+            }\n+\n+            bool CheckForShutdown()\n+            {\n+                if (!_shuttingDown)\n                 {\n-                    HandleExecuteSubmissionException(submission, ex);\n+                    return false;\n+                }\n+\n+                // We were already canceled!\n+                var result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n+                submission.CompleteResults(result);\n+                submission.CompleteLogging(true);\n+                CheckSubmissionCompletenessAndRemove(submission);\n+\n+                return true;\n+            }\n+\n+            CacheResult QueryCache(BuildSubmission buildSubmission, BuildRequestConfiguration newConfiguration)\n+            {\n+                ProjectCacheService cacheService = null;\n+\n+                try\n+                {\n+                    cacheService = _projectCacheService.Result;\n+                }\n+                catch\n+                {\n+                    // Set to null so that EndBuild does not try to shut it down and thus rethrow the exception.\n+                    _projectCacheService = null;\n                     throw;\n                 }\n+\n+                // Project cache plugins require an evaluated project. Evaluate the submission if it's by path.\n+                LoadSubmissionProjectIntoConfiguration(buildSubmission, newConfiguration);\n+\n+                var cacheResult = cacheService.GetCacheResultAsync(\n+                        new BuildRequestData(\n+                            newConfiguration.Project,\n+                            buildSubmission.BuildRequestData.TargetNames.ToArray()))\n+                    .GetAwaiter()\n+                    .GetResult();\n+\n+                return cacheResult;\n+            }\n+\n+            static BuildRequest CreateRealBuildRequest(BuildSubmission submission, int configurationId)\n+            {\n+                return new BuildRequest(\n+                    submission.SubmissionId,\n+                    BackEnd.BuildRequest.InvalidNodeRequestId,\n+                    configurationId,\n+                    submission.BuildRequestData.TargetNames,\n+                    submission.BuildRequestData.HostServices,\n+                    BuildEventContext.Invalid,\n+                    null,\n+                    submission.BuildRequestData.Flags,\n+                    submission.BuildRequestData.RequestedProjectState);\n+            }\n+\n+            static BuildRequest CreateProxyBuildRequest(\n+                BuildSubmission submission,\n+                int configurationId,\n+                ProxyTargets proxyTargets)\n+            {\n+                return new BuildRequest(\n+                    submission.SubmissionId,\n+                    BackEnd.BuildRequest.InvalidNodeRequestId,\n+                    configurationId,\n+                    proxyTargets,\n+                    submission.BuildRequestData.HostServices,\n+                    submission.BuildRequestData.Flags,\n+                    submission.BuildRequestData.RequestedProjectState);\n+            }\n+        }\n+\n+        private void InstantiateProjectCacheServiceForVisualStudioWorkaround(\n+            BuildSubmission submission,\n+            BuildRequestConfiguration config)\n+        {\n+            if (BuildEnvironmentHelper.Instance.RunningInVisualStudio &&\n+                ProjectCacheItems.Count > 0 &&\n+                !_projectCacheServiceInstantiatedByVSWorkaround &&\n+                _projectCacheService == null &&\n+                _buildParameters.ProjectCacheDescriptor == null)\n+            {\n+                _projectCacheServiceInstantiatedByVSWorkaround = true;\n+                ErrorUtilities.VerifyThrowInvalidOperation(\n+                    ProjectCacheItems.Count == 1,\n+                    \"OnlyOneCachePluginMustBeSpecified\",\n+                    string.Join(\"; \", ProjectCacheItems.Values.Select(c => c.PluginPath)));\n+\n+                LoadSubmissionProjectIntoConfiguration(submission, config);\n+\n+                if (IsDesignTimeBuild(config.Project))\n+                {\n+                    // Design time builds do not use the project cache.\n+                    return;\n+                }\n+\n+                var solutionPath = config.Project.GetPropertyValue(SolutionProjectGenerator.SolutionPathPropertyName);\n+\n+                ErrorUtilities.VerifyThrow(\n+                    solutionPath != null && !string.IsNullOrWhiteSpace(solutionPath) && solutionPath != \"*Undefined*\",",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "VS lies when opened on a single project and reports a non existing solution path. For now I'll leave it as is and reconsider if it turns to be a common case.",
              "createdAt": "2021-01-05T19:34:56Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);\n+\n+                        CacheResult cacheResult = null;\n+                        if (_projectCacheService != null)\n                         {\n-                            tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n-                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            cacheResult = QueryCache(submission, newConfiguration);\n                         }\n \n-                        submission.BuildRequestData.ProjectFullPath = Path.Combine(\n-                            submission.BuildRequestData.ProjectInstance\n-                                .GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue, tempName);\n-                    }\n+                        if (cacheResult == null || cacheResult.ResultType != CacheResultType.CacheHit)\n+                        {\n+                            // Issue the real build request.\n+                            SubmitBuildRequest();\n+                        }\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)\n+                        {\n+                            // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid ProjectInstance serialization).\n+                            // The proxy target results are used as results for the real targets.\n \n-                    // Create/Retrieve a configuration for each request\n-                    BuildRequestConfiguration buildRequestConfiguration =\n-                        new BuildRequestConfiguration(submission.BuildRequestData,\n-                            _buildParameters.DefaultToolsVersion);\n-                    BuildRequestConfiguration matchingConfiguration =\n-                        _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n-                    BuildRequestConfiguration newConfiguration = ResolveConfiguration(buildRequestConfiguration,\n-                        matchingConfiguration,\n-                        submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags\n-                            .ReplaceExistingProjectInstance));\n-\n-                    newConfiguration.ExplicitlyLoaded = true;\n-\n-                    // Now create the build request\n-                    submission.BuildRequest = new BuildRequest(\n-                        submission.SubmissionId,\n-                        BackEnd.BuildRequest.InvalidNodeRequestId,\n-                        newConfiguration.ConfigurationId,\n-                        submission.BuildRequestData.TargetNames,\n-                        submission.BuildRequestData.HostServices,\n-                        BuildEventContext.Invalid,\n-                        null,\n-                        submission.BuildRequestData.Flags,\n-                        submission.BuildRequestData.RequestedProjectState);\n+                            submission.BuildRequest = CreateProxyBuildRequest(\n+                                submission,\n+                                newConfiguration.ConfigurationId,\n+                                cacheResult.ProxyTargets);\n \n-                    if (_shuttingDown)\n-                    {\n-                        // We were already canceled!\n-                        BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n-                        submission.CompleteResults(result);\n-                        submission.CompleteLogging(true);\n-                        CheckSubmissionCompletenessAndRemove(submission);\n-                        return;\n-                    }\n-\n-                    // Submit the build request.\n-                    _workQueue.Post(() =>\n-                    {\n-                        try\n-                        {\n-                            IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                            SubmitBuildRequest();\n                         }\n-                        catch (BuildAbortedException bae)\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)\n                         {\n-                            // We were canceled before we got issued by the work queue.\n-                            var result = new BuildResult(submission.BuildRequest, bae);\n-                            submission.CompleteResults(result);\n-                            submission.CompleteLogging(true);\n-                            CheckSubmissionCompletenessAndRemove(submission);\n+                            // Mark the build submission as complete with the provided results and return.\n+                            var result = new BuildResult(submission.BuildRequest);\n+\n+                            foreach (var targetResult in cacheResult.BuildResult.ResultsByTarget)\n+                            {\n+                                result.AddResultsForTarget(targetResult.Key, targetResult.Value);\n+                            }\n+\n+                            _resultsCache.AddResult(result);\n+                            submission.CompleteLogging(false);\n+                            ReportResultsToSubmission(result);\n                         }\n-                        catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    }\n+                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    {\n+                        HandleExecuteSubmissionException(submission, ex);\n+                        throw;\n+                    }\n+                    catch (Exception ex) when (thisMethodIsAsync)\n+                    {\n+                        OnThreadException(ex);\n+                    }\n+                    void SubmitBuildRequest()\n+                    {\n+                        if (CheckForShutdown())\n                         {\n-                            HandleExecuteSubmissionException(submission, ex);\n+                            return;\n                         }\n-                    });\n+\n+                        _workQueue.Post(\n+                            () =>\n+                            {\n+                                try\n+                                {\n+                                    IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                                }\n+                                catch (BuildAbortedException bae)\n+                                {\n+                                    // We were canceled before we got issued by the work queue.\n+                                    var result = new BuildResult(submission.BuildRequest, bae);\n+                                    submission.CompleteResults(result);\n+                                    submission.CompleteLogging(true);\n+                                    CheckSubmissionCompletenessAndRemove(submission);\n+                                }\n+                                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                                {\n+                                    HandleExecuteSubmissionException(submission, ex);\n+                                }\n+                            });\n+                    }\n                 }\n-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+            }\n+\n+            bool ProjectCacheIsPresent()\n+            {\n+                return _projectCacheService != null ||\n+                       _buildParameters.ProjectCacheDescriptor != null ||\n+                       BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Count > 0;\n+            }\n+\n+            bool CheckForShutdown()\n+            {\n+                if (!_shuttingDown)\n                 {\n-                    HandleExecuteSubmissionException(submission, ex);\n+                    return false;\n+                }\n+\n+                // We were already canceled!\n+                var result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n+                submission.CompleteResults(result);\n+                submission.CompleteLogging(true);\n+                CheckSubmissionCompletenessAndRemove(submission);\n+\n+                return true;\n+            }\n+\n+            CacheResult QueryCache(BuildSubmission buildSubmission, BuildRequestConfiguration newConfiguration)\n+            {\n+                ProjectCacheService cacheService = null;\n+\n+                try\n+                {\n+                    cacheService = _projectCacheService.Result;\n+                }\n+                catch\n+                {\n+                    // Set to null so that EndBuild does not try to shut it down and thus rethrow the exception.\n+                    _projectCacheService = null;\n                     throw;\n                 }\n+\n+                // Project cache plugins require an evaluated project. Evaluate the submission if it's by path.\n+                LoadSubmissionProjectIntoConfiguration(buildSubmission, newConfiguration);\n+\n+                var cacheResult = cacheService.GetCacheResultAsync(\n+                        new BuildRequestData(\n+                            newConfiguration.Project,\n+                            buildSubmission.BuildRequestData.TargetNames.ToArray()))\n+                    .GetAwaiter()\n+                    .GetResult();\n+\n+                return cacheResult;\n+            }\n+\n+            static BuildRequest CreateRealBuildRequest(BuildSubmission submission, int configurationId)\n+            {\n+                return new BuildRequest(\n+                    submission.SubmissionId,\n+                    BackEnd.BuildRequest.InvalidNodeRequestId,\n+                    configurationId,\n+                    submission.BuildRequestData.TargetNames,\n+                    submission.BuildRequestData.HostServices,\n+                    BuildEventContext.Invalid,\n+                    null,\n+                    submission.BuildRequestData.Flags,\n+                    submission.BuildRequestData.RequestedProjectState);\n+            }\n+\n+            static BuildRequest CreateProxyBuildRequest(\n+                BuildSubmission submission,\n+                int configurationId,\n+                ProxyTargets proxyTargets)\n+            {\n+                return new BuildRequest(\n+                    submission.SubmissionId,\n+                    BackEnd.BuildRequest.InvalidNodeRequestId,\n+                    configurationId,\n+                    proxyTargets,\n+                    submission.BuildRequestData.HostServices,\n+                    submission.BuildRequestData.Flags,\n+                    submission.BuildRequestData.RequestedProjectState);\n+            }\n+        }\n+\n+        private void InstantiateProjectCacheServiceForVisualStudioWorkaround(\n+            BuildSubmission submission,\n+            BuildRequestConfiguration config)\n+        {\n+            if (BuildEnvironmentHelper.Instance.RunningInVisualStudio &&\n+                ProjectCacheItems.Count > 0 &&\n+                !_projectCacheServiceInstantiatedByVSWorkaround &&\n+                _projectCacheService == null &&\n+                _buildParameters.ProjectCacheDescriptor == null)\n+            {\n+                _projectCacheServiceInstantiatedByVSWorkaround = true;\n+                ErrorUtilities.VerifyThrowInvalidOperation(\n+                    ProjectCacheItems.Count == 1,\n+                    \"OnlyOneCachePluginMustBeSpecified\",\n+                    string.Join(\"; \", ProjectCacheItems.Values.Select(c => c.PluginPath)));\n+\n+                LoadSubmissionProjectIntoConfiguration(submission, config);\n+\n+                if (IsDesignTimeBuild(config.Project))\n+                {\n+                    // Design time builds do not use the project cache.\n+                    return;\n+                }\n+\n+                var solutionPath = config.Project.GetPropertyValue(SolutionProjectGenerator.SolutionPathPropertyName);\n+\n+                ErrorUtilities.VerifyThrow(\n+                    solutionPath != null && !string.IsNullOrWhiteSpace(solutionPath) && solutionPath != \"*Undefined*\",",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "\ud83d\ude22",
              "createdAt": "2021-01-05T22:41:59Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);\n+\n+                        CacheResult cacheResult = null;\n+                        if (_projectCacheService != null)\n                         {\n-                            tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n-                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            cacheResult = QueryCache(submission, newConfiguration);\n                         }\n \n-                        submission.BuildRequestData.ProjectFullPath = Path.Combine(\n-                            submission.BuildRequestData.ProjectInstance\n-                                .GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue, tempName);\n-                    }\n+                        if (cacheResult == null || cacheResult.ResultType != CacheResultType.CacheHit)\n+                        {\n+                            // Issue the real build request.\n+                            SubmitBuildRequest();\n+                        }\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)\n+                        {\n+                            // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid ProjectInstance serialization).\n+                            // The proxy target results are used as results for the real targets.\n \n-                    // Create/Retrieve a configuration for each request\n-                    BuildRequestConfiguration buildRequestConfiguration =\n-                        new BuildRequestConfiguration(submission.BuildRequestData,\n-                            _buildParameters.DefaultToolsVersion);\n-                    BuildRequestConfiguration matchingConfiguration =\n-                        _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n-                    BuildRequestConfiguration newConfiguration = ResolveConfiguration(buildRequestConfiguration,\n-                        matchingConfiguration,\n-                        submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags\n-                            .ReplaceExistingProjectInstance));\n-\n-                    newConfiguration.ExplicitlyLoaded = true;\n-\n-                    // Now create the build request\n-                    submission.BuildRequest = new BuildRequest(\n-                        submission.SubmissionId,\n-                        BackEnd.BuildRequest.InvalidNodeRequestId,\n-                        newConfiguration.ConfigurationId,\n-                        submission.BuildRequestData.TargetNames,\n-                        submission.BuildRequestData.HostServices,\n-                        BuildEventContext.Invalid,\n-                        null,\n-                        submission.BuildRequestData.Flags,\n-                        submission.BuildRequestData.RequestedProjectState);\n+                            submission.BuildRequest = CreateProxyBuildRequest(\n+                                submission,\n+                                newConfiguration.ConfigurationId,\n+                                cacheResult.ProxyTargets);\n \n-                    if (_shuttingDown)\n-                    {\n-                        // We were already canceled!\n-                        BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n-                        submission.CompleteResults(result);\n-                        submission.CompleteLogging(true);\n-                        CheckSubmissionCompletenessAndRemove(submission);\n-                        return;\n-                    }\n-\n-                    // Submit the build request.\n-                    _workQueue.Post(() =>\n-                    {\n-                        try\n-                        {\n-                            IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                            SubmitBuildRequest();\n                         }\n-                        catch (BuildAbortedException bae)\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)\n                         {\n-                            // We were canceled before we got issued by the work queue.\n-                            var result = new BuildResult(submission.BuildRequest, bae);\n-                            submission.CompleteResults(result);\n-                            submission.CompleteLogging(true);\n-                            CheckSubmissionCompletenessAndRemove(submission);\n+                            // Mark the build submission as complete with the provided results and return.\n+                            var result = new BuildResult(submission.BuildRequest);\n+\n+                            foreach (var targetResult in cacheResult.BuildResult.ResultsByTarget)\n+                            {\n+                                result.AddResultsForTarget(targetResult.Key, targetResult.Value);\n+                            }\n+\n+                            _resultsCache.AddResult(result);\n+                            submission.CompleteLogging(false);\n+                            ReportResultsToSubmission(result);\n                         }\n-                        catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    }\n+                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    {\n+                        HandleExecuteSubmissionException(submission, ex);\n+                        throw;\n+                    }\n+                    catch (Exception ex) when (thisMethodIsAsync)\n+                    {\n+                        OnThreadException(ex);\n+                    }\n+                    void SubmitBuildRequest()\n+                    {\n+                        if (CheckForShutdown())\n                         {\n-                            HandleExecuteSubmissionException(submission, ex);\n+                            return;\n                         }\n-                    });\n+\n+                        _workQueue.Post(\n+                            () =>\n+                            {\n+                                try\n+                                {\n+                                    IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                                }\n+                                catch (BuildAbortedException bae)\n+                                {\n+                                    // We were canceled before we got issued by the work queue.\n+                                    var result = new BuildResult(submission.BuildRequest, bae);\n+                                    submission.CompleteResults(result);\n+                                    submission.CompleteLogging(true);\n+                                    CheckSubmissionCompletenessAndRemove(submission);\n+                                }\n+                                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                                {\n+                                    HandleExecuteSubmissionException(submission, ex);\n+                                }\n+                            });\n+                    }\n                 }\n-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+            }\n+\n+            bool ProjectCacheIsPresent()\n+            {\n+                return _projectCacheService != null ||\n+                       _buildParameters.ProjectCacheDescriptor != null ||\n+                       BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Count > 0;\n+            }\n+\n+            bool CheckForShutdown()\n+            {\n+                if (!_shuttingDown)\n                 {\n-                    HandleExecuteSubmissionException(submission, ex);\n+                    return false;\n+                }\n+\n+                // We were already canceled!\n+                var result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n+                submission.CompleteResults(result);\n+                submission.CompleteLogging(true);\n+                CheckSubmissionCompletenessAndRemove(submission);\n+\n+                return true;\n+            }\n+\n+            CacheResult QueryCache(BuildSubmission buildSubmission, BuildRequestConfiguration newConfiguration)\n+            {\n+                ProjectCacheService cacheService = null;\n+\n+                try\n+                {\n+                    cacheService = _projectCacheService.Result;\n+                }\n+                catch\n+                {\n+                    // Set to null so that EndBuild does not try to shut it down and thus rethrow the exception.\n+                    _projectCacheService = null;\n                     throw;\n                 }\n+\n+                // Project cache plugins require an evaluated project. Evaluate the submission if it's by path.\n+                LoadSubmissionProjectIntoConfiguration(buildSubmission, newConfiguration);\n+\n+                var cacheResult = cacheService.GetCacheResultAsync(\n+                        new BuildRequestData(\n+                            newConfiguration.Project,\n+                            buildSubmission.BuildRequestData.TargetNames.ToArray()))\n+                    .GetAwaiter()\n+                    .GetResult();\n+\n+                return cacheResult;\n+            }\n+\n+            static BuildRequest CreateRealBuildRequest(BuildSubmission submission, int configurationId)\n+            {\n+                return new BuildRequest(\n+                    submission.SubmissionId,\n+                    BackEnd.BuildRequest.InvalidNodeRequestId,\n+                    configurationId,\n+                    submission.BuildRequestData.TargetNames,\n+                    submission.BuildRequestData.HostServices,\n+                    BuildEventContext.Invalid,\n+                    null,\n+                    submission.BuildRequestData.Flags,\n+                    submission.BuildRequestData.RequestedProjectState);\n+            }\n+\n+            static BuildRequest CreateProxyBuildRequest(\n+                BuildSubmission submission,\n+                int configurationId,\n+                ProxyTargets proxyTargets)\n+            {\n+                return new BuildRequest(\n+                    submission.SubmissionId,\n+                    BackEnd.BuildRequest.InvalidNodeRequestId,\n+                    configurationId,\n+                    proxyTargets,\n+                    submission.BuildRequestData.HostServices,\n+                    submission.BuildRequestData.Flags,\n+                    submission.BuildRequestData.RequestedProjectState);\n+            }\n+        }\n+\n+        private void InstantiateProjectCacheServiceForVisualStudioWorkaround(\n+            BuildSubmission submission,\n+            BuildRequestConfiguration config)\n+        {\n+            if (BuildEnvironmentHelper.Instance.RunningInVisualStudio &&\n+                ProjectCacheItems.Count > 0 &&\n+                !_projectCacheServiceInstantiatedByVSWorkaround &&\n+                _projectCacheService == null &&\n+                _buildParameters.ProjectCacheDescriptor == null)\n+            {\n+                _projectCacheServiceInstantiatedByVSWorkaround = true;\n+                ErrorUtilities.VerifyThrowInvalidOperation(\n+                    ProjectCacheItems.Count == 1,\n+                    \"OnlyOneCachePluginMustBeSpecified\",\n+                    string.Join(\"; \", ProjectCacheItems.Values.Select(c => c.PluginPath)));\n+\n+                LoadSubmissionProjectIntoConfiguration(submission, config);\n+\n+                if (IsDesignTimeBuild(config.Project))\n+                {\n+                    // Design time builds do not use the project cache.\n+                    return;\n+                }\n+\n+                var solutionPath = config.Project.GetPropertyValue(SolutionProjectGenerator.SolutionPathPropertyName);\n+\n+                ErrorUtilities.VerifyThrow(\n+                    solutionPath != null && !string.IsNullOrWhiteSpace(solutionPath) && solutionPath != \"*Undefined*\",",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't really matter, but it's generally better to put checks that take fewer cycles first, all else being equal, and these sound like they're doing the same thing.",
              "createdAt": "2020-12-30T00:24:23Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -962,117 +1004,324 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread\n             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));\n             ErrorUtilities.VerifyThrow(!submission.IsCompleted, \"Submission already complete.\");\n \n-            lock (_syncLock)\n+            bool thisMethodIsAsync = false;\n+\n+            if (ProjectCacheIsPresent())\n+            {\n+                thisMethodIsAsync = true;\n+\n+                // Potential long running operations:\n+                //  - submission may need evaluation\n+                //  - project cache may need initializing\n+                //  - project cache will be queried\n+                // Use separate thread to unblock calling thread.\n+                Task.Factory.StartNew(\n+                    ExecuteSubmissionImpl,\n+                    CancellationToken.None,\n+                    TaskCreationOptions.LongRunning,\n+                    TaskScheduler.Default\n+                );\n+            }\n+            else\n+            {\n+                ExecuteSubmissionImpl();\n+            }\n+\n+            void ExecuteSubmissionImpl()\n             {\n-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;\n-                if (projectInstance != null)\n+                lock (_syncLock)\n                 {\n-                    if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                    var projectInstance = submission.BuildRequestData.ProjectInstance;\n+                    if (projectInstance != null)\n                     {\n-                        ErrorUtilities.VerifyThrowArgument(\n-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n-                            \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        if (_acquiredProjectRootElementCacheFromProjectInstance)\n+                        {\n+                            ErrorUtilities.VerifyThrowArgument(\n+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,\n+                                \"OM_BuildSubmissionsMultipleProjectCollections\");\n+                        }\n+                        else\n+                        {\n+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n+                            _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        }\n                     }\n-                    else\n+                    else if (_buildParameters.ProjectRootElementCache == null)\n                     {\n-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;\n-                        _acquiredProjectRootElementCacheFromProjectInstance = true;\n+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,\n+                        // we'll dump our cache and use that one.\n+                        _buildParameters.ProjectRootElementCache =\n+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);\n                     }\n-                }\n-                else if (_buildParameters.ProjectRootElementCache == null)\n-                {\n-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,\n-                    // we'll dump our cache and use that one.\n-                    _buildParameters.ProjectRootElementCache =\n-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);\n-                }\n \n-                VerifyStateInternal(BuildManagerState.Building);\n+                    VerifyStateInternal(BuildManagerState.Building);\n \n-                try\n-                {\n-                    // If we have an unnamed project, assign it a temporary name.\n-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                    try\n                     {\n-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,\n-                            \"Unexpected null path for a submission with no ProjectInstance.\");\n+                        // If we have an unnamed project, assign it a temporary name.\n+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))\n+                        {\n+                            ErrorUtilities.VerifyThrow(\n+                                submission.BuildRequestData.ProjectInstance != null,\n+                                \"Unexpected null path for a submission with no ProjectInstance.\");\n+\n+                            // If we have already named this instance when it was submitted previously during this build, use the same\n+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)\n+                            if (!_unnamedProjectInstanceToNames.TryGetValue(\n+                                submission.BuildRequestData.ProjectInstance,\n+                                out var tempName))\n+                            {\n+                                tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            }\n \n-                        // If we have already named this instance when it was submitted previously during this build, use the same\n-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)\n-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,\n-                            out string tempName))\n+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(\n+                                submission.BuildRequestData.ProjectInstance\n+                                    .GetProperty(ReservedPropertyNames.projectDirectory)\n+                                    .EvaluatedValue,\n+                                tempName);\n+                        }\n+\n+                        // Create/Retrieve a configuration for each request\n+                        var buildRequestConfiguration =\n+                            new BuildRequestConfiguration(\n+                                submission.BuildRequestData,\n+                                _buildParameters.DefaultToolsVersion);\n+                        var matchingConfiguration =\n+                            _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n+                        var newConfiguration = ResolveConfiguration(\n+                            buildRequestConfiguration,\n+                            matchingConfiguration,\n+                            submission.BuildRequestData.Flags.HasFlag(\n+                                BuildRequestDataFlags\n+                                    .ReplaceExistingProjectInstance));\n+\n+                        newConfiguration.ExplicitlyLoaded = true;\n+\n+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);\n+\n+                        // TODO: Remove this when VS gets updated to setup project cache plugins.\n+                        InstantiateProjectCacheServiceForVisualStudioWorkaround(submission, newConfiguration);\n+\n+                        CacheResult cacheResult = null;\n+                        if (_projectCacheService != null)\n                         {\n-                            tempName = \"Unnamed_\" + _nextUnnamedProjectId++;\n-                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;\n+                            cacheResult = QueryCache(submission, newConfiguration);\n                         }\n \n-                        submission.BuildRequestData.ProjectFullPath = Path.Combine(\n-                            submission.BuildRequestData.ProjectInstance\n-                                .GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue, tempName);\n-                    }\n+                        if (cacheResult == null || cacheResult.ResultType != CacheResultType.CacheHit)\n+                        {\n+                            // Issue the real build request.\n+                            SubmitBuildRequest();\n+                        }\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)\n+                        {\n+                            // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid ProjectInstance serialization).\n+                            // The proxy target results are used as results for the real targets.\n \n-                    // Create/Retrieve a configuration for each request\n-                    BuildRequestConfiguration buildRequestConfiguration =\n-                        new BuildRequestConfiguration(submission.BuildRequestData,\n-                            _buildParameters.DefaultToolsVersion);\n-                    BuildRequestConfiguration matchingConfiguration =\n-                        _configCache.GetMatchingConfiguration(buildRequestConfiguration);\n-                    BuildRequestConfiguration newConfiguration = ResolveConfiguration(buildRequestConfiguration,\n-                        matchingConfiguration,\n-                        submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags\n-                            .ReplaceExistingProjectInstance));\n-\n-                    newConfiguration.ExplicitlyLoaded = true;\n-\n-                    // Now create the build request\n-                    submission.BuildRequest = new BuildRequest(\n-                        submission.SubmissionId,\n-                        BackEnd.BuildRequest.InvalidNodeRequestId,\n-                        newConfiguration.ConfigurationId,\n-                        submission.BuildRequestData.TargetNames,\n-                        submission.BuildRequestData.HostServices,\n-                        BuildEventContext.Invalid,\n-                        null,\n-                        submission.BuildRequestData.Flags,\n-                        submission.BuildRequestData.RequestedProjectState);\n+                            submission.BuildRequest = CreateProxyBuildRequest(\n+                                submission,\n+                                newConfiguration.ConfigurationId,\n+                                cacheResult.ProxyTargets);\n \n-                    if (_shuttingDown)\n-                    {\n-                        // We were already canceled!\n-                        BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n-                        submission.CompleteResults(result);\n-                        submission.CompleteLogging(true);\n-                        CheckSubmissionCompletenessAndRemove(submission);\n-                        return;\n-                    }\n-\n-                    // Submit the build request.\n-                    _workQueue.Post(() =>\n-                    {\n-                        try\n-                        {\n-                            IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                            SubmitBuildRequest();\n                         }\n-                        catch (BuildAbortedException bae)\n+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)\n                         {\n-                            // We were canceled before we got issued by the work queue.\n-                            var result = new BuildResult(submission.BuildRequest, bae);\n-                            submission.CompleteResults(result);\n-                            submission.CompleteLogging(true);\n-                            CheckSubmissionCompletenessAndRemove(submission);\n+                            // Mark the build submission as complete with the provided results and return.\n+                            var result = new BuildResult(submission.BuildRequest);\n+\n+                            foreach (var targetResult in cacheResult.BuildResult.ResultsByTarget)\n+                            {\n+                                result.AddResultsForTarget(targetResult.Key, targetResult.Value);\n+                            }\n+\n+                            _resultsCache.AddResult(result);\n+                            submission.CompleteLogging(false);\n+                            ReportResultsToSubmission(result);\n                         }\n-                        catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    }\n+                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                    {\n+                        HandleExecuteSubmissionException(submission, ex);\n+                        throw;\n+                    }\n+                    catch (Exception ex) when (thisMethodIsAsync)\n+                    {\n+                        OnThreadException(ex);\n+                    }\n+                    void SubmitBuildRequest()\n+                    {\n+                        if (CheckForShutdown())\n                         {\n-                            HandleExecuteSubmissionException(submission, ex);\n+                            return;\n                         }\n-                    });\n+\n+                        _workQueue.Post(\n+                            () =>\n+                            {\n+                                try\n+                                {\n+                                    IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);\n+                                }\n+                                catch (BuildAbortedException bae)\n+                                {\n+                                    // We were canceled before we got issued by the work queue.\n+                                    var result = new BuildResult(submission.BuildRequest, bae);\n+                                    submission.CompleteResults(result);\n+                                    submission.CompleteLogging(true);\n+                                    CheckSubmissionCompletenessAndRemove(submission);\n+                                }\n+                                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+                                {\n+                                    HandleExecuteSubmissionException(submission, ex);\n+                                }\n+                            });\n+                    }\n                 }\n-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))\n+            }\n+\n+            bool ProjectCacheIsPresent()\n+            {\n+                return _projectCacheService != null ||\n+                       _buildParameters.ProjectCacheDescriptor != null ||\n+                       BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Count > 0;\n+            }\n+\n+            bool CheckForShutdown()\n+            {\n+                if (!_shuttingDown)\n                 {\n-                    HandleExecuteSubmissionException(submission, ex);\n+                    return false;\n+                }\n+\n+                // We were already canceled!\n+                var result = new BuildResult(submission.BuildRequest, new BuildAbortedException());\n+                submission.CompleteResults(result);\n+                submission.CompleteLogging(true);\n+                CheckSubmissionCompletenessAndRemove(submission);\n+\n+                return true;\n+            }\n+\n+            CacheResult QueryCache(BuildSubmission buildSubmission, BuildRequestConfiguration newConfiguration)\n+            {\n+                ProjectCacheService cacheService = null;\n+\n+                try\n+                {\n+                    cacheService = _projectCacheService.Result;\n+                }\n+                catch\n+                {\n+                    // Set to null so that EndBuild does not try to shut it down and thus rethrow the exception.\n+                    _projectCacheService = null;\n                     throw;\n                 }\n+\n+                // Project cache plugins require an evaluated project. Evaluate the submission if it's by path.\n+                LoadSubmissionProjectIntoConfiguration(buildSubmission, newConfiguration);\n+\n+                var cacheResult = cacheService.GetCacheResultAsync(\n+                        new BuildRequestData(\n+                            newConfiguration.Project,\n+                            buildSubmission.BuildRequestData.TargetNames.ToArray()))\n+                    .GetAwaiter()\n+                    .GetResult();\n+\n+                return cacheResult;\n+            }\n+\n+            static BuildRequest CreateRealBuildRequest(BuildSubmission submission, int configurationId)\n+            {\n+                return new BuildRequest(\n+                    submission.SubmissionId,\n+                    BackEnd.BuildRequest.InvalidNodeRequestId,\n+                    configurationId,\n+                    submission.BuildRequestData.TargetNames,\n+                    submission.BuildRequestData.HostServices,\n+                    BuildEventContext.Invalid,\n+                    null,\n+                    submission.BuildRequestData.Flags,\n+                    submission.BuildRequestData.RequestedProjectState);\n+            }\n+\n+            static BuildRequest CreateProxyBuildRequest(\n+                BuildSubmission submission,\n+                int configurationId,\n+                ProxyTargets proxyTargets)\n+            {\n+                return new BuildRequest(\n+                    submission.SubmissionId,\n+                    BackEnd.BuildRequest.InvalidNodeRequestId,\n+                    configurationId,\n+                    proxyTargets,\n+                    submission.BuildRequestData.HostServices,\n+                    submission.BuildRequestData.Flags,\n+                    submission.BuildRequestData.RequestedProjectState);\n+            }\n+        }\n+\n+        private void InstantiateProjectCacheServiceForVisualStudioWorkaround(\n+            BuildSubmission submission,\n+            BuildRequestConfiguration config)\n+        {\n+            if (BuildEnvironmentHelper.Instance.RunningInVisualStudio &&\n+                ProjectCacheItems.Count > 0 &&\n+                !_projectCacheServiceInstantiatedByVSWorkaround &&\n+                _projectCacheService == null &&\n+                _buildParameters.ProjectCacheDescriptor == null)\n+            {\n+                _projectCacheServiceInstantiatedByVSWorkaround = true;\n+                ErrorUtilities.VerifyThrowInvalidOperation(\n+                    ProjectCacheItems.Count == 1,\n+                    \"OnlyOneCachePluginMustBeSpecified\",\n+                    string.Join(\"; \", ProjectCacheItems.Values.Select(c => c.PluginPath)));\n+\n+                LoadSubmissionProjectIntoConfiguration(submission, config);\n+\n+                if (IsDesignTimeBuild(config.Project))\n+                {\n+                    // Design time builds do not use the project cache.\n+                    return;\n+                }\n+\n+                var solutionPath = config.Project.GetPropertyValue(SolutionProjectGenerator.SolutionPathPropertyName);\n+\n+                ErrorUtilities.VerifyThrow(\n+                    solutionPath != null && !string.IsNullOrWhiteSpace(solutionPath) && solutionPath != \"*Undefined*\",\n+                    $\"Expected VS to set a valid SolutionPath property but got: {solutionPath}\");\n+                ErrorUtilities.VerifyThrow(\n+                    FileSystems.Default.FileExists(solutionPath),\n+                    $\"Solution file does not exist: {solutionPath}\");\n+\n+                var projectCacheItem = ProjectCacheItems.First().Value;\n+\n+                InitializeProjectCacheService(\n+                    ProjectCacheDescriptor.FromAssemblyPath(\n+                        projectCacheItem.PluginPath,\n+                        new[]\n+                        {\n+                            new ProjectGraphEntryPoint(\n+                                solutionPath,\n+                                config.Project.GlobalProperties)\n+                        },\n+                        null,\n+                        projectCacheItem.PluginSettings),\n+                    CancellationToken.None);\n+            }\n+\n+            static bool IsDesignTimeBuild(ProjectInstance project)\n+            {\n+                var designTimeBuild = project.GetPropertyValue(DesignTimeProperties.DesignTimeBuild);\n+                var buildingProject = project.GlobalPropertiesDictionary[DesignTimeProperties.BuildingProject]?.EvaluatedValue;\n+\n+                return MSBuildStringIsTrue(designTimeBuild) ||",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This can be null/empty, right?",
              "createdAt": "2020-12-30T17:08:10Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheContext.cs",
              "diffHunk": "@@ -0,0 +1,44 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using Microsoft.Build.FileSystem;\n+using Microsoft.Build.Graph;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Holds various information about the current msbuild execution that the cache might use.\n+    ///     The cache may need to know about the top level projects or the entire project graph, so MSBuild\n+    ///     provides a graph when one is available. When it isn't available, MSBuild provides the top level projects\n+    ///     and the plugin can construct its own graph based on those.\n+    ///     So either <see cref=\"Graph\" />is null, or <see cref=\"GraphEntryPoints\" /> is null. But not both.\n+    /// </summary>\n+    public class CacheContext\n+    {\n+        public IReadOnlyDictionary<string, string> PluginSettings { get; }\n+        public ProjectGraph? Graph { get; }\n+        public IReadOnlyCollection<ProjectGraphEntryPoint>? GraphEntryPoints { get; }\n+        public string MSBuildExePath { get; }\n+        public MSBuildFileSystemBase FileSystem { get; }\n+\n+        public CacheContext(\n+            IReadOnlyDictionary<string, string> pluginSettings,\n+            MSBuildFileSystemBase fileSystem,\n+            ProjectGraph? graph = null,\n+            IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = null)\n+        {\n+            ErrorUtilities.VerifyThrow(\n+                (graph != null) ^ (graphEntryPoints != null),\n+                \"Either Graph is specified, or GraphEntryPoints is specified. Not both.\");\n+\n+            PluginSettings = pluginSettings;\n+            Graph = graph;\n+            GraphEntryPoints = graphEntryPoints;\n+            MSBuildExePath = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yup. Plugins that do not support that can error.",
              "createdAt": "2020-12-31T01:48:26Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheContext.cs",
              "diffHunk": "@@ -0,0 +1,44 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using Microsoft.Build.FileSystem;\n+using Microsoft.Build.Graph;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Holds various information about the current msbuild execution that the cache might use.\n+    ///     The cache may need to know about the top level projects or the entire project graph, so MSBuild\n+    ///     provides a graph when one is available. When it isn't available, MSBuild provides the top level projects\n+    ///     and the plugin can construct its own graph based on those.\n+    ///     So either <see cref=\"Graph\" />is null, or <see cref=\"GraphEntryPoints\" /> is null. But not both.\n+    /// </summary>\n+    public class CacheContext\n+    {\n+        public IReadOnlyDictionary<string, string> PluginSettings { get; }\n+        public ProjectGraph? Graph { get; }\n+        public IReadOnlyCollection<ProjectGraphEntryPoint>? GraphEntryPoints { get; }\n+        public string MSBuildExePath { get; }\n+        public MSBuildFileSystemBase FileSystem { get; }\n+\n+        public CacheContext(\n+            IReadOnlyDictionary<string, string> pluginSettings,\n+            MSBuildFileSystemBase fileSystem,\n+            ProjectGraph? graph = null,\n+            IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = null)\n+        {\n+            ErrorUtilities.VerifyThrow(\n+                (graph != null) ^ (graphEntryPoints != null),\n+                \"Either Graph is specified, or GraphEntryPoints is specified. Not both.\");\n+\n+            PluginSettings = pluginSettings;\n+            Graph = graph;\n+            GraphEntryPoints = graphEntryPoints;\n+            MSBuildExePath = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we make the pluginTargetResult.TaskItems an array of actual TaskItems so we can skip this? This is allocating a lot.",
              "createdAt": "2020-12-30T17:24:50Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,109 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError\n+    }\n+\n+    /// <summary>\n+    ///     Represents the cache result a plugin returns back to MSBuild when queried about a certain project.\n+    ///     Results representing cache hits (with <see cref=\"ResultType\"/> == <see cref=\"CacheResultType.CacheHit\"/>)\n+    ///     contain information about what <see cref=\"Execution.BuildResult\"/> MSBuild should use for the queried project.\n+    ///     It is assumed that all cache hits result in a successful <see cref=\"Execution.BuildResult\"/>.\n+    /// </summary>\n+    public class CacheResult\n+    {\n+        private CacheResult(\n+            CacheResultType resultType,\n+            BuildResult? buildResult = null,\n+            ProxyTargets? proxyTargets = null)\n+        {\n+            if (resultType == CacheResultType.CacheHit)\n+            {\n+                ErrorUtilities.VerifyThrow(\n+                    buildResult != null ^ proxyTargets != null,\n+                    \"Either buildResult is specified, or proxyTargets is specified. Not both.\");\n+            }\n+\n+            ResultType = resultType;\n+            BuildResult = buildResult;\n+            ProxyTargets = proxyTargets;\n+        }\n+\n+        internal CacheResultType ResultType { get; }\n+        internal BuildResult? BuildResult { get; }\n+        internal ProxyTargets? ProxyTargets { get; }\n+\n+        public static CacheResult IndicateCacheHit(BuildResult buildResult)\n+        {\n+            return new CacheResult(CacheResultType.CacheHit, buildResult);\n+        }\n+\n+        public static CacheResult IndicateCacheHit(ProxyTargets proxyTargets)\n+        {\n+            return new CacheResult(CacheResultType.CacheHit, proxyTargets: proxyTargets);\n+        }\n+\n+        public static CacheResult IndicateCacheHit(IReadOnlyCollection<PluginTargetResult> targetResults)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentLength(targetResults, nameof(targetResults));\n+\n+            return new CacheResult(CacheResultType.CacheHit, ConstructBuildResult(targetResults));\n+        }\n+\n+        public static CacheResult IndicateNonCacheHit(CacheResultType resultType)\n+        {\n+            ErrorUtilities.VerifyThrowInvalidOperation(resultType != CacheResultType.CacheHit, \"CantBeCacheHit\");\n+            return new CacheResult(resultType);\n+        }\n+\n+        private static BuildResult ConstructBuildResult(IReadOnlyCollection<PluginTargetResult> targetResults)\n+        {\n+            var buildResult = new BuildResult();\n+\n+            foreach (var pluginTargetResult in targetResults)\n+            {\n+                buildResult.AddResultsForTarget(\n+                    pluginTargetResult.TargetName,\n+                    new TargetResult(\n+                        pluginTargetResult.TaskItems.Select(ti => CreateTaskItem(ti)).ToArray(),",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "TaskItem is not public, and the overall change to make it work without these allocations is probably not worth it.",
              "createdAt": "2020-12-31T01:57:10Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,109 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError\n+    }\n+\n+    /// <summary>\n+    ///     Represents the cache result a plugin returns back to MSBuild when queried about a certain project.\n+    ///     Results representing cache hits (with <see cref=\"ResultType\"/> == <see cref=\"CacheResultType.CacheHit\"/>)\n+    ///     contain information about what <see cref=\"Execution.BuildResult\"/> MSBuild should use for the queried project.\n+    ///     It is assumed that all cache hits result in a successful <see cref=\"Execution.BuildResult\"/>.\n+    /// </summary>\n+    public class CacheResult\n+    {\n+        private CacheResult(\n+            CacheResultType resultType,\n+            BuildResult? buildResult = null,\n+            ProxyTargets? proxyTargets = null)\n+        {\n+            if (resultType == CacheResultType.CacheHit)\n+            {\n+                ErrorUtilities.VerifyThrow(\n+                    buildResult != null ^ proxyTargets != null,\n+                    \"Either buildResult is specified, or proxyTargets is specified. Not both.\");\n+            }\n+\n+            ResultType = resultType;\n+            BuildResult = buildResult;\n+            ProxyTargets = proxyTargets;\n+        }\n+\n+        internal CacheResultType ResultType { get; }\n+        internal BuildResult? BuildResult { get; }\n+        internal ProxyTargets? ProxyTargets { get; }\n+\n+        public static CacheResult IndicateCacheHit(BuildResult buildResult)\n+        {\n+            return new CacheResult(CacheResultType.CacheHit, buildResult);\n+        }\n+\n+        public static CacheResult IndicateCacheHit(ProxyTargets proxyTargets)\n+        {\n+            return new CacheResult(CacheResultType.CacheHit, proxyTargets: proxyTargets);\n+        }\n+\n+        public static CacheResult IndicateCacheHit(IReadOnlyCollection<PluginTargetResult> targetResults)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentLength(targetResults, nameof(targetResults));\n+\n+            return new CacheResult(CacheResultType.CacheHit, ConstructBuildResult(targetResults));\n+        }\n+\n+        public static CacheResult IndicateNonCacheHit(CacheResultType resultType)\n+        {\n+            ErrorUtilities.VerifyThrowInvalidOperation(resultType != CacheResultType.CacheHit, \"CantBeCacheHit\");\n+            return new CacheResult(resultType);\n+        }\n+\n+        private static BuildResult ConstructBuildResult(IReadOnlyCollection<PluginTargetResult> targetResults)\n+        {\n+            var buildResult = new BuildResult();\n+\n+            foreach (var pluginTargetResult in targetResults)\n+            {\n+                buildResult.AddResultsForTarget(\n+                    pluginTargetResult.TargetName,\n+                    new TargetResult(\n+                        pluginTargetResult.TaskItems.Select(ti => CreateTaskItem(ti)).ToArray(),",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Can it not be public? Or more along the lines of what I was thinking, why does PluginTargetResult have to be public?\r\n\r\nIf it can't be helped, maybe at least make it ...Select(ti => ti is ProjectItemInstance.TaskItem piiti ? piiti : CreateTaskItem(ti)).ToArray(),",
              "createdAt": "2020-12-31T19:25:27Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,109 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError\n+    }\n+\n+    /// <summary>\n+    ///     Represents the cache result a plugin returns back to MSBuild when queried about a certain project.\n+    ///     Results representing cache hits (with <see cref=\"ResultType\"/> == <see cref=\"CacheResultType.CacheHit\"/>)\n+    ///     contain information about what <see cref=\"Execution.BuildResult\"/> MSBuild should use for the queried project.\n+    ///     It is assumed that all cache hits result in a successful <see cref=\"Execution.BuildResult\"/>.\n+    /// </summary>\n+    public class CacheResult\n+    {\n+        private CacheResult(\n+            CacheResultType resultType,\n+            BuildResult? buildResult = null,\n+            ProxyTargets? proxyTargets = null)\n+        {\n+            if (resultType == CacheResultType.CacheHit)\n+            {\n+                ErrorUtilities.VerifyThrow(\n+                    buildResult != null ^ proxyTargets != null,\n+                    \"Either buildResult is specified, or proxyTargets is specified. Not both.\");\n+            }\n+\n+            ResultType = resultType;\n+            BuildResult = buildResult;\n+            ProxyTargets = proxyTargets;\n+        }\n+\n+        internal CacheResultType ResultType { get; }\n+        internal BuildResult? BuildResult { get; }\n+        internal ProxyTargets? ProxyTargets { get; }\n+\n+        public static CacheResult IndicateCacheHit(BuildResult buildResult)\n+        {\n+            return new CacheResult(CacheResultType.CacheHit, buildResult);\n+        }\n+\n+        public static CacheResult IndicateCacheHit(ProxyTargets proxyTargets)\n+        {\n+            return new CacheResult(CacheResultType.CacheHit, proxyTargets: proxyTargets);\n+        }\n+\n+        public static CacheResult IndicateCacheHit(IReadOnlyCollection<PluginTargetResult> targetResults)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentLength(targetResults, nameof(targetResults));\n+\n+            return new CacheResult(CacheResultType.CacheHit, ConstructBuildResult(targetResults));\n+        }\n+\n+        public static CacheResult IndicateNonCacheHit(CacheResultType resultType)\n+        {\n+            ErrorUtilities.VerifyThrowInvalidOperation(resultType != CacheResultType.CacheHit, \"CantBeCacheHit\");\n+            return new CacheResult(resultType);\n+        }\n+\n+        private static BuildResult ConstructBuildResult(IReadOnlyCollection<PluginTargetResult> targetResults)\n+        {\n+            var buildResult = new BuildResult();\n+\n+            foreach (var pluginTargetResult in targetResults)\n+            {\n+                buildResult.AddResultsForTarget(\n+                    pluginTargetResult.TargetName,\n+                    new TargetResult(\n+                        pluginTargetResult.TaskItems.Select(ti => CreateTaskItem(ti)).ToArray(),",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "ProjectItemInstance.TaskItem is not public, so it can't be instantiated by plugins. PluginTargetResult must be public because plugins are public, external to MSBuild.",
              "createdAt": "2020-12-31T21:34:35Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/CacheResult.cs",
              "diffHunk": "@@ -0,0 +1,109 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    public enum CacheResultType\n+    {\n+        CacheHit,\n+        CacheMiss,\n+        CacheNotApplicable,\n+        CacheError\n+    }\n+\n+    /// <summary>\n+    ///     Represents the cache result a plugin returns back to MSBuild when queried about a certain project.\n+    ///     Results representing cache hits (with <see cref=\"ResultType\"/> == <see cref=\"CacheResultType.CacheHit\"/>)\n+    ///     contain information about what <see cref=\"Execution.BuildResult\"/> MSBuild should use for the queried project.\n+    ///     It is assumed that all cache hits result in a successful <see cref=\"Execution.BuildResult\"/>.\n+    /// </summary>\n+    public class CacheResult\n+    {\n+        private CacheResult(\n+            CacheResultType resultType,\n+            BuildResult? buildResult = null,\n+            ProxyTargets? proxyTargets = null)\n+        {\n+            if (resultType == CacheResultType.CacheHit)\n+            {\n+                ErrorUtilities.VerifyThrow(\n+                    buildResult != null ^ proxyTargets != null,\n+                    \"Either buildResult is specified, or proxyTargets is specified. Not both.\");\n+            }\n+\n+            ResultType = resultType;\n+            BuildResult = buildResult;\n+            ProxyTargets = proxyTargets;\n+        }\n+\n+        internal CacheResultType ResultType { get; }\n+        internal BuildResult? BuildResult { get; }\n+        internal ProxyTargets? ProxyTargets { get; }\n+\n+        public static CacheResult IndicateCacheHit(BuildResult buildResult)\n+        {\n+            return new CacheResult(CacheResultType.CacheHit, buildResult);\n+        }\n+\n+        public static CacheResult IndicateCacheHit(ProxyTargets proxyTargets)\n+        {\n+            return new CacheResult(CacheResultType.CacheHit, proxyTargets: proxyTargets);\n+        }\n+\n+        public static CacheResult IndicateCacheHit(IReadOnlyCollection<PluginTargetResult> targetResults)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentLength(targetResults, nameof(targetResults));\n+\n+            return new CacheResult(CacheResultType.CacheHit, ConstructBuildResult(targetResults));\n+        }\n+\n+        public static CacheResult IndicateNonCacheHit(CacheResultType resultType)\n+        {\n+            ErrorUtilities.VerifyThrowInvalidOperation(resultType != CacheResultType.CacheHit, \"CantBeCacheHit\");\n+            return new CacheResult(resultType);\n+        }\n+\n+        private static BuildResult ConstructBuildResult(IReadOnlyCollection<PluginTargetResult> targetResults)\n+        {\n+            var buildResult = new BuildResult();\n+\n+            foreach (var pluginTargetResult in targetResults)\n+            {\n+                buildResult.AddResultsForTarget(\n+                    pluginTargetResult.TargetName,\n+                    new TargetResult(\n+                        pluginTargetResult.TaskItems.Select(ti => CreateTaskItem(ti)).ToArray(),",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why add an abstract class if it's only implemented once?",
              "createdAt": "2020-12-30T17:30:21Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs",
              "diffHunk": "@@ -0,0 +1,32 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Events logged with this logger will get pushed into MSBuild's logging infrastructure.\n+    /// </summary>\n+    public abstract class PluginLoggerBase",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Given the many ways one can log things I'd rather keep this at the contract / interfacey level than commit to an arbitrary implementation.",
              "createdAt": "2020-12-31T02:00:20Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs",
              "diffHunk": "@@ -0,0 +1,32 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Events logged with this logger will get pushed into MSBuild's logging infrastructure.\n+    /// </summary>\n+    public abstract class PluginLoggerBase",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Even with a concrete class, we still only commit to the methods in the class, right? We don't commit to how each function is implemented, just that it performs the same work?",
              "createdAt": "2020-12-31T17:39:09Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs",
              "diffHunk": "@@ -0,0 +1,32 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Events logged with this logger will get pushed into MSBuild's logging infrastructure.\n+    /// </summary>\n+    public abstract class PluginLoggerBase",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "But there can be different implementations to the same interface, and it's not clear at all at this point whether we'll end up with one or many. Until then I'd rather not change the rest of the code.",
              "createdAt": "2020-12-31T21:56:28Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs",
              "diffHunk": "@@ -0,0 +1,32 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Experimental.ProjectCache\n+{\n+    /// <summary>\n+    ///     Events logged with this logger will get pushed into MSBuild's logging infrastructure.\n+    /// </summary>\n+    public abstract class PluginLoggerBase",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't understand this? Why are random environment variables expected to be set?",
              "createdAt": "2020-12-30T18:29:30Z",
              "path": "src/Samples/ProjectCachePlugin/MockCacheFromAssembly.cs",
              "diffHunk": "@@ -0,0 +1,58 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Experimental.ProjectCache;\n+using Microsoft.Build.Framework;\n+\n+namespace MockCacheFromAssembly\n+{\n+    public class MockCacheFromAssembly : ProjectCachePluginBase\n+    {\n+        public MockCacheFromAssembly()\n+        {\n+            ThrowFrom(\"Constructor\");\n+        }\n+\n+        public override Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken)\n+        {\n+            logger.LogMessage(\"MockCacheFromAssembly: BeginBuildAsync\", MessageImportance.High);\n+\n+            ThrowFrom(nameof(BeginBuildAsync));\n+\n+            return Task.CompletedTask;\n+        }\n+\n+        public override Task<CacheResult> GetCacheResultAsync(\n+            BuildRequestData buildRequest,\n+            PluginLoggerBase logger,\n+            CancellationToken cancellationToken)\n+        {\n+            logger.LogMessage($\"MockCacheFromAssembly: GetCacheResultAsync for {buildRequest.ProjectFullPath}\", MessageImportance.High);\n+\n+            ThrowFrom(nameof(GetCacheResultAsync));\n+\n+            return Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));\n+        }\n+\n+        public override Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken)\n+        {\n+            logger.LogMessage(\"MockCacheFromAssembly: EndBuildAsync\", MessageImportance.High);\n+\n+            ThrowFrom(nameof(EndBuildAsync));\n+\n+            return Task.CompletedTask;\n+        }\n+\n+        private static void ThrowFrom(string throwFrom)\n+        {\n+            if (Environment.GetEnvironmentVariable(throwFrom) != null)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It's how the tests tell the mock plugin to throw from various points. I couldn't find a simpler way to do it.",
              "createdAt": "2020-12-31T02:01:39Z",
              "path": "src/Samples/ProjectCachePlugin/MockCacheFromAssembly.cs",
              "diffHunk": "@@ -0,0 +1,58 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Experimental.ProjectCache;\n+using Microsoft.Build.Framework;\n+\n+namespace MockCacheFromAssembly\n+{\n+    public class MockCacheFromAssembly : ProjectCachePluginBase\n+    {\n+        public MockCacheFromAssembly()\n+        {\n+            ThrowFrom(\"Constructor\");\n+        }\n+\n+        public override Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken)\n+        {\n+            logger.LogMessage(\"MockCacheFromAssembly: BeginBuildAsync\", MessageImportance.High);\n+\n+            ThrowFrom(nameof(BeginBuildAsync));\n+\n+            return Task.CompletedTask;\n+        }\n+\n+        public override Task<CacheResult> GetCacheResultAsync(\n+            BuildRequestData buildRequest,\n+            PluginLoggerBase logger,\n+            CancellationToken cancellationToken)\n+        {\n+            logger.LogMessage($\"MockCacheFromAssembly: GetCacheResultAsync for {buildRequest.ProjectFullPath}\", MessageImportance.High);\n+\n+            ThrowFrom(nameof(GetCacheResultAsync));\n+\n+            return Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));\n+        }\n+\n+        public override Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken)\n+        {\n+            logger.LogMessage(\"MockCacheFromAssembly: EndBuildAsync\", MessageImportance.High);\n+\n+            ThrowFrom(nameof(EndBuildAsync));\n+\n+            return Task.CompletedTask;\n+        }\n+\n+        private static void ThrowFrom(string throwFrom)\n+        {\n+            if (Environment.GetEnvironmentVariable(throwFrom) != null)",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      }
    ]
  }
}