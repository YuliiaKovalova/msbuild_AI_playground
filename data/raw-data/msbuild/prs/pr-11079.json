{
  "number": 11079,
  "title": "Fixing the contention condition caused by RegisterResolversManifests",
  "body": "Fixes #11043, #7927\r\n\r\n### Context\r\nThere was a contention condition described [here](https://github.com/dotnet/msbuild/issues/7927#issuecomment-1973203412\r\n):\r\nOne thread enters and locks, then initializes a list, starts pushing things onto the list, which is now no longer null.\r\nSecond thread then checks, sees the list is not empty and bypasses the lock, acquires enumerator.\r\nFirst thread pushes additional item into the list.\r\nSecond thread throws.\r\n\r\n### Changes Made\r\nInitializing the list to a placeholder first, only assigning it when it is finished. Due to this, until the list is fully initialized, all threads have to enter the lock, then they will check that the list is now initialized and return.\r\nThis will result in some minor locking overhead, but it is not as strict as locking the collection for all reads.\r\n\r\nFurthermore, since the collection is supposed to be read only as written [here](https://github.com/dotnet/msbuild/issues/7927#issuecomment-1232765468), I've made it into IReadOnlyList instead of the current IList.\r\n\r\n### Testing\r\nI got a reproduction, although a bit clunky.\r\nFirst commit checks should fail. Then I will push the fix which should succeed.\r\n",
  "state": "MERGED",
  "createdAt": "2024-12-04T13:12:49Z",
  "updatedAt": "2025-03-20T15:42:11Z",
  "closedAt": "2024-12-16T10:25:32Z",
  "mergedAt": "2024-12-16T10:25:32Z",
  "additions": 175,
  "deletions": 57,
  "changedFiles": 2,
  "headRefName": "SdkResolverService_race_fix",
  "isDraft": false,
  "author": {
    "login": "SimaTian"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "d7826cdce9352f9d626ccc16478355096d973973",
          "message": "Contention condition reproduction via unit test",
          "committedDate": "2024-12-06T10:18:02Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "dc6456adb5ca491ae4ac86669d3c3312ba5537c9",
          "message": "updating the lists only after they're complete to avoid the contention.",
          "committedDate": "2024-12-06T10:47:18Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "6ae489b8c58969fc4f21c6ddd3feb8b9fe1a9051",
          "message": "Update src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2024-12-09T11:31:09Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "bd782fb1ac2bc1a72895e48b1f0621b608532ef2",
          "message": "addressing review comments",
          "committedDate": "2024-12-09T12:34:22Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "4b3a351becccc00f67c512a83a5f9a0ce4d1be8c",
          "message": "Merge branch 'main' into SdkResolverService_race_fix",
          "committedDate": "2024-12-09T12:34:48Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "cd82cfe477bcf9ff4e46499cb07b928d5cdbe166",
          "message": "minor touchup",
          "committedDate": "2024-12-09T12:37:32Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "36053af4f01fe58b1d5d669eda6be181dde326a6",
          "message": "Merge branch 'SdkResolverService_race_fix' of https://github.com/dotnet/msbuild into SdkResolverService_race_fix",
          "committedDate": "2024-12-09T12:37:40Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "3fe393dfcf275a5f3349383717d9cedafc97f30f",
          "message": "#if DEBUG fix",
          "committedDate": "2024-12-09T12:52:52Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "762e004728ba7dc53eeda5cafbeb14b1f4dc1de6",
          "message": "Merge branch 'main' into SdkResolverService_race_fix",
          "committedDate": "2024-12-09T15:24:05Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "4ffa85698ff5ed9081b0b6945f08fa217291e295",
          "message": "refactoring to get rid of #if directives",
          "committedDate": "2024-12-13T15:28:27Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "b0ed408135858f60a27544eb2bdb543835028167",
          "message": "removing unnecessary include",
          "committedDate": "2024-12-13T15:34:18Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "af5434cdc7a369db567c0757e1b51f436c9de17a",
          "message": "Merge branch 'main' into SdkResolverService_race_fix",
          "committedDate": "2024-12-16T08:48:56Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "4a6597bf7f118af76c45702da640e2c5e6db9cd9",
          "message": "variable rename",
          "committedDate": "2024-12-16T08:52:58Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "> Fixes #11043, #7927\n\nGitHub did not automatically close #7927.  See \"Multiple issues\" in <https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword>.",
        "createdAt": "2024-12-16T19:46:22Z",
        "author": {
          "login": "KalleOlaviNiemitalo"
        }
      },
      {
        "body": "/backport to vs17.12",
        "createdAt": "2025-03-20T15:41:57Z",
        "author": {
          "login": "baronfel"
        }
      },
      {
        "body": "Started backporting to _vs17.12_: https://github.com/dotnet/msbuild/actions/runs/13973433101",
        "createdAt": "2025-03-20T15:42:10Z",
        "author": {
          "login": "github-actions"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "When is this set to `true`?",
              "createdAt": "2024-12-04T20:11:08Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -48,12 +51,17 @@ internal class SdkResolverService : ISdkResolverService\n         /// <summary>\n         /// Stores the list of manifests of specific SDK resolvers which could be loaded.\n         /// </summary>\n-        private IList<SdkResolverManifest> _specificResolversManifestsRegistry;\n+        private IReadOnlyList<SdkResolverManifest> _specificResolversManifestsRegistry;\n \n         /// <summary>\n         /// Stores the list of manifests of general SDK resolvers which could be loaded.\n         /// </summary>\n-        private IList<SdkResolverManifest> _generalResolversManifestsRegistry;\n+        private IReadOnlyList<SdkResolverManifest> _generalResolversManifestsRegistry;\n+\n+#if DEBUG\n+        internal bool _fake_initialization = false;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Ah, only in one test and explicitly from the test side. Can it be part of a constructor or `InitializeForTests` or something?",
              "createdAt": "2024-12-06T17:50:17Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -48,12 +51,17 @@ internal class SdkResolverService : ISdkResolverService\n         /// <summary>\n         /// Stores the list of manifests of specific SDK resolvers which could be loaded.\n         /// </summary>\n-        private IList<SdkResolverManifest> _specificResolversManifestsRegistry;\n+        private IReadOnlyList<SdkResolverManifest> _specificResolversManifestsRegistry;\n \n         /// <summary>\n         /// Stores the list of manifests of general SDK resolvers which could be loaded.\n         /// </summary>\n-        private IList<SdkResolverManifest> _generalResolversManifestsRegistry;\n+        private IReadOnlyList<SdkResolverManifest> _generalResolversManifestsRegistry;\n+\n+#if DEBUG\n+        internal bool _fake_initialization = false;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "style nit: in .NET, generally `_` prefixes mean \"instance-level field\", so these method-local variables shouldn't have one.",
              "createdAt": "2024-12-04T20:12:27Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -485,23 +518,40 @@ private void RegisterResolversManifests(ElementLocation location)\n                 }\n \n                 // Break the list of all resolvers manifests into two parts: manifests with specific and general resolvers.\n-                _specificResolversManifestsRegistry = new List<SdkResolverManifest>();\n-                _generalResolversManifestsRegistry = new List<SdkResolverManifest>();\n+                // Since the collections are meant to be immutable, we have to only ever assign them when they're complete.\n+                // Otherwise race can happen, see https://github.com/dotnet/msbuild/issues/7927\n+                var _specificResolversManifestsRegistryPlaceholder = new List<SdkResolverManifest>();\n+                var _generalResolversManifestsRegistryPlaceholder = new List<SdkResolverManifest>();",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "please observe the [best practice implementation of the disposable pattern] (https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/dispose-pattern)",
              "createdAt": "2024-12-06T11:12:01Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs",
              "diffHunk": "@@ -43,18 +47,20 @@ public SdkResolverService_Tests()\n \n         public void Dispose()",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Looks like this `Dispose()` can be removed now, right? Or does `InitializeForTests()` change static as well as instance state?",
              "createdAt": "2024-12-06T17:04:18Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs",
              "diffHunk": "@@ -43,18 +47,20 @@ public SdkResolverService_Tests()\n \n         public void Dispose()",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Ok looking further there are some tests that use `s_sdkResolverService` too. Can you comment why?",
              "createdAt": "2024-12-06T17:49:00Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs",
              "diffHunk": "@@ -43,18 +47,20 @@ public SdkResolverService_Tests()\n \n         public void Dispose()",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I looked at the s_sdkResolverService and I can see only my test using it. There might have been some older commit doing that due to an imprecise refactoring.",
              "createdAt": "2024-12-09T11:39:01Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs",
              "diffHunk": "@@ -43,18 +47,20 @@ public SdkResolverService_Tests()\n \n         public void Dispose()",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "As for the Dispose(), after a second look, I've removed the remaining static instance and so removed the Dispose as well since it should no longer be necessary.",
              "createdAt": "2024-12-09T12:26:06Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs",
              "diffHunk": "@@ -43,18 +47,20 @@ public SdkResolverService_Tests()\n \n         public void Dispose()",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "consider coverting this to the use of asynchronous calls.",
              "createdAt": "2024-12-06T11:17:34Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs",
              "diffHunk": "@@ -122,28 +130,87 @@ public void AssertResolverThrows()\n         // and it successfully resolves sdk.\n         public void AssertSecondResolverWithPatternCanResolve()\n         {\n-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));\n+            var service = new SdkResolverService();\n+            service.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));\n \n             SdkReference sdk = new SdkReference(\"2sdkName\", \"referencedVersion\", \"minimumVersion\");\n \n-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation(\"file\"), \"sln\", \"projectPath\", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);\n+            var result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation(\"file\"), \"sln\", \"projectPath\", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);\n \n             result.Path.ShouldBe(\"resolverpathwithresolvablesdkpattern2\");\n             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain(\"MockSdkResolverWithResolvableSdkPattern2 running\");\n             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain(\"MockSdkResolver1 running\");\n             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain(\"MockSdkResolver2 running\");\n         }\n \n+#if DEBUG\n+        internal void TryResolveSdk(out bool success)\n+        {\n+            success = true;\n+            SdkReference sdk = new SdkReference(\"2sdkName\", \"referencedVersion\", \"minimumVersion\");\n+            try\n+            {\n+                s_sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId,\n+                                                        sdk,\n+                                                        _loggingContext,\n+                                                        new MockElementLocation(\"file\"),\n+                                                        \"sln\",\n+                                                        \"projectPath\",\n+                                                        interactive: false,\n+                                                        isRunningInVisualStudio: false,\n+                                                        failOnUnresolvedSdk: true);\n+            }\n+            catch (Exception)\n+            {\n+                success = false;\n+            }\n+        }\n+\n+\n+        [Fact]\n+        // Scenario: we want to test that we solved the contention described here: https://github.com/dotnet/msbuild/issues/7927#issuecomment-1232470838\n+        public void AssertResolverPopulationContentionNotPresent()\n+        {\n+            s_sdkResolverService.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true), resolverOnly: true);\n+           \n+            List<SdkResolverManifest> manifests = new List<SdkResolverManifest>();\n+            for (int i = 1; i != 20; i++)\n+            {\n+                var man = new SdkResolverManifest(DisplayName: \"TestResolversManifest\", Path: null, ResolvableSdkRegex: new Regex(\"abc\"));\n+                manifests.Add(man);\n+                man = new SdkResolverManifest(DisplayName: \"TestResolversManifest\", Path: null, null);\n+                manifests.Add(man);\n+            }\n+            s_sdkResolverService._fakeManifestRegistry = manifests.AsReadOnly();\n+            s_sdkResolverService._fake_initialization = true;\n+\n+            SdkReference sdk = new SdkReference(\"2sdkName\", \"referencedVersion\", \"minimumVersion\");\n+\n+            bool result1 = false;\n+            bool result2 = false;\n+            Thread thread1 = new Thread(() => TryResolveSdk(out result1));",
              "author": {
                "login": "donJoseLuis"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        ///<param name=\"resolverOnly\"> Debug parameter for initializing only the resolver part.</param>\r\n```",
              "createdAt": "2024-12-06T17:05:58Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -392,30 +407,37 @@ private bool TryResolveSdkUsingSpecifiedResolvers(\n         /// </summary>\n         /// <param name=\"resolverLoader\">An <see cref=\"SdkResolverLoader\"/> to use for loading SDK resolvers.</param>\n         /// <param name=\"resolvers\">Explicit set of SdkResolvers to use for all SDK resolution.</param>\n-        internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IReadOnlyList<SdkResolver> resolvers = null)\n+        /// <param name=\"resolverOnly\"> Debug parameter for initializing only the resolver part</param>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I have a fairly strong style preference to prefer unnecessary blocks over ifdefing a single close-brace.\r\n```suggestion\r\n#endif\r\n                {\r\n                    allResolversManifests = _sdkResolverLoader.GetResolversManifests(location);\r\n                }\r\n```\r\n\r\n(see also line 474 in the before)",
              "createdAt": "2024-12-06T17:09:19Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -465,10 +487,21 @@ private void RegisterResolversManifests(ElementLocation location)\n                 {\n                     return;\n                 }\n+                IReadOnlyList<SdkResolverManifest> allResolversManifests;\n+#if DEBUG\n+                if (_fake_initialization)\n+                {\n+                    allResolversManifests = _fakeManifestRegistry;\n+                }\n+                else\n+                {\n+#endif\n+                    allResolversManifests = _sdkResolverLoader.GetResolversManifests(location);\n+#if DEBUG\n+                }\n+#endif",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I've reduced it to enclose an if-branch that I need removed for non-debug environment.\r\nOtherwise build complains about stuff not being in scope (since the static definitions for the test are not there and I need at least the _fake_initialization one to insert the thread.sleeps)",
              "createdAt": "2024-12-09T12:52:37Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -465,10 +487,21 @@ private void RegisterResolversManifests(ElementLocation location)\n                 {\n                     return;\n                 }\n+                IReadOnlyList<SdkResolverManifest> allResolversManifests;\n+#if DEBUG\n+                if (_fake_initialization)\n+                {\n+                    allResolversManifests = _fakeManifestRegistry;\n+                }\n+                else\n+                {\n+#endif\n+                    allResolversManifests = _sdkResolverLoader.GetResolversManifests(location);\n+#if DEBUG\n+                }\n+#endif",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It's important that you assign these in reverse order (assign the one that's checked last, then the one that's checked first), right? Comment that please?",
              "createdAt": "2024-12-06T17:13:22Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -484,24 +517,41 @@ private void RegisterResolversManifests(ElementLocation location)\n                     }\n                 }\n \n+                var _specificResolversManifestsRegistryPlaceholder = new List<SdkResolverManifest>();\n+                var _generalResolversManifestsRegistryPlaceholder = new List<SdkResolverManifest>();\n+\n                 // Break the list of all resolvers manifests into two parts: manifests with specific and general resolvers.\n-                _specificResolversManifestsRegistry = new List<SdkResolverManifest>();\n-                _generalResolversManifestsRegistry = new List<SdkResolverManifest>();\n+                // Since the collections are meant to be immutable, we have to only ever assign them when they're complete.\n+                // Otherwise race can happen, see https://github.com/dotnet/msbuild/issues/7927\n                 foreach (SdkResolverManifest manifest in allResolversManifests)\n                 {\n+#if DEBUG\n+                    if (_fake_initialization)\n+                    {\n+                        Thread.Sleep(10);\n+                    }\n+#endif\n                     if (manifest.ResolvableSdkRegex == null)\n                     {\n-                        _generalResolversManifestsRegistry.Add(manifest);\n+                        _generalResolversManifestsRegistryPlaceholder.Add(manifest);\n                     }\n                     else\n                     {\n-                        _specificResolversManifestsRegistry.Add(manifest);\n+                        _specificResolversManifestsRegistryPlaceholder.Add(manifest);\n                     }\n                 }\n                 if (sdkDefaultResolversManifest != null)\n                 {\n-                    _generalResolversManifestsRegistry.Add(sdkDefaultResolversManifest);\n+                    _generalResolversManifestsRegistryPlaceholder.Add(sdkDefaultResolversManifest);\n                 }\n+\n+                // Until this is set(and this is under lock), the ResolveSdkUsingResolversWithPatternsFirst will always\n+                // enter if branch leaving to this section.\n+                // Then it will wait at the lock and return after we release it since the collections we have filled them before releasing the lock.\n+                // The collections are never modified after this point.\n+                // So I've made them ReadOnly\n+                _generalResolversManifestsRegistry = _generalResolversManifestsRegistryPlaceholder.AsReadOnly();\n+                _specificResolversManifestsRegistry = _specificResolversManifestsRegistryPlaceholder.AsReadOnly();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "No, it is not important. It is only important that these are assigned after they're fully initialized.",
              "createdAt": "2024-12-09T08:31:34Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -484,24 +517,41 @@ private void RegisterResolversManifests(ElementLocation location)\n                     }\n                 }\n \n+                var _specificResolversManifestsRegistryPlaceholder = new List<SdkResolverManifest>();\n+                var _generalResolversManifestsRegistryPlaceholder = new List<SdkResolverManifest>();\n+\n                 // Break the list of all resolvers manifests into two parts: manifests with specific and general resolvers.\n-                _specificResolversManifestsRegistry = new List<SdkResolverManifest>();\n-                _generalResolversManifestsRegistry = new List<SdkResolverManifest>();\n+                // Since the collections are meant to be immutable, we have to only ever assign them when they're complete.\n+                // Otherwise race can happen, see https://github.com/dotnet/msbuild/issues/7927\n                 foreach (SdkResolverManifest manifest in allResolversManifests)\n                 {\n+#if DEBUG\n+                    if (_fake_initialization)\n+                    {\n+                        Thread.Sleep(10);\n+                    }\n+#endif\n                     if (manifest.ResolvableSdkRegex == null)\n                     {\n-                        _generalResolversManifestsRegistry.Add(manifest);\n+                        _generalResolversManifestsRegistryPlaceholder.Add(manifest);\n                     }\n                     else\n                     {\n-                        _specificResolversManifestsRegistry.Add(manifest);\n+                        _specificResolversManifestsRegistryPlaceholder.Add(manifest);\n                     }\n                 }\n                 if (sdkDefaultResolversManifest != null)\n                 {\n-                    _generalResolversManifestsRegistry.Add(sdkDefaultResolversManifest);\n+                    _generalResolversManifestsRegistryPlaceholder.Add(sdkDefaultResolversManifest);\n                 }\n+\n+                // Until this is set(and this is under lock), the ResolveSdkUsingResolversWithPatternsFirst will always\n+                // enter if branch leaving to this section.\n+                // Then it will wait at the lock and return after we release it since the collections we have filled them before releasing the lock.\n+                // The collections are never modified after this point.\n+                // So I've made them ReadOnly\n+                _generalResolversManifestsRegistry = _generalResolversManifestsRegistryPlaceholder.AsReadOnly();\n+                _specificResolversManifestsRegistry = _specificResolversManifestsRegistryPlaceholder.AsReadOnly();",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could this be simplified to\r\n```suggestion\r\n                _generalResolversManifestsRegistry = [sdkResolverManifest];\r\n                _specificResolversManifestsRegistry = [];\r\n```\r\n?",
              "createdAt": "2024-12-06T17:45:09Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -392,30 +407,37 @@ private bool TryResolveSdkUsingSpecifiedResolvers(\n         /// </summary>\n         /// <param name=\"resolverLoader\">An <see cref=\"SdkResolverLoader\"/> to use for loading SDK resolvers.</param>\n         /// <param name=\"resolvers\">Explicit set of SdkResolvers to use for all SDK resolution.</param>\n-        internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IReadOnlyList<SdkResolver> resolvers = null)\n+        /// <param name=\"resolverOnly\"> Debug parameter for initializing only the resolver part</param>\n+        internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IReadOnlyList<SdkResolver> resolvers = null, bool resolverOnly = false)\n         {\n             if (resolverLoader != null)\n             {\n                 _sdkResolverLoader = resolverLoader;\n+                if (resolverOnly)\n+                {\n+                    return;\n+                }\n             }\n             else\n             {\n                 _sdkResolverLoader = CachingSdkResolverLoader.Instance;\n             }\n \n-            _specificResolversManifestsRegistry = null;\n-            _generalResolversManifestsRegistry = null;\n+            List<SdkResolverManifest> _specificResolversManifestsRegistryPlaceholder = null;\n+            List<SdkResolverManifest> _generalResolversManifestsRegistryPlaceholder = null;\n             _manifestToResolvers = null;\n \n             if (resolvers != null)\n             {\n-                _specificResolversManifestsRegistry = new List<SdkResolverManifest>();\n-                _generalResolversManifestsRegistry = new List<SdkResolverManifest>();\n+                _specificResolversManifestsRegistryPlaceholder = new List<SdkResolverManifest>();\n+                _generalResolversManifestsRegistryPlaceholder = new List<SdkResolverManifest>();\n                 _manifestToResolvers = new Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>>();\n \n                 SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(DisplayName: \"TestResolversManifest\", Path: null, ResolvableSdkRegex: null);\n-                _generalResolversManifestsRegistry.Add(sdkResolverManifest);\n+                _generalResolversManifestsRegistryPlaceholder.Add(sdkResolverManifest);\n                 _manifestToResolvers[sdkResolverManifest] = resolvers;\n+                _generalResolversManifestsRegistry = _generalResolversManifestsRegistryPlaceholder.AsReadOnly();\n+                _specificResolversManifestsRegistry = _specificResolversManifestsRegistryPlaceholder.AsReadOnly();",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would this `catch` lose information if the call fails, making the test harder to diagnose?",
              "createdAt": "2024-12-06T17:49:13Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs",
              "diffHunk": "@@ -122,28 +130,87 @@ public void AssertResolverThrows()\n         // and it successfully resolves sdk.\n         public void AssertSecondResolverWithPatternCanResolve()\n         {\n-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));\n+            var service = new SdkResolverService();\n+            service.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));\n \n             SdkReference sdk = new SdkReference(\"2sdkName\", \"referencedVersion\", \"minimumVersion\");\n \n-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation(\"file\"), \"sln\", \"projectPath\", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);\n+            var result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation(\"file\"), \"sln\", \"projectPath\", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);\n \n             result.Path.ShouldBe(\"resolverpathwithresolvablesdkpattern2\");\n             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain(\"MockSdkResolverWithResolvableSdkPattern2 running\");\n             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain(\"MockSdkResolver1 running\");\n             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain(\"MockSdkResolver2 running\");\n         }\n \n+#if DEBUG\n+        internal void TryResolveSdk(out bool success)\n+        {\n+            success = true;\n+            SdkReference sdk = new SdkReference(\"2sdkName\", \"referencedVersion\", \"minimumVersion\");\n+            try\n+            {\n+                s_sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId,\n+                                                        sdk,\n+                                                        _loggingContext,\n+                                                        new MockElementLocation(\"file\"),\n+                                                        \"sln\",\n+                                                        \"projectPath\",\n+                                                        interactive: false,\n+                                                        isRunningInVisualStudio: false,\n+                                                        failOnUnresolvedSdk: true);\n+            }\n+            catch (Exception)\n+            {\n+                success = false;\n+            }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Fair enough. I will propagate the error message if it happens.\r\nMy original though was that it doesn't matter all that much since the test is targeted at only one specific error.",
              "createdAt": "2024-12-09T12:20:23Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs",
              "diffHunk": "@@ -122,28 +130,87 @@ public void AssertResolverThrows()\n         // and it successfully resolves sdk.\n         public void AssertSecondResolverWithPatternCanResolve()\n         {\n-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));\n+            var service = new SdkResolverService();\n+            service.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));\n \n             SdkReference sdk = new SdkReference(\"2sdkName\", \"referencedVersion\", \"minimumVersion\");\n \n-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation(\"file\"), \"sln\", \"projectPath\", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);\n+            var result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation(\"file\"), \"sln\", \"projectPath\", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);\n \n             result.Path.ShouldBe(\"resolverpathwithresolvablesdkpattern2\");\n             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain(\"MockSdkResolverWithResolvableSdkPattern2 running\");\n             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain(\"MockSdkResolver1 running\");\n             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain(\"MockSdkResolver2 running\");\n         }\n \n+#if DEBUG\n+        internal void TryResolveSdk(out bool success)\n+        {\n+            success = true;\n+            SdkReference sdk = new SdkReference(\"2sdkName\", \"referencedVersion\", \"minimumVersion\");\n+            try\n+            {\n+                s_sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId,\n+                                                        sdk,\n+                                                        _loggingContext,\n+                                                        new MockElementLocation(\"file\"),\n+                                                        \"sln\",\n+                                                        \"projectPath\",\n+                                                        interactive: false,\n+                                                        isRunningInVisualStudio: false,\n+                                                        failOnUnresolvedSdk: true);\n+            }\n+            catch (Exception)\n+            {\n+                success = false;\n+            }",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we use \"Extended Unit Under Test\" pattern instead of conditional code within production code?",
              "createdAt": "2024-12-11T15:21:56Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -48,12 +51,17 @@ internal class SdkResolverService : ISdkResolverService\n         /// <summary>\n         /// Stores the list of manifests of specific SDK resolvers which could be loaded.\n         /// </summary>\n-        private IList<SdkResolverManifest> _specificResolversManifestsRegistry;\n+        private IReadOnlyList<SdkResolverManifest> _specificResolversManifestsRegistry;\n \n         /// <summary>\n         /// Stores the list of manifests of general SDK resolvers which could be loaded.\n         /// </summary>\n-        private IList<SdkResolverManifest> _generalResolversManifestsRegistry;\n+        private IReadOnlyList<SdkResolverManifest> _generalResolversManifestsRegistry;\n+\n+#if DEBUG",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would a signalable event be more reliable?",
              "createdAt": "2024-12-11T15:22:25Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -178,6 +186,13 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd\n             List<SdkResolverManifest> matchingResolversManifests = new();\n             foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n             {\n+#if DEBUG\n+                // If we're checking about the race condition, we should better make sure we would hit it.\n+                if (_fake_initialization)\n+                {\n+                    Thread.Sleep(10);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "To sum up the discussion:\r\nthis is a negative test, that should eventually hit if we reintroduce this contention condition. Under normal circumstances, this will not fail. It might accidentally succeed, but as long as it fails eventually, it should be fine.\r\nFrom the other hand - modifying the behavior of the function to accurately reproduce the contention would most likely do more harm than good since it would require several \"wait here until given go ahead\" kind of signals. ",
              "createdAt": "2024-12-13T15:31:07Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -178,6 +186,13 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd\n             List<SdkResolverManifest> matchingResolversManifests = new();\n             foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n             {\n+#if DEBUG\n+                // If we're checking about the race condition, we should better make sure we would hit it.\n+                if (_fake_initialization)\n+                {\n+                    Thread.Sleep(10);",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Is this a placeholder?\r\nVery likely just a metter of personal preference - I personally would name this same as the filed, just without the '_' prefix, or if needed, then with 'Local' suffix?",
              "createdAt": "2024-12-13T18:36:42Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -484,24 +492,37 @@ private void RegisterResolversManifests(ElementLocation location)\n                     }\n                 }\n \n+                var specificResolversManifestsRegistryPlaceholder = new List<SdkResolverManifest>();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}