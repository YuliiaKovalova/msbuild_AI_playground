{
  "number": 9214,
  "title": "Add \"cache add\" functionality to project caching - Attempt 2",
  "body": "This is a redo of #8726, but with fixes to make the changes acceptable for VS insertion.",
  "state": "MERGED",
  "createdAt": "2023-09-11T17:25:15Z",
  "updatedAt": "2023-10-09T22:34:11Z",
  "closedAt": "2023-09-19T19:23:14Z",
  "mergedAt": "2023-09-19T19:23:14Z",
  "additions": 2658,
  "deletions": 54,
  "changedFiles": 79,
  "headRefName": "project-cache-vnext-retry",
  "isDraft": false,
  "author": {
    "login": "dfederm"
  },
  "milestone": {
    "title": "VS 17.8"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "2dcbce18c157a3a519430b79f60e81822e33d4d4",
          "message": "Revert \"Revert 'Add \"cache add\" functionality to project caching' (#9188)\"\n\nThis reverts commit 3c910ba83fc9dbd8e12f50dddc8c381404f928c4.",
          "committedDate": "2023-08-30T15:03:14Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d76e92a13c2717d91762b3f4a527db1d1efd4084",
          "message": "Add pkgdef entries to redirect to BXL stuff",
          "committedDate": "2023-08-30T15:13:37Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "01c14a72278129fcfc0ec792f520784e83c8501d",
          "message": "Add missing files to binding redirects/swr",
          "committedDate": "2023-08-31T01:46:44Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7dd37d80ae01bf8927274b0ab8fd276a291133e2",
          "message": "Avoid BuildXL assembly load when not opted in",
          "committedDate": "2023-08-31T01:47:38Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "180ff519a80ee1ad455a62f313509c4fa89c8f3e",
          "message": "Another attempt at avoiding BuildXL assembly load",
          "committedDate": "2023-08-31T17:35:02Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2a71f5614ce79af654d4f99e6b00da3d3a1fd1eb",
          "message": "Remove IBuildParameters implementation",
          "committedDate": "2023-09-01T15:39:02Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d3753ceebe041f5502221339462bd50518465f00",
          "message": "Revert \"Another attempt at avoiding BuildXL assembly load\"\n\nThis reverts commit 180ff519a80ee1ad455a62f313509c4fa89c8f3e.",
          "committedDate": "2023-09-04T12:23:16Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "52206bbb59fb932f20dd3aca061cd8f09ff9e286",
          "message": "Make EnableDetouredNodeLauncher non-inlinable",
          "committedDate": "2023-09-04T12:28:01Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "afdac916d1348d129f177d7f9e0e8d9025d39089",
          "message": "Add Dependency(LoadHint.Sometimes) for BuildXL assemblies",
          "committedDate": "2023-09-05T08:19:09Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "79ad288260f45cfed91b99a2e45d05ff4a67ecfa",
          "message": "[Experiment] Remove types that implement BuildXL interfaces",
          "committedDate": "2023-09-06T06:51:36Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4e7ceac48e283cc78fce918bd349c1c8e7fbdc8d",
          "message": "Revert \"[Experiment] Remove types that implement BuildXL interfaces\"\n\nThis reverts commit 79ad288260f45cfed91b99a2e45d05ff4a67ecfa.",
          "committedDate": "2023-09-06T14:49:54Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9779f386f0fd7cf2c5eb9f92da2520d6e693adf7",
          "message": "Remove unused EnvironmentalBuildParameters",
          "committedDate": "2023-09-06T14:50:16Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "70b4bcfef16a825230647fc33527329713a70dcd",
          "message": "Explicitly NGEN new dependencies",
          "committedDate": "2023-09-07T07:45:26Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "07256def693b1d8e57f1c997f2b310ed030f05b2",
          "message": "Revert \"Explicitly NGEN new dependencies\"\n\nThis reverts commit 70b4bcfef16a825230647fc33527329713a70dcd.",
          "committedDate": "2023-09-08T19:34:07Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "60d49fd3a911923f3cac2412fedbdb0f223cb51b",
          "message": "Fix System.Threading.Channels public key token",
          "committedDate": "2023-09-11T12:17:13Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This `StartsWith` is culture specific while the previous one is ordinal. ",
              "createdAt": "2023-10-09T21:57:56Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,188 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if FEATURE_REPORTFILEACCESSES\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);\n+\n+        // In order to synchronize between the node communication and the file access reporting, a special file access\n+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen\n+        // and the build result is reported can plugins be notified about project completion.\n+        // NOTE! This is currently Windows-specific and will need to change once this feature is opened up to more scenarios.\n+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @\":\\{MSBuildFileAccessCompletion}\\\";\n+\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private object _handlersWriteLock = new object();\n+        private Handlers[] _handlers = Array.Empty<Handlers>();\n+        private string? _tempDirectory;\n+\n+        // Keyed on global request id\n+        private readonly ConcurrentDictionary<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles = new();\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new FileAccessManager();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;\n+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;\n+            _tempDirectory = FileUtilities.EnsureNoTrailingSlash(FileUtilities.TempFileDirectory);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _scheduler = null;\n+            _configCache = null;\n+            _tempDirectory = null;\n+            _fileAccessCompletionWaitHandles.Clear();\n+        }\n+\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)\n+        {\n+            string fileAccessPath = fileAccessData.Path;\n+\n+            // Intercept and avoid forwarding the file access completion\n+            if (fileAccessPath.StartsWith(FileAccessCompletionPrefix, StringComparison.Ordinal))\n+            {\n+                // Parse out the global request id. Note, this must match what NotifyFileAccessCompletion does.\n+                int globalRequestId = int.Parse(fileAccessPath.Substring(FileAccessCompletionPrefix.Length));\n+\n+                ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());\n+                handle.Set();\n+            }\n+            else if (_tempDirectory != null && fileAccessPath.StartsWith(_tempDirectory))",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Did you consider making this parameter `in FileAccessData`? This is a 9 member `struct` which means every call to this API is going to involve a lot of copies. This API is going to be called a lot in a tight loop for non-trivial build operations so it's one where efficiency may be important. ",
              "createdAt": "2023-10-09T22:03:59Z",
              "path": "src/Framework/EngineServices.cs",
              "diffHunk": "@@ -45,5 +54,12 @@ public abstract class EngineServices\n         /// This is a performance optimization allowing tasks to skip expensive double-logging.\n         /// </remarks>\n         public virtual bool IsTaskInputLoggingEnabled => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Reports a file access from a task.\n+        /// </summary>\n+        /// <param name=\"fileAccessData\">The file access to report.</param>\n+        [CLSCompliant(false)]\n+        public virtual void ReportFileAccess(FileAccessData fileAccessData) => throw new NotImplementedException();",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is another case where we're copying a large `struct` in a loop (this is nested in another loop so even more copies).",
              "createdAt": "2023-10-09T22:14:15Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,188 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if FEATURE_REPORTFILEACCESSES\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);\n+\n+        // In order to synchronize between the node communication and the file access reporting, a special file access\n+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen\n+        // and the build result is reported can plugins be notified about project completion.\n+        // NOTE! This is currently Windows-specific and will need to change once this feature is opened up to more scenarios.\n+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @\":\\{MSBuildFileAccessCompletion}\\\";\n+\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private object _handlersWriteLock = new object();\n+        private Handlers[] _handlers = Array.Empty<Handlers>();\n+        private string? _tempDirectory;\n+\n+        // Keyed on global request id\n+        private readonly ConcurrentDictionary<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles = new();\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new FileAccessManager();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;\n+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;\n+            _tempDirectory = FileUtilities.EnsureNoTrailingSlash(FileUtilities.TempFileDirectory);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _scheduler = null;\n+            _configCache = null;\n+            _tempDirectory = null;\n+            _fileAccessCompletionWaitHandles.Clear();\n+        }\n+\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)\n+        {\n+            string fileAccessPath = fileAccessData.Path;\n+\n+            // Intercept and avoid forwarding the file access completion\n+            if (fileAccessPath.StartsWith(FileAccessCompletionPrefix, StringComparison.Ordinal))\n+            {\n+                // Parse out the global request id. Note, this must match what NotifyFileAccessCompletion does.\n+                int globalRequestId = int.Parse(fileAccessPath.Substring(FileAccessCompletionPrefix.Length));\n+\n+                ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());\n+                handle.Set();\n+            }\n+            else if (_tempDirectory != null && fileAccessPath.StartsWith(_tempDirectory))\n+            {\n+                // Ignore MSBuild's temp directory as these are related to internal MSBuild functionality and not always directly related to the execution of the project itself,\n+                // so should not be exposed to handlers. Note that this is not %TEMP% but instead a subdir under %TEMP% which is only expected to be used by MSBuild.\n+                return;\n+            }\n+            else\n+            {\n+                // Forward the file access to handlers.\n+                BuildRequest? buildRequest = GetBuildRequest(nodeId);\n+                if (buildRequest != null)\n+                {\n+                    Handlers[] localHandlers = _handlers;\n+                    foreach (Handlers handlers in localHandlers)\n+                    {\n+                        handlers.FileAccessHander.Invoke(buildRequest, fileAccessData);",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is a place you should consider using \r\n\r\n```csharp\r\nintenal ref readonly FileAccessData FileAccessData => ref _fileAccessData;\r\n```\r\n\r\nOtherwise you're doing a full copy just to access one or two members. ",
              "createdAt": "2023-10-09T22:28:27Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs",
              "diffHunk": "@@ -0,0 +1,27 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessReport : INodePacket\n+    {\n+        private FileAccessData _fileAccessData;\n+\n+        internal FileAccessReport(FileAccessData fileAccessData) => _fileAccessData = fileAccessData;\n+\n+        private FileAccessReport(ITranslator translator) => Translate(translator);\n+\n+        /// <inheritdoc/>\n+        public NodePacketType Type => NodePacketType.FileAccessReport;\n+\n+        /// <inheritdoc/>\n+        public void Translate(ITranslator translator) => translator.Translate(ref _fileAccessData);\n+\n+        internal FileAccessData FileAccessData => _fileAccessData;",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Another place to consider `in FileAccessData` ",
              "createdAt": "2023-10-09T22:28:38Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs",
              "diffHunk": "@@ -0,0 +1,27 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessReport : INodePacket\n+    {\n+        private FileAccessData _fileAccessData;\n+\n+        internal FileAccessReport(FileAccessData fileAccessData) => _fileAccessData = fileAccessData;",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Another place to consider `in` ",
              "createdAt": "2023-10-09T22:28:59Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,26 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if FEATURE_REPORTFILEACCESSES\n+using System;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal interface IFileAccessManager\n+    {\n+        void ReportFileAccess(FileAccessData fileAccessData, int nodeId);",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can use `in` here",
              "createdAt": "2023-10-09T22:32:57Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs",
              "diffHunk": "@@ -39,5 +41,32 @@ public abstract class ProjectCachePluginBase\n         ///     Errors are checked via <see cref=\"PluginLoggerBase.HasLoggedErrors\" />.\n         /// </summary>\n         public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+        /// <summary>\n+        ///     Called for each file access from an MSBuild node or one of its children.\n+        /// </summary>\n+        [CLSCompliant(false)]\n+        public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData)",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can use `in` here",
              "createdAt": "2023-10-09T22:33:04Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs",
              "diffHunk": "@@ -39,5 +41,32 @@ public abstract class ProjectCachePluginBase\n         ///     Errors are checked via <see cref=\"PluginLoggerBase.HasLoggedErrors\" />.\n         /// </summary>\n         public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+        /// <summary>\n+        ///     Called for each file access from an MSBuild node or one of its children.\n+        /// </summary>\n+        [CLSCompliant(false)]\n+        public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData)\n+        {\n+        }\n+\n+        /// <summary>\n+        ///     Called for each new child process created by an MSBuild node or one of its children.\n+        /// </summary>\n+        [CLSCompliant(false)]\n+        public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData)",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "A place where you can use `ref readonly` to alleviate copies \r\n\r\n```csharp\r\ninternal ref readonly ProcessData ProcessData => ref _processData;\r\n```",
              "createdAt": "2023-10-09T22:33:30Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs",
              "diffHunk": "@@ -0,0 +1,27 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class ProcessReport : INodePacket\n+    {\n+        private ProcessData _processData;\n+\n+        internal ProcessReport(ProcessData processData) => _processData = processData;\n+\n+        private ProcessReport(ITranslator translator) => Translate(translator);\n+\n+        /// <inheritdoc/>\n+        public NodePacketType Type => NodePacketType.ProcessReport;\n+\n+        internal ProcessData ProcessData => _processData;",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "can use `in` here",
              "createdAt": "2023-10-09T22:33:38Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs",
              "diffHunk": "@@ -0,0 +1,27 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class ProcessReport : INodePacket\n+    {\n+        private ProcessData _processData;\n+\n+        internal ProcessReport(ProcessData processData) => _processData = processData;",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Copying a large struct in a loop ",
              "createdAt": "2023-10-09T22:34:04Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,188 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if FEATURE_REPORTFILEACCESSES\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);\n+\n+        // In order to synchronize between the node communication and the file access reporting, a special file access\n+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen\n+        // and the build result is reported can plugins be notified about project completion.\n+        // NOTE! This is currently Windows-specific and will need to change once this feature is opened up to more scenarios.\n+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @\":\\{MSBuildFileAccessCompletion}\\\";\n+\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private object _handlersWriteLock = new object();\n+        private Handlers[] _handlers = Array.Empty<Handlers>();\n+        private string? _tempDirectory;\n+\n+        // Keyed on global request id\n+        private readonly ConcurrentDictionary<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles = new();\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new FileAccessManager();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;\n+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;\n+            _tempDirectory = FileUtilities.EnsureNoTrailingSlash(FileUtilities.TempFileDirectory);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _scheduler = null;\n+            _configCache = null;\n+            _tempDirectory = null;\n+            _fileAccessCompletionWaitHandles.Clear();\n+        }\n+\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)\n+        {\n+            string fileAccessPath = fileAccessData.Path;\n+\n+            // Intercept and avoid forwarding the file access completion\n+            if (fileAccessPath.StartsWith(FileAccessCompletionPrefix, StringComparison.Ordinal))\n+            {\n+                // Parse out the global request id. Note, this must match what NotifyFileAccessCompletion does.\n+                int globalRequestId = int.Parse(fileAccessPath.Substring(FileAccessCompletionPrefix.Length));\n+\n+                ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());\n+                handle.Set();\n+            }\n+            else if (_tempDirectory != null && fileAccessPath.StartsWith(_tempDirectory))\n+            {\n+                // Ignore MSBuild's temp directory as these are related to internal MSBuild functionality and not always directly related to the execution of the project itself,\n+                // so should not be exposed to handlers. Note that this is not %TEMP% but instead a subdir under %TEMP% which is only expected to be used by MSBuild.\n+                return;\n+            }\n+            else\n+            {\n+                // Forward the file access to handlers.\n+                BuildRequest? buildRequest = GetBuildRequest(nodeId);\n+                if (buildRequest != null)\n+                {\n+                    Handlers[] localHandlers = _handlers;\n+                    foreach (Handlers handlers in localHandlers)\n+                    {\n+                        handlers.FileAccessHander.Invoke(buildRequest, fileAccessData);\n+                    }\n+                }\n+            }\n+        }\n+\n+        public void ReportProcess(ProcessData processData, int nodeId)\n+        {\n+            BuildRequest? buildRequest = GetBuildRequest(nodeId);\n+            if (buildRequest != null)\n+            {\n+                Handlers[] localHandlers = _handlers;\n+                foreach (Handlers handlers in localHandlers)\n+                {\n+                    handlers.ProcessHandler.Invoke(buildRequest, processData);",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      }
    ]
  }
}