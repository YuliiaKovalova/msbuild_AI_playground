{
  "number": 7026,
  "title": "Optimize diag level for file logger and console logger",
  "body": "Fixes #7022\r\n\r\n### Context\r\nDuring investigation of #7022 I have found out that method `ParallelConsoleLogger.WriteMessageAligned` is very CPU and memory demanding. Main problem seemed to be in splitting message into lines by `String.Split` for purpose of aligning and indenting.\r\n\r\n### Changes Made\r\n- using IndexOf('\\n') loop instead of split\r\n- using IndexOf('\\t') loop instead of string.Replace('\\t', ...)\r\n- reusing single instance StringBuilder\r\n- encapsulate console formatting logic into class\r\n- unit tests console formatting logic\r\n\r\n### Testing\r\nUnit testing.\r\nVarious manual builds.\r\nCompare file logger output by replaying binlog - files were binary identical.\r\nCompare console logger output replaying binlog  - files were binary identical.\r\n\r\n### Results\r\n![image](https://user-images.githubusercontent.com/25249058/141145427-08abae26-aadb-4e79-99c5-5d49f04070c4.png)\r\n\r\nAs for memory I have measured, during incremental OrchardCore build, more than 50% saving. In particular 40,001.786 MB vs 16,567.717 MB\r\n\r\nThis gain is suspiciously more than I have expected. By digging deeper into it, I found out that majority of the gain comes actually from less writes to file logger stream as this stream has, by default, auto flush. My changes build string and push it into stream, as opposed to old version which called `Write` couple times per output line.\r\n\r\nJust to make sure that things make sense I have also measured the perf difference with `flp:\"v=diag;NOAUTOFLUSH\"`.\r\n![image](https://user-images.githubusercontent.com/25249058/141753125-70e60796-7288-4eef-88ed-7234129b5be9.png)\r\n\r\nHowever, people do not use `NOAUTOFLUSH` also partially because they are afraid missing critical log info during theoretical MSBuild crash.\r\n\r\n### Notes\r\n\r\nTABs have now slightly different implementation than before. Now TAB are not simply replaced by spaces but properly aligned to console tabs position. Also few bugs of handling TABs has been fixed. That being said, TABs are not used as often. During compile of OrchardCore there is no simple TAB in logged messages at diag level.\r\n\r\nIt has been decide ChangeWave is enough.\r\n\r\n",
  "state": "MERGED",
  "createdAt": "2021-11-09T13:14:55Z",
  "updatedAt": "2022-10-11T07:21:33Z",
  "closedAt": "2021-11-22T22:30:44Z",
  "mergedAt": "2021-11-22T22:30:44Z",
  "additions": 574,
  "deletions": 34,
  "changedFiles": 5,
  "headRefName": "rokonec/7022-optimize-diag-cosole-logger",
  "isDraft": false,
  "author": {
    "login": "rokonec"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "rokonec"
      }
    ]
  },
  "labels": [
    "Area: Performance",
    "Area: Logging",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "ee18e506a1660a1669b0575526b22d937cf38b09",
          "message": "Replace String.Split by IndexOf loop\n\n- shortcut for file loggers\n- IndexOf loop for tab chars",
          "committedDate": "2021-11-07T18:56:26Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "960ef8c7f99fcf8838dfc2eb857a405039631968",
          "message": "Refactoring into humble class, unit tests and fixes",
          "committedDate": "2021-11-09T13:10:49Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2f0d535f9ca16cc32588a3679e434aa3f6d74609",
          "message": "Imporve unit tests",
          "committedDate": "2021-11-09T19:21:14Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a636d804f613ad15b38d9ff83310fd521a131598",
          "message": "Remove too optimistic optimization",
          "committedDate": "2021-11-09T19:21:43Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "72d78bac8f60228c08295de4265f8be77f05ad3d",
          "message": "Fix bud when newline is first or last character",
          "committedDate": "2021-11-09T19:22:40Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "278ad07da7b11b74c32f2dd1e5aeefd86fc51f40",
          "message": "Add mising unit tests theory cases",
          "committedDate": "2021-11-09T19:25:35Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ba1cd410d7179514edbf906c309788bd51b4d504",
          "message": "Minor refactoring",
          "committedDate": "2021-11-09T19:26:33Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8daa4b02e4e48f64c0881409efe209f996244aaf",
          "message": "Fix missing logger initialization in unit test",
          "committedDate": "2021-11-09T19:57:28Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ef763815adcd55a19a266e3376aa54c045c8c03c",
          "message": "Another unti tests fixed",
          "committedDate": "2021-11-09T22:19:15Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c6e6a2e549c5840e807e94b82ed3c78a98f2f841",
          "message": "Add debug assets for thread safety violation.",
          "committedDate": "2021-11-10T16:11:30Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "86ea2d03c274998091b1d4b458f1242ca995bb82",
          "message": "Fix for non standard line ends",
          "committedDate": "2021-11-12T09:29:20Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b8fd3caec36408e53bb020a6aeccee827b2d741f",
          "message": "comment",
          "committedDate": "2021-11-12T09:35:05Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "984e7f07902d6e5232462e5ac491b0a265b76132",
          "message": "Remove useles Debug.Assert",
          "committedDate": "2021-11-12T09:59:14Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fe74c2cf80f4cabb9aed1c33f4e0db8f11b2fc99",
          "message": "Minor review changes, Ladi #1.\nRemoving EscapeHatch.",
          "committedDate": "2021-11-16T09:30:49Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1ba43491cc1ebdd2d8077ee867756dc44db46554",
          "message": "Added unit tests for \\r",
          "committedDate": "2021-11-18T15:58:03Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "FYI you might like the [`LazyStringSplit`](https://github.com/dotnet/project-system/blob/main/src/Microsoft.VisualStudio.ProjectSystem.Managed/Text/LazyStringSplit.cs) pattern we have in the .NET Project System. It's basically the `IndexOf` loop you have here, but wrapped up in a zero-cost abstraction, enabling `foreach` (which makes consuming code a bit clearer).",
        "createdAt": "2021-11-14T21:52:08Z",
        "author": {
          "login": "drewnoakes"
        }
      },
      {
        "body": "@drewnoakes I like the `LazyStringSplit` pattern from .NET Project System.\r\nUsing `LazyStringSplit` is better than `string.Split` as it does not allocate resulting `string[]` however in this particular use case we need to eliminate allocation of substring  (lines of messages) as there are log messages with hundreds of lines in diag verbosity.",
        "createdAt": "2021-11-15T16:44:52Z",
        "author": {
          "login": "rokonec"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Isn't there some kind of central SB pooling you can use? I can't search the code at the moment.",
              "createdAt": "2021-11-09T13:33:39Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,148 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "I am aware of existence of their pools (we have 2 actually), but since I am optimizing for diag and with this loglevel verbosity usage of this StringBuilder is quite hot, there is no point, IMHO, to rent and return sb to the pool when its constantly needed.",
              "createdAt": "2021-11-10T16:20:29Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,148 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Indent",
              "createdAt": "2021-11-09T13:34:04Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,148 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+            try\n+            {\n+                StringBuilder sb = _reusedStringBuilder;\n+                sb.Length = 0;\n+                // The string contains new lines, treat each new line as a different string to format and send to the console\n+                while (j >= 0)\n+                {\n+                    AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                    i = j + (message[j] == '\\r' ? 2 : 1);\n+                    j = i < message.Length ? message.IndexOfAny(MSBuildConstants.CrLf, i) : -1;\n+                }\n+\n+                // Process rest of message\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, message.Length - i);\n+\n+                return sb.ToString();\n+            }\n+            finally\n+            {\n+                // prepare for reuse\n+                _reusedStringBuilder.Length = 0;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append aligned and indented message lines into running <see cref=\"StringBuilder\"/>.\n+        /// </summary>\n+        private void AlignAndIndentLineOfMessage(StringBuilder sb, bool prefixAlreadyWritten, int prefixWidth, string message, int start, int count)\n+        {\n+            int bufferWidthMinusNewLine = _bufferWidth - 1;\n+\n+            bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > prefixWidth;\n+            if (bufferIsLargerThanPrefix && _alignMessages)\n+            {\n+                // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages.\n+\n+                // Beginning index of string to be written\n+                int index = 0;\n+                // Loop until all the string has been sent to the console\n+                while (index < count)\n+                {\n+                    // Position of virtual console cursor.\n+                    // By simulating cursor position adjustment for tab characters '\\t' we can compute\n+                    // exact numbers of characters from source string to fit into Console.BufferWidth",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is the substring here passed to loggers? If not can you avoid creating it and use Span?",
              "createdAt": "2021-11-09T13:35:33Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1344,40 +1344,57 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int\n             {\n                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;\n \n-                // The string may contain new lines, treat each new line as a different string to format and send to the console\n-                string[] nonNullMessages = SplitStringOnNewLines(message);\n-                for (int i = 0; i < nonNullMessages.Length; i++)\n+                if (Traits.Instance.EscapeHatches.DoNotOptimizeConsoleLogger || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))\n                 {\n-                    string nonNullMessage = nonNullMessages[i];\n-                    // Take into account the new line char which will be added to the end or each reformatted string\n-                    int bufferWidthMinusNewLine = _bufferWidth - 1;\n-\n-                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n-                    // If there is not enough room just print the message out and let the console do the formatting\n-                    bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n-                    bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n-                    if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                    // The string may contain new lines, treat each new line as a different string to format and send to the console\n+                    string[] nonNullMessages = SplitStringOnNewLines(message);\n+                    for (int i = 0; i < nonNullMessages.Length; i++)\n                     {\n-                        // Our message may have embedded tab characters, so expand those to their space\n-                        // equivalent so that wrapping works as expected.\n-                        nonNullMessage = nonNullMessage.Replace(\"\\t\", consoleTab);\n-\n-                        // If the message and the prefix are too large for one line in the console, split the string to fit\n-                        int index = 0;\n-                        int messageLength = nonNullMessage.Length;\n-                        // Loop until all the string has been sent to the console\n-                        while (index < messageLength)\n+                        string nonNullMessage = nonNullMessages[i];\n+                        // Take into account the new line char which will be added to the end or each reformatted string\n+                        int bufferWidthMinusNewLine = _bufferWidth - 1;\n+\n+                        // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n+                        // If there is not enough room just print the message out and let the console do the formatting\n+                        bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n+                        bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n+                        if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                        {\n+                            // Our message may have embedded tab characters, so expand those to their space\n+                            // equivalent so that wrapping works as expected.\n+                            nonNullMessage = nonNullMessage.Replace(\"\\t\", consoleTab);\n+\n+                            // If the message and the prefix are too large for one line in the console, split the string to fit\n+                            int index = 0;\n+                            int messageLength = nonNullMessage.Length;\n+                            // Loop until all the string has been sent to the console\n+                            while (index < messageLength)\n+                            {\n+                                // Calculate how many chars will fit on the console buffer\n+                                int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);\n+                                WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "In general we should aim to allocate zero strings in MSBuild, only using them when they need to go to API we can't change eg loggers, ITask, external API that require strings\ufffc. Slicing Spans is extremely efficient.",
              "createdAt": "2021-11-09T13:38:12Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1344,40 +1344,57 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int\n             {\n                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;\n \n-                // The string may contain new lines, treat each new line as a different string to format and send to the console\n-                string[] nonNullMessages = SplitStringOnNewLines(message);\n-                for (int i = 0; i < nonNullMessages.Length; i++)\n+                if (Traits.Instance.EscapeHatches.DoNotOptimizeConsoleLogger || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))\n                 {\n-                    string nonNullMessage = nonNullMessages[i];\n-                    // Take into account the new line char which will be added to the end or each reformatted string\n-                    int bufferWidthMinusNewLine = _bufferWidth - 1;\n-\n-                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n-                    // If there is not enough room just print the message out and let the console do the formatting\n-                    bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n-                    bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n-                    if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                    // The string may contain new lines, treat each new line as a different string to format and send to the console\n+                    string[] nonNullMessages = SplitStringOnNewLines(message);\n+                    for (int i = 0; i < nonNullMessages.Length; i++)\n                     {\n-                        // Our message may have embedded tab characters, so expand those to their space\n-                        // equivalent so that wrapping works as expected.\n-                        nonNullMessage = nonNullMessage.Replace(\"\\t\", consoleTab);\n-\n-                        // If the message and the prefix are too large for one line in the console, split the string to fit\n-                        int index = 0;\n-                        int messageLength = nonNullMessage.Length;\n-                        // Loop until all the string has been sent to the console\n-                        while (index < messageLength)\n+                        string nonNullMessage = nonNullMessages[i];\n+                        // Take into account the new line char which will be added to the end or each reformatted string\n+                        int bufferWidthMinusNewLine = _bufferWidth - 1;\n+\n+                        // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n+                        // If there is not enough room just print the message out and let the console do the formatting\n+                        bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n+                        bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n+                        if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                        {\n+                            // Our message may have embedded tab characters, so expand those to their space\n+                            // equivalent so that wrapping works as expected.\n+                            nonNullMessage = nonNullMessage.Replace(\"\\t\", consoleTab);\n+\n+                            // If the message and the prefix are too large for one line in the console, split the string to fit\n+                            int index = 0;\n+                            int messageLength = nonNullMessage.Length;\n+                            // Loop until all the string has been sent to the console\n+                            while (index < messageLength)\n+                            {\n+                                // Calculate how many chars will fit on the console buffer\n+                                int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);\n+                                WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "This is old code kept under escape hatch for compatibility reasons.",
              "createdAt": "2021-11-09T19:17:31Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1344,40 +1344,57 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int\n             {\n                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;\n \n-                // The string may contain new lines, treat each new line as a different string to format and send to the console\n-                string[] nonNullMessages = SplitStringOnNewLines(message);\n-                for (int i = 0; i < nonNullMessages.Length; i++)\n+                if (Traits.Instance.EscapeHatches.DoNotOptimizeConsoleLogger || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))\n                 {\n-                    string nonNullMessage = nonNullMessages[i];\n-                    // Take into account the new line char which will be added to the end or each reformatted string\n-                    int bufferWidthMinusNewLine = _bufferWidth - 1;\n-\n-                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n-                    // If there is not enough room just print the message out and let the console do the formatting\n-                    bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n-                    bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n-                    if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                    // The string may contain new lines, treat each new line as a different string to format and send to the console\n+                    string[] nonNullMessages = SplitStringOnNewLines(message);\n+                    for (int i = 0; i < nonNullMessages.Length; i++)\n                     {\n-                        // Our message may have embedded tab characters, so expand those to their space\n-                        // equivalent so that wrapping works as expected.\n-                        nonNullMessage = nonNullMessage.Replace(\"\\t\", consoleTab);\n-\n-                        // If the message and the prefix are too large for one line in the console, split the string to fit\n-                        int index = 0;\n-                        int messageLength = nonNullMessage.Length;\n-                        // Loop until all the string has been sent to the console\n-                        while (index < messageLength)\n+                        string nonNullMessage = nonNullMessages[i];\n+                        // Take into account the new line char which will be added to the end or each reformatted string\n+                        int bufferWidthMinusNewLine = _bufferWidth - 1;\n+\n+                        // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n+                        // If there is not enough room just print the message out and let the console do the formatting\n+                        bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n+                        bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n+                        if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                        {\n+                            // Our message may have embedded tab characters, so expand those to their space\n+                            // equivalent so that wrapping works as expected.\n+                            nonNullMessage = nonNullMessage.Replace(\"\\t\", consoleTab);\n+\n+                            // If the message and the prefix are too large for one line in the console, split the string to fit\n+                            int index = 0;\n+                            int messageLength = nonNullMessage.Length;\n+                            // Loop until all the string has been sent to the console\n+                            while (index < messageLength)\n+                            {\n+                                // Calculate how many chars will fit on the console buffer\n+                                int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);\n+                                WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you use Span rather than creating more strings here?",
              "createdAt": "2021-11-09T13:36:02Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1344,40 +1344,57 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int\n             {\n                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;\n \n-                // The string may contain new lines, treat each new line as a different string to format and send to the console\n-                string[] nonNullMessages = SplitStringOnNewLines(message);\n-                for (int i = 0; i < nonNullMessages.Length; i++)\n+                if (Traits.Instance.EscapeHatches.DoNotOptimizeConsoleLogger || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))\n                 {\n-                    string nonNullMessage = nonNullMessages[i];\n-                    // Take into account the new line char which will be added to the end or each reformatted string\n-                    int bufferWidthMinusNewLine = _bufferWidth - 1;\n-\n-                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n-                    // If there is not enough room just print the message out and let the console do the formatting\n-                    bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n-                    bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n-                    if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                    // The string may contain new lines, treat each new line as a different string to format and send to the console\n+                    string[] nonNullMessages = SplitStringOnNewLines(message);",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "OLD code used in escape hatch to avoid regressions. Kept as close as possible to previous version.",
              "createdAt": "2021-11-09T19:18:36Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1344,40 +1344,57 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int\n             {\n                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;\n \n-                // The string may contain new lines, treat each new line as a different string to format and send to the console\n-                string[] nonNullMessages = SplitStringOnNewLines(message);\n-                for (int i = 0; i < nonNullMessages.Length; i++)\n+                if (Traits.Instance.EscapeHatches.DoNotOptimizeConsoleLogger || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))\n                 {\n-                    string nonNullMessage = nonNullMessages[i];\n-                    // Take into account the new line char which will be added to the end or each reformatted string\n-                    int bufferWidthMinusNewLine = _bufferWidth - 1;\n-\n-                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n-                    // If there is not enough room just print the message out and let the console do the formatting\n-                    bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n-                    bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n-                    if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                    // The string may contain new lines, treat each new line as a different string to format and send to the console\n+                    string[] nonNullMessages = SplitStringOnNewLines(message);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Space after //",
              "createdAt": "2021-11-09T13:36:18Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1344,40 +1344,57 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int\n             {\n                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;\n \n-                // The string may contain new lines, treat each new line as a different string to format and send to the console\n-                string[] nonNullMessages = SplitStringOnNewLines(message);\n-                for (int i = 0; i < nonNullMessages.Length; i++)\n+                if (Traits.Instance.EscapeHatches.DoNotOptimizeConsoleLogger || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))\n                 {\n-                    string nonNullMessage = nonNullMessages[i];\n-                    // Take into account the new line char which will be added to the end or each reformatted string\n-                    int bufferWidthMinusNewLine = _bufferWidth - 1;\n-\n-                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n-                    // If there is not enough room just print the message out and let the console do the formatting\n-                    bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n-                    bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n-                    if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                    // The string may contain new lines, treat each new line as a different string to format and send to the console\n+                    string[] nonNullMessages = SplitStringOnNewLines(message);\n+                    for (int i = 0; i < nonNullMessages.Length; i++)\n                     {\n-                        // Our message may have embedded tab characters, so expand those to their space\n-                        // equivalent so that wrapping works as expected.\n-                        nonNullMessage = nonNullMessage.Replace(\"\\t\", consoleTab);\n-\n-                        // If the message and the prefix are too large for one line in the console, split the string to fit\n-                        int index = 0;\n-                        int messageLength = nonNullMessage.Length;\n-                        // Loop until all the string has been sent to the console\n-                        while (index < messageLength)\n+                        string nonNullMessage = nonNullMessages[i];\n+                        // Take into account the new line char which will be added to the end or each reformatted string\n+                        int bufferWidthMinusNewLine = _bufferWidth - 1;\n+\n+                        // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n+                        // If there is not enough room just print the message out and let the console do the formatting\n+                        bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n+                        bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n+                        if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                        {\n+                            // Our message may have embedded tab characters, so expand those to their space\n+                            // equivalent so that wrapping works as expected.\n+                            nonNullMessage = nonNullMessage.Replace(\"\\t\", consoleTab);\n+\n+                            // If the message and the prefix are too large for one line in the console, split the string to fit\n+                            int index = 0;\n+                            int messageLength = nonNullMessage.Length;\n+                            // Loop until all the string has been sent to the console\n+                            while (index < messageLength)\n+                            {\n+                                // Calculate how many chars will fit on the console buffer\n+                                int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);\n+                                WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);\n+                                index += amountToCopy;\n+                            }\n+                        }\n+                        else\n                         {\n-                            // Calculate how many chars will fit on the console buffer\n-                            int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);\n-                            WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);\n-                            index += amountToCopy;\n+                            //there is not enough room just print the message out and let the console do the formatting",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "OLD code used in escape hatch to avoid regressions. Kept as close as possible to previous version.",
              "createdAt": "2021-11-09T19:18:41Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1344,40 +1344,57 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int\n             {\n                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;\n \n-                // The string may contain new lines, treat each new line as a different string to format and send to the console\n-                string[] nonNullMessages = SplitStringOnNewLines(message);\n-                for (int i = 0; i < nonNullMessages.Length; i++)\n+                if (Traits.Instance.EscapeHatches.DoNotOptimizeConsoleLogger || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))\n                 {\n-                    string nonNullMessage = nonNullMessages[i];\n-                    // Take into account the new line char which will be added to the end or each reformatted string\n-                    int bufferWidthMinusNewLine = _bufferWidth - 1;\n-\n-                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n-                    // If there is not enough room just print the message out and let the console do the formatting\n-                    bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n-                    bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n-                    if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                    // The string may contain new lines, treat each new line as a different string to format and send to the console\n+                    string[] nonNullMessages = SplitStringOnNewLines(message);\n+                    for (int i = 0; i < nonNullMessages.Length; i++)\n                     {\n-                        // Our message may have embedded tab characters, so expand those to their space\n-                        // equivalent so that wrapping works as expected.\n-                        nonNullMessage = nonNullMessage.Replace(\"\\t\", consoleTab);\n-\n-                        // If the message and the prefix are too large for one line in the console, split the string to fit\n-                        int index = 0;\n-                        int messageLength = nonNullMessage.Length;\n-                        // Loop until all the string has been sent to the console\n-                        while (index < messageLength)\n+                        string nonNullMessage = nonNullMessages[i];\n+                        // Take into account the new line char which will be added to the end or each reformatted string\n+                        int bufferWidthMinusNewLine = _bufferWidth - 1;\n+\n+                        // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. \n+                        // If there is not enough room just print the message out and let the console do the formatting\n+                        bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;\n+                        bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;\n+                        if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)\n+                        {\n+                            // Our message may have embedded tab characters, so expand those to their space\n+                            // equivalent so that wrapping works as expected.\n+                            nonNullMessage = nonNullMessage.Replace(\"\\t\", consoleTab);\n+\n+                            // If the message and the prefix are too large for one line in the console, split the string to fit\n+                            int index = 0;\n+                            int messageLength = nonNullMessage.Length;\n+                            // Loop until all the string has been sent to the console\n+                            while (index < messageLength)\n+                            {\n+                                // Calculate how many chars will fit on the console buffer\n+                                int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);\n+                                WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);\n+                                index += amountToCopy;\n+                            }\n+                        }\n+                        else\n                         {\n-                            // Calculate how many chars will fit on the console buffer\n-                            int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);\n-                            WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);\n-                            index += amountToCopy;\n+                            //there is not enough room just print the message out and let the console do the formatting",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "C# 10 interpolated string handlers might provide better performance",
              "createdAt": "2021-11-10T13:01:36Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,148 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "Nevermind, requires net6.0",
              "createdAt": "2021-11-10T13:02:26Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,148 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)",
              "author": {
                "login": "Therzok"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Not sure why this was diffed so badly, but whatever is inside this `if` is identical to the old code, for ChangeWave purposes.",
              "createdAt": "2021-11-10T16:26:09Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1344,42 +1344,49 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int\n             {\n                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;\n \n-                // The string may contain new lines, treat each new line as a different string to format and send to the console\n-                string[] nonNullMessages = SplitStringOnNewLines(message);\n-                for (int i = 0; i < nonNullMessages.Length; i++)\n+                if (Traits.Instance.EscapeHatches.DoNotOptimizeConsoleLogger || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Add `&w=1` to the URL, and it looks great:\r\n![image](https://user-images.githubusercontent.com/12969783/141355583-d2fe8343-1868-4a6d-9b3b-1c1830a2673d.png)\r\n",
              "createdAt": "2021-11-11T19:15:09Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1344,42 +1344,49 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int\n             {\n                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;\n \n-                // The string may contain new lines, treat each new line as a different string to format and send to the console\n-                string[] nonNullMessages = SplitStringOnNewLines(message);\n-                for (int i = 0; i < nonNullMessages.Length; i++)\n+                if (Traits.Instance.EscapeHatches.DoNotOptimizeConsoleLogger || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Found it:\r\n![image](https://user-images.githubusercontent.com/25249058/141375673-88f2ac24-4b96-4dfc-b181-edfd82873877.png)\r\n",
              "createdAt": "2021-11-11T22:06:45Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1344,42 +1344,49 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int\n             {\n                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;\n \n-                // The string may contain new lines, treat each new line as a different string to format and send to the console\n-                string[] nonNullMessages = SplitStringOnNewLines(message);\n-                for (int i = 0; i < nonNullMessages.Length; i++)\n+                if (Traits.Instance.EscapeHatches.DoNotOptimizeConsoleLogger || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this necessary? If someone else is using this in release mode, I think you have bigger problems...",
              "createdAt": "2021-11-11T19:18:28Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,150 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+            try\n+            {\n+                StringBuilder sb = _reusedStringBuilder;\n+                Debug.Assert(sb.Length == 0, \"Something else is using _reusedStringBuilder. Please make sure this instance method is not called concurrently.\");\n+                sb.Length = 0;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I was also battling between 'just in case' vs 'that will never happen'. Now when I think about it I will keep this line, and remove that try..finally. I like it slightly more...",
              "createdAt": "2021-11-11T22:23:07Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,150 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+            try\n+            {\n+                StringBuilder sb = _reusedStringBuilder;\n+                Debug.Assert(sb.Length == 0, \"Something else is using _reusedStringBuilder. Please make sure this instance method is not called concurrently.\");\n+                sb.Length = 0;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-11-12T09:26:36Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,150 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+            try\n+            {\n+                StringBuilder sb = _reusedStringBuilder;\n+                Debug.Assert(sb.Length == 0, \"Something else is using _reusedStringBuilder. Please make sure this instance method is not called concurrently.\");\n+                sb.Length = 0;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it possible to have \\r not followed by \\n? I don't think I've ever seen it, but this looks like missing something.",
              "createdAt": "2021-11-11T19:25:04Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,150 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+            try\n+            {\n+                StringBuilder sb = _reusedStringBuilder;\n+                Debug.Assert(sb.Length == 0, \"Something else is using _reusedStringBuilder. Please make sure this instance method is not called concurrently.\");\n+                sb.Length = 0;\n+                // The string contains new lines, treat each new line as a different string to format and send to the console\n+                while (j >= 0)\n+                {\n+                    AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                    i = j + (message[j] == '\\r' ? 2 : 1);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This would be very unlikely. In such situation, we would skip one character, but what concern me most is that if \\r is last character we could get out of range and most probably crash.\r\n\r\nIt is good point, I will fix it.",
              "createdAt": "2021-11-11T22:19:21Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,150 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+            try\n+            {\n+                StringBuilder sb = _reusedStringBuilder;\n+                Debug.Assert(sb.Length == 0, \"Something else is using _reusedStringBuilder. Please make sure this instance method is not called concurrently.\");\n+                sb.Length = 0;\n+                // The string contains new lines, treat each new line as a different string to format and send to the console\n+                while (j >= 0)\n+                {\n+                    AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                    i = j + (message[j] == '\\r' ? 2 : 1);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "done",
              "createdAt": "2021-11-12T09:26:45Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,150 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+            try\n+            {\n+                StringBuilder sb = _reusedStringBuilder;\n+                Debug.Assert(sb.Length == 0, \"Something else is using _reusedStringBuilder. Please make sure this instance method is not called concurrently.\");\n+                sb.Length = 0;\n+                // The string contains new lines, treat each new line as a different string to format and send to the console\n+                while (j >= 0)\n+                {\n+                    AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                    i = j + (message[j] == '\\r' ? 2 : 1);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Sorry if this is stupid, but should this be:\r\n```suggestion\r\n                    if (!(prefixAlreadyWritten || index > 0 || start > 0) && prefixWidth > 0)\r\n```\r\n?",
              "createdAt": "2021-11-11T19:32:09Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,150 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+            try\n+            {\n+                StringBuilder sb = _reusedStringBuilder;\n+                Debug.Assert(sb.Length == 0, \"Something else is using _reusedStringBuilder. Please make sure this instance method is not called concurrently.\");\n+                sb.Length = 0;\n+                // The string contains new lines, treat each new line as a different string to format and send to the console\n+                while (j >= 0)\n+                {\n+                    AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                    i = j + (message[j] == '\\r' ? 2 : 1);\n+                    j = i < message.Length ? message.IndexOfAny(MSBuildConstants.CrLf, i) : -1;\n+                }\n+\n+                // Process rest of message\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, message.Length - i);\n+\n+                return sb.ToString();\n+            }\n+            finally\n+            {\n+                // prepare for reuse\n+                _reusedStringBuilder.Length = 0;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append aligned and indented message lines into running <see cref=\"StringBuilder\"/>.\n+        /// </summary>\n+        private void AlignAndIndentLineOfMessage(StringBuilder sb, bool prefixAlreadyWritten, int prefixWidth, string message, int start, int count)\n+        {\n+            int bufferWidthMinusNewLine = _bufferWidth - 1;\n+\n+            bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > prefixWidth;\n+            if (_alignMessages && bufferIsLargerThanPrefix && count > 0)\n+            {\n+                // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages\n+\n+                // Beginning index of string to be written\n+                int index = 0;\n+                // Loop until all the string has been sent to the console\n+                while (index < count)\n+                {\n+                    // Position of virtual console cursor.\n+                    // By simulating cursor position adjustment for tab characters '\\t' we can compute\n+                    //   exact numbers of characters from source string to fit into Console.BufferWidth.\n+                    int cursor = 0;\n+\n+                    // Write prefix if needed\n+                    if ((!prefixAlreadyWritten || index > 0 || start > 0) && prefixWidth > 0)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Prefix is written when has not been already written or it is not the very 1st line of the message.\r\nI believe this line is correct, and it is also covered in unite tests.\r\nInput message:\r\n```\r\nprefix:line1\\nline2\\nline3\r\n```\r\noutput:\r\n```\r\nprefix:line1\r\n       line2\r\n       line3\r\n```    ",
              "createdAt": "2021-11-11T21:57:56Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,150 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+            try\n+            {\n+                StringBuilder sb = _reusedStringBuilder;\n+                Debug.Assert(sb.Length == 0, \"Something else is using _reusedStringBuilder. Please make sure this instance method is not called concurrently.\");\n+                sb.Length = 0;\n+                // The string contains new lines, treat each new line as a different string to format and send to the console\n+                while (j >= 0)\n+                {\n+                    AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                    i = j + (message[j] == '\\r' ? 2 : 1);\n+                    j = i < message.Length ? message.IndexOfAny(MSBuildConstants.CrLf, i) : -1;\n+                }\n+\n+                // Process rest of message\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, message.Length - i);\n+\n+                return sb.ToString();\n+            }\n+            finally\n+            {\n+                // prepare for reuse\n+                _reusedStringBuilder.Length = 0;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Append aligned and indented message lines into running <see cref=\"StringBuilder\"/>.\n+        /// </summary>\n+        private void AlignAndIndentLineOfMessage(StringBuilder sb, bool prefixAlreadyWritten, int prefixWidth, string message, int start, int count)\n+        {\n+            int bufferWidthMinusNewLine = _bufferWidth - 1;\n+\n+            bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > prefixWidth;\n+            if (_alignMessages && bufferIsLargerThanPrefix && count > 0)\n+            {\n+                // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages\n+\n+                // Beginning index of string to be written\n+                int index = 0;\n+                // Loop until all the string has been sent to the console\n+                while (index < count)\n+                {\n+                    // Position of virtual console cursor.\n+                    // By simulating cursor position adjustment for tab characters '\\t' we can compute\n+                    //   exact numbers of characters from source string to fit into Console.BufferWidth.\n+                    int cursor = 0;\n+\n+                    // Write prefix if needed\n+                    if ((!prefixAlreadyWritten || index > 0 || start > 0) && prefixWidth > 0)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo `nto`.",
              "createdAt": "2021-11-15T12:32:08Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,143 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `IndexOfAny` handles the case where `i == message.Length` so it doesn't have to be checked explicitly. Can be just:\r\n\r\n```suggestion\r\n                j = message.IndexOfAny(MSBuildConstants.CrLf, i);\r\n```",
              "createdAt": "2021-11-15T12:37:32Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,143 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+\n+            StringBuilder sb = _reusedStringBuilder;\n+            // prepare reused StringBuilder instance for new use.\n+            sb.Length = 0;\n+            // The string contains new lines, treat each new line as a different string to format and send to the console\n+            while (j >= 0)\n+            {\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                i = j + (message[j] == '\\r' && (j + 1) < message.Length && message[j + 1] == '\\n' ? 2 : 1);\n+                j = i < message.Length ? message.IndexOfAny(MSBuildConstants.CrLf, i) : -1;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Done",
              "createdAt": "2021-11-16T09:08:08Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,143 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+\n+            StringBuilder sb = _reusedStringBuilder;\n+            // prepare reused StringBuilder instance for new use.\n+            sb.Length = 0;\n+            // The string contains new lines, treat each new line as a different string to format and send to the console\n+            while (j >= 0)\n+            {\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                i = j + (message[j] == '\\r' && (j + 1) < message.Length && message[j + 1] == '\\n' ? 2 : 1);\n+                j = i < message.Length ? message.IndexOfAny(MSBuildConstants.CrLf, i) : -1;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo in the env var name and inconsistent S/Z.\r\n```suggestion\r\n        public readonly bool DoNotOptimizeConsoleLogger = Environment.GetEnvironmentVariable(\"MSBUILDDONOTOPTIMIZECONSOLELOGGER\") == \"1\";\r\n```",
              "createdAt": "2021-11-15T12:43:27Z",
              "path": "src/Shared/Traits.cs",
              "diffHunk": "@@ -145,6 +145,8 @@ internal class EscapeHatches\n         /// </summary>\n         public readonly bool AlwaysEvaluateDangerousGlobs = Environment.GetEnvironmentVariable(\"MSBuildAlwaysEvaluateDangerousGlobs\") == \"1\";\n \n+        public readonly bool DoNotOptimizeConsoleLogger = Environment.GetEnvironmentVariable(\"MSBUILDDONOOPTIMISECONSOLELOGGER\") == \"1\";",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "This Trait has been remove. This change will be under ChangeWaves only.",
              "createdAt": "2021-11-16T09:09:39Z",
              "path": "src/Shared/Traits.cs",
              "diffHunk": "@@ -145,6 +145,8 @@ internal class EscapeHatches\n         /// </summary>\n         public readonly bool AlwaysEvaluateDangerousGlobs = Environment.GetEnvironmentVariable(\"MSBuildAlwaysEvaluateDangerousGlobs\") == \"1\";\n \n+        public readonly bool DoNotOptimizeConsoleLogger = Environment.GetEnvironmentVariable(\"MSBUILDDONOOPTIMISECONSOLELOGGER\") == \"1\";",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `_alignMessages` is not set only in this method. The code seems to be fine (`ApplyParameter` is called before we get here) but still, it is somewhat fragile. I wonder if it wouldn't be better to make `ConsoleOutputAligner` a static class.\r\n\r\n",
              "createdAt": "2021-11-15T12:52:58Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -105,6 +103,8 @@ private void CheckIfOutputSupportsAlignment()\n                     _alignMessages = false;\n                 }\n             }\n+\n+            _consoleOutputAligner = new ConsoleOutputAligner(_bufferWidth, _alignMessages);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "You are right, it is slightly fragile - good you have bringed this up. I have checked code and I believe it is good-enough as it is. `ApplyParameter` has to be called before `CheckIfOutputSupportsAlignment` otherwise `_forceNoAlign` has no proper value.\r\nAs for static class `ConsoleOutputAligner` I like it slightly more implemented as it is. This way lifetime of `ConsoleOutputAligner` is controlled by class which uses it `ParallelConsoleLogger`. In particular `ConsoleOutputAligner` instance is recycled and collected after build. ",
              "createdAt": "2021-11-16T09:47:12Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -105,6 +103,8 @@ private void CheckIfOutputSupportsAlignment()\n                     _alignMessages = false;\n                 }\n             }\n+\n+            _consoleOutputAligner = new ConsoleOutputAligner(_bufferWidth, _alignMessages);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Why pass the `StringBuilder`? It is a field on this class.",
              "createdAt": "2021-11-15T13:44:29Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,143 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+\n+            StringBuilder sb = _reusedStringBuilder;\n+            // prepare reused StringBuilder instance for new use.\n+            sb.Length = 0;\n+            // The string contains new lines, treat each new line as a different string to format and send to the console\n+            while (j >= 0)\n+            {\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                i = j + (message[j] == '\\r' && (j + 1) < message.Length && message[j + 1] == '\\n' ? 2 : 1);\n+                j = i < message.Length ? message.IndexOfAny(MSBuildConstants.CrLf, i) : -1;\n+            }\n+\n+            // Process rest of message\n+            AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, message.Length - i);\n+\n+            return sb.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Append aligned and indented message lines into running <see cref=\"StringBuilder\"/>.\n+        /// </summary>\n+        private void AlignAndIndentLineOfMessage(StringBuilder sb, bool prefixAlreadyWritten, int prefixWidth, string message, int start, int count)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I wanted to make this method agnostics to how caller acquire 'StringBuilder` so if caller is modified to get StringBuilder from for example some kind of pool, this method does not need to change.",
              "createdAt": "2021-11-16T09:28:24Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,143 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+\n+            StringBuilder sb = _reusedStringBuilder;\n+            // prepare reused StringBuilder instance for new use.\n+            sb.Length = 0;\n+            // The string contains new lines, treat each new line as a different string to format and send to the console\n+            while (j >= 0)\n+            {\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                i = j + (message[j] == '\\r' && (j + 1) < message.Length && message[j + 1] == '\\n' ? 2 : 1);\n+                j = i < message.Length ? message.IndexOfAny(MSBuildConstants.CrLf, i) : -1;\n+            }\n+\n+            // Process rest of message\n+            AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, message.Length - i);\n+\n+            return sb.ToString();\n+        }\n+\n+        /// <summary>\n+        /// Append aligned and indented message lines into running <see cref=\"StringBuilder\"/>.\n+        /// </summary>\n+        private void AlignAndIndentLineOfMessage(StringBuilder sb, bool prefixAlreadyWritten, int prefixWidth, string message, int start, int count)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does the need for this initialization impact API users who might be `new`ing up a `ParallelConsoleLogger`?",
              "createdAt": "2021-11-15T15:12:36Z",
              "path": "src/Build.UnitTests/ConsoleLogger_Tests.cs",
              "diffHunk": "@@ -1480,6 +1480,8 @@ public void DisplayPropertiesList()\n \n             sc = new SimulatedConsole();\n             ParallelConsoleLogger cl2 = new ParallelConsoleLogger(LoggerVerbosity.Diagnostic, sc.Write, null, null);\n+            EventSourceSink es = new EventSourceSink();\n+            cl2.Initialize(es);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Loggers are initialized by infrastructure code by invoking `Ilogger.Initialize`, Even if the user would somehow use his Logger instance directly, calling Initialize was always necessary, it was just that our unit tests get away from not calling it - up to this point.",
              "createdAt": "2021-11-15T20:57:04Z",
              "path": "src/Build.UnitTests/ConsoleLogger_Tests.cs",
              "diffHunk": "@@ -1480,6 +1480,8 @@ public void DisplayPropertiesList()\n \n             sc = new SimulatedConsole();\n             ParallelConsoleLogger cl2 = new ParallelConsoleLogger(LoggerVerbosity.Diagnostic, sc.Write, null, null);\n+            EventSourceSink es = new EventSourceSink();\n+            cl2.Initialize(es);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "if I read right, if there is a `\\r` with no following `\\n`, this will treat it as a newline. (Not sure I see tests verifying this.) \r\n\r\nAs far as I know there is no modern platform that treats this as a newline, so I wonder whether it would be better to ignore it entirely.",
              "createdAt": "2021-11-16T01:09:56Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,143 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+\n+            StringBuilder sb = _reusedStringBuilder;\n+            // prepare reused StringBuilder instance for new use.\n+            sb.Length = 0;\n+            // The string contains new lines, treat each new line as a different string to format and send to the console\n+            while (j >= 0)\n+            {\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                i = j + (message[j] == '\\r' && (j + 1) < message.Length && message[j + 1] == '\\n' ? 2 : 1);",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "@danmoseley  I thought about it. I was not sure what is correct reaction to \\r but I decided to interpret it as new line with following reasoning:\r\nMove to start of line and overwrite whatever was there does not make sense in our event based logging approach. In context  of one `EventArg` why would user wants to overwrite something. In multiple messages it is also unusable as a) messages are delimited by `NewLine` and b) messages can be interleaved in concurrent build.\r\nSo using \\r must be mistake in either user custom messages or logged substring of messages. Now, how can we sanitize this to user best benefit?\r\n\r\n1. implement as console standard i.e. move cursor to indented start of line\r\n    - will overwrite already written text at this line and user can lost some info\r\n    - will be inconsistent with file loggers\r\n    - is most probably not user intent\r\n2. ignore = replace by space\r\n    - will be inconsistent with file viewers\r\n![image](https://user-images.githubusercontent.com/25249058/142482860-c0553f20-5b64-477e-912a-e2df5cbbd1d1.png) \r\n    - is most probably not user intent\r\n3. interpret as new line\r\n   - correct interpretation of user mistake (missed \\n, or mismatching \\n <=> \\r)\r\n   - consistent with file logger\r\n   - consistent with how most file viewers implements it (tried notepad, VS, VS Code)  \r\n![image](https://user-images.githubusercontent.com/25249058/142424176-a2e63c3e-59b2-425d-a8e6-e23f445a5a4c.png)\r\n\r\nI have picked 3 and still considering it as best option.\r\n\r\nI will add unit test cases with explanation.",
              "createdAt": "2021-11-18T13:29:09Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,143 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+\n+            StringBuilder sb = _reusedStringBuilder;\n+            // prepare reused StringBuilder instance for new use.\n+            sb.Length = 0;\n+            // The string contains new lines, treat each new line as a different string to format and send to the console\n+            while (j >= 0)\n+            {\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                i = j + (message[j] == '\\r' && (j + 1) < message.Length && message[j + 1] == '\\n' ? 2 : 1);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "seems reasonable",
              "createdAt": "2021-11-18T14:47:36Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,143 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+\n+            StringBuilder sb = _reusedStringBuilder;\n+            // prepare reused StringBuilder instance for new use.\n+            sb.Length = 0;\n+            // The string contains new lines, treat each new line as a different string to format and send to the console\n+            while (j >= 0)\n+            {\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                i = j + (message[j] == '\\r' && (j + 1) < message.Length && message[j + 1] == '\\n' ? 2 : 1);",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "Unit tests added",
              "createdAt": "2021-11-18T19:18:24Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,143 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+\n+            StringBuilder sb = _reusedStringBuilder;\n+            // prepare reused StringBuilder instance for new use.\n+            sb.Length = 0;\n+            // The string contains new lines, treat each new line as a different string to format and send to the console\n+            while (j >= 0)\n+            {\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                i = j + (message[j] == '\\r' && (j + 1) < message.Length && message[j + 1] == '\\n' ? 2 : 1);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "if sb grew hugely during this work, say, it's now 50K long, should you release it and replace it with a fresh 1024 char one?",
              "createdAt": "2021-11-16T01:11:32Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,143 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+\n+            StringBuilder sb = _reusedStringBuilder;\n+            // prepare reused StringBuilder instance for new use.\n+            sb.Length = 0;\n+            // The string contains new lines, treat each new line as a different string to format and send to the console\n+            while (j >= 0)\n+            {\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                i = j + (message[j] == '\\r' && (j + 1) < message.Length && message[j + 1] == '\\n' ? 2 : 1);\n+                j = i < message.Length ? message.IndexOfAny(MSBuildConstants.CrLf, i) : -1;\n+            }\n+\n+            // Process rest of message\n+            AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, message.Length - i);\n+\n+            return sb.ToString();",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "I though about it and I decided to keep the instance big. With current code instance of `ConsoleOutputAligner` is recycled after end of build. So that huge `StringBuilder` instance will have lifetime of build only.\r\n\r\nI do not see much benefit from recycling SB during build as there is possibility we will need that big SB frequently.\r\nI am not too afraid about OOM regression, as changes in this PR makes memory traffic along with working set considerably smaller.\r\n",
              "createdAt": "2021-11-16T10:00:16Z",
              "path": "src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs",
              "diffHunk": "@@ -0,0 +1,143 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable enable\n+using System;\n+using System.Diagnostics;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.BackEnd.Logging\n+{\n+    /// <summary>\n+    /// Align output to multiple lines so no logged test is lost due to limited <see cref=\"Console.BufferWidth\"/>.\n+    /// During alignment optional prefix/indent is applied.\n+    /// </summary>\n+    /// <remarks>\n+    /// This class is not thread safe.\n+    /// </remarks>\n+    internal class ConsoleOutputAligner\n+    {\n+        internal const int ConsoleTabWidth = 8;\n+\n+        private readonly StringBuilder _reusedStringBuilder = new(1024);\n+        private readonly int _bufferWidth;\n+        private readonly bool _alignMessages;\n+\n+        /// <summary>\n+        /// Constructor.\n+        /// </summary>\n+        /// <param name=\"bufferWidth\">Console buffer width. -1 if unknown/unlimited</param>\n+        /// <param name=\"alignMessages\">Whether messages are aligned/wrapped into console buffer width</param>\n+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)\n+        {\n+            _bufferWidth = bufferWidth;\n+            _alignMessages = alignMessages;\n+        }\n+\n+        /// <summary>\n+        /// Based on bufferWidth split message into multiple lines and indent if needed.\n+        /// TAB character are interpreted by standard Console logic. \n+        /// </summary>\n+        /// <param name=\"message\">Input message. May contains tabs and new lines. Both \\r\\n and \\n is supported but replaced into current environment new line.</param>\n+        /// <param name=\"prefixAlreadyWritten\">true if message already contains prefix (message context, timestamp, etc...).</param>\n+        /// <param name=\"prefixWidth\">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>\n+        /// <returns>Aligned message ready to be written to Console</returns>\n+        /// <remarks>\n+        /// For optimization purposes this method uses single <see cref=\"StringBuilder\"/> instance. This makes this method non thread safe.\n+        /// Calling side is expected this usage is non-concurrent. This shall nto be an issue as it is expected that writing into Console shall be serialized anyway.\n+        /// </remarks>\n+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)\n+        {\n+            int i = 0;\n+            int j = message.IndexOfAny(MSBuildConstants.CrLf);\n+\n+            StringBuilder sb = _reusedStringBuilder;\n+            // prepare reused StringBuilder instance for new use.\n+            sb.Length = 0;\n+            // The string contains new lines, treat each new line as a different string to format and send to the console\n+            while (j >= 0)\n+            {\n+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);\n+                i = j + (message[j] == '\\r' && (j + 1) < message.Length && message[j + 1] == '\\n' ? 2 : 1);\n+                j = i < message.Length ? message.IndexOfAny(MSBuildConstants.CrLf, i) : -1;\n+            }\n+\n+            // Process rest of message\n+            AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, message.Length - i);\n+\n+            return sb.ToString();",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      }
    ]
  }
}