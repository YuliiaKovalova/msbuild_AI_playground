{
  "number": 8792,
  "title": "Get eval results 2",
  "body": "Fixes #3911\r\n\r\n(See https://github.com/dotnet/msbuild/issues/3911#issuecomment-1478468822 for a spec.)\r\n\r\nThis has the backbone of the change I want. It's currently missing two parts: tests and formatting.\r\n\r\nI also chose not to error when someone specifies `getTargetResult` without `-target` because I don't see any reason we shouldn't respect it if someone wants to just have a normal build with the default targets then get the result of some target(s) that built.\r\n\r\nI see no reason to add a `resultsFile` command line switch, as > works great and is already well-known.\r\n\r\nI'm also still thinking about what kind of formatting I think is really important. It currently does a simple format like \"Property\": \"value\". If we wanted to change it to json, I could support that, since it's easier to parse, but I don't think we should support both, as it's added complexity for minimal gain in my opinion.\r\n\r\n### Context\r\n\r\n\r\n### Changes Made\r\nIf someone specifies getProperty or getItem from the command line without specifying -target, it will return the values of the specified properties or items (including metadata) immediately after evaluation. If someone specifies one of those with -target or -targetResult, it gives that information after the build is finished.\r\n\r\n### Testing\r\nManual testing and unit tests\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2023-05-23T00:37:53Z",
  "updatedAt": "2024-02-05T12:19:14Z",
  "closedAt": "2023-08-15T08:03:58Z",
  "mergedAt": "2023-08-15T08:03:58Z",
  "additions": 1092,
  "deletions": 32,
  "changedFiles": 24,
  "headRefName": "get-eval-results-2",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": {
    "title": "VS 17.8"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "0818ef4edb17ffdf2cea69d32cb1597122a468bc",
          "message": "ProofOfConcept",
          "committedDate": "2023-05-18T23:43:42Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3798ad9a3960f6c052c63f483de03d17782b70b2",
          "message": "Add CommandLine switch",
          "committedDate": "2023-05-22T16:51:26Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9c6392b48ea43c166d5113f6a6fd66050a58432b",
          "message": "Implement the rest",
          "committedDate": "2023-05-22T22:39:16Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8ba0ef80e4ba9085e4054aaff4b0a8edd3864d84",
          "message": "Fix bugs",
          "committedDate": "2023-05-23T00:24:39Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9ee3de60db435e7fff1df3510d141139045f5980",
          "message": "un-public BRD",
          "committedDate": "2023-05-23T00:46:37Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3af2613137e9b754118d961d3ed6339bf8420acf",
          "message": "Switch to json format\n\nPrinting properties or items is much more complicated than might be supposed at face value. When creating a Project, we get things like ProjectItems and ProjectProperties; after the build, we get ProjectItemInstances and ProjectPropertyInstances. Properties aren't too bad because we can use a delegate to abstract over that, but ProjectInstances have ProjectItemInstances with ProjectMetadataInstances, which is too many layers of nesting to cleanly abstract that in a delegate, hence two separate helper functions for those.",
          "committedDate": "2023-05-24T17:08:23Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "81cf59e9c633cb5896cf14f98a1d3da00b9aa60c",
          "message": "Progress on tests",
          "committedDate": "2023-05-26T00:07:16Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1870e8467d12ec1db93575dc2799091c96d0bf4a",
          "message": "Add JsonOutputFormatter",
          "committedDate": "2023-06-02T21:51:45Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3fa8dc4d13595e8562298e4cb64c13775a0ac038",
          "message": "Resolve issues and use new class",
          "committedDate": "2023-06-02T22:57:52Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "631eb22cbbe025d76a4443f8c7fccc141218bba4",
          "message": "Use STJ",
          "committedDate": "2023-06-06T21:17:25Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "034ae13c0e9c34678a0bf5750bbb613737cbd73b",
          "message": "Remove XMake garbage",
          "committedDate": "2023-06-06T21:17:36Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "41e2b4a0188b8c46c808201f6df4fd774d935ac4",
          "message": "Add comment",
          "committedDate": "2023-06-06T23:56:17Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bf0e8f338717ac514b7bb2bc172e5e8539d27e81",
          "message": "Suppress build finished message",
          "committedDate": "2023-06-08T20:35:44Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8259a4bf45c18d8fc8aaac8f20c333cbbc6ecfad",
          "message": "Suppress BuildFinished for getTargetResult",
          "committedDate": "2023-06-09T00:08:11Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8b65f88caae0a4401a509565f77e7d81013dbbe8",
          "message": "Support simple format",
          "committedDate": "2023-06-16T20:52:36Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8c3db889a14c7c422df9760ed6746ac79e0d9b0f",
          "message": "Do not fail hard when the user passes an invalid project",
          "committedDate": "2023-06-16T21:26:56Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4f849baa08292045b8043c98858f8ac114526633",
          "message": "Push all logging to stderr",
          "committedDate": "2023-06-16T22:40:13Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d0a1b38b5a0529a6a638c2fc4b06c440b48c405b",
          "message": "Cleanup_1",
          "committedDate": "2023-06-19T21:31:12Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a7a3c332be31b2c2f9634c494d0ee4062df28458",
          "message": "PR comments",
          "committedDate": "2023-06-19T21:41:21Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fa46143392586305c469c0cd3f1c36cafe743563",
          "message": "Add using",
          "committedDate": "2023-06-19T21:41:39Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "41d30919b0861b2fc7669050daa7d4239f16ac32",
          "message": "Do not use custom loggers\n\n...when getting evaluation results",
          "committedDate": "2023-06-29T00:48:31Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "db6210acf1aadd8d8c85b5541e65578c461ca0e2",
          "message": "Merge branch 'main' into get-eval-results-2",
          "committedDate": "2023-07-05T17:26:43Z",
          "author": {
            "name": "Forgind",
            "email": "12969783+Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "241e5b9cfc440f0c29cb4f580aca724be7354737",
          "message": "remove test no longer relevant to design",
          "committedDate": "2023-07-10T17:24:40Z",
          "author": {
            "name": "Forgind",
            "email": "12969783+Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "008983206f2cf35226cb87a066ff4d2f1811cdf9",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild into get-eval-results-2",
          "committedDate": "2023-07-20T17:19:03Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "20c07c79aeb59641847395a130ac209deeba77eb",
          "message": "PR feedback",
          "committedDate": "2023-07-20T17:32:06Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cad93f26297bf89ad5d37acf17434a0d339c38ff",
          "message": "Remove duplicate check",
          "committedDate": "2023-07-20T17:59:40Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b1aab934e9ec76d46bb103e00858324b3fff768b",
          "message": "Continue PR feedback",
          "committedDate": "2023-07-21T18:52:29Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "71a8c9352a79fd2d9d036e1a468c0036082e49fd",
          "message": "Merge branch 'main' into get-eval-results-2",
          "committedDate": "2023-07-21T20:28:58Z",
          "author": {
            "name": "Forgind",
            "email": "12969783+Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c30abd2753b1d7cf557df3c5a4fd5cec72fbd9c",
          "message": "Delete duplicate usings",
          "committedDate": "2023-07-26T19:34:31Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ccf6731d3017c3da561e8409ebe896e1507fc1ff",
          "message": "Most PR comments",
          "committedDate": "2023-07-27T18:54:34Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e843f036e2debc5d0d6f36cff44373f189fe52ce",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild into get-eval-results-2",
          "committedDate": "2023-07-27T18:55:41Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "52a57fa09af2f5db54391d4b00d6f3872ee525f2",
          "message": "Move comment",
          "committedDate": "2023-07-27T19:02:44Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d33d9de2877ea2b4242463544d2f4a823e73deaa",
          "message": "PR comments",
          "committedDate": "2023-08-04T20:17:52Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b9826c16f623da3ad5b5b5d588f21252c4a503c9",
          "message": "Extend ExecuteAppWithGetPropertyAndItem\n\nTo include GetTargetResult!",
          "committedDate": "2023-08-04T20:31:06Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "131f6146b46733afe04a1606f997f0899a8201df",
          "message": "Create local variable",
          "committedDate": "2023-08-07T15:38:41Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6cb6dab68b02b2df1cbe2ae90b1dd277fa1e371b",
          "message": "Output binlog",
          "committedDate": "2023-08-08T19:08:10Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5c38ef421e0b83727d072951e2208df139a93126",
          "message": "Permit \"Build succeeded\" in binlog",
          "committedDate": "2023-08-08T23:45:50Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6d6052fc328d6586be3002514229c526d968ff88",
          "message": "PR feedback",
          "committedDate": "2023-08-09T16:17:35Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d5e7d1331e491ea835e2fa0e0bec8ed0f572a602",
          "message": "Do not permit duplicate additions to eval results",
          "committedDate": "2023-08-11T16:38:14Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Chatted with @baronfel offline, and we decided we can at least start with just supporting the json format and printing out all item metadata, including if its value is an empty string (as is common among built-in metadata).",
        "createdAt": "2023-05-26T00:09:38Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "FYI @vlada-shubina",
        "createdAt": "2023-06-02T09:31:43Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "> Chatted with @baronfel offline, and we decided we can at least start with just supporting the json format and printing out all item metadata, including if its value is an empty string (as is common among built-in metadata).\r\n\r\nI don't think I like this experience for what I expect to be a dominant use-case here:\r\n\r\n```sh-session\r\n\u276f .\\.dotnet\\dotnet.exe msbuild .\\src\\Samples\\PortableTask\\PortableTask.csproj -getproperty:OutDir\r\n{\r\n  \"Properties\": {\r\n    \"OutDir\": \"S:\\\\msbuild\\\\artifacts\\\\bin\\\\Samples\\\\PortableTask\\\\Debug\\\\netstandard2.0\\\\\"\r\n  }\r\n}\r\n\r\n\u276f .\\.dotnet\\dotnet.exe msbuild .\\src\\Samples\\PortableTask\\PortableTask.csproj -getproperty:TargetPath\r\n{\r\n  \"Properties\": {\r\n    \"TargetPath\": \"S:\\\\msbuild\\\\artifacts\\\\bin\\\\Samples\\\\PortableTask\\\\Debug\\\\netstandard2.0\\\\PortableTask.dll\"\r\n  }\r\n}\r\n```\r\n\r\nThat makes using this feature in shell-interpolation contexts _much harder_ than I think it needs to be.\r\n",
        "createdAt": "2023-06-09T16:23:31Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I was thinking that most users were going to be more the 'using from some kind of tooling' kind (and so would have JSON/`jq` available for manipulation) vs the `shell scripting/CI` kind, though admittedly I have no data on that. The use cases we do have (Docker tooling in VSCode, a few internal teams who have reached out with interest) are the former.\r\n\r\nFor single properties it can feel like overhead, but as soon as you request several properties or items (which these do) then interpolation goes right out the window.",
        "createdAt": "2023-06-09T16:28:00Z",
        "author": {
          "login": "baronfel"
        }
      },
      {
        "body": "Fascinating, I had the exact opposite impression: the multi-valued thing is the niche make-it-opt-in case and users mostly want clean output to stuff into, e.g. `cp -r ${dotnet msbuild -getproperty:OutDir} $STAGING_DIRECTORY`.",
        "createdAt": "2023-06-09T16:46:42Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Can you look into this very-bad error experience (there's a missing `</Project>` in `Warn.proj`):\r\n\r\n```sh-session\r\n\u276f .\\.dotnet\\dotnet.exe msbuild .\\Warn.proj -gettargetresult:Go\r\nMSBUILD : error : This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled. [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :     System.Xml.XmlException: Unexpected end of file has occurred. The following elements are not closed: Project. Line 11, position 1. [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at System.Xml.XmlTextReaderImpl.Throw(Exception e) [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at System.Xml.XmlTextReaderImpl.Throw(String res, String arg) [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at System.Xml.XmlTextReaderImpl.ParseElementContent() [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at System.Xml.XmlLoader.LoadNode(Boolean skipOverWhitespace) [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at System.Xml.XmlLoader.LoadDocSequence(XmlDocument parentDoc) [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at System.Xml.XmlDocument.Load(XmlReader reader) [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.Construction.XmlDocumentWithLocation.Load(XmlReader reader) in S:\\msbuild\\src\\Build\\ElementLocation\\XmlDocumentWithLocation.cs:line 168 [S:\\msbuild\\\r\nWarn.proj]\r\nMSBUILD : error :    at Microsoft.Build.Construction.ProjectRootElement.LoadDocument(String fullPath, Boolean preserveFormatting, Boolean loadAsReadOnly) in S:\\msbuild\\src\\Build\\Constructi\r\non\\ProjectRootElement.cs:line 2084 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.Construction.ProjectRootElement..ctor(String path, ProjectRootElementCacheBase projectRootElementCache, Boolean preserveFormatting) in S:\\msbuild\\sr\r\nc\\Build\\Construction\\ProjectRootElement.cs:line 226 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.Construction.ProjectRootElement.CreateProjectFromPath(String projectFile, ProjectRootElementCacheBase projectRootElementCache, Boolean preserveForma\r\ntting) in S:\\msbuild\\src\\Build\\Construction\\ProjectRootElement.cs:line 2045 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.Construction.ProjectRootElement.<>c.<OpenProjectOrSolution>b__209_0(String path, ProjectRootElementCacheBase cache) in S:\\msbuild\\src\\Build\\Construc\r\ntion\\ProjectRootElement.cs:line 1789 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.Evaluation.ProjectRootElementCache.GetOrLoad(String projectFile, OpenProjectRootElement loadProjectRootElement, Boolean isExplicitlyLoaded, Nullable\r\n`1 preserveFormatting) in S:\\msbuild\\src\\Build\\Evaluation\\ProjectRootElementCache.cs:line 349 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.Evaluation.ProjectRootElementCache.Get(String projectFile, OpenProjectRootElement loadProjectRootElement, Boolean isExplicitlyLoaded, Nullable`1 pre\r\nserveFormatting) in S:\\msbuild\\src\\Build\\Evaluation\\ProjectRootElementCache.cs:line 280 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.Construction.ProjectRootElement.OpenProjectOrSolution(String fullPath, IDictionary`2 globalProperties, String toolsVersion, ProjectRootElementCacheB\r\nase projectRootElementCache, Boolean isExplicitlyLoaded) in S:\\msbuild\\src\\Build\\Construction\\ProjectRootElement.cs:line 1787 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.Execution.ProjectInstance..ctor(String projectFile, IDictionary`2 globalProperties, String toolsVersion, BuildParameters buildParameters, ILoggingSe\r\nrvice loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, Int32 submissionId, Nullable`1 projectLoadSettings) in S:\\msbuild\\src\\Build\\Instance\\Proj\r\nectInstance.cs:line 516 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.BackEnd.BuildRequestConfiguration.<>c__DisplayClass61_0.<LoadProjectIntoConfiguration>b__0() in S:\\msbuild\\src\\Build\\BackEnd\\Shared\\BuildRequestConf\r\niguration.cs:line 478 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.BackEnd.BuildRequestConfiguration.InitializeProject(BuildParameters buildParameters, Func`1 loadProjectFromFile) in S:\\msbuild\\src\\Build\\BackEnd\\Sha\r\nred\\BuildRequestConfiguration.cs:line 503 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.BackEnd.BuildRequestConfiguration.LoadProjectIntoConfiguration(IBuildComponentHost componentHost, BuildRequestDataFlags buildRequestDataFlags, Int32\r\n submissionId, Int32 nodeId) in S:\\msbuild\\src\\Build\\BackEnd\\Shared\\BuildRequestConfiguration.cs:line 438 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.BackEnd.RequestBuilder.BuildProject() in S:\\msbuild\\src\\Build\\BackEnd\\Components\\RequestBuilder\\RequestBuilder.cs:line 1126 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error :    at Microsoft.Build.BackEnd.RequestBuilder.BuildAndReport() in S:\\msbuild\\src\\Build\\BackEnd\\Components\\RequestBuilder\\RequestBuilder.cs:line 810 [S:\\msbuild\\Warn.proj]\r\nMSBUILD : error MSB1025: An internal failure occurred while running MSBuild.\r\nSystem.Collections.Generic.KeyNotFoundException: The given key 'Go' was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.ThrowKeyNotFoundException(TKey key)\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Microsoft.Build.CommandLine.JsonOutputFormatter.AddTargetResultsInJsonFormat(String[] targetNames, BuildResult result) in S:\\msbuild\\src\\MSBuild\\JsonOutputFormatter.cs:line 117\r\n   at Microsoft.Build.CommandLine.MSBuildApp.Execute(String[] commandLine) in S:\\msbuild\\src\\MSBuild\\XMake.cs:line 868\r\nThis is an unhandled exception in MSBuild Engine -- PLEASE OPEN A BUG AGAINST THE MSBUILD TEAM.\r\nSystem.Collections.Generic.KeyNotFoundException: The given key 'Go' was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.ThrowKeyNotFoundException(TKey key)\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Microsoft.Build.CommandLine.JsonOutputFormatter.AddTargetResultsInJsonFormat(String[] targetNames, BuildResult result) in S:\\msbuild\\src\\MSBuild\\JsonOutputFormatter.cs:line 117\r\n   at Microsoft.Build.CommandLine.MSBuildApp.Execute(String[] commandLine) in S:\\msbuild\\src\\MSBuild\\XMake.cs:line 868\r\nUnhandled exception: System.Collections.Generic.KeyNotFoundException: The given key 'Go' was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.ThrowKeyNotFoundException(TKey key)\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Microsoft.Build.CommandLine.JsonOutputFormatter.AddTargetResultsInJsonFormat(String[] targetNames, BuildResult result) in S:\\msbuild\\src\\MSBuild\\JsonOutputFormatter.cs:line 117\r\n   at Microsoft.Build.CommandLine.MSBuildApp.Execute(String[] commandLine) in S:\\msbuild\\src\\MSBuild\\XMake.cs:line 868\r\n   at Microsoft.Build.CommandLine.MSBuildApp.Main(String[] args) in S:\\msbuild\\src\\MSBuild\\XMake.cs:line 266\r\n   at Microsoft.DotNet.Cli.Utils.MSBuildForwardingAppWithoutLogging.ExecuteInProc(String[] arguments)\r\n```",
        "createdAt": "2023-06-09T18:17:01Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Even when the project works, if there's an error in the project it doesn't seem great:\r\n\r\n```sh-session\r\n\u276f .\\.dotnet\\dotnet.exe msbuild .\\Warn.proj -gettargetresult:Go\r\nS:\\msbuild\\Warn.proj(9,14): error MSB4064: The \"Message\" parameter is not supported by the \"Warning\" task loaded from assembly: Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutra\r\nl, PublicKeyToken=b03f5f7f11d50a3a from the path: S:\\msbuild\\.dotnet\\sdk\\7.0.203\\Microsoft.Build.Tasks.Core.dll. Verify that the parameter exists on the task, the <UsingTask> points to the\r\n correct assembly, and it is a settable public instance property.\r\nS:\\msbuild\\Warn.proj(9,5): error MSB4063: The \"Warning\" task could not be initialized with its input parameters.\r\n{\r\n  \"Target Results\": {\r\n    \"Go\": {\r\n      \"Result\": \"Failure\",\r\n      \"Items\": [\r\n        {},\r\n        {},\r\n        {}\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nOr a warning (in this thread: Rainer tries to make a project throw a warning):\r\n\r\n```sh-session\r\n\u276f .\\.dotnet\\dotnet.exe msbuild .\\Warn.proj -gettargetresult:Go\r\nS:\\msbuild\\Warn.proj(9,5): warning : Everything is awful!\r\n{\r\n  \"Target Results\": {\r\n    \"Go\": {\r\n      \"Result\": \"Success\",\r\n      \"Items\": [\r\n        {},\r\n        {},\r\n        {}\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNote that this also shows that return values from targets aren't working correctly.",
        "createdAt": "2023-06-09T18:28:48Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Some open design questions:\r\n\r\n# Is JSON the correct format for all invocations of the command? \r\n\r\nWe have two intended uses cases - quick CI invocations ('where's my output path?') and intense developer tool integrations ('I need this array of properties and items after evaluating the GenerateContainer target'). For the latter, JSON makes sense, but for the former you want something clean.\r\n\r\n> Proposal: for single-property-only requests, emit the value on stdout unchanged. For all other requests, use JSON\r\n\r\n# Default Build Target behaviors\r\n\r\nThe current implementation performs an _evaluation_ if no target is explicitly specified on the command line. To return results after executing a target, the `/t` flag must be used to provide the target for execution. This differs from the standard behavior for MSBuild invocations - without the new flags calling the command without a target will execute the default target for the project, if one is specified/discovered during evaluation.  _Is this confusing for end users?_\r\n\r\n# Warning and Error handling\r\n\r\nAs Rainer shows above, we need to decide what to do with warnings and errors. There are a few options:\r\n* emit warnings and errors to stdout\r\n  * this requires tools to handle this, and hurts the CI/scripting scenario\r\n* emit warnings and errors to stderr\r\n  * this is in line with more CLI tooling expectations, but would be a larger unit of work\r\n* emit warnings and errors as part of the JSON formatted response\r\n  * this would be easy to parse for consumers, but could bloat the response, and coupled with the format-switching behavior above might make it hard to anticipate for CI/scripting scenarios what shape your data would be in.\r\n",
        "createdAt": "2023-06-09T19:23:44Z",
        "author": {
          "login": "baronfel"
        }
      },
      {
        "body": "Thanks for the review! I pushed a change to take most of your feedback into account \ud83d\ude42\r\n\r\n> * There seems to be no `getTargetResult` test coverage at all.\r\n\r\nGetTargetResultSwitchIdentificationTest is intended to test getTargetResult from a switch-processing perspective. I can extend ExecuteAppWithGetPropertyAndItem with some getTargetResult parts, though. I'll do that when I get the chance.\r\n\r\n> * Unclear interaction of the new switches with existing switches, e.g. `/getProperty:.. /bl` silently ignores `/bl`. Expected?\r\n\r\nCan you talk more about this one? If you specify msbuild <project> /getProperty:... /bl, it doesn't silently ignore the /bl part, but it also doesn't actually execute a build, so there isn't really much to log, and it doesn't bother outputting a binlog for that. That part is expected. If you run an actual build (i.e., by specifying /getTargetResult or /t), it does create a binlog as far as I can tell.",
        "createdAt": "2023-08-04T20:22:23Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> Thanks for the review! I pushed a change to take most of your feedback into account \ud83d\ude42\r\n\r\nThank you for making the changes!\r\n \r\n> > * There seems to be no `getTargetResult` test coverage at all.\r\n> \r\n> GetTargetResultSwitchIdentificationTest is intended to test getTargetResult from a switch-processing perspective. I can extend ExecuteAppWithGetPropertyAndItem with some getTargetResult parts, though. I'll do that when I get the chance.\r\n\r\nPlease do, because otherwise 1/3 of the feature (the actual functionality, no just the command line switch) would have no test coverage.\r\n\r\n> > * Unclear interaction of the new switches with existing switches, e.g. `/getProperty:.. /bl` silently ignores `/bl`. Expected?\r\n> \r\n> Can you talk more about this one? If you specify msbuild /getProperty:... /bl, it doesn't silently ignore the /bl part, but it also doesn't actually execute a build, so there isn't really much to log, and it doesn't bother outputting a binlog for that. That part is expected. If you run an actual build (i.e., by specifying /getTargetResult or /t), it does create a binlog as far as I can tell.\r\n\r\nAs a user, I could reasonably expect to combine the `/getProperty` and `/bl` switches to create an evaluation-only binlog.\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/12206368/3f830743-bcd6-41a3-abbb-392b8cacf872)\r\n",
        "createdAt": "2023-08-07T15:41:10Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "@ladipro,\r\n\r\nI managed to get it to output a binlog even if you don't build, _but_ it isn't quite right: even if everything goes well, the binlog will still claim the build failed.\r\n\r\nI talked with baronfel about it just now, and he said that's \"in the bucket of 'fix for rc2'\", so I pushed the change. I'm working on figuring out how to fix it still, but if it otherwise seems good to you, I'd appreciate merging it without that fixed, and I'll fix it in a follow-up PR.",
        "createdAt": "2023-08-08T19:45:22Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Re-reviewd the final state - it looks ready to go to me!",
        "createdAt": "2023-08-11T08:20:03Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Do we have a work item to document this new feature in the command-line help?\r\n\r\nI'm wondering if it's expected that the feature produces a binlog if the Directory.Build.rsp contains `/bl`. It makes sense technically but it was unexpected, at least for properties and items. I think it's fine, just wondering if we thought about it.",
        "createdAt": "2024-01-25T01:24:54Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "> Do we have a work item to document this new feature in the command-line help?\r\n\r\n@baronfel (or maybe @ghogen?)\r\n\r\n> I'm wondering if it's expected that the feature produces a binlog if the Directory.Build.rsp contains `/bl`. It makes sense technically but it was unexpected, at least for properties and items. I think it's fine, just wondering if we thought about it.\r\n\r\nThat's as-desired for me, at least. It was intentional that if the user specifies /bl in addition to one of these new flags that /bl would still be respected as normal. bl can come in normally through the command line or be added separately, and I don't think we should discriminate between those.",
        "createdAt": "2024-01-26T00:09:20Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Filed #9710 to track updating the help message.",
        "createdAt": "2024-02-05T12:19:13Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "NTS: Should probably add a comment here",
              "createdAt": "2023-05-23T00:47:19Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1403,21 +1461,27 @@ private static void ResetGatheringSwitchesState()\n                             BuildRequestData buildRequest = null;\n                             if (!restoreOnly)\n                             {\n+                                BuildRequestDataFlags flags = BuildRequestDataFlags.None;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The json outputing code would deserve it's own type and file",
              "createdAt": "2023-06-02T09:37:55Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -985,6 +1025,128 @@ private static void DebuggerLaunchCheck()\n             return exitType;\n         }\n \n+        private static void PrintPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How is this exactly used?\r\nI can imagine someone might want to evaluate properties (and see them in output), while at the same time troubleshoot the processing with the binary log (or file log) - is that possible?\r\nOr even - I can imagine future feature request for outputing those into a user speicifed file - so console logger then might be just fine",
              "createdAt": "2023-06-02T09:41:17Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3486,7 +3679,7 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<IL\n             // If we have a binary logger, force verbosity to diagnostic.\n             // The only place where verbosity is used downstream is to determine whether to log task inputs.\n             // Since we always want task inputs for a binary logger, set it to diagnostic.\n-            verbosity = LoggerVerbosity.Diagnostic;\n+            verbosity = canAdjustVerbosity ? LoggerVerbosity.Diagnostic : verbosity;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Hmm...@baronfel, I don't think someone would want to see property values while also gathering a binlog, since this would be getting something like OutputPath before running a second build and using the result here in that build. Would people actually want a binlog from this \"get property\" build?",
              "createdAt": "2023-06-06T21:22:39Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3486,7 +3679,7 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<IL\n             // If we have a binary logger, force verbosity to diagnostic.\n             // The only place where verbosity is used downstream is to determine whether to log task inputs.\n             // Since we always want task inputs for a binary logger, set it to diagnostic.\n-            verbosity = LoggerVerbosity.Diagnostic;\n+            verbosity = canAdjustVerbosity ? LoggerVerbosity.Diagnostic : verbosity;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "IMO no, if necessary in an emergency we can always fall back on `MSBUILDDEBUGENGINE`.",
              "createdAt": "2023-06-06T21:27:08Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3486,7 +3679,7 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<IL\n             // If we have a binary logger, force verbosity to diagnostic.\n             // The only place where verbosity is used downstream is to determine whether to log task inputs.\n             // Since we always want task inputs for a binary logger, set it to diagnostic.\n-            verbosity = LoggerVerbosity.Diagnostic;\n+            verbosity = canAdjustVerbosity ? LoggerVerbosity.Diagnostic : verbosity;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "The reason I did this is that this change is intended to suppress _all_ output if a user sets one of the flags...except the output from this change. This part prevents unintended output if, say, the user uses a script to build their repo that includes /bl but also adds one of these parameters to the command line. In that case, I would think we'd want to suppress the output anyway, so we wouldn't want the /bl to be properly respected if that makes sense.",
              "createdAt": "2023-06-06T21:27:40Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3486,7 +3679,7 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<IL\n             // If we have a binary logger, force verbosity to diagnostic.\n             // The only place where verbosity is used downstream is to determine whether to log task inputs.\n             // Since we always want task inputs for a binary logger, set it to diagnostic.\n-            verbosity = LoggerVerbosity.Diagnostic;\n+            verbosity = canAdjustVerbosity ? LoggerVerbosity.Diagnostic : verbosity;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I think it's fair to see this eval feature as exclusive with binlogs - if someone has/uses a binlog then they can code the moral equivalent of this feature, and this feature is very strongly focused on the CLI invocation use case only.",
              "createdAt": "2023-06-06T21:32:33Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3486,7 +3679,7 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<IL\n             // If we have a binary logger, force verbosity to diagnostic.\n             // The only place where verbosity is used downstream is to determine whether to log task inputs.\n             // Since we always want task inputs for a binary logger, set it to diagnostic.\n-            verbosity = LoggerVerbosity.Diagnostic;\n+            verbosity = canAdjustVerbosity ? LoggerVerbosity.Diagnostic : verbosity;",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "Coming back to this I'm now not so sure. I wasn't thinking through the build+structured output scenario. Thinking about it now I see two use cases\r\n\r\n1. Design-time-ish builds. Logs less important, mostly just want to populate some state and expect it to mostly pass. But what is the error-handling story if it doesn't?\r\n2. Do a build + collect information about it. Would definitely not want to say \"there's no way to log\".\r\n\r\nBasically, is there any use case for these things _as part of your normal build_? IMO giving the \"specify a target and return the final state\" option _strongly_ opens the door to that; instead of \"collect stuff from the evaluation\" you could more accurately say \"build + tell me these things\". But we cannot lose console or binlogging in that scenario.\r\n\r\nI still prefer the \"just evaluation\" approach, but I recognize that that cuts out one of the primary consumers @baronfel had in mind, which need some design-time target execution.",
              "createdAt": "2023-06-09T18:01:57Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3486,7 +3679,7 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<IL\n             // If we have a binary logger, force verbosity to diagnostic.\n             // The only place where verbosity is used downstream is to determine whether to log task inputs.\n             // Since we always want task inputs for a binary logger, set it to diagnostic.\n-            verbosity = LoggerVerbosity.Diagnostic;\n+            verbosity = canAdjustVerbosity ? LoggerVerbosity.Diagnostic : verbosity;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd suggest moving those to the print output utility class - so that possibly the implementation can be swapped if needed in the future (json/yaml/csv/whoknowswhat).\r\n\r\nPlus the printout utility should ideally internaly use a stream - while default setting it to Console.Out - that way it would be easy to add a future switch for printing into a file",
              "createdAt": "2023-06-02T09:52:10Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -782,6 +789,27 @@ private static void DebuggerLaunchCheck()\n                     {\n                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);\n                     }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && FileUtilities.IsSolutionFilename(projectFile))\n+                    {\n+\n+                        CommandLineSwitchException.Throw(\"SolutionBuildInvalidForCommandLineEvaluation\",\n+                            getProperty.Length > 0 ? \"getProperty\" :\n+                            getItem.Length > 0 ? \"getItem\" :\n+                            \"getTargetResult\");\n+                    }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))\n+                    {\n+                        Project project = Project.FromFile(projectFile, new Definition.ProjectOptions()\n+                        {\n+                            GlobalProperties = globalProperties,\n+                            ToolsVersion = toolsVersion,\n+                        });\n+\n+                        Console.WriteLine(\"{\");",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I left the actual writing part in XMake, so that should keep it easy if you want to add an explicit switch for a stream \ud83d\ude42\r\n\r\n(Though I think Console.Out works great with `>`)",
              "createdAt": "2023-06-06T23:52:36Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -782,6 +789,27 @@ private static void DebuggerLaunchCheck()\n                     {\n                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);\n                     }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && FileUtilities.IsSolutionFilename(projectFile))\n+                    {\n+\n+                        CommandLineSwitchException.Throw(\"SolutionBuildInvalidForCommandLineEvaluation\",\n+                            getProperty.Length > 0 ? \"getProperty\" :\n+                            getItem.Length > 0 ? \"getItem\" :\n+                            \"getTargetResult\");\n+                    }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))\n+                    {\n+                        Project project = Project.FromFile(projectFile, new Definition.ProjectOptions()\n+                        {\n+                            GlobalProperties = globalProperties,\n+                            ToolsVersion = toolsVersion,\n+                        });\n+\n+                        Console.WriteLine(\"{\");",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "While I am a trailing-commas-should-be-required-not-forbidden hardliner, that isn't JSON so I think our output must be `AllowTrailingCommas=false`.",
              "createdAt": "2023-06-09T16:48:05Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = true, WriteIndented = true };",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I don't know why this is true, but I added this because I also like trailing commas, then tested it and found that the commas didn't show up? I don't know why but I didn't fight it...I can make it explicitly false, though.",
              "createdAt": "2023-06-09T22:49:55Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = true, WriteIndented = true };",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why do you need a new overload?",
              "createdAt": "2023-06-09T17:52:39Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -909,6 +909,18 @@ public BuildResult BuildRequest(BuildRequestData requestData)\n         /// </remarks>\n         /// <exception cref=\"InvalidOperationException\">Thrown if there is no build in progress.</exception>\n         public void EndBuild()\n+        {\n+            EndBuild(false);\n+        }\n+\n+        /// <summary>\n+        /// Signals that no more build requests are expected (or allowed) and the BuildManager may clean up.\n+        /// </summary>\n+        /// <remarks>\n+        /// This call blocks until all currently pending requests are complete.\n+        /// </remarks>\n+        /// <exception cref=\"InvalidOperationException\">Thrown if there is no build in progress.</exception>\n+        public void EndBuild(bool skipLoggingBuildFinished)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This is to prevent \"Build Succeeded 0 Warnings 0 Errors\" after you finish a build if you enable the feature, as we should then not log anything but the json (or other format).",
              "createdAt": "2023-06-09T22:50:59Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -909,6 +909,18 @@ public BuildResult BuildRequest(BuildRequestData requestData)\n         /// </remarks>\n         /// <exception cref=\"InvalidOperationException\">Thrown if there is no build in progress.</exception>\n         public void EndBuild()\n+        {\n+            EndBuild(false);\n+        }\n+\n+        /// <summary>\n+        /// Signals that no more build requests are expected (or allowed) and the BuildManager may clean up.\n+        /// </summary>\n+        /// <remarks>\n+        /// This call blocks until all currently pending requests are complete.\n+        /// </remarks>\n+        /// <exception cref=\"InvalidOperationException\">Thrown if there is no build in progress.</exception>\n+        public void EndBuild(bool skipLoggingBuildFinished)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    targets = targets.Union(getTargetResult, MSBuildNameIgnoreCaseComparer.Default).ToArray();\r\n```",
              "createdAt": "2023-06-09T18:12:14Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2377,13 +2438,27 @@ private static bool GatherAutoResponseFileSwitchesFromFullPath(string autoRespon\n                                                            ref outputResultsCache,\n                                                            ref lowPriority,\n                                                            ref question,\n+                                                           ref getProperty,\n+                                                           ref getItem,\n+                                                           ref getTargetResult,\n                                                            recursing: true,\n                                                            commandLine);\n                     }\n \n                     // figure out which targets we are building\n                     targets = ProcessTargetSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Target]);\n \n+                    // If we are looking for the value of a specific property or item post-evaluation or a target post-build, figure that out now\n+                    getProperty = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetProperty] ?? Array.Empty<string>();\n+                    getItem = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetItem] ?? Array.Empty<string>();\n+                    getTargetResult = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetTargetResult] ?? Array.Empty<string>();\n+                    if (getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0)\n+                    {\n+                        commandLineSwitches.SetParameterizedSwitch(CommandLineSwitches.ParameterizedSwitch.Verbosity, \"q\", \"q\", true, true, true);\n+                    }\n+\n+                    targets = targets.Union(getTargetResult).ToArray();",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I would put these in separate tests since they can fail separately.",
              "createdAt": "2023-07-18T21:20:35Z",
              "path": "src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs",
              "diffHunk": "@@ -477,6 +478,52 @@ public void PreprocessSwitchIdentificationTests(string preprocess)\n             unquoteParameters.ShouldBeTrue();\n         }\n \n+        [Fact]\n+        public void EvaluationFromCommandLineSwitchIdentificationTests()\n+        {\n+            CommandLineSwitches.IsParameterizedSwitch(\n+                \"getProperty\",\n+                out CommandLineSwitches.ParameterizedSwitch parameterizedSwitch,\n+                out string duplicateSwitchErrorMessage,\n+                out bool multipleParametersAllowed,\n+                out string missingParametersErrorMessage,\n+                out _,\n+                out _);\n+\n+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GetProperty);\n+            duplicateSwitchErrorMessage.ShouldBeNull();\n+            multipleParametersAllowed.ShouldBeTrue();\n+            missingParametersErrorMessage.ShouldNotBeNullOrEmpty();\n+\n+            CommandLineSwitches.IsParameterizedSwitch(",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Design question: this currently returns success + empty string when querying for an undefined property. That makes sense per MSBuild's model, but should we do something different for this mode?",
              "createdAt": "2023-07-18T21:29:45Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -782,6 +789,42 @@ private static void DebuggerLaunchCheck()\n                     {\n                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);\n                     }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && FileUtilities.IsSolutionFilename(projectFile))\n+                    {\n+\n+                        CommandLineSwitchException.Throw(\"SolutionBuildInvalidForCommandLineEvaluation\",\n+                            getProperty.Length > 0 ? \"getProperty\" :\n+                            getItem.Length > 0 ? \"getItem\" :\n+                            \"getTargetResult\");\n+                    }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))\n+                    {\n+                        try\n+                        {\n+                            Project project = Project.FromFile(projectFile, new Definition.ProjectOptions()\n+                            {\n+                                GlobalProperties = globalProperties,\n+                                ToolsVersion = toolsVersion,\n+                            });\n+\n+                            // Special case if the user requests exactly one property: skip json formatting\n+                            if (getProperty.Length == 1 && getItem.Length == 0)\n+                            {\n+                                Console.WriteLine(project.GetPropertyValue(getProperty[0]));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Doing something different would be unexpected to me from and MSBuild perspective, but I'll admit that it would be...surprising...for it to print out nothing and act like everything is peachy. Thoughts @baronfel?",
              "createdAt": "2023-07-19T16:33:57Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -782,6 +789,42 @@ private static void DebuggerLaunchCheck()\n                     {\n                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);\n                     }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && FileUtilities.IsSolutionFilename(projectFile))\n+                    {\n+\n+                        CommandLineSwitchException.Throw(\"SolutionBuildInvalidForCommandLineEvaluation\",\n+                            getProperty.Length > 0 ? \"getProperty\" :\n+                            getItem.Length > 0 ? \"getItem\" :\n+                            \"getTargetResult\");\n+                    }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))\n+                    {\n+                        try\n+                        {\n+                            Project project = Project.FromFile(projectFile, new Definition.ProjectOptions()\n+                            {\n+                                GlobalProperties = globalProperties,\n+                                ToolsVersion = toolsVersion,\n+                            });\n+\n+                            // Special case if the user requests exactly one property: skip json formatting\n+                            if (getProperty.Length == 1 && getItem.Length == 0)\n+                            {\n+                                Console.WriteLine(project.GetPropertyValue(getProperty[0]));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I don't see an empty string as especially surprising here - folks that have written any MSBuild logic at all have bumped up against comparing to the empty string in targets. I'm happy to return an empty string in this case.",
              "createdAt": "2023-07-19T18:33:05Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -782,6 +789,42 @@ private static void DebuggerLaunchCheck()\n                     {\n                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);\n                     }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && FileUtilities.IsSolutionFilename(projectFile))\n+                    {\n+\n+                        CommandLineSwitchException.Throw(\"SolutionBuildInvalidForCommandLineEvaluation\",\n+                            getProperty.Length > 0 ? \"getProperty\" :\n+                            getItem.Length > 0 ? \"getItem\" :\n+                            \"getTargetResult\");\n+                    }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))\n+                    {\n+                        try\n+                        {\n+                            Project project = Project.FromFile(projectFile, new Definition.ProjectOptions()\n+                            {\n+                                GlobalProperties = globalProperties,\n+                                ToolsVersion = toolsVersion,\n+                            });\n+\n+                            // Special case if the user requests exactly one property: skip json formatting\n+                            if (getProperty.Length == 1 && getItem.Length == 0)\n+                            {\n+                                Console.WriteLine(project.GetPropertyValue(getProperty[0]));",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "Works for me.",
              "createdAt": "2023-07-19T18:42:43Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -782,6 +789,42 @@ private static void DebuggerLaunchCheck()\n                     {\n                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);\n                     }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && FileUtilities.IsSolutionFilename(projectFile))\n+                    {\n+\n+                        CommandLineSwitchException.Throw(\"SolutionBuildInvalidForCommandLineEvaluation\",\n+                            getProperty.Length > 0 ? \"getProperty\" :\n+                            getItem.Length > 0 ? \"getItem\" :\n+                            \"getTargetResult\");\n+                    }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))\n+                    {\n+                        try\n+                        {\n+                            Project project = Project.FromFile(projectFile, new Definition.ProjectOptions()\n+                            {\n+                                GlobalProperties = globalProperties,\n+                                ToolsVersion = toolsVersion,\n+                            });\n+\n+                            // Special case if the user requests exactly one property: skip json formatting\n+                            if (getProperty.Length == 1 && getItem.Length == 0)\n+                            {\n+                                Console.WriteLine(project.GetPropertyValue(getProperty[0]));",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Might be just me but I kept trying to use plurals here.",
              "createdAt": "2023-07-18T21:35:12Z",
              "path": "src/MSBuild/CommandLineSwitches.cs",
              "diffHunk": "@@ -265,6 +268,9 @@ private struct ParameterizedSwitchInfo\n             new ParameterizedSwitchInfo(  new string[] { \"lowpriority\", \"low\" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false),\n             new ParameterizedSwitchInfo(  new string[] { \"question\", \"q\" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),\n             new ParameterizedSwitchInfo(  new string[] { \"detailedsummary\", \"ds\" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),\n+            new ParameterizedSwitchInfo(  new string[] { \"getProperty\" },                       ParameterizedSwitch.GetProperty,                null,                           true,           \"MissingGetPropertyError\",             true,   false),\n+            new ParameterizedSwitchInfo(  new string[] { \"getItem\" },                           ParameterizedSwitch.GetItem,                    null,                           true,           \"MissingGetItemError\",             true,   false),\n+            new ParameterizedSwitchInfo(  new string[] { \"getTargetResult\" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           \"MissingGetTargetResultError\",             true,   false),",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I think that depends on what you see as the primary use case. Are you looking for the json-formatted set that actually takes multiple properties? Or do you see the primary use case to be asking for exactly one property? I don't think one way is obviously more right than the other.",
              "createdAt": "2023-07-19T20:29:48Z",
              "path": "src/MSBuild/CommandLineSwitches.cs",
              "diffHunk": "@@ -265,6 +268,9 @@ private struct ParameterizedSwitchInfo\n             new ParameterizedSwitchInfo(  new string[] { \"lowpriority\", \"low\" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false),\n             new ParameterizedSwitchInfo(  new string[] { \"question\", \"q\" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),\n             new ParameterizedSwitchInfo(  new string[] { \"detailedsummary\", \"ds\" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),\n+            new ParameterizedSwitchInfo(  new string[] { \"getProperty\" },                       ParameterizedSwitch.GetProperty,                null,                           true,           \"MissingGetPropertyError\",             true,   false),\n+            new ParameterizedSwitchInfo(  new string[] { \"getItem\" },                           ParameterizedSwitch.GetItem,                    null,                           true,           \"MissingGetItemError\",             true,   false),\n+            new ParameterizedSwitchInfo(  new string[] { \"getTargetResult\" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           \"MissingGetTargetResultError\",             true,   false),",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yeah I agree, not sure this needs any change--just mentioning it because I hit it on Item and then, like two minutes later, on TargetResult, so my brain apparently had a very specific expectation.",
              "createdAt": "2023-07-19T20:36:37Z",
              "path": "src/MSBuild/CommandLineSwitches.cs",
              "diffHunk": "@@ -265,6 +268,9 @@ private struct ParameterizedSwitchInfo\n             new ParameterizedSwitchInfo(  new string[] { \"lowpriority\", \"low\" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false),\n             new ParameterizedSwitchInfo(  new string[] { \"question\", \"q\" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),\n             new ParameterizedSwitchInfo(  new string[] { \"detailedsummary\", \"ds\" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),\n+            new ParameterizedSwitchInfo(  new string[] { \"getProperty\" },                       ParameterizedSwitch.GetProperty,                null,                           true,           \"MissingGetPropertyError\",             true,   false),\n+            new ParameterizedSwitchInfo(  new string[] { \"getItem\" },                           ParameterizedSwitch.GetItem,                    null,                           true,           \"MissingGetItemError\",             true,   false),\n+            new ParameterizedSwitchInfo(  new string[] { \"getTargetResult\" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           \"MissingGetTargetResultError\",             true,   false),",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "For ease of extracting stuff via `jq` on the command line I think the output schema should not have any spaces in keys. JSON style is generally more camel case than Pascal case but I think we can get away with the latter since it's .NET.\r\n\r\n```suggestion\r\n            _topLevelNode[\"TargetResults\"] = targetResultsNode;\r\n```",
              "createdAt": "2023-07-18T21:47:56Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }\n+\n+                    itemArray.Add(jsonItem);\n+                }\n+\n+                itemsNode[itemName] = itemArray;\n+            }\n+\n+            _topLevelNode[\"Items\"] = itemsNode;\n+        }\n+\n+        internal void AddItemsInJsonFormat(string[] itemNames, Project project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonObject itemsNode = new();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItem item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadata metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }\n+\n+                    itemArray.Add(jsonItem);\n+                }\n+\n+                itemsNode[itemName] = itemArray;\n+            }\n+\n+            _topLevelNode[\"Items\"] = itemsNode;\n+        }\n+\n+        internal void AddTargetResultsInJsonFormat(string[] targetNames, BuildResult result)\n+        {\n+            if (targetNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonObject targetResultsNode = new();\n+            foreach (string targetName in targetNames)\n+            {\n+                TargetResult targetResult = result.ResultsByTarget[targetName];\n+                JsonObject targetResults = new();\n+                targetResults[\"Result\"] = targetResult.ResultCode.ToString();\n+                JsonArray outputArray = new();\n+                foreach (ITaskItem item in targetResult.Items)\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (KeyValuePair<string, string> metadatum in item.EnumerateMetadata())\n+                    {\n+                        jsonItem[metadatum.Key] = metadatum.Value;\n+                    }\n+\n+                    outputArray.Add(jsonItem);\n+                }\n+\n+                targetResults[\"Items\"] = outputArray;\n+                targetResultsNode[targetName] = targetResults;\n+            }\n+\n+            _topLevelNode[\"Target Results\"] = targetResultsNode;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "100% agree with this feedback",
              "createdAt": "2023-07-19T20:45:13Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }\n+\n+                    itemArray.Add(jsonItem);\n+                }\n+\n+                itemsNode[itemName] = itemArray;\n+            }\n+\n+            _topLevelNode[\"Items\"] = itemsNode;\n+        }\n+\n+        internal void AddItemsInJsonFormat(string[] itemNames, Project project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonObject itemsNode = new();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItem item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadata metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }\n+\n+                    itemArray.Add(jsonItem);\n+                }\n+\n+                itemsNode[itemName] = itemArray;\n+            }\n+\n+            _topLevelNode[\"Items\"] = itemsNode;\n+        }\n+\n+        internal void AddTargetResultsInJsonFormat(string[] targetNames, BuildResult result)\n+        {\n+            if (targetNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonObject targetResultsNode = new();\n+            foreach (string targetName in targetNames)\n+            {\n+                TargetResult targetResult = result.ResultsByTarget[targetName];\n+                JsonObject targetResults = new();\n+                targetResults[\"Result\"] = targetResult.ResultCode.ToString();\n+                JsonArray outputArray = new();\n+                foreach (ITaskItem item in targetResult.Items)\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (KeyValuePair<string, string> metadatum in item.EnumerateMetadata())\n+                    {\n+                        jsonItem[metadatum.Key] = metadatum.Value;\n+                    }\n+\n+                    outputArray.Add(jsonItem);\n+                }\n+\n+                targetResults[\"Items\"] = outputArray;\n+                targetResultsNode[targetName] = targetResults;\n+            }\n+\n+            _topLevelNode[\"Target Results\"] = targetResultsNode;",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is a little wordy but it works:\r\n\r\n```sh-session\r\n\u276f .\\.dotnet\\dotnet.exe msbuild .\\src\\MSBuild.UnitTests\\Microsoft.Build.CommandLine.UnitTests.csproj -p:TargetFramework=net7.0 -getItem:Compile | jq -r '.Items.Compile | .[].FullPath'\r\nS:\\msbuild\\src\\MSBuild.UnitTests\\AssemblyInfo.cs\r\nS:\\msbuild\\src\\MSBuild.UnitTests\\CommandLineSwitches_Tests.cs\r\nS:\\msbuild\\src\\MSBuild.UnitTests\\LiveLogger_Tests.cs\r\nS:\\msbuild\\src\\MSBuild.UnitTests\\MSBuildServer_Tests.cs\r\nS:\\msbuild\\src\\MSBuild.UnitTests\\PerfLog_Tests.cs\r\nS:\\msbuild\\src\\MSBuild.UnitTests\\ProjectSchemaValidationHandler_Tests.cs\r\nS:\\msbuild\\src\\MSBuild.UnitTests\\ValidateAssemblyLoadContext.cs\r\nS:\\msbuild\\src\\MSBuild.UnitTests\\XMake_Tests.cs\r\nS:\\msbuild\\src\\Shared\\RegistryDelegates.cs\r\nS:\\msbuild\\src\\Shared\\ProcessExtensions.cs\r\nS:\\msbuild\\src\\Shared\\RegistryHelper.cs\r\nS:\\msbuild\\src\\Shared\\UnitTests\\EngineTestEnvironment.cs\r\nS:\\msbuild\\src\\Shared\\UnitTests\\TestEnvironment.cs\r\nS:\\msbuild\\src\\Shared\\VersionUtilities.cs\r\nS:\\msbuild\\src\\Shared\\UnitTests\\MockEngine.cs\r\nS:\\msbuild\\src\\Shared\\UnitTests\\MockLogger.cs\r\nS:\\msbuild\\src\\Shared\\UnitTests\\ObjectModelHelpers.cs\r\nS:\\msbuild\\src\\UnitTests.Shared\\EnvironmentProvider.cs\r\nS:\\msbuild\\src\\UnitTests.Shared\\RunnerUtilities.cs\r\nS:\\msbuild\\src\\Shared\\UnitTests\\TestAssemblyInfo.cs\r\nS:\\msbuild\\src\\Shared\\UnitTests\\TestProgram.cs\r\n```",
              "createdAt": "2023-07-18T21:51:08Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }\n+\n+                    itemArray.Add(jsonItem);\n+                }\n+\n+                itemsNode[itemName] = itemArray;\n+            }\n+\n+            _topLevelNode[\"Items\"] = itemsNode;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is missing the item include--the most useful information.\r\n\r\nFor example in\r\n\r\n```sh-session\r\n\u276f .\\.dotnet\\dotnet.exe msbuild .\\src\\MSBuild.UnitTests\\Microsoft.Build.CommandLine.UnitTests.csproj -p:TargetFramework=net7.0 -getTargetResult:GetTargetPath\r\n{\r\n  \"Target Results\": {\r\n    \"GetTargetPath\": {\r\n      \"Result\": \"Success\",\r\n      \"Items\": [\r\n        {\r\n          \"TargetFrameworkIdentifier\": \".NETCoreApp\",\r\n          \"TargetPlatformMoniker\": \"\",\r\n          \"CopyUpToDateMarker\": \"S:\\\\msbuild\\\\artifacts\\\\obj\\\\Microsoft.Build.CommandLine.UnitTests\\\\Debug\\\\net7.0\\\\Microsoft.Build.CommandLine.UnitTests.csproj.CopyComplete\",\r\n          \"TargetPlatformIdentifier\": \"\",\r\n          \"TargetFrameworkVersion\": \"7.0\",\r\n          \"ReferenceAssembly\": \"S:\\\\msbuild\\\\artifacts\\\\obj\\\\Microsoft.Build.CommandLine.UnitTests\\\\Debug\\\\net7.0\\\\ref\\\\Microsoft.Build.CommandLine.UnitTests.dll\"\r\n        }\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI expected to see `S:\\msbuild\\artifacts\\bin\\Microsoft.Build.CommandLine.UnitTests\\Debug\\net7.0\\Microsoft.Build.CommandLine.UnitTests.dll`.",
              "createdAt": "2023-07-18T21:52:22Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }\n+\n+                    itemArray.Add(jsonItem);\n+                }\n+\n+                itemsNode[itemName] = itemArray;\n+            }\n+\n+            _topLevelNode[\"Items\"] = itemsNode;\n+        }\n+\n+        internal void AddItemsInJsonFormat(string[] itemNames, Project project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonObject itemsNode = new();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItem item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadata metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }\n+\n+                    itemArray.Add(jsonItem);\n+                }\n+\n+                itemsNode[itemName] = itemArray;\n+            }\n+\n+            _topLevelNode[\"Items\"] = itemsNode;\n+        }\n+\n+        internal void AddTargetResultsInJsonFormat(string[] targetNames, BuildResult result)\n+        {\n+            if (targetNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonObject targetResultsNode = new();\n+            foreach (string targetName in targetNames)\n+            {\n+                TargetResult targetResult = result.ResultsByTarget[targetName];\n+                JsonObject targetResults = new();\n+                targetResults[\"Result\"] = targetResult.ResultCode.ToString();\n+                JsonArray outputArray = new();\n+                foreach (ITaskItem item in targetResult.Items)\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (KeyValuePair<string, string> metadatum in item.EnumerateMetadata())\n+                    {\n+                        jsonItem[metadatum.Key] = metadatum.Value;\n+                    }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I thought I'd tested this, but apparently I tested it for Item but not TargetResult. I switched to using .MetadataNames, which seems to include all the built-in metadata, including identity.",
              "createdAt": "2023-07-20T18:00:32Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }\n+\n+                    itemArray.Add(jsonItem);\n+                }\n+\n+                itemsNode[itemName] = itemArray;\n+            }\n+\n+            _topLevelNode[\"Items\"] = itemsNode;\n+        }\n+\n+        internal void AddItemsInJsonFormat(string[] itemNames, Project project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonObject itemsNode = new();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItem item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadata metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }\n+\n+                    itemArray.Add(jsonItem);\n+                }\n+\n+                itemsNode[itemName] = itemArray;\n+            }\n+\n+            _topLevelNode[\"Items\"] = itemsNode;\n+        }\n+\n+        internal void AddTargetResultsInJsonFormat(string[] targetNames, BuildResult result)\n+        {\n+            if (targetNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonObject targetResultsNode = new();\n+            foreach (string targetName in targetNames)\n+            {\n+                TargetResult targetResult = result.ResultsByTarget[targetName];\n+                JsonObject targetResults = new();\n+                targetResults[\"Result\"] = targetResult.ResultCode.ToString();\n+                JsonArray outputArray = new();\n+                foreach (ITaskItem item in targetResult.Items)\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (KeyValuePair<string, string> metadatum in item.EnumerateMetadata())\n+                    {\n+                        jsonItem[metadatum.Key] = metadatum.Value;\n+                    }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "One thing that's not available here is the Include, which I think of as the \"identity\" of the item.\r\n\r\nA more natural representation IMO would be\r\n\r\n```json\r\n{\r\n  \"ItemInclude\": {\r\n    \"Metadata1\": \"Value1\",\r\n    \"Metadata2\": \"Value2\"\r\n  }\r\n}\r\n```\r\n\r\nBut we can't actually do that because they're not guaranteed to be unique, while JSON would require uniqueness. Maybe just add it as a metadatum?",
              "createdAt": "2023-07-18T21:55:32Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "the general output that I've seen in other tools that would 'naturally' fall into a `name-object` mapping like this is an array instead of a mapping, with the identifier as one of the properties of the objects in the array. so\r\n\r\n```json\r\n\r\n\"Compile\": [\r\n\t{ \"ItemSpec\": \"thing.cs\"\r\n      \"CopyToOutputDirectory\": \"CopyIfNewer\" },\r\n\t{ \"ItemSpec\": \"blah.cs\" }\r\n]\r\n```\r\n",
              "createdAt": "2023-07-19T20:47:21Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "This is much better now. For human-readability, is it possible to push `Identity` to the beginning of the list, in front of all the \"real\" metadata? As is, you get like\r\n\r\n```json\r\n{\r\n  \"Link\": \"TestProgram.cs\",\r\n  \"FullPath\": \"S:\\\\msbuild\\\\src\\\\Shared\\\\UnitTests\\\\TestProgram.cs\",\r\n  \"RootDir\": \"S:\\\\\",\r\n  \"Filename\": \"TestProgram\",\r\n  \"Extension\": \".cs\",\r\n  \"RelativeDir\": \"S:\\\\msbuild\\\\src\\\\Shared\\\\UnitTests\\\\\",\r\n  \"Directory\": \"msbuild\\\\src\\\\Shared\\\\UnitTests\\\\\",\r\n  \"RecursiveDir\": \"\",\r\n  \"Identity\": \"S:\\\\msbuild\\\\src\\\\Shared\\\\UnitTests\\\\TestProgram.cs\",\r\n  \"ModifiedTime\": \"2023-07-14 13:54:04.2486420\",\r\n  \"CreatedTime\": \"2023-07-14 13:54:04.2486420\",\r\n  \"AccessedTime\": \"2023-07-14 13:54:04.2486420\",\r\n  \"DefiningProjectFullPath\": \"S:\\\\msbuild\\\\src\\\\Directory.Build.targets\",\r\n  \"DefiningProjectDirectory\": \"S:\\\\msbuild\\\\src\\\\\",\r\n  \"DefiningProjectName\": \"Directory.Build\",\r\n  \"DefiningProjectExtension\": \".targets\"\r\n}\r\n```\r\n\r\nand it's hard to glance at and understand.",
              "createdAt": "2023-07-27T15:57:38Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It's kinda ugly (code-wise) to push it to the top of the list, but I do think it's better for users. I can do that.",
              "createdAt": "2023-07-27T18:33:59Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you need the `FileUtilities.ItemSpecModifiers.All` here too? I could definitely see `FullPath` being useful.",
              "createdAt": "2023-07-18T21:58:10Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }\n+\n+                    itemArray.Add(jsonItem);\n+                }\n+\n+                itemsNode[itemName] = itemArray;\n+            }\n+\n+            _topLevelNode[\"Items\"] = itemsNode;\n+        }\n+\n+        internal void AddItemsInJsonFormat(string[] itemNames, Project project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonObject itemsNode = new();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItem item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadata metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }\n+\n+                    itemArray.Add(jsonItem);\n+                }\n+\n+                itemsNode[itemName] = itemArray;\n+            }\n+\n+            _topLevelNode[\"Items\"] = itemsNode;\n+        }\n+\n+        internal void AddTargetResultsInJsonFormat(string[] targetNames, BuildResult result)\n+        {\n+            if (targetNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonObject targetResultsNode = new();\n+            foreach (string targetName in targetNames)\n+            {\n+                TargetResult targetResult = result.ResultsByTarget[targetName];\n+                JsonObject targetResults = new();\n+                targetResults[\"Result\"] = targetResult.ResultCode.ToString();\n+                JsonArray outputArray = new();\n+                foreach (ITaskItem item in targetResult.Items)\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (KeyValuePair<string, string> metadatum in item.EnumerateMetadata())\n+                    {\n+                        jsonItem[metadatum.Key] = metadatum.Value;\n+                    }\n+\n+                    outputArray.Add(jsonItem);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think the `builtProject is null` condition is sufficient: I am not seeing this.\r\n\r\n```xml\r\n<Project>\r\n    <Target Name=\"Go\">\r\n        <Error Text=\"Badness happened\" />\r\n    </Target>\r\n</Project>\r\n```\r\n\r\n```sh-session\r\n\u276f .\\.dotnet\\dotnet.exe msbuild .\\bar.proj -getTargetResult:Go\r\n{\r\n  \"Target Results\": {\r\n    \"Go\": {\r\n      \"Result\": \"Failure\",\r\n      \"Items\": []\r\n    }\r\n  }\r\n}\r\n```",
              "createdAt": "2023-07-18T22:07:12Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This needs a regression test.",
              "createdAt": "2023-07-18T22:07:27Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I think I see the error condition here as more specific than you do. I see the error case as \"something catastrophic happened, and we can't give you what you want.\" You see it as \"the build failed for some reason.\" I included the target's success/failure specifically because I'd consider \"Failure\" as a valid output. If you care about whether it succeeded or failed, you can check for that; if not, you may get more information by skipping past the error message and trying to provide what the user requested.",
              "createdAt": "2023-07-19T21:22:16Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Others can weigh in, but I see this feature as pointed towards \"I want more information about my build\" more than \"my build failed, and I want to know why.\" If your build failed, just collect a binlog; it'll be a lot more helpful than anything I could give you here. (And you can still collect a binlog with this feature enabled.)",
              "createdAt": "2023-07-19T21:24:58Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Suppose you have a build definition where you have a script that does a design-time-like build to get information about the project output. In CI, long after this is established, it starts failing. What is the user experience you expect in this case? What does the scripting look like to handle failures?",
              "createdAt": "2023-07-19T21:35:12Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I expect the user to look at the binlog that is also enabled in their CI and use that to diagnose the failure.",
              "createdAt": "2023-07-19T23:15:08Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I'd really like an answer to this part\r\n\r\n> What does the scripting look like to handle failures?",
              "createdAt": "2023-07-20T18:14:04Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I don't think I understand that question. What kind of failure? Like do you mean something like the `<Error />` you mentioned earlier or something more serious? And are you asking how the user is supposed to diagnose the problem, how this feature should handle it, or something else?",
              "createdAt": "2023-07-20T18:17:46Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@Forgind when I was thinking \"errors should go to stderr\" what I was imagining was build errors/warnings (in addition to any catastrophic errors/crashes/etc). given @rainersigwald's sample above, I'd expect to see something like:\r\n\r\n```shell\r\n\u276f .\\.dotnet\\dotnet.exe msbuild .\\bar.proj -getTargetResult:Go\r\n.\\bar.proj(3:8) - error: Badness happened\r\n{\r\n  \"Target Results\": {\r\n    \"Go\": {\r\n      \"Result\": \"Failure\",\r\n      \"Items\": []\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nwith the diagnostic being emitted on stderr, and the json structure emitted to stdout. This is because in shell scripting it's easiest to manage those streams separately (think streaming stdout into `jq` for example) if you don't also have to preprocess out any error lines.",
              "createdAt": "2023-07-20T18:26:47Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "So to be clear, your proposal is that all errors MSBuild emits would go straight to stderr, but we'd generally continue on (if possible) and emit target results as it currently does?",
              "createdAt": "2023-07-20T18:29:23Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I would also expect a nonzero exit code in the case of errors/a failed build.",
              "createdAt": "2023-07-20T18:31:11Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "@Forgind yes, with @rainersigwald's exit code caveat :+1: more concretely - they would be emitted to stderr _using the console logger/formatter's styling_ (we hadn't clarified that before so I wanted to do so here).",
              "createdAt": "2023-07-20T18:32:33Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "I tested with the changes up to `cad93f2` and the exit code is done, but the emitting of msbuild diagnostics to stderr isn't implemented yet @Forgind ",
              "createdAt": "2023-07-21T18:07:32Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +873,32 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            ILogger simpleLogger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                            string errorMessage = simpleLogger is null ? \"internal error\" : (simpleLogger as SimpleErrorLogger).errorList.ToString();\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\", errorMessage));",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why keep a single `StringBuilder` instead of an array of errors (or an array of formatted strings)?",
              "createdAt": "2023-07-18T22:08:23Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,52 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Text;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public StringBuilder errorList;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I don't think it matters too much in this case, to be honest. This isn't intended to be a particularly clever or detailed logger. It isn't harder to append to a string builder or a list, and when accessing the errors at the other end, I'd just concatenate them with \\n in between anyway, so I may as well do that here. If you foresee other uses for this logger (I don't) and want it to be a list, I can make that happen.",
              "createdAt": "2023-07-19T21:29:22Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,52 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Text;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public StringBuilder errorList;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> when accessing the errors at the other end, I'd just concatenate them with \\n in between anyway\r\n\r\nI think the mismatch is I expected see an array of them in the JSON in the failure case.",
              "createdAt": "2023-07-19T21:33:55Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,52 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Text;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public StringBuilder errorList;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "That was one of the options proposed, but that question stayed open for a while with no input provided. The design is not changing on this point now.",
              "createdAt": "2023-07-19T23:16:05Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,52 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Text;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public StringBuilder errorList;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I thought we got to a point where errors were able to be emitted to stderr?",
              "createdAt": "2023-07-19T23:21:42Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,52 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Text;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public StringBuilder errorList;",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "That is what I remember too, now that you mention it.",
              "createdAt": "2023-07-20T13:43:01Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,52 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Text;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public StringBuilder errorList;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "They are; this is part of that mechanism.\r\n\r\nThis logger is enabled in place of the standard console logger when we're attaching loggers as part of processing command line switches. It only listens for errors and keeps track of them as we go along. If we ultimately decide that we want to show errors, they're all emitted to stderr in the end.\r\n\r\nI could have emitted them to stderr as we go, and I think I had a reason for why I did it this way instead, but it's been a while, and I don't remember.",
              "createdAt": "2023-07-20T15:21:51Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,52 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Text;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public StringBuilder errorList;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "My attempts did not show them logged to stderr--see https://github.com/dotnet/msbuild/pull/8792#discussion_r1267346495.",
              "createdAt": "2023-07-20T17:06:22Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,52 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Text;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public StringBuilder errorList;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "As I said in that thread, I see the \"error\" condition as more narrow than you do. My vision for this feature is that it does not log errors unless it is unable to do what it tries to do. If you use the error task, that is a legitimate \"error\" but not a catastrophic one that prevents us from telling you the result of the target (failure).\r\n\r\nThat means that the two cases in which I log to stderr are:\r\n1. We are only evaluating your project rather than running a full build, and we get an InvalidProjectFileException when trying to load your project.\r\n2. We are executing a full build, but we fail to save off the built project, presumably because of a catastrophic failure during build.\r\n\r\nIn all other cases, the design I'm following is to just provide all the information we can without erroring or writing to stderr.",
              "createdAt": "2023-07-20T18:07:47Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,52 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Text;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public StringBuilder errorList;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Consider adding new tests with Verify, preserving the full JSON output.",
              "createdAt": "2023-07-18T22:09:10Z",
              "path": "src/MSBuild.UnitTests/XMake_Tests.cs",
              "diffHunk": "@@ -617,6 +618,58 @@ public void InvalidMaxCPUCountSwitch4()\n             });\n         }\n \n+        [Theory]\n+        [InlineData(\"-getProperty:Foo;Bar\", true, \"EvalValue\", false, false)]\n+        [InlineData(\"-getProperty:Foo;Bar -t:Build\", true, \"TargetValue\", false, false)]\n+        [InlineData(\"-getItem:MyItem\", false, \"\", true, false)]\n+        [InlineData(\"-getItem:MyItem -t:Build\", false, \"\", true, true)]\n+        [InlineData(\"-getItem:WrongItem -t:Build\", false, \"\", false, false)]\n+        [InlineData(\"-getProperty:Foo;Bar -getItem:MyItem -t:Build\", true, \"TargetValue\", true, true)]\n+        [InlineData(\"-getProperty:Foo;Bar -getItem:MyItem\", true, \"EvalValue\", true, false)]\n+        public void ExecuteAppWithGetPropertyAndItem(string extraSwitch, bool fooPresent, string fooResult, bool itemIncludesAlwaysThere, bool itemIncludesTargetItem)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Ping on this.",
              "createdAt": "2023-07-27T16:29:20Z",
              "path": "src/MSBuild.UnitTests/XMake_Tests.cs",
              "diffHunk": "@@ -617,6 +618,58 @@ public void InvalidMaxCPUCountSwitch4()\n             });\n         }\n \n+        [Theory]\n+        [InlineData(\"-getProperty:Foo;Bar\", true, \"EvalValue\", false, false)]\n+        [InlineData(\"-getProperty:Foo;Bar -t:Build\", true, \"TargetValue\", false, false)]\n+        [InlineData(\"-getItem:MyItem\", false, \"\", true, false)]\n+        [InlineData(\"-getItem:MyItem -t:Build\", false, \"\", true, true)]\n+        [InlineData(\"-getItem:WrongItem -t:Build\", false, \"\", false, false)]\n+        [InlineData(\"-getProperty:Foo;Bar -getItem:MyItem -t:Build\", true, \"TargetValue\", true, true)]\n+        [InlineData(\"-getProperty:Foo;Bar -getItem:MyItem\", true, \"EvalValue\", true, false)]\n+        public void ExecuteAppWithGetPropertyAndItem(string extraSwitch, bool fooPresent, string fooResult, bool itemIncludesAlwaysThere, bool itemIncludesTargetItem)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I don't understand how this adds value over what I currently have. I'm already verifying that the output includes the parts I want it to include and doesn't include a value I don't want it to include. If you go down deep enough, some of the metadata are ultimately based on hashing (a dictionary), which means that we can't guarantee that the output will look exactly as it currently does over time. Though I'd be surprised if it changes, I'd still prefer to avoid that risk.",
              "createdAt": "2023-07-27T18:53:44Z",
              "path": "src/MSBuild.UnitTests/XMake_Tests.cs",
              "diffHunk": "@@ -617,6 +618,58 @@ public void InvalidMaxCPUCountSwitch4()\n             });\n         }\n \n+        [Theory]\n+        [InlineData(\"-getProperty:Foo;Bar\", true, \"EvalValue\", false, false)]\n+        [InlineData(\"-getProperty:Foo;Bar -t:Build\", true, \"TargetValue\", false, false)]\n+        [InlineData(\"-getItem:MyItem\", false, \"\", true, false)]\n+        [InlineData(\"-getItem:MyItem -t:Build\", false, \"\", true, true)]\n+        [InlineData(\"-getItem:WrongItem -t:Build\", false, \"\", false, false)]\n+        [InlineData(\"-getProperty:Foo;Bar -getItem:MyItem -t:Build\", true, \"TargetValue\", true, true)]\n+        [InlineData(\"-getProperty:Foo;Bar -getItem:MyItem\", true, \"EvalValue\", true, false)]\n+        public void ExecuteAppWithGetPropertyAndItem(string extraSwitch, bool fooPresent, string fooResult, bool itemIncludesAlwaysThere, bool itemIncludesTargetItem)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Since this is console UX, I think consistency and predictability is important. Order is a good consideration--I'd probably say to sort by key.\r\n\r\nBut if you feel very strongly about this, I think the current state meets the minimum bar.",
              "createdAt": "2023-07-27T21:07:10Z",
              "path": "src/MSBuild.UnitTests/XMake_Tests.cs",
              "diffHunk": "@@ -617,6 +618,58 @@ public void InvalidMaxCPUCountSwitch4()\n             });\n         }\n \n+        [Theory]\n+        [InlineData(\"-getProperty:Foo;Bar\", true, \"EvalValue\", false, false)]\n+        [InlineData(\"-getProperty:Foo;Bar -t:Build\", true, \"TargetValue\", false, false)]\n+        [InlineData(\"-getItem:MyItem\", false, \"\", true, false)]\n+        [InlineData(\"-getItem:MyItem -t:Build\", false, \"\", true, true)]\n+        [InlineData(\"-getItem:WrongItem -t:Build\", false, \"\", false, false)]\n+        [InlineData(\"-getProperty:Foo;Bar -getItem:MyItem -t:Build\", true, \"TargetValue\", true, true)]\n+        [InlineData(\"-getProperty:Foo;Bar -getItem:MyItem\", true, \"EvalValue\", true, false)]\n+        public void ExecuteAppWithGetPropertyAndItem(string extraSwitch, bool fooPresent, string fooResult, bool itemIncludesAlwaysThere, bool itemIncludesTargetItem)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "> I don't understand how this adds value over what I currently have.\r\n\r\nThis still applies for the test change.\r\n\r\nAs far as having a consistent/predictable order, the primary use case from my perspective is via automation, which doesn't care about the order.\r\n\r\nAnother ordering consideration is built-in metadata versus custom metadata. As-is, one of the three implementations explicitly separates custom metadata and built-in metadata and adds them separately. The other two instances do not guarantee that that will be the case, but many implementations do so implicitly, albeit not necessarily the same way. I think having custom metadata and built-in metadata in their own chunks is a valuable thing to include.",
              "createdAt": "2023-08-01T18:52:19Z",
              "path": "src/MSBuild.UnitTests/XMake_Tests.cs",
              "diffHunk": "@@ -617,6 +618,58 @@ public void InvalidMaxCPUCountSwitch4()\n             });\n         }\n \n+        [Theory]\n+        [InlineData(\"-getProperty:Foo;Bar\", true, \"EvalValue\", false, false)]\n+        [InlineData(\"-getProperty:Foo;Bar -t:Build\", true, \"TargetValue\", false, false)]\n+        [InlineData(\"-getItem:MyItem\", false, \"\", true, false)]\n+        [InlineData(\"-getItem:MyItem -t:Build\", false, \"\", true, true)]\n+        [InlineData(\"-getItem:WrongItem -t:Build\", false, \"\", false, false)]\n+        [InlineData(\"-getProperty:Foo;Bar -getItem:MyItem -t:Build\", true, \"TargetValue\", true, true)]\n+        [InlineData(\"-getProperty:Foo;Bar -getItem:MyItem\", true, \"EvalValue\", true, false)]\n+        public void ExecuteAppWithGetPropertyAndItem(string extraSwitch, bool fooPresent, string fooResult, bool itemIncludesAlwaysThere, bool itemIncludesTargetItem)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this necessary, in new code?",
              "createdAt": "2023-07-27T15:40:07Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,61 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Are you setting the console mode somewhere? I don't see it.",
              "createdAt": "2023-07-27T15:46:53Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,61 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public bool hasLoggedErrors = false;\n+        public SimpleErrorLogger()\n+        {\n+        }\n+\n+        public LoggerVerbosity Verbosity\n+        {\n+            get => LoggerVerbosity.Minimal;\n+            set { }\n+        }\n+\n+        public string Parameters\n+        {\n+            get => string.Empty;\n+            set { }\n+        }\n+\n+        public void Initialize(IEventSource eventSource, int nodeCount)\n+        {\n+            eventSource.ErrorRaised += HandleErrorEvent;\n+            eventSource.WarningRaised += HandleWarningEvent;\n+        }\n+\n+        private void HandleErrorEvent(object sender, BuildErrorEventArgs e)\n+        {\n+            hasLoggedErrors = true;\n+            Console.Error.Write(\"\\x1b[31;1m\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I was basing this on our SerialConsoleLogger/BaseConsoleLogger. Do they set the console mode somewhere?",
              "createdAt": "2023-07-27T18:40:34Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,61 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public bool hasLoggedErrors = false;\n+        public SimpleErrorLogger()\n+        {\n+        }\n+\n+        public LoggerVerbosity Verbosity\n+        {\n+            get => LoggerVerbosity.Minimal;\n+            set { }\n+        }\n+\n+        public string Parameters\n+        {\n+            get => string.Empty;\n+            set { }\n+        }\n+\n+        public void Initialize(IEventSource eventSource, int nodeCount)\n+        {\n+            eventSource.ErrorRaised += HandleErrorEvent;\n+            eventSource.WarningRaised += HandleWarningEvent;\n+        }\n+\n+        private void HandleErrorEvent(object sender, BuildErrorEventArgs e)\n+        {\n+            hasLoggedErrors = true;\n+            Console.Error.Write(\"\\x1b[31;1m\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Ah, sorry--setting the console mode is required only on Windows--*nix terminals support this stuff by default. The console logger should only emit these codes when forced to or in an environment that supports them.\r\n\r\nThe terminallogger _also_ doesn't call `SetConsoleMode` as I'd expect it to, so let's file a followup item to do it here and there.",
              "createdAt": "2023-07-27T18:48:08Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,61 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public bool hasLoggedErrors = false;\n+        public SimpleErrorLogger()\n+        {\n+        }\n+\n+        public LoggerVerbosity Verbosity\n+        {\n+            get => LoggerVerbosity.Minimal;\n+            set { }\n+        }\n+\n+        public string Parameters\n+        {\n+            get => string.Empty;\n+            set { }\n+        }\n+\n+        public void Initialize(IEventSource eventSource, int nodeCount)\n+        {\n+            eventSource.ErrorRaised += HandleErrorEvent;\n+            eventSource.WarningRaised += HandleWarningEvent;\n+        }\n+\n+        private void HandleErrorEvent(object sender, BuildErrorEventArgs e)\n+        {\n+            hasLoggedErrors = true;\n+            Console.Error.Write(\"\\x1b[31;1m\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "https://github.com/dotnet/msbuild/issues/9079",
              "createdAt": "2023-07-27T20:56:21Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,61 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public bool hasLoggedErrors = false;\n+        public SimpleErrorLogger()\n+        {\n+        }\n+\n+        public LoggerVerbosity Verbosity\n+        {\n+            get => LoggerVerbosity.Minimal;\n+            set { }\n+        }\n+\n+        public string Parameters\n+        {\n+            get => string.Empty;\n+            set { }\n+        }\n+\n+        public void Initialize(IEventSource eventSource, int nodeCount)\n+        {\n+            eventSource.ErrorRaised += HandleErrorEvent;\n+            eventSource.WarningRaised += HandleWarningEvent;\n+        }\n+\n+        private void HandleErrorEvent(object sender, BuildErrorEventArgs e)\n+        {\n+            hasLoggedErrors = true;\n+            Console.Error.Write(\"\\x1b[31;1m\");",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please write a doc comment explaining what this class is for.",
              "createdAt": "2023-07-27T15:48:02Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,61 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    public class SimpleErrorLogger : INodeLogger",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this (and the Project one below) be unified to the `.MetadataNames` approach you figured out for target results?",
              "createdAt": "2023-07-27T16:06:23Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "That isn't available on ProjectItems, unfortunately.",
              "createdAt": "2023-07-27T18:28:41Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I can do it for ProjectItemInstances, though. I'm a bit split as to whether I prefer \"simpler\" or \"same as the other item thing\", so I can do what you suggested for that case.",
              "createdAt": "2023-07-27T18:30:31Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,139 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)\n+        {\n+            if (propertyNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode propertiesNode = new JsonObject();\n+            foreach (string property in propertyNames)\n+            {\n+                propertiesNode[property] = getProperty(property);\n+            }\n+\n+            _topLevelNode[\"Properties\"] = propertiesNode;\n+        }\n+\n+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)\n+        {\n+            if (itemNames.Length == 0)\n+            {\n+                return;\n+            }\n+\n+            JsonNode itemsNode = new JsonObject();\n+            foreach (string itemName in itemNames)\n+            {\n+                JsonArray itemArray = new();\n+                foreach (ProjectItemInstance item in project.GetItems(itemName))\n+                {\n+                    JsonObject jsonItem = new();\n+                    foreach (ProjectMetadataInstance metadatum in item.Metadata)\n+                    {\n+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;\n+                    }\n+\n+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)\n+                    {\n+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);\n+                    }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I like the prior indentation",
              "createdAt": "2023-07-27T16:25:39Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2452,23 +2562,24 @@ private static bool GatherAutoResponseFileSwitchesFromFullPath(string autoRespon\n                     string[][] groupedFileLoggerParameters = commandLineSwitches.GetFileLoggerParameters();\n \n                     loggers = ProcessLoggingSwitches(\n-                        commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Logger],\n-                        commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.DistributedLogger],\n-                        commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],\n-                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],\n-                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],\n-                        terminallogger,\n-                        commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger\n-                        commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],\n-                        commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],\n-                        commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ProfileEvaluation],\n-                        groupedFileLoggerParameters,\n-                        out distributedLoggerRecords,\n-                        out verbosity,\n-                        out originalVerbosity,\n-                        cpuCount,\n-                        out profilerLogger,\n-                        out enableProfiler);\n+                    commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Logger],\n+                    commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.DistributedLogger],\n+                    commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],\n+                    commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],\n+                    commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],\n+                    terminallogger,\n+                    commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger\n+                    commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],\n+                    commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],\n+                    commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ProfileEvaluation],\n+                    groupedFileLoggerParameters,\n+                    getProperty.Length + getItem.Length + getTargetResult.Length > 0,\n+                    out distributedLoggerRecords,\n+                    out verbosity,\n+                    out originalVerbosity,\n+                    cpuCount,\n+                    out profilerLogger,\n+                    out enableProfiler);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Where did you get these codes from? comment down at the bottom says next code assigned should be 1065.",
              "createdAt": "2023-07-27T20:08:54Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -1033,6 +1033,37 @@\n       LOCALIZATION: The prefix \"MSBUILD : error MSBxxxx:\" should not be localized.\n     </comment>\n   </data>\n+  <data name=\"MissingGetPropertyError\" UESanitized=\"true\" Visibility=\"Public\">\n+    <value>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</value>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "These error codes seem to have been skipped, so I figured I'd fill in a few gaps.\r\n\r\nrg MSB1010 returned only my new usages. Same for MSB1014 and MSB1017. A quick google search brought up MSB1011 instead.",
              "createdAt": "2023-08-01T18:21:10Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -1033,6 +1033,37 @@\n       LOCALIZATION: The prefix \"MSBUILD : error MSBxxxx:\" should not be localized.\n     </comment>\n   </data>\n+  <data name=\"MissingGetPropertyError\" UESanitized=\"true\" Visibility=\"Public\">\n+    <value>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</value>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "In general that is not a good strategy; we should not reuse codes for obsolete errors to avoid having to rejuggle help docs or user-written things. If you're not following the policy, please mention that explicitly with justification and evidence of due diligence. The Google search you just mentioned is good evidence that this is ok.",
              "createdAt": "2023-08-01T18:46:41Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -1033,6 +1033,37 @@\n       LOCALIZATION: The prefix \"MSBUILD : error MSBxxxx:\" should not be localized.\n     </comment>\n   </data>\n+  <data name=\"MissingGetPropertyError\" UESanitized=\"true\" Visibility=\"Public\">\n+    <value>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</value>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Note that the rg search would also find obsolete errors in the deprecated assemblies. I may be wrong, but I'm not aware of any error codes we not only stopped using but also expunged any reference to the error code anywhere in the repo.",
              "createdAt": "2023-08-01T18:54:12Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -1033,6 +1033,37 @@\n       LOCALIZATION: The prefix \"MSBUILD : error MSBxxxx:\" should not be localized.\n     </comment>\n   </data>\n+  <data name=\"MissingGetPropertyError\" UESanitized=\"true\" Visibility=\"Public\">\n+    <value>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</value>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "What I am saying is that a search in the current codebase is not sufficient. We have removed errors before. I do not think it's reliable to assume that we have _always_ made comments like\r\n\r\nhttps://github.com/dotnet/msbuild/blob/69a09e4d0ad2a26fab4100e78585c85bc2f9f5a7/src/Tasks/Resources/Strings.resx#L3033-L3034",
              "createdAt": "2023-08-01T18:57:39Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -1033,6 +1033,37 @@\n       LOCALIZATION: The prefix \"MSBUILD : error MSBxxxx:\" should not be localized.\n     </comment>\n   </data>\n+  <data name=\"MissingGetPropertyError\" UESanitized=\"true\" Visibility=\"Public\">\n+    <value>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</value>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `sealed`",
              "createdAt": "2023-08-03T14:17:33Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,69 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    /// <summary>\n+    /// This logger ignores all message-level output, writing errors and warnings to\n+    /// standard error, colored red and yellow respectively.\n+    ///\n+    /// It is currently used only when the user requests information about specific\n+    /// properties, items, or target results. In that case, we write the desired output\n+    /// to standard out, but we do not want it polluted with any other kinds of information.\n+    /// Users still might want diagnostic information if something goes wrong, so still\n+    /// output that as necessary.\n+    /// </summary>\n+    public class SimpleErrorLogger : INodeLogger",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n        public bool HasLoggedErrors { get; private set; } = false;\r\n```\r\n\r\nand move down to the other props.",
              "createdAt": "2023-08-03T14:29:17Z",
              "path": "src/Build/Logging/SimpleErrorLogger.cs",
              "diffHunk": "@@ -0,0 +1,69 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging.SimpleErrorLogger\n+{\n+    /// <summary>\n+    /// This logger ignores all message-level output, writing errors and warnings to\n+    /// standard error, colored red and yellow respectively.\n+    ///\n+    /// It is currently used only when the user requests information about specific\n+    /// properties, items, or target results. In that case, we write the desired output\n+    /// to standard out, but we do not want it polluted with any other kinds of information.\n+    /// Users still might want diagnostic information if something goes wrong, so still\n+    /// output that as necessary.\n+    /// </summary>\n+    public class SimpleErrorLogger : INodeLogger\n+    {\n+        public bool hasLoggedErrors = false;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `sealed` and a short summary comment if possible.",
              "createdAt": "2023-08-03T14:39:07Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Also, ideally classes like this one would be covered with unit tests.",
              "createdAt": "2023-08-03T14:58:48Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Naming convention `s_options`.",
              "createdAt": "2023-08-03T14:52:44Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: The `Add` prefix suggests additive semantics but the method \"sets\"/\"overwrites\". Would you consider renaming to make this clearer?",
              "createdAt": "2023-08-03T15:44:15Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I see this as adding to the _topLevelNode object. It's a list of all the properties/items/results we've encountered so far, and each time one of these methods is called, more information is added to it.",
              "createdAt": "2023-08-04T19:11:19Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That's what the name suggests, yes. But when called multiple times, properties are not added. Instead the last call wins and overwrites everything added previously (line 41 `_topLevelNode[\"Properties\"] = propertiesNode;`).\r\n\r\nJust a nit really, feel free to ignore.",
              "createdAt": "2023-08-07T15:16:08Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I guess that scenario isn't too important to me because I know that it should not be called more than once. Would it be clearer if I add a VerifyThrow that the \"Properties\" node doesn't exist yet?",
              "createdAt": "2023-08-07T15:19:09Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That would work, yes, thank you.",
              "createdAt": "2023-08-07T16:08:59Z",
              "path": "src/MSBuild/JsonOutputFormatter.cs",
              "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Text.Json;\n+using System.Text.Json.Nodes;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    internal class JsonOutputFormatter\n+    {\n+        private static readonly JsonSerializerOptions Options = new() { AllowTrailingCommas = false, WriteIndented = true };\n+        private readonly JsonNode _topLevelNode = new JsonObject();\n+\n+        public override string ToString()\n+        {\n+            return _topLevelNode.ToJsonString(Options);\n+        }\n+\n+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The complexity is getting a bit out of hand here. Would it be possible to pull this into a helper method, similar to `ReplayBinaryLog`?",
              "createdAt": "2023-08-03T15:59:27Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -782,6 +789,43 @@ private static void DebuggerLaunchCheck()\n                     {\n                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);\n                     }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && FileUtilities.IsSolutionFilename(projectFile))\n+                    {\n+                        exitType = ExitType.BuildError;\n+                        CommandLineSwitchException.Throw(\"SolutionBuildInvalidForCommandLineEvaluation\",\n+                            getProperty.Length > 0 ? \"getProperty\" :\n+                            getItem.Length > 0 ? \"getItem\" :\n+                            \"getTargetResult\");\n+                    }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))\n+                    {\n+                        try\n+                        {\n+                            Project project = Project.FromFile(projectFile, new Definition.ProjectOptions()\n+                            {\n+                                GlobalProperties = globalProperties,\n+                                ToolsVersion = toolsVersion,\n+                            });\n+\n+                            // Special case if the user requests exactly one property: skip json formatting\n+                            if (getProperty.Length == 1 && getItem.Length == 0)\n+                            {\n+                                Console.WriteLine(project.GetPropertyValue(getProperty[0]));\n+                            }\n+                            else\n+                            {\n+                                JsonOutputFormatter jsonOutputFormatter = new();\n+                                jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => project.GetPropertyValue(property));\n+                                jsonOutputFormatter.AddItemsInJsonFormat(getItem, project);\n+                                Console.WriteLine(jsonOutputFormatter.ToString());\n+                            }\n+                        }\n+                        catch (InvalidProjectFileException e)\n+                        {\n+                            exitType = ExitType.BuildError;\n+                            Console.Error.WriteLine(e.Message);\n+                        }\n+                    }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Same as the other big block above - could it be a separate method?",
              "createdAt": "2023-08-03T16:00:10Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -828,6 +874,36 @@ private static void DebuggerLaunchCheck()\n \n                     string timerOutputFilename = Environment.GetEnvironmentVariable(\"MSBUILDTIMEROUTPUTS\");\n \n+                    if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && targets?.Length > 0 && result is not null)\n+                    {\n+                        ProjectInstance builtProject = result.ProjectStateAfterBuild;\n+\n+                        ILogger logger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);\n+                        if (logger is not null)\n+                        {\n+                            exitType = exitType == ExitType.Success && (logger as SimpleErrorLogger).hasLoggedErrors ? ExitType.BuildError : exitType;\n+                        }\n+\n+                        if (builtProject is null)\n+                        {\n+                            // Build failed; do not proceed\n+                            Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"BuildFailedWithPropertiesItemsOrTargetResultsRequested\"));\n+                        }\n+                        // Special case if the user requests exactly one property: skip the json formatting\n+                        else if (getProperty.Length == 1 && getItem.Length == 0 && getTargetResult.Length == 0)\n+                        {\n+                            Console.WriteLine(builtProject.GetPropertyValue(getProperty[0]));\n+                        }\n+                        else\n+                        {\n+                            JsonOutputFormatter jsonOutputFormatter = new();\n+                            jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => builtProject.GetPropertyValue(property));\n+                            jsonOutputFormatter.AddItemInstancesInJsonFormat(getItem, builtProject);\n+                            jsonOutputFormatter.AddTargetResultsInJsonFormat(getTargetResult, result);\n+                            Console.WriteLine(jsonOutputFormatter.ToString());\n+                        }\n+                    }\n+",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n            bool saveProjectResult,\r\n```\r\n?\r\n\r\n`saveProject` looks like it would be saving the project file.",
              "createdAt": "2023-08-03T18:41:36Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1137,6 +1213,8 @@ private static void ResetGatheringSwitchesState()\n             bool question,\n             string[] inputResultsCaches,\n             string outputResultsCache,\n+            bool saveProject,",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This means that if one of the new options is specified, logger switches are silently ignored. I'd say that's a bug and should be fixed in this PR or tracked in an issue.",
              "createdAt": "2023-08-03T19:28:01Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3381,13 +3493,21 @@ private static string ProcessToolsVersionSwitch(string[] parameters)\n             var outVerbosity = verbosity;\n             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);\n \n-            ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            // When returning the result of evaluation from the command line, do not use custom loggers.\n+            if (!useSimpleErrorLogger)\n+            {\n+                ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "To be clear, this is silently ignoring _custom_ logger switches, not all logger switches. That was an intentional choice. As I recall, there was concern about polluting output streams with different kinds of data\u2014that is, if you have a custom logger that writes information to stdout, and I try to put the json in stdout, they could get mixed up (or at least be next to each other), which would make parsing it confusing.",
              "createdAt": "2023-08-04T20:17:00Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3381,13 +3493,21 @@ private static string ProcessToolsVersionSwitch(string[] parameters)\n             var outVerbosity = verbosity;\n             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);\n \n-            ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            // When returning the result of evaluation from the command line, do not use custom loggers.\n+            if (!useSimpleErrorLogger)\n+            {\n+                ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I understand it was intentional for some of the existing switches to be mutually exclusive with the new ones. It's surprising that we would intentionally want to ignore them instead of throwing an error, though. Can you please confirm this is really the case?",
              "createdAt": "2023-08-07T15:28:01Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3381,13 +3493,21 @@ private static string ProcessToolsVersionSwitch(string[] parameters)\n             var outVerbosity = verbosity;\n             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);\n \n-            ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            // When returning the result of evaluation from the command line, do not use custom loggers.\n+            if (!useSimpleErrorLogger)\n+            {\n+                ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "That was my understanding, but there have been a couple cases of misunderstandings here, so @baronfel?",
              "createdAt": "2023-08-07T15:34:43Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3381,13 +3493,21 @@ private static string ProcessToolsVersionSwitch(string[] parameters)\n             var outVerbosity = verbosity;\n             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);\n \n-            ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            // When returning the result of evaluation from the command line, do not use custom loggers.\n+            if (!useSimpleErrorLogger)\n+            {\n+                ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Correct - we opted to silently ignore for a few reasons:\n\n* The custom loggers are entirely ignored when the new flags are used to prevent stdout/stderr hijacking\n* MSBuild is still performing a build, and so reading arguments from not-only-commandline sources like Directory.Build.rsp can mean that tooling/scripts may not be in complete control of the final command line. So we need to be able to use this functionality even on the presence of conflicting command lines, so we just ignore instead of error.",
              "createdAt": "2023-08-07T15:39:25Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3381,13 +3493,21 @@ private static string ProcessToolsVersionSwitch(string[] parameters)\n             var outVerbosity = verbosity;\n             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);\n \n-            ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            // When returning the result of evaluation from the command line, do not use custom loggers.\n+            if (!useSimpleErrorLogger)\n+            {\n+                ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            }",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "Thank you for following up. I stand corrected then. It would be super awesome for this logic to be covered with tests or at least commented so the future me wouldn't try to \"fix it\". (Extra points!)",
              "createdAt": "2023-08-07T16:14:27Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3381,13 +3493,21 @@ private static string ProcessToolsVersionSwitch(string[] parameters)\n             var outVerbosity = verbosity;\n             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);\n \n-            ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            // When returning the result of evaluation from the command line, do not use custom loggers.\n+            if (!useSimpleErrorLogger)\n+            {\n+                ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);\n+            }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0` is repeated 3 times in this method. Would you consider adding a local variable with this value and a good name?",
              "createdAt": "2023-08-07T15:23:57Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -782,6 +791,18 @@ private static void DebuggerLaunchCheck()\n                     {\n                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);\n                     }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && FileUtilities.IsSolutionFilename(projectFile))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I'm not a huge fan of the name I came up with, since it's rather verbose, but I liked other options less. If you can think of something better, please opine \ud83d\ude42",
              "createdAt": "2023-08-07T15:39:21Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -782,6 +791,18 @@ private static void DebuggerLaunchCheck()\n                     {\n                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);\n                     }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0) && FileUtilities.IsSolutionFilename(projectFile))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                        using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))\r\n```\r\n\r\nshould fix the test failures.",
              "createdAt": "2023-08-09T08:15:49Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -776,12 +785,31 @@ private static void DebuggerLaunchCheck()\n \n                     DateTime t1 = DateTime.Now;\n \n+                    bool outputPropertiesItemsOrTargetResults = getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0;\n+\n                     // If the primary file passed to MSBuild is a .binlog file, play it back into passed loggers\n                     // as if a build is happening\n                     if (FileUtilities.IsBinaryLogFilename(projectFile))\n                     {\n                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);\n                     }\n+                    else if (outputPropertiesItemsOrTargetResults && FileUtilities.IsSolutionFilename(projectFile))\n+                    {\n+                        exitType = ExitType.BuildError;\n+                        CommandLineSwitchException.Throw(\"SolutionBuildInvalidForCommandLineEvaluation\",\n+                            getProperty.Length > 0 ? \"getProperty\" :\n+                            getItem.Length > 0 ? \"getItem\" :\n+                            \"getTargetResult\");\n+                    }\n+                    else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))\n+                    {\n+                        using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.None))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}