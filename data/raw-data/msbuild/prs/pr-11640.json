{
  "number": 11640,
  "title": "Support string interning / deduplication within packets",
  "body": "### Context\r\n\r\nWhen looking at serialization overhead for the RAR node, I found that most of the serialization overhead comes down to reading strings from the payload.\r\n\r\nMany strings are shared between task items, such as common metadata values, file names, parent directories.\r\n\r\nWith the existing translator system, you *can* manually do this - you effectively need to create a temporary buffer, ID mapping, and offset the lookup depending on the direction. But it's difficult to set up, all child objects would need separate constructors, and it breaks the idea of having `ITranslator` be unidirectional since the write patterns have different ordering requirements - which makes it incredibly easy to accidentally break.\r\n\r\n### Changes Made\r\n\r\nThis bakes in an opt-in string interning API directly into the `ITranslator` framework. By defining a block like:\r\n```cs\r\ntranslator.WithInterning(StringComparer.Ordinal, translator =>\r\n{\r\n   translator.Translate(ref  _someItem);\r\n   translator.Intern(ref _someString);\r\n   translator.InternDictionary(ref _someDictionary, StringComparer.OrdinalIgnoreCase, translator => new SomeITranslator(translator));\r\n});\r\n```\r\n...all steps are automatically handled. `BinaryWriteTranslator` swaps its writer with a translator provided by `InterningWriteTranslator`. When the block is completed, the offset + flush automatically happens. On the read side, `BinaryReadTranslator` just reads directly from the stream, using `InterningReadTranslator` to decode any interned strings.\r\n\r\nA parent translator can enter multiple intern blocks across its lifetime as the buffers are just reset and reused. This makes it possible to use with the existing node pipe implementations, since they are reused across packets.\r\n\r\nThe `ITranslatable` implementation can selectively choose which strings to intern, and which strings are unlikely to be duplicated.\r\n\r\nIf `_.Intern()` methods are called outside of an enclosing delegate, they simply behave as a non-interned operation. \r\n\r\nThis makes it extremely easy to add string interning / deduplication support for any arbitrary `INodePacket`. See the included example of enabling this for the RAR statefile.\r\n\r\n### Testing\r\n\r\nImplementation seen here effectively cuts packet size for RAR request / response packets by ~50-60%.\r\n\r\nRAR statefile can hit a ~20% size reduction, but only with additional changes to intern on substrings rather than a path separator (e.g. you run into strings like `file///somepath/foo.dll` where the full path isn't deduplicated due to the prefix). Given this, substring / path API needs more thought as it would be very useful to split on multiple known separators. Currently it's closer to ~10% (tested on cloudbuild and orchard core repos).\r\n\r\nBasic powershell command to count the diff:\r\n```powershell\r\nls -r *AssemblyReference.cache | select -ExpandProperty Length | Measure-Object -Sum | foreach {$_.Sum / 100000}\r\n```",
  "state": "MERGED",
  "createdAt": "2025-03-27T14:50:12Z",
  "updatedAt": "2025-05-06T08:48:40Z",
  "closedAt": "2025-05-06T08:48:38Z",
  "mergedAt": "2025-05-06T08:48:38Z",
  "additions": 1151,
  "deletions": 1,
  "changedFiles": 8,
  "headRefName": "dev/chcasta/prop-intern",
  "isDraft": false,
  "author": {
    "login": "ccastanedaucf"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "maridematte"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "772d2cd20996a40f3d2d6bbe228eec15a5eb87a3",
          "message": "Support string interning / deduplication within packets",
          "committedDate": "2025-04-10T18:05:07Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "79f3ccf5bf655f63fddb77ef605b385ae9d317bd",
          "message": "Test on RAR statefile cache",
          "committedDate": "2025-04-10T18:05:07Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a897651254dc40c1c8a4bd4f74bfe34f3b414e35",
          "message": "Undraft (tests, cleanup, documentation)",
          "committedDate": "2025-04-10T18:05:08Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aa1ebe20c024a613372b6143f12b242c8a588d7c",
          "message": "for rebase",
          "committedDate": "2025-04-10T18:05:34Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ce995b1f112721dd8e3cd8bd60e2be957ae3aed9",
          "message": "fix taskhost comp",
          "committedDate": "2025-04-10T18:24:28Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "671ff04d06b795ac23d89ccadd746b25e4043822",
          "message": "Revert #nullable change (broke compile in other files)",
          "committedDate": "2025-04-10T18:32:33Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0fdd426dac1f9e686b977f23ce721448c179b214",
          "message": "Use unix-like paths in UTs",
          "committedDate": "2025-04-10T18:54:10Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7e07ca0fb74e8457ac5e9ad4f4f9616e4917ff87",
          "message": "Fix path combine for unix tests",
          "committedDate": "2025-04-10T20:53:37Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bd256614d62cce8f8d37b95ed8e8252fde7c52c3",
          "message": "Nit: comment typos",
          "committedDate": "2025-04-10T21:35:57Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b19bf6e455b31b3b214383cf5c2cb10ee9b79092",
          "message": "Merge branch 'main' into dev/chcasta/prop-intern",
          "committedDate": "2025-04-15T16:04:25Z",
          "author": {
            "name": "Jan Provazn\u00edk",
            "email": "janprovaznik@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Kk the undraft commit has the diff since review, but the behavioral changes are:\r\n- Instead of passing `InterningWriteTranslator.Translator` to the caller via the delegate, just swap its binary writer for the scope of the delegate. Effectively does the same thing, but simplifies a lot of the setup and routing of calls since everything still goes through the original translator instance.\r\n- Merged the non-nullable optimization up into `ITranslator` as a flag to scale down the API.\r\n- Removed usage in RAR statefile - will do the real switch in a follow up.\r\n\r\nAnd then just chores:\r\n- Added a bunch of UTs at the `BinaryTranslator` level. Nothing at the implementation level (aka asserting on the stream contents), but this still validates that strings are deduped + wanted to ensure that the translator doesn't blow up from reuse or ordering edge cases.\r\n- Documented interning structure, signal flow, everything where ordering is important\r\n- Resolved active PR comments (no more `Console.WriteLine` \ud83d\ude05).",
        "createdAt": "2025-04-10T21:41:26Z",
        "author": {
          "login": "ccastanedaucf"
        }
      },
      {
        "body": "/perfstar",
        "createdAt": "2025-04-15T16:05:15Z",
        "author": {
          "login": "JanProvaznik"
        }
      },
      {
        "body": "Overall I like it. Just some weird questions that are mostly to satisfy my curiosity.\r\nLGTM",
        "createdAt": "2025-04-29T15:32:09Z",
        "author": {
          "login": "SimaTian"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "comment the 100 capacity please?",
              "createdAt": "2025-03-27T15:02:07Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -265,10 +265,13 @@ public override void Translate(ITranslator translator)\n                 throw new NullReferenceException(nameof(instanceLocalFileStateCache));\n             }\n \n-            translator.TranslateDictionary(\n-                ref (translator.Mode == TranslationDirection.WriteToStream) ? ref instanceLocalOutgoingFileStateCache : ref instanceLocalFileStateCache,\n-                StringComparer.OrdinalIgnoreCase,\n-                (ITranslator t) => new FileState(t));\n+            translator.WithInterning(StringComparer.Ordinal, 100, translator =>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\\*cough*",
              "createdAt": "2025-03-27T20:14:50Z",
              "path": "src/Framework/InterningReadTranslator.cs",
              "diffHunk": "@@ -0,0 +1,94 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class InterningReadTranslator : ITranslatable\n+    {\n+        private List<string> _strings = [];\n+\n+        private Dictionary<PathIds, string> _pathIdsToString = [];\n+\n+        private readonly ITranslator _translator;\n+\n+        internal InterningReadTranslator(ITranslator translator)\n+        {\n+            _translator = translator;\n+        }\n+\n+        internal string? ReadNullable()\n+        {\n+            if (!_translator.TranslateNullable(string.Empty))\n+            {\n+                return null;\n+            }\n+\n+            return Read();\n+        }\n+\n+        internal string Read()\n+        {\n+            int key = -1;\n+            _translator.Translate(ref key);\n+            return _strings[key];\n+        }\n+\n+        internal string? ReadNullablePath()\n+        {\n+            if (!_translator.TranslateNullable(string.Empty))\n+            {\n+                return null;\n+            }\n+\n+            return ReadPath();\n+        }\n+\n+        internal string ReadPath()\n+        {\n+            if (!_translator.TranslateNullable(string.Empty))\n+            {\n+                return Read();\n+            }\n+\n+            int directoryKey = -1;\n+            int fileNameKey = -1;\n+            _translator.Translate(ref directoryKey);\n+            _translator.Translate(ref fileNameKey);\n+\n+            PathIds pathIds = new(directoryKey, fileNameKey);\n+\n+            if (_pathIdsToString.TryGetValue(pathIds, out string? path))\n+            {\n+                return path;\n+            }\n+\n+            string directory = _strings[pathIds.DirectoryId];\n+            string fileName = _strings[pathIds.FileNameId];\n+            string str = string.Concat(directory, fileName);\n+            _pathIdsToString.Add(pathIds, str);\n+\n+            return str;\n+        }\n+\n+        public void Translate(ITranslator translator)\n+        {\n+            _translator.Translate(ref _strings);\n+            foreach (string str in _strings)\n+            {\n+                Console.WriteLine(str);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "HA yeah accidentally left this in while looking at statefile strings \ud83d\ude05",
              "createdAt": "2025-03-27T22:01:16Z",
              "path": "src/Framework/InterningReadTranslator.cs",
              "diffHunk": "@@ -0,0 +1,94 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class InterningReadTranslator : ITranslatable\n+    {\n+        private List<string> _strings = [];\n+\n+        private Dictionary<PathIds, string> _pathIdsToString = [];\n+\n+        private readonly ITranslator _translator;\n+\n+        internal InterningReadTranslator(ITranslator translator)\n+        {\n+            _translator = translator;\n+        }\n+\n+        internal string? ReadNullable()\n+        {\n+            if (!_translator.TranslateNullable(string.Empty))\n+            {\n+                return null;\n+            }\n+\n+            return Read();\n+        }\n+\n+        internal string Read()\n+        {\n+            int key = -1;\n+            _translator.Translate(ref key);\n+            return _strings[key];\n+        }\n+\n+        internal string? ReadNullablePath()\n+        {\n+            if (!_translator.TranslateNullable(string.Empty))\n+            {\n+                return null;\n+            }\n+\n+            return ReadPath();\n+        }\n+\n+        internal string ReadPath()\n+        {\n+            if (!_translator.TranslateNullable(string.Empty))\n+            {\n+                return Read();\n+            }\n+\n+            int directoryKey = -1;\n+            int fileNameKey = -1;\n+            _translator.Translate(ref directoryKey);\n+            _translator.Translate(ref fileNameKey);\n+\n+            PathIds pathIds = new(directoryKey, fileNameKey);\n+\n+            if (_pathIdsToString.TryGetValue(pathIds, out string? path))\n+            {\n+                return path;\n+            }\n+\n+            string directory = _strings[pathIds.DirectoryId];\n+            string fileName = _strings[pathIds.FileNameId];\n+            string str = string.Concat(directory, fileName);\n+            _pathIdsToString.Add(pathIds, str);\n+\n+            return str;\n+        }\n+\n+        public void Translate(ITranslator translator)\n+        {\n+            _translator.Translate(ref _strings);\n+            foreach (string str in _strings)\n+            {\n+                Console.WriteLine(str);",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "?",
              "createdAt": "2025-03-27T20:16:39Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -51,6 +51,12 @@ internal static ITranslator GetWriteTranslator(Stream stream)\n             return new BinaryWriteTranslator(stream);\n         }\n \n+        // TODO: Avoid expsoing write translator?",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "comment the multipliers please",
              "createdAt": "2025-03-27T20:19:10Z",
              "path": "src/Framework/InterningWriteTranslator.cs",
              "diffHunk": "@@ -0,0 +1,131 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class InterningWriteTranslator : ITranslatable\n+    {\n+        private List<string> _strings = [];\n+\n+        private Dictionary<string, int> _stringToIds = [];\n+\n+        private Dictionary<string, PathIds> _stringToPathIds = [];\n+\n+        private MemoryStream _packetStream = new();\n+\n+#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+        // Recursive loop\n+        internal ITranslator Translator { get; private set; }\n+#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+\n+        internal void InitCapacity(IEqualityComparer<string> comparer, int count)\n+        {\n+            if (Translator == null)\n+            {\n+                Translator = BinaryTranslator.GetWriteTranslator(_packetStream, this);\n+            }\n+\n+            int capacity = count * 8;\n+            int bufferCapacity = capacity * 128;\n+            _stringToIds = new Dictionary<string, int>(count * 8, comparer);\n+            _stringToPathIds = new Dictionary<string, PathIds>(count * 8, comparer);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I guess this is fine because being wrong is only a perf cost not a correctness concern? But feels like this should be a `LastIndexOfAny`.",
              "createdAt": "2025-03-27T20:25:41Z",
              "path": "src/Framework/InterningWriteTranslator.cs",
              "diffHunk": "@@ -0,0 +1,131 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class InterningWriteTranslator : ITranslatable\n+    {\n+        private List<string> _strings = [];\n+\n+        private Dictionary<string, int> _stringToIds = [];\n+\n+        private Dictionary<string, PathIds> _stringToPathIds = [];\n+\n+        private MemoryStream _packetStream = new();\n+\n+#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+        // Recursive loop\n+        internal ITranslator Translator { get; private set; }\n+#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+\n+        internal void InitCapacity(IEqualityComparer<string> comparer, int count)\n+        {\n+            if (Translator == null)\n+            {\n+                Translator = BinaryTranslator.GetWriteTranslator(_packetStream, this);\n+            }\n+\n+            int capacity = count * 8;\n+            int bufferCapacity = capacity * 128;\n+            _stringToIds = new Dictionary<string, int>(count * 8, comparer);\n+            _stringToPathIds = new Dictionary<string, PathIds>(count * 8, comparer);\n+            _strings.Clear();\n+            _strings.Capacity = capacity;\n+            _packetStream.Position = 0;\n+            _packetStream.SetLength(0);\n+            _packetStream.Capacity = bufferCapacity;\n+        }\n+\n+        internal void Intern(string str) => InternString(str);\n+\n+        internal void InternNullable(string str)\n+        {\n+            if (!Translator.TranslateNullable(str))\n+            {\n+                return;\n+            }\n+\n+            InternString(str);\n+        }\n+\n+        private int InternString(string str)\n+        {\n+            if (!_stringToIds.TryGetValue(str, out int index))\n+            {\n+                index = _strings.Count;\n+                _stringToIds.Add(str, index);\n+                _strings.Add(str);\n+            }\n+\n+            Translator.Translate(ref index);\n+            return index;\n+        }\n+\n+        internal void InternNullablePath(string str)\n+        {\n+            if (!Translator.TranslateNullable(str))\n+            {\n+                return;\n+            }\n+\n+            InternPath(str);\n+        }\n+\n+        internal void InternPath(string str)\n+        {\n+            if (_stringToPathIds.TryGetValue(str, out PathIds pathIds))\n+            {\n+                _ = Translator.TranslateNullable(string.Empty);\n+                int directoryId = pathIds.DirectoryId;\n+                int fileNameId = pathIds.FileNameId;\n+                Translator.Translate(ref directoryId);\n+                Translator.Translate(ref fileNameId);\n+                return;\n+            }\n+\n+            int splitId = str.LastIndexOf(Path.DirectorySeparatorChar);\n+\n+            if (splitId == -1)\n+            {\n+                splitId = str.LastIndexOf(Path.AltDirectorySeparatorChar);\n+            }",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "can you do this with spans and avoid the string allocs?",
              "createdAt": "2025-03-27T20:27:05Z",
              "path": "src/Framework/InterningWriteTranslator.cs",
              "diffHunk": "@@ -0,0 +1,131 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class InterningWriteTranslator : ITranslatable\n+    {\n+        private List<string> _strings = [];\n+\n+        private Dictionary<string, int> _stringToIds = [];\n+\n+        private Dictionary<string, PathIds> _stringToPathIds = [];\n+\n+        private MemoryStream _packetStream = new();\n+\n+#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+        // Recursive loop\n+        internal ITranslator Translator { get; private set; }\n+#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+\n+        internal void InitCapacity(IEqualityComparer<string> comparer, int count)\n+        {\n+            if (Translator == null)\n+            {\n+                Translator = BinaryTranslator.GetWriteTranslator(_packetStream, this);\n+            }\n+\n+            int capacity = count * 8;\n+            int bufferCapacity = capacity * 128;\n+            _stringToIds = new Dictionary<string, int>(count * 8, comparer);\n+            _stringToPathIds = new Dictionary<string, PathIds>(count * 8, comparer);\n+            _strings.Clear();\n+            _strings.Capacity = capacity;\n+            _packetStream.Position = 0;\n+            _packetStream.SetLength(0);\n+            _packetStream.Capacity = bufferCapacity;\n+        }\n+\n+        internal void Intern(string str) => InternString(str);\n+\n+        internal void InternNullable(string str)\n+        {\n+            if (!Translator.TranslateNullable(str))\n+            {\n+                return;\n+            }\n+\n+            InternString(str);\n+        }\n+\n+        private int InternString(string str)\n+        {\n+            if (!_stringToIds.TryGetValue(str, out int index))\n+            {\n+                index = _strings.Count;\n+                _stringToIds.Add(str, index);\n+                _strings.Add(str);\n+            }\n+\n+            Translator.Translate(ref index);\n+            return index;\n+        }\n+\n+        internal void InternNullablePath(string str)\n+        {\n+            if (!Translator.TranslateNullable(str))\n+            {\n+                return;\n+            }\n+\n+            InternPath(str);\n+        }\n+\n+        internal void InternPath(string str)\n+        {\n+            if (_stringToPathIds.TryGetValue(str, out PathIds pathIds))\n+            {\n+                _ = Translator.TranslateNullable(string.Empty);\n+                int directoryId = pathIds.DirectoryId;\n+                int fileNameId = pathIds.FileNameId;\n+                Translator.Translate(ref directoryId);\n+                Translator.Translate(ref fileNameId);\n+                return;\n+            }\n+\n+            int splitId = str.LastIndexOf(Path.DirectorySeparatorChar);\n+\n+            if (splitId == -1)\n+            {\n+                splitId = str.LastIndexOf(Path.AltDirectorySeparatorChar);\n+            }\n+\n+            bool hasDirectorySeparator = splitId > -1\n+                && splitId < str.Length - 1\n+                && str.IndexOf('%') == -1;\n+\n+            if (!hasDirectorySeparator)\n+            {\n+                string? dummy = null;\n+                _ = Translator.TranslateNullable(dummy);\n+                _ = InternString(str);\n+                return;\n+            }\n+\n+            // If we've seen a string already and know it's pathlike, we just need the index duo\n+            string directory = str.Substring(0, splitId + 1);\n+            string fileName = str.Substring(splitId + 1);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It would still end up allocating once it needs to be written to the translator + spans can't be used for dictionary keys. It should be doable in latest .NET with the `AlternateLookup` API, but the translator would still need to support writing spans - so not in this PR.",
              "createdAt": "2025-04-10T18:04:34Z",
              "path": "src/Framework/InterningWriteTranslator.cs",
              "diffHunk": "@@ -0,0 +1,131 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class InterningWriteTranslator : ITranslatable\n+    {\n+        private List<string> _strings = [];\n+\n+        private Dictionary<string, int> _stringToIds = [];\n+\n+        private Dictionary<string, PathIds> _stringToPathIds = [];\n+\n+        private MemoryStream _packetStream = new();\n+\n+#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+        // Recursive loop\n+        internal ITranslator Translator { get; private set; }\n+#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+\n+        internal void InitCapacity(IEqualityComparer<string> comparer, int count)\n+        {\n+            if (Translator == null)\n+            {\n+                Translator = BinaryTranslator.GetWriteTranslator(_packetStream, this);\n+            }\n+\n+            int capacity = count * 8;\n+            int bufferCapacity = capacity * 128;\n+            _stringToIds = new Dictionary<string, int>(count * 8, comparer);\n+            _stringToPathIds = new Dictionary<string, PathIds>(count * 8, comparer);\n+            _strings.Clear();\n+            _strings.Capacity = capacity;\n+            _packetStream.Position = 0;\n+            _packetStream.SetLength(0);\n+            _packetStream.Capacity = bufferCapacity;\n+        }\n+\n+        internal void Intern(string str) => InternString(str);\n+\n+        internal void InternNullable(string str)\n+        {\n+            if (!Translator.TranslateNullable(str))\n+            {\n+                return;\n+            }\n+\n+            InternString(str);\n+        }\n+\n+        private int InternString(string str)\n+        {\n+            if (!_stringToIds.TryGetValue(str, out int index))\n+            {\n+                index = _strings.Count;\n+                _stringToIds.Add(str, index);\n+                _strings.Add(str);\n+            }\n+\n+            Translator.Translate(ref index);\n+            return index;\n+        }\n+\n+        internal void InternNullablePath(string str)\n+        {\n+            if (!Translator.TranslateNullable(str))\n+            {\n+                return;\n+            }\n+\n+            InternPath(str);\n+        }\n+\n+        internal void InternPath(string str)\n+        {\n+            if (_stringToPathIds.TryGetValue(str, out PathIds pathIds))\n+            {\n+                _ = Translator.TranslateNullable(string.Empty);\n+                int directoryId = pathIds.DirectoryId;\n+                int fileNameId = pathIds.FileNameId;\n+                Translator.Translate(ref directoryId);\n+                Translator.Translate(ref fileNameId);\n+                return;\n+            }\n+\n+            int splitId = str.LastIndexOf(Path.DirectorySeparatorChar);\n+\n+            if (splitId == -1)\n+            {\n+                splitId = str.LastIndexOf(Path.AltDirectorySeparatorChar);\n+            }\n+\n+            bool hasDirectorySeparator = splitId > -1\n+                && splitId < str.Length - 1\n+                && str.IndexOf('%') == -1;\n+\n+            if (!hasDirectorySeparator)\n+            {\n+                string? dummy = null;\n+                _ = Translator.TranslateNullable(dummy);\n+                _ = InternString(str);\n+                return;\n+            }\n+\n+            // If we've seen a string already and know it's pathlike, we just need the index duo\n+            string directory = str.Substring(0, splitId + 1);\n+            string fileName = str.Substring(splitId + 1);",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this need to be duplicated in read and write?",
              "createdAt": "2025-03-27T20:28:55Z",
              "path": "src/Framework/InterningWriteTranslator.cs",
              "diffHunk": "@@ -0,0 +1,131 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class InterningWriteTranslator : ITranslatable\n+    {\n+        private List<string> _strings = [];\n+\n+        private Dictionary<string, int> _stringToIds = [];\n+\n+        private Dictionary<string, PathIds> _stringToPathIds = [];\n+\n+        private MemoryStream _packetStream = new();\n+\n+#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+        // Recursive loop\n+        internal ITranslator Translator { get; private set; }\n+#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+\n+        internal void InitCapacity(IEqualityComparer<string> comparer, int count)\n+        {\n+            if (Translator == null)\n+            {\n+                Translator = BinaryTranslator.GetWriteTranslator(_packetStream, this);\n+            }\n+\n+            int capacity = count * 8;\n+            int bufferCapacity = capacity * 128;\n+            _stringToIds = new Dictionary<string, int>(count * 8, comparer);\n+            _stringToPathIds = new Dictionary<string, PathIds>(count * 8, comparer);\n+            _strings.Clear();\n+            _strings.Capacity = capacity;\n+            _packetStream.Position = 0;\n+            _packetStream.SetLength(0);\n+            _packetStream.Capacity = bufferCapacity;\n+        }\n+\n+        internal void Intern(string str) => InternString(str);\n+\n+        internal void InternNullable(string str)\n+        {\n+            if (!Translator.TranslateNullable(str))\n+            {\n+                return;\n+            }\n+\n+            InternString(str);\n+        }\n+\n+        private int InternString(string str)\n+        {\n+            if (!_stringToIds.TryGetValue(str, out int index))\n+            {\n+                index = _strings.Count;\n+                _stringToIds.Add(str, index);\n+                _strings.Add(str);\n+            }\n+\n+            Translator.Translate(ref index);\n+            return index;\n+        }\n+\n+        internal void InternNullablePath(string str)\n+        {\n+            if (!Translator.TranslateNullable(str))\n+            {\n+                return;\n+            }\n+\n+            InternPath(str);\n+        }\n+\n+        internal void InternPath(string str)\n+        {\n+            if (_stringToPathIds.TryGetValue(str, out PathIds pathIds))\n+            {\n+                _ = Translator.TranslateNullable(string.Empty);\n+                int directoryId = pathIds.DirectoryId;\n+                int fileNameId = pathIds.FileNameId;\n+                Translator.Translate(ref directoryId);\n+                Translator.Translate(ref fileNameId);\n+                return;\n+            }\n+\n+            int splitId = str.LastIndexOf(Path.DirectorySeparatorChar);\n+\n+            if (splitId == -1)\n+            {\n+                splitId = str.LastIndexOf(Path.AltDirectorySeparatorChar);\n+            }\n+\n+            bool hasDirectorySeparator = splitId > -1\n+                && splitId < str.Length - 1\n+                && str.IndexOf('%') == -1;\n+\n+            if (!hasDirectorySeparator)\n+            {\n+                string? dummy = null;\n+                _ = Translator.TranslateNullable(dummy);\n+                _ = InternString(str);\n+                return;\n+            }\n+\n+            // If we've seen a string already and know it's pathlike, we just need the index duo\n+            string directory = str.Substring(0, splitId + 1);\n+            string fileName = str.Substring(splitId + 1);\n+\n+            _ = Translator.TranslateNullable(string.Empty);\n+            int directoryIndex = InternString(directory);\n+            int fileNameIndex = InternString(fileName);\n+\n+            _stringToPathIds.Add(str, new PathIds(directoryIndex, fileNameIndex));\n+        }\n+\n+        public void Translate(ITranslator translator)\n+        {\n+            translator.Translate(ref _strings);\n+            byte[] buffer = _packetStream.GetBuffer();\n+            int bufferSize = (int)_packetStream.Length;\n+            translator.Writer.Write(buffer, 0, bufferSize);\n+        }\n+\n+        private readonly record struct PathIds(int DirectoryId, int FileNameId);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yeah I can extract this out, it's the same data structure",
              "createdAt": "2025-03-27T22:03:56Z",
              "path": "src/Framework/InterningWriteTranslator.cs",
              "diffHunk": "@@ -0,0 +1,131 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class InterningWriteTranslator : ITranslatable\n+    {\n+        private List<string> _strings = [];\n+\n+        private Dictionary<string, int> _stringToIds = [];\n+\n+        private Dictionary<string, PathIds> _stringToPathIds = [];\n+\n+        private MemoryStream _packetStream = new();\n+\n+#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+        // Recursive loop\n+        internal ITranslator Translator { get; private set; }\n+#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.\n+\n+        internal void InitCapacity(IEqualityComparer<string> comparer, int count)\n+        {\n+            if (Translator == null)\n+            {\n+                Translator = BinaryTranslator.GetWriteTranslator(_packetStream, this);\n+            }\n+\n+            int capacity = count * 8;\n+            int bufferCapacity = capacity * 128;\n+            _stringToIds = new Dictionary<string, int>(count * 8, comparer);\n+            _stringToPathIds = new Dictionary<string, PathIds>(count * 8, comparer);\n+            _strings.Clear();\n+            _strings.Capacity = capacity;\n+            _packetStream.Position = 0;\n+            _packetStream.SetLength(0);\n+            _packetStream.Capacity = bufferCapacity;\n+        }\n+\n+        internal void Intern(string str) => InternString(str);\n+\n+        internal void InternNullable(string str)\n+        {\n+            if (!Translator.TranslateNullable(str))\n+            {\n+                return;\n+            }\n+\n+            InternString(str);\n+        }\n+\n+        private int InternString(string str)\n+        {\n+            if (!_stringToIds.TryGetValue(str, out int index))\n+            {\n+                index = _strings.Count;\n+                _stringToIds.Add(str, index);\n+                _strings.Add(str);\n+            }\n+\n+            Translator.Translate(ref index);\n+            return index;\n+        }\n+\n+        internal void InternNullablePath(string str)\n+        {\n+            if (!Translator.TranslateNullable(str))\n+            {\n+                return;\n+            }\n+\n+            InternPath(str);\n+        }\n+\n+        internal void InternPath(string str)\n+        {\n+            if (_stringToPathIds.TryGetValue(str, out PathIds pathIds))\n+            {\n+                _ = Translator.TranslateNullable(string.Empty);\n+                int directoryId = pathIds.DirectoryId;\n+                int fileNameId = pathIds.FileNameId;\n+                Translator.Translate(ref directoryId);\n+                Translator.Translate(ref fileNameId);\n+                return;\n+            }\n+\n+            int splitId = str.LastIndexOf(Path.DirectorySeparatorChar);\n+\n+            if (splitId == -1)\n+            {\n+                splitId = str.LastIndexOf(Path.AltDirectorySeparatorChar);\n+            }\n+\n+            bool hasDirectorySeparator = splitId > -1\n+                && splitId < str.Length - 1\n+                && str.IndexOf('%') == -1;\n+\n+            if (!hasDirectorySeparator)\n+            {\n+                string? dummy = null;\n+                _ = Translator.TranslateNullable(dummy);\n+                _ = InternString(str);\n+                return;\n+            }\n+\n+            // If we've seen a string already and know it's pathlike, we just need the index duo\n+            string directory = str.Substring(0, splitId + 1);\n+            string fileName = str.Substring(splitId + 1);\n+\n+            _ = Translator.TranslateNullable(string.Empty);\n+            int directoryIndex = InternString(directory);\n+            int fileNameIndex = InternString(fileName);\n+\n+            _stringToPathIds.Add(str, new PathIds(directoryIndex, fileNameIndex));\n+        }\n+\n+        public void Translate(ITranslator translator)\n+        {\n+            translator.Translate(ref _strings);\n+            byte[] buffer = _packetStream.GetBuffer();\n+            int bufferSize = (int)_packetStream.Length;\n+            translator.Writer.Write(buffer, 0, bufferSize);\n+        }\n+\n+        private readonly record struct PathIds(int DirectoryId, int FileNameId);",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You mentioned that the ITranslateble implementation will be potentially able to select which strings to intern and which not. I don't see any such heuristic here (or if there is please point me to the relevant section, my brain is rebooting after my absence).\r\n\r\nFor example,\r\nWould it be reasonable to for example not bother with interning short strings - like <5 characters?\r\nI know that we're using some 7bit encoded strings so the id will probably still be shorter, but then there is the cost of hashing etc.\r\n\r\n\r\n",
              "createdAt": "2025-04-29T15:10:42Z",
              "path": "src/Framework/InterningWriteTranslator.cs",
              "diffHunk": "@@ -0,0 +1,173 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// Writes strings into a translator with interning / deduplication.\n+    /// </summary>\n+    /// <remarks>\n+    /// This maintains a reusable temporary buffer and lookup table for deduplicating strings within a translatable packet.\n+    /// All unique strings (as determined by the comparer) will be assigned an incrementing ID and stored into a dictionary.\n+    /// This ID will be written to a private buffer in place of the string and any repeat occurrences.\n+    /// When serialized into another translator, the interner will:\n+    /// 1. Serialize the list of unique strings to an array, where the ID is the index.\n+    /// 2. Serialize the temporary buffer (aka the packet body) with all interned strings replaced by their ID.\n+    /// This ordering is important since the reader will need the string lookup table before parsing the body.\n+    /// As such, two rules need to be followed when using this class:\n+    /// 1. Any interleaved non-interned writes should be written using the exposed BinaryWriter to keep the overall\n+    /// packet in sync.\n+    /// 2. Translate should *only* be called after all internable writes have been processed.\n+    /// </remarks>\n+    internal sealed class InterningWriteTranslator : ITranslatable\n+    {\n+        private static readonly char[] DirectorySeparatorChars = [Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar];\n+\n+        private static readonly string IsPathMarker = string.Empty;\n+\n+        private static readonly string? NotPathMarker = null;\n+\n+        private readonly ITranslator _translator;\n+\n+        private readonly MemoryStream _packetStream;\n+\n+        private List<string> _strings = [];\n+\n+        private Dictionary<string, int> _stringToIds = [];\n+\n+        private Dictionary<string, InternPathIds> _stringToPathIds = [];\n+\n+        internal InterningWriteTranslator()\n+        {\n+            _packetStream = new MemoryStream();\n+            _translator = BinaryTranslator.GetWriteTranslator(_packetStream);\n+\n+            // Avoid directly exposing the buffered translator - any accidental Intern_xx method calls could go into a\n+            // recursive loop.\n+            Writer = _translator.Writer;\n+        }\n+\n+        /// <summary>\n+        /// The writer for the underlying buffer.\n+        /// Use to forward any non-interning writes into this translator.\n+        /// </summary>\n+        internal BinaryWriter Writer { get; }\n+\n+        /// <summary>\n+        /// Setup the intern cache and underlying buffer. This allows the interner to be reused.\n+        /// </summary>\n+        /// <param name=\"comparer\">The string comparer to use for string deduplication.</param>\n+        /// <param name=\"initialCapacity\">An estimate of the number of unique strings to be interned.</param>\n+        internal void Setup(IEqualityComparer<string> comparer, int initialCapacity)\n+        {\n+#if NET\n+            if (_stringToIds.Comparer == comparer)\n+            {\n+                // Clear before setting capacity, since dictionaries will rehash every entry.\n+                _strings.Clear();\n+                _stringToIds.Clear();\n+                _stringToPathIds.Clear();\n+                _strings.EnsureCapacity(initialCapacity);\n+                _stringToIds.EnsureCapacity(initialCapacity);\n+                _stringToPathIds.EnsureCapacity(initialCapacity);\n+            }\n+            else\n+            {\n+#endif\n+                // If the interner is in a reused translator, the comparer might not match between packets.\n+                // Just throw away the old collections in this case.\n+                _strings.Clear();\n+                _strings.Capacity = initialCapacity;\n+                _stringToIds = new Dictionary<string, int>(initialCapacity, comparer);\n+                _stringToPathIds = new Dictionary<string, InternPathIds>(initialCapacity, comparer);\n+#if NET\n+            }\n+#endif\n+            _packetStream.Position = 0;\n+            _packetStream.SetLength(0);\n+\n+            // This is a rough estimate since the final size will depend on the length of each string and the total number\n+            // of intern cache hits. Assume a mixture of short strings (e.g. item metadata pairs, RAR assembly metadata)\n+            // and file paths (e.g. item include paths, RAR statefile entries).\n+            const int CharactersPerString = 32;\n+            const int BytesPerCharacter = 2;\n+            const int BytesPerInternedString = 5;\n+            int internHeaderSize = initialCapacity * CharactersPerString * BytesPerCharacter;\n+            int packetPayloadSize = initialCapacity * BytesPerInternedString;\n+            _packetStream.Capacity = internHeaderSize + packetPayloadSize;\n+        }\n+\n+        internal void Intern(string str) => _ = InternString(str);\n+\n+        private int InternString(string str)",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "More accurately, I meant selectively select which **fields** to intern, not specific strings. So yes, that isn't implemented here.\r\n\r\nI actually did run into the ID size hitting a threshold when optimizing more to split on granular delimiters (which is why this only splits on the final slash). Fixed-overhead of 4/5 bytes (null marker + int32) means 3 chars is usually the point where things cancel out.\r\n\r\nIf `ITranslator` either defaulted to varint, or supported it via another method, it would solve this though. Total intern count should generally fit in 2-bytes max, with the most common IDs being placed in the first byte's 7-bit range (since they would generally be encountered first) - so we'd mostly have 1-byte IDs.\r\n\r\n`BinaryWriter.Write7BitEncodedInt(value)` + `BinaryReader.Read7BitEncodedInt()` already have an implementation for varint encoding since it's also used for strings, so it's easy to just piggy-back off the same code. On .NET Core this is already exposed, on .NET framework you just make a dummy subclass since it's `protected`. E.g.:\r\n\r\n```cs\r\nprivate class TranslatorBinaryWriter : BinaryWriter\r\n{\r\n    void Write(int value) => Write7BitEncodedInt(value)\r\n}\r\n```\r\n\r\nMain con I could see against defaulting this inside `ITranslator.Translate(ref int val)` is that negative values or consts like `int.MaxValue` now get encoded to 5-bytes, since the MSB gets used as the next-byte mark. And I guess the version rev. So maybe this could be in an extra method, although I assume that's the uncommon case + it would be nice for every serialized collection to compress their count marker.\r\n\r\nI already wrote a follow up branch testing varints a couple weeks ago, and IIRC it cut another 40% of the size -, assuming due to small strings that were cancelling out before. But without that yet, yeah I think it's a good idea to just set a lower bound.\r\n",
              "createdAt": "2025-04-30T03:16:33Z",
              "path": "src/Framework/InterningWriteTranslator.cs",
              "diffHunk": "@@ -0,0 +1,173 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// Writes strings into a translator with interning / deduplication.\n+    /// </summary>\n+    /// <remarks>\n+    /// This maintains a reusable temporary buffer and lookup table for deduplicating strings within a translatable packet.\n+    /// All unique strings (as determined by the comparer) will be assigned an incrementing ID and stored into a dictionary.\n+    /// This ID will be written to a private buffer in place of the string and any repeat occurrences.\n+    /// When serialized into another translator, the interner will:\n+    /// 1. Serialize the list of unique strings to an array, where the ID is the index.\n+    /// 2. Serialize the temporary buffer (aka the packet body) with all interned strings replaced by their ID.\n+    /// This ordering is important since the reader will need the string lookup table before parsing the body.\n+    /// As such, two rules need to be followed when using this class:\n+    /// 1. Any interleaved non-interned writes should be written using the exposed BinaryWriter to keep the overall\n+    /// packet in sync.\n+    /// 2. Translate should *only* be called after all internable writes have been processed.\n+    /// </remarks>\n+    internal sealed class InterningWriteTranslator : ITranslatable\n+    {\n+        private static readonly char[] DirectorySeparatorChars = [Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar];\n+\n+        private static readonly string IsPathMarker = string.Empty;\n+\n+        private static readonly string? NotPathMarker = null;\n+\n+        private readonly ITranslator _translator;\n+\n+        private readonly MemoryStream _packetStream;\n+\n+        private List<string> _strings = [];\n+\n+        private Dictionary<string, int> _stringToIds = [];\n+\n+        private Dictionary<string, InternPathIds> _stringToPathIds = [];\n+\n+        internal InterningWriteTranslator()\n+        {\n+            _packetStream = new MemoryStream();\n+            _translator = BinaryTranslator.GetWriteTranslator(_packetStream);\n+\n+            // Avoid directly exposing the buffered translator - any accidental Intern_xx method calls could go into a\n+            // recursive loop.\n+            Writer = _translator.Writer;\n+        }\n+\n+        /// <summary>\n+        /// The writer for the underlying buffer.\n+        /// Use to forward any non-interning writes into this translator.\n+        /// </summary>\n+        internal BinaryWriter Writer { get; }\n+\n+        /// <summary>\n+        /// Setup the intern cache and underlying buffer. This allows the interner to be reused.\n+        /// </summary>\n+        /// <param name=\"comparer\">The string comparer to use for string deduplication.</param>\n+        /// <param name=\"initialCapacity\">An estimate of the number of unique strings to be interned.</param>\n+        internal void Setup(IEqualityComparer<string> comparer, int initialCapacity)\n+        {\n+#if NET\n+            if (_stringToIds.Comparer == comparer)\n+            {\n+                // Clear before setting capacity, since dictionaries will rehash every entry.\n+                _strings.Clear();\n+                _stringToIds.Clear();\n+                _stringToPathIds.Clear();\n+                _strings.EnsureCapacity(initialCapacity);\n+                _stringToIds.EnsureCapacity(initialCapacity);\n+                _stringToPathIds.EnsureCapacity(initialCapacity);\n+            }\n+            else\n+            {\n+#endif\n+                // If the interner is in a reused translator, the comparer might not match between packets.\n+                // Just throw away the old collections in this case.\n+                _strings.Clear();\n+                _strings.Capacity = initialCapacity;\n+                _stringToIds = new Dictionary<string, int>(initialCapacity, comparer);\n+                _stringToPathIds = new Dictionary<string, InternPathIds>(initialCapacity, comparer);\n+#if NET\n+            }\n+#endif\n+            _packetStream.Position = 0;\n+            _packetStream.SetLength(0);\n+\n+            // This is a rough estimate since the final size will depend on the length of each string and the total number\n+            // of intern cache hits. Assume a mixture of short strings (e.g. item metadata pairs, RAR assembly metadata)\n+            // and file paths (e.g. item include paths, RAR statefile entries).\n+            const int CharactersPerString = 32;\n+            const int BytesPerCharacter = 2;\n+            const int BytesPerInternedString = 5;\n+            int internHeaderSize = initialCapacity * CharactersPerString * BytesPerCharacter;\n+            int packetPayloadSize = initialCapacity * BytesPerInternedString;\n+            _packetStream.Capacity = internHeaderSize + packetPayloadSize;\n+        }\n+\n+        internal void Intern(string str) => _ = InternString(str);\n+\n+        private int InternString(string str)",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would it be worth it to eventually cache the interned strings to avoid re-sending the header with the strings?\r\n\r\nOr even hard-code a list of some most used strings? (Though this might be a bad idea overall due to maintenance issues)\r\nAges ago I've run some basic checks and found that some strings are used over and over again. \r\n\r\nFor example:\r\n\r\n| String | Count |\r\n|---------------------------------|-------|\r\n| PropertyPageSchema              | 14462 |\r\n| false                           | 15994 |\r\n| Alias                           | 19152 |\r\n| TargetFramework                 | 19272 |\r\n| DisplayName                     | 19284 |\r\n| PackageVersion                  | 23940 |\r\n| Version                         | 25102 |\r\n| _KnownRuntimeIdentiferPlatforms | 25536 |\r\n| MSBuild                         | 42493 |\r\n| true                            | 44196 |\r\n\r\n\r\nI also vaguely recall that the cost of hashing them to perform the actual deduplication was rather high. Do you have any performance numbers please? \r\nI believe completely the size reduction side of the equation - I'm interested in how it translates into actual performance improvement.",
              "createdAt": "2025-04-29T15:21:55Z",
              "path": "src/Framework/InterningReadTranslator.cs",
              "diffHunk": "@@ -0,0 +1,84 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// Reads strings form a translator which contains interned packets.\n+    /// </summary>\n+    /// <remarks>\n+    /// This maintains a reusable lookup table to deserialize packets interned by <see cref=\"InterningWriteTranslator\"/>.\n+    /// On Translate, the intern header (aka the array of strings indexed by ID) is deserialized.\n+    /// The caller can then forward reads to deserialize any interned values in the packet body.\n+    /// </remarks>\n+    internal sealed class InterningReadTranslator : ITranslatable\n+    {\n+        private readonly ITranslator _translator;\n+\n+        private List<string> _strings = [];\n+\n+        private Dictionary<InternPathIds, string> _pathIdsToString = [];",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "I'll run some new profiles, IIRC it was a significant perf difference for IPC, while not noticeable for RAR statefile. But my tests there were much smaller and wanted to test on something already checked-into the repo (and the size reduction is smaller in the statefile as well due to repeated strings existing in larger delimited strings). I do know the cost of deserializing strings shows up as the most expensive part of IPC overhead (will show traces).\r\n\r\nI thought about the common strings as well and already had a prototype (replacing the path split and using slices) with an API like:\r\n\r\n```cs\r\n// C:\\.nuget\\packages\\...\\Namespace.Assembly.dll\r\nInternComponents(\r\n    str,\r\n    substrings: [],\r\n    endDelimiters: ['\\\\', '/'],\r\n    suffixes: [\".dll\"],\r\n// Namespace.Assembly, Version=3.5.1.1, Culture=neutral, PublicKeyToken=31bf3856ad364e35\r\nInternComponents(\r\n    str,\r\n    substrings: [\", Version=\", \", Culture=\", \", PublicKeyToken=\"],\r\n    endDelimiters: ['\\\\', '/'],\r\n    suffixes: [],\r\n)\r\n```\r\n...where `substrings` are used as delimiters and written to the stream as an ID to the in-memory constant array, without actually having to writing the string itself into the payload. I think something similar *could* work for common strings, but would have to measure first. Definitely seems safer for IPC than disk serialization, since both ends of the pipe could even build on the set dynamically. It's something I noticed in RAR out-of-proc IPC as well though, every packet has a ton of metadata keys / vals that are common across every request.",
              "createdAt": "2025-04-30T03:42:05Z",
              "path": "src/Framework/InterningReadTranslator.cs",
              "diffHunk": "@@ -0,0 +1,84 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// Reads strings form a translator which contains interned packets.\n+    /// </summary>\n+    /// <remarks>\n+    /// This maintains a reusable lookup table to deserialize packets interned by <see cref=\"InterningWriteTranslator\"/>.\n+    /// On Translate, the intern header (aka the array of strings indexed by ID) is deserialized.\n+    /// The caller can then forward reads to deserialize any interned values in the packet body.\n+    /// </remarks>\n+    internal sealed class InterningReadTranslator : ITranslatable\n+    {\n+        private readonly ITranslator _translator;\n+\n+        private List<string> _strings = [];\n+\n+        private Dictionary<InternPathIds, string> _pathIdsToString = [];",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      }
    ]
  }
}