{
  "number": 8540,
  "title": "ProjectRootElementCache.Clear do not clear immutable files",
  "body": "### Context\r\nFor `msbuild -restore` scenarios `ProjectRootElementCache` cache used to be cleared for restore could have modified or added some project files (like *.directory.props etc...). \r\nWe can optimize it by keeping ProjectRootElements from immutable locations (like SDK) in that cache as those will be used by build following that restore.\r\n\r\n### Changes Made\r\n`Clear()` does not remove immutable files from cache.\r\n\r\n### Testing\r\nLocally\r\n",
  "state": "MERGED",
  "createdAt": "2023-03-07T14:31:35Z",
  "updatedAt": "2023-03-28T18:59:42Z",
  "closedAt": "2023-03-28T18:59:41Z",
  "mergedAt": "2023-03-28T18:59:41Z",
  "additions": 37,
  "deletions": 5,
  "changedFiles": 1,
  "headRefName": "rokonec/xml-cache-clear-keep-immutable",
  "isDraft": false,
  "author": {
    "login": "rokonec"
  },
  "milestone": {
    "title": "VS 17.6"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "85d6721997c5e7a7fc45cda3ce17680888b804f0",
          "message": "ProjectRootElementCache.Clear do not clear immutable files",
          "committedDate": "2023-03-07T12:24:09Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1bfbf86de4d9b7a3ef8fbcc97aa6327e39159e77",
          "message": "Fix unit test by cleaning unused weak references",
          "committedDate": "2023-03-07T22:30:50Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This walk feels expensive to me. What is causing things to be removed from the strong cache other than the for above, which is removing from both?",
              "createdAt": "2023-03-08T21:09:36Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -411,13 +412,44 @@ internal override void Clear()\n         {\n             lock (_locker)\n             {\n-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n-                _strongCache = new LinkedList<ProjectRootElement>();\n+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+                {\n+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n+                    _strongCache = new LinkedList<ProjectRootElement>();\n \n-                foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    {\n+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    }\n+                }\n+                else\n                 {\n-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    // Manually iterate through LinkedList so we can remove items during this iteration\n+                    for (var listNode = _strongCache.First; listNode != null;)\n+                    {\n+                        var nextNode = listNode.Next;\n+\n+                        ProjectRootElement projectRootElement = listNode.Value;\n+                        // Do not remove cache of files from immutable locations.\n+                        // Those are mostly SDK project files and will be most probably needed in next builds.\n+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))\n+                        {\n+                            _weakCache.Remove(projectRootElement.FullPath);\n+                            _strongCache.Remove(listNode);\n+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                        }\n+\n+                        listNode = nextNode;\n+                    }\n+\n+                    // From weak list remove all which is not in strong list anymore\n+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "The other example I'm aware of is that the strong cache has a maximum size and will remove stuff randomly if we try to go over that:\r\nhttps://github.com/dotnet/msbuild/blob/a0c282787d59ca9a449ded85175f39030e5077b8/src/Build/Evaluation/ProjectRootElementCache.cs#L570-L577",
              "createdAt": "2023-03-09T22:29:46Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -411,13 +412,44 @@ internal override void Clear()\n         {\n             lock (_locker)\n             {\n-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n-                _strongCache = new LinkedList<ProjectRootElement>();\n+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+                {\n+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n+                    _strongCache = new LinkedList<ProjectRootElement>();\n \n-                foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    {\n+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    }\n+                }\n+                else\n                 {\n-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    // Manually iterate through LinkedList so we can remove items during this iteration\n+                    for (var listNode = _strongCache.First; listNode != null;)\n+                    {\n+                        var nextNode = listNode.Next;\n+\n+                        ProjectRootElement projectRootElement = listNode.Value;\n+                        // Do not remove cache of files from immutable locations.\n+                        // Those are mostly SDK project files and will be most probably needed in next builds.\n+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))\n+                        {\n+                            _weakCache.Remove(projectRootElement.FullPath);\n+                            _strongCache.Remove(listNode);\n+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                        }\n+\n+                        listNode = nextNode;\n+                    }\n+\n+                    // From weak list remove all which is not in strong list anymore\n+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Maximum size is 200 by default, but you can set it smaller.",
              "createdAt": "2023-03-09T22:30:19Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -411,13 +412,44 @@ internal override void Clear()\n         {\n             lock (_locker)\n             {\n-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n-                _strongCache = new LinkedList<ProjectRootElement>();\n+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+                {\n+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n+                    _strongCache = new LinkedList<ProjectRootElement>();\n \n-                foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    {\n+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    }\n+                }\n+                else\n                 {\n-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    // Manually iterate through LinkedList so we can remove items during this iteration\n+                    for (var listNode = _strongCache.First; listNode != null;)\n+                    {\n+                        var nextNode = listNode.Next;\n+\n+                        ProjectRootElement projectRootElement = listNode.Value;\n+                        // Do not remove cache of files from immutable locations.\n+                        // Those are mostly SDK project files and will be most probably needed in next builds.\n+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))\n+                        {\n+                            _weakCache.Remove(projectRootElement.FullPath);\n+                            _strongCache.Remove(listNode);\n+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                        }\n+\n+                        listNode = nextNode;\n+                    }\n+\n+                    // From weak list remove all which is not in strong list anymore\n+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This may be a silly question, but where do we actually use the strong cache?",
              "createdAt": "2023-03-09T22:33:43Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -411,13 +412,44 @@ internal override void Clear()\n         {\n             lock (_locker)\n             {\n-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n-                _strongCache = new LinkedList<ProjectRootElement>();\n+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+                {\n+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n+                    _strongCache = new LinkedList<ProjectRootElement>();\n \n-                foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    {\n+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    }\n+                }\n+                else\n                 {\n-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    // Manually iterate through LinkedList so we can remove items during this iteration\n+                    for (var listNode = _strongCache.First; listNode != null;)\n+                    {\n+                        var nextNode = listNode.Next;\n+\n+                        ProjectRootElement projectRootElement = listNode.Value;\n+                        // Do not remove cache of files from immutable locations.\n+                        // Those are mostly SDK project files and will be most probably needed in next builds.\n+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))\n+                        {\n+                            _weakCache.Remove(projectRootElement.FullPath);\n+                            _strongCache.Remove(listNode);\n+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                        }\n+\n+                        listNode = nextNode;\n+                    }\n+\n+                    // From weak list remove all which is not in strong list anymore\n+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "We don't - GC does.  strong cache is there to hold strong reference to cache item so GC will not collect it. Where there is no active/strong reference GC will collect it at next Collect.\r\nDue to heavy allocation patterns in MSBuild it means that we have mostly only 200 XMLs cached. Which often is not enough. For example OrchardCore during build have 1500 distinct XMLs read - every project have couple `directory.proj` etc...",
              "createdAt": "2023-03-14T10:54:46Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -411,13 +412,44 @@ internal override void Clear()\n         {\n             lock (_locker)\n             {\n-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n-                _strongCache = new LinkedList<ProjectRootElement>();\n+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+                {\n+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n+                    _strongCache = new LinkedList<ProjectRootElement>();\n \n-                foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    {\n+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    }\n+                }\n+                else\n                 {\n-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    // Manually iterate through LinkedList so we can remove items during this iteration\n+                    for (var listNode = _strongCache.First; listNode != null;)\n+                    {\n+                        var nextNode = listNode.Next;\n+\n+                        ProjectRootElement projectRootElement = listNode.Value;\n+                        // Do not remove cache of files from immutable locations.\n+                        // Those are mostly SDK project files and will be most probably needed in next builds.\n+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))\n+                        {\n+                            _weakCache.Remove(projectRootElement.FullPath);\n+                            _strongCache.Remove(listNode);\n+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                        }\n+\n+                        listNode = nextNode;\n+                    }\n+\n+                    // From weak list remove all which is not in strong list anymore\n+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "@rainersigwald \r\n> This walk feels expensive to me.\r\n\r\nIt is not really expensive. It is called only once between -restore and build, have complexity O(N+M), where N and M are about 200.\r\n\r\n> What is causing things to be removed from the strong cache other than the for above, which is removing from both?\r\n\r\n`Project.UnloadProjects` calls `ProjectRootElementCache.DiscardStrongReferences()`\r\n\r\nWithout that weak cleaning a unit test was failing. I was trying to make most safe changes respecting comment  `Attempts to clear out the weak cache resulted in this guarantee being broken and subtle bugs popping up everywhere.` in `ProjectRootElementCache.DiscardStrongReferences()`.",
              "createdAt": "2023-03-14T12:37:24Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -411,13 +412,44 @@ internal override void Clear()\n         {\n             lock (_locker)\n             {\n-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n-                _strongCache = new LinkedList<ProjectRootElement>();\n+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+                {\n+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n+                    _strongCache = new LinkedList<ProjectRootElement>();\n \n-                foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    {\n+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    }\n+                }\n+                else\n                 {\n-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    // Manually iterate through LinkedList so we can remove items during this iteration\n+                    for (var listNode = _strongCache.First; listNode != null;)\n+                    {\n+                        var nextNode = listNode.Next;\n+\n+                        ProjectRootElement projectRootElement = listNode.Value;\n+                        // Do not remove cache of files from immutable locations.\n+                        // Those are mostly SDK project files and will be most probably needed in next builds.\n+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))\n+                        {\n+                            _weakCache.Remove(projectRootElement.FullPath);\n+                            _strongCache.Remove(listNode);\n+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                        }\n+\n+                        listNode = nextNode;\n+                    }\n+\n+                    // From weak list remove all which is not in strong list anymore\n+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "> GC does\r\n\r\nSo if we don't use it, we shouldn't really care about duplicates or structure, etc., right? I'm thinking two thoughts.\r\n\r\nOne is that arrays are much more space-efficient than LinkedLists; the only problem with arrays is that they're static, so we can't reallocate them over and over again cheaply to add one more element. Proposal: rather than a simple LinkedList, we could have a LinkedList of arrays. The last would be size 32; the second-to-last would be 64; the third-to-last would be 128; etc. When we want to add something, we go to the head, check if it's full, and if not, add to that. If so, add a new node in front of it, and put it there.\r\n\r\nSecond, we're putting a lot of effort into making it a semi-legit cache. I'd propose getting lazy and stripping out all the times we currently walk the list, just resetting it when we discard strong references and at the end of builds. In this case, we also wouldn't have a maximum size for the cache.\r\n\r\nWhat do you think? If you think it might help, I'd be happily to (experimentally) implement it so we can measure its performance. Either way, it isn't too relevant for this particular PR, so it can be a follow-up.",
              "createdAt": "2023-03-14T17:27:29Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -411,13 +412,44 @@ internal override void Clear()\n         {\n             lock (_locker)\n             {\n-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n-                _strongCache = new LinkedList<ProjectRootElement>();\n+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+                {\n+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n+                    _strongCache = new LinkedList<ProjectRootElement>();\n \n-                foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    {\n+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    }\n+                }\n+                else\n                 {\n-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    // Manually iterate through LinkedList so we can remove items during this iteration\n+                    for (var listNode = _strongCache.First; listNode != null;)\n+                    {\n+                        var nextNode = listNode.Next;\n+\n+                        ProjectRootElement projectRootElement = listNode.Value;\n+                        // Do not remove cache of files from immutable locations.\n+                        // Those are mostly SDK project files and will be most probably needed in next builds.\n+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))\n+                        {\n+                            _weakCache.Remove(projectRootElement.FullPath);\n+                            _strongCache.Remove(listNode);\n+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                        }\n+\n+                        listNode = nextNode;\n+                    }\n+\n+                    // From weak list remove all which is not in strong list anymore\n+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Our `ProjecRootElementCache` is LRU, Last Recently Used, cache. \r\nOut solution is text book of 'theoretical' correctness, the one expected on technical interviews, you can seek internet wisdom for best theoretical solutions.\r\nNow for practical correctness, because our cache max count is just 200, it could be solved many ways, as even O(n^3) would still be acceptable. Caching and especially its invalidations are common places of nasty concurrence bugs, and I am mostly trying to not touch it, unless the gain is significant. \r\nOur current LRN mechanism, weak/strong, is goof enough, actually too good with a baggage of unnecessary complexity, and I do not believe that optimizing data structures will bring any practical performance gain.\r\nHowever, it is good learning opportunity but for that I would recommend to isolate our logic and use `BenchmarkDotNet` tooling. If you are interesting I can give you crash course in it - it is very useful tool.\r\n\r\n",
              "createdAt": "2023-03-14T19:29:26Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -411,13 +412,44 @@ internal override void Clear()\n         {\n             lock (_locker)\n             {\n-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n-                _strongCache = new LinkedList<ProjectRootElement>();\n+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+                {\n+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n+                    _strongCache = new LinkedList<ProjectRootElement>();\n \n-                foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    {\n+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    }\n+                }\n+                else\n                 {\n-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    // Manually iterate through LinkedList so we can remove items during this iteration\n+                    for (var listNode = _strongCache.First; listNode != null;)\n+                    {\n+                        var nextNode = listNode.Next;\n+\n+                        ProjectRootElement projectRootElement = listNode.Value;\n+                        // Do not remove cache of files from immutable locations.\n+                        // Those are mostly SDK project files and will be most probably needed in next builds.\n+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))\n+                        {\n+                            _weakCache.Remove(projectRootElement.FullPath);\n+                            _strongCache.Remove(listNode);\n+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                        }\n+\n+                        listNode = nextNode;\n+                    }\n+\n+                    // From weak list remove all which is not in strong list anymore\n+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "> Out solution is text book of 'theoretical' correctness, the one expected on technical interviews, you can seek internet wisdom for best theoretical solutions.\r\n\r\n-ish? The proof that LRU caches are at worst 2x as expensive as the ideal cache comes with two assumptions: you're using a LinkedList, and you _access_ things in the cache; they aren't just cached to prevent GC.\r\n\r\nI'll build OrchardCore once, since that was the example you used earlier, with some extra traces to see what gets called when, then throw the results into BenchmarkDotNet and report results when I can.",
              "createdAt": "2023-03-14T19:44:17Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -411,13 +412,44 @@ internal override void Clear()\n         {\n             lock (_locker)\n             {\n-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n-                _strongCache = new LinkedList<ProjectRootElement>();\n+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+                {\n+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n+                    _strongCache = new LinkedList<ProjectRootElement>();\n \n-                foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    {\n+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    }\n+                }\n+                else\n                 {\n-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    // Manually iterate through LinkedList so we can remove items during this iteration\n+                    for (var listNode = _strongCache.First; listNode != null;)\n+                    {\n+                        var nextNode = listNode.Next;\n+\n+                        ProjectRootElement projectRootElement = listNode.Value;\n+                        // Do not remove cache of files from immutable locations.\n+                        // Those are mostly SDK project files and will be most probably needed in next builds.\n+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))\n+                        {\n+                            _weakCache.Remove(projectRootElement.FullPath);\n+                            _strongCache.Remove(listNode);\n+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                        }\n+\n+                        listNode = nextNode;\n+                    }\n+\n+                    // From weak list remove all which is not in strong list anymore\n+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I mocked the cache calls involved in a single (clean) OC build:\r\n|  Method |       Mean |     Error |    StdDev |   Gen 0 |  Gen 1 | Gen 2 | Allocated |\r\n|--------  |------------:|----------:|----------:|--------:|-------:|------:|----------:|\r\n| Current |  1,571.73 us | 31.399 us | 30.838 us | 76.1719 | 1.9531 |     - | 469.74 KB |\r\n|    Mine  |    55.32 us |  0.701 us |  0.585 us | 20.8130 | 6.8970 |     - | 128.74 KB |\r\n\r\nI'm happy showing you more precisely what exactly I did if you want to look at it together.\r\n\r\nAs far as I'm concerned, this is a massive improvement percentage-wise but not a massive improvement total time-wise, so maybe it's worth working on, since I don't think it would take _too_ long, but up to you \ud83d\ude42",
              "createdAt": "2023-03-14T22:17:18Z",
              "path": "src/Build/Evaluation/ProjectRootElementCache.cs",
              "diffHunk": "@@ -411,13 +412,44 @@ internal override void Clear()\n         {\n             lock (_locker)\n             {\n-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n-                _strongCache = new LinkedList<ProjectRootElement>();\n+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n+                {\n+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;\n+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);\n+                    _strongCache = new LinkedList<ProjectRootElement>();\n \n-                foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)\n+                    {\n+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    }\n+                }\n+                else\n                 {\n-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                    // Manually iterate through LinkedList so we can remove items during this iteration\n+                    for (var listNode = _strongCache.First; listNode != null;)\n+                    {\n+                        var nextNode = listNode.Next;\n+\n+                        ProjectRootElement projectRootElement = listNode.Value;\n+                        // Do not remove cache of files from immutable locations.\n+                        // Those are mostly SDK project files and will be most probably needed in next builds.\n+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))\n+                        {\n+                            _weakCache.Remove(projectRootElement.FullPath);\n+                            _strongCache.Remove(listNode);\n+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);\n+                        }\n+\n+                        listNode = nextNode;\n+                    }\n+\n+                    // From weak list remove all which is not in strong list anymore\n+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}