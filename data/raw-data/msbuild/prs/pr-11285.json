{
  "number": 11285,
  "title": "Add TargetFramework(s) unexpected check",
  "body": "Fixes #10635\r\n\r\n### Context\r\nTargetFramework(s) are honored only in SDK-style projects - emit diagnostic if the property is used in legacy style project\r\n\r\n\r\n### Testing\r\nTargetted test\r\n\r\n",
  "state": "MERGED",
  "createdAt": "2025-01-14T18:25:53Z",
  "updatedAt": "2025-02-03T13:00:00Z",
  "closedAt": "2025-02-03T12:59:58Z",
  "mergedAt": "2025-02-03T12:59:58Z",
  "additions": 329,
  "deletions": 2,
  "changedFiles": 21,
  "headRefName": "buildcheck/tfm-unexpected",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "13613791f1757bf376318e7c87f9dc6e1fbbba7b",
          "message": "Add TargetFramework(s) unexpected check",
          "committedDate": "2025-01-14T18:24:42Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ed077afdb414e0d049e46fe65bde3680e8fe4320",
          "message": "Buildfix",
          "committedDate": "2025-01-14T19:03:49Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "64a273f21bd5aef1228d6679bbefc98e09ec81e8",
          "message": "Improve the check",
          "committedDate": "2025-01-17T18:41:54Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "69f772980a669701b54ae12ed7e2a0cb5ff4e5e7",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2025-01-17T18:45:39Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "be1593870d4804c27c1b411277b510497e5a1bbe",
          "message": "Update src/Build/Resources/Strings.resx\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2025-01-17T18:50:29Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7095c873f120924d4a38bf9241b3361db3b2b36b",
          "message": "Reflected PR comments",
          "committedDate": "2025-01-17T18:52:43Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6cb6e4b04e15c959af4354dba95f8939359d0b45",
          "message": "Testfix",
          "committedDate": "2025-01-20T10:12:34Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eb3aef38a324880366df0a713e8c61f8f6a3af9a",
          "message": "Bump targetting in tests",
          "committedDate": "2025-01-20T15:13:48Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dd38aef7b25df3f363f6ef8999c0a871915f00f4",
          "message": "Merge branch 'main' into buildcheck/tfm-unexpected",
          "committedDate": "2025-01-22T11:19:40Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9c0c1f6dc9248ffee5a399726a01e695b49aeff0",
          "message": "Bump tests targetting",
          "committedDate": "2025-01-29T16:16:35Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "30808f40aec972d8fdf2cf1374bbe8cf686dc6c2",
          "message": "Run test on windows only",
          "committedDate": "2025-01-29T18:05:29Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n| [BC0108](#bc0108---targetframework-or-targetframeworks-specified-in-non-sdk-style-project) | Warning | N/A | 9.0.300 | TargetFramework or TargetFrameworks specified in non-SDK style project. |\r\n```",
              "createdAt": "2025-01-14T20:51:05Z",
              "path": "documentation/specs/BuildCheck/Codes.md",
              "diffHunk": "@@ -10,7 +10,8 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are\n | [BC0104](#bc0104---projectreference-is-preferred-to-reference) | Warning | N/A | 9.0.200 | ProjectReference is preferred to Reference. |\n | [BC0105](#bc0105---embeddedresource-should-specify-culture-metadata) | Warning | N/A | 9.0.200 | Culture specific EmbeddedResource should specify Culture metadata. |\n | [BC0106](#bc0106---copytooutputdirectoryalways-should-be-avoided) | Warning | N/A | 9.0.200 | CopyToOutputDirectory='Always' should be avoided. |\n-| [BC0107](#bc0107---targetframework-and-targetframeworks-specified-together) | Warning | N/A | 9.0.200 | TargetFramework and TargetFrameworks specified together. |\n+| [BC0107](#bc0107---targetframework-and-targetframeworks-specified-together) | Warning | N/A | 9.0.200 | TargetFramework or TargetFrameworks specified in non-SDK style project. |\n+| [BC0108](#bc0108---targetframework-or-targetframeworks-specified-in-non-sdk-style-project) | Warning | N/A | 9.0.300 | TargetFramework and TargetFrameworks specified together. |",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    <value>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</value>\r\n```",
              "createdAt": "2025-01-14T20:52:50Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -2198,6 +2198,14 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n     <value>Project {0} specifies 'TargetFrameworks' property '{1}' and 'TargetFramework' property '{2}' at the same time. This will lead to 'TargetFrameworks' being ignored and build will behave as single-targeted.</value>\n     <comment>Terms in quotes are not to be translated.</comment>\n   </data>\n+  <data name=\"BuildCheck_BC0108_Title\" xml:space=\"preserve\">\n+    <value>'TargetFramework' nor 'TargetFrameworks' property should not be specified in non-SDK style projects.</value>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How dare you use the forbidden word? \ud83d\ude05\r\n\r\n```suggestion\r\n    <value>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</value>\r\n```",
              "createdAt": "2025-01-14T20:55:20Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -2198,6 +2198,14 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n     <value>Project {0} specifies 'TargetFrameworks' property '{1}' and 'TargetFramework' property '{2}' at the same time. This will lead to 'TargetFrameworks' being ignored and build will behave as single-targeted.</value>\n     <comment>Terms in quotes are not to be translated.</comment>\n   </data>\n+  <data name=\"BuildCheck_BC0108_Title\" xml:space=\"preserve\">\n+    <value>'TargetFramework' nor 'TargetFrameworks' property should not be specified in non-SDK style projects.</value>\n+    <comment>Terms in quotes are not to be translated.</comment>\n+  </data>\n+  <data name=\"BuildCheck_BC0108_MessageFmt\" xml:space=\"preserve\">\n+    <value>Project {0} specifies 'TargetFramework(s)' property '{1}', while it's not SDK-style project. Those properties are not understood by legacy-style projects and have no impact.</value>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "\ud83d\ude4a",
              "createdAt": "2025-01-15T19:27:10Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -2198,6 +2198,14 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n     <value>Project {0} specifies 'TargetFrameworks' property '{1}' and 'TargetFramework' property '{2}' at the same time. This will lead to 'TargetFrameworks' being ignored and build will behave as single-targeted.</value>\n     <comment>Terms in quotes are not to be translated.</comment>\n   </data>\n+  <data name=\"BuildCheck_BC0108_Title\" xml:space=\"preserve\">\n+    <value>'TargetFramework' nor 'TargetFrameworks' property should not be specified in non-SDK style projects.</value>\n+    <comment>Terms in quotes are not to be translated.</comment>\n+  </data>\n+  <data name=\"BuildCheck_BC0108_MessageFmt\" xml:space=\"preserve\">\n+    <value>Project {0} specifies 'TargetFramework(s)' property '{1}', while it's not SDK-style project. Those properties are not understood by legacy-style projects and have no impact.</value>",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "??",
              "createdAt": "2025-01-14T20:56:47Z",
              "path": "src/Build/BuildCheck/Checks/TargetFrameworkUnexpectedCheck.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class TargetFrameworkUnexpectedCheck : Check\n+{\n+    private const string RuleId = \"BC0108\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"TargetFrameworkUnexpected\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.TargetFrameworkUnexpected\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly HashSet<string> _projectsSeen = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // We want to avoid repeated checking of a same project (as it might be evaluated multiple times)\n+        //  for this reason we use a hashset with already seen projects.\n+        if (!_projectsSeen.Add(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? frameworks = null;\n+        string? framework = null;\n+        // This is not SDK style project\n+        if ((!context.Data.EvaluatedProperties.TryGetValue(PropertyNames.UsingMicrosoftNETSdk, out string? usingSdkStr) ||\n+            !StringExtensions.IsMSBuildTrueString(usingSdkStr))\n+            &&\n+            // But TargetFramework(s) is specified\n+            (context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFrameworks, out frameworks) ||\n+            context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFramework, out framework)) &&\n+            !string.IsNullOrEmpty(framework ?? frameworks))\n+        {\n+            // {0} specifies 'TargetFrameworks' property '{1}' and 'TargetFramework' property '{2}'",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If I'm reading your conditions correctly here, I think this would fire on a C++/CLI vcxproj targeting .NET 8--but shouldn't.",
              "createdAt": "2025-01-14T20:57:23Z",
              "path": "src/Build/BuildCheck/Checks/TargetFrameworkUnexpectedCheck.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class TargetFrameworkUnexpectedCheck : Check\n+{\n+    private const string RuleId = \"BC0108\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"TargetFrameworkUnexpected\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.TargetFrameworkUnexpected\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly HashSet<string> _projectsSeen = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // We want to avoid repeated checking of a same project (as it might be evaluated multiple times)\n+        //  for this reason we use a hashset with already seen projects.\n+        if (!_projectsSeen.Add(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? frameworks = null;\n+        string? framework = null;\n+        // This is not SDK style project\n+        if ((!context.Data.EvaluatedProperties.TryGetValue(PropertyNames.UsingMicrosoftNETSdk, out string? usingSdkStr) ||",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "We can detect import of `Microsoft.Cpp.props` to handle this.\r\nBut together with this comment: https://github.com/dotnet/msbuild/pull/11285#discussion_r1915593634 - this leads to more importnat question: do you feel this is fundamentaly wrong and would you suggest different way of detecting non-SDK project?",
              "createdAt": "2025-01-15T12:11:32Z",
              "path": "src/Build/BuildCheck/Checks/TargetFrameworkUnexpectedCheck.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class TargetFrameworkUnexpectedCheck : Check\n+{\n+    private const string RuleId = \"BC0108\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"TargetFrameworkUnexpected\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.TargetFrameworkUnexpected\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly HashSet<string> _projectsSeen = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // We want to avoid repeated checking of a same project (as it might be evaluated multiple times)\n+        //  for this reason we use a hashset with already seen projects.\n+        if (!_projectsSeen.Add(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? frameworks = null;\n+        string? framework = null;\n+        // This is not SDK style project\n+        if ((!context.Data.EvaluatedProperties.TryGetValue(PropertyNames.UsingMicrosoftNETSdk, out string? usingSdkStr) ||",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I wonder if we should restrict it to `.csproj`? Or check for any import called `CSharp.targets`? though I guess it should apply to vbproj and fsproj too . . .",
              "createdAt": "2025-01-15T19:42:29Z",
              "path": "src/Build/BuildCheck/Checks/TargetFrameworkUnexpectedCheck.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class TargetFrameworkUnexpectedCheck : Check\n+{\n+    private const string RuleId = \"BC0108\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"TargetFrameworkUnexpected\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.TargetFrameworkUnexpected\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly HashSet<string> _projectsSeen = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // We want to avoid repeated checking of a same project (as it might be evaluated multiple times)\n+        //  for this reason we use a hashset with already seen projects.\n+        if (!_projectsSeen.Add(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? frameworks = null;\n+        string? framework = null;\n+        // This is not SDK style project\n+        if ((!context.Data.EvaluatedProperties.TryGetValue(PropertyNames.UsingMicrosoftNETSdk, out string? usingSdkStr) ||",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "As brainstormed offline - I updated the check to detect ProjectCapability and if the project is sdk-style or c++/cli",
              "createdAt": "2025-01-17T18:43:22Z",
              "path": "src/Build/BuildCheck/Checks/TargetFrameworkUnexpectedCheck.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class TargetFrameworkUnexpectedCheck : Check\n+{\n+    private const string RuleId = \"BC0108\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"TargetFrameworkUnexpected\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.TargetFrameworkUnexpected\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly HashSet<string> _projectsSeen = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // We want to avoid repeated checking of a same project (as it might be evaluated multiple times)\n+        //  for this reason we use a hashset with already seen projects.\n+        if (!_projectsSeen.Add(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? frameworks = null;\n+        string? framework = null;\n+        // This is not SDK style project\n+        if ((!context.Data.EvaluatedProperties.TryGetValue(PropertyNames.UsingMicrosoftNETSdk, out string? usingSdkStr) ||",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nMake sure the Target Framework is specified appropriately for your project.\r\n```",
              "createdAt": "2025-01-14T20:59:09Z",
              "path": "documentation/specs/BuildCheck/Codes.md",
              "diffHunk": "@@ -126,6 +127,16 @@ If you specify `TargetFramework` you are instructing the build to produce a sing\n dotnet build my-multi-target.csproj /p:TargetFramework=net9.0\n ```\n \n+<a name=\"BC0108\"></a>\n+## BC0108 - TargetFramework or TargetFrameworks specified in non-SDK style project.\n+\n+\"'TargetFramework' nor 'TargetFrameworks' property should not be specified in non-SDK style projects.\"\n+\n+'TargetFramework' or 'TargetFrameworks' control the project output targets in modern .NET SDK-style projects. The older non-SDK style projects ('legacy style' projects) interprets different properties for similar mechanism (like 'TargetFrameworkVersion') and the 'TargetFramework' or 'TargetFrameworks' are silently ignored.\n+\n+Make sure the Target Framework targetting is done by properly understood mechanism.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "don't say \"legacy\". And the _style_ of the project isn't relevant, the actual SDK used is what matters (this is a hill I'll die on, \"SDK-style\" is horribly overused).",
              "createdAt": "2025-01-14T20:59:12Z",
              "path": "documentation/specs/BuildCheck/Codes.md",
              "diffHunk": "@@ -126,6 +127,16 @@ If you specify `TargetFramework` you are instructing the build to produce a sing\n dotnet build my-multi-target.csproj /p:TargetFramework=net9.0\n ```\n \n+<a name=\"BC0108\"></a>\n+## BC0108 - TargetFramework or TargetFrameworks specified in non-SDK style project.\n+\n+\"'TargetFramework' nor 'TargetFrameworks' property should not be specified in non-SDK style projects.\"\n+\n+'TargetFramework' or 'TargetFrameworks' control the project output targets in modern .NET SDK-style projects. The older non-SDK style projects ('legacy style' projects) interprets different properties for similar mechanism (like 'TargetFrameworkVersion') and the 'TargetFramework' or 'TargetFrameworks' are silently ignored.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd say this is an example of a project that _shouldn't_ fire this: it's not controlling an output DLL's TF, but it might be doing something on purpose . . .",
              "createdAt": "2025-01-14T21:01:16Z",
              "path": "src/BuildCheck.UnitTests/EndToEndTests.cs",
              "diffHunk": "@@ -401,6 +401,37 @@ void ReplaceStringInFile(string filePath, string original, string replacement)\n         }\n     }\n \n+    [Fact]\n+    public void TFMinNonSdkCheckTest()\n+    {\n+        string content = \"\"\"",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This is now a case where it does NOT fire",
              "createdAt": "2025-01-17T18:51:06Z",
              "path": "src/BuildCheck.UnitTests/EndToEndTests.cs",
              "diffHunk": "@@ -401,6 +401,37 @@ void ReplaceStringInFile(string filePath, string original, string replacement)\n         }\n     }\n \n+    [Fact]\n+    public void TFMinNonSdkCheckTest()\n+    {\n+        string content = \"\"\"",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This check was not changed here right? So, the description doesn't match.",
              "createdAt": "2025-01-15T13:53:44Z",
              "path": "documentation/specs/BuildCheck/Codes.md",
              "diffHunk": "@@ -10,7 +10,8 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are\n | [BC0104](#bc0104---projectreference-is-preferred-to-reference) | Warning | N/A | 9.0.200 | ProjectReference is preferred to Reference. |\n | [BC0105](#bc0105---embeddedresource-should-specify-culture-metadata) | Warning | N/A | 9.0.200 | Culture specific EmbeddedResource should specify Culture metadata. |\n | [BC0106](#bc0106---copytooutputdirectoryalways-should-be-avoided) | Warning | N/A | 9.0.200 | CopyToOutputDirectory='Always' should be avoided. |\n-| [BC0107](#bc0107---targetframework-and-targetframeworks-specified-together) | Warning | N/A | 9.0.200 | TargetFramework and TargetFrameworks specified together. |\n+| [BC0107](#bc0107---targetframework-and-targetframeworks-specified-together) | Warning | N/A | 9.0.200 | TargetFramework or TargetFrameworks specified in non-SDK style project. |",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "Ah - good catch!",
              "createdAt": "2025-01-17T18:47:37Z",
              "path": "documentation/specs/BuildCheck/Codes.md",
              "diffHunk": "@@ -10,7 +10,8 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are\n | [BC0104](#bc0104---projectreference-is-preferred-to-reference) | Warning | N/A | 9.0.200 | ProjectReference is preferred to Reference. |\n | [BC0105](#bc0105---embeddedresource-should-specify-culture-metadata) | Warning | N/A | 9.0.200 | Culture specific EmbeddedResource should specify Culture metadata. |\n | [BC0106](#bc0106---copytooutputdirectoryalways-should-be-avoided) | Warning | N/A | 9.0.200 | CopyToOutputDirectory='Always' should be avoided. |\n-| [BC0107](#bc0107---targetframework-and-targetframeworks-specified-together) | Warning | N/A | 9.0.200 | TargetFramework and TargetFrameworks specified together. |\n+| [BC0107](#bc0107---targetframework-and-targetframeworks-specified-together) | Warning | N/A | 9.0.200 | TargetFramework or TargetFrameworks specified in non-SDK style project. |",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\r\n```suggestion\r\n                // Populating precise location tracked via https://github.com/dotnet/msbuild/issues/10383\r\n```\r\nThe link is to our private project.",
              "createdAt": "2025-01-15T14:19:07Z",
              "path": "src/Build/BuildCheck/Checks/TargetFrameworkUnexpectedCheck.cs",
              "diffHunk": "@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class TargetFrameworkUnexpectedCheck : Check\n+{\n+    private const string RuleId = \"BC0108\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"TargetFrameworkUnexpected\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.TargetFrameworkUnexpected\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly HashSet<string> _projectsSeen = new(MSBuildNameIgnoreCaseComparer.Default);\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // We want to avoid repeated checking of a same project (as it might be evaluated multiple times)\n+        //  for this reason we use a hashset with already seen projects.\n+        if (!_projectsSeen.Add(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? frameworks = null;\n+        string? framework = null;\n+        // This is not SDK style project\n+        if ((!context.Data.EvaluatedProperties.TryGetValue(PropertyNames.UsingMicrosoftNETSdk, out string? usingSdkStr) ||\n+            !StringExtensions.IsMSBuildTrueString(usingSdkStr))\n+            &&\n+            // But TargetFramework(s) is specified\n+            (context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFrameworks, out frameworks) ||\n+            context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFramework, out framework)) &&\n+            !string.IsNullOrEmpty(framework ?? frameworks))\n+        {\n+            // {0} specifies 'TargetFrameworks' property '{1}' and 'TargetFramework' property '{2}'\n+            context.ReportResult(BuildCheckResult.Create(\n+                SupportedRule,\n+                // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "is having another dictionary with all the project paths in it worth it memory-wise to avoid looping over ProjectCapability? Which has worse perf I wonder?\r\n\r\nThis is fine, it makes sense to do this kind of check, though I wonder if we should somehow make it cheaper for individual checks to do this sort of thing.",
              "createdAt": "2025-01-17T19:30:38Z",
              "path": "src/Build/BuildCheck/Checks/TargetFrameworkUnexpectedCheck.cs",
              "diffHunk": "@@ -0,0 +1,105 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class TargetFrameworkUnexpectedCheck : Check\n+{\n+    private const string RuleId = \"BC0108\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"TargetFrameworkUnexpected\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.TargetFrameworkUnexpected\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+        registrationContext.RegisterEvaluatedItemsAction(EvaluatedItemsAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly HashSet<string> _projectsSeen = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private string? _tfm;\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // Resetting state for the next project.\n+        _tfm = null;\n+\n+        // See CopyAlwaysCheck.EvaluatedPropertiesAction for explanation. \n+        if (_projectsSeen.Contains(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? frameworks = null;\n+        string? framework = null;\n+        // TargetFramework(s) is specified\n+        if ((context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFrameworks, out frameworks) ||\n+             context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFramework, out framework)) &&\n+            !string.IsNullOrEmpty(framework ?? frameworks)\n+            &&\n+            !IsSdkStyleProject(context.Data.EvaluatedProperties) && !IsCppCliProject(context.Data.EvaluatedProperties)\n+            )\n+        {\n+            // Indicating that to the EvaluatedItemsAction, that if this project is recognized as manged - we should emit diagnostics.\n+            _tfm = framework ?? frameworks;\n+        }\n+\n+        bool IsSdkStyleProject(IReadOnlyDictionary<string, string> evaluatedProperties)\n+            => evaluatedProperties.TryGetValue(PropertyNames.UsingMicrosoftNETSdk, out string? usingSdkStr) &&\n+               usingSdkStr.IsMSBuildTrueString();\n+\n+        bool IsCppCliProject(IReadOnlyDictionary<string, string> evaluatedProperties)\n+            => evaluatedProperties.TryGetValue(\"CLRSupport\", out string? clrSupportStr) &&\n+               MSBuildNameIgnoreCaseComparer.Default.Equals(clrSupportStr, \"NetCore\");\n+    }\n+\n+    private void EvaluatedItemsAction(BuildCheckDataContext<EvaluatedItemsCheckData> context)\n+    {\n+        // Neither TargetFrameworks nor TargetFramework is specified, or the project is not Sdk-style nor C++/CLI project.\n+        if (_tfm == null)\n+        {\n+            return;\n+        }\n+\n+        // We want to avoid repeated checking of a same project (as it might be evaluated multiple times)\n+        //  for this reason we use a hashset with already seen projects.\n+        if (!_projectsSeen.Add(context.Data.ProjectFilePath))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It's as well about prevention of duplicate diagnostics.\r\nBut - YES! - it absolutely makes sense to avoid the cost of this in individual checks. We have https://github.com/dotnet/msbuild/issues/11085 for this. It didn't meet the bar (it might once we baseline and prioritize perf) ... but anyways it should be easy - I added it to my bucket list for things to do in spare time: https://github.com/orgs/dotnet/projects/117/views/27?pane=issue&itemId=93235857 ",
              "createdAt": "2025-01-20T10:12:15Z",
              "path": "src/Build/BuildCheck/Checks/TargetFrameworkUnexpectedCheck.cs",
              "diffHunk": "@@ -0,0 +1,105 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+using System.IO;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck.Checks;\n+internal class TargetFrameworkUnexpectedCheck : Check\n+{\n+    private const string RuleId = \"BC0108\";\n+    public static CheckRule SupportedRule = new CheckRule(RuleId, \"TargetFrameworkUnexpected\",\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_Title\")!,\n+        ResourceUtilities.GetResourceString(\"BuildCheck_BC0108_MessageFmt\")!,\n+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });\n+\n+    public override string FriendlyName => \"MSBuild.TargetFrameworkUnexpected\";\n+\n+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];\n+\n+    public override void Initialize(ConfigurationContext configurationContext)\n+    {\n+        /* This is it - no custom configuration */\n+    }\n+\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)\n+    {\n+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);\n+        registrationContext.RegisterEvaluatedItemsAction(EvaluatedItemsAction);\n+    }\n+\n+    internal override bool IsBuiltIn => true;\n+\n+    private readonly HashSet<string> _projectsSeen = new(MSBuildNameIgnoreCaseComparer.Default);\n+    private string? _tfm;\n+\n+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    {\n+        // Resetting state for the next project.\n+        _tfm = null;\n+\n+        // See CopyAlwaysCheck.EvaluatedPropertiesAction for explanation. \n+        if (_projectsSeen.Contains(context.Data.ProjectFilePath))\n+        {\n+            return;\n+        }\n+\n+        string? frameworks = null;\n+        string? framework = null;\n+        // TargetFramework(s) is specified\n+        if ((context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFrameworks, out frameworks) ||\n+             context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFramework, out framework)) &&\n+            !string.IsNullOrEmpty(framework ?? frameworks)\n+            &&\n+            !IsSdkStyleProject(context.Data.EvaluatedProperties) && !IsCppCliProject(context.Data.EvaluatedProperties)\n+            )\n+        {\n+            // Indicating that to the EvaluatedItemsAction, that if this project is recognized as manged - we should emit diagnostics.\n+            _tfm = framework ?? frameworks;\n+        }\n+\n+        bool IsSdkStyleProject(IReadOnlyDictionary<string, string> evaluatedProperties)\n+            => evaluatedProperties.TryGetValue(PropertyNames.UsingMicrosoftNETSdk, out string? usingSdkStr) &&\n+               usingSdkStr.IsMSBuildTrueString();\n+\n+        bool IsCppCliProject(IReadOnlyDictionary<string, string> evaluatedProperties)\n+            => evaluatedProperties.TryGetValue(\"CLRSupport\", out string? clrSupportStr) &&\n+               MSBuildNameIgnoreCaseComparer.Default.Equals(clrSupportStr, \"NetCore\");\n+    }\n+\n+    private void EvaluatedItemsAction(BuildCheckDataContext<EvaluatedItemsCheckData> context)\n+    {\n+        // Neither TargetFrameworks nor TargetFramework is specified, or the project is not Sdk-style nor C++/CLI project.\n+        if (_tfm == null)\n+        {\n+            return;\n+        }\n+\n+        // We want to avoid repeated checking of a same project (as it might be evaluated multiple times)\n+        //  for this reason we use a hashset with already seen projects.\n+        if (!_projectsSeen.Add(context.Data.ProjectFilePath))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Update this with the new error text please",
              "createdAt": "2025-01-17T19:34:30Z",
              "path": "documentation/specs/BuildCheck/Codes.md",
              "diffHunk": "@@ -126,6 +127,16 @@ If you specify `TargetFramework` you are instructing the build to produce a sing\n dotnet build my-multi-target.csproj /p:TargetFramework=net9.0\n ```\n \n+<a name=\"BC0108\"></a>\n+## BC0108 - TargetFramework or TargetFrameworks specified in SDK-less project.\n+\n+\"'TargetFramework' nor 'TargetFrameworks' property should not be specified in projects not using .NET SDK.\"\n+\n+'TargetFramework' or 'TargetFrameworks' control the project output targets in modern .NET SDK projects. The older SDK-less projects interprets different properties for similar mechanism (like 'TargetFrameworkVersion') and the 'TargetFramework' or 'TargetFrameworks' are silently ignored.\n+\n+Make sure the Target Framework is specified appropriately for your project.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}