{
  "number": 8619,
  "title": "LiveLogger v2",
  "body": "Fixes #8481, fixes #8464, fixes #8463, fixes #8460, fixes #8458, fixes #8456, fixes #8430, fixes #8370, fixes #8392\r\n\r\n### Context\r\n\r\nWe have decided to change the LiveLogger UX. Instead of the \"full screen\" or \"takes-over-the-screen-buffer\" interactive experience, the goal is a more conventional logger with a node-centric live view and no interactivity.\r\n\r\n### Changes Made\r\n\r\nRe-implemented LiveLogger based on the https://www.github.com/rainersigwald/tortillachip prototype. Since the visual design is not yet finalized, the strings are still hardcoded in source files.\r\n\r\n### Testing\r\n\r\nExisting and newly introduced tests. Manual smoke test.\r\n\r\n### Notes\r\n\r\n`LiveLogger.cs` was completely rewritten so please look at the new content instead of the diff.\r\n\r\nHere are some of the differences compared to v1:\r\n\r\n- The logger is supported only in the .NET build of MSBuild, i.e. not in MSBuild.exe.\r\n- We now use a proper check for ANSI capable terminal on Windows. Interestingly, the classic cmd satisfies the check and LiveLogger works there as well (on Win11 at least).\r\n- The logger is recognized by the minimum message importance optimization for better perf.\r\n\r\n### Example build gifs\r\n\r\n![fsac-build](https://user-images.githubusercontent.com/573979/230428714-992f53fc-3818-4a4d-9a35-6157217baf25.gif)\r\n\r\n",
  "state": "MERGED",
  "createdAt": "2023-03-31T14:49:31Z",
  "updatedAt": "2023-04-12T16:25:13Z",
  "closedAt": "2023-04-12T16:25:12Z",
  "mergedAt": "2023-04-12T16:25:12Z",
  "additions": 1606,
  "deletions": 1459,
  "changedFiles": 24,
  "headRefName": "livelogger",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "c4d8930ed63395515217f0e54319c93b03ab9d06",
          "message": "Delete old LiveLogger",
          "committedDate": "2023-03-22T09:03:36Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "082e89b3e000fef75cd5aacb60ab3224809ee4e7",
          "message": "Re-implement the ANSI/VT100 terminal check",
          "committedDate": "2023-03-22T10:35:54Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "145244b003be8ba470a686195418b60654ec8414",
          "message": "Add Logger and Project from rainersigwald/tortillachip",
          "committedDate": "2023-03-22T10:56:46Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "61f6311355c12b95fdb4b108ac352b418ad93669",
          "message": "Fix warnings",
          "committedDate": "2023-03-22T11:02:54Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0e951312c16793bf5439300dc2cf863c5d386c50",
          "message": "Re-enable /ll with the new LiveLogger",
          "committedDate": "2023-03-22T12:14:26Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "18ece9498a00ac3544fd7bd81b07d3ecac3ec276",
          "message": "Check if ENABLE_VIRTUAL_TERMINAL_PROCESSING sticks",
          "committedDate": "2023-03-22T13:12:49Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "be32f2e4893a182e2ebfee17744e1252390fc2df",
          "message": "Join the refresher thread on shutdown",
          "committedDate": "2023-03-22T13:13:15Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d2c22201fbd507c7f7558824db58cfdb86b15a3e",
          "message": "Rerender nodes only if the output actually changed",
          "committedDate": "2023-03-22T18:30:27Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "332c1ff4817eec47e07facfa53d5d5d727a47297",
          "message": "Enable nullability checks",
          "committedDate": "2023-03-23T14:23:56Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b21687387aa9fcf9207035a130884ebb535440f0",
          "message": "Add hyper-links to outputs",
          "committedDate": "2023-03-23T16:22:49Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8154e0feab7b675d854958fd55958b417aeffce7",
          "message": "Better detection of output path",
          "committedDate": "2023-03-24T10:28:38Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0d2aed1427d43cf6854e7a77a8b019de846b731a",
          "message": "Introduce FEATURE_LIVELOGGER",
          "committedDate": "2023-03-24T12:15:20Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dc55f86b89df60e6623173ce67c9bf9abdc7e9f7",
          "message": "Use ReadOnlySpan/ReadOnlyMemory where appropriate",
          "committedDate": "2023-03-24T14:19:32Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b73b9b94d0b900e591d55f68029324cb58a82318",
          "message": "Add warning & error handling",
          "committedDate": "2023-03-24T16:23:17Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6d6b9f64b97f25570b2a26ef0fd17b27ccafe7db",
          "message": "Simplify warning & error handling, set output to UTF8",
          "committedDate": "2023-03-27T09:39:23Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fde43a12fd265a315f61752a874c1650eb7ab972",
          "message": "Abstract output to ITerminal/Terminal",
          "committedDate": "2023-03-27T10:12:44Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "13a47fcf784dcd3ec3250aedfbb8ace4ffbde025",
          "message": "Add colors to ITerminal/Terminal",
          "committedDate": "2023-03-27T11:15:17Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b46e5c771806e8a1ab6dc949932ee3b6a1b6308b",
          "message": "Add 'atomic' writes to fix flickering",
          "committedDate": "2023-03-27T11:40:00Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1c3db862e27d922c10594cf2c2382da3485aab7b",
          "message": "Use Begin/EnUpdate when finishing a project",
          "committedDate": "2023-03-27T11:50:53Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f2122e2c2a729d59183982bd1d7e9871703b56a9",
          "message": "Code cleanup and comments",
          "committedDate": "2023-03-28T09:47:44Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "42a9e0ecb1cbe462760bbd60bddeb9910ee8be48",
          "message": "Report only output-producing projects as 'completed'",
          "committedDate": "2023-03-28T15:20:28Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "03f9bfc90c02cf16f14aed2b6ca3269dfc75afbc",
          "message": "Print project file name without path",
          "committedDate": "2023-03-29T09:14:10Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a9cf5c8abac0ad0910aa29a0db64fb794e13a88c",
          "message": "Print per-project succeeded/failed upon completion",
          "committedDate": "2023-03-29T09:43:38Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "847b58cff924239b47d22a5d95952552f66dde92",
          "message": "Add indentation per initial mock-ups",
          "committedDate": "2023-03-29T09:51:27Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "981a6373009e438235643b6b5cf8adc68b2597c5",
          "message": "Print build result summary",
          "committedDate": "2023-03-29T11:30:06Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "234718660c4c8452b65e5bd78282538869726428",
          "message": "Print target framework where available",
          "committedDate": "2023-03-29T12:13:09Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ece387936d56c916b7f1cb1d86b4b1bd63f84434",
          "message": "Rename _notableProjects to _projects, track everything",
          "committedDate": "2023-03-29T12:18:22Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8c385b0066e1d96c7725d4df4cfd622cafa3541b",
          "message": "Make the min-importance optimization aware of LiveLogger",
          "committedDate": "2023-03-29T14:49:30Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aa5cf683008a5dcb92ed697df1ac3250bd86a478",
          "message": "Add sample LiveLogger unit tests",
          "committedDate": "2023-03-31T08:00:07Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "107d1f893537fa5caa413e3f2ada9f178385e4ad",
          "message": "Reduce screen flicking by delta rendering",
          "committedDate": "2023-03-31T08:10:58Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f42f68790f97f59a272b23fd9510e0d565587281",
          "message": "Optimize rendering loop for flickering",
          "committedDate": "2023-03-31T08:40:32Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "415891eeeec4bc9affe4692fb7a445683b6b0283",
          "message": "Fix and suppress warnings in LiveLogger_Tests.cs",
          "committedDate": "2023-03-31T09:24:39Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "28cf5abb1d9c3900db6e1c2a8e6b9165b700a56b",
          "message": "Add command line switch test",
          "committedDate": "2023-03-31T09:24:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2c7c07b09749b92a97707ae64b031caf3fe53c1b",
          "message": "Fixing using Terminal\nDetect and fix console resize\nDetect and limit max nodes by console height",
          "committedDate": "2023-03-31T12:54:52Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c4dbf3411737abeb72de2a2296f06e825dcd6acd",
          "message": "Merge branch 'livelogger' of https://github.com/dotnet/msbuild into livelogger",
          "committedDate": "2023-03-31T12:55:02Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7e2c5455e40bdd0597886cd72daecc81a0c68418",
          "message": "Thread safety fixes",
          "committedDate": "2023-03-31T13:21:33Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "24fc018a5b583e9c36b96eeae49da239f22acf3b",
          "message": "Minor code clean",
          "committedDate": "2023-03-31T13:38:46Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b0542f37f6cfc6342bf6615338e72487ae1d7f82",
          "message": "Add #region's and minor cleanup",
          "committedDate": "2023-03-31T14:30:14Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "41390058e72934b6783ef6ad6b194aa14b08cf7c",
          "message": "Merge remote-tracking branch 'dotnet/main' into livelogger",
          "committedDate": "2023-03-31T14:54:20Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7c51985be35c48a91b2b22f911d0e6865650f371",
          "message": "PR feedback: Reduce block nesting in QueryIsScreenAndTryEnableAnsiColorCodes",
          "committedDate": "2023-04-04T09:27:42Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8b3f013c4f2fcb20c4e2454681d89186510df350",
          "message": "PR feedback: Move top-level types to their own source files",
          "committedDate": "2023-04-04T09:41:00Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "69d4bd5a51c66c2f6789e2ba9a2f4213fc49483c",
          "message": "PR feedback: Centralize escape codes in class AnsiCodes",
          "committedDate": "2023-04-04T11:29:36Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a4194b5743f031f872c61f39b2573979ec63c355",
          "message": "Hide the cursor when overwriting live lines",
          "committedDate": "2023-04-04T13:22:46Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "af8b87585c658cb2f261a860d9908cfb1838d110",
          "message": "Additionally accept -tl and -terminallogger\n\nThis will give us a new hook to ensure folks are on the newest bits and not the prior version.",
          "committedDate": "2023-04-06T15:08:38Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dae5e4fd766903f5c3583942eb699bdf1ffcbda9",
          "message": "fixup! Additionally accept -tl and -terminallogger",
          "committedDate": "2023-04-06T21:18:11Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a276ac580468e6f43d927efd4d6231e223776ed0",
          "message": "Allow explicit LiveLogger opt-in\n\nNow accepts `-tl` which means `-tl:auto`, as well as `-tl:true` and\n`-tl:false`, allowing overriding the detection.",
          "committedDate": "2023-04-06T22:20:57Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "694193844062e895187bbc229de126b0aa003ba3",
          "message": "Mark node idle when it finishes a project\n\nI was noticing a bunch of nodes that seemed \"stuck\" on targets that shouldn't take a long time--turns out they were done with that + idle but never got marked as such so they kept counting up confusingly.",
          "committedDate": "2023-04-10T15:06:09Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4c88a51aba44cba91963e3304d99b086434d491c",
          "message": "Try to tone down the emoji\n\nUse variation selector to try to display as a symbol instead of an emoji.",
          "committedDate": "2023-04-10T15:14:56Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "11df683c8eaf3fb6c846cba719f9eadb5c633f1e",
          "message": "Track restore via node status\n\nThis is more responsive and keeps the counter on screen\nat all times at the cost of giving up any hope of understanding\nwhat's going on within the restore.",
          "committedDate": "2023-04-10T18:53:01Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2caea922c0b06ae0114fefe4af8b11be0b2ee08a",
          "message": "Print project names without extension",
          "committedDate": "2023-04-11T10:29:07Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3a6a34d243e67883e869d9d17fdc8dba7767e6e2",
          "message": "Merge remote-tracking branch 'dotnet/main' into livelogger",
          "committedDate": "2023-04-11T10:33:10Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6b0a1c0fd47641b7a486b4bc3ed1cfde92435331",
          "message": "Add LiveLogger to MSBuild.exe as well",
          "committedDate": "2023-04-12T14:40:29Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: consider `typeof(LiveLogger).FullName`, that way if namespaces change the code will remain valid.",
              "createdAt": "2023-04-03T12:22:24Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -1651,8 +1651,11 @@ private void UpdateMinimumMessageImportance(ILogger logger)\n                 // The null logger has no effect on minimum verbosity.\n                 Execution.BuildManager.NullLogger => null,\n \n-                // If the logger is not on our whitelist, there are no importance guarantees. Fall back to \"any importance\".\n-                _ => MessageImportance.Low\n+                // The live logger consumes only high priority messages.\n+                _ => innerLogger.GetType().FullName == \"Microsoft.Build.Logging.LiveLogger.LiveLogger\"",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "This is unfortunately not possible with the current layering. The new logger is in `MSBuild.dll` and this backend code resides in `Microsoft.Build.dll` which is a dependent assembly of `MSBuild.dll`. We are aware of the limitation and if more issues like this arise, we may go ahead and move the logger to the other assembly. ",
              "createdAt": "2023-04-04T09:11:41Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -1651,8 +1651,11 @@ private void UpdateMinimumMessageImportance(ILogger logger)\n                 // The null logger has no effect on minimum verbosity.\n                 Execution.BuildManager.NullLogger => null,\n \n-                // If the logger is not on our whitelist, there are no importance guarantees. Fall back to \"any importance\".\n-                _ => MessageImportance.Low\n+                // The live logger consumes only high priority messages.\n+                _ => innerLogger.GetType().FullName == \"Microsoft.Build.Logging.LiveLogger.LiveLogger\"",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: Could the if block hierarchy be flattened?\r\n\r\n```\r\nif (!Console.IsOutputRedirected && \r\nIsWindows &&\r\nGetStdHandle(STD_OUTPUT_HANDLE) is IntPtr stdOut &&\r\nGetConsoleMode(stdOut, out uint cnosoleMode){...}\r\n```",
              "createdAt": "2023-04-03T12:28:48Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1480,6 +1480,69 @@ internal static void VerifyThrowWin32Result(int result)\n         }\n     }\n \n+#if !CLR2COMPATIBILITY\n+    internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalConsoleMode) QueryIsScreenAndTryEnableAnsiColorCodes()\n+    {\n+        bool acceptAnsiColorCodes = false;\n+        bool outputIsScreen = false;\n+        uint? originalConsoleMode = null;\n+\n+        if (!Console.IsOutputRedirected)",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Doesn't seem to be possible to go this far. I have removed one level of nesting.",
              "createdAt": "2023-04-04T11:31:15Z",
              "path": "src/Framework/NativeMethods.cs",
              "diffHunk": "@@ -1480,6 +1480,69 @@ internal static void VerifyThrowWin32Result(int result)\n         }\n     }\n \n+#if !CLR2COMPATIBILITY\n+    internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalConsoleMode) QueryIsScreenAndTryEnableAnsiColorCodes()\n+    {\n+        bool acceptAnsiColorCodes = false;\n+        bool outputIsScreen = false;\n+        uint? originalConsoleMode = null;\n+\n+        if (!Console.IsOutputRedirected)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: Though it's test code, consider https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/dispose-pattern",
              "createdAt": "2023-04-03T12:31:58Z",
              "path": "src/MSBuild.UnitTests/LiveLogger_Tests.cs",
              "diffHunk": "@@ -0,0 +1,217 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Logging.LiveLogger;\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.Build.UnitTests\n+{\n+    public class LiveLogger_Tests : IEventSource, IDisposable\n+    {\n+        private const int _nodeCount = 8;\n+        private const int _terminalWidth = 80;\n+        private const int _terminalHeight = 40;\n+        private const string _eventSender = \"Test\";\n+        private const string _projectFile = @\"C:\\src\\project.proj\";\n+\n+        private readonly MockTerminal _mockTerminal;\n+        private readonly LiveLogger _liveLogger;\n+\n+        private readonly DateTime _buildStartTime = new DateTime(2023, 3, 30, 16, 30, 0);\n+        private readonly DateTime _buildFinishTime = new DateTime(2023, 3, 30, 16, 30, 5);\n+\n+        public LiveLogger_Tests()\n+        {\n+            _mockTerminal = new MockTerminal(_terminalWidth, _terminalHeight);\n+            _liveLogger = new LiveLogger(_mockTerminal);\n+\n+            _liveLogger.Initialize(this, _nodeCount);\n+        }\n+\n+        #region IEventSource implementation\n+\n+#pragma warning disable CS0067\n+        public event BuildMessageEventHandler? MessageRaised;\n+\n+        public event BuildErrorEventHandler? ErrorRaised;\n+\n+        public event BuildWarningEventHandler? WarningRaised;\n+\n+        public event BuildStartedEventHandler? BuildStarted;\n+\n+        public event BuildFinishedEventHandler? BuildFinished;\n+\n+        public event ProjectStartedEventHandler? ProjectStarted;\n+\n+        public event ProjectFinishedEventHandler? ProjectFinished;\n+\n+        public event TargetStartedEventHandler? TargetStarted;\n+\n+        public event TargetFinishedEventHandler? TargetFinished;\n+\n+        public event TaskStartedEventHandler? TaskStarted;\n+\n+        public event TaskFinishedEventHandler? TaskFinished;\n+\n+        public event CustomBuildEventHandler? CustomEventRaised;\n+\n+        public event BuildStatusEventHandler? StatusEventRaised;\n+\n+        public event AnyEventHandler? AnyEventRaised;\n+#pragma warning restore CS0067\n+\n+        #endregion\n+\n+        #region IDisposable implementation\n+\n+        public void Dispose()",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "`IDispose` is just for running code after each test. The full pattern would be an overkill (we don't do it in existing tests either, I've checked).",
              "createdAt": "2023-04-04T11:33:25Z",
              "path": "src/MSBuild.UnitTests/LiveLogger_Tests.cs",
              "diffHunk": "@@ -0,0 +1,217 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Logging.LiveLogger;\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.Build.UnitTests\n+{\n+    public class LiveLogger_Tests : IEventSource, IDisposable\n+    {\n+        private const int _nodeCount = 8;\n+        private const int _terminalWidth = 80;\n+        private const int _terminalHeight = 40;\n+        private const string _eventSender = \"Test\";\n+        private const string _projectFile = @\"C:\\src\\project.proj\";\n+\n+        private readonly MockTerminal _mockTerminal;\n+        private readonly LiveLogger _liveLogger;\n+\n+        private readonly DateTime _buildStartTime = new DateTime(2023, 3, 30, 16, 30, 0);\n+        private readonly DateTime _buildFinishTime = new DateTime(2023, 3, 30, 16, 30, 5);\n+\n+        public LiveLogger_Tests()\n+        {\n+            _mockTerminal = new MockTerminal(_terminalWidth, _terminalHeight);\n+            _liveLogger = new LiveLogger(_mockTerminal);\n+\n+            _liveLogger.Initialize(this, _nodeCount);\n+        }\n+\n+        #region IEventSource implementation\n+\n+#pragma warning disable CS0067\n+        public event BuildMessageEventHandler? MessageRaised;\n+\n+        public event BuildErrorEventHandler? ErrorRaised;\n+\n+        public event BuildWarningEventHandler? WarningRaised;\n+\n+        public event BuildStartedEventHandler? BuildStarted;\n+\n+        public event BuildFinishedEventHandler? BuildFinished;\n+\n+        public event ProjectStartedEventHandler? ProjectStarted;\n+\n+        public event ProjectFinishedEventHandler? ProjectFinished;\n+\n+        public event TargetStartedEventHandler? TargetStarted;\n+\n+        public event TargetFinishedEventHandler? TargetFinished;\n+\n+        public event TaskStartedEventHandler? TaskStarted;\n+\n+        public event TaskFinishedEventHandler? TaskFinished;\n+\n+        public event CustomBuildEventHandler? CustomEventRaised;\n+\n+        public event BuildStatusEventHandler? StatusEventRaised;\n+\n+        public event AnyEventHandler? AnyEventRaised;\n+#pragma warning restore CS0067\n+\n+        #endregion\n+\n+        #region IDisposable implementation\n+\n+        public void Dispose()",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: consider 1 type / file.",
              "createdAt": "2023-04-03T12:37:45Z",
              "path": "src/MSBuild/LiveLogger/Project.cs",
              "diffHunk": "@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+\n+namespace Microsoft.Build.Logging.LiveLogger;\n+\n+/// <summary>\n+/// Represents a project being built.\n+/// </summary>\n+internal sealed class Project\n+{\n+    /// <summary>\n+    /// Initialized a new <see cref=\"Project\"/> with the given <paramref name=\"targetFramework\"/>.\n+    /// </summary>\n+    /// <param name=\"targetFramework\">The target framework of the project or null if not multi-targeting.</param>\n+    public Project(string? targetFramework)\n+    {\n+        TargetFramework = targetFramework;\n+    }\n+\n+    /// <summary>\n+    /// A stopwatch to time the build of the project.\n+    /// </summary>\n+    public Stopwatch Stopwatch { get; } = Stopwatch.StartNew();\n+\n+    /// <summary>\n+    /// Full path to the primary output of the project, if known.\n+    /// </summary>\n+    public ReadOnlyMemory<char>? OutputPath { get; set; }\n+\n+    /// <summary>\n+    /// The target framework of the project or null if not multi-targeting.\n+    /// </summary>\n+    public string? TargetFramework { get; }\n+\n+    /// <summary>\n+    /// A lazily initialized list of build messages/warnings/errors raised during the build.\n+    /// </summary>\n+    public List<BuildMessage>? BuildMessages { get; private set; }\n+\n+    /// <summary>\n+    /// Adds a build message of the given severity to <see cref=\"BuildMessages\"/>.\n+    /// </summary>\n+    public void AddBuildMessage(MessageSeverity severity, string message)\n+    {\n+        BuildMessages ??= new List<BuildMessage>();\n+        BuildMessages.Add(new BuildMessage(severity, message));\n+    }\n+}\n+\n+/// <summary>\n+/// Enumerates the supported message severities.\n+/// </summary>\n+internal enum MessageSeverity { Warning, Error }",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Thank you, done. All top-level types have their own source file now.",
              "createdAt": "2023-04-04T11:33:59Z",
              "path": "src/MSBuild/LiveLogger/Project.cs",
              "diffHunk": "@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+\n+namespace Microsoft.Build.Logging.LiveLogger;\n+\n+/// <summary>\n+/// Represents a project being built.\n+/// </summary>\n+internal sealed class Project\n+{\n+    /// <summary>\n+    /// Initialized a new <see cref=\"Project\"/> with the given <paramref name=\"targetFramework\"/>.\n+    /// </summary>\n+    /// <param name=\"targetFramework\">The target framework of the project or null if not multi-targeting.</param>\n+    public Project(string? targetFramework)\n+    {\n+        TargetFramework = targetFramework;\n+    }\n+\n+    /// <summary>\n+    /// A stopwatch to time the build of the project.\n+    /// </summary>\n+    public Stopwatch Stopwatch { get; } = Stopwatch.StartNew();\n+\n+    /// <summary>\n+    /// Full path to the primary output of the project, if known.\n+    /// </summary>\n+    public ReadOnlyMemory<char>? OutputPath { get; set; }\n+\n+    /// <summary>\n+    /// The target framework of the project or null if not multi-targeting.\n+    /// </summary>\n+    public string? TargetFramework { get; }\n+\n+    /// <summary>\n+    /// A lazily initialized list of build messages/warnings/errors raised during the build.\n+    /// </summary>\n+    public List<BuildMessage>? BuildMessages { get; private set; }\n+\n+    /// <summary>\n+    /// Adds a build message of the given severity to <see cref=\"BuildMessages\"/>.\n+    /// </summary>\n+    public void AddBuildMessage(MessageSeverity severity, string message)\n+    {\n+        BuildMessages ??= new List<BuildMessage>();\n+        BuildMessages.Add(new BuildMessage(severity, message));\n+    }\n+}\n+\n+/// <summary>\n+/// Enumerates the supported message severities.\n+/// </summary>\n+internal enum MessageSeverity { Warning, Error }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: Consider constants for these escape sequences.",
              "createdAt": "2023-04-03T12:39:39Z",
              "path": "src/MSBuild/LiveLogger/Terminal.cs",
              "diffHunk": "@@ -0,0 +1,147 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Text;\n+\n+namespace Microsoft.Build.Logging.LiveLogger;\n+\n+/// <summary>\n+/// An <see cref=\"ITerminal\"/> implementation for ANSI/VT100 terminals.\n+/// </summary>\n+internal sealed class Terminal : ITerminal\n+{\n+    /// <summary>\n+    /// The encoding read from <see cref=\"Console.OutputEncoding\"/> when the terminal is instantiated.\n+    /// </summary>\n+    private readonly Encoding _originalOutputEncoding;\n+\n+    /// <summary>\n+    /// A string buffer used with <see cref=\"BeginUpdate\"/>/<see cref=\"EndUpdate\"/>.\n+    /// </summary>\n+    private readonly StringBuilder _outputBuilder = new();\n+\n+    /// <summary>\n+    /// True if <see cref=\"BeginUpdate\"/> was called and <c>Write*</c> methods are buffering instead of directly printing.\n+    /// </summary>\n+    private bool _isBuffering = false;\n+\n+    /// <inheritdoc/>\n+    public int Height => Console.BufferHeight;\n+\n+    /// <inheritdoc/>\n+    public int Width => Console.BufferWidth;\n+\n+    public Terminal()\n+    {\n+        _originalOutputEncoding = Console.OutputEncoding;\n+        Console.OutputEncoding = Encoding.UTF8;\n+    }\n+\n+    /// <inheritdoc/>\n+    public void BeginUpdate()\n+    {\n+        if (_isBuffering)\n+        {\n+            throw new InvalidOperationException();\n+        }\n+        _isBuffering = true;\n+    }\n+\n+    /// <inheritdoc/>\n+    public void EndUpdate()\n+    {\n+        if (!_isBuffering)\n+        {\n+            throw new InvalidOperationException();\n+        }\n+        _isBuffering = false;\n+\n+        Console.Write(_outputBuilder.ToString());\n+        _outputBuilder.Clear();\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Write(string text)\n+    {\n+        if (_isBuffering)\n+        {\n+            _outputBuilder.Append(text);\n+        }\n+        else\n+        {\n+            Console.Write(text);\n+        }\n+    }\n+\n+    /// <inheritdoc/>\n+    public void WriteLine(string text)\n+    {\n+        if (_isBuffering)\n+        {\n+            _outputBuilder.AppendLine(text);\n+        }\n+        else\n+        {\n+            Console.WriteLine(text);\n+        }\n+    }\n+\n+    /// <inheritdoc/>\n+    public void WriteLine(ReadOnlySpan<char> text)\n+    {\n+        if (_isBuffering)\n+        {\n+            _outputBuilder.Append(text);\n+            _outputBuilder.AppendLine();\n+        }\n+        else\n+        {\n+            Console.Out.WriteLine(text);\n+        }\n+    }\n+\n+    /// <inheritdoc/>\n+    public void WriteLineFitToWidth(ReadOnlySpan<char> input)\n+    {\n+        WriteLine(input.Slice(0, Math.Min(input.Length, Width - 1)));\n+    }\n+\n+    /// <inheritdoc/>\n+    public void WriteColor(TerminalColor color, string text)\n+    {\n+        if (_isBuffering)\n+        {\n+            _outputBuilder\n+                .Append(\"\\x1b[\")",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "I've added `AnsiCodes.cs` with the escape sequences used in the logger.",
              "createdAt": "2023-04-04T11:34:41Z",
              "path": "src/MSBuild/LiveLogger/Terminal.cs",
              "diffHunk": "@@ -0,0 +1,147 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Text;\n+\n+namespace Microsoft.Build.Logging.LiveLogger;\n+\n+/// <summary>\n+/// An <see cref=\"ITerminal\"/> implementation for ANSI/VT100 terminals.\n+/// </summary>\n+internal sealed class Terminal : ITerminal\n+{\n+    /// <summary>\n+    /// The encoding read from <see cref=\"Console.OutputEncoding\"/> when the terminal is instantiated.\n+    /// </summary>\n+    private readonly Encoding _originalOutputEncoding;\n+\n+    /// <summary>\n+    /// A string buffer used with <see cref=\"BeginUpdate\"/>/<see cref=\"EndUpdate\"/>.\n+    /// </summary>\n+    private readonly StringBuilder _outputBuilder = new();\n+\n+    /// <summary>\n+    /// True if <see cref=\"BeginUpdate\"/> was called and <c>Write*</c> methods are buffering instead of directly printing.\n+    /// </summary>\n+    private bool _isBuffering = false;\n+\n+    /// <inheritdoc/>\n+    public int Height => Console.BufferHeight;\n+\n+    /// <inheritdoc/>\n+    public int Width => Console.BufferWidth;\n+\n+    public Terminal()\n+    {\n+        _originalOutputEncoding = Console.OutputEncoding;\n+        Console.OutputEncoding = Encoding.UTF8;\n+    }\n+\n+    /// <inheritdoc/>\n+    public void BeginUpdate()\n+    {\n+        if (_isBuffering)\n+        {\n+            throw new InvalidOperationException();\n+        }\n+        _isBuffering = true;\n+    }\n+\n+    /// <inheritdoc/>\n+    public void EndUpdate()\n+    {\n+        if (!_isBuffering)\n+        {\n+            throw new InvalidOperationException();\n+        }\n+        _isBuffering = false;\n+\n+        Console.Write(_outputBuilder.ToString());\n+        _outputBuilder.Clear();\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Write(string text)\n+    {\n+        if (_isBuffering)\n+        {\n+            _outputBuilder.Append(text);\n+        }\n+        else\n+        {\n+            Console.Write(text);\n+        }\n+    }\n+\n+    /// <inheritdoc/>\n+    public void WriteLine(string text)\n+    {\n+        if (_isBuffering)\n+        {\n+            _outputBuilder.AppendLine(text);\n+        }\n+        else\n+        {\n+            Console.WriteLine(text);\n+        }\n+    }\n+\n+    /// <inheritdoc/>\n+    public void WriteLine(ReadOnlySpan<char> text)\n+    {\n+        if (_isBuffering)\n+        {\n+            _outputBuilder.Append(text);\n+            _outputBuilder.AppendLine();\n+        }\n+        else\n+        {\n+            Console.Out.WriteLine(text);\n+        }\n+    }\n+\n+    /// <inheritdoc/>\n+    public void WriteLineFitToWidth(ReadOnlySpan<char> input)\n+    {\n+        WriteLine(input.Slice(0, Math.Min(input.Length, Width - 1)));\n+    }\n+\n+    /// <inheritdoc/>\n+    public void WriteColor(TerminalColor color, string text)\n+    {\n+        if (_isBuffering)\n+        {\n+            _outputBuilder\n+                .Append(\"\\x1b[\")",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't like losing the new logger on `MSBuild.exe` and it doesn't seem like it should be necessary. Are the perf improvements from fast-span so dramatic that it's not ok without it?",
              "createdAt": "2023-04-10T19:47:16Z",
              "path": "src/Directory.BeforeCommon.targets",
              "diffHunk": "@@ -92,6 +92,7 @@\n     <DefineConstants>$(DefineConstants);USE_MSBUILD_DLL_EXTN</DefineConstants>\n     <DefineConstants>$(DefineConstants);WORKAROUND_COREFX_19110</DefineConstants>\n     <DefineConstants>$(DefineConstants);FEATURE_SYMLINK_TARGET</DefineConstants>\n+    <DefineConstants>$(DefineConstants);FEATURE_LIVELOGGER</DefineConstants>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Definitely not dramatic. The motivation for the feature flag was the explicit decision that we want to support the new logger only in .NET SDK, not span or other implementation details. I may have misunderstood, tagging @baronfel to check if he's OK with exposing `/tl` in `MSBuild.exe` as well.",
              "createdAt": "2023-04-11T09:10:57Z",
              "path": "src/Directory.BeforeCommon.targets",
              "diffHunk": "@@ -92,6 +92,7 @@\n     <DefineConstants>$(DefineConstants);USE_MSBUILD_DLL_EXTN</DefineConstants>\n     <DefineConstants>$(DefineConstants);WORKAROUND_COREFX_19110</DefineConstants>\n     <DefineConstants>$(DefineConstants);FEATURE_SYMLINK_TARGET</DefineConstants>\n+    <DefineConstants>$(DefineConstants);FEATURE_LIVELOGGER</DefineConstants>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I'm perfectly happy to allow it to be exposed in both tools - but our focus should be on the .NET SDK user base as far as final desired UX decisions go.",
              "createdAt": "2023-04-11T14:54:54Z",
              "path": "src/Directory.BeforeCommon.targets",
              "diffHunk": "@@ -92,6 +92,7 @@\n     <DefineConstants>$(DefineConstants);USE_MSBUILD_DLL_EXTN</DefineConstants>\n     <DefineConstants>$(DefineConstants);WORKAROUND_COREFX_19110</DefineConstants>\n     <DefineConstants>$(DefineConstants);FEATURE_SYMLINK_TARGET</DefineConstants>\n+    <DefineConstants>$(DefineConstants);FEATURE_LIVELOGGER</DefineConstants>",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "I have removed the ifdef and enabled the logger in `MSBuild.exe` in 6b0a1c0fd.",
              "createdAt": "2023-04-12T14:41:43Z",
              "path": "src/Directory.BeforeCommon.targets",
              "diffHunk": "@@ -92,6 +92,7 @@\n     <DefineConstants>$(DefineConstants);USE_MSBUILD_DLL_EXTN</DefineConstants>\n     <DefineConstants>$(DefineConstants);WORKAROUND_COREFX_19110</DefineConstants>\n     <DefineConstants>$(DefineConstants);FEATURE_SYMLINK_TARGET</DefineConstants>\n+    <DefineConstants>$(DefineConstants);FEATURE_LIVELOGGER</DefineConstants>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's the motivation for this? I think I'd rather have two extra characters of space.",
              "createdAt": "2023-04-10T19:48:38Z",
              "path": "src/MSBuild/LiveLogger/LiveLogger.cs",
              "diffHunk": "@@ -2,36 +2,123 @@\n // The .NET Foundation licenses this file to you under the MIT license.\n \n using System;\n-using System.Collections.Concurrent;\n using System.Collections.Generic;\n using System.Diagnostics;\n-using System.Threading.Tasks;\n+using System.IO;\n+\n+using System.Text;\n+using System.Threading;\n using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging.LiveLogger;\n \n-namespace Microsoft.Build.Logging.LiveLogger\n+/// <summary>\n+/// A logger which updates the console output \"live\" during the build.\n+/// </summary>\n+/// <remarks>\n+/// Uses ANSI/VT100 control codes to erase and overwrite lines as the build is progressing.\n+/// </remarks>\n+internal sealed class LiveLogger : INodeLogger\n {\n-    internal class LiveLogger : ILogger\n+    /// <summary>\n+    /// A wrapper over the project context ID passed to us in <see cref=\"IEventSource\"/> logger events.\n+    /// </summary>\n+    internal record struct ProjectContext(int Id)\n     {\n-        private ConcurrentDictionary<int, ProjectNode> projects = new();\n-\n-        private bool succeeded;\n-        private int startedProjects = 0;\n-        private int finishedProjects = 0;\n-        private ConcurrentDictionary<string, int> blockedProjects = new();\n-\n-        private Stopwatch? _stopwatch;\n-\n-        public LoggerVerbosity Verbosity { get; set; }\n-        public string Parameters { get; set; }\n+        public ProjectContext(BuildEventContext context)\n+            : this(context.ProjectContextId)\n+        { }\n+    }\n \n-        /// <summary>\n-        /// List of events the logger needs as parameters to the <see cref=\"ConfigurableForwardingLogger\"/>.\n-        /// </summary>\n-        /// <remarks>\n-        /// If LiveLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main node using an instance of <see cref=\"ConfigurableForwardingLogger\"/> with the following parameters.\n-        /// </remarks>\n-        public static readonly string[] ConfigurableForwardingLoggerParameters =\n+    /// <summary>\n+    /// Encapsulates the per-node data shown in live node output.\n+    /// </summary>\n+    internal record NodeStatus(string Project, string? TargetFramework, string Target, Stopwatch Stopwatch)\n+    {\n+        public override string ToString()\n         {\n+            return string.IsNullOrEmpty(TargetFramework)\n+                ? $\"{Indentation}{Project} {Target} ({Stopwatch.Elapsed.TotalSeconds:F1}s)\"\n+                : $\"{Indentation}{Project} [{TargetFramework}] {Target} ({Stopwatch.Elapsed.TotalSeconds:F1}s)\";\n+        }\n+    }\n+\n+    /// <summary>\n+    /// The indentation to use for all build output.\n+    /// </summary>\n+    private const string Indentation = \"  \";",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I think we wanted this for an easier-to-read multiline output (both \"project done\" and warnings/errors) because it's easier to  tell on which terminal line a logical line starts. Without this the output looks like the proverbial wall of text. Very subjective and I don't feel strongly about it.",
              "createdAt": "2023-04-11T09:21:05Z",
              "path": "src/MSBuild/LiveLogger/LiveLogger.cs",
              "diffHunk": "@@ -2,36 +2,123 @@\n // The .NET Foundation licenses this file to you under the MIT license.\n \n using System;\n-using System.Collections.Concurrent;\n using System.Collections.Generic;\n using System.Diagnostics;\n-using System.Threading.Tasks;\n+using System.IO;\n+\n+using System.Text;\n+using System.Threading;\n using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Logging.LiveLogger;\n \n-namespace Microsoft.Build.Logging.LiveLogger\n+/// <summary>\n+/// A logger which updates the console output \"live\" during the build.\n+/// </summary>\n+/// <remarks>\n+/// Uses ANSI/VT100 control codes to erase and overwrite lines as the build is progressing.\n+/// </remarks>\n+internal sealed class LiveLogger : INodeLogger\n {\n-    internal class LiveLogger : ILogger\n+    /// <summary>\n+    /// A wrapper over the project context ID passed to us in <see cref=\"IEventSource\"/> logger events.\n+    /// </summary>\n+    internal record struct ProjectContext(int Id)\n     {\n-        private ConcurrentDictionary<int, ProjectNode> projects = new();\n-\n-        private bool succeeded;\n-        private int startedProjects = 0;\n-        private int finishedProjects = 0;\n-        private ConcurrentDictionary<string, int> blockedProjects = new();\n-\n-        private Stopwatch? _stopwatch;\n-\n-        public LoggerVerbosity Verbosity { get; set; }\n-        public string Parameters { get; set; }\n+        public ProjectContext(BuildEventContext context)\n+            : this(context.ProjectContextId)\n+        { }\n+    }\n \n-        /// <summary>\n-        /// List of events the logger needs as parameters to the <see cref=\"ConfigurableForwardingLogger\"/>.\n-        /// </summary>\n-        /// <remarks>\n-        /// If LiveLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main node using an instance of <see cref=\"ConfigurableForwardingLogger\"/> with the following parameters.\n-        /// </remarks>\n-        public static readonly string[] ConfigurableForwardingLoggerParameters =\n+    /// <summary>\n+    /// Encapsulates the per-node data shown in live node output.\n+    /// </summary>\n+    internal record NodeStatus(string Project, string? TargetFramework, string Target, Stopwatch Stopwatch)\n+    {\n+        public override string ToString()\n         {\n+            return string.IsNullOrEmpty(TargetFramework)\n+                ? $\"{Indentation}{Project} {Target} ({Stopwatch.Elapsed.TotalSeconds:F1}s)\"\n+                : $\"{Indentation}{Project} [{TargetFramework}] {Target} ({Stopwatch.Elapsed.TotalSeconds:F1}s)\";\n+        }\n+    }\n+\n+    /// <summary>\n+    /// The indentation to use for all build output.\n+    /// </summary>\n+    private const string Indentation = \"  \";",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "In most cases we're keeping track of elapsed time in the logger itself, but here we're trusting the MSBuild timestamps. Ever seen a mismatch there? I don't think I have so this might not be a problem.",
              "createdAt": "2023-04-10T19:54:02Z",
              "path": "src/MSBuild/LiveLogger/LiveLogger.cs",
              "diffHunk": "@@ -42,302 +129,608 @@ internal class LiveLogger : ILogger\n             \"HIGHMESSAGEEVENT\",\n             \"WARNINGEVENT\",\n             \"ERROREVENT\"\n-        };\n+    };\n+\n+    /// <summary>\n+    /// Default constructor, used by the MSBuild logger infra.\n+    /// </summary>\n+    public LiveLogger()\n+    {\n+        Terminal = new Terminal();\n+    }\n+\n+    /// <summary>\n+    /// Internal constructor accepting a custom <see cref=\"ITerminal\"/> for testing.\n+    /// </summary>\n+    internal LiveLogger(ITerminal terminal)\n+    {\n+        Terminal = terminal;\n+    }\n+\n+    #region INodeLogger implementation\n+\n+    /// <inheritdoc/>\n+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Minimal; set { } }\n+\n+    /// <inheritdoc/>\n+    public string Parameters { get => \"\"; set { } }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource, int nodeCount)\n+    {\n+        _nodes = new NodeStatus[nodeCount];\n+\n+        Initialize(eventSource);\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource)\n+    {\n+        eventSource.BuildStarted += BuildStarted;\n+        eventSource.BuildFinished += BuildFinished;\n+        eventSource.ProjectStarted += ProjectStarted;\n+        eventSource.ProjectFinished += ProjectFinished;\n+        eventSource.TargetStarted += TargetStarted;\n+        eventSource.TargetFinished += TargetFinished;\n+        eventSource.TaskStarted += TaskStarted;\n+\n+        eventSource.MessageRaised += MessageRaised;\n+        eventSource.WarningRaised += WarningRaised;\n+        eventSource.ErrorRaised += ErrorRaised;\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Shutdown()\n+    {\n+        Terminal.Dispose();\n+    }\n+\n+    #endregion\n+\n+    #region Logger callbacks\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildStarted\"/> callback.\n+    /// </summary>\n+    private void BuildStarted(object sender, BuildStartedEventArgs e)\n+    {\n+        _refresher = new Thread(ThreadProc);\n+        _refresher.Start();\n+\n+        _buildStartTime = e.Timestamp;\n+    }\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildFinished\"/> callback.\n+    /// </summary>\n+    private void BuildFinished(object sender, BuildFinishedEventArgs e)\n+    {\n+        _cts.Cancel();\n+        _refresher?.Join();\n+\n+        _projects.Clear();\n \n-        public LiveLogger()\n+        Terminal.BeginUpdate();\n+        try\n         {\n-            Parameters = \"\";\n+\n+            Terminal.WriteLine(\"\");\n+            Terminal.Write(\"Build \");\n+\n+            PrintBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);\n+\n+            double duration = (e.Timestamp - _buildStartTime).TotalSeconds;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "No mismatch observed so far and console logger uses these too. So I think I'd vote for not a problem.",
              "createdAt": "2023-04-11T09:27:24Z",
              "path": "src/MSBuild/LiveLogger/LiveLogger.cs",
              "diffHunk": "@@ -42,302 +129,608 @@ internal class LiveLogger : ILogger\n             \"HIGHMESSAGEEVENT\",\n             \"WARNINGEVENT\",\n             \"ERROREVENT\"\n-        };\n+    };\n+\n+    /// <summary>\n+    /// Default constructor, used by the MSBuild logger infra.\n+    /// </summary>\n+    public LiveLogger()\n+    {\n+        Terminal = new Terminal();\n+    }\n+\n+    /// <summary>\n+    /// Internal constructor accepting a custom <see cref=\"ITerminal\"/> for testing.\n+    /// </summary>\n+    internal LiveLogger(ITerminal terminal)\n+    {\n+        Terminal = terminal;\n+    }\n+\n+    #region INodeLogger implementation\n+\n+    /// <inheritdoc/>\n+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Minimal; set { } }\n+\n+    /// <inheritdoc/>\n+    public string Parameters { get => \"\"; set { } }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource, int nodeCount)\n+    {\n+        _nodes = new NodeStatus[nodeCount];\n+\n+        Initialize(eventSource);\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource)\n+    {\n+        eventSource.BuildStarted += BuildStarted;\n+        eventSource.BuildFinished += BuildFinished;\n+        eventSource.ProjectStarted += ProjectStarted;\n+        eventSource.ProjectFinished += ProjectFinished;\n+        eventSource.TargetStarted += TargetStarted;\n+        eventSource.TargetFinished += TargetFinished;\n+        eventSource.TaskStarted += TaskStarted;\n+\n+        eventSource.MessageRaised += MessageRaised;\n+        eventSource.WarningRaised += WarningRaised;\n+        eventSource.ErrorRaised += ErrorRaised;\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Shutdown()\n+    {\n+        Terminal.Dispose();\n+    }\n+\n+    #endregion\n+\n+    #region Logger callbacks\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildStarted\"/> callback.\n+    /// </summary>\n+    private void BuildStarted(object sender, BuildStartedEventArgs e)\n+    {\n+        _refresher = new Thread(ThreadProc);\n+        _refresher.Start();\n+\n+        _buildStartTime = e.Timestamp;\n+    }\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildFinished\"/> callback.\n+    /// </summary>\n+    private void BuildFinished(object sender, BuildFinishedEventArgs e)\n+    {\n+        _cts.Cancel();\n+        _refresher?.Join();\n+\n+        _projects.Clear();\n \n-        public LiveLogger()\n+        Terminal.BeginUpdate();\n+        try\n         {\n-            Parameters = \"\";\n+\n+            Terminal.WriteLine(\"\");\n+            Terminal.Write(\"Build \");\n+\n+            PrintBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);\n+\n+            double duration = (e.Timestamp - _buildStartTime).TotalSeconds;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "(not blocking this PR in any way)\r\n\r\nWe should configure using `ProjectConfigurationDescription` instead, but it's a bit chatty--maybe only the values on the right-hand side?",
              "createdAt": "2023-04-10T19:57:30Z",
              "path": "src/MSBuild/LiveLogger/LiveLogger.cs",
              "diffHunk": "@@ -42,302 +129,608 @@ internal class LiveLogger : ILogger\n             \"HIGHMESSAGEEVENT\",\n             \"WARNINGEVENT\",\n             \"ERROREVENT\"\n-        };\n+    };\n+\n+    /// <summary>\n+    /// Default constructor, used by the MSBuild logger infra.\n+    /// </summary>\n+    public LiveLogger()\n+    {\n+        Terminal = new Terminal();\n+    }\n+\n+    /// <summary>\n+    /// Internal constructor accepting a custom <see cref=\"ITerminal\"/> for testing.\n+    /// </summary>\n+    internal LiveLogger(ITerminal terminal)\n+    {\n+        Terminal = terminal;\n+    }\n+\n+    #region INodeLogger implementation\n+\n+    /// <inheritdoc/>\n+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Minimal; set { } }\n+\n+    /// <inheritdoc/>\n+    public string Parameters { get => \"\"; set { } }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource, int nodeCount)\n+    {\n+        _nodes = new NodeStatus[nodeCount];\n+\n+        Initialize(eventSource);\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource)\n+    {\n+        eventSource.BuildStarted += BuildStarted;\n+        eventSource.BuildFinished += BuildFinished;\n+        eventSource.ProjectStarted += ProjectStarted;\n+        eventSource.ProjectFinished += ProjectFinished;\n+        eventSource.TargetStarted += TargetStarted;\n+        eventSource.TargetFinished += TargetFinished;\n+        eventSource.TaskStarted += TaskStarted;\n+\n+        eventSource.MessageRaised += MessageRaised;\n+        eventSource.WarningRaised += WarningRaised;\n+        eventSource.ErrorRaised += ErrorRaised;\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Shutdown()\n+    {\n+        Terminal.Dispose();\n+    }\n+\n+    #endregion\n+\n+    #region Logger callbacks\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildStarted\"/> callback.\n+    /// </summary>\n+    private void BuildStarted(object sender, BuildStartedEventArgs e)\n+    {\n+        _refresher = new Thread(ThreadProc);\n+        _refresher.Start();\n+\n+        _buildStartTime = e.Timestamp;\n+    }\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildFinished\"/> callback.\n+    /// </summary>\n+    private void BuildFinished(object sender, BuildFinishedEventArgs e)\n+    {\n+        _cts.Cancel();\n+        _refresher?.Join();\n+\n+        _projects.Clear();\n \n-        public LiveLogger()\n+        Terminal.BeginUpdate();\n+        try\n         {\n-            Parameters = \"\";\n+\n+            Terminal.WriteLine(\"\");\n+            Terminal.Write(\"Build \");\n+\n+            PrintBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);\n+\n+            double duration = (e.Timestamp - _buildStartTime).TotalSeconds;\n+            Terminal.WriteLine($\" in {duration:F1}s\");\n         }\n+        finally\n+        {\n+            Terminal.EndUpdate();\n+        }\n+\n+        _buildHasErrors = false;\n+        _buildHasWarnings = false;\n+    }\n \n-        public void Initialize(IEventSource eventSource)\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.ProjectStarted\"/> callback.\n+    /// </summary>\n+    private void ProjectStarted(object sender, ProjectStartedEventArgs e)\n+    {\n+        var buildEventContext = e.BuildEventContext;\n+        if (buildEventContext is null)\n+        {\n+            return;\n+        }\n+\n+        ProjectContext c = new ProjectContext(buildEventContext);\n+\n+        if (_restoreContext is null)\n         {\n-            // Start the stopwatch as soon as the logger is initialized to capture\n-            // any time before the BuildStarted event\n-            _stopwatch = Stopwatch.StartNew();\n-            // Register for different events. Make sure that ConfigurableForwardingLoggerParameters are in sync with them.\n-            // Started and Finished events  \n-            eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);\n-            eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);\n-            eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);\n-            eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);\n-            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);\n-            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);\n-            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);\n-\n-            // Messages/Warnings/Errors\n-            // BuildMessageEventHandler event handler below currently process only High importance events. \n-            eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);\n-            eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);\n-            eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);\n-\n-            // Cancelled\n-            Console.CancelKeyPress += new ConsoleCancelEventHandler(console_CancelKeyPressed);\n-\n-            Task.Run(() =>\n+            if (e.GlobalProperties?.TryGetValue(\"TargetFramework\", out string? targetFramework) != true)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Filed #8651. What do you mean by right-hand side?",
              "createdAt": "2023-04-11T10:03:46Z",
              "path": "src/MSBuild/LiveLogger/LiveLogger.cs",
              "diffHunk": "@@ -42,302 +129,608 @@ internal class LiveLogger : ILogger\n             \"HIGHMESSAGEEVENT\",\n             \"WARNINGEVENT\",\n             \"ERROREVENT\"\n-        };\n+    };\n+\n+    /// <summary>\n+    /// Default constructor, used by the MSBuild logger infra.\n+    /// </summary>\n+    public LiveLogger()\n+    {\n+        Terminal = new Terminal();\n+    }\n+\n+    /// <summary>\n+    /// Internal constructor accepting a custom <see cref=\"ITerminal\"/> for testing.\n+    /// </summary>\n+    internal LiveLogger(ITerminal terminal)\n+    {\n+        Terminal = terminal;\n+    }\n+\n+    #region INodeLogger implementation\n+\n+    /// <inheritdoc/>\n+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Minimal; set { } }\n+\n+    /// <inheritdoc/>\n+    public string Parameters { get => \"\"; set { } }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource, int nodeCount)\n+    {\n+        _nodes = new NodeStatus[nodeCount];\n+\n+        Initialize(eventSource);\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource)\n+    {\n+        eventSource.BuildStarted += BuildStarted;\n+        eventSource.BuildFinished += BuildFinished;\n+        eventSource.ProjectStarted += ProjectStarted;\n+        eventSource.ProjectFinished += ProjectFinished;\n+        eventSource.TargetStarted += TargetStarted;\n+        eventSource.TargetFinished += TargetFinished;\n+        eventSource.TaskStarted += TaskStarted;\n+\n+        eventSource.MessageRaised += MessageRaised;\n+        eventSource.WarningRaised += WarningRaised;\n+        eventSource.ErrorRaised += ErrorRaised;\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Shutdown()\n+    {\n+        Terminal.Dispose();\n+    }\n+\n+    #endregion\n+\n+    #region Logger callbacks\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildStarted\"/> callback.\n+    /// </summary>\n+    private void BuildStarted(object sender, BuildStartedEventArgs e)\n+    {\n+        _refresher = new Thread(ThreadProc);\n+        _refresher.Start();\n+\n+        _buildStartTime = e.Timestamp;\n+    }\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildFinished\"/> callback.\n+    /// </summary>\n+    private void BuildFinished(object sender, BuildFinishedEventArgs e)\n+    {\n+        _cts.Cancel();\n+        _refresher?.Join();\n+\n+        _projects.Clear();\n \n-        public LiveLogger()\n+        Terminal.BeginUpdate();\n+        try\n         {\n-            Parameters = \"\";\n+\n+            Terminal.WriteLine(\"\");\n+            Terminal.Write(\"Build \");\n+\n+            PrintBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);\n+\n+            double duration = (e.Timestamp - _buildStartTime).TotalSeconds;\n+            Terminal.WriteLine($\" in {duration:F1}s\");\n         }\n+        finally\n+        {\n+            Terminal.EndUpdate();\n+        }\n+\n+        _buildHasErrors = false;\n+        _buildHasWarnings = false;\n+    }\n \n-        public void Initialize(IEventSource eventSource)\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.ProjectStarted\"/> callback.\n+    /// </summary>\n+    private void ProjectStarted(object sender, ProjectStartedEventArgs e)\n+    {\n+        var buildEventContext = e.BuildEventContext;\n+        if (buildEventContext is null)\n+        {\n+            return;\n+        }\n+\n+        ProjectContext c = new ProjectContext(buildEventContext);\n+\n+        if (_restoreContext is null)\n         {\n-            // Start the stopwatch as soon as the logger is initialized to capture\n-            // any time before the BuildStarted event\n-            _stopwatch = Stopwatch.StartNew();\n-            // Register for different events. Make sure that ConfigurableForwardingLoggerParameters are in sync with them.\n-            // Started and Finished events  \n-            eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);\n-            eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);\n-            eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);\n-            eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);\n-            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);\n-            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);\n-            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);\n-\n-            // Messages/Warnings/Errors\n-            // BuildMessageEventHandler event handler below currently process only High importance events. \n-            eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);\n-            eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);\n-            eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);\n-\n-            // Cancelled\n-            Console.CancelKeyPress += new ConsoleCancelEventHandler(console_CancelKeyPressed);\n-\n-            Task.Run(() =>\n+            if (e.GlobalProperties?.TryGetValue(\"TargetFramework\", out string? targetFramework) != true)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The old-school message is `FileNameWithoutExtension`. I think I'd prefer to keep that.",
              "createdAt": "2023-04-10T21:05:09Z",
              "path": "src/MSBuild/LiveLogger/LiveLogger.cs",
              "diffHunk": "@@ -42,302 +129,608 @@ internal class LiveLogger : ILogger\n             \"HIGHMESSAGEEVENT\",\n             \"WARNINGEVENT\",\n             \"ERROREVENT\"\n-        };\n+    };\n+\n+    /// <summary>\n+    /// Default constructor, used by the MSBuild logger infra.\n+    /// </summary>\n+    public LiveLogger()\n+    {\n+        Terminal = new Terminal();\n+    }\n+\n+    /// <summary>\n+    /// Internal constructor accepting a custom <see cref=\"ITerminal\"/> for testing.\n+    /// </summary>\n+    internal LiveLogger(ITerminal terminal)\n+    {\n+        Terminal = terminal;\n+    }\n+\n+    #region INodeLogger implementation\n+\n+    /// <inheritdoc/>\n+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Minimal; set { } }\n+\n+    /// <inheritdoc/>\n+    public string Parameters { get => \"\"; set { } }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource, int nodeCount)\n+    {\n+        _nodes = new NodeStatus[nodeCount];\n+\n+        Initialize(eventSource);\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource)\n+    {\n+        eventSource.BuildStarted += BuildStarted;\n+        eventSource.BuildFinished += BuildFinished;\n+        eventSource.ProjectStarted += ProjectStarted;\n+        eventSource.ProjectFinished += ProjectFinished;\n+        eventSource.TargetStarted += TargetStarted;\n+        eventSource.TargetFinished += TargetFinished;\n+        eventSource.TaskStarted += TaskStarted;\n+\n+        eventSource.MessageRaised += MessageRaised;\n+        eventSource.WarningRaised += WarningRaised;\n+        eventSource.ErrorRaised += ErrorRaised;\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Shutdown()\n+    {\n+        Terminal.Dispose();\n+    }\n+\n+    #endregion\n+\n+    #region Logger callbacks\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildStarted\"/> callback.\n+    /// </summary>\n+    private void BuildStarted(object sender, BuildStartedEventArgs e)\n+    {\n+        _refresher = new Thread(ThreadProc);\n+        _refresher.Start();\n+\n+        _buildStartTime = e.Timestamp;\n+    }\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildFinished\"/> callback.\n+    /// </summary>\n+    private void BuildFinished(object sender, BuildFinishedEventArgs e)\n+    {\n+        _cts.Cancel();\n+        _refresher?.Join();\n+\n+        _projects.Clear();\n \n-        public LiveLogger()\n+        Terminal.BeginUpdate();\n+        try\n         {\n-            Parameters = \"\";\n+\n+            Terminal.WriteLine(\"\");\n+            Terminal.Write(\"Build \");\n+\n+            PrintBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);\n+\n+            double duration = (e.Timestamp - _buildStartTime).TotalSeconds;\n+            Terminal.WriteLine($\" in {duration:F1}s\");\n         }\n+        finally\n+        {\n+            Terminal.EndUpdate();\n+        }\n+\n+        _buildHasErrors = false;\n+        _buildHasWarnings = false;\n+    }\n \n-        public void Initialize(IEventSource eventSource)\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.ProjectStarted\"/> callback.\n+    /// </summary>\n+    private void ProjectStarted(object sender, ProjectStartedEventArgs e)\n+    {\n+        var buildEventContext = e.BuildEventContext;\n+        if (buildEventContext is null)\n+        {\n+            return;\n+        }\n+\n+        ProjectContext c = new ProjectContext(buildEventContext);\n+\n+        if (_restoreContext is null)\n         {\n-            // Start the stopwatch as soon as the logger is initialized to capture\n-            // any time before the BuildStarted event\n-            _stopwatch = Stopwatch.StartNew();\n-            // Register for different events. Make sure that ConfigurableForwardingLoggerParameters are in sync with them.\n-            // Started and Finished events  \n-            eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);\n-            eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);\n-            eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);\n-            eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);\n-            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);\n-            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);\n-            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);\n-\n-            // Messages/Warnings/Errors\n-            // BuildMessageEventHandler event handler below currently process only High importance events. \n-            eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);\n-            eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);\n-            eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);\n-\n-            // Cancelled\n-            Console.CancelKeyPress += new ConsoleCancelEventHandler(console_CancelKeyPressed);\n-\n-            Task.Run(() =>\n+            if (e.GlobalProperties?.TryGetValue(\"TargetFramework\", out string? targetFramework) != true)\n             {\n-                Render();\n-            });\n+                targetFramework = null;\n+            }\n+            _projects[c] = new(targetFramework);\n         }\n \n-        private void Render()\n+        if (e.TargetNames == \"Restore\")\n         {\n-            // Initialize LiveLoggerBuffer\n-            TerminalBuffer.Initialize();\n-            // TODO: Fix. First line does not appear at top. Leaving empty line for now\n-            TerminalBuffer.WriteNewLine(string.Empty);\n+            _restoreContext = c;\n+            _nodes[0] = new NodeStatus(e.ProjectFile!, null, \"Restore\", _projects[c].Stopwatch);\n+        }\n+    }\n \n-            // Top line indicates the number of finished projects.\n-            TerminalBuffer.FinishedProjects = this.finishedProjects;\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.ProjectFinished\"/> callback.\n+    /// </summary>\n+    private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n+    {\n+        var buildEventContext = e.BuildEventContext;\n+        if (buildEventContext is null)\n+        {\n+            return;\n+        }\n \n-            // First render\n-            TerminalBuffer.Render();\n-            int i = 0;\n-            // Rerender periodically\n-            while (!TerminalBuffer.IsTerminated)\n+        // Mark node idle until something uses it again\n+        if (_restoreContext is null)\n+        {\n+            lock (_lock)\n             {\n-                i++;\n-                // Delay by 1/60 seconds\n-                // Use task delay to avoid blocking the task, so that keyboard input is listened continously\n-                Task.Delay((i / 60) * 1_000).ContinueWith((t) =>\n+                _nodes[NodeIndexForContext(buildEventContext)] = null;\n+            }\n+        }\n+\n+        ProjectContext c = new(buildEventContext);\n+\n+        // First check if we're done restoring.\n+        if (_restoreContext is ProjectContext restoreContext && c == restoreContext)\n+        {\n+            lock (_lock)\n+            {\n+                _restoreContext = null;\n+\n+                Stopwatch projectStopwatch = _projects[restoreContext].Stopwatch;\n+                double duration = projectStopwatch.Elapsed.TotalSeconds;\n+                projectStopwatch.Stop();\n+\n+                Terminal.BeginUpdate();\n+                try\n+                {\n+                    EraseNodes();\n+                    Terminal.WriteLine($\"Restore complete ({duration:F1}s)\");\n+                    DisplayNodes();\n+                }\n+                finally\n                 {\n-                    TerminalBuffer.FinishedProjects = this.finishedProjects;\n+                    Terminal.EndUpdate();\n+                }\n+                return;\n+            }\n+        }\n+\n+        // If this was a notable project build, we print it as completed only if it's produced an output or warnings/error.\n+        if (_projects.TryGetValue(c, out Project? project) && (project.OutputPath is not null || project.BuildMessages is not null))\n+        {\n+            lock (_lock)\n+            {\n+                Terminal.BeginUpdate();\n+                try\n+                {\n+                    EraseNodes();\n+\n+                    double duration = project.Stopwatch.Elapsed.TotalSeconds;\n+                    ReadOnlyMemory<char>? outputPath = project.OutputPath;\n \n-                    // Rerender projects only when needed\n-                    foreach (var project in projects)\n+                    Terminal.Write(Indentation);\n+\n+                    if (e.ProjectFile is not null)\n+                    {\n+                        string projectFile = Path.GetFileName(e.ProjectFile);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Fixed in 2caea92.",
              "createdAt": "2023-04-11T10:30:41Z",
              "path": "src/MSBuild/LiveLogger/LiveLogger.cs",
              "diffHunk": "@@ -42,302 +129,608 @@ internal class LiveLogger : ILogger\n             \"HIGHMESSAGEEVENT\",\n             \"WARNINGEVENT\",\n             \"ERROREVENT\"\n-        };\n+    };\n+\n+    /// <summary>\n+    /// Default constructor, used by the MSBuild logger infra.\n+    /// </summary>\n+    public LiveLogger()\n+    {\n+        Terminal = new Terminal();\n+    }\n+\n+    /// <summary>\n+    /// Internal constructor accepting a custom <see cref=\"ITerminal\"/> for testing.\n+    /// </summary>\n+    internal LiveLogger(ITerminal terminal)\n+    {\n+        Terminal = terminal;\n+    }\n+\n+    #region INodeLogger implementation\n+\n+    /// <inheritdoc/>\n+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Minimal; set { } }\n+\n+    /// <inheritdoc/>\n+    public string Parameters { get => \"\"; set { } }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource, int nodeCount)\n+    {\n+        _nodes = new NodeStatus[nodeCount];\n+\n+        Initialize(eventSource);\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Initialize(IEventSource eventSource)\n+    {\n+        eventSource.BuildStarted += BuildStarted;\n+        eventSource.BuildFinished += BuildFinished;\n+        eventSource.ProjectStarted += ProjectStarted;\n+        eventSource.ProjectFinished += ProjectFinished;\n+        eventSource.TargetStarted += TargetStarted;\n+        eventSource.TargetFinished += TargetFinished;\n+        eventSource.TaskStarted += TaskStarted;\n+\n+        eventSource.MessageRaised += MessageRaised;\n+        eventSource.WarningRaised += WarningRaised;\n+        eventSource.ErrorRaised += ErrorRaised;\n+    }\n+\n+    /// <inheritdoc/>\n+    public void Shutdown()\n+    {\n+        Terminal.Dispose();\n+    }\n+\n+    #endregion\n+\n+    #region Logger callbacks\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildStarted\"/> callback.\n+    /// </summary>\n+    private void BuildStarted(object sender, BuildStartedEventArgs e)\n+    {\n+        _refresher = new Thread(ThreadProc);\n+        _refresher.Start();\n+\n+        _buildStartTime = e.Timestamp;\n+    }\n+\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.BuildFinished\"/> callback.\n+    /// </summary>\n+    private void BuildFinished(object sender, BuildFinishedEventArgs e)\n+    {\n+        _cts.Cancel();\n+        _refresher?.Join();\n+\n+        _projects.Clear();\n \n-        public LiveLogger()\n+        Terminal.BeginUpdate();\n+        try\n         {\n-            Parameters = \"\";\n+\n+            Terminal.WriteLine(\"\");\n+            Terminal.Write(\"Build \");\n+\n+            PrintBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);\n+\n+            double duration = (e.Timestamp - _buildStartTime).TotalSeconds;\n+            Terminal.WriteLine($\" in {duration:F1}s\");\n         }\n+        finally\n+        {\n+            Terminal.EndUpdate();\n+        }\n+\n+        _buildHasErrors = false;\n+        _buildHasWarnings = false;\n+    }\n \n-        public void Initialize(IEventSource eventSource)\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.ProjectStarted\"/> callback.\n+    /// </summary>\n+    private void ProjectStarted(object sender, ProjectStartedEventArgs e)\n+    {\n+        var buildEventContext = e.BuildEventContext;\n+        if (buildEventContext is null)\n+        {\n+            return;\n+        }\n+\n+        ProjectContext c = new ProjectContext(buildEventContext);\n+\n+        if (_restoreContext is null)\n         {\n-            // Start the stopwatch as soon as the logger is initialized to capture\n-            // any time before the BuildStarted event\n-            _stopwatch = Stopwatch.StartNew();\n-            // Register for different events. Make sure that ConfigurableForwardingLoggerParameters are in sync with them.\n-            // Started and Finished events  \n-            eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);\n-            eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);\n-            eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);\n-            eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);\n-            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);\n-            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);\n-            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);\n-\n-            // Messages/Warnings/Errors\n-            // BuildMessageEventHandler event handler below currently process only High importance events. \n-            eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);\n-            eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);\n-            eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);\n-\n-            // Cancelled\n-            Console.CancelKeyPress += new ConsoleCancelEventHandler(console_CancelKeyPressed);\n-\n-            Task.Run(() =>\n+            if (e.GlobalProperties?.TryGetValue(\"TargetFramework\", out string? targetFramework) != true)\n             {\n-                Render();\n-            });\n+                targetFramework = null;\n+            }\n+            _projects[c] = new(targetFramework);\n         }\n \n-        private void Render()\n+        if (e.TargetNames == \"Restore\")\n         {\n-            // Initialize LiveLoggerBuffer\n-            TerminalBuffer.Initialize();\n-            // TODO: Fix. First line does not appear at top. Leaving empty line for now\n-            TerminalBuffer.WriteNewLine(string.Empty);\n+            _restoreContext = c;\n+            _nodes[0] = new NodeStatus(e.ProjectFile!, null, \"Restore\", _projects[c].Stopwatch);\n+        }\n+    }\n \n-            // Top line indicates the number of finished projects.\n-            TerminalBuffer.FinishedProjects = this.finishedProjects;\n+    /// <summary>\n+    /// The <see cref=\"IEventSource.ProjectFinished\"/> callback.\n+    /// </summary>\n+    private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n+    {\n+        var buildEventContext = e.BuildEventContext;\n+        if (buildEventContext is null)\n+        {\n+            return;\n+        }\n \n-            // First render\n-            TerminalBuffer.Render();\n-            int i = 0;\n-            // Rerender periodically\n-            while (!TerminalBuffer.IsTerminated)\n+        // Mark node idle until something uses it again\n+        if (_restoreContext is null)\n+        {\n+            lock (_lock)\n             {\n-                i++;\n-                // Delay by 1/60 seconds\n-                // Use task delay to avoid blocking the task, so that keyboard input is listened continously\n-                Task.Delay((i / 60) * 1_000).ContinueWith((t) =>\n+                _nodes[NodeIndexForContext(buildEventContext)] = null;\n+            }\n+        }\n+\n+        ProjectContext c = new(buildEventContext);\n+\n+        // First check if we're done restoring.\n+        if (_restoreContext is ProjectContext restoreContext && c == restoreContext)\n+        {\n+            lock (_lock)\n+            {\n+                _restoreContext = null;\n+\n+                Stopwatch projectStopwatch = _projects[restoreContext].Stopwatch;\n+                double duration = projectStopwatch.Elapsed.TotalSeconds;\n+                projectStopwatch.Stop();\n+\n+                Terminal.BeginUpdate();\n+                try\n+                {\n+                    EraseNodes();\n+                    Terminal.WriteLine($\"Restore complete ({duration:F1}s)\");\n+                    DisplayNodes();\n+                }\n+                finally\n                 {\n-                    TerminalBuffer.FinishedProjects = this.finishedProjects;\n+                    Terminal.EndUpdate();\n+                }\n+                return;\n+            }\n+        }\n+\n+        // If this was a notable project build, we print it as completed only if it's produced an output or warnings/error.\n+        if (_projects.TryGetValue(c, out Project? project) && (project.OutputPath is not null || project.BuildMessages is not null))\n+        {\n+            lock (_lock)\n+            {\n+                Terminal.BeginUpdate();\n+                try\n+                {\n+                    EraseNodes();\n+\n+                    double duration = project.Stopwatch.Elapsed.TotalSeconds;\n+                    ReadOnlyMemory<char>? outputPath = project.OutputPath;\n \n-                    // Rerender projects only when needed\n-                    foreach (var project in projects)\n+                    Terminal.Write(Indentation);\n+\n+                    if (e.ProjectFile is not null)\n+                    {\n+                        string projectFile = Path.GetFileName(e.ProjectFile);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}