{
  "number": 6311,
  "title": "Change relative path calculation",
  "body": "For some reason, the pre-caching change seems to fail in the installer repo at the build step because of a failing relative path calculation. This version seems to work.\r\n",
  "state": "MERGED",
  "createdAt": "2021-03-30T16:54:24Z",
  "updatedAt": "2021-04-02T22:16:00Z",
  "closedAt": "2021-04-02T22:15:59Z",
  "mergedAt": "2021-04-02T22:15:59Z",
  "additions": 44,
  "deletions": 22,
  "changedFiles": 2,
  "headRefName": "change-relative-path-calculation",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "437e0f5f63e398668e02bdec3707ca3839aadc94",
          "message": "Change relative path calculation",
          "committedDate": "2021-03-30T23:28:40Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1d4fea6d7f951641a25aedca09b7301671bf45c2",
          "message": "PR feedback",
          "committedDate": "2021-03-31T14:08:50Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d8c9ccc7e9f4747ad6d096a85d2be4a6a8ad5b55",
          "message": "feedback",
          "committedDate": "2021-04-01T22:40:29Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "21095b731d3e0377f5b1d5b9b78da4a1f49af698",
          "message": "refactor",
          "committedDate": "2021-04-02T13:18:18Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "457557bc3ced80c95da545132b580359b297d6f6",
          "message": "Fix index",
          "committedDate": "2021-04-02T16:37:25Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d8dbbeef1b58fda90ce0ec7fbb80fe1a52ff1ad1",
          "message": "Update src/Shared/FileUtilities.cs",
          "committedDate": "2021-04-02T18:47:57Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I assume it's a PR from msbuild into the installer that's failing tests? Can you link it here?",
        "createdAt": "2021-03-30T21:58:37Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "https://github.com/dotnet/installer/pull/10037\r\n\r\nBased on some local testing, I currently believe it needs both this and https://github.com/dotnet/msbuild/pull/6301 to go in for it to work. (I also have a couple local changes.)",
        "createdAt": "2021-03-30T21:59:46Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "The old code threw exceptions if the URI was deemed invalid for some reason. Two such cases that stood out to me:\r\nIf it contains too many slashes.\r\nIf the specified scheme name was invalid. \"The scheme name must begin with a letter and must contain only letters, digits, and the characters \".\", \"+\", or \"-\".\" That was too restrictive for, among other things, macs.",
        "createdAt": "2021-04-01T21:37:44Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Thanks @BenVillalobos for the perf check!",
        "createdAt": "2021-04-02T18:48:58Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            return StringBuilderCache.GetStringAndRelease(sb);\r\n```",
              "createdAt": "2021-03-30T22:29:26Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,80 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar);\n+            string[] splitPath = fullPath.Split(Path.DirectorySeparatorChar);\n \n-            Uri pathUri = CreateUriFromPath(path);\n-\n-            if (!pathUri.IsAbsoluteUri)\n+            if (!path.StartsWith(splitPath[0]))\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n             }\n \n-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);\n-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());\n-\n-            string result = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);\n+            int baseI = 0;\n+            int pathI = 0;\n+            while (true)\n+            {\n+                if (baseI == splitBase.Length)\n+                {\n+                    while (String.IsNullOrEmpty(splitPath[pathI]))\n+                    {\n+                        pathI++;\n+                    }\n+                    if (pathI == splitPath.Length)\n+                    {\n+                        return \".\";\n+                    }\n+                    break;\n+                }\n+                else if (pathI == splitPath.Length)\n+                {\n+                    break;\n+                }\n+                else if (String.IsNullOrEmpty(splitBase[baseI]))\n+                {\n+                    baseI++;\n+                }\n+                else if (String.IsNullOrEmpty(splitPath[pathI]))\n+                {\n+                    pathI++;\n+                }\n+                else if (splitBase[baseI].Equals(splitPath[pathI], PathComparison))\n+                {\n+                    baseI++;\n+                    pathI++;\n+                }\n+                else\n+                {\n+                    break;\n+                }\n+            }\n \n-            return result;\n+            StringBuilder sb = StringBuilderCache.Acquire();\n+            if (baseI == 0)\n+            {\n+                return fullPath;\n+            }\n+            while (baseI < splitBase.Length)\n+            {\n+                if (!String.IsNullOrEmpty(splitBase[baseI]))\n+                {\n+                    sb.Append(\"..\").Append(Path.DirectorySeparatorChar);\n+                }\n+                baseI++;\n+            }\n+            while (pathI < splitPath.Length)\n+            {\n+                if (!String.IsNullOrEmpty(splitPath[pathI]))\n+                {\n+                    sb.Append(splitPath[pathI]).Append(Path.DirectorySeparatorChar);\n+                }\n+                pathI++;\n+            }\n+            sb.Remove(sb.Length - 1, 1);\n+            return sb.ToString();",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I was trying to think of that but didn't come up with it. Thanks!",
              "createdAt": "2021-03-30T23:04:28Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,80 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar);\n+            string[] splitPath = fullPath.Split(Path.DirectorySeparatorChar);\n \n-            Uri pathUri = CreateUriFromPath(path);\n-\n-            if (!pathUri.IsAbsoluteUri)\n+            if (!path.StartsWith(splitPath[0]))\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n             }\n \n-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);\n-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());\n-\n-            string result = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);\n+            int baseI = 0;\n+            int pathI = 0;\n+            while (true)\n+            {\n+                if (baseI == splitBase.Length)\n+                {\n+                    while (String.IsNullOrEmpty(splitPath[pathI]))\n+                    {\n+                        pathI++;\n+                    }\n+                    if (pathI == splitPath.Length)\n+                    {\n+                        return \".\";\n+                    }\n+                    break;\n+                }\n+                else if (pathI == splitPath.Length)\n+                {\n+                    break;\n+                }\n+                else if (String.IsNullOrEmpty(splitBase[baseI]))\n+                {\n+                    baseI++;\n+                }\n+                else if (String.IsNullOrEmpty(splitPath[pathI]))\n+                {\n+                    pathI++;\n+                }\n+                else if (splitBase[baseI].Equals(splitPath[pathI], PathComparison))\n+                {\n+                    baseI++;\n+                    pathI++;\n+                }\n+                else\n+                {\n+                    break;\n+                }\n+            }\n \n-            return result;\n+            StringBuilder sb = StringBuilderCache.Acquire();\n+            if (baseI == 0)\n+            {\n+                return fullPath;\n+            }\n+            while (baseI < splitBase.Length)\n+            {\n+                if (!String.IsNullOrEmpty(splitBase[baseI]))\n+                {\n+                    sb.Append(\"..\").Append(Path.DirectorySeparatorChar);\n+                }\n+                baseI++;\n+            }\n+            while (pathI < splitPath.Length)\n+            {\n+                if (!String.IsNullOrEmpty(splitPath[pathI]))\n+                {\n+                    sb.Append(splitPath[pathI]).Append(Path.DirectorySeparatorChar);\n+                }\n+                pathI++;\n+            }\n+            sb.Remove(sb.Length - 1, 1);\n+            return sb.ToString();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems suspicious to me, but I have no evidence off the top of my head \ud83e\udd14",
              "createdAt": "2021-03-30T22:32:37Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,80 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar);\n+            string[] splitPath = fullPath.Split(Path.DirectorySeparatorChar);\n \n-            Uri pathUri = CreateUriFromPath(path);\n-\n-            if (!pathUri.IsAbsoluteUri)\n+            if (!path.StartsWith(splitPath[0]))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Seeing if `fullPath` starts with the current working directory could be another way of determining this, though the current method is faster.",
              "createdAt": "2021-03-30T22:45:15Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,80 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar);\n+            string[] splitPath = fullPath.Split(Path.DirectorySeparatorChar);\n \n-            Uri pathUri = CreateUriFromPath(path);\n-\n-            if (!pathUri.IsAbsoluteUri)\n+            if (!path.StartsWith(splitPath[0]))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "One possible suspicious reason is the (bug) I just found for mac/linux: the path starts with `/`, which means this will always return false. Now fixed.",
              "createdAt": "2021-03-30T23:01:55Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,80 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar);\n+            string[] splitPath = fullPath.Split(Path.DirectorySeparatorChar);\n \n-            Uri pathUri = CreateUriFromPath(path);\n-\n-            if (!pathUri.IsAbsoluteUri)\n+            if (!path.StartsWith(splitPath[0]))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why return a dot here?",
              "createdAt": "2021-03-30T22:35:28Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,80 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar);\n+            string[] splitPath = fullPath.Split(Path.DirectorySeparatorChar);\n \n-            Uri pathUri = CreateUriFromPath(path);\n-\n-            if (!pathUri.IsAbsoluteUri)\n+            if (!path.StartsWith(splitPath[0]))\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n             }\n \n-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);\n-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());\n-\n-            string result = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);\n+            int baseI = 0;\n+            int pathI = 0;\n+            while (true)\n+            {\n+                if (baseI == splitBase.Length)\n+                {\n+                    while (String.IsNullOrEmpty(splitPath[pathI]))\n+                    {\n+                        pathI++;\n+                    }\n+                    if (pathI == splitPath.Length)\n+                    {\n+                        return \".\";",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "That's for if you want a relative path from a directory to itself, so if we determine that every part is the same, just return the self-referential dot. Your base path should always be a directory, so we don't have to worry about a relative path from a file to itself.",
              "createdAt": "2021-03-30T23:03:46Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,80 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar);\n+            string[] splitPath = fullPath.Split(Path.DirectorySeparatorChar);\n \n-            Uri pathUri = CreateUriFromPath(path);\n-\n-            if (!pathUri.IsAbsoluteUri)\n+            if (!path.StartsWith(splitPath[0]))\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n             }\n \n-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);\n-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());\n-\n-            string result = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);\n+            int baseI = 0;\n+            int pathI = 0;\n+            while (true)\n+            {\n+                if (baseI == splitBase.Length)\n+                {\n+                    while (String.IsNullOrEmpty(splitPath[pathI]))\n+                    {\n+                        pathI++;\n+                    }\n+                    if (pathI == splitPath.Length)\n+                    {\n+                        return \".\";",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "We should have a test case for this. It would be worth throwing that test case into the code prior to this change to make sure that's how it previously worked.",
              "createdAt": "2021-03-31T16:54:17Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,80 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar);\n+            string[] splitPath = fullPath.Split(Path.DirectorySeparatorChar);\n \n-            Uri pathUri = CreateUriFromPath(path);\n-\n-            if (!pathUri.IsAbsoluteUri)\n+            if (!path.StartsWith(splitPath[0]))\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n             }\n \n-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);\n-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());\n-\n-            string result = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);\n+            int baseI = 0;\n+            int pathI = 0;\n+            while (true)\n+            {\n+                if (baseI == splitBase.Length)\n+                {\n+                    while (String.IsNullOrEmpty(splitPath[pathI]))\n+                    {\n+                        pathI++;\n+                    }\n+                    if (pathI == splitPath.Length)\n+                    {\n+                        return \".\";",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Prior to this change, it would return `..\\<folder>`:\r\n![image](https://user-images.githubusercontent.com/12969783/113184310-de7c9680-9209-11eb-9e53-fe8477b16f43.png)\r\n\r\nThat's a valid relative path but not the optimal one. This returns a better path.",
              "createdAt": "2021-03-31T17:14:53Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,80 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar);\n+            string[] splitPath = fullPath.Split(Path.DirectorySeparatorChar);\n \n-            Uri pathUri = CreateUriFromPath(path);\n-\n-            if (!pathUri.IsAbsoluteUri)\n+            if (!path.StartsWith(splitPath[0]))\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n             }\n \n-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);\n-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());\n-\n-            string result = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);\n+            int baseI = 0;\n+            int pathI = 0;\n+            while (true)\n+            {\n+                if (baseI == splitBase.Length)\n+                {\n+                    while (String.IsNullOrEmpty(splitPath[pathI]))\n+                    {\n+                        pathI++;\n+                    }\n+                    if (pathI == splitPath.Length)\n+                    {\n+                        return \".\";",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Some comments around if statements like this would help readability.",
              "createdAt": "2021-03-30T22:36:15Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,80 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar);\n+            string[] splitPath = fullPath.Split(Path.DirectorySeparatorChar);\n \n-            Uri pathUri = CreateUriFromPath(path);\n-\n-            if (!pathUri.IsAbsoluteUri)\n+            if (!path.StartsWith(splitPath[0]))\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n             }\n \n-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);\n-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());\n-\n-            string result = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);\n+            int baseI = 0;\n+            int pathI = 0;\n+            while (true)\n+            {\n+                if (baseI == splitBase.Length)\n+                {\n+                    while (String.IsNullOrEmpty(splitPath[pathI]))\n+                    {\n+                        pathI++;\n+                    }\n+                    if (pathI == splitPath.Length)\n+                    {\n+                        return \".\";\n+                    }\n+                    break;\n+                }\n+                else if (pathI == splitPath.Length)\n+                {\n+                    break;\n+                }\n+                else if (String.IsNullOrEmpty(splitBase[baseI]))\n+                {\n+                    baseI++;\n+                }\n+                else if (String.IsNullOrEmpty(splitPath[pathI]))\n+                {\n+                    pathI++;\n+                }\n+                else if (splitBase[baseI].Equals(splitPath[pathI], PathComparison))\n+                {\n+                    baseI++;\n+                    pathI++;\n+                }\n+                else\n+                {\n+                    break;\n+                }\n+            }\n \n-            return result;\n+            StringBuilder sb = StringBuilderCache.Acquire();\n+            if (baseI == 0)",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Calling `Split` with `StringSplitOptions.RemoveEmptyEntries` should be a faster way of filtering out empty components.",
              "createdAt": "2021-03-31T07:26:33Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,72 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar).Where(x => !String.IsNullOrEmpty(x)).ToArray();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Had to make it char[] because it seems that Split(char, StringSplitOptions) isn't available on .NET Framework. I don't think ifdefs are worth it here. Still a lot nicer than what I had before; thanks!",
              "createdAt": "2021-03-31T14:11:17Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,72 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar).Where(x => !String.IsNullOrEmpty(x)).ToArray();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What guarantees that the string is not just slashes, meaning that the code won't crash with out of bounds access? The split above uses only the primary directory separator char on the current platform and will accept e.g. forward slashes on Windows.",
              "createdAt": "2021-03-31T07:35:23Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,72 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(Path.DirectorySeparatorChar).Where(x => !String.IsNullOrEmpty(x)).ToArray();\n+            string[] splitPath = fullPath.Split(Path.DirectorySeparatorChar).Where(x => !String.IsNullOrEmpty(x)).ToArray();\n \n-            Uri pathUri = CreateUriFromPath(path);\n+            ErrorUtilities.VerifyThrow(splitPath.Length > 0, \"Cannot call MakeRelative on a path of only slashes.\");\n \n-            if (!pathUri.IsAbsoluteUri)\n+            // On a mac, the path could start with any number of slashes and still be valid. We have to check them all.\n+            int indexOfFirstNonSlashChar = 0;\n+            while (IsSlash(path[indexOfFirstNonSlashChar]))\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                indexOfFirstNonSlashChar++;\n+            }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The char array is worth caching. And looks like we already do it in `Constants.DirectorySeparatorChar`!",
              "createdAt": "2021-04-01T21:43:20Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,72 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(new char[] { Path.DirectorySeparatorChar }, StringSplitOptions.RemoveEmptyEntries);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I would expect\r\n```suggestion\r\n            sb.Length = sb.Length - 1;\r\n```\r\nto be slightly faster and also easier to read.",
              "createdAt": "2021-04-01T21:49:20Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,72 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(new char[] { Path.DirectorySeparatorChar }, StringSplitOptions.RemoveEmptyEntries);\n+            string[] splitPath = fullPath.Split(new char[] { Path.DirectorySeparatorChar }, StringSplitOptions.RemoveEmptyEntries);\n \n-            Uri pathUri = CreateUriFromPath(path);\n+            ErrorUtilities.VerifyThrow(splitPath.Length > 0, \"Cannot call MakeRelative on a path of only slashes.\");\n \n-            if (!pathUri.IsAbsoluteUri)\n+            // On a mac, the path could start with any number of slashes and still be valid. We have to check them all.\n+            int indexOfFirstNonSlashChar = 0;\n+            while (path[indexOfFirstNonSlashChar] == Path.DirectorySeparatorChar)\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                indexOfFirstNonSlashChar++;\n+            }\n+            if (path.IndexOf(splitPath[0]) != indexOfFirstNonSlashChar)\n+            {\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n             }\n \n-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);\n-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());\n+            int baseI = 0;\n+            int pathI = 0;\n+            while (true)\n+            {\n+                if (baseI == splitBase.Length)\n+                {\n+                    if (pathI == splitPath.Length)\n+                    {\n+                        return \".\";\n+                    }\n+                    break;\n+                }\n+                else if (pathI == splitPath.Length)\n+                {\n+                    break;\n+                }\n+                else if (splitBase[baseI].Equals(splitPath[pathI], PathComparison))\n+                {\n+                    baseI++;\n+                    pathI++;\n+                }\n+                else\n+                {\n+                    break;\n+                }\n+            }\n \n-            string result = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);\n+            StringBuilder sb = StringBuilderCache.Acquire();\n \n-            return result;\n+            // If the paths have no component in common, the only valid relative path is the full path.\n+            if (baseI == 0)\n+            {\n+                return fullPath;\n+            }\n+            while (baseI < splitBase.Length)\n+            {\n+                sb.Append(\"..\").Append(Path.DirectorySeparatorChar);\n+                baseI++;\n+            }\n+            while (pathI < splitPath.Length)\n+            {\n+                sb.Append(splitPath[pathI]).Append(Path.DirectorySeparatorChar);\n+                pathI++;\n+            }\n+            sb.Remove(sb.Length - 1, 1);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I would find the following much easier to read. As long as it's equivalent, please double-check:\r\n\r\n```suggestion\r\n            while (baseI < splitBase.Length && pathI < splitPath.Length && splitBase[baseI].Equals(splitPath[pathI], PathComparison))\r\n            {\r\n                    baseI++;\r\n                    pathI++;\r\n            }\r\n            if (baseI == splitBase.Length && pathI == splitPath.Length)\r\n            {\r\n                   return \".\";\r\n            }\r\n  }\r\n```",
              "createdAt": "2021-04-01T22:00:07Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,72 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            string[] splitBase = fullBase.Split(new char[] { Path.DirectorySeparatorChar }, StringSplitOptions.RemoveEmptyEntries);\n+            string[] splitPath = fullPath.Split(new char[] { Path.DirectorySeparatorChar }, StringSplitOptions.RemoveEmptyEntries);\n \n-            Uri pathUri = CreateUriFromPath(path);\n+            ErrorUtilities.VerifyThrow(splitPath.Length > 0, \"Cannot call MakeRelative on a path of only slashes.\");\n \n-            if (!pathUri.IsAbsoluteUri)\n+            // On a mac, the path could start with any number of slashes and still be valid. We have to check them all.\n+            int indexOfFirstNonSlashChar = 0;\n+            while (path[indexOfFirstNonSlashChar] == Path.DirectorySeparatorChar)\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                indexOfFirstNonSlashChar++;\n+            }\n+            if (path.IndexOf(splitPath[0]) != indexOfFirstNonSlashChar)\n+            {\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n             }\n \n-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);\n-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());\n+            int baseI = 0;\n+            int pathI = 0;\n+            while (true)\n+            {\n+                if (baseI == splitBase.Length)\n+                {\n+                    if (pathI == splitPath.Length)\n+                    {\n+                        return \".\";\n+                    }\n+                    break;\n+                }\n+                else if (pathI == splitPath.Length)\n+                {\n+                    break;\n+                }\n+                else if (splitBase[baseI].Equals(splitPath[pathI], PathComparison))\n+                {\n+                    baseI++;\n+                    pathI++;\n+                }\n+                else\n+                {\n+                    break;\n+                }\n+            }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit (last one, promise!): Since the two integers are always incremented together, consider having only one and changing the `while (baseI < ...` and `while (pathI < ...` below to for loops. Totally optional, no perf impact, just a matter of subjective taste.",
              "createdAt": "2021-04-02T11:25:39Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,58 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n+\n+            string[] splitBase = fullBase.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);\n+            string[] splitPath = fullPath.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            ErrorUtilities.VerifyThrow(splitPath.Length > 0, \"Cannot call MakeRelative on a path of only slashes.\");\n \n-            Uri pathUri = CreateUriFromPath(path);\n+            // On a mac, the path could start with any number of slashes and still be valid. We have to check them all.\n+            int indexOfFirstNonSlashChar = 0;\n+            while (path[indexOfFirstNonSlashChar] == Path.DirectorySeparatorChar)\n+            {\n+                indexOfFirstNonSlashChar++;\n+            }\n+            if (path.IndexOf(splitPath[0]) != indexOfFirstNonSlashChar)\n+            {\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n+            }\n \n-            if (!pathUri.IsAbsoluteUri)\n+            int baseI = 0;\n+            int pathI = 0;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Yep! This PR came out unusually janky, so I appreciate all the refactoring suggestions.",
              "createdAt": "2021-04-02T13:19:16Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,58 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n+\n+            string[] splitBase = fullBase.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);\n+            string[] splitPath = fullPath.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            ErrorUtilities.VerifyThrow(splitPath.Length > 0, \"Cannot call MakeRelative on a path of only slashes.\");\n \n-            Uri pathUri = CreateUriFromPath(path);\n+            // On a mac, the path could start with any number of slashes and still be valid. We have to check them all.\n+            int indexOfFirstNonSlashChar = 0;\n+            while (path[indexOfFirstNonSlashChar] == Path.DirectorySeparatorChar)\n+            {\n+                indexOfFirstNonSlashChar++;\n+            }\n+            if (path.IndexOf(splitPath[0]) != indexOfFirstNonSlashChar)\n+            {\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n+            }\n \n-            if (!pathUri.IsAbsoluteUri)\n+            int baseI = 0;\n+            int pathI = 0;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "hyper-nit-9000: newline here.",
              "createdAt": "2021-04-02T18:19:24Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,54 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n+\n+            string[] splitBase = fullBase.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);\n+            string[] splitPath = fullPath.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            ErrorUtilities.VerifyThrow(splitPath.Length > 0, \"Cannot call MakeRelative on a path of only slashes.\");\n \n-            Uri pathUri = CreateUriFromPath(path);\n+            // On a mac, the path could start with any number of slashes and still be valid. We have to check them all.\n+            int indexOfFirstNonSlashChar = 0;\n+            while (path[indexOfFirstNonSlashChar] == Path.DirectorySeparatorChar)\n+            {\n+                indexOfFirstNonSlashChar++;\n+            }\n+            if (path.IndexOf(splitPath[0]) != indexOfFirstNonSlashChar)\n+            {\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n+            }\n \n-            if (!pathUri.IsAbsoluteUri)\n+            int index = 0;\n+            while (index < splitBase.Length && index < splitPath.Length && splitBase[index].Equals(splitPath[index], PathComparison))\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                index++;\n             }\n \n-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);\n-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());\n+            if (index == splitBase.Length && index == splitPath.Length)\n+            {\n+                return \".\";\n+            }\n+            // If the paths have no component in common, the only valid relative path is the full path.",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            }\r\n            \r\n            // If the paths have no component in common, the only valid relative path is the full path.\r\n```",
              "createdAt": "2021-04-02T18:47:52Z",
              "path": "src/Shared/FileUtilities.cs",
              "diffHunk": "@@ -1031,27 +1031,54 @@ internal static string MakeRelative(string basePath, string path)\n             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));\n             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));\n \n-            if (basePath.Length == 0)\n-            {\n-                return path;\n-            }\n+            string fullBase = Path.GetFullPath(basePath);\n+            string fullPath = Path.GetFullPath(path);\n+\n+            string[] splitBase = fullBase.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);\n+            string[] splitPath = fullPath.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);\n \n-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException\n+            ErrorUtilities.VerifyThrow(splitPath.Length > 0, \"Cannot call MakeRelative on a path of only slashes.\");\n \n-            Uri pathUri = CreateUriFromPath(path);\n+            // On a mac, the path could start with any number of slashes and still be valid. We have to check them all.\n+            int indexOfFirstNonSlashChar = 0;\n+            while (path[indexOfFirstNonSlashChar] == Path.DirectorySeparatorChar)\n+            {\n+                indexOfFirstNonSlashChar++;\n+            }\n+            if (path.IndexOf(splitPath[0]) != indexOfFirstNonSlashChar)\n+            {\n+                // path was already relative so just return it\n+                return FixFilePath(path);\n+            }\n \n-            if (!pathUri.IsAbsoluteUri)\n+            int index = 0;\n+            while (index < splitBase.Length && index < splitPath.Length && splitBase[index].Equals(splitPath[index], PathComparison))\n             {\n-                // the path is already a relative url, we will just normalize it...\n-                pathUri = new Uri(baseUri, pathUri);\n+                index++;\n             }\n \n-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);\n-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());\n+            if (index == splitBase.Length && index == splitPath.Length)\n+            {\n+                return \".\";\n+            }\n+            // If the paths have no component in common, the only valid relative path is the full path.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}