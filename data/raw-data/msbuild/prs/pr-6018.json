{
  "number": 6018,
  "title": "Added Include/Exclude filtering capability to Unzip Task (#5169)",
  "body": "Fixes #5169\r\n\r\n### Context\r\nSee #5169\r\n\r\n### Changes Made\r\nUnzip Task now has \"Include\" and \"Exclude\" optional properties to pass a pattern to filter archive entries to be unzipped.\r\n\r\n### Testing\r\nAdded following tests:\r\n- CanUnzip_WithIncludeFilter\r\n- CanUnzip_WithExcludeFilter\r\n- CanUnzip_WithIncludeAndExcludeFilter\r\n\r\nThese 3 test the ability to include/exclude files from the archive unzip.\r\n\r\n### Notes\r\nUnable to translate the resources to all languages. Can someone provide guidance/translations?",
  "state": "MERGED",
  "createdAt": "2021-01-11T14:36:55Z",
  "updatedAt": "2021-02-07T10:19:19Z",
  "closedAt": "2021-02-06T21:02:43Z",
  "mergedAt": "2021-02-06T21:02:43Z",
  "additions": 564,
  "deletions": 33,
  "changedFiles": 20,
  "headRefName": "feature/UnzipFiltering",
  "isDraft": false,
  "author": {
    "login": "IvanLieckens"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "99879408f2908a1178ffdcf9c976b44e89ccf4af",
          "message": "Added Include/Exclude RegEx filtering capability to Unzip Task",
          "committedDate": "2021-01-11T14:21:26Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "08cb0d135ddb548112f812b96a75dbf40db625eb",
          "message": "Added Exclude Filter Unit Test for Unzip Task",
          "committedDate": "2021-01-11T14:31:10Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "86c25c2e90240e05734af2ba2c4e5e4c40fbeb4c",
          "message": "Adjusted Unit Test according to feedback",
          "committedDate": "2021-01-14T18:09:44Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fbc0a4f314787387c4d2880f2cd0e1da6ec48cec",
          "message": "Applied resource string suggestion",
          "committedDate": "2021-01-14T18:10:35Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e71e37f6a4ef30dd4a1647e3f41185c8605e9b87",
          "message": "Adjusted Include and Exclude to IncludePattern and ExcludePattern as per Review Suggestion",
          "committedDate": "2021-01-20T13:24:40Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "152aadc5a43f5c8389adfeaf0d4be7971ace4d7b",
          "message": "Adjusted property names to \"Include\" and \"Exclude\" and altered them to regular glob matching instead of RegEx",
          "committedDate": "2021-01-26T18:31:02Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "941d7eb5620562e697f3476ee9b7b1dab539d331",
          "message": "Unzip task unit tests for pattern parsing",
          "committedDate": "2021-01-27T06:59:00Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "658c23a91d30d78bca72197f2c6d1785962c4a88",
          "message": "Name adjustment to better match actual verification",
          "committedDate": "2021-01-28T07:53:43Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8164bfdf08382dfb6573ecc0ae46216d1756f0c5",
          "message": "Attempt to fail valid character path tests on MacOS and Linux",
          "committedDate": "2021-01-28T08:53:16Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1f1aa6d56ecca82e22537740883c37f9dfbca493",
          "message": "Made InvalidPath Unzip unit tests platform specific",
          "committedDate": "2021-01-28T10:16:03Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5e489e2cdef310963bd4c294313b07cd35aea8cf",
          "message": "Improved property or item reference detection\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-01-29T08:31:40Z",
          "author": {
            "name": "IvanLieckens",
            "email": "ivanlieckens@hotmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9fedb34fb31c2769aca86f5e749b06a0d20d7142",
          "message": "Invalid path detection before splitting improvement",
          "committedDate": "2021-01-29T08:39:59Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "62d56a9aabbd6bee7a6811f968f5dfea5f235803",
          "message": "Added | to invalid path testing",
          "committedDate": "2021-01-29T08:40:22Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "76a94f14c795d789455fa7bb0d6de0af709f9bed",
          "message": "Removed platform specific attribute on Invalid Path Character tests in Unzip unit tests",
          "committedDate": "2021-01-29T08:44:15Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e9e0f5fed07bb43963bd9c32bba1f2de01a8352e",
          "message": "Perf improvement detecting include pattern match\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-01-29T08:46:35Z",
          "author": {
            "name": "IvanLieckens",
            "email": "ivanlieckens@hotmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8608320c23ddfa7b4571bee570c72a568f208023",
          "message": "Perf improvement detecting exclude pattern match\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-01-29T08:46:51Z",
          "author": {
            "name": "IvanLieckens",
            "email": "ivanlieckens@hotmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e4d0286a63fd89dc302453174c7c2774ade01e8d",
          "message": "Small FileMatcher correction, Removed return on parsing for patterns of Unzip Task",
          "committedDate": "2021-01-29T09:18:54Z",
          "author": {
            "name": "Ivan Lieckens (Sitecore)",
            "email": "ivan.lieckens@sitecore.com"
          }
        }
      },
      {
        "commit": {
          "oid": "164e8e7c8ed246b0b5ee45c36f8824ec5dd37974",
          "message": "Updated Include description\n\nCo-authored-by: Mihai Codoban <micodoba@microsoft.com>",
          "committedDate": "2021-01-29T23:17:44Z",
          "author": {
            "name": "IvanLieckens",
            "email": "ivanlieckens@hotmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "081c1796da9fd8d812e54f1d295f7143e0dc49e1",
          "message": "Updated Exclude description\n\nCo-authored-by: Mihai Codoban <micodoba@microsoft.com>",
          "committedDate": "2021-01-29T23:18:22Z",
          "author": {
            "name": "IvanLieckens",
            "email": "ivanlieckens@hotmail.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Don't worry about the failing PR builds--I believe #6019 will fix that.\r\n\r\n> Unable to translate the resources to all languages. Can someone provide guidance/translations?\r\n\r\nThanks, but no need to worry! A Microsoft-funded team will do the translations. Details in the [loc doc](https://github.com/dotnet/msbuild/blob/master/documentation/wiki/Localization.md) if you're interested.",
        "createdAt": "2021-01-11T17:40:21Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "/azp run",
        "createdAt": "2021-01-11T22:04:38Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2021-01-11T22:04:47Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "Thanks @IvanLieckens!",
        "createdAt": "2021-02-06T21:03:03Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n    <value>Did not unzip file \"{0}\" because it didn't match the include or because it matched the exclude filter.</value>\r\n```",
              "createdAt": "2021-01-13T19:48:14Z",
              "path": "src/Tasks/Resources/Strings.resx",
              "diffHunk": "@@ -2792,6 +2792,9 @@\n   <data name=\"Unzip.DidNotUnzipBecauseOfFileMatch\">\n     <value>Did not unzip from file \"{0}\" to file \"{1}\" because the \"{2}\" parameter was set to \"{3}\" in the project and the files' sizes and timestamps match.</value>\n   </data>\n+  <data name=\"Unzip.DidNotUnzipBecauseOfFilter\">\n+    <value>Did not unzip file \"{0}\" because it didn't match the include or matched the exclude filter.</value>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "No problem, I have applied it in the new commits",
              "createdAt": "2021-01-14T18:11:24Z",
              "path": "src/Tasks/Resources/Strings.resx",
              "diffHunk": "@@ -2792,6 +2792,9 @@\n   <data name=\"Unzip.DidNotUnzipBecauseOfFileMatch\">\n     <value>Did not unzip from file \"{0}\" to file \"{1}\" because the \"{2}\" parameter was set to \"{3}\" in the project and the files' sizes and timestamps match.</value>\n   </data>\n+  <data name=\"Unzip.DidNotUnzipBecauseOfFilter\">\n+    <value>Did not unzip file \"{0}\" because it didn't match the include or matched the exclude filter.</value>",
              "author": {
                "login": "IvanLieckens"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would you mind modifying this test to use wildcards such that two are included, of which one is also excluded; a third is also excluded; and a fourth isn't excluded or included?",
              "createdAt": "2021-01-13T19:49:57Z",
              "path": "src/Tasks.UnitTests/Unzip_Tests.cs",
              "diffHunk": "@@ -214,5 +214,95 @@ public void LogsErrorIfSourceFileDoesNotExist()\n                 _mockEngine.Log.ShouldContain(\"MSB3932\", () => _mockEngine.Log);\n             }\n         }\n+\n+        [Fact]\n+        public void CanUnzip_WithIncludeFilter()\n+        {\n+            using (TestEnvironment testEnvironment = TestEnvironment.Create())\n+            {\n+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);\n+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);\n+                testEnvironment.CreateFile(source, \"BE78A17D30144B549D21F71D5C633F7D.txt\", \"file1\");\n+                testEnvironment.CreateFile(source, \"A04FF4B88DF14860B7C73A8E75A4FB76.txt\", \"file2\");\n+\n+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));\n+\n+                Unzip unzip = new Unzip\n+                                  {\n+                                      BuildEngine = _mockEngine,\n+                                      DestinationFolder = new TaskItem(destination.Path),\n+                                      OverwriteReadOnlyFiles = true,\n+                                      SkipUnchangedFiles = false,\n+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },\n+                                      Include = \"BE78A17D30144B549D21F71D5C633F7D\"\n+                                  };\n+\n+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);\n+\n+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, \"BE78A17D30144B549D21F71D5C633F7D.txt\"), () => _mockEngine.Log);\n+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, \"A04FF4B88DF14860B7C73A8E75A4FB76.txt\"), () => _mockEngine.Log);\n+            }\n+        }\n+\n+        [Fact]\n+        public void CanUnzip_WithExcludeFilter()\n+        {\n+            using (TestEnvironment testEnvironment = TestEnvironment.Create())\n+            {\n+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);\n+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);\n+                testEnvironment.CreateFile(source, \"BE78A17D30144B549D21F71D5C633F7D.txt\", \"file1\");\n+                testEnvironment.CreateFile(source, \"A04FF4B88DF14860B7C73A8E75A4FB76.txt\", \"file2\");\n+\n+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));\n+\n+                Unzip unzip = new Unzip\n+                                  {\n+                                      BuildEngine = _mockEngine,\n+                                      DestinationFolder = new TaskItem(destination.Path),\n+                                      OverwriteReadOnlyFiles = true,\n+                                      SkipUnchangedFiles = false,\n+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },\n+                                      Exclude = \"BE78A17D30144B549D21F71D5C633F7D\"\n+                                  };\n+\n+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);\n+\n+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, \"BE78A17D30144B549D21F71D5C633F7D.txt\"), () => _mockEngine.Log);\n+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, \"A04FF4B88DF14860B7C73A8E75A4FB76.txt\"), () => _mockEngine.Log);\n+            }\n+        }\n+\n+        [Fact]\n+        public void CanUnzip_WithIncludeAndExcludeFilter()\n+        {\n+            using (TestEnvironment testEnvironment = TestEnvironment.Create())\n+            {\n+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);\n+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Not at all, I hope this new version is more what you were looking for?",
              "createdAt": "2021-01-14T18:12:42Z",
              "path": "src/Tasks.UnitTests/Unzip_Tests.cs",
              "diffHunk": "@@ -214,5 +214,95 @@ public void LogsErrorIfSourceFileDoesNotExist()\n                 _mockEngine.Log.ShouldContain(\"MSB3932\", () => _mockEngine.Log);\n             }\n         }\n+\n+        [Fact]\n+        public void CanUnzip_WithIncludeFilter()\n+        {\n+            using (TestEnvironment testEnvironment = TestEnvironment.Create())\n+            {\n+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);\n+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);\n+                testEnvironment.CreateFile(source, \"BE78A17D30144B549D21F71D5C633F7D.txt\", \"file1\");\n+                testEnvironment.CreateFile(source, \"A04FF4B88DF14860B7C73A8E75A4FB76.txt\", \"file2\");\n+\n+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));\n+\n+                Unzip unzip = new Unzip\n+                                  {\n+                                      BuildEngine = _mockEngine,\n+                                      DestinationFolder = new TaskItem(destination.Path),\n+                                      OverwriteReadOnlyFiles = true,\n+                                      SkipUnchangedFiles = false,\n+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },\n+                                      Include = \"BE78A17D30144B549D21F71D5C633F7D\"\n+                                  };\n+\n+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);\n+\n+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, \"BE78A17D30144B549D21F71D5C633F7D.txt\"), () => _mockEngine.Log);\n+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, \"A04FF4B88DF14860B7C73A8E75A4FB76.txt\"), () => _mockEngine.Log);\n+            }\n+        }\n+\n+        [Fact]\n+        public void CanUnzip_WithExcludeFilter()\n+        {\n+            using (TestEnvironment testEnvironment = TestEnvironment.Create())\n+            {\n+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);\n+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);\n+                testEnvironment.CreateFile(source, \"BE78A17D30144B549D21F71D5C633F7D.txt\", \"file1\");\n+                testEnvironment.CreateFile(source, \"A04FF4B88DF14860B7C73A8E75A4FB76.txt\", \"file2\");\n+\n+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));\n+\n+                Unzip unzip = new Unzip\n+                                  {\n+                                      BuildEngine = _mockEngine,\n+                                      DestinationFolder = new TaskItem(destination.Path),\n+                                      OverwriteReadOnlyFiles = true,\n+                                      SkipUnchangedFiles = false,\n+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },\n+                                      Exclude = \"BE78A17D30144B549D21F71D5C633F7D\"\n+                                  };\n+\n+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);\n+\n+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, \"BE78A17D30144B549D21F71D5C633F7D.txt\"), () => _mockEngine.Log);\n+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, \"A04FF4B88DF14860B7C73A8E75A4FB76.txt\"), () => _mockEngine.Log);\n+            }\n+        }\n+\n+        [Fact]\n+        public void CanUnzip_WithIncludeAndExcludeFilter()\n+        {\n+            using (TestEnvironment testEnvironment = TestEnvironment.Create())\n+            {\n+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);\n+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);",
              "author": {
                "login": "IvanLieckens"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If we stick with regular expressions for this, we should change the names for `Exclude` and `Include` as they are \"default\" msbuild names. ie. items are added via Include and the patterns differ between them and regular expressions. A suggested name during PR review was `IncludePattern` & `ExcludePattern`",
              "createdAt": "2021-01-15T16:51:23Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1217,6 +1217,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso\n         public Unzip() { }\n         [Microsoft.Build.Framework.RequiredAttribute]\n         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }\n+        public string Exclude { get { throw null; } set { } }\n+        public string Include { get { throw null; } set { } }",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "This makes sense, the functionality differs indeed. I have pushed the change.",
              "createdAt": "2021-01-20T13:25:33Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1217,6 +1217,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso\n         public Unzip() { }\n         [Microsoft.Build.Framework.RequiredAttribute]\n         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }\n+        public string Exclude { get { throw null; } set { } }\n+        public string Include { get { throw null; } set { } }",
              "author": {
                "login": "IvanLieckens"
              }
            },
            {
              "body": "@BenVillalobos, I thought we'd agreed globs were more MSBuild-y than regex? Confused by your comment.",
              "createdAt": "2021-01-20T15:52:07Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1217,6 +1217,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso\n         public Unzip() { }\n         [Microsoft.Build.Framework.RequiredAttribute]\n         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }\n+        public string Exclude { get { throw null; } set { } }\n+        public string Include { get { throw null; } set { } }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "We did, I posted this while we were talking about it, hence the \"If we stick with regular expressions.\" The current implementation is still regex, is this how we process includes and excludes normally?",
              "createdAt": "2021-01-20T19:15:50Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1217,6 +1217,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso\n         public Unzip() { }\n         [Microsoft.Build.Framework.RequiredAttribute]\n         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }\n+        public string Exclude { get { throw null; } set { } }\n+        public string Include { get { throw null; } set { } }",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "No; we use globs.",
              "createdAt": "2021-01-20T22:54:47Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1217,6 +1217,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso\n         public Unzip() { }\n         [Microsoft.Build.Framework.RequiredAttribute]\n         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }\n+        public string Exclude { get { throw null; } set { } }\n+        public string Include { get { throw null; } set { } }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "So we're in agreement \ud83d\ude42\r\n\r\n@IvanLieckens the to-do list here would be:\r\n- [ ] Rename ExcludePattern and IncludePattern back to Exclude and Include (sorry)\r\n   - We wanted ExcludePattern if we were sticking with RegEx, but it turns out we don't want to use regex here\r\n- [ ] Change the implementation to expect * parse a glob pattern",
              "createdAt": "2021-01-20T23:45:15Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1217,6 +1217,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso\n         public Unzip() { }\n         [Microsoft.Build.Framework.RequiredAttribute]\n         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }\n+        public string Exclude { get { throw null; } set { } }\n+        public string Include { get { throw null; } set { } }",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "@BenVillalobos ok, thank you for the clearing up. Is there a good example in MSBuild of how you'd like this to function I can use as a lead for the implementation? Just want to make sure that it feels native without any quirks.",
              "createdAt": "2021-01-21T09:07:55Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1217,6 +1217,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso\n         public Unzip() { }\n         [Microsoft.Build.Framework.RequiredAttribute]\n         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }\n+        public string Exclude { get { throw null; } set { } }\n+        public string Include { get { throw null; } set { } }",
              "author": {
                "login": "IvanLieckens"
              }
            },
            {
              "body": "Check out `Expander.cs`, `ExpandIntoItemsLeaveEscaped` may have what you're looking for.",
              "createdAt": "2021-01-21T22:23:30Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1217,6 +1217,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso\n         public Unzip() { }\n         [Microsoft.Build.Framework.RequiredAttribute]\n         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }\n+        public string Exclude { get { throw null; } set { } }\n+        public string Include { get { throw null; } set { } }",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "`ItemSpec.cs` is also relevant here.",
              "createdAt": "2021-01-22T00:58:57Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1217,6 +1217,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso\n         public Unzip() { }\n         [Microsoft.Build.Framework.RequiredAttribute]\n         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }\n+        public string Exclude { get { throw null; } set { } }\n+        public string Include { get { throw null; } set { } }",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Thank you @BenVillalobos , I studied Expander and ItemSpec but they were outside of reach for the Tasks assembly and I did not want to introduce dependencies so I leveraged FileMatcher to handle the normalization and verification of the globs and paths. It does not support property references due to this. I hope this matches with your expected behavior.",
              "createdAt": "2021-01-26T18:35:09Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1217,6 +1217,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso\n         public Unzip() { }\n         [Microsoft.Build.Framework.RequiredAttribute]\n         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }\n+        public string Exclude { get { throw null; } set { } }\n+        public string Include { get { throw null; } set { } }",
              "author": {
                "login": "IvanLieckens"
              }
            },
            {
              "body": "[MSBuildGlob](https://github.com/dotnet/msbuild/blob/master/src/Build/Globbing/MSBuildGlob.cs) would have been great here, but unfortunately it's not visible by tasks. :(",
              "createdAt": "2021-01-29T19:31:34Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1217,6 +1217,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso\n         public Unzip() { }\n         [Microsoft.Build.Framework.RequiredAttribute]\n         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }\n+        public string Exclude { get { throw null; } set { } }\n+        public string Include { get { throw null; } set { } }",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        private static readonly string[] s_propertyAndItemReferences = { \"$(\", \"@(\" };\r\n```\r\n\r\nItems are referred to with an `@` and properties with `$`.",
              "createdAt": "2021-01-27T21:15:07Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -31,6 +31,8 @@ internal class FileMatcher\n         private static readonly char[] s_wildcardCharacters = { '*', '?' };\n         private static readonly char[] s_wildcardAndSemicolonCharacters = { '*', '?', ';' };\n \n+        private static readonly string[] s_propertyReferences = { \"$(\", \"@(\" };",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Thanks, I just copied from the old name of the method. I adjusted the naming now to these.",
              "createdAt": "2021-01-28T07:52:58Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -31,6 +31,8 @@ internal class FileMatcher\n         private static readonly char[] s_wildcardCharacters = { '*', '?' };\n         private static readonly char[] s_wildcardAndSemicolonCharacters = { '*', '?', ';' };\n \n+        private static readonly string[] s_propertyReferences = { \"$(\", \"@(\" };",
              "author": {
                "login": "IvanLieckens"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        internal static bool HasPropertyOrItemReferences(string filespec)\r\n```\r\n\r\nAnother option would be to create a `HasPropertyReferences` that checks for `$(` and a separate `HasItemReferences` that checks for `@(`. Though I don't feel too strongly about that extra suggestion since filematcher already has something like `s_wildcardAndSemicolonCharacters` and `HasWildcardsOrSemicolon`.",
              "createdAt": "2021-01-27T21:17:33Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -180,18 +180,33 @@ internal static bool HasWildcards(string filespec)\n         }\n \n         /// <summary>\n-        /// Determines whether the given path has any wild card characters or any semicolons.\n+        /// Determines whether the given path has any wild card characters or semicolons.\n+        /// </summary>\n+        internal static bool HasWildcardsOrSemicolon(string filespec)\n+        {\n+            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);\n+        }\n+\n+        /// <summary>\n+        /// Determines whether the given path has any wild card characters, any semicolons or any property references.\n         /// </summary>\n         internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec)\n         {\n             return\n \n                 (-1 != filespec.IndexOfAny(s_wildcardAndSemicolonCharacters)) ||\n-                filespec.Contains(\"$(\") ||\n-                filespec.Contains(\"@(\")\n+                HasPropertyReferences(filespec)\n                 ;\n         }\n \n+        /// <summary>\n+        /// Determines whether the given path has any property references.\n+        /// </summary>\n+        internal static bool HasPropertyReferences(string filespec)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Yeah, I split up the existing method that was already there to allow more granular calling and identification. But I didn't want to introduce too many new methods if they weren't needed.",
              "createdAt": "2021-01-28T07:46:32Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -180,18 +180,33 @@ internal static bool HasWildcards(string filespec)\n         }\n \n         /// <summary>\n-        /// Determines whether the given path has any wild card characters or any semicolons.\n+        /// Determines whether the given path has any wild card characters or semicolons.\n+        /// </summary>\n+        internal static bool HasWildcardsOrSemicolon(string filespec)\n+        {\n+            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);\n+        }\n+\n+        /// <summary>\n+        /// Determines whether the given path has any wild card characters, any semicolons or any property references.\n         /// </summary>\n         internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec)\n         {\n             return\n \n                 (-1 != filespec.IndexOfAny(s_wildcardAndSemicolonCharacters)) ||\n-                filespec.Contains(\"$(\") ||\n-                filespec.Contains(\"@(\")\n+                HasPropertyReferences(filespec)\n                 ;\n         }\n \n+        /// <summary>\n+        /// Determines whether the given path has any property references.\n+        /// </summary>\n+        internal static bool HasPropertyReferences(string filespec)",
              "author": {
                "login": "IvanLieckens"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there any significant perf difference between using `Aggregate` and `-1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters)`?",
              "createdAt": "2021-01-27T21:19:11Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -180,18 +180,33 @@ internal static bool HasWildcards(string filespec)\n         }\n \n         /// <summary>\n-        /// Determines whether the given path has any wild card characters or any semicolons.\n+        /// Determines whether the given path has any wild card characters or semicolons.\n+        /// </summary>\n+        internal static bool HasWildcardsOrSemicolon(string filespec)\n+        {\n+            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Were you thinking Aggregate with a function like Aggregate(false, (acc, ch) => acc || s_wildcardAndSemicolonCharacters.Contains(ch))? That would almost certainly be slower than this.",
              "createdAt": "2021-01-27T23:21:44Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -180,18 +180,33 @@ internal static bool HasWildcards(string filespec)\n         }\n \n         /// <summary>\n-        /// Determines whether the given path has any wild card characters or any semicolons.\n+        /// Determines whether the given path has any wild card characters or semicolons.\n+        /// </summary>\n+        internal static bool HasWildcardsOrSemicolon(string filespec)\n+        {\n+            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I was thinking the difference between `s_propertyReferences.Aggregate(false, (current, propertyReference) => current | filespec.Contains(propertyReference));` and `-1 != filespec.LastIndexOfAny(s_propertyReferences);`\r\n\r\nIf the former is more efficient, we can change `HasWildcardsOrSemicolon` to do the same.",
              "createdAt": "2021-01-28T00:06:23Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -180,18 +180,33 @@ internal static bool HasWildcards(string filespec)\n         }\n \n         /// <summary>\n-        /// Determines whether the given path has any wild card characters or any semicolons.\n+        /// Determines whether the given path has any wild card characters or semicolons.\n+        /// </summary>\n+        internal static bool HasWildcardsOrSemicolon(string filespec)\n+        {\n+            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I believe LastIndexOf is going to be faster but I had to use the aggregate for the other because the s_wildcardAndSemicolonCharacters are `char[]` and the s_propertyReferences are `string[]`. Would need to setup a microbenchmark to validate.",
              "createdAt": "2021-01-28T07:59:24Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -180,18 +180,33 @@ internal static bool HasWildcards(string filespec)\n         }\n \n         /// <summary>\n-        /// Determines whether the given path has any wild card characters or any semicolons.\n+        /// Determines whether the given path has any wild card characters or semicolons.\n+        /// </summary>\n+        internal static bool HasWildcardsOrSemicolon(string filespec)\n+        {\n+            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);",
              "author": {
                "login": "IvanLieckens"
              }
            },
            {
              "body": "Ah! I didn't realize that we couldn't replicate what was already there. This looks fine to me \ud83d\udc4d",
              "createdAt": "2021-01-28T23:10:01Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -180,18 +180,33 @@ internal static bool HasWildcards(string filespec)\n         }\n \n         /// <summary>\n-        /// Determines whether the given path has any wild card characters or any semicolons.\n+        /// Determines whether the given path has any wild card characters or semicolons.\n+        /// </summary>\n+        internal static bool HasWildcardsOrSemicolon(string filespec)\n+        {\n+            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Forgind improved it further now to use Any() :)",
              "createdAt": "2021-01-29T09:26:23Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -180,18 +180,33 @@ internal static bool HasWildcards(string filespec)\n         }\n \n         /// <summary>\n-        /// Determines whether the given path has any wild card characters or any semicolons.\n+        /// Determines whether the given path has any wild card characters or semicolons.\n+        /// </summary>\n+        internal static bool HasWildcardsOrSemicolon(string filespec)\n+        {\n+            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);",
              "author": {
                "login": "IvanLieckens"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            return s_propertyAndItemReferences.Any(ref=> filespec.Contains(ref));\r\n```\r\n",
              "createdAt": "2021-01-28T16:27:32Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -180,18 +180,33 @@ internal static bool HasWildcards(string filespec)\n         }\n \n         /// <summary>\n-        /// Determines whether the given path has any wild card characters or any semicolons.\n+        /// Determines whether the given path has any wild card characters or semicolons.\n+        /// </summary>\n+        internal static bool HasWildcardsOrSemicolon(string filespec)\n+        {\n+            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);\n+        }\n+\n+        /// <summary>\n+        /// Determines whether the given path has any wild card characters, any semicolons or any property references.\n         /// </summary>\n         internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec)\n         {\n             return\n \n                 (-1 != filespec.IndexOfAny(s_wildcardAndSemicolonCharacters)) ||\n-                filespec.Contains(\"$(\") ||\n-                filespec.Contains(\"@(\")\n+                HasPropertyOrItemReferences(filespec)\n                 ;\n         }\n \n+        /// <summary>\n+        /// Determines whether the given path has any property references.\n+        /// </summary>\n+        internal static bool HasPropertyOrItemReferences(string filespec)\n+        {\n+            return s_propertyAndItemReferences.Aggregate(false, (current, propertyReference) => current | filespec.Contains(propertyReference));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nMove this before the split?",
              "createdAt": "2021-01-28T16:32:12Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -212,5 +275,41 @@ private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry, FileInfo fileInfo)\n                    && zipArchiveEntry.LastWriteTime == fileInfo.LastWriteTimeUtc\n                    && zipArchiveEntry.Length == fileInfo.Length;\n         }\n+\n+        private bool ParseIncludeExclude()\n+        {\n+            return ParsePattern(Include, out _includePatterns) && ParsePattern(Exclude, out _excludePatterns);\n+        }\n+\n+        private bool ParsePattern(string pattern, out string[] patterns)\n+        {\n+            bool result = false;\n+            patterns = Array.Empty<string>();\n+            if (string.IsNullOrWhiteSpace(pattern))\n+            {\n+                result = true;\n+            }\n+            else if (FileMatcher.HasPropertyOrItemReferences(pattern))\n+            {\n+                // Supporting property references would require access to Expander which is unavailable in Microsoft.Build.Tasks\n+                Log.LogErrorWithCodeFromResources(\"Unzip.ErrorParsingPatternPropertyReferences\", pattern);\n+            }\n+            else\n+            {\n+                patterns = pattern.Contains(';')\n+                               ? pattern.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries).Select(FileMatcher.Normalize).ToArray()\n+                               : new[] { pattern };\n+                if (patterns.Any(p => p.IndexOfAny(Path.GetInvalidPathChars()) != -1))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This is very strange...the docs for Path.GetInvalidPathChars explicitly says that \"on Windows-based desktop platforms, invalid path characters might include...less than (<), greater than (>), pipe (|),...\" yet trying that out on my Windows-based desktop platform, it didn't. I submitted an issue about it: https://github.com/dotnet/dotnet-api-docs/issues/5292\r\n\r\nI'd use FileUtilities.InvalidPathChars and modify the tests to target | or a character 1-31 and make it the same across all platforms.",
              "createdAt": "2021-01-28T17:01:38Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -212,5 +275,41 @@ private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry, FileInfo fileInfo)\n                    && zipArchiveEntry.LastWriteTime == fileInfo.LastWriteTimeUtc\n                    && zipArchiveEntry.Length == fileInfo.Length;\n         }\n+\n+        private bool ParseIncludeExclude()\n+        {\n+            return ParsePattern(Include, out _includePatterns) && ParsePattern(Exclude, out _excludePatterns);\n+        }\n+\n+        private bool ParsePattern(string pattern, out string[] patterns)\n+        {\n+            bool result = false;\n+            patterns = Array.Empty<string>();\n+            if (string.IsNullOrWhiteSpace(pattern))\n+            {\n+                result = true;\n+            }\n+            else if (FileMatcher.HasPropertyOrItemReferences(pattern))\n+            {\n+                // Supporting property references would require access to Expander which is unavailable in Microsoft.Build.Tasks\n+                Log.LogErrorWithCodeFromResources(\"Unzip.ErrorParsingPatternPropertyReferences\", pattern);\n+            }\n+            else\n+            {\n+                patterns = pattern.Contains(';')\n+                               ? pattern.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries).Select(FileMatcher.Normalize).ToArray()\n+                               : new[] { pattern };\n+                if (patterns.Any(p => p.IndexOfAny(Path.GetInvalidPathChars()) != -1))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That's very interesting, I changed to using the FileUtilities.InvalidPathChars and added a pipe in the name in the test whilst removing the platform specific flag.",
              "createdAt": "2021-01-29T08:43:42Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -212,5 +275,41 @@ private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry, FileInfo fileInfo)\n                    && zipArchiveEntry.LastWriteTime == fileInfo.LastWriteTimeUtc\n                    && zipArchiveEntry.Length == fileInfo.Length;\n         }\n+\n+        private bool ParseIncludeExclude()\n+        {\n+            return ParsePattern(Include, out _includePatterns) && ParsePattern(Exclude, out _excludePatterns);\n+        }\n+\n+        private bool ParsePattern(string pattern, out string[] patterns)\n+        {\n+            bool result = false;\n+            patterns = Array.Empty<string>();\n+            if (string.IsNullOrWhiteSpace(pattern))\n+            {\n+                result = true;\n+            }\n+            else if (FileMatcher.HasPropertyOrItemReferences(pattern))\n+            {\n+                // Supporting property references would require access to Expander which is unavailable in Microsoft.Build.Tasks\n+                Log.LogErrorWithCodeFromResources(\"Unzip.ErrorParsingPatternPropertyReferences\", pattern);\n+            }\n+            else\n+            {\n+                patterns = pattern.Contains(';')\n+                               ? pattern.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries).Select(FileMatcher.Normalize).ToArray()\n+                               : new[] { pattern };\n+                if (patterns.Any(p => p.IndexOfAny(Path.GetInvalidPathChars()) != -1))",
              "author": {
                "login": "IvanLieckens"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                result = _includePatterns.All(pattern => !FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern, true));\r\n```",
              "createdAt": "2021-01-28T16:35:32Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -199,6 +230,38 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector\n             }\n         }\n \n+        /// <summary>\n+        /// Determines whether or not a file should be skipped when unzipping by filtering.\n+        /// </summary>\n+        /// <param name=\"zipArchiveEntry\">The <see cref=\"ZipArchiveEntry\"/> object containing information about the file in the zip archive.</param>\n+        /// <returns><code>true</code> if the file should be skipped, otherwise <code>false</code>.</returns>\n+        private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry)\n+        {\n+            bool result = false;\n+\n+            if (_includePatterns.Length > 0)\n+            {\n+                result |= _includePatterns.Aggregate(\n+                    false,\n+                    (current, pattern) => current | !FileMatcher.IsMatch(\n+                                              FileMatcher.Normalize(zipArchiveEntry.FullName),\n+                                              pattern,\n+                                              true));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                result |= _excludePatterns.Any(pattern => FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern, true));\r\n```",
              "createdAt": "2021-01-28T16:37:15Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -199,6 +230,38 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector\n             }\n         }\n \n+        /// <summary>\n+        /// Determines whether or not a file should be skipped when unzipping by filtering.\n+        /// </summary>\n+        /// <param name=\"zipArchiveEntry\">The <see cref=\"ZipArchiveEntry\"/> object containing information about the file in the zip archive.</param>\n+        /// <returns><code>true</code> if the file should be skipped, otherwise <code>false</code>.</returns>\n+        private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry)\n+        {\n+            bool result = false;\n+\n+            if (_includePatterns.Length > 0)\n+            {\n+                result |= _includePatterns.Aggregate(\n+                    false,\n+                    (current, pattern) => current | !FileMatcher.IsMatch(\n+                                              FileMatcher.Normalize(zipArchiveEntry.FullName),\n+                                              pattern,\n+                                              true));\n+            }\n+\n+            if (_excludePatterns.Length > 0)\n+            {\n+                result |= _excludePatterns.Aggregate(\n+                    false,\n+                    (current, pattern) => current | FileMatcher.IsMatch(\n+                                              FileMatcher.Normalize(zipArchiveEntry.FullName),\n+                                              pattern,\n+                                              true));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why does this return anything? Looking at ParsePattern below, it either throws an error or returns true. That means that this either throws an error or returns true. I was momentarily confused when I thought it was skipping everything if there were no include/exclude present, so I'd just remove that bit.",
              "createdAt": "2021-01-28T16:44:48Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -212,5 +275,41 @@ private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry, FileInfo fileInfo)\n                    && zipArchiveEntry.LastWriteTime == fileInfo.LastWriteTimeUtc\n                    && zipArchiveEntry.Length == fileInfo.Length;\n         }\n+\n+        private bool ParseIncludeExclude()",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Ok, I removed the return and swapped to using `Log.HasLoggedErrors` to jump out preventing further execution when the Task is misconfigured.",
              "createdAt": "2021-01-29T09:10:08Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -212,5 +275,41 @@ private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry, FileInfo fileInfo)\n                    && zipArchiveEntry.LastWriteTime == fileInfo.LastWriteTimeUtc\n                    && zipArchiveEntry.Length == fileInfo.Length;\n         }\n+\n+        private bool ParseIncludeExclude()",
              "author": {
                "login": "IvanLieckens"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\ud83d\udc4d Nice!",
              "createdAt": "2021-01-29T16:57:58Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -204,7 +204,7 @@ internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filesp\n         /// </summary>\n         internal static bool HasPropertyOrItemReferences(string filespec)\n         {\n-            return s_propertyAndItemReferences.Any(ref=> filespec.Contains(ref));\n+            return s_propertyAndItemReferences.Any(filespec.Contains);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        /// Gets or sets an MSBuild glob expression that will be used to determine which files to include being unzipped from the archive.\r\n```",
              "createdAt": "2021-01-29T19:44:15Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -49,6 +61,16 @@ public sealed class Unzip : TaskExtension, ICancelableTask\n         [Required]\n         public ITaskItem[] SourceFiles { get; set; }\n \n+        /// <summary>\n+        /// Gets or sets a glob expression that will be used to determine which files to include being unzipped from the archive.",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        /// Gets or sets an MSBuild glob expression that will be used to determine which files to exclude from being unzipped from the archive.\r\n```",
              "createdAt": "2021-01-29T19:44:33Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -49,6 +61,16 @@ public sealed class Unzip : TaskExtension, ICancelableTask\n         [Required]\n         public ITaskItem[] SourceFiles { get; set; }\n \n+        /// <summary>\n+        /// Gets or sets a glob expression that will be used to determine which files to include being unzipped from the archive.\n+        /// </summary>\n+        public string Include { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a glob expression that will be used to determine which files to exclude from being unzipped from the archive.",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      }
    ]
  }
}