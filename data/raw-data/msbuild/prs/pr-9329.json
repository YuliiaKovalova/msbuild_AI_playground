{
  "number": 9329,
  "title": "Update Project Cache docs to reflect new functionality",
  "body": "Update Project Cache docs to reflect new functionality\r\n\r\nMost the new stuff was added in #9214, but some other changes have gone in before then as well which made these docs out of date.",
  "state": "MERGED",
  "createdAt": "2023-10-13T21:16:08Z",
  "updatedAt": "2024-01-03T15:02:10Z",
  "closedAt": "2024-01-03T15:02:03Z",
  "mergedAt": "2024-01-03T15:02:03Z",
  "additions": 160,
  "deletions": 81,
  "changedFiles": 1,
  "headRefName": "project-cache-docs",
  "isDraft": false,
  "author": {
    "login": "dfederm"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "AR-May"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "854abd2b0c67875b8de3294e51da586ca7d5cbbd",
          "message": "Update Project Cache docs to reflect new functionality",
          "committedDate": "2023-10-13T21:13:14Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1e78fa90a4987b15709d472c62d4ceec1c9ee143",
          "message": "PR feedback",
          "committedDate": "2023-10-20T17:52:58Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cd782c5c3b40416eb4d2302ee89ab5edd7b73cb9",
          "message": "PR feedback\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-12-20T21:22:27Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b344365ea37a48db0dd8f006a66c47b888220067",
          "message": "PR feedback\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-12-20T21:22:40Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dd06d5490b998d14464908e211427f81bf005ef7",
          "message": "PR feedback\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-12-20T21:22:52Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "97a51c298464e81e013e2746b795d061232aae2f",
          "message": "PR feedback\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-12-20T21:23:04Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "95220f68ec71553261512aed5316e71bff96749e",
          "message": "PR feedback",
          "committedDate": "2023-12-20T21:26:29Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: plugin **to** add",
              "createdAt": "2023-10-13T21:32:00Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: Programmatic",
              "createdAt": "2023-10-13T21:33:42Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: before **the** build",
              "createdAt": "2023-10-13T21:35:43Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: format `BuildRequestData`",
              "createdAt": "2023-10-13T21:45:22Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: programmatic",
              "createdAt": "2023-10-13T21:46:19Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should you also mention the required bitness of MSBuild for `ReportFileAccesses`?",
              "createdAt": "2023-10-13T21:47:53Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: making it easy",
              "createdAt": "2023-10-13T21:50:27Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: will events?",
              "createdAt": "2023-10-13T21:55:13Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.",
              "author": {
                "login": "DmitriyShepelev"
              }
            },
            {
              "body": "Should be \"will emit events\"",
              "createdAt": "2023-10-20T17:22:43Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: scheduler not receives?",
              "createdAt": "2023-10-13T21:56:59Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and node communication is also over a pipe, and pipes are async, there is some coordination required for ensuring that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.\n+\n+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler not recieves as \"project finished\" event over the node communication pipe, it will wait to determine that the project is actually finished until it also recieves the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler deterines the project is finished and schedules new work to the worker node (which would trigger new file accesses).",
              "author": {
                "login": "DmitriyShepelev"
              }
            },
            {
              "body": "Nit: **determines**",
              "createdAt": "2023-10-13T21:57:29Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and node communication is also over a pipe, and pipes are async, there is some coordination required for ensuring that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.\n+\n+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler not recieves as \"project finished\" event over the node communication pipe, it will wait to determine that the project is actually finished until it also recieves the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler deterines the project is finished and schedules new work to the worker node (which would trigger new file accesses).",
              "author": {
                "login": "DmitriyShepelev"
              }
            },
            {
              "body": "\"scheduler node receives\"\r\n\r\nI also spelled receives wrong. Twice.",
              "createdAt": "2023-10-20T17:24:02Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and node communication is also over a pipe, and pipes are async, there is some coordination required for ensuring that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.\n+\n+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler not recieves as \"project finished\" event over the node communication pipe, it will wait to determine that the project is actually finished until it also recieves the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler deterines the project is finished and schedules new work to the worker node (which would trigger new file accesses).",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: This list item is terminated by a period but the other items aren't",
              "createdAt": "2023-10-13T21:59:37Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and node communication is also over a pipe, and pipes are async, there is some coordination required for ensuring that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.\n+\n+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler not recieves as \"project finished\" event over the node communication pipe, it will wait to determine that the project is actually finished until it also recieves the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler deterines the project is finished and schedules new work to the worker node (which would trigger new file accesses).\n+\n+# Plugin implementation guidance and simple example design\n+\n+The following will describe a very basic (and not very correct) plugin implementation.\n+\n+In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build (\"if Tuesday copy this file\"), but if considered caching would be quite infeasible.\n+\n+## Fingerprinting\n+\n+A \"fingerprint\" describes each unique input which went into the building a build request. The more granular the fingerprint, the more \"correct\" the caching is, as described above.\n+\n+In this example, we will only consider the following as inputs, and thus part of the fingerprint:\n+- The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)\n+- The content hash of the project file\n+- The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`. ",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: add them **to** a cache",
              "createdAt": "2023-10-13T22:06:17Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and node communication is also over a pipe, and pipes are async, there is some coordination required for ensuring that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.\n+\n+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler not recieves as \"project finished\" event over the node communication pipe, it will wait to determine that the project is actually finished until it also recieves the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler deterines the project is finished and schedules new work to the worker node (which would trigger new file accesses).\n+\n+# Plugin implementation guidance and simple example design\n+\n+The following will describe a very basic (and not very correct) plugin implementation.\n+\n+In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build (\"if Tuesday copy this file\"), but if considered caching would be quite infeasible.\n+\n+## Fingerprinting\n+\n+A \"fingerprint\" describes each unique input which went into the building a build request. The more granular the fingerprint, the more \"correct\" the caching is, as described above.\n+\n+In this example, we will only consider the following as inputs, and thus part of the fingerprint:\n+- The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)\n+- The content hash of the project file\n+- The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`. \n+- The fingerprint of referenced projects\n+\n+Again, this is for illustrative purposes and a real implementation will want to use additional state for fingerprinting depending on the environment in which it runs and the correctness requirements.\n+\n+It can make sense for a fingerprint to be a hash of its inputs, so effectively is a byte array which can be represented by a string.\n+\n+At the beginning of the build, the plugin's `BeginBuildAsync` method will be called. As part of the `CacheContext`, the plugin is either given the graph or the entry points to the graph for which it can create a graph from. The plugin can use this graph to do some initial processing, like predicting various inputs which a project is likely to use. This information can then be stored to help construct a fingerprint for a build request later.\n+\n+## Cache storage\n+\n+Any storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/en-us/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.\n+\n+For illustration purposes, consider our cache implementation is based on a simple filesystem which a separate metadata and content directory inside it. Under the metadata dir, each file is a metadata file where the filename matches the fingerprint it's describing. Under the content dir, each file is a content file where the filename matches the hash of the content itself.\n+\n+## First build (cache population)\n+\n+In the very first build there will be no cache hits so the \"cache add\" scenario will be most relevant here.\n+\n+For a given project, `GetCacheResultAsync` will be invoked, but will end up returning a cache miss since the cache is empty.\n+\n+MSBuild will then build the project normally but under a detoured worker node. Because of this, the plugin will recieve `HandleFileAccess` and `HandleProcess` events. In this example implementation we will ignore `HandleProcess`. For `HandleFileAccess`, the plugin will simply store all `FileAccessData`s for a `FileAccessContext` to build up a list of all file accesses during the build. The plugin may decide to avoid storing the entire `FileAccessData` and instead just peel off the data it finds relevant (eg. paths, whether it was a read or write, etc).\n+\n+Once MSBuild is done building the project, it will call the plugin's `HandleProjectFinishedAsync`. Now the plugin knows the project is done and can process the results and add them a cache. In general it's only useful to cache successful results, so the plugin should filter out non-success results. The `FileAccessContext` provided can then be used to retrieve the list of `FileAccessData` the plugin recieved. These `FileAccessData` can be processed to understand which files were read and writted as part of the build.",
              "author": {
                "login": "DmitriyShepelev"
              }
            },
            {
              "body": "Nit; **written**",
              "createdAt": "2023-10-13T22:07:00Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and node communication is also over a pipe, and pipes are async, there is some coordination required for ensuring that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.\n+\n+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler not recieves as \"project finished\" event over the node communication pipe, it will wait to determine that the project is actually finished until it also recieves the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler deterines the project is finished and schedules new work to the worker node (which would trigger new file accesses).\n+\n+# Plugin implementation guidance and simple example design\n+\n+The following will describe a very basic (and not very correct) plugin implementation.\n+\n+In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build (\"if Tuesday copy this file\"), but if considered caching would be quite infeasible.\n+\n+## Fingerprinting\n+\n+A \"fingerprint\" describes each unique input which went into the building a build request. The more granular the fingerprint, the more \"correct\" the caching is, as described above.\n+\n+In this example, we will only consider the following as inputs, and thus part of the fingerprint:\n+- The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)\n+- The content hash of the project file\n+- The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`. \n+- The fingerprint of referenced projects\n+\n+Again, this is for illustrative purposes and a real implementation will want to use additional state for fingerprinting depending on the environment in which it runs and the correctness requirements.\n+\n+It can make sense for a fingerprint to be a hash of its inputs, so effectively is a byte array which can be represented by a string.\n+\n+At the beginning of the build, the plugin's `BeginBuildAsync` method will be called. As part of the `CacheContext`, the plugin is either given the graph or the entry points to the graph for which it can create a graph from. The plugin can use this graph to do some initial processing, like predicting various inputs which a project is likely to use. This information can then be stored to help construct a fingerprint for a build request later.\n+\n+## Cache storage\n+\n+Any storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/en-us/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.\n+\n+For illustration purposes, consider our cache implementation is based on a simple filesystem which a separate metadata and content directory inside it. Under the metadata dir, each file is a metadata file where the filename matches the fingerprint it's describing. Under the content dir, each file is a content file where the filename matches the hash of the content itself.\n+\n+## First build (cache population)\n+\n+In the very first build there will be no cache hits so the \"cache add\" scenario will be most relevant here.\n+\n+For a given project, `GetCacheResultAsync` will be invoked, but will end up returning a cache miss since the cache is empty.\n+\n+MSBuild will then build the project normally but under a detoured worker node. Because of this, the plugin will recieve `HandleFileAccess` and `HandleProcess` events. In this example implementation we will ignore `HandleProcess`. For `HandleFileAccess`, the plugin will simply store all `FileAccessData`s for a `FileAccessContext` to build up a list of all file accesses during the build. The plugin may decide to avoid storing the entire `FileAccessData` and instead just peel off the data it finds relevant (eg. paths, whether it was a read or write, etc).\n+\n+Once MSBuild is done building the project, it will call the plugin's `HandleProjectFinishedAsync`. Now the plugin knows the project is done and can process the results and add them a cache. In general it's only useful to cache successful results, so the plugin should filter out non-success results. The `FileAccessContext` provided can then be used to retrieve the list of `FileAccessData` the plugin recieved. These `FileAccessData` can be processed to understand which files were read and writted as part of the build.",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: **it** describes",
              "createdAt": "2023-10-13T22:09:40Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and node communication is also over a pipe, and pipes are async, there is some coordination required for ensuring that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.\n+\n+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler not recieves as \"project finished\" event over the node communication pipe, it will wait to determine that the project is actually finished until it also recieves the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler deterines the project is finished and schedules new work to the worker node (which would trigger new file accesses).\n+\n+# Plugin implementation guidance and simple example design\n+\n+The following will describe a very basic (and not very correct) plugin implementation.\n+\n+In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build (\"if Tuesday copy this file\"), but if considered caching would be quite infeasible.\n+\n+## Fingerprinting\n+\n+A \"fingerprint\" describes each unique input which went into the building a build request. The more granular the fingerprint, the more \"correct\" the caching is, as described above.\n+\n+In this example, we will only consider the following as inputs, and thus part of the fingerprint:\n+- The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)\n+- The content hash of the project file\n+- The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`. \n+- The fingerprint of referenced projects\n+\n+Again, this is for illustrative purposes and a real implementation will want to use additional state for fingerprinting depending on the environment in which it runs and the correctness requirements.\n+\n+It can make sense for a fingerprint to be a hash of its inputs, so effectively is a byte array which can be represented by a string.\n+\n+At the beginning of the build, the plugin's `BeginBuildAsync` method will be called. As part of the `CacheContext`, the plugin is either given the graph or the entry points to the graph for which it can create a graph from. The plugin can use this graph to do some initial processing, like predicting various inputs which a project is likely to use. This information can then be stored to help construct a fingerprint for a build request later.\n+\n+## Cache storage\n+\n+Any storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/en-us/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.\n+\n+For illustration purposes, consider our cache implementation is based on a simple filesystem which a separate metadata and content directory inside it. Under the metadata dir, each file is a metadata file where the filename matches the fingerprint it's describing. Under the content dir, each file is a content file where the filename matches the hash of the content itself.\n+\n+## First build (cache population)\n+\n+In the very first build there will be no cache hits so the \"cache add\" scenario will be most relevant here.\n+\n+For a given project, `GetCacheResultAsync` will be invoked, but will end up returning a cache miss since the cache is empty.\n+\n+MSBuild will then build the project normally but under a detoured worker node. Because of this, the plugin will recieve `HandleFileAccess` and `HandleProcess` events. In this example implementation we will ignore `HandleProcess`. For `HandleFileAccess`, the plugin will simply store all `FileAccessData`s for a `FileAccessContext` to build up a list of all file accesses during the build. The plugin may decide to avoid storing the entire `FileAccessData` and instead just peel off the data it finds relevant (eg. paths, whether it was a read or write, etc).\n+\n+Once MSBuild is done building the project, it will call the plugin's `HandleProjectFinishedAsync`. Now the plugin knows the project is done and can process the results and add them a cache. In general it's only useful to cache successful results, so the plugin should filter out non-success results. The `FileAccessContext` provided can then be used to retrieve the list of `FileAccessData` the plugin recieved. These `FileAccessData` can be processed to understand which files were read and writted as part of the build.\n+\n+In our example, we can use the read files to construct a fingerprint for the build request. We can then add the files written during the build (\"outputs\") to some cache implementation.\n+\n+The plugin would then create some metadata describing the outputs (eg. the paths and hashes) and the serialized `BuildResult`, and associate it with the fingerprint and put that assocation in the cache.\n+\n+To illustrate this, consider a project with fingerprint `F` which wrote a single file `O` with hash `H` and had `BuildResult R`. The plugin could create a metadata file `M` which describes the outputs of the build (the path and hash of `O`) as well as the serialized `R`. Using the cache implementation described above, the plugin would write the following two files to the cache:\n+ - `metadata/F -> M`\n+ - `content/H -> O`\n+\n+This can then be used for future builds.\n+\n+ ## Second Build (cache hits)\n+ \n+ In the second build we have a populated cache and so it could be possible to get cache hits.\n+\n+ For a given project, `GetCacheResultAsync` will be invoked. The plugin can fingerprint the request and use that fingerprint to look up in its cache. If the cache entry exists, it can declare a cache hit.\n+\n+In the example above, if all inputs are the same as in the first build, we should end up with a fingerprint `F`. We look up in the metadata part of the cache (file `metadata/F`) and find that it exists. This means we have a cache hit. We can fetch that metadata `M` from the cache and find that is describes the output with path `O` and hash `H`. The plugin would then copy `content/H` to `O` and return the deserialized `BuildResult R` contained in `M` to MSBuild.",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should there be a statement/section describing the performance cost of Detours/cache add overall?",
              "createdAt": "2023-10-13T22:12:55Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.",
              "author": {
                "login": "DmitriyShepelev"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nontrivial knowledge might possibly be assumed from readers of this document, but still I feel it can possibly benefit from some adjustments:\r\n * topo sort -> topological sort (at least the first mention of it)\r\n * `since it is assumed that users issue build requests in reverse toposort order` - possibly just `since it is assumed that build requests will be issued in reverse toposort order`? I'm bit confused by the explicit mention of the user. But it might likely be just lack of understanding on my side\r\n * `This happens based on the requirement of using /graph` - such requirement is mentioned only later in this doc (the `Enabling from command line` section) - so it feels slightly confusing. Maybe linking that requirements secion here might add clarity.\r\n * `Plugins can function with and without a static graph` - This feels as contradicting the previous point\r\n\r\nOverall those 3 points felt very heavy to digest :-)",
              "createdAt": "2023-10-19T12:54:22Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Reworked some of these points.",
              "createdAt": "2023-10-20T17:42:15Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Those 3 points seem a bit redundant, while each telling  something slightly different ('MSBuild can report file accesses', 'MSBuild forwards file accesses info to the plugin', 'Unless opted in, no file accesses are reported') - wouldn't it be better to mention it just once, while mentioning the opt-in mechanics?",
              "createdAt": "2023-10-19T13:03:09Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Reworked some of the verbiage",
              "createdAt": "2023-10-20T17:47:57Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This feels superfluous to the link to iplementation provided",
              "createdAt": "2023-10-19T13:06:36Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Also it should probably link the `Deteours` section below (and leave the implementation details info - like the need to disable in-proc node etc. - to be mentioned only in that section. Now some info is duplicated)",
              "createdAt": "2023-10-19T13:09:54Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Removing the signatures and linked to the `Plugin implementation guidance and simple example design` section.",
              "createdAt": "2023-10-20T17:51:19Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nBecause the Detours implementation being used communicates over a pipe, and nodes communicate over a pipe as well, and pipes are async, there is some coordination required to ensure that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.\r\n```\r\n\r\nBut I'm not a native speaker though",
              "createdAt": "2023-10-19T13:13:39Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and node communication is also over a pipe, and pipes are async, there is some coordination required for ensuring that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "That's much less awkward sentence structure :)",
              "createdAt": "2023-10-20T17:52:43Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,195 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Progrmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before th build can complete.\n+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds. In other words, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). This happens based on the requirement of using `/graph`. Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- To facilitate the plugin being able to hande future builds, MSBuild can report file accesses as well as the build result for the BuildRequestData.\n+- MSBuild disables the in-proc node and uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. It forwards this information to the plugin for it to use as desired.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`) and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass. It contains the following methods:\n+\n+```cs\n+public abstract Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public abstract Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);\n+\n+public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);\n+\n+public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);\n+\n+public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);\n+```\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and node communication is also over a pipe, and pipes are async, there is some coordination required for ensuring that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I strongly prefer using the same language that we have in the project files instead of dependency language (because of the great \"which way do arrows point\" debate)\r\n\r\n```suggestion\r\n- The plugin instance will get called in reverse topological sort order (from referenced projects up towards referencing projects). This happens when performing a graph build (`/graph`), Visual Studio solution builds, and commonly in higher build engines.\r\n```",
              "createdAt": "2023-12-20T11:58:46Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,185 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin to add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Programmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+  - `BeginBuildAsync` may be called with or without a `ProjectGraph`, depending on MSBuild has one to provide. When it is not provided, hints about the graph entry points are provided with which the plugin may decide to construct the `ProjectGraph` itself, if desired.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before the build can complete.\n+- The plugin instance will get called in reverse topological sort order (from dependencies up towards dependents). This happens when performing a graph build (`/graph`), Visual Studio solution builds, and commonly in higher build engines.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\r\n```suggestion\r\n- Only the top-level build requests are checked against the cache. Build requests issued recursively from the top-level requests, for example a project building its dependencies, are not checked against the cache. However, because the build requests are assumed to be issued in reverse topological sort order, those requests should have already been built and present in MSBuild's internal result cache, provided either by the project cache plugin or real builds. A consequence of this is that projects which are not well-described in the graph (e.g. using `<MSBuild>` tasks directly) will not benefit from the cache.\r\n```",
              "createdAt": "2023-12-20T11:59:25Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,185 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin to add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Programmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+  - `BeginBuildAsync` may be called with or without a `ProjectGraph`, depending on MSBuild has one to provide. When it is not provided, hints about the graph entry points are provided with which the plugin may decide to construct the `ProjectGraph` itself, if desired.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before the build can complete.\n+- The plugin instance will get called in reverse topological sort order (from dependencies up towards dependents). This happens when performing a graph build (`/graph`), Visual Studio solution builds, and commonly in higher build engines.\n+- Only the top-level build requests are checked against the cache. Build requests issued recursively from the top-level requests, for example a project building its dependencies, are not checked against the cache. However, because the build requests are assumed to be issued in reverse topological sort order, those requests should have already been built and present in MSBuild's internal result cache, provided either by the project cache plugin or real builds. A consequence of this is that, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\r\n```suggestion\r\nAny storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.\r\n```",
              "createdAt": "2023-12-20T12:04:40Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,185 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin to add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Programmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+  - `BeginBuildAsync` may be called with or without a `ProjectGraph`, depending on MSBuild has one to provide. When it is not provided, hints about the graph entry points are provided with which the plugin may decide to construct the `ProjectGraph` itself, if desired.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before the build can complete.\n+- The plugin instance will get called in reverse topological sort order (from dependencies up towards dependents). This happens when performing a graph build (`/graph`), Visual Studio solution builds, and commonly in higher build engines.\n+- Only the top-level build requests are checked against the cache. Build requests issued recursively from the top-level requests, for example a project building its dependencies, are not checked against the cache. However, because the build requests are assumed to be issued in reverse topological sort order, those requests should have already been built and present in MSBuild's internal result cache, provided either by the project cache plugin or real builds. A consequence of this is that, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  \n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- MSBuild uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. To facilitate the plugin being able to handle future builds, it forwards this information as well as the build result to the plugin for it to use as desired, for example to add to a cache.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programmatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+  - The in-proc node is disabled since MSBuild is unable to use Detours on the currently running process. It also would not want to capture the file accesses of the plugins themselves.\n+  - Detours adds some overhead to file accesses. Based on initial experimentation, it's around 10-15%. There's the overhead of the plugin adding to the cache. Caching becomes valuable if it can save more than the overhead on average.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`), only for the x64 flavor (not x86 or arm64), and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass.\n+\n+See the [Plugin implementation guidance and simple example design](#plugin-implementation-guidance-and-simple-example-design) section for guidance for plugin implementations.\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, making it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will emit events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and nodes communicate over a pipe as well, and pipes are async, there is some coordination required to ensure that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.\n+\n+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler node receives as \"project finished\" event over the node communication pipe, it will wait to determine that the project is actually finished until it also receives the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler determines the project is finished and schedules new work to the worker node (which would trigger new file accesses).\n+\n+# Plugin implementation guidance and simple example design\n+\n+The following will describe a very basic (and not very correct) plugin implementation.\n+\n+In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build (\"if Tuesday copy this file\"), but if considered caching would be quite infeasible.\n+\n+## Fingerprinting\n+\n+A \"fingerprint\" describes each unique input which went into the building a build request. The more granular the fingerprint, the more \"correct\" the caching is, as described above.\n+\n+In this example, we will only consider the following as inputs, and thus part of the fingerprint:\n+- The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)\n+- The content hash of the project file\n+- The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`\n+- The fingerprint of referenced projects\n+\n+Again, this is for illustrative purposes and a real implementation will want to use additional state for fingerprinting depending on the environment in which it runs and the correctness requirements.\n+\n+It can make sense for a fingerprint to be a hash of its inputs, so effectively is a byte array which can be represented by a string.\n+\n+At the beginning of the build, the plugin's `BeginBuildAsync` method will be called. As part of the `CacheContext`, the plugin is either given the graph or the entry points to the graph for which it can create a graph from. The plugin can use this graph to do some initial processing, like predicting various inputs which a project is likely to use. This information can then be stored to help construct a fingerprint for a build request later.\n+\n+## Cache storage\n+\n+Any storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/en-us/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\r\n```suggestion\r\nFor illustration purposes, consider our cache implementation is based on a simple filesystem with a separate metadata and content directory inside it. Under the metadata dir, each file is a metadata file where the filename matches the fingerprint it's describing. Under the content dir, each file is a content file where the filename matches the hash of the content itself.\r\n```",
              "createdAt": "2023-12-20T12:05:10Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,185 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin to add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Programmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+  - `BeginBuildAsync` may be called with or without a `ProjectGraph`, depending on MSBuild has one to provide. When it is not provided, hints about the graph entry points are provided with which the plugin may decide to construct the `ProjectGraph` itself, if desired.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before the build can complete.\n+- The plugin instance will get called in reverse topological sort order (from dependencies up towards dependents). This happens when performing a graph build (`/graph`), Visual Studio solution builds, and commonly in higher build engines.\n+- Only the top-level build requests are checked against the cache. Build requests issued recursively from the top-level requests, for example a project building its dependencies, are not checked against the cache. However, because the build requests are assumed to be issued in reverse topological sort order, those requests should have already been built and present in MSBuild's internal result cache, provided either by the project cache plugin or real builds. A consequence of this is that, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  \n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- MSBuild uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. To facilitate the plugin being able to handle future builds, it forwards this information as well as the build result to the plugin for it to use as desired, for example to add to a cache.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programmatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+  - The in-proc node is disabled since MSBuild is unable to use Detours on the currently running process. It also would not want to capture the file accesses of the plugins themselves.\n+  - Detours adds some overhead to file accesses. Based on initial experimentation, it's around 10-15%. There's the overhead of the plugin adding to the cache. Caching becomes valuable if it can save more than the overhead on average.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`), only for the x64 flavor (not x86 or arm64), and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass.\n+\n+See the [Plugin implementation guidance and simple example design](#plugin-implementation-guidance-and-simple-example-design) section for guidance for plugin implementations.\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, making it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will emit events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and nodes communicate over a pipe as well, and pipes are async, there is some coordination required to ensure that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.\n+\n+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler node receives as \"project finished\" event over the node communication pipe, it will wait to determine that the project is actually finished until it also receives the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler determines the project is finished and schedules new work to the worker node (which would trigger new file accesses).\n+\n+# Plugin implementation guidance and simple example design\n+\n+The following will describe a very basic (and not very correct) plugin implementation.\n+\n+In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build (\"if Tuesday copy this file\"), but if considered caching would be quite infeasible.\n+\n+## Fingerprinting\n+\n+A \"fingerprint\" describes each unique input which went into the building a build request. The more granular the fingerprint, the more \"correct\" the caching is, as described above.\n+\n+In this example, we will only consider the following as inputs, and thus part of the fingerprint:\n+- The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)\n+- The content hash of the project file\n+- The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`\n+- The fingerprint of referenced projects\n+\n+Again, this is for illustrative purposes and a real implementation will want to use additional state for fingerprinting depending on the environment in which it runs and the correctness requirements.\n+\n+It can make sense for a fingerprint to be a hash of its inputs, so effectively is a byte array which can be represented by a string.\n+\n+At the beginning of the build, the plugin's `BeginBuildAsync` method will be called. As part of the `CacheContext`, the plugin is either given the graph or the entry points to the graph for which it can create a graph from. The plugin can use this graph to do some initial processing, like predicting various inputs which a project is likely to use. This information can then be stored to help construct a fingerprint for a build request later.\n+\n+## Cache storage\n+\n+Any storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/en-us/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.\n+\n+For illustration purposes, consider our cache implementation is based on a simple filesystem which a separate metadata and content directory inside it. Under the metadata dir, each file is a metadata file where the filename matches the fingerprint it's describing. Under the content dir, each file is a content file where the filename matches the hash of the content itself.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I found this kinda hard to follow, I was expecting R to appear in one of the files. It's not _wrong_ now that I read it a few times but if you have an easy rephrase I'd appreciate it. Maybe something like\r\n```suggestion\r\nTo illustrate this, consider a project with fingerprint `F` which wrote a single file `O` with hash `H` and had `BuildResult R`. The plugin could create a metadata file `M` which describes the outputs of the build (the path and hash of `O`) as well as the serialized `R`. Using the cache implementation described above, the plugin would write the following two files to the cache:\r\n - `metadata/F -> M:'{outputs: {path: 'path/to/O', hash: H}, result: R}`\r\n - `content/H -> O`\r\n```",
              "createdAt": "2023-12-20T12:09:59Z",
              "path": "documentation/specs/project-cache.md",
              "diffHunk": "@@ -14,106 +14,185 @@ This change also simplifies and unifies user experiences. MSBuild works the same\n \n - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:\n   - it makes the filesystem look as if the project built\n-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.\n \n # High-level design\n-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.\n-- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.\n-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n+\n+Conceptually, there are two parts of caching: \"cache get\" and \"cache add\". \"Cache get\" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. \"Cache add\" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin to add the results to its cache and safely be able to retrieve it for some future build.\n+\n+The \"cache get\" functionality was introduced in 16.9, while \"cache add\" was added in 17.8.\n+\n+## Plugin discovery\n+\n - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).\n   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.\n   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.\n-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.\n-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.\n-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the \"graph\" when static graph is not available).\n-- A single plugin is supported (for now).\n-\n-# APIs and calling patterns\n-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).\n-\n-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.\n-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.\n-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.\n-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.\n-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.\n-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.\n-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.\n-\n-## From command line\n-- Requires /graph. It is the easiest way to implement the plugin:\n-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.\n-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n-- User calls msbuild /graph.\n-- MSBuild constructs the static graph.\n-- The graph builder finds and loads the plugin into the `BuildManager`.\n-  - Each graph node has a ProjectInstance, which is used to search for the plugin.\n-  - If a project defines a plugin, then all projects in the graph must define that same plugin.\n-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).\n-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.\n-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.\n-\n-## From Visual Studio, a temporary workaround\n-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:\n-  - The workaround logic activates only when MSBuild detects that it's running under VS.\n-  - Plugin discovery\n-    - When VS evaluates projects via \"new Project(..)\" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n-  - Plugin usage:\n-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.\n-\n-# Details\n-- Plugin discovery\n-  - Each project defines an item containing the path to the plugin DLL:\n ```xml\n-<ProjectCachePlugin Include=\"..\\..\\QuickbuildProjectCachePlugin.dll\">\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\" />\n+</ItemGroup>\n ```\n-- Plugin acquisition\n-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.\n-- Defining the \"graph\" when static graph is not available\n-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.\n-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.\n-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.\n-- Returning a valid BuildResult object on cache hits.\n-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).\n+- Programmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.\n+\n+## Plugin lifetime\n+\n+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.\n+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a \"fire-and-forget\" call at this point. The first query on the plugin will wait for plugin initialization.\n+  - `BeginBuildAsync` may be called with or without a `ProjectGraph`, depending on MSBuild has one to provide. When it is not provided, hints about the graph entry points are provided with which the plugin may decide to construct the `ProjectGraph` itself, if desired.\n+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before the build can complete.\n+- The plugin instance will get called in reverse topological sort order (from dependencies up towards dependents). This happens when performing a graph build (`/graph`), Visual Studio solution builds, and commonly in higher build engines.\n+- Only the top-level build requests are checked against the cache. Build requests issued recursively from the top-level requests, for example a project building its dependencies, are not checked against the cache. However, because the build requests are assumed to be issued in reverse topological sort order, those requests should have already been built and present in MSBuild's internal result cache, provided either by the project cache plugin or real builds. A consequence of this is that, projects which are not well-described in the graph (eg using `<MSBuild>` tasks directly) will not benefit from the cache.\n+\n+## Cache get scenario\n+\n+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.\n+  \n+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.\n+- If the plugin decides to build, then MSBuild proceeds building the project as usual.\n+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets (\"proxy targets\").\n+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.\n   - Plugins have three options:\n-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.\n+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.\n+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.\n       - Proxy target assumptions:\n         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).\n         - They do not mutate state (file system, environment variables, etc).\n         - They do not MSBuild task call into other projects.\n-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.\n-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.\n-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.\n-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.\n-- Configuring plugins\n-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.\n+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.\n+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.\n+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.\n+\n+## Cache add scenario\n+\n+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.\n+- MSBuild uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. To facilitate the plugin being able to handle future builds, it forwards this information as well as the build result to the plugin for it to use as desired, for example to add to a cache.\n+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programmatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.\n+  - The in-proc node is disabled since MSBuild is unable to use Detours on the currently running process. It also would not want to capture the file accesses of the plugins themselves.\n+  - Detours adds some overhead to file accesses. Based on initial experimentation, it's around 10-15%. There's the overhead of the plugin adding to the cache. Caching becomes valuable if it can save more than the overhead on average.\n+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`), only for the x64 flavor (not x86 or arm64), and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.\n+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.\n+\n+# APIs and calling patterns\n+\n+## Plugin API\n+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass.\n+\n+See the [Plugin implementation guidance and simple example design](#plugin-implementation-guidance-and-simple-example-design) section for guidance for plugin implementations.\n+\n+## Configuring plugins\n+\n+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:\n+\n ```xml\n-<ProjectCachePlugin Update=\"@(ProjectCachePlugin)\" setting1=\"val1\" setting2=\"val2\" />\n+<ItemGroup>\n+  <ProjectCachePlugin Include=\"$(SomePath)\\MyAmazingCachePlugin.dll\">\n+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>\n+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>\n+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>\n+  </ProjectCachePlugin>\n+</ItemGroup>\n ```\n-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):\n-  - From command line: `msbuild /graph:NoBuild`\n-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`\n-- Logging\n-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.\n-  - Log messages from querying a project get parented under that project's logging context.\n-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.\n+\n+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.\n+\n+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.\n+\n+## Enabling from command line\n+\n+- Requires `/graph` to light up cache get scenarios.\n+- Requires `/reportfileaccesses` to light up cache add scenarios.\n+- The static graph has all the project instances in the same process, making it easy to find and keep plugin instances in one process.\n+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.\n+\n+## Enabling from Visual Studio, a temporary workaround\n+\n+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.\n+- The workaround logic activates only when MSBuild detects that it's running under VS.\n+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.\n+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.\n+- Plugins will be given the graph entry points instead of the entire graph in this scenario.\n+- There is currently no way to enable cache add scenarios in Visual Studio.\n+\n+# Detours (cache add scenario)\n+\n+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will emit events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.\n+\n+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.\n+\n+## Pipe synchronization\n+\n+Because the Detours implementation being used communicates over a pipe, and nodes communicate over a pipe as well, and pipes are async, there is some coordination required to ensure that file accesses are associated with the proper build request. For example, if a \"project finished\" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.\n+\n+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler node receives as \"project finished\" event over the node communication pipe, it will wait to determine that the project is actually finished until it also receives the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler determines the project is finished and schedules new work to the worker node (which would trigger new file accesses).\n+\n+# Plugin implementation guidance and simple example design\n+\n+The following will describe a very basic (and not very correct) plugin implementation.\n+\n+In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build (\"if Tuesday copy this file\"), but if considered caching would be quite infeasible.\n+\n+## Fingerprinting\n+\n+A \"fingerprint\" describes each unique input which went into the building a build request. The more granular the fingerprint, the more \"correct\" the caching is, as described above.\n+\n+In this example, we will only consider the following as inputs, and thus part of the fingerprint:\n+- The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)\n+- The content hash of the project file\n+- The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`\n+- The fingerprint of referenced projects\n+\n+Again, this is for illustrative purposes and a real implementation will want to use additional state for fingerprinting depending on the environment in which it runs and the correctness requirements.\n+\n+It can make sense for a fingerprint to be a hash of its inputs, so effectively is a byte array which can be represented by a string.\n+\n+At the beginning of the build, the plugin's `BeginBuildAsync` method will be called. As part of the `CacheContext`, the plugin is either given the graph or the entry points to the graph for which it can create a graph from. The plugin can use this graph to do some initial processing, like predicting various inputs which a project is likely to use. This information can then be stored to help construct a fingerprint for a build request later.\n+\n+## Cache storage\n+\n+Any storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/en-us/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.\n+\n+For illustration purposes, consider our cache implementation is based on a simple filesystem which a separate metadata and content directory inside it. Under the metadata dir, each file is a metadata file where the filename matches the fingerprint it's describing. Under the content dir, each file is a content file where the filename matches the hash of the content itself.\n+\n+## First build (cache population)\n+\n+In the very first build there will be no cache hits so the \"cache add\" scenario will be most relevant here.\n+\n+For a given project, `GetCacheResultAsync` will be invoked, but will end up returning a cache miss since the cache is empty.\n+\n+MSBuild will then build the project normally but under a detoured worker node. Because of this, the plugin will recieve `HandleFileAccess` and `HandleProcess` events. In this example implementation we will ignore `HandleProcess`. For `HandleFileAccess`, the plugin will simply store all `FileAccessData`s for a `FileAccessContext` to build up a list of all file accesses during the build. The plugin may decide to avoid storing the entire `FileAccessData` and instead just peel off the data it finds relevant (eg. paths, whether it was a read or write, etc).\n+\n+Once MSBuild is done building the project, it will call the plugin's `HandleProjectFinishedAsync`. Now the plugin knows the project is done and can process the results and add them to a cache. In general it's only useful to cache successful results, so the plugin should filter out non-success results. The `FileAccessContext` provided can then be used to retrieve the list of `FileAccessData` the plugin recieved. These `FileAccessData` can be processed to understand which files were read and written as part of the build.\n+\n+In our example, we can use the read files to construct a fingerprint for the build request. We can then add the files written during the build (\"outputs\") to some cache implementation.\n+\n+The plugin would then create some metadata describing the outputs (eg. the paths and hashes) and the serialized `BuildResult`, and associate it with the fingerprint and put that assocation in the cache.\n+\n+To illustrate this, consider a project with fingerprint `F` which wrote a single file `O` with hash `H` and had `BuildResult R`. The plugin could create a metadata file `M` which describes the outputs of the build (the path and hash of `O`) as well as the serialized `R`. Using the cache implementation described above, the plugin would write the following two files to the cache:\n+ - `metadata/F -> M`\n+ - `content/H -> O`",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}