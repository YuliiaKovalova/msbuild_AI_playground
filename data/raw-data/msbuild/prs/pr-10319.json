{
  "number": 10319,
  "title": "High Level overview",
  "body": "Fixes https://github.com/dotnet/msbuild/issues/10215\r\n\r\nA document on the high level MSBuild parts and execution.",
  "state": "MERGED",
  "createdAt": "2024-07-01T20:58:09Z",
  "updatedAt": "2024-08-07T10:10:29Z",
  "closedAt": "2024-07-26T09:19:36Z",
  "mergedAt": "2024-07-26T09:19:36Z",
  "additions": 279,
  "deletions": 0,
  "changedFiles": 1,
  "headRefName": "docOverview",
  "isDraft": false,
  "author": {
    "login": "maridematte"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "9101c0421e38ec47bad21ff433c96e273789960c",
          "message": "Why many words when few words work",
          "committedDate": "2024-06-25T17:35:32Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "285070960a76f5e8980b6a2cc36f16791d2b96e7",
          "message": "MSBuild XSM section",
          "committedDate": "2024-06-25T18:59:21Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "86d36ad4ba81b7ae75d72faca991b298601f102c",
          "message": "Progress",
          "committedDate": "2024-06-26T20:01:28Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f46938e8c61c3d01f3f5834c957637c181e9ef46",
          "message": "More progress",
          "committedDate": "2024-06-28T20:59:11Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a04a60784c52810a4008f4450a2f0394ef0445b3",
          "message": "Extensibility section done",
          "committedDate": "2024-06-28T21:55:43Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "80351dde5851324892f0545d7a8826de6c44cead",
          "message": "Execution almost done",
          "committedDate": "2024-07-01T14:00:13Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "84a3aad2819b87d7906bb8b8cfa3ef070c1e4b17",
          "message": "Fix typos",
          "committedDate": "2024-07-01T17:29:02Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "634e15ba11f12b49fc3727dcf5da61121b406174",
          "message": "First draft done",
          "committedDate": "2024-07-01T20:56:00Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "32886ae06a2d953a4cd94c863fb2236beb024fa2",
          "message": "Removed todo marker",
          "committedDate": "2024-07-01T21:09:37Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "890eb20149347ca1831b98024854c48738e0d97a",
          "message": "Addressed some PR suggestions",
          "committedDate": "2024-07-03T12:17:38Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "002531f7c71a7e57e9e0e850baacb98cc3c28e1f",
          "message": "Addressed PR comments",
          "committedDate": "2024-07-15T14:13:47Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "39597ba7e45e886698ede82cbcc37c9af1b1c43b",
          "message": "remove locale from doc links",
          "committedDate": "2024-07-15T18:25:30Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f8aa51c7a72fb1fa77979d31ef821ae3b27a4904",
          "message": "replace MSBuild repo links with relative",
          "committedDate": "2024-07-15T18:27:00Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2ba9c82d103453694369d12307ac840d600bc281",
          "message": "fixup! replace MSBuild repo links with relative",
          "committedDate": "2024-07-15T18:35:23Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c16fabdb055b3d69b53ec719b148c87b9ebdd413",
          "message": "Specify the TaskHost behavior",
          "committedDate": "2024-07-16T09:57:38Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "krivanek.j@hotmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f43a09aae35bbbef86ffa3f4308469f14bfbec62",
          "message": "Fixed phrases from PR comments",
          "committedDate": "2024-07-16T22:30:50Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2eb01626ddc2a6f925437624cbfd1271c5da3c2d",
          "message": "Solved half of Rainer's comments",
          "committedDate": "2024-07-17T21:31:41Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2c9ee02124fde83e5cf36b9d034a0f50802612fa",
          "message": "Added links, Added specificications to some topics",
          "committedDate": "2024-07-18T12:51:40Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "181ce0d8bfab0de5df00cd37b98d3d096642ec06",
          "message": "Some PR comments and suggestions",
          "committedDate": "2024-07-18T13:10:04Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "de1122f2288bb13a8488870b93d86305f2215ee6",
          "message": "Another round of PR comments",
          "committedDate": "2024-07-18T13:30:54Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb0ebc6162968b38d2c0977f465bca1d0b28fe96",
          "message": "Add Incremental Build and RAR caching info",
          "committedDate": "2024-07-19T12:20:50Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1822dcdfc8cf3cc749fe6571cedc3adf56626082",
          "message": "Add tasks section to overview",
          "committedDate": "2024-07-19T15:01:21Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "34e41d75281e41579c83f60e6a11b0705c750882",
          "message": "More PR comments",
          "committedDate": "2024-07-19T16:57:12Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "39c44969a781eca53660819b125eca2423428729",
          "message": "Addressed PR comments",
          "committedDate": "2024-07-23T21:24:40Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "79e7574b36c86e38e90e649a24a721f62efa048c",
          "message": "Merge branch 'main' into docOverview",
          "committedDate": "2024-07-23T21:25:01Z",
          "author": {
            "name": "Mariana Dematte",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "04445fe3c9d2ecf06b03532f8773e93f2b7413fd",
          "message": "Added diagrams",
          "committedDate": "2024-07-24T13:21:57Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2aff1173c670a0c456714623cea73f54eb679180",
          "message": "Engine parts diagram",
          "committedDate": "2024-07-24T14:12:59Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2bcf4cbeb5e24f74381f9dc56971cba34e9e05f4",
          "message": "Addressed some comments",
          "committedDate": "2024-07-24T19:32:46Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f65d4e629c131f0722b30f2ce35a1e21351684c7",
          "message": "Addressed more comments",
          "committedDate": "2024-07-24T19:41:44Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "701acdb5c56a65de00e650a4d2bb1b3448a7c1af",
          "message": "PR comments",
          "committedDate": "2024-07-26T09:02:17Z",
          "author": {
            "name": "Mariana Dematt\u00e9",
            "email": "magarces@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ffcb5a6bd1a7bb81eab6e59a6cfecb361a4ee879",
          "message": "Merge branch 'main' into docOverview",
          "committedDate": "2024-07-26T09:02:35Z",
          "author": {
            "name": "Mariana Dematte",
            "email": "magarces@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "There are a few topics that are not covered here or deserve a bit more about them. These are not a full list:\r\n- MSBuild server\r\n- Built-in tasks and targets: some more widely used examples.\r\n- PerfStar usage",
        "createdAt": "2024-07-01T21:13:57Z",
        "author": {
          "login": "maridematte"
        }
      },
      {
        "body": "As the document mentions the FileTracker, should we also mention the Locator?",
        "createdAt": "2024-07-25T09:55:54Z",
        "author": {
          "login": "MichalPavlik"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this something that happens during the execution or it is up to the user to do that explicitly per task? \r\n",
              "createdAt": "2024-07-02T06:44:57Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "From my understanding it is up to the user to explicitly opt-in the Task Host behaviour per task.",
              "createdAt": "2024-07-15T12:46:05Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could you please clarify what does it mean in this context blocked? \r\n> The project's execution starts and proceeds until the whole operation ends or is blocked.",
              "createdAt": "2024-07-02T06:48:10Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "Blocked here means by being dependent on outputs of a different project (that yet needs to be built).\r\n\r\nThat being said - 100% agree it'd be good to specify",
              "createdAt": "2024-07-02T07:38:15Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Oh I see it's mentioned below. But it still might be briefly mentioned - to make it clear the blocking happens due to dependencies",
              "createdAt": "2024-07-02T07:42:48Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Added a comment about what being blocked means so things are clearer.",
              "createdAt": "2024-07-15T12:48:29Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Coudl you please clarify what is SML here? ",
              "createdAt": "2024-07-02T06:53:29Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.\n+\n+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current execution, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and assigns the dependency to be executed to either the current node or another one that is free.\n+\n+### Incremental build\n+Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from each project build is saved in memory, which becomes one big cache for MSBuild.\n+\n+## Parallelism\n+Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently from projects.\n+\n+For multi-targeted builds parallelism works slightly different. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.\n+\n+\n+## IPC (inter-process communication)\n+In multi-process MSBuild execution, many OS processes exist that need to communicate with each other. There are two main reasons:\n+ - Dealing with blocked tasks on processes: Communicating with the engine, scheduler, cache, etc...\n+ - Communication on task execution for a task host: Task definition, task inputs, task outputs.\n+\n+## Graph build\n+A graph build changes the sequence in which MSBuild processes projects. Normally a project starts execution, and when it has a dependency on another project, then that project starts to build. A graph build evaluates all projects and their relationship before starting execution of any project. This is achieved by looking at specific items in the XML (like Project Reference) to construct the dependency graph.\n+\n+There are a couple of different modes to run graph mode in:\n+- Standard mode: Tried to work from the leaves of the dependency graph and makes sure all results are within the cache. If there is a cache miss / unexpected reference, it just schedules the missing reference for execution.\n+- Strict / isolate mode: If there is a cache miss when building, the whole built is failed. This is used mostly for distributed system builds.\n+\n+## MSBuid Server\n+In normal MSBuild execution the main process is cleared after the build ends, or after a set time limit. The MSBuild Server project aims to change that, making the entry point process and the scheduler process node separate entities. This allows processes to preserve in-memory cache and make consecutive builds faster.\n+\n+# Extensibilities\n+MSBuild includes some extra features that are related to the build process but does not fit on the previous categories. These extensibility features are critical for the build process, but they can also be customized by third parties for their own use.\n+\n+## Packaging system\n+MSBuild interacts with external packages in almost every build. However, the MSBuild engine does not recognize external packages as third parties, and it also does not handle external dependencies. This is done by a packaging system. The supported one being NuGet. As such, it is NuGet that is responsible for finding the packages, downloading them, and providing the MSBuild engine with a package path for the build.\n+\n+## Restore\n+The restore operation is a built-in target within MSBuild. The main function is to walk through the project references and `packages.config` file about all the packages that need to be restored. This process is executed by NuGet, as MSBuild does not have a packaging system within the code.\n+\n+## Diagnosability / Loggers\n+Diagnosability within MSBuild went through some changes. Before we had a debugger, where you could step through the XML during the build and debug. This was discarded in favor of a log focused approach, where MSBuild has a more robust logging system that contains more data to identify what is happening during a build.\n+\n+Beyond loggers, we have some ETW (Event Tracing for Windows) events which can also be identified through loggers.\n+\n+### General Loggers\n+Logging within MSBuild consists of various integrated and pluggable loggers. Integrated loggers generally processes code structure events, such as communication between nodes during build, or data for BuildCheck analyzers to run properly. Built-in loggers include the Binary Logger, Console / Terminal logger, and a Text Log. Pluggable loggers are third party loggers that can receive events through the MSBuild API, or the .NET event handlers.\n+\n+Pluggable loggers are added through DLLs, and MSBuild engine identifies them at the beginning of the build. Because of this, build logic is not able to manipulate loggers.\n+\n+### Binary logger\n+The Binary Logger, also called BinLog, is a structured log that contains all the events within a build. It achieves that through its implementation focused on reading events from the build and serializing those in an structured form. To read a BinLog the BinLog reader can be used, but it is not officially supported by the MSBuild team.\n+It is one of the best tools for debugging MSBuild. \n+\n+## Resolvers\n+There are a few elements within the MSBuild SML that indicate that a call to the .NET SDK is necessary. Some examples include:",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "This is a typo, it's XML.",
              "createdAt": "2024-07-03T11:41:13Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.\n+\n+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current execution, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and assigns the dependency to be executed to either the current node or another one that is free.\n+\n+### Incremental build\n+Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from each project build is saved in memory, which becomes one big cache for MSBuild.\n+\n+## Parallelism\n+Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently from projects.\n+\n+For multi-targeted builds parallelism works slightly different. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.\n+\n+\n+## IPC (inter-process communication)\n+In multi-process MSBuild execution, many OS processes exist that need to communicate with each other. There are two main reasons:\n+ - Dealing with blocked tasks on processes: Communicating with the engine, scheduler, cache, etc...\n+ - Communication on task execution for a task host: Task definition, task inputs, task outputs.\n+\n+## Graph build\n+A graph build changes the sequence in which MSBuild processes projects. Normally a project starts execution, and when it has a dependency on another project, then that project starts to build. A graph build evaluates all projects and their relationship before starting execution of any project. This is achieved by looking at specific items in the XML (like Project Reference) to construct the dependency graph.\n+\n+There are a couple of different modes to run graph mode in:\n+- Standard mode: Tried to work from the leaves of the dependency graph and makes sure all results are within the cache. If there is a cache miss / unexpected reference, it just schedules the missing reference for execution.\n+- Strict / isolate mode: If there is a cache miss when building, the whole built is failed. This is used mostly for distributed system builds.\n+\n+## MSBuid Server\n+In normal MSBuild execution the main process is cleared after the build ends, or after a set time limit. The MSBuild Server project aims to change that, making the entry point process and the scheduler process node separate entities. This allows processes to preserve in-memory cache and make consecutive builds faster.\n+\n+# Extensibilities\n+MSBuild includes some extra features that are related to the build process but does not fit on the previous categories. These extensibility features are critical for the build process, but they can also be customized by third parties for their own use.\n+\n+## Packaging system\n+MSBuild interacts with external packages in almost every build. However, the MSBuild engine does not recognize external packages as third parties, and it also does not handle external dependencies. This is done by a packaging system. The supported one being NuGet. As such, it is NuGet that is responsible for finding the packages, downloading them, and providing the MSBuild engine with a package path for the build.\n+\n+## Restore\n+The restore operation is a built-in target within MSBuild. The main function is to walk through the project references and `packages.config` file about all the packages that need to be restored. This process is executed by NuGet, as MSBuild does not have a packaging system within the code.\n+\n+## Diagnosability / Loggers\n+Diagnosability within MSBuild went through some changes. Before we had a debugger, where you could step through the XML during the build and debug. This was discarded in favor of a log focused approach, where MSBuild has a more robust logging system that contains more data to identify what is happening during a build.\n+\n+Beyond loggers, we have some ETW (Event Tracing for Windows) events which can also be identified through loggers.\n+\n+### General Loggers\n+Logging within MSBuild consists of various integrated and pluggable loggers. Integrated loggers generally processes code structure events, such as communication between nodes during build, or data for BuildCheck analyzers to run properly. Built-in loggers include the Binary Logger, Console / Terminal logger, and a Text Log. Pluggable loggers are third party loggers that can receive events through the MSBuild API, or the .NET event handlers.\n+\n+Pluggable loggers are added through DLLs, and MSBuild engine identifies them at the beginning of the build. Because of this, build logic is not able to manipulate loggers.\n+\n+### Binary logger\n+The Binary Logger, also called BinLog, is a structured log that contains all the events within a build. It achieves that through its implementation focused on reading events from the build and serializing those in an structured form. To read a BinLog the BinLog reader can be used, but it is not officially supported by the MSBuild team.\n+It is one of the best tools for debugging MSBuild. \n+\n+## Resolvers\n+There are a few elements within the MSBuild SML that indicate that a call to the .NET SDK is necessary. Some examples include:",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThese attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files, are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\r\n```",
              "createdAt": "2024-07-02T07:06:01Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nSince the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/en-us/visualstudio/msbuild/how-to-use-project-sdk).\r\n```",
              "createdAt": "2024-07-02T07:10:28Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not sure what is meant by the last sentece `It also enables the change of the MSBuild Language without directly changing the project file itself.`\r\n\r\nCan it be clarified?",
              "createdAt": "2024-07-02T07:12:31Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "This is about the VS use case, where options within VS change the behaviour of MSBuild. I'll add clarification there about this specific case.",
              "createdAt": "2024-07-15T12:56:02Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "I like the new formulation - it's now clear to me :-)",
              "createdAt": "2024-07-16T09:43:07Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This section uses 'Entry point' for 2 dfferent meanings:\r\n* the way how user invokes the build\r\n* the inital project (implicit or explicit) that is given to the build to be processed\r\n\r\nIt might be worth to disambiguate here",
              "createdAt": "2024-07-02T07:17:23Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. ",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "That section only uses the term entry point for the way that the user invokes the build. I have clarified the section so that does not get confused.",
              "createdAt": "2024-07-15T13:13:12Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. ",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nComplex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\r\n```",
              "createdAt": "2024-07-02T07:22:05Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```\r\nThe final order might change if an earlier target modifies a property of a later target.\r\n```\r\n\r\nNot sure if I understand this - but it doesn't sound correct.\r\nCan it be restated or simply removed?",
              "createdAt": "2024-07-02T07:25:49Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I tried changing it to see if it makes sense. I think it is an important bit of information so I'd like to keep it in the document.",
              "createdAt": "2024-07-15T13:20:37Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nMSBuild has an ability to run tasks out of process via the Task Host. That allows tasks to run in a different .NET runtime or bintess than the one used by the build engine for the build execution.\r\n```",
              "createdAt": "2024-07-02T07:28:26Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The main usage scenario is the need to use specific `Runtime` or `Architecture` for the task - those can be specified in `UsingTask` (https://learn.microsoft.com/en-us/visualstudio/msbuild/usingtask-element-msbuild) - and if those differ from the executing build engine, then the TaskHost is being used",
              "createdAt": "2024-07-02T07:31:26Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "They can also be specified in the task invocation XML.",
              "createdAt": "2024-07-15T20:23:30Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```\r\n is when the whole build, the OS tears down the process\r\n```\r\n\r\nSomething seems to be missing here?",
              "createdAt": "2024-07-02T07:32:49Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```\r\nthis communication happens within the engine using built-in loggers.\r\n```\r\n\r\nIs this true?\r\nRequesting and providing results should be a built-in contract of the scheduler. I do not think any loggers are involved here (I might be wrong)",
              "createdAt": "2024-07-02T07:41:00Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I think this is true. But let's confirm it with @rainersigwald ",
              "createdAt": "2024-07-15T13:51:25Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "Jan is correct; the serialization and IPC here use the normal IPC mechanisms and aren't related to logging.",
              "createdAt": "2024-07-15T20:50:12Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is an important section for the threat modeling - let's capture all the extensibility mechanisms that has been discussed during the syncs:\r\n* Loggers (given by dll)\r\n* Tasks (given by dll or inline code)\r\n* Resolvers (discovered in fixed location)\r\n* SDKs (injectable via project files)\r\n* Cache plugin (injectable via project files or via API)\r\n* Build Checks (injectable via package reference)\r\n",
              "createdAt": "2024-07-02T07:49:18Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.\n+\n+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current execution, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and assigns the dependency to be executed to either the current node or another one that is free.\n+\n+### Incremental build\n+Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from each project build is saved in memory, which becomes one big cache for MSBuild.\n+\n+## Parallelism\n+Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently from projects.\n+\n+For multi-targeted builds parallelism works slightly different. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.\n+\n+\n+## IPC (inter-process communication)\n+In multi-process MSBuild execution, many OS processes exist that need to communicate with each other. There are two main reasons:\n+ - Dealing with blocked tasks on processes: Communicating with the engine, scheduler, cache, etc...\n+ - Communication on task execution for a task host: Task definition, task inputs, task outputs.\n+\n+## Graph build\n+A graph build changes the sequence in which MSBuild processes projects. Normally a project starts execution, and when it has a dependency on another project, then that project starts to build. A graph build evaluates all projects and their relationship before starting execution of any project. This is achieved by looking at specific items in the XML (like Project Reference) to construct the dependency graph.\n+\n+There are a couple of different modes to run graph mode in:\n+- Standard mode: Tried to work from the leaves of the dependency graph and makes sure all results are within the cache. If there is a cache miss / unexpected reference, it just schedules the missing reference for execution.\n+- Strict / isolate mode: If there is a cache miss when building, the whole built is failed. This is used mostly for distributed system builds.\n+\n+## MSBuid Server\n+In normal MSBuild execution the main process is cleared after the build ends, or after a set time limit. The MSBuild Server project aims to change that, making the entry point process and the scheduler process node separate entities. This allows processes to preserve in-memory cache and make consecutive builds faster.\n+\n+# Extensibilities",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Added sections for Tasks and BuildCheck, which are the only ones missing from the document.",
              "createdAt": "2024-07-15T14:11:45Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.\n+\n+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current execution, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and assigns the dependency to be executed to either the current node or another one that is free.\n+\n+### Incremental build\n+Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from each project build is saved in memory, which becomes one big cache for MSBuild.\n+\n+## Parallelism\n+Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently from projects.\n+\n+For multi-targeted builds parallelism works slightly different. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.\n+\n+\n+## IPC (inter-process communication)\n+In multi-process MSBuild execution, many OS processes exist that need to communicate with each other. There are two main reasons:\n+ - Dealing with blocked tasks on processes: Communicating with the engine, scheduler, cache, etc...\n+ - Communication on task execution for a task host: Task definition, task inputs, task outputs.\n+\n+## Graph build\n+A graph build changes the sequence in which MSBuild processes projects. Normally a project starts execution, and when it has a dependency on another project, then that project starts to build. A graph build evaluates all projects and their relationship before starting execution of any project. This is achieved by looking at specific items in the XML (like Project Reference) to construct the dependency graph.\n+\n+There are a couple of different modes to run graph mode in:\n+- Standard mode: Tried to work from the leaves of the dependency graph and makes sure all results are within the cache. If there is a cache miss / unexpected reference, it just schedules the missing reference for execution.\n+- Strict / isolate mode: If there is a cache miss when building, the whole built is failed. This is used mostly for distributed system builds.\n+\n+## MSBuid Server\n+In normal MSBuild execution the main process is cleared after the build ends, or after a set time limit. The MSBuild Server project aims to change that, making the entry point process and the scheduler process node separate entities. This allows processes to preserve in-memory cache and make consecutive builds faster.\n+\n+# Extensibilities",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "There's also \"build logic\" which can be arbitrarily imported or NuGet-delivered.",
              "createdAt": "2024-07-15T21:15:14Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.\n+\n+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current execution, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and assigns the dependency to be executed to either the current node or another one that is free.\n+\n+### Incremental build\n+Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from each project build is saved in memory, which becomes one big cache for MSBuild.\n+\n+## Parallelism\n+Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently from projects.\n+\n+For multi-targeted builds parallelism works slightly different. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.\n+\n+\n+## IPC (inter-process communication)\n+In multi-process MSBuild execution, many OS processes exist that need to communicate with each other. There are two main reasons:\n+ - Dealing with blocked tasks on processes: Communicating with the engine, scheduler, cache, etc...\n+ - Communication on task execution for a task host: Task definition, task inputs, task outputs.\n+\n+## Graph build\n+A graph build changes the sequence in which MSBuild processes projects. Normally a project starts execution, and when it has a dependency on another project, then that project starts to build. A graph build evaluates all projects and their relationship before starting execution of any project. This is achieved by looking at specific items in the XML (like Project Reference) to construct the dependency graph.\n+\n+There are a couple of different modes to run graph mode in:\n+- Standard mode: Tried to work from the leaves of the dependency graph and makes sure all results are within the cache. If there is a cache miss / unexpected reference, it just schedules the missing reference for execution.\n+- Strict / isolate mode: If there is a cache miss when building, the whole built is failed. This is used mostly for distributed system builds.\n+\n+## MSBuid Server\n+In normal MSBuild execution the main process is cleared after the build ends, or after a set time limit. The MSBuild Server project aims to change that, making the entry point process and the scheduler process node separate entities. This allows processes to preserve in-memory cache and make consecutive builds faster.\n+\n+# Extensibilities",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "There's also the extension points within the Common targets that I have [documented](https://github.com/dotnet/msbuild/issues/2767#issuecomment-514342730) in #2767",
              "createdAt": "2024-07-18T08:01:38Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.\n+\n+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current execution, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and assigns the dependency to be executed to either the current node or another one that is free.\n+\n+### Incremental build\n+Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from each project build is saved in memory, which becomes one big cache for MSBuild.\n+\n+## Parallelism\n+Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently from projects.\n+\n+For multi-targeted builds parallelism works slightly different. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.\n+\n+\n+## IPC (inter-process communication)\n+In multi-process MSBuild execution, many OS processes exist that need to communicate with each other. There are two main reasons:\n+ - Dealing with blocked tasks on processes: Communicating with the engine, scheduler, cache, etc...\n+ - Communication on task execution for a task host: Task definition, task inputs, task outputs.\n+\n+## Graph build\n+A graph build changes the sequence in which MSBuild processes projects. Normally a project starts execution, and when it has a dependency on another project, then that project starts to build. A graph build evaluates all projects and their relationship before starting execution of any project. This is achieved by looking at specific items in the XML (like Project Reference) to construct the dependency graph.\n+\n+There are a couple of different modes to run graph mode in:\n+- Standard mode: Tried to work from the leaves of the dependency graph and makes sure all results are within the cache. If there is a cache miss / unexpected reference, it just schedules the missing reference for execution.\n+- Strict / isolate mode: If there is a cache miss when building, the whole built is failed. This is used mostly for distributed system builds.\n+\n+## MSBuid Server\n+In normal MSBuild execution the main process is cleared after the build ends, or after a set time limit. The MSBuild Server project aims to change that, making the entry point process and the scheduler process node separate entities. This allows processes to preserve in-memory cache and make consecutive builds faster.\n+\n+# Extensibilities",
              "author": {
                "login": "Nirmal4G"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is an important topic for thread modeling - let's add bit more details here:\r\n * Transport layer - named pipes, with restricting access to current user\r\n * Message layer - custom binary serialization implementation being used",
              "createdAt": "2024-07-02T07:52:54Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.\n+\n+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current execution, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and assigns the dependency to be executed to either the current node or another one that is free.\n+\n+### Incremental build\n+Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from each project build is saved in memory, which becomes one big cache for MSBuild.\n+\n+## Parallelism\n+Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently from projects.\n+\n+For multi-targeted builds parallelism works slightly different. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.\n+\n+\n+## IPC (inter-process communication)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Added more about the two layers for IPC.",
              "createdAt": "2024-07-15T14:11:14Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,150 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within `.csproj` files, which are considered *projects*. `.sln` solution files can be normally found in .NET projects, are not written with MSBuild XML, but it is interpreted during project build so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports of libraries, that contains their own tasks and targets. One example that is vastly used is the SDK with `dotnet build`. These libraries also extend what can be done with a build, and overall functionality.\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... It also enables the change of the MSBuild Language without directly changing the project file itself.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include some specific build logic for the projects, generally given by the entry points, User defined imports, and the `.g.props` from NuGet restore. \n+\n+An example of that is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import can be a lot of things, a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. But the final order might change if an earlier target modifies a property of a later target. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has a tool called Task Host, that allows tasks to run in a different .NET environment than the one used for build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started MSBuild starts a process, which runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+### Project result cache plugin\n+This Project Cache differs from the previous one because it is separate from the main MSBuild code and used mainly for distributed builds. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. To accomplish this, it adds profiles on disk based on hashes of the project or task ID / name. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.\n+\n+For more in depth information visit [the spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/project-cache.md).\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. Once a node is not proceeding with the current project, either finished or blocked, the scheduler then access if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.\n+\n+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current execution, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and assigns the dependency to be executed to either the current node or another one that is free.\n+\n+### Incremental build\n+Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from each project build is saved in memory, which becomes one big cache for MSBuild.\n+\n+## Parallelism\n+Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently from projects.\n+\n+For multi-targeted builds parallelism works slightly different. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.\n+\n+\n+## IPC (inter-process communication)",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd move discussion ToolTask to another section, or remove it, it does not seem as high level as the rest of the doc. ToolTask is not an interface for all custom tasks, but an abstract class for derived custom Tasks that spawn an executable.",
              "createdAt": "2024-07-15T15:39:10Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/en-us/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Yeah I'd say \r\n\r\n> Users can implement custom tasks via arbitrary .NET code, and MSBuild provides helper classes for common use cases like \"build a command line for and then run a command-line tool\".\r\n\r\nis probably the level of granularity that's interesting here.",
              "createdAt": "2024-07-15T18:49:40Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/en-us/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "### Custom Tasks\r\nLifecycle\r\n```mermaid\r\ngraph \r\n\r\nT[\"Implement:\\n extend ITask interface in .dll\"] --> X[\"Register:\\n &ltUsingTask/&gt\"] --> F[\"Initialize:\\n compile inline or load from assembly \\n(TaskFactory)\"] --> Tar[\"Use:\\n &ltTarget&gt&ltMyTask/&gt&ltTarget/&gt\"] --> S[\"Setup:\\n Set input properties\\n (TaskExecutionHost)\"] --> E[\"ITask.Execute()\"] --> O[\"Gather outputs: \\n (TaskExecutionHost)\"]\r\n```",
              "createdAt": "2024-07-15T16:01:34Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/en-us/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has an ability to run tasks out of process via the called Task Host. That allows tasks to run in a different .NET runtime or bintess than the one used by the build engine for the build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started, MSBuild starts a process that runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build finishes execution, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+There is also another Project Cache Plugin, which focuses on result cache in distributed builds. More information about it is in the Extensibility section.\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. A node is considered blocked, when the project that it is currently building depends on another project that has not yet finished executing. Once a node is not proceeding with the current project, the scheduler then asseses if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.\n+\n+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current execution, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and assigns the dependency to be executed to either the current node or another one that is free.\n+\n+### Incremental build\n+Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from each project build is saved in memory, which becomes one big cache for MSBuild.\n+\n+## Parallelism\n+Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently from projects.\n+\n+For multi-targeted builds parallelism works slightly different. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.\n+\n+\n+## IPC (Inter-Process Communication)\n+In multi-process MSBuild execution, many OS processes exist that need to communicate with each other. There are two main reasons:\n+ - Dealing with blocked tasks on processes: Communicating with the engine, scheduler, cache, etc...\n+ - Communication on task execution for a task host: Task definition, task inputs, task outputs.\n+\n+The transportation layer for messages are based on a .NET pipe implementattion. These pipes are specifically for windows, while the unix system implmentation has a wrap around sockets for the same functionality.\n+\n+The message layer has a custom serialization protocal that is specific to MSBuild.It is designed so implementing new types for new messages is easy, oinly needs to implement the `ITranslatable` interface. All message types used are known internal MSBuild types, that also have an extra field with a `string, string` disctionary to support extra user messages.\n+\n+## Graph build\n+A graph build changes the sequence in which MSBuild processes projects. Normally a project starts execution, and when it has a dependency on another project, then that project starts to build. A graph build evaluates all projects and their relationship before starting execution of any project. This is achieved by looking at specific items in the XML (like Project Reference) to construct the dependency graph.\n+\n+There are a couple of different modes to run graph mode in:\n+- Standard mode: Tried to work from the leaves of the dependency graph and makes sure all results are within the cache. If there is a cache miss / unexpected reference, it just schedules the missing reference for execution.\n+- Strict / isolate mode: If there is a cache miss when building, the whole built is failed. This is used mostly for distributed system builds.\n+\n+## MSBuid Server\n+In normal MSBuild execution the main process is cleared after the build ends, or after a set time limit. The MSBuild Server project aims to change that, making the entry point process and the scheduler process node separate entities. This allows processes to preserve in-memory cache and make consecutive builds faster.\n+\n+# Extensibilities\n+MSBuild includes some extra features that are related to the build process but does not fit on the previous categories. These extensibility features are critical for the build process, but they can also be customized by third parties for their own use.\n+\n+## Packaging system\n+MSBuild interacts with external packages in almost every build. However, the MSBuild engine does not recognize external packages as third parties, and it also does not handle external dependencies. This is done by a packaging system. The supported one being NuGet. As such, it is NuGet that is responsible for finding the packages, downloading them, and providing the MSBuild engine with a package path for the build.\n+\n+## Restore\n+The restore operation is a built-in target within MSBuild. The main function is to walk through the project references and `packages.config` file about all the packages that need to be restored. This process is executed by NuGet, as MSBuild does not have a packaging system within the code.\n+\n+## Tasks\n+",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "I love this Task lifecycle, but this is more specific implementation than we are expecting from this document. It would be great if you could add this to out Custom Task documentation so we have it written down somewhere.",
              "createdAt": "2024-07-19T16:53:47Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/en-us/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation. \n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/en-us/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/en-us/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has an ability to run tasks out of process via the called Task Host. That allows tasks to run in a different .NET runtime or bintess than the one used by the build engine for the build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started, MSBuild starts a process that runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build finishes execution, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache\n+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that the `return` and `output` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.\n+\n+There is also another Project Cache Plugin, which focuses on result cache in distributed builds. More information about it is in the Extensibility section.\n+\n+## Scheduler\n+The scheduler is the part of the MSBuild engine responsible for scheduling work to different nodes, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a working node (generally the in-proc node). The project's execution starts and proceeds until the whole operation ends or is blocked. A node is considered blocked, when the project that it is currently building depends on another project that has not yet finished executing. Once a node is not proceeding with the current project, the scheduler then asseses if it has more work to be given to that node and assigns it.\n+\n+On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed targets, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. Since the scheduler and project are generally in different processes, this communication happens within the engine using built-in loggers.\n+\n+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current execution, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and assigns the dependency to be executed to either the current node or another one that is free.\n+\n+### Incremental build\n+Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from each project build is saved in memory, which becomes one big cache for MSBuild.\n+\n+## Parallelism\n+Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently from projects.\n+\n+For multi-targeted builds parallelism works slightly different. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.\n+\n+\n+## IPC (Inter-Process Communication)\n+In multi-process MSBuild execution, many OS processes exist that need to communicate with each other. There are two main reasons:\n+ - Dealing with blocked tasks on processes: Communicating with the engine, scheduler, cache, etc...\n+ - Communication on task execution for a task host: Task definition, task inputs, task outputs.\n+\n+The transportation layer for messages are based on a .NET pipe implementattion. These pipes are specifically for windows, while the unix system implmentation has a wrap around sockets for the same functionality.\n+\n+The message layer has a custom serialization protocal that is specific to MSBuild.It is designed so implementing new types for new messages is easy, oinly needs to implement the `ITranslatable` interface. All message types used are known internal MSBuild types, that also have an extra field with a `string, string` disctionary to support extra user messages.\n+\n+## Graph build\n+A graph build changes the sequence in which MSBuild processes projects. Normally a project starts execution, and when it has a dependency on another project, then that project starts to build. A graph build evaluates all projects and their relationship before starting execution of any project. This is achieved by looking at specific items in the XML (like Project Reference) to construct the dependency graph.\n+\n+There are a couple of different modes to run graph mode in:\n+- Standard mode: Tried to work from the leaves of the dependency graph and makes sure all results are within the cache. If there is a cache miss / unexpected reference, it just schedules the missing reference for execution.\n+- Strict / isolate mode: If there is a cache miss when building, the whole built is failed. This is used mostly for distributed system builds.\n+\n+## MSBuid Server\n+In normal MSBuild execution the main process is cleared after the build ends, or after a set time limit. The MSBuild Server project aims to change that, making the entry point process and the scheduler process node separate entities. This allows processes to preserve in-memory cache and make consecutive builds faster.\n+\n+# Extensibilities\n+MSBuild includes some extra features that are related to the build process but does not fit on the previous categories. These extensibility features are critical for the build process, but they can also be customized by third parties for their own use.\n+\n+## Packaging system\n+MSBuild interacts with external packages in almost every build. However, the MSBuild engine does not recognize external packages as third parties, and it also does not handle external dependencies. This is done by a packaging system. The supported one being NuGet. As such, it is NuGet that is responsible for finding the packages, downloading them, and providing the MSBuild engine with a package path for the build.\n+\n+## Restore\n+The restore operation is a built-in target within MSBuild. The main function is to walk through the project references and `packages.config` file about all the packages that need to be restored. This process is executed by NuGet, as MSBuild does not have a packaging system within the code.\n+\n+## Tasks\n+",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nMSBuild is a build platform used mainly for .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\r\n```",
              "createdAt": "2024-07-15T18:20:15Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe MSBuild XML is built around representing a project's data. It uses various attributes to do so:\r\n```",
              "createdAt": "2024-07-15T18:21:12Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability. \n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/en-us/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](https://github.com/dotnet/msbuild/blob/main/src/Build/Microsoft.Build.csproj). \n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I would reorder this so properties and items are first: there are plenty of user projects that have only properties and items.",
              "createdAt": "2024-07-15T18:30:37Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](..src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThese attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but the MSBuild command-line application can parse them to find projects to build.\r\n```",
              "createdAt": "2024-07-15T18:31:30Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](..src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Many tasks are defined within MSBuild itself, but tasks can also be authored by third parties by implementing the `ITask` interface.\r\n```",
              "createdAt": "2024-07-15T18:32:37Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](..src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Because \"attribute\" means something very specific in XML I would prefer to avoid it here in favor of \"element\" (the correct XML word) or \"concept\" (extremely general).",
              "createdAt": "2024-07-15T18:34:01Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](..src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe MSBuild programming language is a subset of XML with a focus on describing a project. You can see an [example project here](../src/Build/Microsoft.Build.csproj).\r\n```",
              "createdAt": "2024-07-15T18:36:27Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](..src/Build/Microsoft.Build.csproj).",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "this is missing the \"common targets that define what a build means to MSBuild\" part; I generally combine the engine with the CLI/API interface in my \"three things\" lists.",
              "createdAt": "2024-07-15T18:37:54Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Added a new item on the list to cover common targets.",
              "createdAt": "2024-07-17T20:11:35Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThis document covers all parts of MSBuild in a general manner from the perspective of an MSBuild codebase maintainer. There will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Microsoft Learn's MSBuild documentation](https://learn.microsoft.com/visualstudio/msbuild).\r\n```",
              "createdAt": "2024-07-15T18:42:21Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nWhile the project file defines the data used for the build, the actual build instructions are generally imported from a common location through the `Import` element or MSBuild SDKs that contain their own tasks and targets. One example that is widely used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\r\n```",
              "createdAt": "2024-07-15T18:45:43Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This section conflates the .NET API with common targets, and I think we'd be better off separating those things.\r\n\r\n```suggestion\r\nThe MSBuild API is a .NET library with a focus on building and extracting data from MSBuild projects. It is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\r\n```",
              "createdAt": "2024-07-15T18:48:02Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Separated into Common Targets and API sections",
              "createdAt": "2024-07-17T20:20:26Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Important use cases for Visual Studio:\r\n\r\n* Extract information from a project, like \"what source files should I draw in the project tree view?\"\r\n* Design-time builds (extension of the above with more custom code execution)\r\n* Edit operations that reflect MSBuild-level changes (like \"set a property\") down to XML edits",
              "createdAt": "2024-07-15T18:51:33Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Added these to the new common targets section",
              "createdAt": "2024-07-17T20:33:57Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. This includes managing the extensibility that MSBuild offers, integrating customizations into the build process even if they're authored by third parties.\r\n```",
              "createdAt": "2024-07-15T18:52:20Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You're not wrong or anything but I don't think saying this here is super helpful and would cut it\r\n\r\n```suggestion\r\nThe MSBuild engine's logic is divided into two main stages: the evalution stage and the execution stage.\r\n```",
              "createdAt": "2024-07-15T18:53:13Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd go so far as to say that we only support the API and these are the partners we care about the most, rather than supported entry points.",
              "createdAt": "2024-07-15T18:54:45Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I have removed the official support line and have been more explicit on what the team is responsible for.",
              "createdAt": "2024-07-17T20:10:44Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n - Build logic for the projects, either from the project's XML, or from imports referenced the entry point project.\r\n```",
              "createdAt": "2024-07-15T19:43:31Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What do you mean by \"entry point\" here?",
              "createdAt": "2024-07-15T19:45:06Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Specified that it is entry point project.",
              "createdAt": "2024-07-17T20:35:15Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nEvaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Some API consumers, like Visual Studio project systems, extract information about which C# files, solution files and project files are relevant to a project after evaluation.\r\n```",
              "createdAt": "2024-07-15T19:46:01Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Restore is interesting. Maybe even deserving of its own section. It's _not_ very interesting in terms of MSBuild, but scenario-wise the timing and implementation details of restore should  be here.",
              "createdAt": "2024-07-15T19:48:34Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "There is a restore section further down in the document, under extensibilities.",
              "createdAt": "2024-07-17T20:36:34Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "```suggestion\r\n - The generated build imports (`.g.props` and `.g.targets`) from NuGet restore.\r\n \r\n More on this in the [**Restore**](#restore) section below.\r\n```",
              "createdAt": "2024-07-18T07:52:41Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.",
              "author": {
                "login": "Nirmal4G"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same project, each of which has a defined role and is required for subsequent passes. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same build logic. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\r\n```",
              "createdAt": "2024-07-15T19:50:28Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "> Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\r\n\r\nNot sure I understand this. Can you elaborate? Items can be updated/removed/appended and properties can be overwritten during their own passes, but e.g. the item pass doesn't affect properties.",
              "createdAt": "2024-07-15T19:51:42Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Broke down the paragraph and elaborated on when properties can be modified or read.",
              "createdAt": "2024-07-17T21:00:33Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is just one exception (\"SDK resolvers run arbitrary .NET code during evaluation\") though I agree that calling NuGet out specifically is a good idea.",
              "createdAt": "2024-07-15T19:52:34Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n### Imports\r\n\r\n```",
              "createdAt": "2024-07-15T19:52:44Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Worth mentioning SDKs here I think",
              "createdAt": "2024-07-15T20:11:52Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Are you thinking of `ToolsVersion`? Maybe rewrite to something like\r\n\r\n> Historically a single version of MSBuild supported multiple `ToolsVersion`s that could result in differing imports for the same expression, but today an MSBuild distribution provides only one `ToolsVersion` and selection between versions is expected to be done outside of MSBuild.",
              "createdAt": "2024-07-15T20:13:42Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Worth mentioning I think that a request comes with a list of targets and they're built according to the ordering rules.",
              "createdAt": "2024-07-15T20:14:51Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Move to the `Tasks` section?",
              "createdAt": "2024-07-15T20:15:27Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has an ability to run tasks out of process via the called Task Host. That allows tasks to run in a different .NET runtime or bintess than the one used by the build engine for the build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think this section should include some details about between-project dependencies and ordering.",
              "createdAt": "2024-07-15T20:16:11Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If a task hard crashes it's bad either way, there's not a HUGE improvement in recoverability/diagnosability by pushing it OOP.",
              "createdAt": "2024-07-15T20:23:11Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has an ability to run tasks out of process via the called Task Host. That allows tasks to run in a different .NET runtime or bintess than the one used by the build engine for the build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nMSBuild has an ability to run tasks out of process via the called Task Host. That allows tasks to run in a different .NET runtime or bitness than the one used by the build engine for the build execution.\r\n```",
              "createdAt": "2024-07-15T20:23:45Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has an ability to run tasks out of process via the called Task Host. That allows tasks to run in a different .NET runtime or bintess than the one used by the build engine for the build execution.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Important to distinguish between the API and the CLI behavior here. Specifically what you described is the default CLI behavior; in VS the `devenv.exe` process is the scheduler node (and it's super long lived)",
              "createdAt": "2024-07-15T20:25:09Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has an ability to run tasks out of process via the called Task Host. That allows tasks to run in a different .NET runtime or bintess than the one used by the build engine for the build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started, MSBuild starts a process that runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build finishes execution, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This one is important for performance AND correctness so I'd push it to the top of the list.",
              "createdAt": "2024-07-15T20:27:57Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has an ability to run tasks out of process via the called Task Host. That allows tasks to run in a different .NET runtime or bintess than the one used by the build engine for the build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started, MSBuild starts a process that runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build finishes execution, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches\n+### Register Task Objects\n+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.\n+\n+### Project result cache",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd also add \"incremental build\"/on-disk state as a \"cache\".",
              "createdAt": "2024-07-15T20:28:18Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has an ability to run tasks out of process via the called Task Host. That allows tasks to run in a different .NET runtime or bintess than the one used by the build engine for the build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started, MSBuild starts a process that runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build finishes execution, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Added a new section for incremental build cacheing.",
              "createdAt": "2024-07-18T11:09:35Z",
              "path": "documentation/High-level-overview.md",
              "diffHunk": "@@ -0,0 +1,166 @@\n+# What is MSBuild\n+MSBuild is a build platform used mainly for C# projects within .NET and Visual Studio. But when referencing MSBuild technically we can divide what MSBuild is in 3 main parts:\n+- Programming language that uses XML semantics to define build actions and data.\n+- API and command line program that interprets and manipulates the programming language.\n+- Build engine that executes a build based on the programming language inputs.\n+\n+MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.\n+\n+This document covers all parts of MSBuild in a general manner. So, there will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit [Learn Microsoft](https://learn.microsoft.com/visualstudio/msbuild).\n+\n+\n+# MSBuild XML Language\n+The MSBuild programming language is a programming language that uses XML semantics with a focus on describing a project. You can see an [exmaple here](../src/Build/Microsoft.Build.csproj).\n+\n+The MSBuilkd XML is built around representing a project's data. It uses various attributes to do so:\n+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Most used tasks are defined within MSBuild itself but can also be externally authored by implementing the `ITask` interface.\n+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.\n+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are inputs to the build system, mostly to tasks or targets. They can represent project files, code files, libraries and most things that a project can depend on.\n+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.\n+\n+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). `.sln` solution files are not written with MSBuild XML, but those are interpreted during build process so all projects can be identified.\n+\n+Since the project file defines the data used for the build, the actual build instructions are imported through imports or/and SDKs, that contains their own tasks and targets. One example that is vastly used is the [.NET SDK](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk).\n+\n+# MSBuild API\n+The MSBuild API is a library with a focus on building .NET programs, as such it is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. The library includes common build logic and targets, like creation and management of output folder, intermidiary folders, custom task creation, etc... This also allows programs (like Visual Studio) to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly.\n+\n+## ToolTask\n+ToolTask is an interface offered by MSBuild to implement custom tasks. During the build, the MSBuild Engine will construct the task, call the execute method and let it run during execution. This process has performance advantages on windows when compared to writing a script to do the same work.\n+\n+# Engine\n+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. Which includes managing the extensibilities modules that MSBuild offers, integrating them into this process even if they're authored by third parties.\n+\n+Building a project can easily become a huge and time-consuming project. To simplify things the MSBuild's engine logic is divided into two main stages: the evalution stage and the execution stage.\n+\n+## Entry points\n+There are a few officially supported entry points for the engine: Visual Studio, .NET SDK and the CLI executable (`MSBuild.exe`). All these methods are an implementation or extension of the MSBuild API. The inputs necessary to start a build include:\n+ - Build logic for the projects, either from user generated on the project's XML, or from implicit imports by the entry point programs.\n+ - User defined imports\n+ - `.g.props` from NuGet restore.\n+\n+\n+An example of the imported build logic is the `<Project Sdk=\"Microsoft.NET.Sdk\">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic that comes with the .NET SDK.\n+\n+## Evaluate operation\n+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).\n+\n+Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking entry point, imports, items, and tasks. Additionally, for Visual Studio it also gathers information about which C# files, solution files and project files are checked in the IDE.\n+\n+The first step of evaluation is to load the project file and the XML data it contains. There are multiple passes within the same file to collect data, some of those to specifically define project properties and imports that are necessary for other tasks. At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brough within the project logic, so other projects can refence the same import logic instead of having a copy of the same data. Data loaded within the evaluation are not used until execution stage. This means that data can be added and modified during evaluation.\n+\n+The evaluation stage should not have any side effect on disk, no new or deleted files. Two exceptions for this are:\n+ - SDK resolution\n+ - NuGet SDK, which might add packages to the disk\n+\n+### imports\n+Complex projects generally include imports of many different types. In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.\n+\n+In the case of tool imports, MSBuild does not process tool resolution via registry. Instead, it is resolved by looking on adjacent folder to the current running version of MSBuild. The folders will be different depending is MSBuild is running from Visual Studio or the .NET SDK.\n+\n+## Execution operation\n+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).\n+\n+The execution phase is simply executing the targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).\n+\n+### Task Host\n+MSBuild has an ability to run tasks out of process via the called Task Host. That allows tasks to run in a different .NET runtime or bintess than the one used by the build engine for the build execution.\n+\n+This is an opt-in behavior that can be used for various cases:\n+- If a task breaks the build process it can be relegated to the Task Host, so it does not influence the main build.\n+- If a task is built in the same repo that is currently being built by MSBuild and the code might change. So, Task Host makes sure the DLLs are not locked at the end of the build.\n+\n+## Processes and nodes\n+When a new build is started, MSBuild starts a process that runs some setup code and prepares itself to start a build. This first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build finishes execution, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. This is offset by having longer lived processes, that can be reused when building projects successionally.\n+\n+## Caches",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      }
    ]
  }
}