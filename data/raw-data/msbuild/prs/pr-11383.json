{
  "number": 11383,
  "title": "Implement out-of-proc RAR node lifecycle",
  "body": "### Context\r\nThis implements the full node lifecycle and execution flow for an out-of-proc RAR node via an additional `nodemode`. This does not yet execute the RAR task itself, or serialize anything other than empty dummy payloads - enabling the feature will only run a test message and then fall back to in-proc execution.\r\n\r\n### Changes Made\r\n#### New RAR nodemode\r\n- Setting `$env:MSBuildRarNode=1` conditions the `RarNodeLauncher` to create a new instance of `msbuild.exe /nodemode:3`. This runs a persistent out-of-proc RAR node which can receive serialized requests from a RAR task client in another process, execute the task, and serialize back the outputs.\r\n- IPC and serialization logic reuses existing MSBuild node infrastructure.\r\n- Currently, this does not actually invoke the RAR task, and the request/response objects are empty data structures - but it does implement the full execution and communication flow between the client and server. The only component missing for the feature to be functional (aka executing the RAR task) is populating the request/response with the real RAR inputs/outputs.\r\n\r\n#### Conditioning execution\r\n- `EngineServices.IsOutOfProcRarNodeEnabled` tells the RAR task whether to run out-of-proc. This is necessary since we want the task to avoid trying to connect to the node if MSBuild was launched without the flag enabled, which can differ between builds. This is not easily achieved via environment variables due to node reuse.\r\n- MSBuild property `ResolveAssemblyReferencesOutOfProcess` can be used to exclude a specific target from running out-of-proc.\r\n\r\n#### RAR Out-Of-Proc Node\r\n- The out-of-proc node manages two pipe servers - a single-instance server for handling the lifecycle of the node and preventing duplicate nodes from running, and a multi-instance server for executing multiple RAR tasks concurrently.\r\n\r\n#### RAR Out-Of-Proc Client\r\n- A per-build-node client is shared across all RAR invocations within a build by registering the instance to the host `BuildEngine`. This ensures that we don't pay overhead cost of reconnecting / repeating handshakes for every task, while still disposing of the client between builds to prevent an idle reused MSBuild node from holding on to a server instance.\r\n\r\n### Testing\r\n\r\nYou can validate the feature is functional by setting `$env:MSBuildRarNode=1` and checking tracing logs + active processes. Untested code is mostly glue and orchestrating pipe connections. The most brittle code (IPC / serialization) already has test coverage from other MSBuild node implementations.\r\n\r\n### Notes\r\n\r\n- Env var should be replaced by an actual MSBuild flag in the future, but holding off as the feature is still WIP\r\n- Need feedback for consistent naming scheme (e.g. is this the RAR out-of-proc service or RAR node? Should RAR be abbreviated everywhere in the node-related types?)",
  "state": "MERGED",
  "createdAt": "2025-02-04T10:09:14Z",
  "updatedAt": "2025-05-26T07:07:24Z",
  "closedAt": "2025-05-26T07:07:23Z",
  "mergedAt": "2025-05-26T07:07:23Z",
  "additions": 666,
  "deletions": 7,
  "changedFiles": 22,
  "headRefName": "dev/chcasta/rar-pr-1",
  "isDraft": false,
  "author": {
    "login": "ccastanedaucf"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "rainersigwald"
      },
      {
        "login": "SimaTian"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "6e215d4e41e432486f0774fcf0b65b084854bac7",
          "message": "Implement out-of-proc RAR node lifecycle",
          "committedDate": "2025-05-07T21:58:41Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4b7e5b1816d5e26b721c6ff13acb8c1ccdfc534d",
          "message": "Fix CI test (bump EngineServices version)",
          "committedDate": "2025-05-07T21:58:42Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "661300692691ddd1cd1806c5e814c19ccd11bd73",
          "message": "Fix connection logic for Node reuse scenarios",
          "committedDate": "2025-05-07T21:58:42Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eb00e2f46027508c45c3a72101dc450880094dd9",
          "message": "Rebase + fix missing ValueTask (reference System.Threading.Channels)",
          "committedDate": "2025-05-07T21:58:42Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0ec1d0bd3928f9dd2e10114efc145d5d811c7128",
          "message": "Switch server to async APIs from shared IPC",
          "committedDate": "2025-05-07T21:58:42Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4a30ed7a3b8f6eda78ed5afecdedffa8e1b44ea3",
          "message": "Move channels under netstandard itemgroup",
          "committedDate": "2025-05-07T21:58:42Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4add6ce3ff590db38b492efde60fff50d2bbba85",
          "message": "Changes for rebase (won't compile till !11650 is merged)",
          "committedDate": "2025-05-07T21:58:42Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ab8eb4bc2c9f9fce64c8de97073e49b476d7e2e0",
          "message": "Rename / flip out-of-proc override",
          "committedDate": "2025-05-07T23:36:49Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a37ff7f341867aad15f6569154ea16fb40c3e2f7",
          "message": "Condition multi-instance pipe flag, assert all succeed",
          "committedDate": "2025-05-07T23:44:01Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2b8aecd627b5dad0fb236e7393d00fc9b558daa3",
          "message": "Remove fire-and-forget TODO",
          "committedDate": "2025-05-08T00:06:29Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "654f4ec4e7e16e952e976698f68df1f1088924c2",
          "message": "Seal types",
          "committedDate": "2025-05-08T02:38:09Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "096916f78538e34ff3b88aeb5fc21c0b65bdc9c3",
          "message": "Startup perf: Fire and forget launcher",
          "committedDate": "2025-05-08T02:44:23Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fb8fb89cc35895580dc25b443834546a78b6e1e7",
          "message": "Startup perf: Skip expensive process ID check in ServerNodeHandshake",
          "committedDate": "2025-05-08T02:44:56Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "df240e1be8e4b316b177e31ff85bd58c07c54ce9",
          "message": "Accessor oopsie",
          "committedDate": "2025-05-08T03:18:05Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2dc7fef4b24bba603c2d03231eb473cd0372b569",
          "message": "Disposal comment",
          "committedDate": "2025-05-21T00:33:35Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4e68b557e140d536d1abf570adda5eaa85e9abc7",
          "message": "Propogate UnauthorizedAccessException",
          "committedDate": "2025-05-21T00:33:38Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f60d13583364ed35bc2f09e7a13065f3dde98a6d",
          "message": "Trace endpoint cancellation",
          "committedDate": "2025-05-21T00:33:40Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c6a90cf7e21a72a14e1dc33178ac38c5dae77809",
          "message": "Change prop 'Disabled' to 'Allow'",
          "committedDate": "2025-05-21T00:33:41Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7c2d80f8d0993927aad9b89c4c2faa72a80b94ce",
          "message": "Startup perf: Pre-run RAR static resource intializers",
          "committedDate": "2025-05-21T23:39:18Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a21a68511ee49f7f26d758999d9caa0341a8a2da",
          "message": "Startup perf: Lift common state initialization to host node",
          "committedDate": "2025-05-21T23:39:28Z",
          "author": {
            "name": "Christian Castaneda",
            "email": "chcasta@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Would you be able to separate the pure code moves and actual code changes? It's fine to keep all in a single PR, but separate commits would be great.\r\n\r\nIt'll help speed up and focus the reviews.",
        "createdAt": "2025-02-04T19:54:12Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "FYI I'm separating the code moves (named pipe / IPC stuff) into another PR since I've been further consolidating the IPC code that's duplicated across all node implementations, and that's a bit more risk given the different code paths for the APM and TPL-based versions due to .NET 3.5 compat for the TaskHost. `NodeProviderOutOfProcBase`, `NodeEndpointOutOfProcBase`, `MSBuildClient`, and `MSBuildClientPacketPump` all use effectively the same logic for setting up the client and server, handshake, sending and receiving packets, serialization, ect., in a way that isn't really reusable via inheritance. Cuts out a pretty big chunk of code from the RAR node implementation too.\r\n\r\nWill be updating the main work item with the overall design / ordering of PRs so it helps to see where this is going, since there's still ~5 or so main components after this. But that should be the only real code move / refactoring required for the whole project.",
        "createdAt": "2025-02-21T23:57:41Z",
        "author": {
          "login": "ccastanedaucf"
        }
      },
      {
        "body": "There are some minor conflicts, probably due to the perf work from @Erarndt we recently merged.\r\nYou have more context than me @ccastanedaucf , can you take a look please?",
        "createdAt": "2025-03-04T09:57:53Z",
        "author": {
          "login": "SimaTian"
        }
      },
      {
        "body": "Relevant changes are in second commit - I just rebased on the active IPC pr since this depends on it.",
        "createdAt": "2025-03-13T14:58:43Z",
        "author": {
          "login": "ccastanedaucf"
        }
      },
      {
        "body": "Updated PR description to accurately represent changes since all of the IPC code was extracted into #11546 \r\n\r\nCan ignore the first commit and merge conflicts since it's just a result of copying over #11546 (will rebase once that's merged)",
        "createdAt": "2025-03-19T02:54:16Z",
        "author": {
          "login": "ccastanedaucf"
        }
      },
      {
        "body": "Kk since the IPC stuff got merged, this is also good to go other than this compile error I hit after rebasing:\r\n```\r\nD:\\src\\msbuild\\rawr-pr-1\\src\\Shared\\NodePipeBase.cs(238,23): error CS0246: The type or namespace name 'ValueTask<>' could not be found (are you missing a using directive or an assembly reference?) [D:\\src\\msb\r\nuild\\rawr-pr-1\\src\\Tasks\\Microsoft.Build.Tasks.csproj::TargetFramework=netstandard2.0]\r\n```\r\nI think this is from the change which swapped `Task` for `ValueTask` in some hot paths.\r\n\r\nIt seems like referencing `System.Threading.Channels` pulls in `ValueTask` correctly (since we don't seem have a ref for `System.Threading.Tasks.Extensions`), but then I get the additional pre-built error in CI:\r\n```\r\n.packages/microsoft.dotnet.arcade.sdk/9.0.0-beta.25164.2/tools/SourceBuild/AfterSourceBuild.proj#L81\r\n\r\n.packages/microsoft.dotnet.arcade.sdk/9.0.0-beta.25164.2/tools/SourceBuild/AfterSourceBuild.proj(81,5): error : (NETCORE_ENGINEERING_TELEMETRY=AfterSourceBuild) 1 new pre-builts discovered! Detailed usage report can be found at /__w/1/s/artifacts/sb/prebuilt-report/baseline-comparison.xml.\r\nSee https://aka.ms/dotnet/prebuilts for guidance on what pre-builts are and how to eliminate them.\r\nPackage IDs are:\r\nMicrosoft.Bcl.AsyncInterfaces.9.0.0\r\n```\r\n\r\nAnything that can be done to resolve this? Ideally I would have access to `Channels` here anyways since a future PR is planning to use it for queueing log messages.\r\n\r\nOtherwise the simplest thing would to swap `NodePipeBase` back to using `Task` to get this unblocked.",
        "createdAt": "2025-03-27T22:55:55Z",
        "author": {
          "login": "ccastanedaucf"
        }
      },
      {
        "body": "Had to force push to test off main, just small changes starting from ~6 [Rename / flip out-of-proc override - ab8eb4b](https://github.com/dotnet/msbuild/pull/11383/commits/ab8eb4bc2c9f9fce64c8de97073e49b476d7e2e0)",
        "createdAt": "2025-05-08T02:54:59Z",
        "author": {
          "login": "ccastanedaucf"
        }
      },
      {
        "body": "cc @rainersigwald please final look and we're good to go?",
        "createdAt": "2025-05-13T13:55:01Z",
        "author": {
          "login": "SimaTian"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "future proofing: when does it become a good time to switch to a switch, given the increasing number of node types?",
              "createdAt": "2025-03-04T08:38:27Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3420,6 +3426,21 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches, bool\n                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();\n                     shutdownReason = node.Run(out nodeException);\n                 }\n+                else if (nodeModeNumber == 3)",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would it be reasonable to refactor this in a manner that doesn't use interwoven #if directives or would it lead to too many branches? (and if so, maybe some more shuffling could help?)\r\nIn an IDE it will probably be somewhat more readable, however as-is it is tad clunky to parse what happens when.\r\n",
              "createdAt": "2025-03-04T08:48:06Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -438,6 +457,267 @@ internal static void SetEnvironment(IDictionary<string, string> newEnvironment)\n         }\n \n #nullable enable\n+        internal static NamedPipeClientStream CreateSecurePipeClient(string pipeName)\n+        {\n+#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter\n+            return new NamedPipeClientStream(\n+                serverName: \".\",\n+                pipeName,\n+                PipeDirection.InOut,\n+                PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter\n+        }\n+\n+        internal static void ConnectToPipeStream(NamedPipeClientStream pipeClient, string pipeName, Handshake handshake, int timeout = DefaultConnectTimeout)\n+        {\n+            Trace(\"Attempting connect to pipe {0} with timeout {1} ms\", pipeName, timeout);\n+\n+            pipeClient.Connect(timeout);\n+\n+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                // Verify that the owner of the pipe is us.  This prevents a security hole where a remote node has\n+                // been faked up with ACLs that would let us attach to it.  It could then issue fake build requests back to\n+                // us, potentially causing us to execute builds that do harmful or unexpected things.  The pipe owner can\n+                // only be set to the user's own SID by a normal, unprivileged process.  The conditions where a faked up\n+                // remote node could set the owner to something else would also let it change owners on other objects, so\n+                // this would be a security flaw upstream of us.\n+                ValidateRemotePipeSecurityOnWindows(pipeClient);\n+            }\n+#endif\n+\n+            SendHandshake(pipeClient, pipeName, handshake, timeout);\n+\n+            // We got a connection.\n+            Trace(\"Successfully connected to pipe {0}...!\", pipeName);\n+        }\n+\n+        /// <summary>\n+        /// Connect to named pipe stream and ensure validate handshake and security.\n+        /// </summary>\n+        internal static void SendHandshake(NamedPipeClientStream pipeClient, string pipeName, Handshake handshake, int timeout)\n+        {\n+\n+            int[] handshakeComponents = handshake.RetrieveHandshakeComponents();\n+            for (int i = 0; i < handshakeComponents.Length; i++)\n+            {\n+                Trace(\"Writing handshake part {0} ({1}) to pipe {2}\", i, handshakeComponents[i], pipeName);\n+                pipeClient.WriteIntForHandshake(handshakeComponents[i]);\n+            }\n+\n+            // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.\n+            pipeClient.WriteEndOfHandshakeSignal();\n+\n+            Trace(\"Reading handshake from pipe {0}\", pipeName);\n+\n+#if NETCOREAPP2_1_OR_GREATER\n+            pipeClient.ReadEndOfHandshakeSignal(true, timeout);\n+#else\n+            pipeClient.ReadEndOfHandshakeSignal(true);\n+#endif\n+        }\n+\n+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+        // This code needs to be in a separate method so that we don't try (and fail) to load the Windows-only APIs when JIT-ing the code\n+        //  on non-Windows operating systems\n+        private static void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream pipeClient)\n+        {\n+            SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;\n+#if FEATURE_PIPE_SECURITY\n+            PipeSecurity remoteSecurity = pipeClient.GetAccessControl();\n+#else\n+            var remoteSecurity = new PipeSecurity(pipeClient.SafePipeHandle, System.Security.AccessControl.AccessControlSections.Access | System.Security.AccessControl.AccessControlSections.Owner | System.Security.AccessControl.AccessControlSections.Group);\n+#endif\n+            IdentityReference remoteOwner = remoteSecurity.GetOwner(typeof(SecurityIdentifier));\n+            if (remoteOwner != identifier)\n+            {\n+                Trace(\"The remote pipe owner {0} does not match {1}\", remoteOwner.Value, identifier.Value);\n+                throw new UnauthorizedAccessException();\n+            }\n+        }\n+#endif\n+\n+\n+        internal static NamedPipeServerStream CreateSecurePipeServer(string pipeName, int maxNumberOfServerInstances = 1, int pipeBufferSize = DefaultPipeBufferSize)\n+        {\n+#if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "Yup I'm about to put out a separate PR with the pipe communication refactor on its own. I did a pass through the flags and consolidated it down to FEATURE_PIPEOPTIONS_CURRENTUSERONLY and TASKHOST. The gist is that NETCore has the `CurrentUserOnly` flag which lets us skip manually validating the user, And since Mono is no long targeted, the Full Framework bits will always run on Windows.\r\n\r\nMost of these flags were either redundant or guarding against scenarios no longer supported.",
              "createdAt": "2025-03-06T01:22:50Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -438,6 +457,267 @@ internal static void SetEnvironment(IDictionary<string, string> newEnvironment)\n         }\n \n #nullable enable\n+        internal static NamedPipeClientStream CreateSecurePipeClient(string pipeName)\n+        {\n+#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter\n+            return new NamedPipeClientStream(\n+                serverName: \".\",\n+                pipeName,\n+                PipeDirection.InOut,\n+                PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter\n+        }\n+\n+        internal static void ConnectToPipeStream(NamedPipeClientStream pipeClient, string pipeName, Handshake handshake, int timeout = DefaultConnectTimeout)\n+        {\n+            Trace(\"Attempting connect to pipe {0} with timeout {1} ms\", pipeName, timeout);\n+\n+            pipeClient.Connect(timeout);\n+\n+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                // Verify that the owner of the pipe is us.  This prevents a security hole where a remote node has\n+                // been faked up with ACLs that would let us attach to it.  It could then issue fake build requests back to\n+                // us, potentially causing us to execute builds that do harmful or unexpected things.  The pipe owner can\n+                // only be set to the user's own SID by a normal, unprivileged process.  The conditions where a faked up\n+                // remote node could set the owner to something else would also let it change owners on other objects, so\n+                // this would be a security flaw upstream of us.\n+                ValidateRemotePipeSecurityOnWindows(pipeClient);\n+            }\n+#endif\n+\n+            SendHandshake(pipeClient, pipeName, handshake, timeout);\n+\n+            // We got a connection.\n+            Trace(\"Successfully connected to pipe {0}...!\", pipeName);\n+        }\n+\n+        /// <summary>\n+        /// Connect to named pipe stream and ensure validate handshake and security.\n+        /// </summary>\n+        internal static void SendHandshake(NamedPipeClientStream pipeClient, string pipeName, Handshake handshake, int timeout)\n+        {\n+\n+            int[] handshakeComponents = handshake.RetrieveHandshakeComponents();\n+            for (int i = 0; i < handshakeComponents.Length; i++)\n+            {\n+                Trace(\"Writing handshake part {0} ({1}) to pipe {2}\", i, handshakeComponents[i], pipeName);\n+                pipeClient.WriteIntForHandshake(handshakeComponents[i]);\n+            }\n+\n+            // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.\n+            pipeClient.WriteEndOfHandshakeSignal();\n+\n+            Trace(\"Reading handshake from pipe {0}\", pipeName);\n+\n+#if NETCOREAPP2_1_OR_GREATER\n+            pipeClient.ReadEndOfHandshakeSignal(true, timeout);\n+#else\n+            pipeClient.ReadEndOfHandshakeSignal(true);\n+#endif\n+        }\n+\n+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+        // This code needs to be in a separate method so that we don't try (and fail) to load the Windows-only APIs when JIT-ing the code\n+        //  on non-Windows operating systems\n+        private static void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream pipeClient)\n+        {\n+            SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;\n+#if FEATURE_PIPE_SECURITY\n+            PipeSecurity remoteSecurity = pipeClient.GetAccessControl();\n+#else\n+            var remoteSecurity = new PipeSecurity(pipeClient.SafePipeHandle, System.Security.AccessControl.AccessControlSections.Access | System.Security.AccessControl.AccessControlSections.Owner | System.Security.AccessControl.AccessControlSections.Group);\n+#endif\n+            IdentityReference remoteOwner = remoteSecurity.GetOwner(typeof(SecurityIdentifier));\n+            if (remoteOwner != identifier)\n+            {\n+                Trace(\"The remote pipe owner {0} does not match {1}\", remoteOwner.Value, identifier.Value);\n+                throw new UnauthorizedAccessException();\n+            }\n+        }\n+#endif\n+\n+\n+        internal static NamedPipeServerStream CreateSecurePipeServer(string pipeName, int maxNumberOfServerInstances = 1, int pipeBufferSize = DefaultPipeBufferSize)\n+        {\n+#if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "do we really want to enable it by default?",
              "createdAt": "2025-05-06T16:15:46Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -2385,6 +2385,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ResolveAssemblyReferencesStateFile Condition=\"'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''\">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>\n     </PropertyGroup>\n \n+    <PropertyGroup>\n+      <ResolveAssemblyReferencesOutOfProcess Condition=\"'$(ResolveAssemblyReferencesOutOfProcess)' == ''\">true</ResolveAssemblyReferencesOutOfProcess>",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "I suppose that this will be clarified later. now the code won't run because of the trait",
              "createdAt": "2025-05-07T10:57:45Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -2385,6 +2385,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ResolveAssemblyReferencesStateFile Condition=\"'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''\">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>\n     </PropertyGroup>\n \n+    <PropertyGroup>\n+      <ResolveAssemblyReferencesOutOfProcess Condition=\"'$(ResolveAssemblyReferencesOutOfProcess)' == ''\">true</ResolveAssemblyReferencesOutOfProcess>",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "So this is a per-project opt-out property, not necessarily the control flag. Maybe flipping the condition + rename would make this more clear?",
              "createdAt": "2025-05-07T18:17:26Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -2385,6 +2385,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ResolveAssemblyReferencesStateFile Condition=\"'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''\">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>\n     </PropertyGroup>\n \n+    <PropertyGroup>\n+      <ResolveAssemblyReferencesOutOfProcess Condition=\"'$(ResolveAssemblyReferencesOutOfProcess)' == ''\">true</ResolveAssemblyReferencesOutOfProcess>",
              "author": {
                "login": "ccastanedaucf"
              }
            },
            {
              "body": "Just flipped this to `DisableResolveAssemblyReferencesOutOfProcNode` (default false)",
              "createdAt": "2025-05-08T03:11:17Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -2385,6 +2385,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <ResolveAssemblyReferencesStateFile Condition=\"'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''\">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>\n     </PropertyGroup>\n \n+    <PropertyGroup>\n+      <ResolveAssemblyReferencesOutOfProcess Condition=\"'$(ResolveAssemblyReferencesOutOfProcess)' == ''\">true</ResolveAssemblyReferencesOutOfProcess>",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How important is this? Do you plan to do it at a later stage? Can you add this to the spec?",
              "createdAt": "2025-05-07T09:19:46Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -559,6 +559,19 @@ public void BeginBuild(BuildParameters parameters)\n                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath(\"msbuild-cache\");\n                 }\n \n+                // Launch the RAR node before the detoured launcher overrides the default node launcher.\n+                if (_buildParameters.EnableRarNode)\n+                {\n+                    NodeLauncher nodeLauncher = ((IBuildComponentHost)this).GetComponent<NodeLauncher>(BuildComponentType.NodeLauncher);\n+                    RarNodeLauncher rarNodeLauncher = new(nodeLauncher);\n+\n+                    // TODO: Evaluate making this fire-and-forget so we can continue with the build.",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Not super important - since testing I haven't seen it show up as a perf issue, so I'm good to remove the TODO. Plus one bonus of running synchronously here is being able to override the feature if anything funky happens.",
              "createdAt": "2025-05-07T18:23:17Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -559,6 +559,19 @@ public void BeginBuild(BuildParameters parameters)\n                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath(\"msbuild-cache\");\n                 }\n \n+                // Launch the RAR node before the detoured launcher overrides the default node launcher.\n+                if (_buildParameters.EnableRarNode)\n+                {\n+                    NodeLauncher nodeLauncher = ((IBuildComponentHost)this).GetComponent<NodeLauncher>(BuildComponentType.NodeLauncher);\n+                    RarNodeLauncher rarNodeLauncher = new(nodeLauncher);\n+\n+                    // TODO: Evaluate making this fire-and-forget so we can continue with the build.",
              "author": {
                "login": "ccastanedaucf"
              }
            },
            {
              "body": "Ah I remember now, there's a slow kernel call from NodeLauncher always retrieving the process handle (which isn't used at all here). I just added the fire-and-forget since it's a basic blocking IO call.",
              "createdAt": "2025-05-08T03:02:21Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -559,6 +559,19 @@ public void BeginBuild(BuildParameters parameters)\n                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath(\"msbuild-cache\");\n                 }\n \n+                // Launch the RAR node before the detoured launcher overrides the default node launcher.\n+                if (_buildParameters.EnableRarNode)\n+                {\n+                    NodeLauncher nodeLauncher = ((IBuildComponentHost)this).GetComponent<NodeLauncher>(BuildComponentType.NodeLauncher);\n+                    RarNodeLauncher rarNodeLauncher = new(nodeLauncher);\n+\n+                    // TODO: Evaluate making this fire-and-forget so we can continue with the build.",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is this now needed? I'm a bit concerned this regresses security expectations. could a compromised user now spawn rogue instances that masquerade as legitimate endpoints?",
              "createdAt": "2025-05-07T11:18:15Z",
              "path": "src/Shared/NodePipeServer.cs",
              "diffHunk": "@@ -47,7 +47,7 @@ internal NodePipeServer(string pipeName, Handshake handshake, int maxNumberOfSer\n             // SIDs or the client will reject this server.  This is used to avoid attacks where a\n             // hacked server creates a less restricted pipe in an attempt to lure us into using it and\n             // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)\n-            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite, AccessControlType.Allow);\n+            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite | PipeAccessRights.CreateNewInstance, AccessControlType.Allow);",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Multi-instances pipes unfortunately don't work without the access right (the first succeeds, all others throw an exception). \r\n\r\nI can definitely condition this to only add the flag on the multi-instance path, and bail out if any of the pipes fail to start (which will happen if a single additional pipe instance already exists). Aren't both the client and server already restricted to the current user though? Aka if the current user is compromised (running some malicious tool), that's already one step away from read/writeprocessmemory and a host of other exploits on that user",
              "createdAt": "2025-05-07T20:00:42Z",
              "path": "src/Shared/NodePipeServer.cs",
              "diffHunk": "@@ -47,7 +47,7 @@ internal NodePipeServer(string pipeName, Handshake handshake, int maxNumberOfSer\n             // SIDs or the client will reject this server.  This is used to avoid attacks where a\n             // hacked server creates a less restricted pipe in an attempt to lure us into using it and\n             // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)\n-            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite, AccessControlType.Allow);\n+            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite | PipeAccessRights.CreateNewInstance, AccessControlType.Allow);",
              "author": {
                "login": "ccastanedaucf"
              }
            },
            {
              "body": "^^just did the above. Oddly enough, .NET Core doesn't need this flag, nor does it set it internally when passing `PipeOptions.CurrentUserOnly` + the multi-instance count... which makes me wonder if the `lpSecurityAttributes` that's currently produced is less restrictive.",
              "createdAt": "2025-05-08T03:05:47Z",
              "path": "src/Shared/NodePipeServer.cs",
              "diffHunk": "@@ -47,7 +47,7 @@ internal NodePipeServer(string pipeName, Handshake handshake, int maxNumberOfSer\n             // SIDs or the client will reject this server.  This is used to avoid attacks where a\n             // hacked server creates a less restricted pipe in an attempt to lure us into using it and\n             // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)\n-            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite, AccessControlType.Allow);\n+            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite | PipeAccessRights.CreateNewInstance, AccessControlType.Allow);",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "discussion: should `Node Reuse = false` imply RAR server does not run?",
              "createdAt": "2025-05-07T11:31:07Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -277,6 +279,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)\n             _culture = other._culture;\n             _defaultToolsVersion = other._defaultToolsVersion;\n             _enableNodeReuse = other._enableNodeReuse;",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "This is a tricky one since in distributed build (QuickBuild), we run every target individually with node reuse disabled so we can track accesses with Detours. *But* we still want to run RAR as its own untracked node since we want to ignore those accesses. So I think this becomes more of an issue whenever we decide on default behavior.",
              "createdAt": "2025-05-07T20:13:17Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -277,6 +279,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)\n             _culture = other._culture;\n             _defaultToolsVersion = other._defaultToolsVersion;\n             _enableNodeReuse = other._enableNodeReuse;",
              "author": {
                "login": "ccastanedaucf"
              }
            },
            {
              "body": "That said, the client would have the ability to kill the server if needed by sending a message to the master pipe. Which scenarios will require that in practice, unsure yet",
              "createdAt": "2025-05-07T20:23:22Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -277,6 +279,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)\n             _culture = other._culture;\n             _defaultToolsVersion = other._defaultToolsVersion;\n             _enableNodeReuse = other._enableNodeReuse;",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "this is where we'd return early if successful, right?",
              "createdAt": "2025-05-07T11:33:42Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3243,6 +3249,24 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr\n         /// <returns>True if there was success.</returns>\n         public override bool Execute()\n         {\n+            if (ExecuteOutOfProcess\n+                && BuildEngine is IBuildEngine10 buildEngine10\n+                && buildEngine10.EngineServices.IsOutOfProcRarNodeEnabled)\n+            {\n+                try\n+                {\n+#pragma warning disable CA2000 // Dispose objects before losing scope\n+                    _ = OutOfProcRarClient.GetInstance(buildEngine10).Execute(this);\n+#pragma warning restore CA2000 // Dispose objects before losing scope\n+                    CommunicationsUtilities.Trace(\"RAR out-of-proc test connection completed. Executing task in-proc.\");",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Correct",
              "createdAt": "2025-05-07T20:04:30Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3243,6 +3249,24 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr\n         /// <returns>True if there was success.</returns>\n         public override bool Execute()\n         {\n+            if (ExecuteOutOfProcess\n+                && BuildEngine is IBuildEngine10 buildEngine10\n+                && buildEngine10.EngineServices.IsOutOfProcRarNodeEnabled)\n+            {\n+                try\n+                {\n+#pragma warning disable CA2000 // Dispose objects before losing scope\n+                    _ = OutOfProcRarClient.GetInstance(buildEngine10).Execute(this);\n+#pragma warning restore CA2000 // Dispose objects before losing scope\n+                    CommunicationsUtilities.Trace(\"RAR out-of-proc test connection completed. Executing task in-proc.\");",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "why 0?",
              "createdAt": "2025-05-07T12:08:40Z",
              "path": "src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,79 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class RarNodeLauncher\n+    {\n+        private readonly INodeLauncher _nodeLauncher;\n+\n+        private readonly string _pipeName;\n+\n+        internal RarNodeLauncher(INodeLauncher nodeLauncher)\n+        {\n+            _nodeLauncher = nodeLauncher;\n+            _pipeName = NamedPipeUtil.GetRarNodePipeName(new(HandshakeOptions.None));\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process with the RAR nodemode.\n+        /// </summary>\n+        public bool Start()\n+        {\n+            if (IsRarNodeRunning())\n+            {\n+                CommunicationsUtilities.Trace(\"Existing RAR node found.\");\n+                return true;\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Launching RAR node...\");\n+\n+            try\n+            {\n+                LaunchNode();\n+            }\n+            catch (NodeFailedToLaunchException ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch RAR node: {0}\", ex);\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private bool IsRarNodeRunning()\n+        {\n+            // Determine if the node is running by checking if the expected named pipe exists.\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                const string NamedPipeRoot = @\"\\\\.\\pipe\\\";\n+\n+                // File.Exists() will crash the pipe server, as the underlying Windows APIs have undefined behavior\n+                // when used with pipe objects. Enumerating the pipe directory avoids this issue.\n+                IEnumerable<string> pipeNames = FileSystems.Default.EnumerateFiles(NamedPipeRoot);\n+\n+                return pipeNames.Contains(Path.Combine(NamedPipeRoot, _pipeName));\n+            }\n+            else\n+            {\n+                // On Unix, named pipes are implemented via sockets, and the pipe name is simply the file path.\n+                return FileSystems.Default.FileExists(_pipeName);\n+            }\n+        }\n+\n+        private void LaunchNode()\n+        {\n+            string msbuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            string commandLineArgs = string.Join(\" \", [\"/nologo\", \"/nodemode:3\"]);\n+            _ = _nodeLauncher.Start(msbuildLocation, commandLineArgs, nodeId: 0);",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Interface arg that doesn't get used in the default launcher:\r\nhttps://github.com/dotnet/msbuild/blob/695b1ef88c242c19a95c9f6a504a2376661762c2/src/Build/BackEnd/Components/Communications/NodeLauncher.cs#L38",
              "createdAt": "2025-05-07T20:16:41Z",
              "path": "src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,79 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class RarNodeLauncher\n+    {\n+        private readonly INodeLauncher _nodeLauncher;\n+\n+        private readonly string _pipeName;\n+\n+        internal RarNodeLauncher(INodeLauncher nodeLauncher)\n+        {\n+            _nodeLauncher = nodeLauncher;\n+            _pipeName = NamedPipeUtil.GetRarNodePipeName(new(HandshakeOptions.None));\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process with the RAR nodemode.\n+        /// </summary>\n+        public bool Start()\n+        {\n+            if (IsRarNodeRunning())\n+            {\n+                CommunicationsUtilities.Trace(\"Existing RAR node found.\");\n+                return true;\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Launching RAR node...\");\n+\n+            try\n+            {\n+                LaunchNode();\n+            }\n+            catch (NodeFailedToLaunchException ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch RAR node: {0}\", ex);\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private bool IsRarNodeRunning()\n+        {\n+            // Determine if the node is running by checking if the expected named pipe exists.\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                const string NamedPipeRoot = @\"\\\\.\\pipe\\\";\n+\n+                // File.Exists() will crash the pipe server, as the underlying Windows APIs have undefined behavior\n+                // when used with pipe objects. Enumerating the pipe directory avoids this issue.\n+                IEnumerable<string> pipeNames = FileSystems.Default.EnumerateFiles(NamedPipeRoot);\n+\n+                return pipeNames.Contains(Path.Combine(NamedPipeRoot, _pipeName));\n+            }\n+            else\n+            {\n+                // On Unix, named pipes are implemented via sockets, and the pipe name is simply the file path.\n+                return FileSystems.Default.FileExists(_pipeName);\n+            }\n+        }\n+\n+        private void LaunchNode()\n+        {\n+            string msbuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            string commandLineArgs = string.Join(\" \", [\"/nologo\", \"/nodemode:3\"]);\n+            _ = _nodeLauncher.Start(msbuildLocation, commandLineArgs, nodeId: 0);",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "question/observation so if some unrecoverable state was reached on RAR server that would cause exception on each request we'd continue to use the server wastefully? I'm not saying I know how to do it better.",
              "createdAt": "2025-05-07T12:27:40Z",
              "path": "src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks.AssemblyDependency\n+{\n+    /// <summary>\n+    /// Implements a single instance of a pipe server which executes the ResolveAssemblyReference task.\n+    /// </summary>\n+    internal class OutOfProcRarNodeEndpoint : IDisposable\n+    {\n+        private readonly int _endpointId;\n+\n+        private readonly NodePipeServer _pipeServer;\n+\n+        internal OutOfProcRarNodeEndpoint(int endpointId, ServerNodeHandshake handshake, int maxNumberOfServerInstances)\n+        {\n+            _endpointId = endpointId;\n+            _pipeServer = new NodePipeServer(NamedPipeUtil.GetRarNodeEndpointPipeName(handshake), handshake, maxNumberOfServerInstances);\n+\n+            NodePacketFactory packetFactory = new();\n+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteRequest, RarNodeExecuteRequest.FactoryForDeserialization, null);\n+            _pipeServer.RegisterPacketFactory(packetFactory);\n+        }\n+\n+        public void Dispose() => _pipeServer.Dispose();\n+\n+        internal async Task RunAsync(CancellationToken cancellationToken = default)\n+        {\n+            CommunicationsUtilities.Trace(\"({0}) Starting RAR endpoint.\", _endpointId);\n+\n+            try\n+            {\n+                await RunInternalAsync(cancellationToken);\n+            }\n+            catch (OperationCanceledException)\n+            {\n+                // Swallow cancellation excpetions for now. We're using this as a simple way to gracefully shutdown the\n+                // endpoint, instead of having to implement separate Start / Stop methods and deferring to the caller.\n+                // Can reevaluate if we need more granular control over cancellation vs shutdown.\n+            }\n+        }\n+\n+        private async Task RunInternalAsync(CancellationToken cancellationToken)\n+        {\n+            while (!cancellationToken.IsCancellationRequested)\n+            {\n+                while (!_pipeServer.IsConnected)\n+                {\n+                    _ = _pipeServer.WaitForConnection();\n+                }\n+\n+                CommunicationsUtilities.Trace(\"({0}) Received RAR request.\", _endpointId);\n+\n+                try\n+                {\n+                    INodePacket packet = await _pipeServer.ReadPacketAsync(cancellationToken);\n+\n+                    if (packet.Type == NodePacketType.NodeShutdown)\n+                    {\n+                        // Although the client has already disconnected, it is still necessary to Diconnect() so the\n+                        // pipe can transition into PipeState.Disonnected, which is treated as an intentional pipe break.\n+                        // Otherwise, all future operations on the pipe will throw an exception.\n+                        CommunicationsUtilities.Trace(\"({0}) RAR client disconnected.\", _endpointId);\n+                        _pipeServer.Disconnect();\n+                        continue;\n+                    }\n+\n+                    RarNodeExecuteRequest request = (RarNodeExecuteRequest)packet;\n+\n+                    // TODO: Use request packet to set inputs on the RAR task.\n+                    ResolveAssemblyReference rarTask = new();\n+\n+                    // TODO: bool success = rarTask.ExecuteInProcess();\n+                    // TODO: Use RAR task outputs to create response packet.\n+                    await _pipeServer.WritePacketAsync(new RarNodeExecuteResponse(), cancellationToken);\n+\n+                    CommunicationsUtilities.Trace(\"({0}) Completed RAR request.\", _endpointId);\n+                }\n+                catch (Exception e) when (e is not OperationCanceledException)",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Yeah this will need a bit of dogfooding to figure out what the non-recoverable states look like.",
              "createdAt": "2025-05-07T20:19:51Z",
              "path": "src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks.AssemblyDependency\n+{\n+    /// <summary>\n+    /// Implements a single instance of a pipe server which executes the ResolveAssemblyReference task.\n+    /// </summary>\n+    internal class OutOfProcRarNodeEndpoint : IDisposable\n+    {\n+        private readonly int _endpointId;\n+\n+        private readonly NodePipeServer _pipeServer;\n+\n+        internal OutOfProcRarNodeEndpoint(int endpointId, ServerNodeHandshake handshake, int maxNumberOfServerInstances)\n+        {\n+            _endpointId = endpointId;\n+            _pipeServer = new NodePipeServer(NamedPipeUtil.GetRarNodeEndpointPipeName(handshake), handshake, maxNumberOfServerInstances);\n+\n+            NodePacketFactory packetFactory = new();\n+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteRequest, RarNodeExecuteRequest.FactoryForDeserialization, null);\n+            _pipeServer.RegisterPacketFactory(packetFactory);\n+        }\n+\n+        public void Dispose() => _pipeServer.Dispose();\n+\n+        internal async Task RunAsync(CancellationToken cancellationToken = default)\n+        {\n+            CommunicationsUtilities.Trace(\"({0}) Starting RAR endpoint.\", _endpointId);\n+\n+            try\n+            {\n+                await RunInternalAsync(cancellationToken);\n+            }\n+            catch (OperationCanceledException)\n+            {\n+                // Swallow cancellation excpetions for now. We're using this as a simple way to gracefully shutdown the\n+                // endpoint, instead of having to implement separate Start / Stop methods and deferring to the caller.\n+                // Can reevaluate if we need more granular control over cancellation vs shutdown.\n+            }\n+        }\n+\n+        private async Task RunInternalAsync(CancellationToken cancellationToken)\n+        {\n+            while (!cancellationToken.IsCancellationRequested)\n+            {\n+                while (!_pipeServer.IsConnected)\n+                {\n+                    _ = _pipeServer.WaitForConnection();\n+                }\n+\n+                CommunicationsUtilities.Trace(\"({0}) Received RAR request.\", _endpointId);\n+\n+                try\n+                {\n+                    INodePacket packet = await _pipeServer.ReadPacketAsync(cancellationToken);\n+\n+                    if (packet.Type == NodePacketType.NodeShutdown)\n+                    {\n+                        // Although the client has already disconnected, it is still necessary to Diconnect() so the\n+                        // pipe can transition into PipeState.Disonnected, which is treated as an intentional pipe break.\n+                        // Otherwise, all future operations on the pipe will throw an exception.\n+                        CommunicationsUtilities.Trace(\"({0}) RAR client disconnected.\", _endpointId);\n+                        _pipeServer.Disconnect();\n+                        continue;\n+                    }\n+\n+                    RarNodeExecuteRequest request = (RarNodeExecuteRequest)packet;\n+\n+                    // TODO: Use request packet to set inputs on the RAR task.\n+                    ResolveAssemblyReference rarTask = new();\n+\n+                    // TODO: bool success = rarTask.ExecuteInProcess();\n+                    // TODO: Use RAR task outputs to create response packet.\n+                    await _pipeServer.WritePacketAsync(new RarNodeExecuteResponse(), cancellationToken);\n+\n+                    CommunicationsUtilities.Trace(\"({0}) Completed RAR request.\", _endpointId);\n+                }\n+                catch (Exception e) when (e is not OperationCanceledException)",
              "author": {
                "login": "ccastanedaucf"
              }
            },
            {
              "body": "Also the node doesn't currently time out, but it's hard to figure out a solid metric before doing some dogfooding",
              "createdAt": "2025-05-07T20:21:50Z",
              "path": "src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks.AssemblyDependency\n+{\n+    /// <summary>\n+    /// Implements a single instance of a pipe server which executes the ResolveAssemblyReference task.\n+    /// </summary>\n+    internal class OutOfProcRarNodeEndpoint : IDisposable\n+    {\n+        private readonly int _endpointId;\n+\n+        private readonly NodePipeServer _pipeServer;\n+\n+        internal OutOfProcRarNodeEndpoint(int endpointId, ServerNodeHandshake handshake, int maxNumberOfServerInstances)\n+        {\n+            _endpointId = endpointId;\n+            _pipeServer = new NodePipeServer(NamedPipeUtil.GetRarNodeEndpointPipeName(handshake), handshake, maxNumberOfServerInstances);\n+\n+            NodePacketFactory packetFactory = new();\n+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteRequest, RarNodeExecuteRequest.FactoryForDeserialization, null);\n+            _pipeServer.RegisterPacketFactory(packetFactory);\n+        }\n+\n+        public void Dispose() => _pipeServer.Dispose();\n+\n+        internal async Task RunAsync(CancellationToken cancellationToken = default)\n+        {\n+            CommunicationsUtilities.Trace(\"({0}) Starting RAR endpoint.\", _endpointId);\n+\n+            try\n+            {\n+                await RunInternalAsync(cancellationToken);\n+            }\n+            catch (OperationCanceledException)\n+            {\n+                // Swallow cancellation excpetions for now. We're using this as a simple way to gracefully shutdown the\n+                // endpoint, instead of having to implement separate Start / Stop methods and deferring to the caller.\n+                // Can reevaluate if we need more granular control over cancellation vs shutdown.\n+            }\n+        }\n+\n+        private async Task RunInternalAsync(CancellationToken cancellationToken)\n+        {\n+            while (!cancellationToken.IsCancellationRequested)\n+            {\n+                while (!_pipeServer.IsConnected)\n+                {\n+                    _ = _pipeServer.WaitForConnection();\n+                }\n+\n+                CommunicationsUtilities.Trace(\"({0}) Received RAR request.\", _endpointId);\n+\n+                try\n+                {\n+                    INodePacket packet = await _pipeServer.ReadPacketAsync(cancellationToken);\n+\n+                    if (packet.Type == NodePacketType.NodeShutdown)\n+                    {\n+                        // Although the client has already disconnected, it is still necessary to Diconnect() so the\n+                        // pipe can transition into PipeState.Disonnected, which is treated as an intentional pipe break.\n+                        // Otherwise, all future operations on the pipe will throw an exception.\n+                        CommunicationsUtilities.Trace(\"({0}) RAR client disconnected.\", _endpointId);\n+                        _pipeServer.Disconnect();\n+                        continue;\n+                    }\n+\n+                    RarNodeExecuteRequest request = (RarNodeExecuteRequest)packet;\n+\n+                    // TODO: Use request packet to set inputs on the RAR task.\n+                    ResolveAssemblyReference rarTask = new();\n+\n+                    // TODO: bool success = rarTask.ExecuteInProcess();\n+                    // TODO: Use RAR task outputs to create response packet.\n+                    await _pipeServer.WritePacketAsync(new RarNodeExecuteResponse(), cancellationToken);\n+\n+                    CommunicationsUtilities.Trace(\"({0}) Completed RAR request.\", _endpointId);\n+                }\n+                catch (Exception e) when (e is not OperationCanceledException)",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Re-arranged a bit here as well. Found this also calling into `GetCurrentProcess` + `NtQuerySystemInformation` every time a client is initialized, which isn't used at all by `ServerNodeHandshake`.",
              "createdAt": "2025-05-08T03:19:05Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -110,8 +115,13 @@ protected internal Handshake(HandshakeOptions nodeType)\n             fileVersionMinor = fileVersion.Minor;\n             fileVersionBuild = fileVersion.Build;\n             fileVersionPrivate = fileVersion.Revision;\n-            using Process currentProcess = Process.GetCurrentProcess();\n-            sessionId = currentProcess.SessionId;\n+\n+            // This reaches out to NtQuerySystemInformation. Due to latency, allow skipping for derived handshake if unused.\n+            if (includeSessionId)",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You say \"before\" here, but are launching an async task -- is there a danger that it won't start before the override?",
              "createdAt": "2025-05-20T20:36:51Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -560,6 +560,21 @@ public void BeginBuild(BuildParameters parameters)\n                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath(\"msbuild-cache\");\n                 }\n \n+                // Launch the RAR node before the detoured launcher overrides the default node launcher.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yup, that's why I pull the `NodeLauncher` reference out of the component host right before kicking off the task",
              "createdAt": "2025-05-20T22:27:43Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -560,6 +560,21 @@ public void BeginBuild(BuildParameters parameters)\n                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath(\"msbuild-cache\");\n                 }\n \n+                // Launch the RAR node before the detoured launcher overrides the default node launcher.",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's the risk of other implementations/callers of RAR that are unaware of this parameter breaking when things move out of proc? Have you tested with F# which calls RAR in `fsc.exe`?\r\n\r\nI think I might prefer an opt-in like `AllowOutOfProc` and set it to `true` in calls we control, as a conservative option?",
              "createdAt": "2025-05-20T20:41:49Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -920,6 +921,11 @@ public string[] FullFrameworkFolders\n \n         public bool FailIfNotIncremental { get; set; }\n \n+        /// <summary>\n+        /// Forces the task to run in-proc, regardless of BuildEngine flags.\n+        /// </summary>\n+        public bool DisableOutOfProcNode { get; set; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Their legacy RAR impl shouldn't trigger it since they pass a custom base `IBuildEngine`. No idea how this plays out when they call into RAR directly though. I can err on the safe side here for now.",
              "createdAt": "2025-05-21T00:32:23Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -920,6 +921,11 @@ public string[] FullFrameworkFolders\n \n         public bool FailIfNotIncremental { get; set; }\n \n+        /// <summary>\n+        /// Forces the task to run in-proc, regardless of BuildEngine flags.\n+        /// </summary>\n+        public bool DisableOutOfProcNode { get; set; }",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this accurate?\r\n\r\n```suggestion\r\n#pragma warning disable CA2000 // The OutOfProcRarClient is disposable but its disposal is handled by RegisterTaskObject\r\n```",
              "createdAt": "2025-05-20T20:44:53Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3243,6 +3249,25 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr\n         /// <returns>True if there was success.</returns>\n         public override bool Execute()\n         {\n+            if (!DisableOutOfProcNode\n+                && BuildEngine is IBuildEngine10 buildEngine10\n+                && buildEngine10.EngineServices.IsOutOfProcRarNodeEnabled)\n+            {\n+                try\n+                {\n+#pragma warning disable CA2000 // Dispose objects before losing scope",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "That was just the default comment by the LSP code action, can put something more accurate",
              "createdAt": "2025-05-20T22:29:44Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -3243,6 +3249,25 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr\n         /// <returns>True if there was success.</returns>\n         public override bool Execute()\n         {\n+            if (!DisableOutOfProcNode\n+                && BuildEngine is IBuildEngine10 buildEngine10\n+                && buildEngine10.EngineServices.IsOutOfProcRarNodeEnabled)\n+            {\n+                try\n+                {\n+#pragma warning disable CA2000 // Dispose objects before losing scope",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there  no other information we could glean from the `UnauthorizedAccessException`?",
              "createdAt": "2025-05-20T20:48:02Z",
              "path": "src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs",
              "diffHunk": "@@ -0,0 +1,166 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks.AssemblyDependency\n+{\n+    /// <summary>\n+    /// Implements a persistent node for the ResolveAssemblyReferences task.\n+    /// This manages the lifecycle of the multi-instance pipe server which executes RAR requests\n+    /// and does not invoke the task itself.\n+    /// </summary>\n+    public sealed class OutOfProcRarNode\n+    {\n+        private readonly ServerNodeHandshake _handshake = new(HandshakeOptions.None);\n+\n+        private readonly int _maxNumberOfConcurrentTasks;\n+\n+        public OutOfProcRarNode()\n+            : this(Environment.ProcessorCount)\n+        {\n+        }\n+\n+        public OutOfProcRarNode(int maxNumberOfConcurrentTasks) => _maxNumberOfConcurrentTasks = maxNumberOfConcurrentTasks;\n+\n+        /// <summary>\n+        /// Starts the node and begins processing RAR execution requests until cancelled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <param name=\"cancellationToken\">A cancellation token to observe while running the node loop.</param>\n+        /// <returns>The reason for the node shutdown.</returns>\n+        public RarNodeShutdownReason Run(out Exception? shutdownException, CancellationToken cancellationToken = default)\n+        {\n+            RarNodeShutdownReason shutdownReason;\n+            shutdownException = null;\n+\n+            try\n+            {\n+                shutdownReason = RunNodeAsync(cancellationToken).GetAwaiter().GetResult();\n+            }\n+            catch (OperationCanceledException)\n+            {\n+                // Consider cancellation as an intentional shutdown of the node.\n+                shutdownReason = RarNodeShutdownReason.Complete;\n+            }\n+            catch (UnauthorizedAccessException)\n+            {\n+                // Access to the path is denied if the named pipe already exists.\n+                shutdownException = new InvalidOperationException(\"RAR node is already running.\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This also throws if the user doesn't match. There's nothing that differentiates them apart than the message though (HResult gets overriden to `E_ACCESSDENIED` in both cases), so the only option is to just bubble up the inner exception",
              "createdAt": "2025-05-21T00:39:44Z",
              "path": "src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs",
              "diffHunk": "@@ -0,0 +1,166 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks.AssemblyDependency\n+{\n+    /// <summary>\n+    /// Implements a persistent node for the ResolveAssemblyReferences task.\n+    /// This manages the lifecycle of the multi-instance pipe server which executes RAR requests\n+    /// and does not invoke the task itself.\n+    /// </summary>\n+    public sealed class OutOfProcRarNode\n+    {\n+        private readonly ServerNodeHandshake _handshake = new(HandshakeOptions.None);\n+\n+        private readonly int _maxNumberOfConcurrentTasks;\n+\n+        public OutOfProcRarNode()\n+            : this(Environment.ProcessorCount)\n+        {\n+        }\n+\n+        public OutOfProcRarNode(int maxNumberOfConcurrentTasks) => _maxNumberOfConcurrentTasks = maxNumberOfConcurrentTasks;\n+\n+        /// <summary>\n+        /// Starts the node and begins processing RAR execution requests until cancelled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <param name=\"cancellationToken\">A cancellation token to observe while running the node loop.</param>\n+        /// <returns>The reason for the node shutdown.</returns>\n+        public RarNodeShutdownReason Run(out Exception? shutdownException, CancellationToken cancellationToken = default)\n+        {\n+            RarNodeShutdownReason shutdownReason;\n+            shutdownException = null;\n+\n+            try\n+            {\n+                shutdownReason = RunNodeAsync(cancellationToken).GetAwaiter().GetResult();\n+            }\n+            catch (OperationCanceledException)\n+            {\n+                // Consider cancellation as an intentional shutdown of the node.\n+                shutdownReason = RarNodeShutdownReason.Complete;\n+            }\n+            catch (UnauthorizedAccessException)\n+            {\n+                // Access to the path is denied if the named pipe already exists.\n+                shutdownException = new InvalidOperationException(\"RAR node is already running.\");",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems kinda expensive, should we be worried about removing or reducing it in the future?",
              "createdAt": "2025-05-20T21:07:54Z",
              "path": "src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,79 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class RarNodeLauncher\n+    {\n+        private readonly INodeLauncher _nodeLauncher;\n+\n+        private readonly string _pipeName;\n+\n+        internal RarNodeLauncher(INodeLauncher nodeLauncher)\n+        {\n+            _nodeLauncher = nodeLauncher;\n+            _pipeName = NamedPipeUtil.GetRarNodePipeName(new(HandshakeOptions.None));\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process with the RAR nodemode.\n+        /// </summary>\n+        public bool Start()\n+        {\n+            if (IsRarNodeRunning())\n+            {\n+                CommunicationsUtilities.Trace(\"Existing RAR node found.\");\n+                return true;\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Launching RAR node...\");\n+\n+            try\n+            {\n+                LaunchNode();\n+            }\n+            catch (NodeFailedToLaunchException ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch RAR node: {0}\", ex);\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private bool IsRarNodeRunning()\n+        {\n+            // Determine if the node is running by checking if the expected named pipe exists.\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                const string NamedPipeRoot = @\"\\\\.\\pipe\\\";\n+\n+                // File.Exists() will crash the pipe server, as the underlying Windows APIs have undefined behavior\n+                // when used with pipe objects. Enumerating the pipe directory avoids this issue.\n+                IEnumerable<string> pipeNames = FileSystems.Default.EnumerateFiles(NamedPipeRoot);\n+\n+                return pipeNames.Contains(Path.Combine(NamedPipeRoot, _pipeName));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Both a no-op connection and an enumeration seem to take the same amount of time ~(15ms) - although I guess that could scale depending on the number of pipes. That said, even on a hello-world, a freshly started RAR node is always ready by the time the first RAR task is hit. So I think running this concurrently is enough.\r\n\r\nWhat *can* be improved is the first worker connection from the first RAR task, since right now that's another blocking ~15ms. And that one's assuming the node exists. Should amount to just populating the shared object cache earlier, but I haven't look at where that should happen yet.",
              "createdAt": "2025-05-20T23:25:21Z",
              "path": "src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,79 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class RarNodeLauncher\n+    {\n+        private readonly INodeLauncher _nodeLauncher;\n+\n+        private readonly string _pipeName;\n+\n+        internal RarNodeLauncher(INodeLauncher nodeLauncher)\n+        {\n+            _nodeLauncher = nodeLauncher;\n+            _pipeName = NamedPipeUtil.GetRarNodePipeName(new(HandshakeOptions.None));\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process with the RAR nodemode.\n+        /// </summary>\n+        public bool Start()\n+        {\n+            if (IsRarNodeRunning())\n+            {\n+                CommunicationsUtilities.Trace(\"Existing RAR node found.\");\n+                return true;\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Launching RAR node...\");\n+\n+            try\n+            {\n+                LaunchNode();\n+            }\n+            catch (NodeFailedToLaunchException ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch RAR node: {0}\", ex);\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private bool IsRarNodeRunning()\n+        {\n+            // Determine if the node is running by checking if the expected named pipe exists.\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                const string NamedPipeRoot = @\"\\\\.\\pipe\\\";\n+\n+                // File.Exists() will crash the pipe server, as the underlying Windows APIs have undefined behavior\n+                // when used with pipe objects. Enumerating the pipe directory avoids this issue.\n+                IEnumerable<string> pipeNames = FileSystems.Default.EnumerateFiles(NamedPipeRoot);\n+\n+                return pipeNames.Contains(Path.Combine(NamedPipeRoot, _pipeName));",
              "author": {
                "login": "ccastanedaucf"
              }
            },
            {
              "body": "I got sniped looking into this more, the bottleneck from doing existence via pipe connection is mostly just the handshake since it triggers a bunch of small 4-byte reads/writes. Mocked up doing the handshake in a single read + write and that came down to 2ms, so with some future work that would be the ideal.\r\n\r\n++edit: This is also all mixed with JIT time so it's a bit tricky to measure the real costs",
              "createdAt": "2025-05-21T23:40:50Z",
              "path": "src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,79 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class RarNodeLauncher\n+    {\n+        private readonly INodeLauncher _nodeLauncher;\n+\n+        private readonly string _pipeName;\n+\n+        internal RarNodeLauncher(INodeLauncher nodeLauncher)\n+        {\n+            _nodeLauncher = nodeLauncher;\n+            _pipeName = NamedPipeUtil.GetRarNodePipeName(new(HandshakeOptions.None));\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process with the RAR nodemode.\n+        /// </summary>\n+        public bool Start()\n+        {\n+            if (IsRarNodeRunning())\n+            {\n+                CommunicationsUtilities.Trace(\"Existing RAR node found.\");\n+                return true;\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Launching RAR node...\");\n+\n+            try\n+            {\n+                LaunchNode();\n+            }\n+            catch (NodeFailedToLaunchException ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch RAR node: {0}\", ex);\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private bool IsRarNodeRunning()\n+        {\n+            // Determine if the node is running by checking if the expected named pipe exists.\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                const string NamedPipeRoot = @\"\\\\.\\pipe\\\";\n+\n+                // File.Exists() will crash the pipe server, as the underlying Windows APIs have undefined behavior\n+                // when used with pipe objects. Enumerating the pipe directory avoids this issue.\n+                IEnumerable<string> pipeNames = FileSystems.Default.EnumerateFiles(NamedPipeRoot);\n+\n+                return pipeNames.Contains(Path.Combine(NamedPipeRoot, _pipeName));",
              "author": {
                "login": "ccastanedaucf"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "IMO at least put a comm log entry in.",
              "createdAt": "2025-05-20T21:13:25Z",
              "path": "src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Tasks.AssemblyDependency\n+{\n+    /// <summary>\n+    /// Implements a single instance of a pipe server which executes the ResolveAssemblyReference task.\n+    /// </summary>\n+    internal sealed class OutOfProcRarNodeEndpoint : IDisposable\n+    {\n+        private readonly int _endpointId;\n+\n+        private readonly NodePipeServer _pipeServer;\n+\n+        internal OutOfProcRarNodeEndpoint(int endpointId, ServerNodeHandshake handshake, int maxNumberOfServerInstances)\n+        {\n+            _endpointId = endpointId;\n+            _pipeServer = new NodePipeServer(NamedPipeUtil.GetRarNodeEndpointPipeName(handshake), handshake, maxNumberOfServerInstances);\n+\n+            NodePacketFactory packetFactory = new();\n+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteRequest, RarNodeExecuteRequest.FactoryForDeserialization, null);\n+            _pipeServer.RegisterPacketFactory(packetFactory);\n+        }\n+\n+        public void Dispose() => _pipeServer.Dispose();\n+\n+        internal async Task RunAsync(CancellationToken cancellationToken = default)\n+        {\n+            CommunicationsUtilities.Trace(\"({0}) Starting RAR endpoint.\", _endpointId);\n+\n+            try\n+            {\n+                await RunInternalAsync(cancellationToken);\n+            }\n+            catch (OperationCanceledException)\n+            {\n+                // Swallow cancellation excpetions for now. We're using this as a simple way to gracefully shutdown the\n+                // endpoint, instead of having to implement separate Start / Stop methods and deferring to the caller.\n+                // Can reevaluate if we need more granular control over cancellation vs shutdown.\n+            }",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}