{
  "number": 9805,
  "title": "Use repository root for output path calculation when the output isn't a child of the working directory",
  "body": "Fixes #9800\r\n\r\n### Context\r\nThis PR teaches Terminal Logger to look for a specific kind of MSBuild Item for a project during the build. This kind of item (SourceRoot) points to the computed source code repository of the build, which we can use to calculate the output path to render for a project when that project doesn't build to location that's a child of the current directory. Here's what it looks like when building a child project in a repository using the SDK Artifacts path layout: \r\n\r\n![image](https://github.com/dotnet/msbuild/assets/573979/4131cb51-65be-458e-a6fb-4fe68327a106)\r\n\r\n### Changes Made\r\n\r\nTerminal Logger Projects now keep track of a SourceRoot span. This span is calculated by looking for the first `SourceRoot` item that has `SourceControl` metadata on it. This data is filled in by Sourcelink, which is part of the .NET SDK.\r\n\r\nTerminal Logger is opted into TaskParameterEventArgs messages via the `IEventSource3.IncludeTaskInputs()` method.\r\n\r\nDuring output rendering, if the output path isn't a child of the working directory, the SourceRoot is checked as a fallback,  if it exists. If so, the relative path between the working directory and the SourceRoot is computed and combined with the portion of the output path that maps to the SourceRoot.\r\n\r\n### Testing\r\n\r\nI need to add testing for this scenario.\r\n\r\n### Notes\r\n\r\nThis will only work when /m:1 currently because the messages that contain task inputs are not `High` importance.  To fix this, we will need to make TerminalLogger a proper forwarding logger, not using the ConfigurableForwardingLogger infrastructure. I logged https://github.com/dotnet/msbuild/issues/9806 to capture this need.\r\n",
  "state": "CLOSED",
  "createdAt": "2024-02-29T18:35:33Z",
  "updatedAt": "2024-11-06T16:45:17Z",
  "closedAt": "2024-11-06T16:45:17Z",
  "mergedAt": null,
  "additions": 300,
  "deletions": 42,
  "changedFiles": 4,
  "headRefName": "use-sourceroot-for-relative-paths",
  "isDraft": false,
  "author": {
    "login": "baronfel"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "66547b59ff44629121f483dd17ae9034e58cbe43",
          "message": "wip",
          "committedDate": "2024-09-06T20:56:58Z",
          "author": {
            "name": "Chet Husk",
            "email": "chusk3@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5c5a0a2e0fbaf92b771018ef0934a97c17fc70eb",
          "message": "wip",
          "committedDate": "2024-09-06T20:57:34Z",
          "author": {
            "name": "Chet Husk",
            "email": "chusk3@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4920101d78ecc7ce7c594d1306f272fbcfe5b04f",
          "message": "correct display",
          "committedDate": "2024-09-06T20:57:37Z",
          "author": {
            "name": "Chet Husk",
            "email": "chusk3@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a67aec20b57f8a6b8791711797c0445c3f2d5444",
          "message": "compute relative paths from working directory to source root",
          "committedDate": "2024-09-06T20:57:37Z",
          "author": {
            "name": "Chet Husk",
            "email": "chusk3@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3d906ae7b5c2c2e18bcc364c4fb2a12d5adc2a38",
          "message": "simplfy output path creation",
          "committedDate": "2024-09-06T20:58:36Z",
          "author": {
            "name": "Chet Husk",
            "email": "chusk3@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2c5c0b757feef05bc2ee1d1bfc91ac4170c7a2b0",
          "message": "use strings instead of spans because Path APIs are pushing us that way",
          "committedDate": "2024-09-06T20:58:36Z",
          "author": {
            "name": "Chet Husk",
            "email": "chusk3@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a0f9e5c51b16f824e91dbbe84e9694797a2e900a",
          "message": "Detect and generate full paths if requested",
          "committedDate": "2024-09-06T20:59:25Z",
          "author": {
            "name": "Chet Husk",
            "email": "chusk3@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f924f4998024238b5741cb6fed34765259b1f3f5",
          "message": "use FileInfo/DirectoryInfo to check path relationships instead of raw substring manipulation",
          "committedDate": "2024-09-06T21:00:26Z",
          "author": {
            "name": "Chet Husk",
            "email": "chusk3@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d1182fd7241930e81e99c2163e3135b33ad18b2a",
          "message": "WIP use ProjectEvaluationFinishedEventArgs to read GenerateFullPaths property data",
          "committedDate": "2024-09-06T21:02:08Z",
          "author": {
            "name": "Chet Husk",
            "email": "chusk3@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1b72331fd1cb02944727be67d022faffd535fc59",
          "message": "Introduce a cache of Evaluation data that is looked up",
          "committedDate": "2024-09-06T21:06:02Z",
          "author": {
            "name": "Chet Husk",
            "email": "chusk3@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5a41571f06b9a407d7d1f9f7312533bc8656cce3",
          "message": "also do nuget package output detection",
          "committedDate": "2024-09-06T21:31:10Z",
          "author": {
            "name": "Chet Husk",
            "email": "chusk3@gmail.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "We decided to close this PR, as no further work will follow this implementation.",
        "createdAt": "2024-11-06T16:45:17Z",
        "author": {
          "login": "maridematte"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this needed?",
              "createdAt": "2024-03-08T10:48:06Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -639,6 +692,17 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)\n         }\n \n         string? message = e.Message;\n+        if (e is TaskParameterEventArgs taskArgs)\n+        {\n+            Debug.WriteLine(taskArgs.BuildEventContext?.TaskId);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I know this is pre-existing logic, but it feels fragile - what if in future the working directory path ends with separator?\r\n\r\nIt would be nice to unify and extract the logic of the 2 cases - \"given the common root, CWD and a path - return a proper relative path\".\r\nAs a side benefit, the +/-1 problem of the separator location would get easily testable. ",
              "createdAt": "2024-03-08T10:58:33Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -520,19 +529,37 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n                                 urlString = uri.AbsoluteUri;\n                             }\n \n+                            var relativeDisplayPathSpan = outputPathSpan;\n+                            var workingDirectorySpan = _initialWorkingDirectory.AsSpan();\n                             // If the output path is under the initial working directory, make the console output relative to that to save space.\n-                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))\n+                            if (outputPathSpan.StartsWith(workingDirectorySpan, FileUtilities.PathComparison))\n+                            {\n+                                if (outputPathSpan.Length > workingDirectorySpan.Length\n+                                    && (outputPathSpan[workingDirectorySpan.Length] == Path.DirectorySeparatorChar\n+                                        || outputPathSpan[workingDirectorySpan.Length] == Path.AltDirectorySeparatorChar))",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Yeah, I agree it's messy :) I can take a look and try to make something principled/reusable.",
              "createdAt": "2024-03-08T16:32:10Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -520,19 +529,37 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n                                 urlString = uri.AbsoluteUri;\n                             }\n \n+                            var relativeDisplayPathSpan = outputPathSpan;\n+                            var workingDirectorySpan = _initialWorkingDirectory.AsSpan();\n                             // If the output path is under the initial working directory, make the console output relative to that to save space.\n-                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))\n+                            if (outputPathSpan.StartsWith(workingDirectorySpan, FileUtilities.PathComparison))\n+                            {\n+                                if (outputPathSpan.Length > workingDirectorySpan.Length\n+                                    && (outputPathSpan[workingDirectorySpan.Length] == Path.DirectorySeparatorChar\n+                                        || outputPathSpan[workingDirectorySpan.Length] == Path.AltDirectorySeparatorChar))",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "I'm not at all sure that we need to care about Spans here - this logic will be run once per project, not every message.",
              "createdAt": "2024-03-08T20:28:26Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -520,19 +529,37 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n                                 urlString = uri.AbsoluteUri;\n                             }\n \n+                            var relativeDisplayPathSpan = outputPathSpan;\n+                            var workingDirectorySpan = _initialWorkingDirectory.AsSpan();\n                             // If the output path is under the initial working directory, make the console output relative to that to save space.\n-                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))\n+                            if (outputPathSpan.StartsWith(workingDirectorySpan, FileUtilities.PathComparison))\n+                            {\n+                                if (outputPathSpan.Length > workingDirectorySpan.Length\n+                                    && (outputPathSpan[workingDirectorySpan.Length] == Path.DirectorySeparatorChar\n+                                        || outputPathSpan[workingDirectorySpan.Length] == Path.AltDirectorySeparatorChar))",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "I rewrote this completely in terms of `Path.GetRelativePath`. To me this reads much more simply now - what do you think? I tested it and it still works as expected, even when triggering builds from locations outside of the entire repo being built!\r\n\r\n```terminal\r\n> .\\.dotnet\\dotnet.exe publish -t:PublishContainer -bl -tl E:\\code\\sdk-container-demo\\src\\sdk-container-demo\\ /m:1\r\nWaiting for debugger to attach (E:\\Code\\msbuild\\.dotnet\\dotnet.exe PID 73700).  Press enter to continue...\r\n\r\nMSBuild version 17.10.0-dev-24158-01+2473b36c8 for .NET\r\nRestore complete (0.8s)\r\n  sdk-container-demo succeeded (0.9s) \u2192 ..\\sdk-container-demo\\artifacts\\publish\\sdk-container-demo\\release\\\r\n```\r\n\r\nI cut off the rest of that^ because it's a gnarly compilation error (not a problem with Terminal Logger)",
              "createdAt": "2024-03-08T20:35:28Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -520,19 +529,37 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n                                 urlString = uri.AbsoluteUri;\n                             }\n \n+                            var relativeDisplayPathSpan = outputPathSpan;\n+                            var workingDirectorySpan = _initialWorkingDirectory.AsSpan();\n                             // If the output path is under the initial working directory, make the console output relative to that to save space.\n-                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))\n+                            if (outputPathSpan.StartsWith(workingDirectorySpan, FileUtilities.PathComparison))\n+                            {\n+                                if (outputPathSpan.Length > workingDirectorySpan.Length\n+                                    && (outputPathSpan[workingDirectorySpan.Length] == Path.DirectorySeparatorChar\n+                                        || outputPathSpan[workingDirectorySpan.Length] == Path.AltDirectorySeparatorChar))",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "Yeah - it now reads much easier - thanks for the effort!",
              "createdAt": "2024-03-09T20:41:25Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -520,19 +529,37 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n                                 urlString = uri.AbsoluteUri;\n                             }\n \n+                            var relativeDisplayPathSpan = outputPathSpan;\n+                            var workingDirectorySpan = _initialWorkingDirectory.AsSpan();\n                             // If the output path is under the initial working directory, make the console output relative to that to save space.\n-                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))\n+                            if (outputPathSpan.StartsWith(workingDirectorySpan, FileUtilities.PathComparison))\n+                            {\n+                                if (outputPathSpan.Length > workingDirectorySpan.Length\n+                                    && (outputPathSpan[workingDirectorySpan.Length] == Path.DirectorySeparatorChar\n+                                        || outputPathSpan[workingDirectorySpan.Length] == Path.AltDirectorySeparatorChar))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: We don't seem to be setting this to anything else than a `string` so keeping it as a span seems unnecessary.",
              "createdAt": "2024-03-12T08:36:35Z",
              "path": "src/MSBuild/TerminalLogger/Project.cs",
              "diffHunk": "@@ -41,6 +41,11 @@ public Project(string? targetFramework, StopwatchAbstraction? stopwatch)\n     /// </summary>\n     public ReadOnlyMemory<char>? OutputPath { get; set; }\n \n+    /// <summary>\n+    /// Full path to the 'root' of this project's source control repository, if known.\n+    /// </summary>\n+    public ReadOnlyMemory<char>? SourceRoot { get; set; }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this because there is no `TaskParameterMessageKind.UpdateItem`? We should totally add it as part of the analyzer work.",
              "createdAt": "2024-03-12T08:43:52Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -609,6 +630,32 @@ private void TargetFinished(object sender, TargetFinishedEventArgs e)\n     {\n     }\n \n+    private void TryReadSourceControlInformationForProject(BuildEventContext? context, IEnumerable<ITaskItem>? sourceRoots)\n+    {\n+        if (context is null || sourceRoots is null)\n+        {\n+            return;\n+        }\n+\n+        var projectContext = new ProjectContext(context);\n+        if (_projects.TryGetValue(projectContext, out Project? project))\n+        {\n+            if (project.SourceRoot is not null)\n+            {\n+                return;\n+            }\n+            var sourceControlSourceRoot = sourceRoots.FirstOrDefault(root => !string.IsNullOrEmpty(root.GetMetadata(\"SourceControl\")));\n+            if (sourceControlSourceRoot is not null)\n+            {\n+                // This takes the first root from source control the first time it's added to the build.\n+                // This seems to be the Target InitializeSourceControlInformationFromSourceControlManager.\n+                // So far this has been acceptable, but if a SourceRoot would be modified by a task later on\n+                // (e.g. TranslateGitHubUrlsInSourceControlInformation) we would lose that modification.",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "In this case it's not an `Update` unfortunately - the targets explicitly remove all of the previous items and re-add the new items. \r\nI think it would be useful separately to have an `UpdateItem` but it wouldn't help me here :)",
              "createdAt": "2024-03-19T15:35:54Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -609,6 +630,32 @@ private void TargetFinished(object sender, TargetFinishedEventArgs e)\n     {\n     }\n \n+    private void TryReadSourceControlInformationForProject(BuildEventContext? context, IEnumerable<ITaskItem>? sourceRoots)\n+    {\n+        if (context is null || sourceRoots is null)\n+        {\n+            return;\n+        }\n+\n+        var projectContext = new ProjectContext(context);\n+        if (_projects.TryGetValue(projectContext, out Project? project))\n+        {\n+            if (project.SourceRoot is not null)\n+            {\n+                return;\n+            }\n+            var sourceControlSourceRoot = sourceRoots.FirstOrDefault(root => !string.IsNullOrEmpty(root.GetMetadata(\"SourceControl\")));\n+            if (sourceControlSourceRoot is not null)\n+            {\n+                // This takes the first root from source control the first time it's added to the build.\n+                // This seems to be the Target InitializeSourceControlInformationFromSourceControlManager.\n+                // So far this has been acceptable, but if a SourceRoot would be modified by a task later on\n+                // (e.g. TranslateGitHubUrlsInSourceControlInformation) we would lose that modification.",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Are the false matches on strings like\r\n`outputPathString = \"C:\\src_output\\foo\\bar.dll\"`\r\n`sourceRootString = \"C:\\src\"`\r\nok here?",
              "createdAt": "2024-03-12T08:50:12Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -520,19 +529,31 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n                                 urlString = uri.AbsoluteUri;\n                             }\n \n+                            var outputPathString = outputPathSpan.ToString();\n+                            var relativeDisplayPath = outputPathString;\n+                            var workingDirectory = _initialWorkingDirectory;\n+\n                             // If the output path is under the initial working directory, make the console output relative to that to save space.\n-                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))\n+                            if (outputPathString.StartsWith(workingDirectory, FileUtilities.PathComparison))\n+                            {\n+                                relativeDisplayPath = Path.GetRelativePath(workingDirectory, outputPathString);\n+                            }\n+\n+                            // if the output path isn't under the working directory, but is under the source root, make the output relative to that to save space\n+                            else if (project.SourceRoot is ReadOnlyMemory<char> sourceRoot)\n                             {\n-                                if (outputPathSpan.Length > _initialWorkingDirectory.Length\n-                                    && (outputPathSpan[_initialWorkingDirectory.Length] == Path.DirectorySeparatorChar\n-                                        || outputPathSpan[_initialWorkingDirectory.Length] == Path.AltDirectorySeparatorChar))\n+                                var sourceRootString = sourceRoot.Span.ToString();\n+                                if (outputPathString.StartsWith(sourceRootString, FileUtilities.PathComparison))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I _think_ so - that would mean that someone had specifically set up a git repo that was building content from a completely parallel folder structure, which is certainly possible (though not exactly what we might consider a good practice).",
              "createdAt": "2024-03-14T18:21:31Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -520,19 +529,31 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n                                 urlString = uri.AbsoluteUri;\n                             }\n \n+                            var outputPathString = outputPathSpan.ToString();\n+                            var relativeDisplayPath = outputPathString;\n+                            var workingDirectory = _initialWorkingDirectory;\n+\n                             // If the output path is under the initial working directory, make the console output relative to that to save space.\n-                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))\n+                            if (outputPathString.StartsWith(workingDirectory, FileUtilities.PathComparison))\n+                            {\n+                                relativeDisplayPath = Path.GetRelativePath(workingDirectory, outputPathString);\n+                            }\n+\n+                            // if the output path isn't under the working directory, but is under the source root, make the output relative to that to save space\n+                            else if (project.SourceRoot is ReadOnlyMemory<char> sourceRoot)\n                             {\n-                                if (outputPathSpan.Length > _initialWorkingDirectory.Length\n-                                    && (outputPathSpan[_initialWorkingDirectory.Length] == Path.DirectorySeparatorChar\n-                                        || outputPathSpan[_initialWorkingDirectory.Length] == Path.AltDirectorySeparatorChar))\n+                                var sourceRootString = sourceRoot.Span.ToString();\n+                                if (outputPathString.StartsWith(sourceRootString, FileUtilities.PathComparison))",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "Actually - same thing when comparing output path and working directory. I'm basically pointing out the check for `/` or '\\` which was in the old code and is now missing.\r\n\r\nSo in cases like:\r\n`outputPathString = \"C:\\src_output\\foo\\bar.dll\"`\r\n`workingDirectory = \"C:\\src\"`\r\n\r\nwe see that `StartsWith` matches (line 568 in current iteration) and it makes us skip the `SourceRoot` logic altogether.",
              "createdAt": "2024-03-15T07:57:40Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -520,19 +529,31 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n                                 urlString = uri.AbsoluteUri;\n                             }\n \n+                            var outputPathString = outputPathSpan.ToString();\n+                            var relativeDisplayPath = outputPathString;\n+                            var workingDirectory = _initialWorkingDirectory;\n+\n                             // If the output path is under the initial working directory, make the console output relative to that to save space.\n-                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))\n+                            if (outputPathString.StartsWith(workingDirectory, FileUtilities.PathComparison))\n+                            {\n+                                relativeDisplayPath = Path.GetRelativePath(workingDirectory, outputPathString);\n+                            }\n+\n+                            // if the output path isn't under the working directory, but is under the source root, make the output relative to that to save space\n+                            else if (project.SourceRoot is ReadOnlyMemory<char> sourceRoot)\n                             {\n-                                if (outputPathSpan.Length > _initialWorkingDirectory.Length\n-                                    && (outputPathSpan[_initialWorkingDirectory.Length] == Path.DirectorySeparatorChar\n-                                        || outputPathSpan[_initialWorkingDirectory.Length] == Path.AltDirectorySeparatorChar))\n+                                var sourceRootString = sourceRoot.Span.ToString();\n+                                if (outputPathString.StartsWith(sourceRootString, FileUtilities.PathComparison))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Gotcha - I can do more path-like checking to safeguard. This is also a case that we can nail down with explicit tests.",
              "createdAt": "2024-03-19T15:37:16Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -520,19 +529,31 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n                                 urlString = uri.AbsoluteUri;\n                             }\n \n+                            var outputPathString = outputPathSpan.ToString();\n+                            var relativeDisplayPath = outputPathString;\n+                            var workingDirectory = _initialWorkingDirectory;\n+\n                             // If the output path is under the initial working directory, make the console output relative to that to save space.\n-                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))\n+                            if (outputPathString.StartsWith(workingDirectory, FileUtilities.PathComparison))\n+                            {\n+                                relativeDisplayPath = Path.GetRelativePath(workingDirectory, outputPathString);\n+                            }\n+\n+                            // if the output path isn't under the working directory, but is under the source root, make the output relative to that to save space\n+                            else if (project.SourceRoot is ReadOnlyMemory<char> sourceRoot)\n                             {\n-                                if (outputPathSpan.Length > _initialWorkingDirectory.Length\n-                                    && (outputPathSpan[_initialWorkingDirectory.Length] == Path.DirectorySeparatorChar\n-                                        || outputPathSpan[_initialWorkingDirectory.Length] == Path.AltDirectorySeparatorChar))\n+                                var sourceRootString = sourceRoot.Span.ToString();\n+                                if (outputPathString.StartsWith(sourceRootString, FileUtilities.PathComparison))",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "I pushed a commit that addresses this by moving away from string manipulation entirely in favor of using FileInfo/DirectoryInfo relationships to determine if a file is withing a given root. ",
              "createdAt": "2024-03-19T16:18:42Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -520,19 +529,31 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)\n                                 urlString = uri.AbsoluteUri;\n                             }\n \n+                            var outputPathString = outputPathSpan.ToString();\n+                            var relativeDisplayPath = outputPathString;\n+                            var workingDirectory = _initialWorkingDirectory;\n+\n                             // If the output path is under the initial working directory, make the console output relative to that to save space.\n-                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))\n+                            if (outputPathString.StartsWith(workingDirectory, FileUtilities.PathComparison))\n+                            {\n+                                relativeDisplayPath = Path.GetRelativePath(workingDirectory, outputPathString);\n+                            }\n+\n+                            // if the output path isn't under the working directory, but is under the source root, make the output relative to that to save space\n+                            else if (project.SourceRoot is ReadOnlyMemory<char> sourceRoot)\n                             {\n-                                if (outputPathSpan.Length > _initialWorkingDirectory.Length\n-                                    && (outputPathSpan[_initialWorkingDirectory.Length] == Path.DirectorySeparatorChar\n-                                        || outputPathSpan[_initialWorkingDirectory.Length] == Path.AltDirectorySeparatorChar))\n+                                var sourceRootString = sourceRoot.Span.ToString();\n+                                if (outputPathString.StartsWith(sourceRootString, FileUtilities.PathComparison))",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I am not at all sure about this change. Without it, the `Properties` of the `ProjectStartedEventArgs` are empty, and I can't manipulate the environment variables to tell the LoggingService to serialize all properties (or just a subset of properties) from within the logger, that's the wrong way around.\r\n\r\nIt feels like \r\n\r\n```csharp\r\n        if (eventSource is IEventSource4 eventSource4)\r\n        {\r\n            eventSource4.IncludeEvaluationPropertiesAndItems();\r\n        }\r\n```\r\n\r\nshould be all we need to do to start getting this information, so I'm not entirely sure why I never do.\r\n\r\nFor lines 98-100, the conditions break down (before this change) while debugging as:\r\n\r\n```csharp\r\nif (!false &&\r\n    !true && \r\n    (!false || false))\r\n```\r\n\r\nso the IncludeEvaluationPropertiesAndItems seems to be working against us here - perhaps because those are then intended to be on the ProjectEvaluationStart/Finish Events instead?\r\n\r\nA bit further down, lines 118-121 evaluate as\r\n\r\n```csharp\r\nif (false &&\r\n    !true && \r\n    false &&\r\n    !false)\r\n```\r\n\r\nso in this case including the events is again causing what I expect to occur to not occur. And as mentioned, since I can't control `propertiesToSerialize` I can't ask for `GenerateFullPaths` to flow through :(\r\n\r\n\r\n",
              "createdAt": "2024-03-14T22:49:54Z",
              "path": "src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs",
              "diffHunk": "@@ -96,7 +96,7 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque\n \n             // If we are only logging critical events lets not pass back the items or properties\n             if (!LoggingService.OnlyLogCriticalEvents &&\n-                !LoggingService.IncludeEvaluationPropertiesAndItems &&\n+                LoggingService.IncludeEvaluationPropertiesAndItems &&",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "The props and items are only on EvaluatinFinished event args.\r\n\r\n@AR-May was recently fixing the env vars not being properly reflected in nodes - in this case (requested in logger initialization) it feels it should work, right?\r\n\r\nLastly - we'll be battling similar needs in Analyzers as well - where we might discover the need later during the evaluation, when it's already not possible to communicate the need to the node. So I'm wondering if it really has some measurable perf impact or if we should send the evaluated props and items in EventArgs allways unconditionally. @AR-May - would you want to create a workitem for yourself to try some perf runs with and without `MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION` set to true/1?",
              "createdAt": "2024-03-15T06:32:54Z",
              "path": "src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs",
              "diffHunk": "@@ -96,7 +96,7 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque\n \n             // If we are only logging critical events lets not pass back the items or properties\n             if (!LoggingService.OnlyLogCriticalEvents &&\n-                !LoggingService.IncludeEvaluationPropertiesAndItems &&\n+                LoggingService.IncludeEvaluationPropertiesAndItems &&",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "The story here is:\r\n\r\n1. In the bad old days pre-binlog, the ProjectStarted event had a _text_ dump of items and properties.\r\n2. Then we got the binlog and the viewer started _parsing_ that to recover stuff.\r\n3. But that sucks! We have structured events!\r\n4. So let's emit structured data on ProjectEvaluationFinished instead\r\n5. Oh no, some _other_ loggers also parsed that text and broke.\r\n6. So let's make the new behavior opt-in, and if any logger _hasn't_ opted in still emit that text.\r\n\r\nSo I told you wrong when I said it was on ProjectStarted, sorry!",
              "createdAt": "2024-03-15T13:46:42Z",
              "path": "src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs",
              "diffHunk": "@@ -96,7 +96,7 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque\n \n             // If we are only logging critical events lets not pass back the items or properties\n             if (!LoggingService.OnlyLogCriticalEvents &&\n-                !LoggingService.IncludeEvaluationPropertiesAndItems &&\n+                LoggingService.IncludeEvaluationPropertiesAndItems &&",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Haha, always happy to get more history.\n\nSo that means I need to figure out why my earlier attempt to get ProjectEvaluationFinishedEventArgs events never received any events, then. ",
              "createdAt": "2024-03-15T14:00:19Z",
              "path": "src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs",
              "diffHunk": "@@ -96,7 +96,7 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque\n \n             // If we are only logging critical events lets not pass back the items or properties\n             if (!LoggingService.OnlyLogCriticalEvents &&\n-                !LoggingService.IncludeEvaluationPropertiesAndItems &&\n+                LoggingService.IncludeEvaluationPropertiesAndItems &&",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this be a case-insensitive comparison to match `e.GlobalProperties` which has a case insensitive key comparer?",
              "createdAt": "2024-03-19T21:27:22Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -380,6 +390,30 @@ private void ProjectStarted(object sender, ProjectStartedEventArgs e)\n                 int nodeIndex = NodeIndexForContext(buildEventContext);\n                 _nodes[nodeIndex] = new NodeStatus(e.ProjectFile!, null, \"Restore\", _projects[c].Stopwatch);\n             }\n+\n+            TryDetectGenerateFullPaths(e, project);\n+        }\n+    }\n+\n+    private void TryDetectGenerateFullPaths(ProjectStartedEventArgs e, Project project)\n+    {\n+        if (e.GlobalProperties is not null\n+            && e.GlobalProperties.TryGetValue(\"GenerateFullPaths\", out string? generateFullPaths)\n+            && bool.TryParse(generateFullPaths, out bool generateFullPathsValue))\n+        {\n+            project.GenerateFullPaths = generateFullPathsValue;\n+        }\n+        else if (e.Properties is not null)\n+        {\n+            foreach (DictionaryEntry property in e.Properties)\n+            {\n+                if (property.Key is \"GenerateFullPaths\" &&",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Oh I'm going nuts on the implementation still trying to find something that consistently works with ProjectEvaluationFinishedEventArgs, I wouldn't check any of this as 'final' yet. \r\n\r\nI'm running into a kind of frustrating scenario with this PR switching from ProjectStarted to ProjectEvaluationFinishedEventArgs.\r\n\r\nThe `Project` items we create are keyed to specific `ProjectContextId`s from the BuildEventContext, but those `ProjectContextId`s are not the same between evaluation and execution. Neither are the `ProjectInstanceId`s - so I'm not sure what the key could be to derive some information at evaluation time and then use it after execution time.",
              "createdAt": "2024-03-19T22:35:25Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -380,6 +390,30 @@ private void ProjectStarted(object sender, ProjectStartedEventArgs e)\n                 int nodeIndex = NodeIndexForContext(buildEventContext);\n                 _nodes[nodeIndex] = new NodeStatus(e.ProjectFile!, null, \"Restore\", _projects[c].Stopwatch);\n             }\n+\n+            TryDetectGenerateFullPaths(e, project);\n+        }\n+    }\n+\n+    private void TryDetectGenerateFullPaths(ProjectStartedEventArgs e, Project project)\n+    {\n+        if (e.GlobalProperties is not null\n+            && e.GlobalProperties.TryGetValue(\"GenerateFullPaths\", out string? generateFullPaths)\n+            && bool.TryParse(generateFullPaths, out bool generateFullPathsValue))\n+        {\n+            project.GenerateFullPaths = generateFullPathsValue;\n+        }\n+        else if (e.Properties is not null)\n+        {\n+            foreach (DictionaryEntry property in e.Properties)\n+            {\n+                if (property.Key is \"GenerateFullPaths\" &&",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "Have you tried matching on `EvaluationId`? It looks like the value passed to `ProjectStarted` matches the one in `ProjectEvaluationFinishedEventArgs`.",
              "createdAt": "2024-03-20T07:27:04Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -380,6 +390,30 @@ private void ProjectStarted(object sender, ProjectStartedEventArgs e)\n                 int nodeIndex = NodeIndexForContext(buildEventContext);\n                 _nodes[nodeIndex] = new NodeStatus(e.ProjectFile!, null, \"Restore\", _projects[c].Stopwatch);\n             }\n+\n+            TryDetectGenerateFullPaths(e, project);\n+        }\n+    }\n+\n+    private void TryDetectGenerateFullPaths(ProjectStartedEventArgs e, Project project)\n+    {\n+        if (e.GlobalProperties is not null\n+            && e.GlobalProperties.TryGetValue(\"GenerateFullPaths\", out string? generateFullPaths)\n+            && bool.TryParse(generateFullPaths, out bool generateFullPathsValue))\n+        {\n+            project.GenerateFullPaths = generateFullPathsValue;\n+        }\n+        else if (e.Properties is not null)\n+        {\n+            foreach (DictionaryEntry property in e.Properties)\n+            {\n+                if (property.Key is \"GenerateFullPaths\" &&",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "@ladipro there's something here that's making me pretty concerned.  I put breakpoints on 3 locations in the terminal logger\r\n\r\n* where we handle ProjectEvaluationFinishedEventArgs\r\n* where we handle ProjectStartedEventArgs\r\n* where we handle TaskParameterEventArgs\r\n\r\nand at no point is there an Id that remains the same across all of them. Here's some data from a recent test run to highlight the problem:\r\n\r\n```\r\nRestore evaluation (ProjectEvaluationFinishedEventArgs)\r\n    {Node=1 Submission=0 ProjectContext=-2 ProjectInstance=-1 Eval=4 Target=-1 Task=-1}\r\nRestore execution (ProjectStarted)\r\n    {Node=1 Submission=0 ProjectContext=4 ProjectInstance=2 Eval=4 Target=-1 Task=-1}\r\n_IsProjectRestoreSupported evaluation (ProjectEvaluationFinishedEventArgs)\r\n    {Node=1 Submission=0 ProjectContext=-2 ProjectInstance=-1 Eval=7 Target=-1 Task=-1}\r\n_IsProjectRestoreSupported execution (ProjectStarted)\r\n    {Node=1 Submission=0 ProjectContext=7 ProjectInstance=3 Eval=7 Target=-1 Task=-1}\r\n_GenerateRestoreProjectPathWalk execution (ProjectStarted)\r\n    {Node=1 Submission=0 ProjectContext=10 ProjectInstance=3 Eval=7 Target=-1 Task=-1}\r\n_IsProjectRestoreSupported execution (ProjectStarted)\r\n    {Node=1 Submission=0 ProjectContext=13 ProjectInstance=3 Eval=7 Target=-1 Task=-1}\r\n_GenerateRestoreGraphProjectEntry execution (ProjectStarted)\r\n    {Node=1 Submission=0 ProjectContext=16 ProjectInstance=3 Eval=7 Target=-1 Task=-1}\r\n_GenerateProjectRestoreGraph execution (ProjectStarted)\r\n    {Node=1 Submission=0 ProjectContext=19 ProjectInstance=3 Eval=7 Target=-1 Task=-1}\r\n'actual' evaluation (ProjectEvaluationFinishedEventArgs)\r\n    {Node=1 Submission=1 ProjectContext=-2 ProjectInstance=-1 Eval=10 Target=-1 Task=-1}\r\n'actual' execution (ProjectStarted)\r\n    {Node=1 Submission=1 ProjectContext=22 ProjectInstance=4 Eval=10 Target=-1 Task=-1}\r\nTaskItem emit (TaskParameterEventArgs) context - Why is Eval -1?\r\n    {Node=1 Submission=1 ProjectContext=22 ProjectInstance=4 Eval=-1 Target=135 Task=-1}\r\n```\r\n\r\nEach line is the build context at each state - my conclusion is there is no single Id that we can use to keep a shared context across evaluation, execution, and arbitrary task messages. I think we might need to keep/track both ProjectInstance and Eval Ids and be able to look up TerminalLogger's `Project` based on either of those.",
              "createdAt": "2024-03-20T15:02:01Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -380,6 +390,30 @@ private void ProjectStarted(object sender, ProjectStartedEventArgs e)\n                 int nodeIndex = NodeIndexForContext(buildEventContext);\n                 _nodes[nodeIndex] = new NodeStatus(e.ProjectFile!, null, \"Restore\", _projects[c].Stopwatch);\n             }\n+\n+            TryDetectGenerateFullPaths(e, project);\n+        }\n+    }\n+\n+    private void TryDetectGenerateFullPaths(ProjectStartedEventArgs e, Project project)\n+    {\n+        if (e.GlobalProperties is not null\n+            && e.GlobalProperties.TryGetValue(\"GenerateFullPaths\", out string? generateFullPaths)\n+            && bool.TryParse(generateFullPaths, out bool generateFullPathsValue))\n+        {\n+            project.GenerateFullPaths = generateFullPathsValue;\n+        }\n+        else if (e.Properties is not null)\n+        {\n+            foreach (DictionaryEntry property in e.Properties)\n+            {\n+                if (property.Key is \"GenerateFullPaths\" &&",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "I figured it out - I made a parallel tracker for data we are interested in from evaluation time (which right now is just TFM) and then use the `BuildMessageContext.Eval` property as the key for that evaluation data. This is working great and should be a good model for us in the future - we can use the new `EvaluationData` structure to hold specific data that's relevant just from an evaluation, and the `Project` structure should contain all data that changes or is computed at target execution time.",
              "createdAt": "2024-03-20T17:14:52Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -380,6 +390,30 @@ private void ProjectStarted(object sender, ProjectStartedEventArgs e)\n                 int nodeIndex = NodeIndexForContext(buildEventContext);\n                 _nodes[nodeIndex] = new NodeStatus(e.ProjectFile!, null, \"Restore\", _projects[c].Stopwatch);\n             }\n+\n+            TryDetectGenerateFullPaths(e, project);\n+        }\n+    }\n+\n+    private void TryDetectGenerateFullPaths(ProjectStartedEventArgs e, Project project)\n+    {\n+        if (e.GlobalProperties is not null\n+            && e.GlobalProperties.TryGetValue(\"GenerateFullPaths\", out string? generateFullPaths)\n+            && bool.TryParse(generateFullPaths, out bool generateFullPathsValue))\n+        {\n+            project.GenerateFullPaths = generateFullPathsValue;\n+        }\n+        else if (e.Properties is not null)\n+        {\n+            foreach (DictionaryEntry property in e.Properties)\n+            {\n+                if (property.Key is \"GenerateFullPaths\" &&",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: A `break` here would make it slightly better perf-wise.",
              "createdAt": "2024-03-19T21:35:27Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -380,6 +390,30 @@ private void ProjectStarted(object sender, ProjectStartedEventArgs e)\n                 int nodeIndex = NodeIndexForContext(buildEventContext);\n                 _nodes[nodeIndex] = new NodeStatus(e.ProjectFile!, null, \"Restore\", _projects[c].Stopwatch);\n             }\n+\n+            TryDetectGenerateFullPaths(e, project);\n+        }\n+    }\n+\n+    private void TryDetectGenerateFullPaths(ProjectStartedEventArgs e, Project project)\n+    {\n+        if (e.GlobalProperties is not null\n+            && e.GlobalProperties.TryGetValue(\"GenerateFullPaths\", out string? generateFullPaths)\n+            && bool.TryParse(generateFullPaths, out bool generateFullPathsValue))\n+        {\n+            project.GenerateFullPaths = generateFullPathsValue;\n+        }\n+        else if (e.Properties is not null)\n+        {\n+            foreach (DictionaryEntry property in e.Properties)\n+            {\n+                if (property.Key is \"GenerateFullPaths\" &&\n+                    property.Value is string generateFullPathsString\n+                    && bool.TryParse(generateFullPathsString, out bool generateFullPathsPropertyValue))\n+                {\n+                    project.GenerateFullPaths = generateFullPathsPropertyValue;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: You've removed the `TargetFramework` property.",
              "createdAt": "2024-03-21T12:18:40Z",
              "path": "src/MSBuild/TerminalLogger/Project.cs",
              "diffHunk": "@@ -10,16 +15,15 @@ namespace Microsoft.Build.Logging.TerminalLogger;\n /// <summary>\n /// Represents a project being built.\n /// </summary>\n+[DebuggerDisplay(\"{OutputPath}({TargetFramework})\")]",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}