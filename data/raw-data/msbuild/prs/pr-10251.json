{
  "number": 10251,
  "title": "Add version to BuildResult",
  "body": "Fixes #10208\r\n\r\n### Context\r\nWe are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases. The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\r\n- 1st step (done): Add a special key to the dictionary. The presence of this key indicates that the version is serialized next. When serializing, add a key to the dictionary and a version field. Delete the special key from the dictionary during the deserialization and read a version if it presents.\r\n- 2nd step: Stop writing a special key to the dictionary. Always serialize and de-serialize the version field. Remove the special keys if they present in the dictionary.\r\n- 3rd step: Stop removing the special keys from the dictionary.\r\n\r\n### Changes Made\r\n1st step from above description.\r\n\r\n### Testing\r\nUnit tests, manual tests, experimental insertion",
  "state": "CLOSED",
  "createdAt": "2024-06-17T11:13:29Z",
  "updatedAt": "2024-06-25T17:25:19Z",
  "closedAt": "2024-06-25T17:25:19Z",
  "mergedAt": null,
  "additions": 175,
  "deletions": 10,
  "changedFiles": 5,
  "headRefName": "fix-results-cache-versioning-2",
  "isDraft": true,
  "author": {
    "login": "AR-May"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "AR-May"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "1f494b95096806742a303eaf8f63e10925526ddf",
          "message": "Add version to BuildResult",
          "committedDate": "2024-06-17T11:05:51Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "547e719bdfe3aaf8c6db2e3ae15582cfe9e6c2dc",
          "message": "Fix comments.",
          "committedDate": "2024-06-17T11:14:40Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9eeeb1c48d9c4d1655f14890ee00bc40b1177441",
          "message": "Fix setting the version.",
          "committedDate": "2024-06-17T16:06:36Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "189f4e2d74609aa06ba84aae475faf2e3665fd87",
          "message": "Add tests.",
          "committedDate": "2024-06-18T08:33:14Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b5ef0c584a82bbb7b9ab3e0f57b008a0459a35b0",
          "message": "Adress comments",
          "committedDate": "2024-06-24T12:26:42Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "86b04afcb4b397936ad4bd854b80e2da2f01032a",
          "message": "Fix test",
          "committedDate": "2024-06-24T15:51:37Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "58c0632d089c798630074e42ebeaf11cf2f0c9dd",
          "message": "Merge remote-tracking branch 'upstream/vs17.11' into fix-results-cache-versioning-2",
          "committedDate": "2024-06-24T16:17:56Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a87b4119952c708b0d5ac978f3bcdb98f397e9d4",
          "message": "Add version bump",
          "committedDate": "2024-06-24T16:18:17Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "> The locking in translation method looks very suspitious - we should try to avoid that\r\n\r\n@JanKrivanek although I do not expect to Translate method to be called in parallel, if I am wrong, it might be quite a bad bug without this lock. One thing that I considered is to use a local dictionary instead of modifying the existing one. It might be a perf problem to create it each time though, so I decided in favor of extra lock. What is your suggestion for avoiding the lock?\r\n\r\nUPD: nvm, I saw your comment in code.",
        "createdAt": "2024-06-18T12:45:38Z",
        "author": {
          "login": "AR-May"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Could you please specify which mode is here? Is it only read? are there any other modes ?",
              "createdAt": "2024-06-17T12:48:43Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +634,82 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.\n+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\n+            // 1st step (done): Add a special key to the dictionary. The presence of this key indicates that the version is serialized next.\n+            // When serializing, add a key to the dictionary and a version field. Delete the special key from the dictionary during the deserialization and read a version if it presents.\n+            // 2nd step: Stop writing a special key to the dictionary. Always serialize and de-serialize the version field. Remove the special keys if they present in the dictionary.\n+            // 3rd step: Stop removing the special keys from the dictionary.\n+            if (Traits.Instance.EscapeHatches.DoNotVersionBuildResult)\n+            {\n+                // Escape hatch: serialize/deserialize without version field.\n+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+                _version = 0;\n+            }\n+            else\n+            {\n+                lock (_lock)\n+                {\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        // Add the special key VersionKeyName indicating the presence of a version to the _savedEnvironmentVariables dictionary.\n+                        // If the dictionary was null, add another special key SavedEnvironmentVariablesDictionaryWasNull to the dictionary.\n+                        if (_savedEnvironmentVariables is null)\n+                        {\n+                            _savedEnvironmentVariables = new Dictionary<string, string>\n+                            {\n+                                { SavedEnvironmentVariablesDictionaryWasNull, String.Empty }\n+                            };\n+                        }\n+\n+                        _savedEnvironmentVariables.Add(VersionKeyName, String.Empty);\n+                        translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+                        translator.Translate(ref _version);\n+\n+                        // Remove the added keys from the dictionary.\n+                        if (_savedEnvironmentVariables.ContainsKey(SavedEnvironmentVariablesDictionaryWasNull))\n+                        {\n+                            _savedEnvironmentVariables = null;\n+                        }\n+                        else\n+                        {\n+                            _savedEnvironmentVariables.Remove(VersionKeyName);\n+                        }\n+                    }\n+                    else",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "There is only read and write modes there. So, one code path is reading, another is writing.",
              "createdAt": "2024-06-17T12:59:41Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +634,82 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.\n+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\n+            // 1st step (done): Add a special key to the dictionary. The presence of this key indicates that the version is serialized next.\n+            // When serializing, add a key to the dictionary and a version field. Delete the special key from the dictionary during the deserialization and read a version if it presents.\n+            // 2nd step: Stop writing a special key to the dictionary. Always serialize and de-serialize the version field. Remove the special keys if they present in the dictionary.\n+            // 3rd step: Stop removing the special keys from the dictionary.\n+            if (Traits.Instance.EscapeHatches.DoNotVersionBuildResult)\n+            {\n+                // Escape hatch: serialize/deserialize without version field.\n+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+                _version = 0;\n+            }\n+            else\n+            {\n+                lock (_lock)\n+                {\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        // Add the special key VersionKeyName indicating the presence of a version to the _savedEnvironmentVariables dictionary.\n+                        // If the dictionary was null, add another special key SavedEnvironmentVariablesDictionaryWasNull to the dictionary.\n+                        if (_savedEnvironmentVariables is null)\n+                        {\n+                            _savedEnvironmentVariables = new Dictionary<string, string>\n+                            {\n+                                { SavedEnvironmentVariablesDictionaryWasNull, String.Empty }\n+                            };\n+                        }\n+\n+                        _savedEnvironmentVariables.Add(VersionKeyName, String.Empty);\n+                        translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+                        translator.Translate(ref _version);\n+\n+                        // Remove the added keys from the dictionary.\n+                        if (_savedEnvironmentVariables.ContainsKey(SavedEnvironmentVariablesDictionaryWasNull))\n+                        {\n+                            _savedEnvironmentVariables = null;\n+                        }\n+                        else\n+                        {\n+                            _savedEnvironmentVariables.Remove(VersionKeyName);\n+                        }\n+                    }\n+                    else",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Thank you for clarifying! Is there a chance to explicitly specify this mode per diffeerent else if (value == read mode )? ",
              "createdAt": "2024-06-17T15:03:34Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +634,82 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.\n+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\n+            // 1st step (done): Add a special key to the dictionary. The presence of this key indicates that the version is serialized next.\n+            // When serializing, add a key to the dictionary and a version field. Delete the special key from the dictionary during the deserialization and read a version if it presents.\n+            // 2nd step: Stop writing a special key to the dictionary. Always serialize and de-serialize the version field. Remove the special keys if they present in the dictionary.\n+            // 3rd step: Stop removing the special keys from the dictionary.\n+            if (Traits.Instance.EscapeHatches.DoNotVersionBuildResult)\n+            {\n+                // Escape hatch: serialize/deserialize without version field.\n+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+                _version = 0;\n+            }\n+            else\n+            {\n+                lock (_lock)\n+                {\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        // Add the special key VersionKeyName indicating the presence of a version to the _savedEnvironmentVariables dictionary.\n+                        // If the dictionary was null, add another special key SavedEnvironmentVariablesDictionaryWasNull to the dictionary.\n+                        if (_savedEnvironmentVariables is null)\n+                        {\n+                            _savedEnvironmentVariables = new Dictionary<string, string>\n+                            {\n+                                { SavedEnvironmentVariablesDictionaryWasNull, String.Empty }\n+                            };\n+                        }\n+\n+                        _savedEnvironmentVariables.Add(VersionKeyName, String.Empty);\n+                        translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+                        translator.Translate(ref _version);\n+\n+                        // Remove the added keys from the dictionary.\n+                        if (_savedEnvironmentVariables.ContainsKey(SavedEnvironmentVariablesDictionaryWasNull))\n+                        {\n+                            _savedEnvironmentVariables = null;\n+                        }\n+                        else\n+                        {\n+                            _savedEnvironmentVariables.Remove(VersionKeyName);\n+                        }\n+                    }\n+                    else",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "Why not indeed. It will be a bit more readable. I will do it.",
              "createdAt": "2024-06-17T16:05:46Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +634,82 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.\n+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\n+            // 1st step (done): Add a special key to the dictionary. The presence of this key indicates that the version is serialized next.\n+            // When serializing, add a key to the dictionary and a version field. Delete the special key from the dictionary during the deserialization and read a version if it presents.\n+            // 2nd step: Stop writing a special key to the dictionary. Always serialize and de-serialize the version field. Remove the special keys if they present in the dictionary.\n+            // 3rd step: Stop removing the special keys from the dictionary.\n+            if (Traits.Instance.EscapeHatches.DoNotVersionBuildResult)\n+            {\n+                // Escape hatch: serialize/deserialize without version field.\n+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+                _version = 0;\n+            }\n+            else\n+            {\n+                lock (_lock)\n+                {\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        // Add the special key VersionKeyName indicating the presence of a version to the _savedEnvironmentVariables dictionary.\n+                        // If the dictionary was null, add another special key SavedEnvironmentVariablesDictionaryWasNull to the dictionary.\n+                        if (_savedEnvironmentVariables is null)\n+                        {\n+                            _savedEnvironmentVariables = new Dictionary<string, string>\n+                            {\n+                                { SavedEnvironmentVariablesDictionaryWasNull, String.Empty }\n+                            };\n+                        }\n+\n+                        _savedEnvironmentVariables.Add(VersionKeyName, String.Empty);\n+                        translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+                        translator.Translate(ref _version);\n+\n+                        // Remove the added keys from the dictionary.\n+                        if (_savedEnvironmentVariables.ContainsKey(SavedEnvironmentVariablesDictionaryWasNull))\n+                        {\n+                            _savedEnvironmentVariables = null;\n+                        }\n+                        else\n+                        {\n+                            _savedEnvironmentVariables.Remove(VersionKeyName);\n+                        }\n+                    }\n+                    else",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Consider making this an illegal environment variable name, that is including the forbidden character `=` in it. That way if we forget to remove it at some point we will see it soon :)",
              "createdAt": "2024-06-17T14:29:57Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -100,6 +112,24 @@ public class BuildResult : INodePacket, IBuildResults\n         /// </summary>\n         private Dictionary<string, string> _savedEnvironmentVariables;\n \n+        /// <summary>\n+        /// Lock object for the dictionary <see cref=\"_savedEnvironmentVariables\"/>.\n+        /// </summary>\n+        private readonly object _lock = new object();\n+\n+        /// <summary>\n+        /// When this key is in the dictionary <see cref=\"_savedEnvironmentVariables\"/>, serialize the build result version.\n+        /// </summary>\n+        private const string VersionKeyName = \"MSBUILDFEATUREBUILDRESULTHASVERSION\";",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Oh, great idea! This will decrease the probability of collision to zero indeed.",
              "createdAt": "2024-06-18T08:37:34Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -100,6 +112,24 @@ public class BuildResult : INodePacket, IBuildResults\n         /// </summary>\n         private Dictionary<string, string> _savedEnvironmentVariables;\n \n+        /// <summary>\n+        /// Lock object for the dictionary <see cref=\"_savedEnvironmentVariables\"/>.\n+        /// </summary>\n+        private readonly object _lock = new object();\n+\n+        /// <summary>\n+        /// When this key is in the dictionary <see cref=\"_savedEnvironmentVariables\"/>, serialize the build result version.\n+        /// </summary>\n+        private const string VersionKeyName = \"MSBUILDFEATUREBUILDRESULTHASVERSION\";",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I cannot do this in the implementation with the lock - because the read of the dictionary is not protected by the lock it may lead to a crash trying to set this variable.",
              "createdAt": "2024-06-24T16:53:10Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -100,6 +112,24 @@ public class BuildResult : INodePacket, IBuildResults\n         /// </summary>\n         private Dictionary<string, string> _savedEnvironmentVariables;\n \n+        /// <summary>\n+        /// Lock object for the dictionary <see cref=\"_savedEnvironmentVariables\"/>.\n+        /// </summary>\n+        private readonly object _lock = new object();\n+\n+        /// <summary>\n+        /// When this key is in the dictionary <see cref=\"_savedEnvironmentVariables\"/>, serialize the build result version.\n+        /// </summary>\n+        private const string VersionKeyName = \"MSBUILDFEATUREBUILDRESULTHASVERSION\";",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Same illegal-env-var name comment",
              "createdAt": "2024-06-17T18:08:02Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -100,6 +112,24 @@ public class BuildResult : INodePacket, IBuildResults\n         /// </summary>\n         private Dictionary<string, string> _savedEnvironmentVariables;\n \n+        /// <summary>\n+        /// Lock object for the dictionary <see cref=\"_savedEnvironmentVariables\"/>.\n+        /// </summary>\n+        private readonly object _lock = new object();\n+\n+        /// <summary>\n+        /// When this key is in the dictionary <see cref=\"_savedEnvironmentVariables\"/>, serialize the build result version.\n+        /// </summary>\n+        private const string VersionKeyName = \"MSBUILDFEATUREBUILDRESULTHASVERSION\";\n+\n+        /// <summary>\n+        /// Presence of this key is in the dictionary <see cref=\"_savedEnvironmentVariables\"/> indicates that it was null.\n+        /// </summary>\n+        /// <remarks>\n+        /// There is a behavioral difference between dictionary <see cref=\"_savedEnvironmentVariables\"/> being empty and being null. Adding a magic key to distinguish these situations on deserialization. \n+        /// </remarks>\n+        private const string SavedEnvironmentVariablesDictionaryWasNull = \"MSBUILDSAVEDENVIRONMENTVARIABLESWASNULL\";",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we need to distinguish between empty an null original dictionary?\r\nIf yes - when can empty dictionary and when can null dictionary happen (e.g. no env vars vs env vars not sent)?\r\n\r\nIdeally we wouldn't care and do just:\r\n\r\n```csharp\r\n_savedEnvironmentVariables.Remove(VersionKeyName);\r\n```",
              "createdAt": "2024-06-17T19:12:40Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +639,81 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.\n+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\n+            // 1st step (done): Add a special key to the dictionary. The presence of this key indicates that the version is serialized next.\n+            // When serializing, add a key to the dictionary and a version field. Delete the special key from the dictionary during the deserialization and read a version if it presents.\n+            // 2nd step: Stop writing a special key to the dictionary. Always serialize and de-serialize the version field. Remove the special keys if they present in the dictionary.\n+            // 3rd step: Stop removing the special keys from the dictionary.\n+            if (_version == 0)\n+            {\n+                // Escape hatch: serialize/deserialize without version field.\n+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+            }\n+            else\n+            {\n+                lock (_lock)\n+                {\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        // Add the special key VersionKeyName indicating the presence of a version to the _savedEnvironmentVariables dictionary.\n+                        // If the dictionary was null, add another special key SavedEnvironmentVariablesDictionaryWasNull to the dictionary.\n+                        if (_savedEnvironmentVariables is null)\n+                        {\n+                            _savedEnvironmentVariables = new Dictionary<string, string>\n+                            {\n+                                { SavedEnvironmentVariablesDictionaryWasNull, String.Empty }\n+                            };\n+                        }\n+\n+                        _savedEnvironmentVariables.Add(VersionKeyName, String.Empty);\n+                        translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+                        translator.Translate(ref _version);\n+\n+                        // Remove the added keys from the dictionary.\n+                        if (_savedEnvironmentVariables.ContainsKey(SavedEnvironmentVariablesDictionaryWasNull))\n+                        {\n+                            _savedEnvironmentVariables = null;\n+                        }\n+                        else\n+                        {\n+                            _savedEnvironmentVariables.Remove(VersionKeyName);\n+                        }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Yes, ideally, we would not care, however when I was digging into it, I found there might be a behavioral difference between null and empty dictionary: https://github.com/dotnet/msbuild/blob/0a3683cf7bb7d635aa418dbc8afbc69f6aa3e2cb/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L1278\r\nIt seems to me that when the `BuildParameters.SaveOperatingEnvironment` is true the SavedEnvironmentVariables should actually exist and this null check is not needed, but maybe under a certain condition (like first build on a node or something similar) it might not. I thought it is safer to assume this null check is not redundant there, so we do not unintentionally introduce behavior changes.",
              "createdAt": "2024-06-18T09:20:50Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +639,81 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.\n+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\n+            // 1st step (done): Add a special key to the dictionary. The presence of this key indicates that the version is serialized next.\n+            // When serializing, add a key to the dictionary and a version field. Delete the special key from the dictionary during the deserialization and read a version if it presents.\n+            // 2nd step: Stop writing a special key to the dictionary. Always serialize and de-serialize the version field. Remove the special keys if they present in the dictionary.\n+            // 3rd step: Stop removing the special keys from the dictionary.\n+            if (_version == 0)\n+            {\n+                // Escape hatch: serialize/deserialize without version field.\n+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+            }\n+            else\n+            {\n+                lock (_lock)\n+                {\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        // Add the special key VersionKeyName indicating the presence of a version to the _savedEnvironmentVariables dictionary.\n+                        // If the dictionary was null, add another special key SavedEnvironmentVariablesDictionaryWasNull to the dictionary.\n+                        if (_savedEnvironmentVariables is null)\n+                        {\n+                            _savedEnvironmentVariables = new Dictionary<string, string>\n+                            {\n+                                { SavedEnvironmentVariablesDictionaryWasNull, String.Empty }\n+                            };\n+                        }\n+\n+                        _savedEnvironmentVariables.Add(VersionKeyName, String.Empty);\n+                        translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+                        translator.Translate(ref _version);\n+\n+                        // Remove the added keys from the dictionary.\n+                        if (_savedEnvironmentVariables.ContainsKey(SavedEnvironmentVariablesDictionaryWasNull))\n+                        {\n+                            _savedEnvironmentVariables = null;\n+                        }\n+                        else\n+                        {\n+                            _savedEnvironmentVariables.Remove(VersionKeyName);\n+                        }",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is the lock guarding here?\r\n\r\nThe `_savedEnvironmentVariables` can anyways be accessed outside of the synchronized context and concurent access to `Translate` method seems as a weird scenario",
              "createdAt": "2024-06-17T19:18:54Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +639,81 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.\n+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\n+            // 1st step (done): Add a special key to the dictionary. The presence of this key indicates that the version is serialized next.\n+            // When serializing, add a key to the dictionary and a version field. Delete the special key from the dictionary during the deserialization and read a version if it presents.\n+            // 2nd step: Stop writing a special key to the dictionary. Always serialize and de-serialize the version field. Remove the special keys if they present in the dictionary.\n+            // 3rd step: Stop removing the special keys from the dictionary.\n+            if (_version == 0)\n+            {\n+                // Escape hatch: serialize/deserialize without version field.\n+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+            }\n+            else\n+            {\n+                lock (_lock)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Can we do it without mutating `_savedEnvironmentVariables `?\r\nE.g. - in the `WriteToStream` direction we can probably create and use an overload of `TranslateDictionary`, that would accept optional IEnumerable<KeyValuePair<string,string>>. And in the `ReadFromStream` direction we can read to a temporary dictionary, process it, and only then assign it to the `_savedEnvironmentVariables` variable",
              "createdAt": "2024-06-17T19:22:34Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +639,81 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.\n+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\n+            // 1st step (done): Add a special key to the dictionary. The presence of this key indicates that the version is serialized next.\n+            // When serializing, add a key to the dictionary and a version field. Delete the special key from the dictionary during the deserialization and read a version if it presents.\n+            // 2nd step: Stop writing a special key to the dictionary. Always serialize and de-serialize the version field. Remove the special keys if they present in the dictionary.\n+            // 3rd step: Stop removing the special keys from the dictionary.\n+            if (_version == 0)\n+            {\n+                // Escape hatch: serialize/deserialize without version field.\n+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+            }\n+            else\n+            {\n+                lock (_lock)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I thought about it. \r\n\r\nIn the deserialization code path I agree, just writing to a local dictionary and then reassigning the `_savedEnvironmentVariables` is a good solution. But on the deserialization the object is not ready to be used anyway - every field are null, it is being created, so I think it is not necessary to do this. \r\n\r\nBut in other direction, serialization, we will need to have a copy of the dictionary to add the keys and serialize. I have a perf concern about this one. Also, if someone will read the field, this is not covered by a lock, so it might lead to some problems. But, first, it should not happen on this stage of the build. And second - this is a mild bug, the env variables that are never used are added. However, if I use the @rainersigwald idea of making these keys illegal env. variables names, it might lead to a crash, and that is a bigger issue. ",
              "createdAt": "2024-06-18T12:56:47Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +639,81 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.\n+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\n+            // 1st step (done): Add a special key to the dictionary. The presence of this key indicates that the version is serialized next.\n+            // When serializing, add a key to the dictionary and a version field. Delete the special key from the dictionary during the deserialization and read a version if it presents.\n+            // 2nd step: Stop writing a special key to the dictionary. Always serialize and de-serialize the version field. Remove the special keys if they present in the dictionary.\n+            // 3rd step: Stop removing the special keys from the dictionary.\n+            if (_version == 0)\n+            {\n+                // Escape hatch: serialize/deserialize without version field.\n+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+            }\n+            else\n+            {\n+                lock (_lock)",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      }
    ]
  }
}