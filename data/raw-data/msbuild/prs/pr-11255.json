{
  "number": 11255,
  "title": "Implement OpenTelemetry infrastructure",
  "body": "Fixes #10945 #10948\r\n\r\n### Context\r\nhttps://github.com/dotnet/msbuild/issues/10560\r\n- infrastructure part of this\r\n\r\n### Changes Made\r\nadd singleton OpenTelemetryManager\r\n\r\nexecutions in Framework (standalone and managed) trace and collect basic build events with a defined sampling rate.\r\nSending end of build telemetry comparable to the one sent in sdk.\r\n\r\n### Testing\r\nUnit tests of the behavior,\r\nmonitoring if we get data to the backend\r\nmanual tests in experimental insertions\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2025-01-10T14:47:47Z",
  "updatedAt": "2025-02-21T12:55:43Z",
  "closedAt": "2025-02-21T12:55:43Z",
  "mergedAt": "2025-02-21T12:55:43Z",
  "additions": 1213,
  "deletions": 74,
  "changedFiles": 32,
  "headRefName": "otel-basic",
  "isDraft": false,
  "author": {
    "login": "JanProvaznik"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "ff9341d954da4bf1066f5a19da65a1b82adb3c22",
          "message": "implement, add tests",
          "committedDate": "2025-01-10T14:46:34Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9fe19f87a1b9572a048dc4c3cd3f23d21ca4af82",
          "message": "Merge branch 'main' into otel-basic",
          "committedDate": "2025-01-10T14:53:09Z",
          "author": {
            "name": "Jan Provazn\u00edk",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a2f07203ed89de1252cbeb5dd5216e1a7272d48b",
          "message": "update app.config s",
          "committedDate": "2025-01-10T16:18:13Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "96eeeee1434fa1bab3099a97b39d0e5558e45225",
          "message": "Merge branch 'otel-basic' of https://github.com/JanProvaznik/msbuild into otel-basic",
          "committedDate": "2025-01-10T16:18:27Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "49467bbb4c1eac81a2d675dd24d454ca75240e88",
          "message": "fix test envvar behavior",
          "committedDate": "2025-01-13T09:31:43Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cdaa52a07b7e5de23f2a24c6aff99f0a94e89c31",
          "message": "apply feedback",
          "committedDate": "2025-01-13T10:53:49Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2c28a876661a4ab94209e028a5ad56caed084533",
          "message": "don't use ConversionUtilities",
          "committedDate": "2025-01-13T11:32:17Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cf089e950a5092fe4989f13fa09153461c2b65a3",
          "message": "fix: dispose before flushing",
          "committedDate": "2025-01-13T12:32:59Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7b88424f298d035202694653151334e3f4d162a0",
          "message": "Move telemetry envvar handling to Traits\nunify hashing logic",
          "committedDate": "2025-01-14T13:10:00Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "49c429d4d1f12995ec9243df89df4d2d3e27265f",
          "message": "downgrade packages, manage lifetime of telemetry in BuildManager",
          "committedDate": "2025-01-14T16:15:43Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c95245c8ea019bd43b038a9f6294ddf30ff8d261",
          "message": "test what happens in ci with otel",
          "committedDate": "2025-01-14T18:04:30Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "918912158801a067a9039d30acd2706835e66fee",
          "message": "testing in ci",
          "committedDate": "2025-01-15T11:53:14Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9dfb8c9ec339ec6a27c7211749493da95d6261ab",
          "message": "remove explicit adding source to exporter, wildcard from VS default handles that",
          "committedDate": "2025-01-15T19:22:05Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "338570428f31de1347ae6815ab97a5d0f5161bcf",
          "message": "remove assembly redirect",
          "committedDate": "2025-01-16T13:38:44Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a43acbdf50fdb038f8406f79f3bce5d4af06f0f8",
          "message": "remove binding redirect",
          "committedDate": "2025-01-16T13:45:37Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b2f06013bfe816254953cccfe2251377b1d67e78",
          "message": "remove explicit Extensions primitives reference",
          "committedDate": "2025-01-16T16:11:37Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fab67b538f472049aed28a3d6d3623bf9d736049",
          "message": "undo binding asyncinterface binding redirect deletion",
          "committedDate": "2025-01-16T16:19:47Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "da883a92d447ee0f8d7773c2ec9b87a509fa3a43",
          "message": "reintroduce diagnosticsource redirect",
          "committedDate": "2025-01-16T16:30:24Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1c6a09960bddbb74bd96b8b0bc0cce2af3f25b02",
          "message": "nit",
          "committedDate": "2025-01-16T16:32:06Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "de12d0574b4f596a1c6889a643314ae05874938d",
          "message": "reintroduce extensions binding redirect...",
          "committedDate": "2025-01-16T17:24:27Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a208e672da7bbe02096de30b8e9146dce1a582d2",
          "message": "downgrade diagnosticsource, upgrade VSOTel to VS compatible verison",
          "committedDate": "2025-01-17T15:29:02Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eba5787f65ea665edcdb44bba57a115119594e67",
          "message": "downgrade diagnosticsource, privateassets vs otel",
          "committedDate": "2025-01-17T15:33:22Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f05135f73538f473d44b106971d244c00a73fa3c",
          "message": "remove Extensions primitives redirect",
          "committedDate": "2025-01-17T15:36:40Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6ef74969fca7c48dcf0868f5cf09a6989daee419",
          "message": "Revert \"remove Extensions primitives redirect\"\n\nThis reverts commit f05135f73538f473d44b106971d244c00a73fa3c.",
          "committedDate": "2025-01-17T16:09:18Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "06ef018b16d381f89c87c7e097d0d3394f05ca8f",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild into otel-basic",
          "committedDate": "2025-01-17T16:48:57Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9ceb237e1fd296d3e7b1435b21991c84dc5466e3",
          "message": "Avoid ValueTuple build error",
          "committedDate": "2025-01-17T23:22:53Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5fee7a5fb8706365208c58f4bcd2dfb2a267d558",
          "message": "Merge branch 'otel-basic' of https://github.com/JanProvaznik/msbuild into otel-basic",
          "committedDate": "2025-01-20T08:07:50Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e0f93124e256164348d75f86a0350204ec05512c",
          "message": "reference correct diagnosticsource in version.details.xml",
          "committedDate": "2025-01-20T10:05:15Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "735f6e226080d4ad9c3d1612761fdd66d93987af",
          "message": "include otel in test packages",
          "committedDate": "2025-01-20T10:05:34Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "db283b0b83915413345b14409c801f48337b3855",
          "message": "mention places that need to upgrade vs version on major release",
          "committedDate": "2025-01-20T12:35:03Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "91afbfae1db6bdab86cf077af26897f7cc731eb8",
          "message": "17.14 changewave = optout",
          "committedDate": "2025-01-20T17:59:14Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "41a7879f5bce0d19605bf13cf3aad92a75c37159",
          "message": "fix logic in GetProperties",
          "committedDate": "2025-01-21T17:12:12Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8c0c825513e262b0bf8cf1a644ea67d518785974",
          "message": "remove explicit references that are transitively included",
          "committedDate": "2025-01-22T10:32:43Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "91643e39273edec13ef2c7b6e8d3a14df67779f9",
          "message": "remove vs-impl package source",
          "committedDate": "2025-01-22T12:57:36Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "802dfc0eef5933ebc41d2d0a7756b858b97aef9c",
          "message": "adjust VS package",
          "committedDate": "2025-01-22T12:58:17Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb72029eb33ad40e9a2cd5ef0d319713711aa136",
          "message": "move telemetrystate inside the class it's relevant to",
          "committedDate": "2025-01-22T12:59:50Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a1ffd51bdec651a02d7137ad030eaa727fbb1eb2",
          "message": "Revert \"remove vs-impl package source\"\n\nThis reverts commit 91643e39273edec13ef2c7b6e8d3a14df67779f9.",
          "committedDate": "2025-01-22T13:05:45Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f4befb6c4aea09a502bea0e34bad08dbd2158ed5",
          "message": "Merge branch 'main' into otel-basic",
          "committedDate": "2025-01-22T13:27:34Z",
          "author": {
            "name": "Jan Provazn\u00edk",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "559f85d55c03c7e0890517a944dff1bef8375ddb",
          "message": "add Otel to dependent assemblies",
          "committedDate": "2025-01-22T14:29:32Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "17e7628e9c7f3e2fd477c9f38fbb4f8b6079566f",
          "message": "add all transitive dependencies to app.amd64.config and ngen",
          "committedDate": "2025-01-23T11:23:13Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6627e028709eb3cd25611313ca03903fcf8247c4",
          "message": "don't sign OpenTelemetry",
          "committedDate": "2025-01-23T14:36:28Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "86fcf77f8160f69a40eb4eb6d405d4cf7a1ba009",
          "message": "sign correctly",
          "committedDate": "2025-01-23T16:32:56Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "039e92995701ab6c0cede01e82d0e827ecb8953c",
          "message": "thirdpartynotices new packages",
          "committedDate": "2025-01-24T10:11:11Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "83bdf4ffd20c9fc1ded87880a8abc5176e5978b1",
          "message": "extensions primitives to swr",
          "committedDate": "2025-01-24T10:12:00Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "512ef64eaeee5e0d502ef57711a62df4d9b44952",
          "message": "more missing packages in swr",
          "committedDate": "2025-01-24T10:52:21Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "da511752c9042601320735c2caf57eaebe7c0071",
          "message": "remove otel assemblies from test project",
          "committedDate": "2025-01-27T11:45:19Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bfba539d3e6da9de6b21b71787fad9a32edf55f5",
          "message": "gracefully handle load errors",
          "committedDate": "2025-01-27T12:30:01Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3789e8b863eb54e6a668aba4e81428930efb9067",
          "message": "reintroduce reliable shutdown in standalone, and unreliable longrunning",
          "committedDate": "2025-01-27T12:30:47Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c2d550b5694d89b5dd9c0552bb2268917d9b8c15",
          "message": "fix tests",
          "committedDate": "2025-01-27T14:06:42Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a5c2ce60f948b57ffd65f6d0183f9a3218e67189",
          "message": "avoid assembly loads when not sampled, add samplerate as a telemetry datapoint",
          "committedDate": "2025-01-29T12:42:27Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b885721cf0404e60e87da0bcf7c27f418c7ba27a",
          "message": "refactor tests",
          "committedDate": "2025-01-30T14:17:14Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e4fe8665cb0c11cc4ed7fa21ae737a342d30f5b3",
          "message": "disable telemetry by default",
          "committedDate": "2025-01-30T14:35:41Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "26203bcb00fee56d3375de5b8db8fadf766ed380",
          "message": "fix tests",
          "committedDate": "2025-01-30T16:52:53Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "81664cbfff36a4b2788970a0bf7ba29bbb6bdf02",
          "message": "handle envvars correctly in test context",
          "committedDate": "2025-01-31T09:38:23Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9e06c721763ea81b650918f106ed6ca02c455c91",
          "message": "reformulate release checklist, needs hashing clarification, lock-free early return in initialize, exception pattern match",
          "committedDate": "2025-02-03T12:40:16Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "99f8d0afbc1dbfe1ba0a596af5ae1f0acd417a08",
          "message": "Merge branch 'main' into otel-basic",
          "committedDate": "2025-02-03T13:46:10Z",
          "author": {
            "name": "Jan Provazn\u00edk",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d4c024ed9204f66b3669b242b4a77e54105fe292",
          "message": "format thirdpartynotices",
          "committedDate": "2025-02-04T10:21:20Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "21c9d98db2bd87b794ff4e068eeb51c932e4d66b",
          "message": "separate opt in and override sample rate concepts",
          "committedDate": "2025-02-07T15:31:39Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "034c1af2508e68049b83e484fcb34b21b6d00d6a",
          "message": "update telemetry version",
          "committedDate": "2025-02-07T15:31:59Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "88eaab41b435b3c08c872cb09f374dd345557cff",
          "message": "rm accidentally commited file",
          "committedDate": "2025-02-18T10:46:24Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8f54bcf181174d4b7b5a7416bf018748a93f8486",
          "message": "Merge branch 'main' into otel-basic",
          "committedDate": "2025-02-20T07:44:44Z",
          "author": {
            "name": "Jan Provazn\u00edk",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3d5c9e43043e3438db96205c5dd20d77a9521f79",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild into otel-basic",
          "committedDate": "2025-02-20T08:01:38Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b16b5c451da1048139cc66e0fefad39f742ea398",
          "message": "fix telemetry version",
          "committedDate": "2025-02-20T20:47:39Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f2c8ea9e99a7fde53b82622bd13dd237e31afebe",
          "message": "remove internal, because it has no effect due to sdk optout",
          "committedDate": "2025-02-20T20:50:07Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3b96e5d9a373d35403af269046acb9949c8599ad",
          "message": "Merge remote-tracking branch 'refs/remotes/origin/otel-basic' into otel-basic",
          "committedDate": "2025-02-20T20:51:03Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d5f42fb8b78dc986a0674f0518587279e03ae23b",
          "message": "ungac correct version",
          "committedDate": "2025-02-21T08:06:25Z",
          "author": {
            "name": "Jan Provaznik",
            "email": "janprovaznik@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "A suggestion, feel free to ignore:\r\ncan we logically split the types of collected data? e.g. `AddFeatureFlags`, `AddBuildProperties`, `AddTimeMetrics`, to improve readability and simplify adding new lines?\r\n\r\nIt looks like this method has a huge potential to grow :)",
              "createdAt": "2025-01-13T09:31:11Z",
              "path": "src/Framework/Telemetry/BuildTelemetry.cs",
              "diffHunk": "@@ -167,5 +167,56 @@ public override IDictionary<string, string> GetProperties()\n \n             return properties;\n         }\n+\n+        /// <summary>\n+        /// Create a list of properties sent to VS telemetry with the information whether they should be hashed.\n+        /// </summary>\n+        /// <returns></returns>\n+        public IList<TelemetryItem> GetActivityProperties()",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "My idea is that this class is holding basic datapoints that are shared between sdk and VS telemetry which won't change soon, so likely YAGNI.\r\nFor more telemetry events with multiple data points there will be different classes holding that data implementing IActivityTelemetryDataHolder. I am open to the opinions that this scheme is wrong in it's entirety, but if not I think refactoring this specific class is overengineering.",
              "createdAt": "2025-01-31T09:52:38Z",
              "path": "src/Framework/Telemetry/BuildTelemetry.cs",
              "diffHunk": "@@ -167,5 +167,56 @@ public override IDictionary<string, string> GetProperties()\n \n             return properties;\n         }\n+\n+        /// <summary>\n+        /// Create a list of properties sent to VS telemetry with the information whether they should be hashed.\n+        /// </summary>\n+        /// <returns></returns>\n+        public IList<TelemetryItem> GetActivityProperties()",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it possible to avoid raw strings here and use `nameof` instead?",
              "createdAt": "2025-01-13T09:33:00Z",
              "path": "src/Framework/Telemetry/BuildTelemetry.cs",
              "diffHunk": "@@ -167,5 +167,56 @@ public override IDictionary<string, string> GetProperties()\n \n             return properties;\n         }\n+\n+        /// <summary>\n+        /// Create a list of properties sent to VS telemetry with the information whether they should be hashed.\n+        /// </summary>\n+        /// <returns></returns>\n+        public IList<TelemetryItem> GetActivityProperties()\n+        {\n+            List<TelemetryItem> telemetryItems = new(8);\n+\n+            if (StartAt.HasValue && FinishedAt.HasValue)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildDurationInMilliseconds\", (FinishedAt.Value - StartAt.Value).TotalMilliseconds, false));\n+            }\n+\n+            if (InnerStartAt.HasValue && FinishedAt.HasValue)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"InnerBuildDurationInMilliseconds\", (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds, false));\n+            }\n+\n+            if (Host != null)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildEngineHost\", Host, false));\n+            }\n+\n+            if (Success.HasValue)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildSuccess\", Success, false));\n+            }\n+\n+            if (Target != null)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildTarget\", Target, true));\n+            }\n+\n+            if (Version != null)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildEngineVersion\", Version.ToString(), false));\n+            }\n+\n+            if (BuildCheckEnabled != null)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildCheckEnabled\", BuildCheckEnabled, false));",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "can Version or other strings be empty?",
              "createdAt": "2025-01-13T09:33:32Z",
              "path": "src/Framework/Telemetry/BuildTelemetry.cs",
              "diffHunk": "@@ -167,5 +167,56 @@ public override IDictionary<string, string> GetProperties()\n \n             return properties;\n         }\n+\n+        /// <summary>\n+        /// Create a list of properties sent to VS telemetry with the information whether they should be hashed.\n+        /// </summary>\n+        /// <returns></returns>\n+        public IList<TelemetryItem> GetActivityProperties()\n+        {\n+            List<TelemetryItem> telemetryItems = new(8);\n+\n+            if (StartAt.HasValue && FinishedAt.HasValue)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildDurationInMilliseconds\", (FinishedAt.Value - StartAt.Value).TotalMilliseconds, false));\n+            }\n+\n+            if (InnerStartAt.HasValue && FinishedAt.HasValue)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"InnerBuildDurationInMilliseconds\", (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds, false));\n+            }\n+\n+            if (Host != null)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildEngineHost\", Host, false));\n+            }\n+\n+            if (Success.HasValue)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildSuccess\", Success, false));\n+            }\n+\n+            if (Target != null)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildTarget\", Target, true));\n+            }\n+\n+            if (Version != null)",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "some of these strings are sometimes empty, this is copied logic from sdk telemetry, I'm leaning towards that it's out of scope to refactor here",
              "createdAt": "2025-01-30T14:54:15Z",
              "path": "src/Framework/Telemetry/BuildTelemetry.cs",
              "diffHunk": "@@ -167,5 +167,56 @@ public override IDictionary<string, string> GetProperties()\n \n             return properties;\n         }\n+\n+        /// <summary>\n+        /// Create a list of properties sent to VS telemetry with the information whether they should be hashed.\n+        /// </summary>\n+        /// <returns></returns>\n+        public IList<TelemetryItem> GetActivityProperties()\n+        {\n+            List<TelemetryItem> telemetryItems = new(8);\n+\n+            if (StartAt.HasValue && FinishedAt.HasValue)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildDurationInMilliseconds\", (FinishedAt.Value - StartAt.Value).TotalMilliseconds, false));\n+            }\n+\n+            if (InnerStartAt.HasValue && FinishedAt.HasValue)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"InnerBuildDurationInMilliseconds\", (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds, false));\n+            }\n+\n+            if (Host != null)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildEngineHost\", Host, false));\n+            }\n+\n+            if (Success.HasValue)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildSuccess\", Success, false));\n+            }\n+\n+            if (Target != null)\n+            {\n+                telemetryItems.Add(new TelemetryItem(\"BuildTarget\", Target, true));\n+            }\n+\n+            if (Version != null)",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "could you please add documentation here in this class?",
              "createdAt": "2025-01-13T09:34:37Z",
              "path": "src/Framework/Telemetry/ActivityExtensions.cs",
              "diffHunk": "@@ -0,0 +1,110 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;   // for Microsoft.VisualStudio.OpenTelemetry.ClientExtensions\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+#else\n+using System.Security.Cryptography;\n+using System.Text;\n+#endif\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    internal static class ActivityExtensions\n+    {\n+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder dataHolder)",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "please check https://github.com/dotnet/msbuild/blob/bfa266d7c91ead845ce90b80f639a384abc38793/src/Shared/ConversionUtilities.cs#L17 to reuse some of methods for hashing",
              "createdAt": "2025-01-13T09:38:49Z",
              "path": "src/Framework/Telemetry/ActivityExtensions.cs",
              "diffHunk": "@@ -0,0 +1,110 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;   // for Microsoft.VisualStudio.OpenTelemetry.ClientExtensions\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+#else\n+using System.Security.Cryptography;\n+using System.Text;\n+#endif\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    internal static class ActivityExtensions\n+    {\n+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder dataHolder)\n+        {\n+            activity.WithTags(dataHolder.GetActivityProperties());\n+            return activity;\n+        }\n+\n+        public static Activity WithTags(this Activity activity, IList<TelemetryItem> tags)\n+        {\n+            foreach (var tag in tags)\n+            {\n+                activity.WithTag(tag);\n+            }\n+            return activity;\n+        }\n+\n+        public static Activity WithTag(this Activity activity, TelemetryItem item)\n+        {\n+            object value = item.Hashed ? GetHashed(item.Value) : item.Value;\n+            activity.SetTag($\"{TelemetryConstants.PropertyPrefix}{item.Name}\", value);\n+            return activity;\n+        }\n+\n+        public static Activity WithStartTime(this Activity activity, DateTime? startTime)\n+        {\n+            if (startTime.HasValue)\n+            {\n+                activity.SetStartTime(startTime.Value);\n+            }\n+            return activity;\n+        }\n+\n+        private static object GetHashed(object value)\n+        {\n+#if NETFRAMEWORK\n+                        return new clientext::Microsoft.VisualStudio.Telemetry.TelemetryHashedProperty(value);\n+#else\n+            return Sha256Hasher.Hash(value.ToString() ?? \"\");\n+#endif\n+        }\n+\n+        // https://github.com/dotnet/sdk/blob/8bd19a2390a6bba4aa80d1ac3b6c5385527cc311/src/Cli/Microsoft.DotNet.Cli.Utils/Sha256Hasher.cs + workaround for netstandard2.0\n+#if NET || NETSTANDARD2_0_OR_GREATER\n+        private static class Sha256Hasher\n+        {\n+            /// <summary>\n+            /// The hashed mac address needs to be the same hashed value as produced by the other distinct sources given the same input. (e.g. VsCode)\n+            /// </summary>\n+            public static string Hash(string text)\n+            {\n+                byte[] bytes = Encoding.UTF8.GetBytes(text);\n+#if NET\n+                byte[] hash = SHA256.HashData(bytes);\n+#if NET9_0_OR_GREATER\n+                return Convert.ToHexStringLower(hash);\n+#else\n+            return Convert.ToHexString(hash).ToLowerInvariant();\n+#endif\n+\n+#else\n+            // Create the SHA256 object and compute the hash\n+            using (var sha256 = SHA256.Create())",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "The aim here is to do the same thing as sdk https://github.com/dotnet/sdk/blob/8bd19a2390a6bba4aa80d1ac3b6c5385527cc311/src/Cli/Microsoft.DotNet.Cli.Utils/Sha256Hasher.cs not to use MSBuild-specific implementations.",
              "createdAt": "2025-01-13T11:12:01Z",
              "path": "src/Framework/Telemetry/ActivityExtensions.cs",
              "diffHunk": "@@ -0,0 +1,110 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;   // for Microsoft.VisualStudio.OpenTelemetry.ClientExtensions\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+#else\n+using System.Security.Cryptography;\n+using System.Text;\n+#endif\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    internal static class ActivityExtensions\n+    {\n+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder dataHolder)\n+        {\n+            activity.WithTags(dataHolder.GetActivityProperties());\n+            return activity;\n+        }\n+\n+        public static Activity WithTags(this Activity activity, IList<TelemetryItem> tags)\n+        {\n+            foreach (var tag in tags)\n+            {\n+                activity.WithTag(tag);\n+            }\n+            return activity;\n+        }\n+\n+        public static Activity WithTag(this Activity activity, TelemetryItem item)\n+        {\n+            object value = item.Hashed ? GetHashed(item.Value) : item.Value;\n+            activity.SetTag($\"{TelemetryConstants.PropertyPrefix}{item.Name}\", value);\n+            return activity;\n+        }\n+\n+        public static Activity WithStartTime(this Activity activity, DateTime? startTime)\n+        {\n+            if (startTime.HasValue)\n+            {\n+                activity.SetStartTime(startTime.Value);\n+            }\n+            return activity;\n+        }\n+\n+        private static object GetHashed(object value)\n+        {\n+#if NETFRAMEWORK\n+                        return new clientext::Microsoft.VisualStudio.Telemetry.TelemetryHashedProperty(value);\n+#else\n+            return Sha256Hasher.Hash(value.ToString() ?? \"\");\n+#endif\n+        }\n+\n+        // https://github.com/dotnet/sdk/blob/8bd19a2390a6bba4aa80d1ac3b6c5385527cc311/src/Cli/Microsoft.DotNet.Cli.Utils/Sha256Hasher.cs + workaround for netstandard2.0\n+#if NET || NETSTANDARD2_0_OR_GREATER\n+        private static class Sha256Hasher\n+        {\n+            /// <summary>\n+            /// The hashed mac address needs to be the same hashed value as produced by the other distinct sources given the same input. (e.g. VsCode)\n+            /// </summary>\n+            public static string Hash(string text)\n+            {\n+                byte[] bytes = Encoding.UTF8.GetBytes(text);\n+#if NET\n+                byte[] hash = SHA256.HashData(bytes);\n+#if NET9_0_OR_GREATER\n+                return Convert.ToHexStringLower(hash);\n+#else\n+            return Convert.ToHexString(hash).ToLowerInvariant();\n+#endif\n+\n+#else\n+            // Create the SHA256 object and compute the hash\n+            using (var sha256 = SHA256.Create())",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "how do be plan to stay up to date with sdk implementation?\r\n",
              "createdAt": "2025-01-13T11:21:08Z",
              "path": "src/Framework/Telemetry/ActivityExtensions.cs",
              "diffHunk": "@@ -0,0 +1,110 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;   // for Microsoft.VisualStudio.OpenTelemetry.ClientExtensions\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+#else\n+using System.Security.Cryptography;\n+using System.Text;\n+#endif\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    internal static class ActivityExtensions\n+    {\n+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder dataHolder)\n+        {\n+            activity.WithTags(dataHolder.GetActivityProperties());\n+            return activity;\n+        }\n+\n+        public static Activity WithTags(this Activity activity, IList<TelemetryItem> tags)\n+        {\n+            foreach (var tag in tags)\n+            {\n+                activity.WithTag(tag);\n+            }\n+            return activity;\n+        }\n+\n+        public static Activity WithTag(this Activity activity, TelemetryItem item)\n+        {\n+            object value = item.Hashed ? GetHashed(item.Value) : item.Value;\n+            activity.SetTag($\"{TelemetryConstants.PropertyPrefix}{item.Name}\", value);\n+            return activity;\n+        }\n+\n+        public static Activity WithStartTime(this Activity activity, DateTime? startTime)\n+        {\n+            if (startTime.HasValue)\n+            {\n+                activity.SetStartTime(startTime.Value);\n+            }\n+            return activity;\n+        }\n+\n+        private static object GetHashed(object value)\n+        {\n+#if NETFRAMEWORK\n+                        return new clientext::Microsoft.VisualStudio.Telemetry.TelemetryHashedProperty(value);\n+#else\n+            return Sha256Hasher.Hash(value.ToString() ?? \"\");\n+#endif\n+        }\n+\n+        // https://github.com/dotnet/sdk/blob/8bd19a2390a6bba4aa80d1ac3b6c5385527cc311/src/Cli/Microsoft.DotNet.Cli.Utils/Sha256Hasher.cs + workaround for netstandard2.0\n+#if NET || NETSTANDARD2_0_OR_GREATER\n+        private static class Sha256Hasher\n+        {\n+            /// <summary>\n+            /// The hashed mac address needs to be the same hashed value as produced by the other distinct sources given the same input. (e.g. VsCode)\n+            /// </summary>\n+            public static string Hash(string text)\n+            {\n+                byte[] bytes = Encoding.UTF8.GetBytes(text);\n+#if NET\n+                byte[] hash = SHA256.HashData(bytes);\n+#if NET9_0_OR_GREATER\n+                return Convert.ToHexStringLower(hash);\n+#else\n+            return Convert.ToHexString(hash).ToLowerInvariant();\n+#endif\n+\n+#else\n+            // Create the SHA256 object and compute the hash\n+            using (var sha256 = SHA256.Create())",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Context: This code only runs when customers hook their own telemetry in core.\r\n\r\nThe aim was so the hash matches the one produced by sdk which would only be helpful if internal people collected it and looked at the sdk data table. If sdk changed then it'd need to be changed manually, which is concerning. I don't see how we could depend on their hasher implementation, that would create a circular dependency, no? (And also it's not completely the same, since I made a netstandard2.0 conditionally compiled version based on it which is not in sdk).\r\n\r\nAn option is to omit implementing this logic and make it a problem of the people hooking their telemetry processor/exporter.\r\n\r\nAnother option is to make a \"MSBuild hasher\" that does not aim to be the same as sdk, but why not start with the one in sdk.\r\n\r\nAfter trying to use ConversionUtilities, it would require moving a lot of internal stuff to framework which I don't know if is worth it or if there are any concerning implications.",
              "createdAt": "2025-01-13T11:50:43Z",
              "path": "src/Framework/Telemetry/ActivityExtensions.cs",
              "diffHunk": "@@ -0,0 +1,110 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;   // for Microsoft.VisualStudio.OpenTelemetry.ClientExtensions\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+#else\n+using System.Security.Cryptography;\n+using System.Text;\n+#endif\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    internal static class ActivityExtensions\n+    {\n+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder dataHolder)\n+        {\n+            activity.WithTags(dataHolder.GetActivityProperties());\n+            return activity;\n+        }\n+\n+        public static Activity WithTags(this Activity activity, IList<TelemetryItem> tags)\n+        {\n+            foreach (var tag in tags)\n+            {\n+                activity.WithTag(tag);\n+            }\n+            return activity;\n+        }\n+\n+        public static Activity WithTag(this Activity activity, TelemetryItem item)\n+        {\n+            object value = item.Hashed ? GetHashed(item.Value) : item.Value;\n+            activity.SetTag($\"{TelemetryConstants.PropertyPrefix}{item.Name}\", value);\n+            return activity;\n+        }\n+\n+        public static Activity WithStartTime(this Activity activity, DateTime? startTime)\n+        {\n+            if (startTime.HasValue)\n+            {\n+                activity.SetStartTime(startTime.Value);\n+            }\n+            return activity;\n+        }\n+\n+        private static object GetHashed(object value)\n+        {\n+#if NETFRAMEWORK\n+                        return new clientext::Microsoft.VisualStudio.Telemetry.TelemetryHashedProperty(value);\n+#else\n+            return Sha256Hasher.Hash(value.ToString() ?? \"\");\n+#endif\n+        }\n+\n+        // https://github.com/dotnet/sdk/blob/8bd19a2390a6bba4aa80d1ac3b6c5385527cc311/src/Cli/Microsoft.DotNet.Cli.Utils/Sha256Hasher.cs + workaround for netstandard2.0\n+#if NET || NETSTANDARD2_0_OR_GREATER\n+        private static class Sha256Hasher\n+        {\n+            /// <summary>\n+            /// The hashed mac address needs to be the same hashed value as produced by the other distinct sources given the same input. (e.g. VsCode)\n+            /// </summary>\n+            public static string Hash(string text)\n+            {\n+                byte[] bytes = Encoding.UTF8.GetBytes(text);\n+#if NET\n+                byte[] hash = SHA256.HashData(bytes);\n+#if NET9_0_OR_GREATER\n+                return Convert.ToHexStringLower(hash);\n+#else\n+            return Convert.ToHexString(hash).ToLowerInvariant();\n+#endif\n+\n+#else\n+            // Create the SHA256 object and compute the hash\n+            using (var sha256 = SHA256.Create())",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: formatting",
              "createdAt": "2025-01-13T09:39:10Z",
              "path": "src/Framework/Telemetry/ActivityExtensions.cs",
              "diffHunk": "@@ -0,0 +1,110 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;   // for Microsoft.VisualStudio.OpenTelemetry.ClientExtensions\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+#else\n+using System.Security.Cryptography;\n+using System.Text;\n+#endif\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    internal static class ActivityExtensions\n+    {\n+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder dataHolder)\n+        {\n+            activity.WithTags(dataHolder.GetActivityProperties());\n+            return activity;\n+        }\n+\n+        public static Activity WithTags(this Activity activity, IList<TelemetryItem> tags)\n+        {\n+            foreach (var tag in tags)\n+            {\n+                activity.WithTag(tag);\n+            }\n+            return activity;\n+        }\n+\n+        public static Activity WithTag(this Activity activity, TelemetryItem item)\n+        {\n+            object value = item.Hashed ? GetHashed(item.Value) : item.Value;\n+            activity.SetTag($\"{TelemetryConstants.PropertyPrefix}{item.Name}\", value);\n+            return activity;\n+        }\n+\n+        public static Activity WithStartTime(this Activity activity, DateTime? startTime)\n+        {\n+            if (startTime.HasValue)\n+            {\n+                activity.SetStartTime(startTime.Value);\n+            }\n+            return activity;\n+        }\n+\n+        private static object GetHashed(object value)\n+        {\n+#if NETFRAMEWORK\n+                        return new clientext::Microsoft.VisualStudio.Telemetry.TelemetryHashedProperty(value);",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`IsEnvVarTrue(TelemetryConstants.TelemetryFxOptoutEnvVarName) || IsEnvVarTrue(TelemetryConstants.DotnetOptOut)`\r\n?",
              "createdAt": "2025-01-13T09:43:02Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,265 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// State of the telemetry infrastructure.\n+    /// </summary>\n+    internal enum TelemetryState\n+    {\n+        /// <summary>\n+        /// Initial state.\n+        /// </summary>\n+        Uninitialized,\n+\n+        /// <summary>\n+        /// Opt out of telemetry.\n+        /// </summary>\n+        OptOut,\n+\n+        /// <summary>\n+        /// Run not sampled for telemetry.\n+        /// </summary>\n+        Unsampled,\n+\n+        /// <summary>\n+        /// For core hook, ActivitySource is created.\n+        /// </summary>\n+        TracerInitialized,\n+\n+        /// <summary>\n+        /// For VS scenario with a collector. ActivitySource, OTel TracerProvider are created.\n+        /// </summary>\n+        ExporterInitialized,\n+\n+        /// <summary>\n+        /// For standalone, ActivitySource, OTel TracerProvider, VS OpenTelemetry Collector are created.\n+        /// </summary>\n+        CollectorInitialized,\n+\n+        /// <summary>\n+        /// End state.\n+        /// </summary>\n+        Disposed\n+    }\n+\n+    /// <summary>\n+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,\n+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.\n+    /// </summary>\n+    internal class OpenTelemetryManager\n+    {\n+        // Lazy<T> provides thread-safe lazy initialization.\n+        private static readonly Lazy<OpenTelemetryManager> s_instance =\n+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);\n+\n+        /// <summary>\n+        /// Globally accessible instance of <see cref=\"OpenTelemetryManager\"/>.\n+        /// </summary>\n+        public static OpenTelemetryManager Instance => s_instance.Value;\n+\n+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;\n+        private readonly object _initializeLock = new();\n+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;\n+\n+#if NETFRAMEWORK\n+        private TracerProvider? _tracerProvider;\n+        private IOpenTelemetryCollector? _collector;\n+#endif\n+\n+        /// <summary>\n+        /// Optional activity source for MSBuild or other telemetry usage.\n+        /// </summary>\n+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }\n+\n+        private OpenTelemetryManager()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.\n+        /// </summary>\n+        /// <param name=\"isStandalone\">Differentiates between executing as MSBuild.exe or from VS/API.</param>\n+        public void Initialize(bool isStandalone)\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (_telemetryState != TelemetryState.Uninitialized)\n+                {\n+                    return;\n+                }\n+\n+                if (IsOptOut())\n+                {\n+                    _telemetryState = TelemetryState.OptOut;\n+                    return;\n+                }\n+\n+                if (!IsSampled())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                DefaultActivitySource = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace);\n+\n+#if NETFRAMEWORK\n+                InitializeTracerProvider();\n+                // TODO: Enable commented logic when Collector is present in VS\n+                // if (isStandalone)\n+                InitializeCollector();\n+\n+                // }\n+#endif\n+            }\n+        }\n+\n+#if NETFRAMEWORK\n+        /// <summary>\n+        /// Initializes the OpenTelemetry SDK TracerProvider with VS default exporter settings.\n+        /// </summary>\n+        private void InitializeTracerProvider()\n+        {\n+            var exporterSettings = OpenTelemetryExporterSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            TracerProviderBuilder tracerProviderBuilder = Sdk\n+                .CreateTracerProviderBuilder()\n+                // register all ActivitySources that should be listened to\n+                .AddSource(TelemetryConstants.DefaultActivitySourceNamespace)\n+                .AddVisualStudioDefaultTraceExporter(exporterSettings);\n+\n+            _tracerProvider = tracerProviderBuilder.Build();\n+            _telemetryState = TelemetryState.ExporterInitialized;\n+        }\n+\n+        /// <summary>\n+        /// Initializes the VS OpenTelemetry Collector with VS default settings.\n+        /// </summary>\n+        private void InitializeCollector()\n+        {\n+            IOpenTelemetryCollectorSettings collectorSettings = OpenTelemetryCollectorSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            _collector = OpenTelemetryCollectorProvider.CreateCollector(collectorSettings);\n+            _collector.StartAsync();\n+\n+            _telemetryState = TelemetryState.CollectorInitialized;\n+        }\n+#endif\n+        /// <summary>\n+        /// Flush the telemetry in TracerProvider/Exporter.\n+        /// </summary>\n+        public void ForceFlush()\n+        {\n+#if NETFRAMEWORK\n+            _tracerProvider?.ForceFlush();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Shuts down the telemetry infrastructure.\n+        /// </summary>\n+        public void Shutdown()\n+        {\n+            lock (_initializeLock)\n+            {\n+#if NETFRAMEWORK\n+                _tracerProvider?.Shutdown();\n+                _collector?.Dispose();\n+#endif\n+                _telemetryState = TelemetryState.Disposed;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Determines if the user has explicitly opted out of telemetry.\n+        /// </summary>\n+        private bool IsOptOut()\n+        {\n+            if (IsEnvVarTrue(TelemetryConstants.TelemetryFxOptoutEnvVarName))",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "can it be used here?\r\nhttps://github.com/dotnet/msbuild/blob/bfa266d7c91ead845ce90b80f639a384abc38793/src/Shared/ConversionUtilities.cs#L141",
              "createdAt": "2025-01-13T09:46:12Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,265 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// State of the telemetry infrastructure.\n+    /// </summary>\n+    internal enum TelemetryState\n+    {\n+        /// <summary>\n+        /// Initial state.\n+        /// </summary>\n+        Uninitialized,\n+\n+        /// <summary>\n+        /// Opt out of telemetry.\n+        /// </summary>\n+        OptOut,\n+\n+        /// <summary>\n+        /// Run not sampled for telemetry.\n+        /// </summary>\n+        Unsampled,\n+\n+        /// <summary>\n+        /// For core hook, ActivitySource is created.\n+        /// </summary>\n+        TracerInitialized,\n+\n+        /// <summary>\n+        /// For VS scenario with a collector. ActivitySource, OTel TracerProvider are created.\n+        /// </summary>\n+        ExporterInitialized,\n+\n+        /// <summary>\n+        /// For standalone, ActivitySource, OTel TracerProvider, VS OpenTelemetry Collector are created.\n+        /// </summary>\n+        CollectorInitialized,\n+\n+        /// <summary>\n+        /// End state.\n+        /// </summary>\n+        Disposed\n+    }\n+\n+    /// <summary>\n+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,\n+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.\n+    /// </summary>\n+    internal class OpenTelemetryManager\n+    {\n+        // Lazy<T> provides thread-safe lazy initialization.\n+        private static readonly Lazy<OpenTelemetryManager> s_instance =\n+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);\n+\n+        /// <summary>\n+        /// Globally accessible instance of <see cref=\"OpenTelemetryManager\"/>.\n+        /// </summary>\n+        public static OpenTelemetryManager Instance => s_instance.Value;\n+\n+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;\n+        private readonly object _initializeLock = new();\n+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;\n+\n+#if NETFRAMEWORK\n+        private TracerProvider? _tracerProvider;\n+        private IOpenTelemetryCollector? _collector;\n+#endif\n+\n+        /// <summary>\n+        /// Optional activity source for MSBuild or other telemetry usage.\n+        /// </summary>\n+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }\n+\n+        private OpenTelemetryManager()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.\n+        /// </summary>\n+        /// <param name=\"isStandalone\">Differentiates between executing as MSBuild.exe or from VS/API.</param>\n+        public void Initialize(bool isStandalone)\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (_telemetryState != TelemetryState.Uninitialized)\n+                {\n+                    return;\n+                }\n+\n+                if (IsOptOut())\n+                {\n+                    _telemetryState = TelemetryState.OptOut;\n+                    return;\n+                }\n+\n+                if (!IsSampled())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                DefaultActivitySource = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace);\n+\n+#if NETFRAMEWORK\n+                InitializeTracerProvider();\n+                // TODO: Enable commented logic when Collector is present in VS\n+                // if (isStandalone)\n+                InitializeCollector();\n+\n+                // }\n+#endif\n+            }\n+        }\n+\n+#if NETFRAMEWORK\n+        /// <summary>\n+        /// Initializes the OpenTelemetry SDK TracerProvider with VS default exporter settings.\n+        /// </summary>\n+        private void InitializeTracerProvider()\n+        {\n+            var exporterSettings = OpenTelemetryExporterSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            TracerProviderBuilder tracerProviderBuilder = Sdk\n+                .CreateTracerProviderBuilder()\n+                // register all ActivitySources that should be listened to\n+                .AddSource(TelemetryConstants.DefaultActivitySourceNamespace)\n+                .AddVisualStudioDefaultTraceExporter(exporterSettings);\n+\n+            _tracerProvider = tracerProviderBuilder.Build();\n+            _telemetryState = TelemetryState.ExporterInitialized;\n+        }\n+\n+        /// <summary>\n+        /// Initializes the VS OpenTelemetry Collector with VS default settings.\n+        /// </summary>\n+        private void InitializeCollector()\n+        {\n+            IOpenTelemetryCollectorSettings collectorSettings = OpenTelemetryCollectorSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            _collector = OpenTelemetryCollectorProvider.CreateCollector(collectorSettings);\n+            _collector.StartAsync();\n+\n+            _telemetryState = TelemetryState.CollectorInitialized;\n+        }\n+#endif\n+        /// <summary>\n+        /// Flush the telemetry in TracerProvider/Exporter.\n+        /// </summary>\n+        public void ForceFlush()\n+        {\n+#if NETFRAMEWORK\n+            _tracerProvider?.ForceFlush();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Shuts down the telemetry infrastructure.\n+        /// </summary>\n+        public void Shutdown()\n+        {\n+            lock (_initializeLock)\n+            {\n+#if NETFRAMEWORK\n+                _tracerProvider?.Shutdown();\n+                _collector?.Dispose();\n+#endif\n+                _telemetryState = TelemetryState.Disposed;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Determines if the user has explicitly opted out of telemetry.\n+        /// </summary>\n+        private bool IsOptOut()\n+        {\n+            if (IsEnvVarTrue(TelemetryConstants.TelemetryFxOptoutEnvVarName))\n+            {\n+                return true;\n+            }\n+\n+            if (IsEnvVarTrue(TelemetryConstants.DotnetOptOut))\n+            {\n+                return true;\n+            }\n+\n+            /* VS OTel manages opt outs by not sending data. */\n+\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Determines if telemetry should be initialized based on sampling and environment variable overrides.\n+        /// </summary>\n+        private bool IsSampled()\n+        {\n+            double? overrideRate = ReadDoubleEnvVar(TelemetryConstants.TelemetrySampleRateOverrideEnvVarName);\n+            if (overrideRate.HasValue)\n+            {\n+                _sampleRate = overrideRate.Value;\n+            }\n+            else\n+            {\n+#if !NETFRAMEWORK\n+                // In core, OTel infrastructure is not initialized by default.\n+                return false;\n+#endif\n+            }\n+\n+            // Simple random sampling, this method is called \n+            Random random = new();\n+            return random.NextDouble() < _sampleRate;\n+        }\n+\n+        /// <summary>\n+        /// Parses a double environment variable, if present.\n+        /// </summary>\n+        private double? ReadDoubleEnvVar(string name)\n+        {\n+            string? sampleRateString =\n+                Environment.GetEnvironmentVariable(name);\n+\n+            if (double.TryParse(sampleRateString, out double result))",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "It's not visible in microsoft.build.framework. Should I try to move it somewhere where it is?",
              "createdAt": "2025-01-13T10:14:13Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,265 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// State of the telemetry infrastructure.\n+    /// </summary>\n+    internal enum TelemetryState\n+    {\n+        /// <summary>\n+        /// Initial state.\n+        /// </summary>\n+        Uninitialized,\n+\n+        /// <summary>\n+        /// Opt out of telemetry.\n+        /// </summary>\n+        OptOut,\n+\n+        /// <summary>\n+        /// Run not sampled for telemetry.\n+        /// </summary>\n+        Unsampled,\n+\n+        /// <summary>\n+        /// For core hook, ActivitySource is created.\n+        /// </summary>\n+        TracerInitialized,\n+\n+        /// <summary>\n+        /// For VS scenario with a collector. ActivitySource, OTel TracerProvider are created.\n+        /// </summary>\n+        ExporterInitialized,\n+\n+        /// <summary>\n+        /// For standalone, ActivitySource, OTel TracerProvider, VS OpenTelemetry Collector are created.\n+        /// </summary>\n+        CollectorInitialized,\n+\n+        /// <summary>\n+        /// End state.\n+        /// </summary>\n+        Disposed\n+    }\n+\n+    /// <summary>\n+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,\n+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.\n+    /// </summary>\n+    internal class OpenTelemetryManager\n+    {\n+        // Lazy<T> provides thread-safe lazy initialization.\n+        private static readonly Lazy<OpenTelemetryManager> s_instance =\n+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);\n+\n+        /// <summary>\n+        /// Globally accessible instance of <see cref=\"OpenTelemetryManager\"/>.\n+        /// </summary>\n+        public static OpenTelemetryManager Instance => s_instance.Value;\n+\n+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;\n+        private readonly object _initializeLock = new();\n+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;\n+\n+#if NETFRAMEWORK\n+        private TracerProvider? _tracerProvider;\n+        private IOpenTelemetryCollector? _collector;\n+#endif\n+\n+        /// <summary>\n+        /// Optional activity source for MSBuild or other telemetry usage.\n+        /// </summary>\n+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }\n+\n+        private OpenTelemetryManager()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.\n+        /// </summary>\n+        /// <param name=\"isStandalone\">Differentiates between executing as MSBuild.exe or from VS/API.</param>\n+        public void Initialize(bool isStandalone)\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (_telemetryState != TelemetryState.Uninitialized)\n+                {\n+                    return;\n+                }\n+\n+                if (IsOptOut())\n+                {\n+                    _telemetryState = TelemetryState.OptOut;\n+                    return;\n+                }\n+\n+                if (!IsSampled())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                DefaultActivitySource = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace);\n+\n+#if NETFRAMEWORK\n+                InitializeTracerProvider();\n+                // TODO: Enable commented logic when Collector is present in VS\n+                // if (isStandalone)\n+                InitializeCollector();\n+\n+                // }\n+#endif\n+            }\n+        }\n+\n+#if NETFRAMEWORK\n+        /// <summary>\n+        /// Initializes the OpenTelemetry SDK TracerProvider with VS default exporter settings.\n+        /// </summary>\n+        private void InitializeTracerProvider()\n+        {\n+            var exporterSettings = OpenTelemetryExporterSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            TracerProviderBuilder tracerProviderBuilder = Sdk\n+                .CreateTracerProviderBuilder()\n+                // register all ActivitySources that should be listened to\n+                .AddSource(TelemetryConstants.DefaultActivitySourceNamespace)\n+                .AddVisualStudioDefaultTraceExporter(exporterSettings);\n+\n+            _tracerProvider = tracerProviderBuilder.Build();\n+            _telemetryState = TelemetryState.ExporterInitialized;\n+        }\n+\n+        /// <summary>\n+        /// Initializes the VS OpenTelemetry Collector with VS default settings.\n+        /// </summary>\n+        private void InitializeCollector()\n+        {\n+            IOpenTelemetryCollectorSettings collectorSettings = OpenTelemetryCollectorSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            _collector = OpenTelemetryCollectorProvider.CreateCollector(collectorSettings);\n+            _collector.StartAsync();\n+\n+            _telemetryState = TelemetryState.CollectorInitialized;\n+        }\n+#endif\n+        /// <summary>\n+        /// Flush the telemetry in TracerProvider/Exporter.\n+        /// </summary>\n+        public void ForceFlush()\n+        {\n+#if NETFRAMEWORK\n+            _tracerProvider?.ForceFlush();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Shuts down the telemetry infrastructure.\n+        /// </summary>\n+        public void Shutdown()\n+        {\n+            lock (_initializeLock)\n+            {\n+#if NETFRAMEWORK\n+                _tracerProvider?.Shutdown();\n+                _collector?.Dispose();\n+#endif\n+                _telemetryState = TelemetryState.Disposed;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Determines if the user has explicitly opted out of telemetry.\n+        /// </summary>\n+        private bool IsOptOut()\n+        {\n+            if (IsEnvVarTrue(TelemetryConstants.TelemetryFxOptoutEnvVarName))\n+            {\n+                return true;\n+            }\n+\n+            if (IsEnvVarTrue(TelemetryConstants.DotnetOptOut))\n+            {\n+                return true;\n+            }\n+\n+            /* VS OTel manages opt outs by not sending data. */\n+\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Determines if telemetry should be initialized based on sampling and environment variable overrides.\n+        /// </summary>\n+        private bool IsSampled()\n+        {\n+            double? overrideRate = ReadDoubleEnvVar(TelemetryConstants.TelemetrySampleRateOverrideEnvVarName);\n+            if (overrideRate.HasValue)\n+            {\n+                _sampleRate = overrideRate.Value;\n+            }\n+            else\n+            {\n+#if !NETFRAMEWORK\n+                // In core, OTel infrastructure is not initialized by default.\n+                return false;\n+#endif\n+            }\n+\n+            // Simple random sampling, this method is called \n+            Random random = new();\n+            return random.NextDouble() < _sampleRate;\n+        }\n+\n+        /// <summary>\n+        /// Parses a double environment variable, if present.\n+        /// </summary>\n+        private double? ReadDoubleEnvVar(string name)\n+        {\n+            string? sampleRateString =\n+                Environment.GetEnvironmentVariable(name);\n+\n+            if (double.TryParse(sampleRateString, out double result))",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "only if it doesn't take too much time",
              "createdAt": "2025-01-13T10:20:46Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,265 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// State of the telemetry infrastructure.\n+    /// </summary>\n+    internal enum TelemetryState\n+    {\n+        /// <summary>\n+        /// Initial state.\n+        /// </summary>\n+        Uninitialized,\n+\n+        /// <summary>\n+        /// Opt out of telemetry.\n+        /// </summary>\n+        OptOut,\n+\n+        /// <summary>\n+        /// Run not sampled for telemetry.\n+        /// </summary>\n+        Unsampled,\n+\n+        /// <summary>\n+        /// For core hook, ActivitySource is created.\n+        /// </summary>\n+        TracerInitialized,\n+\n+        /// <summary>\n+        /// For VS scenario with a collector. ActivitySource, OTel TracerProvider are created.\n+        /// </summary>\n+        ExporterInitialized,\n+\n+        /// <summary>\n+        /// For standalone, ActivitySource, OTel TracerProvider, VS OpenTelemetry Collector are created.\n+        /// </summary>\n+        CollectorInitialized,\n+\n+        /// <summary>\n+        /// End state.\n+        /// </summary>\n+        Disposed\n+    }\n+\n+    /// <summary>\n+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,\n+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.\n+    /// </summary>\n+    internal class OpenTelemetryManager\n+    {\n+        // Lazy<T> provides thread-safe lazy initialization.\n+        private static readonly Lazy<OpenTelemetryManager> s_instance =\n+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);\n+\n+        /// <summary>\n+        /// Globally accessible instance of <see cref=\"OpenTelemetryManager\"/>.\n+        /// </summary>\n+        public static OpenTelemetryManager Instance => s_instance.Value;\n+\n+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;\n+        private readonly object _initializeLock = new();\n+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;\n+\n+#if NETFRAMEWORK\n+        private TracerProvider? _tracerProvider;\n+        private IOpenTelemetryCollector? _collector;\n+#endif\n+\n+        /// <summary>\n+        /// Optional activity source for MSBuild or other telemetry usage.\n+        /// </summary>\n+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }\n+\n+        private OpenTelemetryManager()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.\n+        /// </summary>\n+        /// <param name=\"isStandalone\">Differentiates between executing as MSBuild.exe or from VS/API.</param>\n+        public void Initialize(bool isStandalone)\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (_telemetryState != TelemetryState.Uninitialized)\n+                {\n+                    return;\n+                }\n+\n+                if (IsOptOut())\n+                {\n+                    _telemetryState = TelemetryState.OptOut;\n+                    return;\n+                }\n+\n+                if (!IsSampled())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                DefaultActivitySource = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace);\n+\n+#if NETFRAMEWORK\n+                InitializeTracerProvider();\n+                // TODO: Enable commented logic when Collector is present in VS\n+                // if (isStandalone)\n+                InitializeCollector();\n+\n+                // }\n+#endif\n+            }\n+        }\n+\n+#if NETFRAMEWORK\n+        /// <summary>\n+        /// Initializes the OpenTelemetry SDK TracerProvider with VS default exporter settings.\n+        /// </summary>\n+        private void InitializeTracerProvider()\n+        {\n+            var exporterSettings = OpenTelemetryExporterSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            TracerProviderBuilder tracerProviderBuilder = Sdk\n+                .CreateTracerProviderBuilder()\n+                // register all ActivitySources that should be listened to\n+                .AddSource(TelemetryConstants.DefaultActivitySourceNamespace)\n+                .AddVisualStudioDefaultTraceExporter(exporterSettings);\n+\n+            _tracerProvider = tracerProviderBuilder.Build();\n+            _telemetryState = TelemetryState.ExporterInitialized;\n+        }\n+\n+        /// <summary>\n+        /// Initializes the VS OpenTelemetry Collector with VS default settings.\n+        /// </summary>\n+        private void InitializeCollector()\n+        {\n+            IOpenTelemetryCollectorSettings collectorSettings = OpenTelemetryCollectorSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            _collector = OpenTelemetryCollectorProvider.CreateCollector(collectorSettings);\n+            _collector.StartAsync();\n+\n+            _telemetryState = TelemetryState.CollectorInitialized;\n+        }\n+#endif\n+        /// <summary>\n+        /// Flush the telemetry in TracerProvider/Exporter.\n+        /// </summary>\n+        public void ForceFlush()\n+        {\n+#if NETFRAMEWORK\n+            _tracerProvider?.ForceFlush();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Shuts down the telemetry infrastructure.\n+        /// </summary>\n+        public void Shutdown()\n+        {\n+            lock (_initializeLock)\n+            {\n+#if NETFRAMEWORK\n+                _tracerProvider?.Shutdown();\n+                _collector?.Dispose();\n+#endif\n+                _telemetryState = TelemetryState.Disposed;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Determines if the user has explicitly opted out of telemetry.\n+        /// </summary>\n+        private bool IsOptOut()\n+        {\n+            if (IsEnvVarTrue(TelemetryConstants.TelemetryFxOptoutEnvVarName))\n+            {\n+                return true;\n+            }\n+\n+            if (IsEnvVarTrue(TelemetryConstants.DotnetOptOut))\n+            {\n+                return true;\n+            }\n+\n+            /* VS OTel manages opt outs by not sending data. */\n+\n+            return false;\n+        }\n+\n+        /// <summary>\n+        /// Determines if telemetry should be initialized based on sampling and environment variable overrides.\n+        /// </summary>\n+        private bool IsSampled()\n+        {\n+            double? overrideRate = ReadDoubleEnvVar(TelemetryConstants.TelemetrySampleRateOverrideEnvVarName);\n+            if (overrideRate.HasValue)\n+            {\n+                _sampleRate = overrideRate.Value;\n+            }\n+            else\n+            {\n+#if !NETFRAMEWORK\n+                // In core, OTel infrastructure is not initialized by default.\n+                return false;\n+#endif\n+            }\n+\n+            // Simple random sampling, this method is called \n+            Random random = new();\n+            return random.NextDouble() < _sampleRate;\n+        }\n+\n+        /// <summary>\n+        /// Parses a double environment variable, if present.\n+        /// </summary>\n+        private double? ReadDoubleEnvVar(string name)\n+        {\n+            string? sampleRateString =\n+                Environment.GetEnvironmentVariable(name);\n+\n+            if (double.TryParse(sampleRateString, out double result))",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "should we track this field somewhere if the docs to stay up to date?",
              "createdAt": "2025-01-13T09:56:04Z",
              "path": "src/Framework/Telemetry/TelemetryConstants.cs",
              "diffHunk": "@@ -0,0 +1,57 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+namespace Microsoft.Build.Framework.Telemetry;\n+\n+/// <summary>\n+/// Constants for VS OpenTelemetry for basic configuration and appropriate naming for VS exporting/collection.\n+/// </summary>\n+internal static class TelemetryConstants\n+{\n+    /// <summary>\n+    /// \"Microsoft.VisualStudio.OpenTelemetry.*\" namespace is required by VS exporting/collection.\n+    /// </summary>\n+    public const string ActivitySourceNamespacePrefix = \"Microsoft.VisualStudio.OpenTelemetry.MSBuild.\";\n+\n+    /// <summary>\n+    /// Namespace of the default ActivitySource handling e.g. End of build telemetry.\n+    /// </summary>\n+    public const string DefaultActivitySourceNamespace = $\"{ActivitySourceNamespacePrefix}Default\";\n+\n+    /// <summary>\n+    /// Prefix required by VS exporting/collection.\n+    /// </summary>\n+    public const string EventPrefix = \"VS/MSBuild/\";\n+\n+    /// <summary>\n+    /// Prefix required by VS exporting/collection.\n+    /// </summary>\n+    public const string PropertyPrefix = \"VS.MSBuild.\";\n+\n+    /// <summary>\n+    /// For VS OpenTelemetry Collector to apply the correct privacy policy.\n+    /// </summary>\n+    public const string VSMajorVersion = \"17.0\";",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "unused ref",
              "createdAt": "2025-01-13T10:04:11Z",
              "path": "src/Framework/Telemetry/MSBuildActivitySource.cs",
              "diffHunk": "@@ -0,0 +1,35 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using System.Runtime.CompilerServices;",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: formatting",
              "createdAt": "2025-01-13T10:04:28Z",
              "path": "src/Framework/Telemetry/MSBuildActivitySource.cs",
              "diffHunk": "@@ -0,0 +1,35 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: formatting",
              "createdAt": "2025-01-13T10:05:57Z",
              "path": "src/Framework/Telemetry/ActivityExtensions.cs",
              "diffHunk": "@@ -0,0 +1,110 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;   // for Microsoft.VisualStudio.OpenTelemetry.ClientExtensions\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+#else\n+using System.Security.Cryptography;\n+using System.Text;\n+#endif\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using System.Runtime.CompilerServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "unused ref",
              "createdAt": "2025-01-13T10:07:21Z",
              "path": "src/Framework/Telemetry/IActivityTelemetryDataHolder.cs",
              "diffHunk": "@@ -0,0 +1,16 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I see it was previously bumped with the bunch of other packages\r\nhttps://github.com/dotnet/msbuild/commit/352c48c0217a664f9190272ff69163f7295bded4#diff-af84f50fd5aa2e8bfc3479cb6ddf7882bc084ce1af01de6dd49ff93aa2d1718cR111\r\n\r\n@rainersigwald , could you please confirm if it's safe to do it only for Microsoft.Bcl.AsyncInterfaces?",
              "createdAt": "2025-01-13T10:14:31Z",
              "path": "src/MSBuild/app.config",
              "diffHunk": "@@ -33,7 +33,7 @@\n         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->\n         <dependentAssembly>\n           <assemblyIdentity name=\"Microsoft.Bcl.AsyncInterfaces\" publicKeyToken=\"cc7b13ffcd2ddd51\" culture=\"neutral\" />\n-          <bindingRedirect oldVersion=\"0.0.0.0-8.0.0.0\" newVersion=\"8.0.0.0\" />\n+          <bindingRedirect oldVersion=\"0.0.0.0-9.0.0.0\" newVersion=\"9.0.0.0\" />",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "What package needs this? (similarly for M.E.Primitives and M.E.Configuration.Binder)",
              "createdAt": "2025-01-13T18:33:40Z",
              "path": "src/MSBuild/app.config",
              "diffHunk": "@@ -33,7 +33,7 @@\n         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->\n         <dependentAssembly>\n           <assemblyIdentity name=\"Microsoft.Bcl.AsyncInterfaces\" publicKeyToken=\"cc7b13ffcd2ddd51\" culture=\"neutral\" />\n-          <bindingRedirect oldVersion=\"0.0.0.0-8.0.0.0\" newVersion=\"8.0.0.0\" />\n+          <bindingRedirect oldVersion=\"0.0.0.0-9.0.0.0\" newVersion=\"9.0.0.0\" />",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "OpenTelemetry 1.10.0 I think, I will test in the WIP branch if I can downgrade to 1.9.0. But I don't see why not take 9.0 e.g. https://github.com/dotnet/msbuild/pull/9535 upgraded them in ~December 2023 after .net 8 release",
              "createdAt": "2025-01-13T19:43:29Z",
              "path": "src/MSBuild/app.config",
              "diffHunk": "@@ -33,7 +33,7 @@\n         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->\n         <dependentAssembly>\n           <assemblyIdentity name=\"Microsoft.Bcl.AsyncInterfaces\" publicKeyToken=\"cc7b13ffcd2ddd51\" culture=\"neutral\" />\n-          <bindingRedirect oldVersion=\"0.0.0.0-8.0.0.0\" newVersion=\"8.0.0.0\" />\n+          <bindingRedirect oldVersion=\"0.0.0.0-9.0.0.0\" newVersion=\"9.0.0.0\" />",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Yeah we'll have to sync these with VS, so this'll be blocked on https://github.com/dotnet/msbuild/pull/11145",
              "createdAt": "2025-01-13T20:04:50Z",
              "path": "src/MSBuild/app.config",
              "diffHunk": "@@ -33,7 +33,7 @@\n         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->\n         <dependentAssembly>\n           <assemblyIdentity name=\"Microsoft.Bcl.AsyncInterfaces\" publicKeyToken=\"cc7b13ffcd2ddd51\" culture=\"neutral\" />\n-          <bindingRedirect oldVersion=\"0.0.0.0-8.0.0.0\" newVersion=\"8.0.0.0\" />\n+          <bindingRedirect oldVersion=\"0.0.0.0-9.0.0.0\" newVersion=\"9.0.0.0\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "downgraded",
              "createdAt": "2025-01-14T16:22:32Z",
              "path": "src/MSBuild/app.config",
              "diffHunk": "@@ -33,7 +33,7 @@\n         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->\n         <dependentAssembly>\n           <assemblyIdentity name=\"Microsoft.Bcl.AsyncInterfaces\" publicKeyToken=\"cc7b13ffcd2ddd51\" culture=\"neutral\" />\n-          <bindingRedirect oldVersion=\"0.0.0.0-8.0.0.0\" newVersion=\"8.0.0.0\" />\n+          <bindingRedirect oldVersion=\"0.0.0.0-9.0.0.0\" newVersion=\"9.0.0.0\" />",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "is it a temporary thing?\r\nI recall we had some limitations for using this feed in msbuild repo",
              "createdAt": "2025-01-13T10:17:26Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -13,6 +13,14 @@\n     <add key=\"dotnet8\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json\" />\n     <add key=\"dotnet8-transport\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json\" />\n     <add key=\"dotnet9\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json\" />\n+    <add key=\"vs-impl\" value=\"https://pkgs.dev.azure.com/azure-public/vside/_packaging/vs-impl/nuget/v3/index.json\" />",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "It's intended to be permanent. Under it, there is a restriction that this feed can pull only VS OpenTelemetry packages. (and it won't pull them outside Framework because they're conditionally included in Microsoft.Build.Framework.csproj",
              "createdAt": "2025-01-13T10:17:50Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -13,6 +13,14 @@\n     <add key=\"dotnet8\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json\" />\n     <add key=\"dotnet8-transport\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json\" />\n     <add key=\"dotnet9\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json\" />\n+    <add key=\"vs-impl\" value=\"https://pkgs.dev.azure.com/azure-public/vside/_packaging/vs-impl/nuget/v3/index.json\" />",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "@rainersigwald to draw your attention here",
              "createdAt": "2025-01-13T10:21:20Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -13,6 +13,14 @@\n     <add key=\"dotnet8\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json\" />\n     <add key=\"dotnet8-transport\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json\" />\n     <add key=\"dotnet9\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json\" />\n+    <add key=\"vs-impl\" value=\"https://pkgs.dev.azure.com/azure-public/vside/_packaging/vs-impl/nuget/v3/index.json\" />",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "The PSM configuration doesn't exactly say that: it says that `Microsoft.VisualStudio.OpenTelemetry*` must come from `vs-impl`, not that `vs-impl` can only be used for that package.\r\n\r\nWe need to be careful here--have you talked to the VMR/sourcebuild folks about the dependency?",
              "createdAt": "2025-01-13T19:26:15Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -13,6 +13,14 @@\n     <add key=\"dotnet8\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json\" />\n     <add key=\"dotnet8-transport\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json\" />\n     <add key=\"dotnet9\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json\" />\n+    <add key=\"vs-impl\" value=\"https://pkgs.dev.azure.com/azure-public/vside/_packaging/vs-impl/nuget/v3/index.json\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "> The PSM configuration doesn't exactly say that: it says that Microsoft.VisualStudio.OpenTelemetry* must come from vs-impl, not that vs-impl can only be used for that package.\r\n\r\nThanks, I misunderstood that. Is it possible to do? From a quick look at docs I guess no \u2639\ufe0f \r\n\r\nWe're in contact and it does not impact sourcebuild, because it's references are gated only for .NET Framework in Microsoft.Build.Framework.csproj, and .NET Framework dependencies are not a part of sourcebuild.\r\n\r\nThere is no way to condition on that in NuGet.config though.",
              "createdAt": "2025-01-13T19:50:36Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -13,6 +13,14 @@\n     <add key=\"dotnet8\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json\" />\n     <add key=\"dotnet8-transport\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json\" />\n     <add key=\"dotnet9\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json\" />\n+    <add key=\"vs-impl\" value=\"https://pkgs.dev.azure.com/azure-public/vside/_packaging/vs-impl/nuget/v3/index.json\" />",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "~~It's in dotnet-tools feed, removed vs-impl.~~ cache trolled me",
              "createdAt": "2025-01-22T13:00:33Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -13,6 +13,14 @@\n     <add key=\"dotnet8\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json\" />\n     <add key=\"dotnet8-transport\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json\" />\n     <add key=\"dotnet9\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json\" />\n+    <add key=\"vs-impl\" value=\"https://pkgs.dev.azure.com/azure-public/vside/_packaging/vs-impl/nuget/v3/index.json\" />",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it fine if Initialize is called twice? (in case of standalone msbuild)",
              "createdAt": "2025-01-13T17:00:16Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -453,6 +453,7 @@ private void UpdatePriority(Process p, ProcessPriorityClass priority)\n         /// <exception cref=\"InvalidOperationException\">Thrown if a build is already in progress.</exception>\n         public void BeginBuild(BuildParameters parameters)\n         {\n+            OpenTelemetryManager.Instance.Initialize(isStandalone: false);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Oh I see it just skips then.",
              "createdAt": "2025-01-13T17:06:29Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -453,6 +453,7 @@ private void UpdatePriority(Process p, ProcessPriorityClass priority)\n         /// <exception cref=\"InvalidOperationException\">Thrown if a build is already in progress.</exception>\n         public void BeginBuild(BuildParameters parameters)\n         {\n+            OpenTelemetryManager.Instance.Initialize(isStandalone: false);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why do we want to use different code here?\r\nIs there a chance that the hash algo will differ? (I'm trying to see if we might end up with different values in backend for same things - e.g. let's think name of custom buildcheck or task - depending on where/how it was executed)",
              "createdAt": "2025-01-13T17:03:43Z",
              "path": "src/Framework/Telemetry/ActivityExtensions.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NETFRAMEWORK\n+extern alias clientext;   // for Microsoft.VisualStudio.OpenTelemetry.ClientExtensions\n+#else\n+using System.Security.Cryptography;\n+using System.Text;\n+#endif\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    /// <summary>\n+    /// Extension methods for <see cref=\"Activity\"/>. usage in VS OpenTelemetry.\n+    /// </summary>\n+    internal static class ActivityExtensions\n+    {\n+        /// <summary>\n+        /// Add tags to the activity from a <see cref=\"IActivityTelemetryDataHolder\"/>.\n+        /// </summary>\n+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder dataHolder)\n+        {\n+            activity.WithTags(dataHolder.GetActivityProperties());\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Add tags to the activity from a list of TelemetryItems.\n+        /// </summary>\n+        public static Activity WithTags(this Activity activity, IList<TelemetryItem> tags)\n+        {\n+            foreach (var tag in tags)\n+            {\n+                activity.WithTag(tag);\n+            }\n+            return activity;\n+        }\n+        /// <summary>\n+        /// Add a tag to the activity from a <see cref=\"TelemetryItem\"/>.\n+        /// </summary>\n+        public static Activity WithTag(this Activity activity, TelemetryItem item)\n+        {\n+            object value = item.Hashed ? GetHashed(item.Value) : item.Value;\n+            activity.SetTag($\"{TelemetryConstants.PropertyPrefix}{item.Name}\", value);\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Set the start time of the activity.\n+        /// </summary>\n+        public static Activity WithStartTime(this Activity activity, DateTime? startTime)\n+        {\n+            if (startTime.HasValue)\n+            {\n+                activity.SetStartTime(startTime.Value);\n+            }\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Depending on the platform, hash the value using an available mechanism.\n+        /// </summary>\n+        private static object GetHashed(object value)\n+        {\n+#if NETFRAMEWORK\n+            return new clientext::Microsoft.VisualStudio.Telemetry.TelemetryHashedProperty(value);\n+#else\n+            return Sha256Hasher.Hash(value.ToString() ?? \"\");\n+#endif",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I wanted to use the standard method of hashing telemetry in VS, obviously that's not available in Core\r\nmaybe this is a non-goal",
              "createdAt": "2025-01-13T19:20:38Z",
              "path": "src/Framework/Telemetry/ActivityExtensions.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NETFRAMEWORK\n+extern alias clientext;   // for Microsoft.VisualStudio.OpenTelemetry.ClientExtensions\n+#else\n+using System.Security.Cryptography;\n+using System.Text;\n+#endif\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    /// <summary>\n+    /// Extension methods for <see cref=\"Activity\"/>. usage in VS OpenTelemetry.\n+    /// </summary>\n+    internal static class ActivityExtensions\n+    {\n+        /// <summary>\n+        /// Add tags to the activity from a <see cref=\"IActivityTelemetryDataHolder\"/>.\n+        /// </summary>\n+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder dataHolder)\n+        {\n+            activity.WithTags(dataHolder.GetActivityProperties());\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Add tags to the activity from a list of TelemetryItems.\n+        /// </summary>\n+        public static Activity WithTags(this Activity activity, IList<TelemetryItem> tags)\n+        {\n+            foreach (var tag in tags)\n+            {\n+                activity.WithTag(tag);\n+            }\n+            return activity;\n+        }\n+        /// <summary>\n+        /// Add a tag to the activity from a <see cref=\"TelemetryItem\"/>.\n+        /// </summary>\n+        public static Activity WithTag(this Activity activity, TelemetryItem item)\n+        {\n+            object value = item.Hashed ? GetHashed(item.Value) : item.Value;\n+            activity.SetTag($\"{TelemetryConstants.PropertyPrefix}{item.Name}\", value);\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Set the start time of the activity.\n+        /// </summary>\n+        public static Activity WithStartTime(this Activity activity, DateTime? startTime)\n+        {\n+            if (startTime.HasValue)\n+            {\n+                activity.SetStartTime(startTime.Value);\n+            }\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Depending on the platform, hash the value using an available mechanism.\n+        /// </summary>\n+        private static object GetHashed(object value)\n+        {\n+#if NETFRAMEWORK\n+            return new clientext::Microsoft.VisualStudio.Telemetry.TelemetryHashedProperty(value);\n+#else\n+            return Sha256Hasher.Hash(value.ToString() ?? \"\");\n+#endif",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "I'd say this is a non-goal. The .NET SDK also has this hashing algorithm reconstructed, and that's been judged good enough. If VS ever changes the algo we'll have to do a bunch of changes all across the stack.",
              "createdAt": "2025-01-13T19:22:46Z",
              "path": "src/Framework/Telemetry/ActivityExtensions.cs",
              "diffHunk": "@@ -0,0 +1,118 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if NETFRAMEWORK\n+extern alias clientext;   // for Microsoft.VisualStudio.OpenTelemetry.ClientExtensions\n+#else\n+using System.Security.Cryptography;\n+using System.Text;\n+#endif\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    /// <summary>\n+    /// Extension methods for <see cref=\"Activity\"/>. usage in VS OpenTelemetry.\n+    /// </summary>\n+    internal static class ActivityExtensions\n+    {\n+        /// <summary>\n+        /// Add tags to the activity from a <see cref=\"IActivityTelemetryDataHolder\"/>.\n+        /// </summary>\n+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder dataHolder)\n+        {\n+            activity.WithTags(dataHolder.GetActivityProperties());\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Add tags to the activity from a list of TelemetryItems.\n+        /// </summary>\n+        public static Activity WithTags(this Activity activity, IList<TelemetryItem> tags)\n+        {\n+            foreach (var tag in tags)\n+            {\n+                activity.WithTag(tag);\n+            }\n+            return activity;\n+        }\n+        /// <summary>\n+        /// Add a tag to the activity from a <see cref=\"TelemetryItem\"/>.\n+        /// </summary>\n+        public static Activity WithTag(this Activity activity, TelemetryItem item)\n+        {\n+            object value = item.Hashed ? GetHashed(item.Value) : item.Value;\n+            activity.SetTag($\"{TelemetryConstants.PropertyPrefix}{item.Name}\", value);\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Set the start time of the activity.\n+        /// </summary>\n+        public static Activity WithStartTime(this Activity activity, DateTime? startTime)\n+        {\n+            if (startTime.HasValue)\n+            {\n+                activity.SetStartTime(startTime.Value);\n+            }\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Depending on the platform, hash the value using an available mechanism.\n+        /// </summary>\n+        private static object GetHashed(object value)\n+        {\n+#if NETFRAMEWORK\n+            return new clientext::Microsoft.VisualStudio.Telemetry.TelemetryHashedProperty(value);\n+#else\n+            return Sha256Hasher.Hash(value.ToString() ?? \"\");\n+#endif",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How does the instrumentation code check whether a data should be collected? Does it need to check if state is any of those? Or is there otehr single property that can be checked in boolean style?",
              "createdAt": "2025-01-13T17:47:22Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,245 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Threading;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// State of the telemetry infrastructure.\n+    /// </summary>\n+    internal enum TelemetryState\n+    {\n+        /// <summary>\n+        /// Initial state.\n+        /// </summary>\n+        Uninitialized,\n+\n+        /// <summary>\n+        /// Opt out of telemetry.\n+        /// </summary>\n+        OptOut,\n+\n+        /// <summary>\n+        /// Run not sampled for telemetry.\n+        /// </summary>\n+        Unsampled,\n+\n+        /// <summary>\n+        /// For core hook, ActivitySource is created.\n+        /// </summary>\n+        TracerInitialized,\n+\n+        /// <summary>\n+        /// For VS scenario with a collector. ActivitySource, OTel TracerProvider are created.\n+        /// </summary>\n+        ExporterInitialized,\n+\n+        /// <summary>\n+        /// For standalone, ActivitySource, OTel TracerProvider, VS OpenTelemetry Collector are created.\n+        /// </summary>\n+        CollectorInitialized,",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "No. It's for inner tracking of the state of the instrumentation (perhaps I can make it private).\r\nInstrumented code does something or is a no-op based on the Tracer+Exporter objects.\r\n\r\nIn the spirit this PR not having 2k LoC it samples everything with one rate, subsequent PR will deal with sample rate differentiation based on namespaces. I figured this is acceptable since this is not a public API so we can easily change/refactor.",
              "createdAt": "2025-01-13T19:36:53Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,245 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Threading;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// State of the telemetry infrastructure.\n+    /// </summary>\n+    internal enum TelemetryState\n+    {\n+        /// <summary>\n+        /// Initial state.\n+        /// </summary>\n+        Uninitialized,\n+\n+        /// <summary>\n+        /// Opt out of telemetry.\n+        /// </summary>\n+        OptOut,\n+\n+        /// <summary>\n+        /// Run not sampled for telemetry.\n+        /// </summary>\n+        Unsampled,\n+\n+        /// <summary>\n+        /// For core hook, ActivitySource is created.\n+        /// </summary>\n+        TracerInitialized,\n+\n+        /// <summary>\n+        /// For VS scenario with a collector. ActivitySource, OTel TracerProvider are created.\n+        /// </summary>\n+        ExporterInitialized,\n+\n+        /// <summary>\n+        /// For standalone, ActivitySource, OTel TracerProvider, VS OpenTelemetry Collector are created.\n+        /// </summary>\n+        CollectorInitialized,",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "If it can be private, than I'd recommend that - it wouldn't be distracting then :-)\r\nFeel free to resolve this comment.",
              "createdAt": "2025-01-22T11:29:02Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,245 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Threading;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// State of the telemetry infrastructure.\n+    /// </summary>\n+    internal enum TelemetryState\n+    {\n+        /// <summary>\n+        /// Initial state.\n+        /// </summary>\n+        Uninitialized,\n+\n+        /// <summary>\n+        /// Opt out of telemetry.\n+        /// </summary>\n+        OptOut,\n+\n+        /// <summary>\n+        /// Run not sampled for telemetry.\n+        /// </summary>\n+        Unsampled,\n+\n+        /// <summary>\n+        /// For core hook, ActivitySource is created.\n+        /// </summary>\n+        TracerInitialized,\n+\n+        /// <summary>\n+        /// For VS scenario with a collector. ActivitySource, OTel TracerProvider are created.\n+        /// </summary>\n+        ExporterInitialized,\n+\n+        /// <summary>\n+        /// For standalone, ActivitySource, OTel TracerProvider, VS OpenTelemetry Collector are created.\n+        /// </summary>\n+        CollectorInitialized,",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Resolving as no, tests use it and I don't see how to validate Initialization logic otherwise, because telemetry is a hard to catch side effect...",
              "createdAt": "2025-01-22T12:11:42Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,245 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Threading;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// State of the telemetry infrastructure.\n+    /// </summary>\n+    internal enum TelemetryState\n+    {\n+        /// <summary>\n+        /// Initial state.\n+        /// </summary>\n+        Uninitialized,\n+\n+        /// <summary>\n+        /// Opt out of telemetry.\n+        /// </summary>\n+        OptOut,\n+\n+        /// <summary>\n+        /// Run not sampled for telemetry.\n+        /// </summary>\n+        Unsampled,\n+\n+        /// <summary>\n+        /// For core hook, ActivitySource is created.\n+        /// </summary>\n+        TracerInitialized,\n+\n+        /// <summary>\n+        /// For VS scenario with a collector. ActivitySource, OTel TracerProvider are created.\n+        /// </summary>\n+        ExporterInitialized,\n+\n+        /// <summary>\n+        /// For standalone, ActivitySource, OTel TracerProvider, VS OpenTelemetry Collector are created.\n+        /// </summary>\n+        CollectorInitialized,",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We don't seem to call this for the API usage case.\r\nLet's try to see if we can have better place to control lifetime of the telemetry manager (probably BuildManager?)",
              "createdAt": "2025-01-13T18:37:54Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -296,6 +298,9 @@ string[] args\n                 DumpCounters(false /* log to console */);\n             }\n \n+            // Send OpenTelemetry before exiting\n+            OpenTelemetryManager.Instance.Shutdown();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "~~Oh that's an oversight given we don't have the collector in VS yet. Now that I look at it, it makes more sense to do everything in EndBuild.~~\r\n\r\nThe point is that somewhere the collector has to be shut down for standalone, to reliably send the build data before the app exits. But if someone uses the API and keeps reusing one BuildManager (I think this happens in VS), it would be OK to let the collector and telemetry manager live, it sends data on a timer and it can die when the devenv process dies and we're not really concerned about reliability but about responsiveness.\r\n",
              "createdAt": "2025-01-13T19:34:01Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -296,6 +298,9 @@ string[] args\n                 DumpCounters(false /* log to console */);\n             }\n \n+            // Send OpenTelemetry before exiting\n+            OpenTelemetryManager.Instance.Shutdown();",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we use implementation from `Traits`?",
              "createdAt": "2025-01-13T18:41:16Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,245 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+extern alias clientext;\n+\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Threading;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// State of the telemetry infrastructure.\n+    /// </summary>\n+    internal enum TelemetryState\n+    {\n+        /// <summary>\n+        /// Initial state.\n+        /// </summary>\n+        Uninitialized,\n+\n+        /// <summary>\n+        /// Opt out of telemetry.\n+        /// </summary>\n+        OptOut,\n+\n+        /// <summary>\n+        /// Run not sampled for telemetry.\n+        /// </summary>\n+        Unsampled,\n+\n+        /// <summary>\n+        /// For core hook, ActivitySource is created.\n+        /// </summary>\n+        TracerInitialized,\n+\n+        /// <summary>\n+        /// For VS scenario with a collector. ActivitySource, OTel TracerProvider are created.\n+        /// </summary>\n+        ExporterInitialized,\n+\n+        /// <summary>\n+        /// For standalone, ActivitySource, OTel TracerProvider, VS OpenTelemetry Collector are created.\n+        /// </summary>\n+        CollectorInitialized,\n+\n+        /// <summary>\n+        /// End state.\n+        /// </summary>\n+        Disposed\n+    }\n+\n+    /// <summary>\n+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,\n+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.\n+    /// </summary>\n+    internal class OpenTelemetryManager\n+    {\n+        // Lazy<T> provides thread-safe lazy initialization.\n+        private static readonly Lazy<OpenTelemetryManager> s_instance =\n+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);\n+\n+        /// <summary>\n+        /// Globally accessible instance of <see cref=\"OpenTelemetryManager\"/>.\n+        /// </summary>\n+        public static OpenTelemetryManager Instance => s_instance.Value;\n+\n+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;\n+        private readonly object _initializeLock = new();\n+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;\n+\n+#if NETFRAMEWORK\n+        private TracerProvider? _tracerProvider;\n+        private IOpenTelemetryCollector? _collector;\n+#endif\n+\n+        /// <summary>\n+        /// Optional activity source for MSBuild or other telemetry usage.\n+        /// </summary>\n+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }\n+\n+        private OpenTelemetryManager()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.\n+        /// </summary>\n+        /// <param name=\"isStandalone\">Differentiates between executing as MSBuild.exe or from VS/API.</param>\n+        public void Initialize(bool isStandalone)\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (_telemetryState != TelemetryState.Uninitialized)\n+                {\n+                    return;\n+                }\n+\n+                if (IsOptOut())\n+                {\n+                    _telemetryState = TelemetryState.OptOut;\n+                    return;\n+                }\n+\n+                if (!IsSampled())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                DefaultActivitySource = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace);\n+\n+#if NETFRAMEWORK\n+                InitializeTracerProvider();\n+\n+                // TODO: Enable commented logic when Collector is present in VS\n+                // if (isStandalone)\n+                InitializeCollector();\n+\n+                // }\n+#endif\n+            }\n+        }\n+\n+#if NETFRAMEWORK\n+        /// <summary>\n+        /// Initializes the OpenTelemetry SDK TracerProvider with VS default exporter settings.\n+        /// </summary>\n+        private void InitializeTracerProvider()\n+        {\n+            var exporterSettings = OpenTelemetryExporterSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            TracerProviderBuilder tracerProviderBuilder = Sdk\n+                .CreateTracerProviderBuilder()\n+                // register all ActivitySources that should be listened to\n+                .AddSource(TelemetryConstants.DefaultActivitySourceNamespace)\n+                .AddVisualStudioDefaultTraceExporter(exporterSettings);\n+\n+            _tracerProvider = tracerProviderBuilder.Build();\n+            _telemetryState = TelemetryState.ExporterInitialized;\n+        }\n+\n+        /// <summary>\n+        /// Initializes the VS OpenTelemetry Collector with VS default settings.\n+        /// </summary>\n+        private void InitializeCollector()\n+        {\n+            IOpenTelemetryCollectorSettings collectorSettings = OpenTelemetryCollectorSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            _collector = OpenTelemetryCollectorProvider.CreateCollector(collectorSettings);\n+            _collector.StartAsync();\n+\n+            _telemetryState = TelemetryState.CollectorInitialized;\n+        }\n+#endif\n+        /// <summary>\n+        /// Flush the telemetry in TracerProvider/Exporter.\n+        /// </summary>\n+        public void ForceFlush()\n+        {\n+#if NETFRAMEWORK\n+            _tracerProvider?.ForceFlush();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Shuts down the telemetry infrastructure.\n+        /// </summary>\n+        public void Shutdown()\n+        {\n+            lock (_initializeLock)\n+            {\n+#if NETFRAMEWORK\n+                _tracerProvider?.Shutdown();\n+                _collector?.Dispose();\n+#endif\n+                _telemetryState = TelemetryState.Disposed;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Determines if the user has explicitly opted out of telemetry.\n+        /// </summary>\n+        private bool IsOptOut() =>\n+            IsEnvVarTrue(TelemetryConstants.TelemetryFxOptoutEnvVarName) ||\n+            IsEnvVarTrue(TelemetryConstants.DotnetOptOut);\n+\n+        /// <summary>\n+        /// Determines if telemetry should be initialized based on sampling and environment variable overrides.\n+        /// </summary>\n+        private bool IsSampled()\n+        {\n+            double? overrideRate = ReadDoubleEnvVar(TelemetryConstants.TelemetrySampleRateOverrideEnvVarName);\n+            if (overrideRate.HasValue)\n+            {\n+                _sampleRate = overrideRate.Value;\n+            }\n+            else\n+            {\n+#if !NETFRAMEWORK\n+                // In core, OTel infrastructure is not initialized by default.\n+                return false;\n+#endif\n+            }\n+\n+            // Simple random sampling, this method is called \n+            Random random = new();\n+            return random.NextDouble() < _sampleRate;\n+        }\n+\n+        /// <summary>\n+        /// Parses a double environment variable, if present.\n+        /// </summary>\n+        private double? ReadDoubleEnvVar(string name)\n+        {\n+            string? sampleRateString =\n+                Environment.GetEnvironmentVariable(name);\n+            return double.TryParse(sampleRateString, NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture.NumberFormat, out double result) ? result : null;\n+        }\n+\n+        /// <summary>\n+        /// Evaluates if an environment variable is set to \"1\" or \"true\".\n+        /// </summary>\n+        private bool IsEnvVarTrue(string name)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you make these all `PrivateAssets=\"all\"` so they don't affect our NuGet packages? We are using them as an internal implementation detail for VS and don't need to expose that to folks who are building against our API.",
              "createdAt": "2025-01-17T15:04:02Z",
              "path": "src/Framework/Microsoft.Build.Framework.csproj",
              "diffHunk": "@@ -23,6 +23,16 @@\n     <PackageReference Include=\"System.Runtime.CompilerServices.Unsafe\" />\n     <PackageReference Include=\"Microsoft.VisualStudio.Setup.Configuration.Interop\" PrivateAssets=\"all\" />\n     <Reference Include=\"System.Xaml\" />\n+    \n+    <!-- Telemetry in Framework-->\n+    <PackageReference Include=\"Microsoft.VisualStudio.OpenTelemetry.Collector\"/>\n+    <PackageReference Include=\"Microsoft.VisualStudio.OpenTelemetry.ClientExtensions\"/>\n+    <PackageReference Include=\"OpenTelemetry\" />",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just curious - how will we identify standalone msbuild.exe CLI run? Via `host` being null? Should we add something more explicit?\r\nThe need wasn't there before (telemetry wasn't collected) - it'll be there from now on.",
              "createdAt": "2025-02-01T20:14:33Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -1073,14 +1074,19 @@ public void EndBuild()\n                             {\n                                 host = \"VSCode\";\n                             }\n-                            _buildTelemetry.Host = host;\n+                            _buildTelemetry.BuildEngineHost = host;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Yes, now it'll be null which would show up in the backend as the property missing. Now that happens in 2 cases: if it's called via API from outside VS (e.g. with loading msbuildlocator located assemblies), and standalone. Differentiation would make sense... https://github.com/dotnet/msbuild/issues/11376",
              "createdAt": "2025-02-03T13:11:05Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -1073,14 +1074,19 @@ public void EndBuild()\n                             {\n                                 host = \"VSCode\";\n                             }\n-                            _buildTelemetry.Host = host;\n+                            _buildTelemetry.BuildEngineHost = host;",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: indentation is wrong from this line on",
              "createdAt": "2025-02-01T20:19:47Z",
              "path": "src/Framework/Telemetry/ActivityExtensions.cs",
              "diffHunk": "@@ -0,0 +1,108 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Security.Cryptography;\n+using System.Text;\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    /// <summary>\n+    /// Extension methods for <see cref=\"Activity\"/>. usage in VS OpenTelemetry.\n+    /// </summary>\n+    internal static class ActivityExtensions\n+    {\n+        /// <summary>\n+        /// Add tags to the activity from a <see cref=\"IActivityTelemetryDataHolder\"/>.\n+        /// </summary>\n+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder dataHolder)\n+        {\n+            activity.WithTags(dataHolder.GetActivityProperties());\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Add tags to the activity from a list of TelemetryItems.\n+        /// </summary>\n+        public static Activity WithTags(this Activity activity, IList<TelemetryItem> tags)\n+        {\n+            foreach (var tag in tags)\n+            {\n+                activity.WithTag(tag);\n+            }\n+            return activity;\n+        }\n+        /// <summary>\n+        /// Add a tag to the activity from a <see cref=\"TelemetryItem\"/>.\n+        /// </summary>\n+        public static Activity WithTag(this Activity activity, TelemetryItem item)\n+        {\n+            object value = item.Hashed ? GetHashed(item.Value) : item.Value;\n+            activity.SetTag($\"{TelemetryConstants.PropertyPrefix}{item.Name}\", value);\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Set the start time of the activity.\n+        /// </summary>\n+        public static Activity WithStartTime(this Activity activity, DateTime? startTime)\n+        {\n+            if (startTime.HasValue)\n+            {\n+                activity.SetStartTime(startTime.Value);\n+            }\n+            return activity;\n+        }\n+\n+        /// <summary>\n+        /// Depending on the platform, hash the value using an available mechanism.\n+        /// </summary>\n+        private static object GetHashed(object value)\n+        {\n+            return Sha256Hasher.Hash(value.ToString() ?? \"\");\n+        }\n+\n+        // https://github.com/dotnet/sdk/blob/8bd19a2390a6bba4aa80d1ac3b6c5385527cc311/src/Cli/Microsoft.DotNet.Cli.Utils/Sha256Hasher.cs + workaround for netstandard2.0\n+        private static class Sha256Hasher\n+        {\n+            /// <summary>\n+            /// The hashed mac address needs to be the same hashed value as produced by the other distinct sources given the same input. (e.g. VsCode)\n+            /// </summary>\n+            public static string Hash(string text)\n+            {\n+                byte[] bytes = Encoding.UTF8.GetBytes(text);\n+#if NET\n+                byte[] hash = SHA256.HashData(bytes);\n+#if NET9_0_OR_GREATER\n+                return Convert.ToHexStringLower(hash);\n+#else\n+            return Convert.ToHexString(hash).ToLowerInvariant();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This fixes https://github.com/dotnet/msbuild/issues/11316 - correct?",
              "createdAt": "2025-02-02T10:35:58Z",
              "path": "src/Framework/Telemetry/MSBuildActivitySource.cs",
              "diffHunk": "@@ -0,0 +1,35 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Diagnostics;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    /// <summary>\n+    /// Wrapper class for ActivitySource with a <see cref=\"StartActivity(string)\"/> method that wraps Activity name with VS OTel prefix.\n+    /// </summary>\n+    internal class MSBuildActivitySource\n+    {\n+        private readonly ActivitySource _source;\n+        private readonly double _sampleRate;\n+\n+        public MSBuildActivitySource(string name, double sampleRate)\n+        {\n+            _source = new ActivitySource(name);\n+            _sampleRate = sampleRate;\n+        }\n+        /// <summary>\n+        /// Prefixes activity with VS OpenTelemetry.\n+        /// </summary>\n+        /// <param name=\"name\">Name of the telemetry event without prefix.</param>\n+        /// <returns></returns>\n+        public Activity? StartActivity(string name)\n+        {\n+            var activity = Activity.Current?.HasRemoteParent == true\n+                ? _source.StartActivity($\"{TelemetryConstants.EventPrefix}{name}\", ActivityKind.Internal, parentId: Activity.Current.ParentId)\n+                : _source.StartActivity($\"{TelemetryConstants.EventPrefix}{name}\");\n+            activity?.WithTag(new(\"SampleRate\", _sampleRate, false));",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Not really, \"p(override sample rate) * p(A/B sample)\" I would not consider faithful cardinality.",
              "createdAt": "2025-02-03T11:02:45Z",
              "path": "src/Framework/Telemetry/MSBuildActivitySource.cs",
              "diffHunk": "@@ -0,0 +1,35 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Diagnostics;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+    /// <summary>\n+    /// Wrapper class for ActivitySource with a <see cref=\"StartActivity(string)\"/> method that wraps Activity name with VS OTel prefix.\n+    /// </summary>\n+    internal class MSBuildActivitySource\n+    {\n+        private readonly ActivitySource _source;\n+        private readonly double _sampleRate;\n+\n+        public MSBuildActivitySource(string name, double sampleRate)\n+        {\n+            _source = new ActivitySource(name);\n+            _sampleRate = sampleRate;\n+        }\n+        /// <summary>\n+        /// Prefixes activity with VS OpenTelemetry.\n+        /// </summary>\n+        /// <param name=\"name\">Name of the telemetry event without prefix.</param>\n+        /// <returns></returns>\n+        public Activity? StartActivity(string name)\n+        {\n+            var activity = Activity.Current?.HasRemoteParent == true\n+                ? _source.StartActivity($\"{TelemetryConstants.EventPrefix}{name}\", ActivityKind.Internal, parentId: Activity.Current.ParentId)\n+                : _source.StartActivity($\"{TelemetryConstants.EventPrefix}{name}\");\n+            activity?.WithTag(new(\"SampleRate\", _sampleRate, false));",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The cost of the lock is very small - especially as it should never be contended... on the other hand - we're going to call it twice for every CLI build - let's add the uninitialized check before the lock - to bail out quick.",
              "createdAt": "2025-02-02T10:49:40Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,279 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Threading;\n+using System.Globalization;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,\n+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.\n+    /// </summary>\n+    internal class OpenTelemetryManager\n+    {\n+        // Lazy<T> provides thread-safe lazy initialization.\n+        private static readonly Lazy<OpenTelemetryManager> s_instance =\n+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);\n+\n+        /// <summary>\n+        /// Globally accessible instance of <see cref=\"OpenTelemetryManager\"/>.\n+        /// </summary>\n+        public static OpenTelemetryManager Instance => s_instance.Value;\n+\n+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;\n+        private readonly object _initializeLock = new();\n+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;\n+\n+#if NETFRAMEWORK\n+        private TracerProvider? _tracerProvider;\n+        private IOpenTelemetryCollector? _collector;\n+#endif\n+\n+        /// <summary>\n+        /// Optional activity source for MSBuild or other telemetry usage.\n+        /// </summary>\n+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }\n+\n+        private OpenTelemetryManager()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.\n+        /// </summary>\n+        /// <param name=\"isStandalone\">Differentiates between executing as MSBuild.exe or from VS/API.</param>\n+        public void Initialize(bool isStandalone)\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (_telemetryState != TelemetryState.Uninitialized)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Let's move this into pattern matching of the exception catching above - so that we do not have to rethrow below.\r\n\r\nAlso - this is worth logging - at least as low-pri message (but it probably deserves high-pri - as it means that MSBuild was attempted to be executed via some nonstandard way - custom copy&pasting of portion of binaries from VS folder, leaving out some of the deps. Correct?)",
              "createdAt": "2025-02-02T11:01:13Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,279 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Threading;\n+using System.Globalization;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,\n+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.\n+    /// </summary>\n+    internal class OpenTelemetryManager\n+    {\n+        // Lazy<T> provides thread-safe lazy initialization.\n+        private static readonly Lazy<OpenTelemetryManager> s_instance =\n+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);\n+\n+        /// <summary>\n+        /// Globally accessible instance of <see cref=\"OpenTelemetryManager\"/>.\n+        /// </summary>\n+        public static OpenTelemetryManager Instance => s_instance.Value;\n+\n+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;\n+        private readonly object _initializeLock = new();\n+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;\n+\n+#if NETFRAMEWORK\n+        private TracerProvider? _tracerProvider;\n+        private IOpenTelemetryCollector? _collector;\n+#endif\n+\n+        /// <summary>\n+        /// Optional activity source for MSBuild or other telemetry usage.\n+        /// </summary>\n+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }\n+\n+        private OpenTelemetryManager()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.\n+        /// </summary>\n+        /// <param name=\"isStandalone\">Differentiates between executing as MSBuild.exe or from VS/API.</param>\n+        public void Initialize(bool isStandalone)\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (_telemetryState != TelemetryState.Uninitialized)\n+                {\n+                    return;\n+                }\n+\n+                if (IsOptOut())\n+                {\n+                    _telemetryState = TelemetryState.OptOut;\n+                    return;\n+                }\n+\n+                // TODO: temporary until we have green light to enable telemetry perf-wise\n+                if (!IsOptIn())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                if (!IsSampled())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                InitializeActivitySources();\n+            }\n+#if NETFRAMEWORK\n+            try\n+            {\n+                InitializeTracerProvider();\n+\n+                // TODO: Enable commented logic when Collector is present in VS\n+                // if (isStandalone)\n+                InitializeCollector();\n+\n+                // }\n+            }\n+            catch (Exception ex)\n+            {\n+                // catch exceptions from loading the OTel SDK or Collector to maintain usability of Microsoft.Build.Framework package in our and downstream tests in VS.\n+                if (ex is System.IO.FileNotFoundException or System.IO.FileLoadException)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "added pattern match, issue for logging: https://github.com/dotnet/msbuild/issues/11377",
              "createdAt": "2025-02-03T13:45:14Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,279 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Threading;\n+using System.Globalization;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,\n+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.\n+    /// </summary>\n+    internal class OpenTelemetryManager\n+    {\n+        // Lazy<T> provides thread-safe lazy initialization.\n+        private static readonly Lazy<OpenTelemetryManager> s_instance =\n+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);\n+\n+        /// <summary>\n+        /// Globally accessible instance of <see cref=\"OpenTelemetryManager\"/>.\n+        /// </summary>\n+        public static OpenTelemetryManager Instance => s_instance.Value;\n+\n+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;\n+        private readonly object _initializeLock = new();\n+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;\n+\n+#if NETFRAMEWORK\n+        private TracerProvider? _tracerProvider;\n+        private IOpenTelemetryCollector? _collector;\n+#endif\n+\n+        /// <summary>\n+        /// Optional activity source for MSBuild or other telemetry usage.\n+        /// </summary>\n+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }\n+\n+        private OpenTelemetryManager()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.\n+        /// </summary>\n+        /// <param name=\"isStandalone\">Differentiates between executing as MSBuild.exe or from VS/API.</param>\n+        public void Initialize(bool isStandalone)\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (_telemetryState != TelemetryState.Uninitialized)\n+                {\n+                    return;\n+                }\n+\n+                if (IsOptOut())\n+                {\n+                    _telemetryState = TelemetryState.OptOut;\n+                    return;\n+                }\n+\n+                // TODO: temporary until we have green light to enable telemetry perf-wise\n+                if (!IsOptIn())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                if (!IsSampled())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                InitializeActivitySources();\n+            }\n+#if NETFRAMEWORK\n+            try\n+            {\n+                InitializeTracerProvider();\n+\n+                // TODO: Enable commented logic when Collector is present in VS\n+                // if (isStandalone)\n+                InitializeCollector();\n+\n+                // }\n+            }\n+            catch (Exception ex)\n+            {\n+                // catch exceptions from loading the OTel SDK or Collector to maintain usability of Microsoft.Build.Framework package in our and downstream tests in VS.\n+                if (ex is System.IO.FileNotFoundException or System.IO.FileLoadException)",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Consider adding the check as well before locking.\r\n\r\nWhile the gain is super small (order of dozens of instructions) - it's for free and it's there for virtualy every build in the wild",
              "createdAt": "2025-02-02T11:16:05Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,279 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Threading;\n+using System.Globalization;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,\n+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.\n+    /// </summary>\n+    internal class OpenTelemetryManager\n+    {\n+        // Lazy<T> provides thread-safe lazy initialization.\n+        private static readonly Lazy<OpenTelemetryManager> s_instance =\n+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);\n+\n+        /// <summary>\n+        /// Globally accessible instance of <see cref=\"OpenTelemetryManager\"/>.\n+        /// </summary>\n+        public static OpenTelemetryManager Instance => s_instance.Value;\n+\n+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;\n+        private readonly object _initializeLock = new();\n+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;\n+\n+#if NETFRAMEWORK\n+        private TracerProvider? _tracerProvider;\n+        private IOpenTelemetryCollector? _collector;\n+#endif\n+\n+        /// <summary>\n+        /// Optional activity source for MSBuild or other telemetry usage.\n+        /// </summary>\n+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }\n+\n+        private OpenTelemetryManager()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.\n+        /// </summary>\n+        /// <param name=\"isStandalone\">Differentiates between executing as MSBuild.exe or from VS/API.</param>\n+        public void Initialize(bool isStandalone)\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (_telemetryState != TelemetryState.Uninitialized)\n+                {\n+                    return;\n+                }\n+\n+                if (IsOptOut())\n+                {\n+                    _telemetryState = TelemetryState.OptOut;\n+                    return;\n+                }\n+\n+                // TODO: temporary until we have green light to enable telemetry perf-wise\n+                if (!IsOptIn())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                if (!IsSampled())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                InitializeActivitySources();\n+            }\n+#if NETFRAMEWORK\n+            try\n+            {\n+                InitializeTracerProvider();\n+\n+                // TODO: Enable commented logic when Collector is present in VS\n+                // if (isStandalone)\n+                InitializeCollector();\n+\n+                // }\n+            }\n+            catch (Exception ex)\n+            {\n+                // catch exceptions from loading the OTel SDK or Collector to maintain usability of Microsoft.Build.Framework package in our and downstream tests in VS.\n+                if (ex is System.IO.FileNotFoundException or System.IO.FileLoadException)\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                throw;\n+            }\n+#endif\n+        }\n+\n+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads\n+        private void InitializeActivitySources()\n+        {\n+            _telemetryState = TelemetryState.TracerInitialized;\n+            DefaultActivitySource = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace, _sampleRate);\n+        }\n+\n+#if NETFRAMEWORK\n+        /// <summary>\n+        /// Initializes the OpenTelemetry SDK TracerProvider with VS default exporter settings.\n+        /// </summary>\n+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads\n+        private void InitializeTracerProvider()\n+        {\n+            var exporterSettings = OpenTelemetryExporterSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            TracerProviderBuilder tracerProviderBuilder = Sdk\n+                .CreateTracerProviderBuilder()\n+                // this adds listeners to ActivitySources with the prefix \"Microsoft.VisualStudio.OpenTelemetry.\"\n+                                .AddVisualStudioDefaultTraceExporter(exporterSettings);\n+\n+            _tracerProvider = tracerProviderBuilder.Build();\n+            _telemetryState = TelemetryState.ExporterInitialized;\n+        }\n+\n+        /// <summary>\n+        /// Initializes the VS OpenTelemetry Collector with VS default settings.\n+        /// </summary>\n+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads\n+        private void InitializeCollector()\n+        {\n+            IOpenTelemetryCollectorSettings collectorSettings = OpenTelemetryCollectorSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            _collector = OpenTelemetryCollectorProvider.CreateCollector(collectorSettings);\n+            _collector.StartAsync().GetAwaiter().GetResult();\n+\n+            _telemetryState = TelemetryState.CollectorInitialized;\n+        }\n+#endif\n+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads\n+        private void ForceFlushInner()\n+        {\n+#if NETFRAMEWORK\n+            _tracerProvider?.ForceFlush();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Flush the telemetry in TracerProvider/Exporter.\n+        /// </summary>\n+        public void ForceFlush()\n+        {\n+            if (ShouldBeCleanedUp())\n+            {\n+                ForceFlushInner();\n+            }\n+        }\n+\n+        // to avoid assembly loading OpenTelemetry in tests\n+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads\n+        private void ShutdownInner()\n+        {\n+#if NETFRAMEWORK\n+            _tracerProvider?.Shutdown();\n+            // Dispose stops the collector, with a default drain timeout of 10s\n+            _collector?.Dispose();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Shuts down the telemetry infrastructure.\n+        /// </summary>\n+        public void Shutdown()\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (ShouldBeCleanedUp())",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "This suggestion creates a logical race condition I think, but on the other hand as the feature stands it would not be hit because initialize-shutdown sequence happens only on a synchronous path.\r\nShutdown should happen only on standalone at the end of Xmake, not in BuildManager (which is where VS can introduce race conditions by having multiple buildmanagers).\r\n\r\nRC:\r\nT1: Initialize() -> is initializing no change to variable yet\r\nT2: Shutdown() -> checks ShouldBeCelanedUp()... no -> shutdown returns\r\nT1: sets state variable\r\nT2: shutdown does not happen (wrong)",
              "createdAt": "2025-02-03T12:30:22Z",
              "path": "src/Framework/Telemetry/OpenTelemetryManager.cs",
              "diffHunk": "@@ -0,0 +1,279 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+#if NETFRAMEWORK\n+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;\n+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;\n+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;\n+using OpenTelemetry;\n+using OpenTelemetry.Trace;\n+#endif\n+using System;\n+using System.Diagnostics;\n+using System.Threading;\n+using System.Globalization;\n+using System.Runtime.CompilerServices;\n+\n+namespace Microsoft.Build.Framework.Telemetry\n+{\n+\n+    /// <summary>\n+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,\n+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.\n+    /// </summary>\n+    internal class OpenTelemetryManager\n+    {\n+        // Lazy<T> provides thread-safe lazy initialization.\n+        private static readonly Lazy<OpenTelemetryManager> s_instance =\n+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);\n+\n+        /// <summary>\n+        /// Globally accessible instance of <see cref=\"OpenTelemetryManager\"/>.\n+        /// </summary>\n+        public static OpenTelemetryManager Instance => s_instance.Value;\n+\n+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;\n+        private readonly object _initializeLock = new();\n+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;\n+\n+#if NETFRAMEWORK\n+        private TracerProvider? _tracerProvider;\n+        private IOpenTelemetryCollector? _collector;\n+#endif\n+\n+        /// <summary>\n+        /// Optional activity source for MSBuild or other telemetry usage.\n+        /// </summary>\n+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }\n+\n+        private OpenTelemetryManager()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.\n+        /// </summary>\n+        /// <param name=\"isStandalone\">Differentiates between executing as MSBuild.exe or from VS/API.</param>\n+        public void Initialize(bool isStandalone)\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (_telemetryState != TelemetryState.Uninitialized)\n+                {\n+                    return;\n+                }\n+\n+                if (IsOptOut())\n+                {\n+                    _telemetryState = TelemetryState.OptOut;\n+                    return;\n+                }\n+\n+                // TODO: temporary until we have green light to enable telemetry perf-wise\n+                if (!IsOptIn())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                if (!IsSampled())\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                InitializeActivitySources();\n+            }\n+#if NETFRAMEWORK\n+            try\n+            {\n+                InitializeTracerProvider();\n+\n+                // TODO: Enable commented logic when Collector is present in VS\n+                // if (isStandalone)\n+                InitializeCollector();\n+\n+                // }\n+            }\n+            catch (Exception ex)\n+            {\n+                // catch exceptions from loading the OTel SDK or Collector to maintain usability of Microsoft.Build.Framework package in our and downstream tests in VS.\n+                if (ex is System.IO.FileNotFoundException or System.IO.FileLoadException)\n+                {\n+                    _telemetryState = TelemetryState.Unsampled;\n+                    return;\n+                }\n+\n+                throw;\n+            }\n+#endif\n+        }\n+\n+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads\n+        private void InitializeActivitySources()\n+        {\n+            _telemetryState = TelemetryState.TracerInitialized;\n+            DefaultActivitySource = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace, _sampleRate);\n+        }\n+\n+#if NETFRAMEWORK\n+        /// <summary>\n+        /// Initializes the OpenTelemetry SDK TracerProvider with VS default exporter settings.\n+        /// </summary>\n+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads\n+        private void InitializeTracerProvider()\n+        {\n+            var exporterSettings = OpenTelemetryExporterSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            TracerProviderBuilder tracerProviderBuilder = Sdk\n+                .CreateTracerProviderBuilder()\n+                // this adds listeners to ActivitySources with the prefix \"Microsoft.VisualStudio.OpenTelemetry.\"\n+                                .AddVisualStudioDefaultTraceExporter(exporterSettings);\n+\n+            _tracerProvider = tracerProviderBuilder.Build();\n+            _telemetryState = TelemetryState.ExporterInitialized;\n+        }\n+\n+        /// <summary>\n+        /// Initializes the VS OpenTelemetry Collector with VS default settings.\n+        /// </summary>\n+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads\n+        private void InitializeCollector()\n+        {\n+            IOpenTelemetryCollectorSettings collectorSettings = OpenTelemetryCollectorSettingsBuilder\n+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)\n+                .Build();\n+\n+            _collector = OpenTelemetryCollectorProvider.CreateCollector(collectorSettings);\n+            _collector.StartAsync().GetAwaiter().GetResult();\n+\n+            _telemetryState = TelemetryState.CollectorInitialized;\n+        }\n+#endif\n+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads\n+        private void ForceFlushInner()\n+        {\n+#if NETFRAMEWORK\n+            _tracerProvider?.ForceFlush();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Flush the telemetry in TracerProvider/Exporter.\n+        /// </summary>\n+        public void ForceFlush()\n+        {\n+            if (ShouldBeCleanedUp())\n+            {\n+                ForceFlushInner();\n+            }\n+        }\n+\n+        // to avoid assembly loading OpenTelemetry in tests\n+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads\n+        private void ShutdownInner()\n+        {\n+#if NETFRAMEWORK\n+            _tracerProvider?.Shutdown();\n+            // Dispose stops the collector, with a default drain timeout of 10s\n+            _collector?.Dispose();\n+#endif\n+        }\n+\n+        /// <summary>\n+        /// Shuts down the telemetry infrastructure.\n+        /// </summary>\n+        public void Shutdown()\n+        {\n+            lock (_initializeLock)\n+            {\n+                if (ShouldBeCleanedUp())",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please add a check to release checklist to check this section if major version is changing",
              "createdAt": "2025-02-02T11:22:14Z",
              "path": "documentation/release.md",
              "diffHunk": "@@ -17,3 +17,11 @@ As of [#7018](https://github.com/dotnet/msbuild/pull/7018), MSBuild uses a Rosly\n 3. At release time, we must manually promote the `Unshipped` public API to `Shipped`.\n \n That is a new step in our release process for each formal release (including patch releases if they change API surface).\n+\n+## Major release extra release steps",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Very opinionted suggestion :-) - let's keep this as it was. During testing with A/B experiments can set env vars for both - opt-in and the override rate. Once we exit the VS experimental tasting we won't have risk of forgetting this in and storming tel backend",
              "createdAt": "2025-02-02T11:25:53Z",
              "path": "src/Framework/Telemetry/TelemetryConstants.cs",
              "diffHunk": "@@ -0,0 +1,51 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+namespace Microsoft.Build.Framework.Telemetry;\n+\n+/// <summary>\n+/// Constants for VS OpenTelemetry for basic configuration and appropriate naming for VS exporting/collection.\n+/// </summary>\n+internal static class TelemetryConstants\n+{\n+    /// <summary>\n+    /// \"Microsoft.VisualStudio.OpenTelemetry.*\" namespace is required by VS exporting/collection.\n+    /// </summary>\n+    public const string ActivitySourceNamespacePrefix = \"Microsoft.VisualStudio.OpenTelemetry.MSBuild.\";\n+\n+    /// <summary>\n+    /// Namespace of the default ActivitySource handling e.g. End of build telemetry.\n+    /// </summary>\n+    public const string DefaultActivitySourceNamespace = $\"{ActivitySourceNamespacePrefix}Default\";\n+\n+    /// <summary>\n+    /// Prefix required by VS exporting/collection.\n+    /// </summary>\n+    public const string EventPrefix = \"VS/MSBuild/\";\n+\n+    /// <summary>\n+    /// Prefix required by VS exporting/collection.\n+    /// </summary>\n+    public const string PropertyPrefix = \"VS.MSBuild.\";\n+\n+    /// <summary>\n+    /// For VS OpenTelemetry Collector to apply the correct privacy policy.\n+    /// </summary>\n+    public const string VSMajorVersion = \"17.0\";\n+\n+    /// <summary>\n+    /// Sample rate for the default namespace.\n+    /// 1:25000 gives us sample size of sufficient confidence with the assumption we collect the order of 1e7 - 1e8 events per day.\n+    /// </summary>\n+    // public const double DefaultSampleRate = 4e-5;\n+    public const double DefaultSampleRate = 1.0;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "The idea of the changed PR is that opt in = Override sample rate env var. So this is now a dead variable waiting to be rolled back to when \"Default\" means something. \r\nI did not want to split these concepts because override without opt in is meaningless and it's not transparent what the sample rate should be when you opt in without specifying an override (I would personally expect it to be 1, not 1:25000).\r\n\r\nI'm not concerned it would spam the backend because for enabling the behavior by default we'd have to change MSBuild, not the VS A/B code.",
              "createdAt": "2025-02-03T11:38:00Z",
              "path": "src/Framework/Telemetry/TelemetryConstants.cs",
              "diffHunk": "@@ -0,0 +1,51 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+namespace Microsoft.Build.Framework.Telemetry;\n+\n+/// <summary>\n+/// Constants for VS OpenTelemetry for basic configuration and appropriate naming for VS exporting/collection.\n+/// </summary>\n+internal static class TelemetryConstants\n+{\n+    /// <summary>\n+    /// \"Microsoft.VisualStudio.OpenTelemetry.*\" namespace is required by VS exporting/collection.\n+    /// </summary>\n+    public const string ActivitySourceNamespacePrefix = \"Microsoft.VisualStudio.OpenTelemetry.MSBuild.\";\n+\n+    /// <summary>\n+    /// Namespace of the default ActivitySource handling e.g. End of build telemetry.\n+    /// </summary>\n+    public const string DefaultActivitySourceNamespace = $\"{ActivitySourceNamespacePrefix}Default\";\n+\n+    /// <summary>\n+    /// Prefix required by VS exporting/collection.\n+    /// </summary>\n+    public const string EventPrefix = \"VS/MSBuild/\";\n+\n+    /// <summary>\n+    /// Prefix required by VS exporting/collection.\n+    /// </summary>\n+    public const string PropertyPrefix = \"VS.MSBuild.\";\n+\n+    /// <summary>\n+    /// For VS OpenTelemetry Collector to apply the correct privacy policy.\n+    /// </summary>\n+    public const string VSMajorVersion = \"17.0\";\n+\n+    /// <summary>\n+    /// Sample rate for the default namespace.\n+    /// 1:25000 gives us sample size of sufficient confidence with the assumption we collect the order of 1e7 - 1e8 events per day.\n+    /// </summary>\n+    // public const double DefaultSampleRate = 4e-5;\n+    public const double DefaultSampleRate = 1.0;",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "i made the change, it makes sense",
              "createdAt": "2025-02-18T09:51:47Z",
              "path": "src/Framework/Telemetry/TelemetryConstants.cs",
              "diffHunk": "@@ -0,0 +1,51 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+namespace Microsoft.Build.Framework.Telemetry;\n+\n+/// <summary>\n+/// Constants for VS OpenTelemetry for basic configuration and appropriate naming for VS exporting/collection.\n+/// </summary>\n+internal static class TelemetryConstants\n+{\n+    /// <summary>\n+    /// \"Microsoft.VisualStudio.OpenTelemetry.*\" namespace is required by VS exporting/collection.\n+    /// </summary>\n+    public const string ActivitySourceNamespacePrefix = \"Microsoft.VisualStudio.OpenTelemetry.MSBuild.\";\n+\n+    /// <summary>\n+    /// Namespace of the default ActivitySource handling e.g. End of build telemetry.\n+    /// </summary>\n+    public const string DefaultActivitySourceNamespace = $\"{ActivitySourceNamespacePrefix}Default\";\n+\n+    /// <summary>\n+    /// Prefix required by VS exporting/collection.\n+    /// </summary>\n+    public const string EventPrefix = \"VS/MSBuild/\";\n+\n+    /// <summary>\n+    /// Prefix required by VS exporting/collection.\n+    /// </summary>\n+    public const string PropertyPrefix = \"VS.MSBuild.\";\n+\n+    /// <summary>\n+    /// For VS OpenTelemetry Collector to apply the correct privacy policy.\n+    /// </summary>\n+    public const string VSMajorVersion = \"17.0\";\n+\n+    /// <summary>\n+    /// Sample rate for the default namespace.\n+    /// 1:25000 gives us sample size of sufficient confidence with the assumption we collect the order of 1e7 - 1e8 events per day.\n+    /// </summary>\n+    // public const double DefaultSampleRate = 4e-5;\n+    public const double DefaultSampleRate = 1.0;",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The last boolean means that the value _will need to be hashed_, rather than _it is already hashed_ - correct?\r\n```suggestion\r\ninternal record TelemetryItem(string Name, object Value, bool NeedsHashing);\r\n```",
              "createdAt": "2025-02-02T11:29:11Z",
              "path": "src/Framework/Telemetry/TelemetryItem.cs",
              "diffHunk": "@@ -0,0 +1,6 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Framework.Telemetry;\n+\n+internal record TelemetryItem(string Name, object Value, bool Hashed);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": ":heart:",
              "createdAt": "2025-02-02T11:32:16Z",
              "path": "src/Framework/Traits.cs",
              "diffHunk": "@@ -4,8 +4,6 @@\n using System;\n using System.Globalization;\n \n-#nullable disable\n-",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}