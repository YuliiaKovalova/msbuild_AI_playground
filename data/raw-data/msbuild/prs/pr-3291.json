{
  "number": 3291,
  "title": "Add ZipDirectory and Unzip tasks",
  "body": "`ZipDirectory` task zips up a whole directory.  It will fail if the destination file already exists.  Zipping individual files is a lot harder because you have to calculated a base path for all files and make zip entries relative to that.  The code in the CLR that does this is very efficient by reusing string buffers and I didn't want to have to replicate the code.  So for now there's only `ZipDirectory` instead of a more generic `Zip`.\r\n\r\n`Unzip` unzips files from an archive to a directory.\r\n* Defaults to skip unzipping files that are already up-to-date\r\n* Logs every file that was unzipped\r\n* Supports cancellation\r\n* Supports overwriting read-only files\r\n* Supports unzipping multiple files to the same directory\r\n\r\nFixes #1781 ",
  "state": "MERGED",
  "createdAt": "2018-05-09T20:43:40Z",
  "updatedAt": "2023-11-04T07:34:45Z",
  "closedAt": "2018-05-22T20:36:05Z",
  "mergedAt": "2018-05-22T20:36:05Z",
  "additions": 1951,
  "deletions": 360,
  "changedFiles": 25,
  "headRefName": "zip",
  "isDraft": false,
  "author": {
    "login": "jeffkl"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "3f45618a2a2648f99bd80d097e1386ba0472f659",
          "message": "Add Unzip task",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1301481fc071b70e663162b94b850bd4c913178a",
          "message": "ZipDirectory and strings",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1580946afb8885a25529f4372d4bf1540a86a387",
          "message": "Update xsd",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "611beb943e3323edcb8c5f40318581f99e4ce242",
          "message": "Update public API",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6427cc8ca1a4f9f7258986cb8704b03995ca0ce5",
          "message": "Fix copy/paste error",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e178b6861bc16c8ca2cdac550d2ad9b4c50ed19c",
          "message": "Remove Output properties of Unzip\n\nAdd unit tests for Unzip",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9f066d006228b1f67c07954439e24cdb1a8a9f3b",
          "message": "Fix runtime error on net46",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2966a71193926253f4205c207e0005fec2713d28",
          "message": "Update xlf after rebase",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a0880f0b6837856a3af98a722b326bc06ae2f4ce",
          "message": "Add ZipDirectory unit tests",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1cc09274a4dc081d40f06c3f35d1b2a50d29e5ac",
          "message": "Fix broken tests",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4501ce63d7fe623021fef602943eb4b21c40a2bb",
          "message": "Use cancellation token and Yield while extracting",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "47662af8b450f1e739d3ee1153e1029be7e29323",
          "message": "Remove unused parameter",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6fe2b564831964fe1891682599a06816dad28be5",
          "message": "Add Overwrite property to ZipDirectory",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e0289440bc1c0f428b2c84713a301d4c69ac9ce8",
          "message": "Use [PlatformSpecific(TestPlatforms.Windows)]",
          "committedDate": "2018-05-21T14:47:33Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "85831576df9c2084a5b05ff2ab6d96f1d9b72209",
          "message": "Address comments",
          "committedDate": "2018-05-21T15:02:54Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "88d02fe651ec4af54e412448886c8ae870bfbb1b",
          "message": "Yield execution in ZipDirectory",
          "committedDate": "2018-05-22T16:37:14Z",
          "author": {
            "name": "Jeff Kluge",
            "email": "jeffkl@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@Microsoft/msbuild-maintainers this is ready for final review",
        "createdAt": "2018-05-15T14:01:08Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "`Copy` doesn\u2019t restore the RO bit, so I\u2019d say don\u2019t do it here either.\r\n",
        "createdAt": "2018-05-21T15:03:12Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@cdmihai can you please review my changes to address your comments?  I think this is ready to merge but wanted to make sure you were happy.",
        "createdAt": "2018-05-22T15:25:53Z",
        "author": {
          "login": "jeffkl"
        }
      },
      {
        "body": "@natemcmaster I'll double check but I _think_ my unit tests cover that scenario.",
        "createdAt": "2018-05-22T20:51:06Z",
        "author": {
          "login": "jeffkl"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we always want this? Seems like it could be a giant list in some cases and use up a lot of memory and may or may not be needed? The output folder might be enough?",
              "createdAt": "2018-05-10T20:35:28Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,211 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.ObjectModel;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a collection of all destination files.\n+        /// </summary>\n+        private readonly Collection<ITaskItem> _destinationFiles = new Collection<ITaskItem>();\n+\n+        /// <summary>\n+        /// Stores a collection of all files that were unzipped.\n+        /// </summary>\n+        private readonly Collection<ITaskItem> _unzippedFiles = new Collection<ITaskItem>();\n+\n+        /// <summary>\n+        /// Stores a value indicating if a cancellation was requested.\n+        /// </summary>\n+        private bool _canceling;\n+\n+        /// <summary>\n+        /// Gets an array of <see cref=\"ITaskItem\"/> objects containing details about all of the destination files.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] DestinationFiles => _destinationFiles.ToArray();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets an array of <see cref=\"ITaskItem\"/> objects containing details about only the files that were unzipped.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] UnzippedFiles => _unzippedFiles.ToArray();\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _canceling = true;\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_canceling))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(sourceFile, zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", e.Message);\n+                }\n+            }\n+\n+            return !_canceling && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceTaskItem\">The original <see cref=\"ITaskItem\"/> containing details about the source file.</param>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ITaskItem sourceTaskItem, ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_canceling))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\n+\n+                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\n+                    // for logging and cancellation, we need to check for it ourselves.\n+                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\n+                    continue;\n+                }\n+                \n+                TaskItem taskItem = new TaskItem(EscapingUtilities.Escape(destinationPath.FullName));\n+\n+                sourceTaskItem.CopyMetadataTo(taskItem);\n+\n+                _destinationFiles.Add(taskItem);",
              "author": {
                "login": "AndyGerlicher"
              }
            },
            {
              "body": "Its what `<Copy />` does so I though I'd ... :expressionless: ... \ud83d\ude0e _copy_ it.\r\n\r\nTechnically you could copy a ton of files as well \r\n\r\n```xml\r\n<ItemGroup>\r\n  <Files Include=\"Folder\\**\" />\r\n</ItemGroup>\r\n\r\n<Copy\r\n  SourceFiles=\"@(Files)\"\r\n  DestinationFolder=\"Foo\"\r\n  />\r\n```\r\n\r\nAnd we'll waste all of the memory.  What should I do?",
              "createdAt": "2018-05-10T20:46:22Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,211 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.ObjectModel;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a collection of all destination files.\n+        /// </summary>\n+        private readonly Collection<ITaskItem> _destinationFiles = new Collection<ITaskItem>();\n+\n+        /// <summary>\n+        /// Stores a collection of all files that were unzipped.\n+        /// </summary>\n+        private readonly Collection<ITaskItem> _unzippedFiles = new Collection<ITaskItem>();\n+\n+        /// <summary>\n+        /// Stores a value indicating if a cancellation was requested.\n+        /// </summary>\n+        private bool _canceling;\n+\n+        /// <summary>\n+        /// Gets an array of <see cref=\"ITaskItem\"/> objects containing details about all of the destination files.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] DestinationFiles => _destinationFiles.ToArray();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets an array of <see cref=\"ITaskItem\"/> objects containing details about only the files that were unzipped.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] UnzippedFiles => _unzippedFiles.ToArray();\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _canceling = true;\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_canceling))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(sourceFile, zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", e.Message);\n+                }\n+            }\n+\n+            return !_canceling && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceTaskItem\">The original <see cref=\"ITaskItem\"/> containing details about the source file.</param>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ITaskItem sourceTaskItem, ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_canceling))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\n+\n+                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\n+                    // for logging and cancellation, we need to check for it ourselves.\n+                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\n+                    continue;\n+                }\n+                \n+                TaskItem taskItem = new TaskItem(EscapingUtilities.Escape(destinationPath.FullName));\n+\n+                sourceTaskItem.CopyMetadataTo(taskItem);\n+\n+                _destinationFiles.Add(taskItem);",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "@jeffkl Would it save memory to make _unzippedFiles and _destinationFiles a collection of tuples of sourceTaskItem and destinationPath.FullName? That way if you access the output properties DestinationFiles or UnzippedFiles you could build the full list of TaskItems on demand?",
              "createdAt": "2018-05-11T15:28:57Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,211 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.ObjectModel;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a collection of all destination files.\n+        /// </summary>\n+        private readonly Collection<ITaskItem> _destinationFiles = new Collection<ITaskItem>();\n+\n+        /// <summary>\n+        /// Stores a collection of all files that were unzipped.\n+        /// </summary>\n+        private readonly Collection<ITaskItem> _unzippedFiles = new Collection<ITaskItem>();\n+\n+        /// <summary>\n+        /// Stores a value indicating if a cancellation was requested.\n+        /// </summary>\n+        private bool _canceling;\n+\n+        /// <summary>\n+        /// Gets an array of <see cref=\"ITaskItem\"/> objects containing details about all of the destination files.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] DestinationFiles => _destinationFiles.ToArray();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets an array of <see cref=\"ITaskItem\"/> objects containing details about only the files that were unzipped.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] UnzippedFiles => _unzippedFiles.ToArray();\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _canceling = true;\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_canceling))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(sourceFile, zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", e.Message);\n+                }\n+            }\n+\n+            return !_canceling && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceTaskItem\">The original <see cref=\"ITaskItem\"/> containing details about the source file.</param>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ITaskItem sourceTaskItem, ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_canceling))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\n+\n+                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\n+                    // for logging and cancellation, we need to check for it ourselves.\n+                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\n+                    continue;\n+                }\n+                \n+                TaskItem taskItem = new TaskItem(EscapingUtilities.Escape(destinationPath.FullName));\n+\n+                sourceTaskItem.CopyMetadataTo(taskItem);\n+\n+                _destinationFiles.Add(taskItem);",
              "author": {
                "login": "CZEMacLeod"
              }
            },
            {
              "body": "We decided to just remove it.  If necessary, we can add the functionality later.",
              "createdAt": "2018-05-11T17:31:08Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,211 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.ObjectModel;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a collection of all destination files.\n+        /// </summary>\n+        private readonly Collection<ITaskItem> _destinationFiles = new Collection<ITaskItem>();\n+\n+        /// <summary>\n+        /// Stores a collection of all files that were unzipped.\n+        /// </summary>\n+        private readonly Collection<ITaskItem> _unzippedFiles = new Collection<ITaskItem>();\n+\n+        /// <summary>\n+        /// Stores a value indicating if a cancellation was requested.\n+        /// </summary>\n+        private bool _canceling;\n+\n+        /// <summary>\n+        /// Gets an array of <see cref=\"ITaskItem\"/> objects containing details about all of the destination files.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] DestinationFiles => _destinationFiles.ToArray();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets an array of <see cref=\"ITaskItem\"/> objects containing details about only the files that were unzipped.\n+        /// </summary>\n+        [Output]\n+        public ITaskItem[] UnzippedFiles => _unzippedFiles.ToArray();\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _canceling = true;\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_canceling))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(sourceFile, zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", e.Message);\n+                }\n+            }\n+\n+            return !_canceling && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceTaskItem\">The original <see cref=\"ITaskItem\"/> containing details about the source file.</param>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ITaskItem sourceTaskItem, ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_canceling))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\n+\n+                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\n+                    // for logging and cancellation, we need to check for it ourselves.\n+                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\n+                    continue;\n+                }\n+                \n+                TaskItem taskItem = new TaskItem(EscapingUtilities.Escape(destinationPath.FullName));\n+\n+                sourceTaskItem.CopyMetadataTo(taskItem);\n+\n+                _destinationFiles.Add(taskItem);",
              "author": {
                "login": "jeffkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm a bit worried about this interface. It's pretty much impossible to get correct incremental behavior out of this. You'd have to:\r\n\r\n* Enumerate the contents of the folder _just before_ the target that invokes `ZipDirectory`.\r\n* Additionally compute a hash of those items to avoid the removed-an-input problem.\r\n* Use the new stuff in the target that calls this.\r\n\r\nAccepting `Item[]` would be more complex in implementation but easier to make correct.",
              "createdAt": "2018-05-14T15:38:44Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1281,6 +1293,15 @@ public partial class XslTransformation : Microsoft.Build.Tasks.TaskExtension\n         public Microsoft.Build.Framework.ITaskItem XslInputPath { get { throw null; } set { } }\n         public override bool Execute() { throw null; }\n     }\n+    public sealed partial class ZipDirectory : Microsoft.Build.Tasks.TaskExtension\n+    {\n+        public ZipDirectory() { }\n+        [Microsoft.Build.Framework.RequiredAttribute]\n+        public Microsoft.Build.Framework.ITaskItem DestinationFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }\n+        [Microsoft.Build.Framework.RequiredAttribute]\n+        public Microsoft.Build.Framework.ITaskItem SourceDirectory { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I discussed this with @AndyGerlicher and we're concerned more about the complexity required to make it incremental out-of-the-box.  So we're going to leave it as-is.",
              "createdAt": "2018-05-14T17:04:17Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1281,6 +1293,15 @@ public partial class XslTransformation : Microsoft.Build.Tasks.TaskExtension\n         public Microsoft.Build.Framework.ITaskItem XslInputPath { get { throw null; } set { } }\n         public override bool Execute() { throw null; }\n     }\n+    public sealed partial class ZipDirectory : Microsoft.Build.Tasks.TaskExtension\n+    {\n+        public ZipDirectory() { }\n+        [Microsoft.Build.Framework.RequiredAttribute]\n+        public Microsoft.Build.Framework.ITaskItem DestinationFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }\n+        [Microsoft.Build.Framework.RequiredAttribute]\n+        public Microsoft.Build.Framework.ITaskItem SourceDirectory { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "I think if we wrote a target that used this we would need to make it incremental. But given that it zips a directory, it doesn't seem worth the complexity to implement at the task level. It might be worth writing a sample in the docs page that is a target that zips your output folder that would be incremental as an example.",
              "createdAt": "2018-05-14T17:06:32Z",
              "path": "ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs",
              "diffHunk": "@@ -1281,6 +1293,15 @@ public partial class XslTransformation : Microsoft.Build.Tasks.TaskExtension\n         public Microsoft.Build.Framework.ITaskItem XslInputPath { get { throw null; } set { } }\n         public override bool Execute() { throw null; }\n     }\n+    public sealed partial class ZipDirectory : Microsoft.Build.Tasks.TaskExtension\n+    {\n+        public ZipDirectory() { }\n+        [Microsoft.Build.Framework.RequiredAttribute]\n+        public Microsoft.Build.Framework.ITaskItem DestinationFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }\n+        [Microsoft.Build.Framework.RequiredAttribute]\n+        public Microsoft.Build.Framework.ITaskItem SourceDirectory { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }",
              "author": {
                "login": "AndyGerlicher"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this not deserve an `Overwrite` param?",
              "createdAt": "2018-05-14T15:42:14Z",
              "path": "src/Tasks/ZipDirectory.cs",
              "diffHunk": "@@ -0,0 +1,47 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class ZipDirectory : TaskExtension\n+    {\n+        [Required]\n+        public ITaskItem DestinationFile { get; set; }\n+\n+        [Required]\n+        public ITaskItem SourceDirectory { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            if (!Directory.Exists(SourceDirectory.ItemSpec))\n+            {\n+                Log.LogErrorFromResources(\"ZipDirectory.ErrorDirectoryDoesNotExist\", SourceDirectory.ItemSpec);\n+                return false;\n+            }\n+\n+            if (File.Exists(DestinationFile.ItemSpec))\n+            {\n+                Log.LogErrorFromResources(\"ZipDirectory.ErrorFileExists\", DestinationFile.ItemSpec);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why not just create? Didn't we make something create instead of erroring in this situation fairly recently?\r\n",
              "createdAt": "2018-05-14T15:42:50Z",
              "path": "src/Tasks/ZipDirectory.cs",
              "diffHunk": "@@ -0,0 +1,47 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class ZipDirectory : TaskExtension\n+    {\n+        [Required]\n+        public ITaskItem DestinationFile { get; set; }\n+\n+        [Required]\n+        public ITaskItem SourceDirectory { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            if (!Directory.Exists(SourceDirectory.ItemSpec))\n+            {\n+                Log.LogErrorFromResources(\"ZipDirectory.ErrorDirectoryDoesNotExist\", SourceDirectory.ItemSpec);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This is the directory to zip up, so it must exist",
              "createdAt": "2018-05-14T16:18:09Z",
              "path": "src/Tasks/ZipDirectory.cs",
              "diffHunk": "@@ -0,0 +1,47 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class ZipDirectory : TaskExtension\n+    {\n+        [Required]\n+        public ITaskItem DestinationFile { get; set; }\n+\n+        [Required]\n+        public ITaskItem SourceDirectory { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            if (!Directory.Exists(SourceDirectory.ItemSpec))\n+            {\n+                Log.LogErrorFromResources(\"ZipDirectory.ErrorDirectoryDoesNotExist\", SourceDirectory.ItemSpec);",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "Yes, that . . . is definitely true \ud83d\ude2c ",
              "createdAt": "2018-05-14T16:23:58Z",
              "path": "src/Tasks/ZipDirectory.cs",
              "diffHunk": "@@ -0,0 +1,47 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class ZipDirectory : TaskExtension\n+    {\n+        [Required]\n+        public ITaskItem DestinationFile { get; set; }\n+\n+        [Required]\n+        public ITaskItem SourceDirectory { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            if (!Directory.Exists(SourceDirectory.ItemSpec))\n+            {\n+                Log.LogErrorFromResources(\"ZipDirectory.ErrorDirectoryDoesNotExist\", SourceDirectory.ItemSpec);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you think this is sufficiently long-running/IO intensive that we should `Yield()` here?",
              "createdAt": "2018-05-14T15:44:40Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,187 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.ObjectModel;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a value indicating if a cancellation was requested.\n+        /// </summary>\n+        private bool _canceling;\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _canceling = true;\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_canceling))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(sourceFile, zipArchive, destinationDirectory);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yeah the zip file could contain a large file, I'll add it",
              "createdAt": "2018-05-14T16:24:49Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,187 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.ObjectModel;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a value indicating if a cancellation was requested.\n+        /// </summary>\n+        private bool _canceling;\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _canceling = true;\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_canceling))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(sourceFile, zipArchive, destinationDirectory);",
              "author": {
                "login": "jeffkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this used?",
              "createdAt": "2018-05-14T15:46:53Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,187 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.ObjectModel;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a value indicating if a cancellation was requested.\n+        /// </summary>\n+        private bool _canceling;\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _canceling = true;\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_canceling))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(sourceFile, zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\n+                }\n+            }\n+\n+            return !_canceling && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceTaskItem\">The original <see cref=\"ITaskItem\"/> containing details about the source file.</param>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I was at one point, good catch",
              "createdAt": "2018-05-14T16:28:20Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,187 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.ObjectModel;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a value indicating if a cancellation was requested.\n+        /// </summary>\n+        private bool _canceling;\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _canceling = true;\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_canceling))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(sourceFile, zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\n+                }\n+            }\n+\n+            return !_canceling && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceTaskItem\">The original <see cref=\"ITaskItem\"/> containing details about the source file.</param>",
              "author": {
                "login": "jeffkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Worth using the `CopyToAsync` overload that takes a `CancellationToken` to speed up canceling if we're stuck in a huge file? Possibly not . . .",
              "createdAt": "2018-05-14T15:49:39Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,187 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.ObjectModel;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a value indicating if a cancellation was requested.\n+        /// </summary>\n+        private bool _canceling;\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _canceling = true;\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_canceling))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(sourceFile, zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\n+                }\n+            }\n+\n+            return !_canceling && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceTaskItem\">The original <see cref=\"ITaskItem\"/> containing details about the source file.</param>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ITaskItem sourceTaskItem, ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_canceling))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\n+\n+                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\n+                    // for logging and cancellation, we need to check for it ourselves.\n+                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\n+                    continue;\n+                }\n+                \n+                if (ShouldSkipEntry(zipArchiveEntry, destinationPath))\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Low, \"Unzip.DidNotUnzipBecauseOfFileMatch\", zipArchiveEntry.FullName, destinationPath.FullName, nameof(SkipUnchangedFiles), \"true\");\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    destinationPath.Directory?.Create();\n+                }\n+                catch (Exception e)\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", destinationPath.DirectoryName, e.Message);\n+                    continue;\n+                }\n+\n+                if (OverwriteReadOnlyFiles && destinationPath.Exists && destinationPath.IsReadOnly)\n+                {\n+                    try\n+                    {\n+                        destinationPath.IsReadOnly = false;\n+                    }\n+                    catch (Exception e)\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotMakeFileWriteable\", zipArchiveEntry.FullName, destinationPath.FullName, e.Message);\n+                        continue;\n+                    }\n+                }\n+\n+                try\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Normal, \"Unzip.FileComment\", zipArchiveEntry.FullName, destinationPath.FullName);\n+                    \n+                    using (Stream destination = File.Open(destinationPath.FullName, FileMode.Create, FileAccess.Write, FileShare.None))\n+                    using (Stream stream = zipArchiveEntry.Open())\n+                    {\n+                        stream.CopyTo(destination);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Make this a `CancellationTokenSource` instead and pass around a `CancellationToken`?",
              "createdAt": "2018-05-14T15:52:46Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,187 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.Collections.ObjectModel;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a value indicating if a cancellation was requested.\n+        /// </summary>\n+        private bool _canceling;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Don't forget to manually port these to the internal VS repo after this merges.",
              "createdAt": "2018-05-15T14:37:06Z",
              "path": "src/MSBuild/Microsoft.Build.CommonTypes.xsd",
              "diffHunk": "@@ -5114,6 +5114,21 @@ elementFormDefault=\"qualified\">\n         </xs:complexType>\n     </xs:element>\n \n+    <xs:element name=\"Unzip\" substitutionGroup=\"msb:Task\">",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Use\r\n\r\n```c#\r\n[PlatformSpecific(TestPlatforms.Windows)]\r\n```\r\n\r\ninstead.",
              "createdAt": "2018-05-15T14:39:34Z",
              "path": "src/Tasks.UnitTests/Unzip_Tests.cs",
              "diffHunk": "@@ -0,0 +1,163 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using System.IO;\n+using Xunit;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class Unzip_Tests\n+    {\n+        private readonly MockEngine _mockEngine = new MockEngine();\n+\n+        [Fact]\n+        public void CanOverwriteReadOnlyFile()\n+        {\n+            using (TestEnvironment testEnvironment = TestEnvironment.Create())\n+            {\n+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);\n+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);\n+                TransientTestFile file1 = testEnvironment.CreateFile(source, \"638AF4AE88A146E09CB69FE1CA7083DC.txt\", \"file1\");\n+\n+                new FileInfo(file1.Path).IsReadOnly = true;\n+\n+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, destination);\n+\n+                Unzip unzip = new Unzip\n+                {\n+                    BuildEngine = _mockEngine,\n+                    DestinationFolder = new TaskItem(source.FolderPath),\n+                    OverwriteReadOnlyFiles = true,\n+                    SkipUnchangedFiles = false,\n+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) }\n+                };\n+\n+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);\n+\n+                _mockEngine.Log.ShouldContain(\"638AF4AE88A146E09CB69FE1CA7083DC\", () => _mockEngine.Log);\n+            }\n+        }\n+\n+        [Fact]\n+        public void CanUnzip()\n+        {\n+            using (TestEnvironment testEnvironment = TestEnvironment.Create())\n+            {\n+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);\n+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);\n+                testEnvironment.CreateFile(source, \"BE78A17D30144B549D21F71D5C633F7D.txt\", \"file1\");\n+                testEnvironment.CreateFile(source, \"A04FF4B88DF14860B7C73A8E75A4FB76.txt\", \"file2\");\n+\n+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));\n+\n+                Unzip unzip = new Unzip\n+                {\n+                    BuildEngine = _mockEngine,\n+                    DestinationFolder = new TaskItem(destination.FolderPath),\n+                    OverwriteReadOnlyFiles = true,\n+                    SkipUnchangedFiles = false,\n+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) }\n+                };\n+\n+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);\n+\n+                _mockEngine.Log.ShouldContain(Path.Combine(destination.FolderPath, \"BE78A17D30144B549D21F71D5C633F7D.txt\"), () => _mockEngine.Log);\n+                _mockEngine.Log.ShouldContain(Path.Combine(destination.FolderPath, \"A04FF4B88DF14860B7C73A8E75A4FB76.txt\"), () => _mockEngine.Log);\n+            }\n+        }\n+\n+#if  RUNTIME_TYPE_NETCORE\n+        [Fact(Skip = \"Can't figure out how to make CreateDirectory throw on non-Windows\")]",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why not eagerly exit to reduce the time it takes to finish the build on error?",
              "createdAt": "2018-05-16T22:15:59Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _cancellationToken.Cancel();\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            BuildEngine3.Yield();\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Ah, to show all errors at once rather than one at a time. The alternative is to complicate things and check everything first, and do the extraction second.\r\n\r\n---\r\nIn reply to: [188788554](https://github.com/Microsoft/msbuild/pull/3291#discussion_r188788554) [](ancestors = 188788554)",
              "createdAt": "2018-05-16T22:25:33Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _cancellationToken.Cancel();\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            BuildEngine3.Yield();\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't Reacquire be in a finally block? Or does the engine handle this?",
              "createdAt": "2018-05-16T22:18:56Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _cancellationToken.Cancel();\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            BuildEngine3.Yield();\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (OperationCanceledException)\n+                {\n+                    break;\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\n+                }\n+            }\n+\n+            BuildEngine3.Reacquire();",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What happens if there's files in multiple archives with the same path? Should there be an option to warn or error about this?",
              "createdAt": "2018-05-16T22:28:33Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I think its okay to just ignore it, do you want me to log something?",
              "createdAt": "2018-05-21T14:53:24Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "I guess people can use the diagnostic log to see the task inputs, so I guess they already have insight into the sources.",
              "createdAt": "2018-05-22T16:23:34Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should it be made readonly after the write to preserve user data? :)",
              "createdAt": "2018-05-16T22:31:17Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _cancellationToken.Cancel();\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            BuildEngine3.Yield();\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (OperationCanceledException)\n+                {\n+                    break;\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\n+                }\n+            }\n+\n+            BuildEngine3.Reacquire();\n+\n+            return !_cancellationToken.IsCancellationRequested && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\n+\n+                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\n+                    // for logging and cancellation, we need to check for it ourselves.\n+                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\n+                    continue;\n+                }\n+\n+                if (ShouldSkipEntry(zipArchiveEntry, destinationPath))\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Low, \"Unzip.DidNotUnzipBecauseOfFileMatch\", zipArchiveEntry.FullName, destinationPath.FullName, nameof(SkipUnchangedFiles), \"true\");\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    destinationPath.Directory?.Create();\n+                }\n+                catch (Exception e)\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", destinationPath.DirectoryName, e.Message);\n+                    continue;\n+                }\n+\n+                if (OverwriteReadOnlyFiles && destinationPath.Exists && destinationPath.IsReadOnly)\n+                {\n+                    try\n+                    {\n+                        destinationPath.IsReadOnly = false;",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I'm not sure.  I'd assume that if the file is readonly in the archive it should be readonly after extraction but I don't see attributes like that in the `ZipArchiveEntry` class...  It seems a little weird to be setting the readonly attribute based on what the file _used_ to have.  Thoughts?",
              "createdAt": "2018-05-21T14:56:55Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _cancellationToken.Cancel();\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            BuildEngine3.Yield();\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (OperationCanceledException)\n+                {\n+                    break;\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\n+                }\n+            }\n+\n+            BuildEngine3.Reacquire();\n+\n+            return !_cancellationToken.IsCancellationRequested && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\n+\n+                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\n+                    // for logging and cancellation, we need to check for it ourselves.\n+                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\n+                    continue;\n+                }\n+\n+                if (ShouldSkipEntry(zipArchiveEntry, destinationPath))\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Low, \"Unzip.DidNotUnzipBecauseOfFileMatch\", zipArchiveEntry.FullName, destinationPath.FullName, nameof(SkipUnchangedFiles), \"true\");\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    destinationPath.Directory?.Create();\n+                }\n+                catch (Exception e)\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", destinationPath.DirectoryName, e.Message);\n+                    continue;\n+                }\n+\n+                if (OverwriteReadOnlyFiles && destinationPath.Exists && destinationPath.IsReadOnly)\n+                {\n+                    try\n+                    {\n+                        destinationPath.IsReadOnly = false;",
              "author": {
                "login": "jeffkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: named constant for the buffer size.",
              "createdAt": "2018-05-16T22:32:36Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _cancellationToken.Cancel();\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            BuildEngine3.Yield();\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (OperationCanceledException)\n+                {\n+                    break;\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\n+                }\n+            }\n+\n+            BuildEngine3.Reacquire();\n+\n+            return !_cancellationToken.IsCancellationRequested && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\n+\n+                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\n+                    // for logging and cancellation, we need to check for it ourselves.\n+                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\n+                    continue;\n+                }\n+\n+                if (ShouldSkipEntry(zipArchiveEntry, destinationPath))\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Low, \"Unzip.DidNotUnzipBecauseOfFileMatch\", zipArchiveEntry.FullName, destinationPath.FullName, nameof(SkipUnchangedFiles), \"true\");\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    destinationPath.Directory?.Create();\n+                }\n+                catch (Exception e)\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", destinationPath.DirectoryName, e.Message);\n+                    continue;\n+                }\n+\n+                if (OverwriteReadOnlyFiles && destinationPath.Exists && destinationPath.IsReadOnly)\n+                {\n+                    try\n+                    {\n+                        destinationPath.IsReadOnly = false;\n+                    }\n+                    catch (Exception e)\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotMakeFileWriteable\", zipArchiveEntry.FullName, destinationPath.FullName, e.Message);\n+                        continue;\n+                    }\n+                }\n+\n+                try\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Normal, \"Unzip.FileComment\", zipArchiveEntry.FullName, destinationPath.FullName);\n+\n+                    using (Stream destination = File.Open(destinationPath.FullName, FileMode.Create, FileAccess.Write, FileShare.None))\n+                    using (Stream stream = zipArchiveEntry.Open())\n+                    {\n+                        stream.CopyToAsync(destination, 81920, _cancellationToken.Token);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The other task wraps each IO in a try catch. Should this one be wrapped too?",
              "createdAt": "2018-05-16T22:37:36Z",
              "path": "src/Tasks/ZipDirectory.cs",
              "diffHunk": "@@ -0,0 +1,67 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class ZipDirectory : TaskExtension\n+    {\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> containing the full path to the destination file to create.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFile { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating if the destination file should be overwritten.\n+        /// </summary>\n+        public bool Overwrite { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> containing the full path to the source directory to create a zip archive from.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem SourceDirectory { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            DirectoryInfo sourceDirectory = new DirectoryInfo(SourceDirectory.ItemSpec);\n+\n+            if (!sourceDirectory.Exists)\n+            {\n+                Log.LogErrorFromResources(\"ZipDirectory.ErrorDirectoryDoesNotExist\", sourceDirectory.FullName);\n+                return false;\n+            }\n+\n+            FileInfo destinationFile = new FileInfo(DestinationFile.ItemSpec);\n+\n+            if (destinationFile.Exists)\n+            {\n+                if(!Overwrite)\n+                {\n+                    Log.LogErrorFromResources(\"ZipDirectory.ErrorFileExists\", destinationFile.FullName);\n+\n+                    return false;\n+                }\n+\n+                File.Delete(destinationFile.FullName);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't the returned task be awaited before the entire task returns?",
              "createdAt": "2018-05-16T22:55:13Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _cancellationToken.Cancel();\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            BuildEngine3.Yield();\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (OperationCanceledException)\n+                {\n+                    break;\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\n+                }\n+            }\n+\n+            BuildEngine3.Reacquire();\n+\n+            return !_cancellationToken.IsCancellationRequested && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\n+\n+                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\n+                    // for logging and cancellation, we need to check for it ourselves.\n+                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\n+                    continue;\n+                }\n+\n+                if (ShouldSkipEntry(zipArchiveEntry, destinationPath))\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Low, \"Unzip.DidNotUnzipBecauseOfFileMatch\", zipArchiveEntry.FullName, destinationPath.FullName, nameof(SkipUnchangedFiles), \"true\");\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    destinationPath.Directory?.Create();\n+                }\n+                catch (Exception e)\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", destinationPath.DirectoryName, e.Message);\n+                    continue;\n+                }\n+\n+                if (OverwriteReadOnlyFiles && destinationPath.Exists && destinationPath.IsReadOnly)\n+                {\n+                    try\n+                    {\n+                        destinationPath.IsReadOnly = false;\n+                    }\n+                    catch (Exception e)\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotMakeFileWriteable\", zipArchiveEntry.FullName, destinationPath.FullName, e.Message);\n+                        continue;\n+                    }\n+                }\n+\n+                try\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Normal, \"Unzip.FileComment\", zipArchiveEntry.FullName, destinationPath.FullName);\n+\n+                    using (Stream destination = File.Open(destinationPath.FullName, FileMode.Create, FileAccess.Write, FileShare.None))\n+                    using (Stream stream = zipArchiveEntry.Open())\n+                    {\n+                        stream.CopyToAsync(destination, 81920, _cancellationToken.Token);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Curious what happens if another file exists in the destination and is longer than the archive entry. Does this override or does it just copy over the source stream, leaving some trailing bytes from the destination? The CopyTo documentation is a bit unclear on this.",
              "createdAt": "2018-05-16T22:58:20Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _cancellationToken.Cancel();\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            BuildEngine3.Yield();\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (OperationCanceledException)\n+                {\n+                    break;\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\n+                }\n+            }\n+\n+            BuildEngine3.Reacquire();\n+\n+            return !_cancellationToken.IsCancellationRequested && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\n+\n+                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\n+                    // for logging and cancellation, we need to check for it ourselves.\n+                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\n+                    continue;\n+                }\n+\n+                if (ShouldSkipEntry(zipArchiveEntry, destinationPath))\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Low, \"Unzip.DidNotUnzipBecauseOfFileMatch\", zipArchiveEntry.FullName, destinationPath.FullName, nameof(SkipUnchangedFiles), \"true\");\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    destinationPath.Directory?.Create();\n+                }\n+                catch (Exception e)\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", destinationPath.DirectoryName, e.Message);\n+                    continue;\n+                }\n+\n+                if (OverwriteReadOnlyFiles && destinationPath.Exists && destinationPath.IsReadOnly)\n+                {\n+                    try\n+                    {\n+                        destinationPath.IsReadOnly = false;\n+                    }\n+                    catch (Exception e)\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotMakeFileWriteable\", zipArchiveEntry.FullName, destinationPath.FullName, e.Message);\n+                        continue;\n+                    }\n+                }\n+\n+                try\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Normal, \"Unzip.FileComment\", zipArchiveEntry.FullName, destinationPath.FullName);\n+\n+                    using (Stream destination = File.Open(destinationPath.FullName, FileMode.Create, FileAccess.Write, FileShare.None))\n+                    using (Stream stream = zipArchiveEntry.Open())\n+                    {\n+                        stream.CopyToAsync(destination, 81920, _cancellationToken.Token);",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Oh, did not notice the FileMode.Create. Nevermind.\r\n\r\n---\r\nIn reply to: [188796551](https://github.com/Microsoft/msbuild/pull/3291#discussion_r188796551) [](ancestors = 188796551)",
              "createdAt": "2018-05-16T22:59:50Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,193 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _cancellationToken.Cancel();\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            BuildEngine3.Yield();\n+\n+            foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                if (!File.Exists(sourceFile.ItemSpec))\n+                {\n+                    Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                    {\n+                        using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                        {\n+                            try\n+                            {\n+                                Extract(zipArchive, destinationDirectory);\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                // Unhandled exception in Extract() is a bug!\n+                                Log.LogErrorFromException(e, showStackTrace: true);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                catch (OperationCanceledException)\n+                {\n+                    break;\n+                }\n+                catch (Exception e)\n+                {\n+                    // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                    Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\n+                }\n+            }\n+\n+            BuildEngine3.Reacquire();\n+\n+            return !_cancellationToken.IsCancellationRequested && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));\n+\n+                if (!destinationPath.FullName.StartsWith(destinationDirectory.FullName, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    // ExtractToDirectory() throws an IOException for this but since we're extracting one file at a time\n+                    // for logging and cancellation, we need to check for it ourselves.\n+                    Log.LogErrorFromResources(\"Unzip.ErrorExtractingResultsInFilesOutsideDestination\", destinationPath.FullName, destinationDirectory.FullName);\n+                    continue;\n+                }\n+\n+                if (ShouldSkipEntry(zipArchiveEntry, destinationPath))\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Low, \"Unzip.DidNotUnzipBecauseOfFileMatch\", zipArchiveEntry.FullName, destinationPath.FullName, nameof(SkipUnchangedFiles), \"true\");\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    destinationPath.Directory?.Create();\n+                }\n+                catch (Exception e)\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", destinationPath.DirectoryName, e.Message);\n+                    continue;\n+                }\n+\n+                if (OverwriteReadOnlyFiles && destinationPath.Exists && destinationPath.IsReadOnly)\n+                {\n+                    try\n+                    {\n+                        destinationPath.IsReadOnly = false;\n+                    }\n+                    catch (Exception e)\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"Unzip.ErrorCouldNotMakeFileWriteable\", zipArchiveEntry.FullName, destinationPath.FullName, e.Message);\n+                        continue;\n+                    }\n+                }\n+\n+                try\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Normal, \"Unzip.FileComment\", zipArchiveEntry.FullName, destinationPath.FullName);\n+\n+                    using (Stream destination = File.Open(destinationPath.FullName, FileMode.Create, FileAccess.Write, FileShare.None))\n+                    using (Stream stream = zipArchiveEntry.Open())\n+                    {\n+                        stream.CopyToAsync(destination, 81920, _cancellationToken.Token);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you please make this yieldable as well?",
              "createdAt": "2018-05-22T16:33:05Z",
              "path": "src/Tasks/ZipDirectory.cs",
              "diffHunk": "@@ -0,0 +1,76 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class ZipDirectory : TaskExtension\n+    {\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> containing the full path to the destination file to create.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFile { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating if the destination file should be overwritten.\n+        /// </summary>\n+        public bool Overwrite { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> containing the full path to the source directory to create a zip archive from.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem SourceDirectory { get; set; }\n+\n+        public override bool Execute()",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Sorry to comment after you've just merged, but would you consider normalizing directory separators? One of the most common errors I've encountered is that zips created on Windows using `\\` as a directory separator will not extract correctly on Linux/macOS. Instead `\\` becomes part of the filename.\r\n![image](https://user-images.githubusercontent.com/2696087/40389159-71632bd8-5dc6-11e8-9da8-f58484b39d3c.png)\r\n\r\nThis common error is something we worked around in the unzip task used in the .NET Core build system: see https://github.com/dotnet/arcade/blob/0d117c0b3649565a6d9aacf9f435e29ab67c3c0d/src/Microsoft.DotNet.Build.Tasks.IO/src/UnzipArchive.cs#L64-L76\r\n\r\n",
              "createdAt": "2018-05-22T20:48:21Z",
              "path": "src/Tasks/Unzip.cs",
              "diffHunk": "@@ -0,0 +1,206 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+using System.Linq;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that can extract a .zip archive.\n+    /// </summary>\n+    public sealed class Unzip : TaskExtension, ICancelableTask\n+    {\n+        // We pick a value that is the largest multiple of 4096 that is still smaller than the large object heap threshold (85K).\n+        // The CopyTo/CopyToAsync buffer is short-lived and is likely to be collected at Gen0, and it offers a significant\n+        // improvement in Copy performance.\n+        private const int _DefaultCopyBufferSize = 81920;\n+\n+        /// <summary>\n+        /// Stores a <see cref=\"CancellationTokenSource\"/> used for cancellation.\n+        /// </summary>\n+        private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> with a destination folder path to unzip the files to.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFolder { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether read-only files should be overwritten.\n+        /// </summary>\n+        public bool OverwriteReadOnlyFiles { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating whether files should be skipped if the destination is unchanged.\n+        /// </summary>\n+        public bool SkipUnchangedFiles { get; set; } = true;\n+\n+        /// <summary>\n+        /// Gets or sets an array of <see cref=\"ITaskItem\"/> objects containing the paths to .zip archive files to unzip.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem[] SourceFiles { get; set; }\n+\n+        /// <inheritdoc cref=\"ICancelableTask.Cancel\"/>\n+        public void Cancel()\n+        {\n+            _cancellationToken.Cancel();\n+        }\n+\n+        /// <inheritdoc cref=\"Task.Execute\"/>\n+        public override bool Execute()\n+        {\n+            DirectoryInfo destinationDirectory;\n+            try\n+            {\n+                destinationDirectory = Directory.CreateDirectory(DestinationFolder.ItemSpec);\n+            }\n+            catch (Exception e)\n+            {\n+                Log.LogErrorFromResources(\"Unzip.ErrorCouldNotCreateDestinationDirectory\", DestinationFolder.ItemSpec, e.Message);\n+\n+                return false;\n+            }\n+\n+            BuildEngine3.Yield();\n+\n+            try\n+            {\n+                foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+                {\n+                    if (!File.Exists(sourceFile.ItemSpec))\n+                    {\n+                        Log.LogErrorFromResources(\"Unzip.ErrorFileDoesNotExist\", sourceFile.ItemSpec);\n+                        continue;\n+                    }\n+\n+                    try\n+                    {\n+                        using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))\n+                        {\n+                            using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))\n+                            {\n+                                try\n+                                {\n+                                    Extract(zipArchive, destinationDirectory);\n+                                }\n+                                catch (Exception e)\n+                                {\n+                                    // Unhandled exception in Extract() is a bug!\n+                                    Log.LogErrorFromException(e, showStackTrace: true);\n+                                    return false;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    catch (OperationCanceledException)\n+                    {\n+                        break;\n+                    }\n+                    catch (Exception e)\n+                    {\n+                        // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)\n+                        Log.LogErrorFromResources(\"Unzip.ErrorCouldNotOpenFile\", sourceFile.ItemSpec, e.Message);\n+                    }\n+                }\n+            }\n+            finally\n+            {\n+                BuildEngine3.Reacquire();\n+            }\n+\n+            return !_cancellationToken.IsCancellationRequested && !Log.HasLoggedErrors;\n+        }\n+\n+        /// <summary>\n+        /// Extracts all files to the specified directory.\n+        /// </summary>\n+        /// <param name=\"sourceArchive\">The <see cref=\"ZipArchive\"/> containing the files to extract.</param>\n+        /// <param name=\"destinationDirectory\">The <see cref=\"DirectoryInfo\"/> to extract files to.</param>\n+        private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory)\n+        {\n+            foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))\n+            {\n+                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));",
              "author": {
                "login": "natemcmaster"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think need make the \"includeBaseDirectory\" argment as an option",
              "createdAt": "2023-11-04T07:34:45Z",
              "path": "src/Tasks/ZipDirectory.cs",
              "diffHunk": "@@ -0,0 +1,85 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Framework;\n+using System;\n+using System.IO;\n+using System.IO.Compression;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class ZipDirectory : TaskExtension\n+    {\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> containing the full path to the destination file to create.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem DestinationFile { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a value indicating if the destination file should be overwritten.\n+        /// </summary>\n+        public bool Overwrite { get; set; }\n+\n+        /// <summary>\n+        /// Gets or sets a <see cref=\"ITaskItem\"/> containing the full path to the source directory to create a zip archive from.\n+        /// </summary>\n+        [Required]\n+        public ITaskItem SourceDirectory { get; set; }\n+\n+        public override bool Execute()\n+        {\n+            DirectoryInfo sourceDirectory = new DirectoryInfo(SourceDirectory.ItemSpec);\n+\n+            if (!sourceDirectory.Exists)\n+            {\n+                Log.LogErrorFromResources(\"ZipDirectory.ErrorDirectoryDoesNotExist\", sourceDirectory.FullName);\n+                return false;\n+            }\n+\n+            FileInfo destinationFile = new FileInfo(DestinationFile.ItemSpec);\n+\n+            BuildEngine3.Yield();\n+\n+            try\n+            {\n+                if (destinationFile.Exists)\n+                {\n+                    if (!Overwrite)\n+                    {\n+                        Log.LogErrorFromResources(\"ZipDirectory.ErrorFileExists\", destinationFile.FullName);\n+\n+                        return false;\n+                    }\n+\n+                    try\n+                    {\n+                        File.Delete(destinationFile.FullName);\n+                    }\n+                    catch (Exception e)\n+                    {\n+                        Log.LogErrorFromResources(\"ZipDirectory.ErrorFailed\", sourceDirectory.FullName, destinationFile.FullName, e.Message);\n+\n+                        return false;\n+                    }\n+                }\n+\n+                try\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.High, \"ZipDirectory.Comment\", sourceDirectory.FullName, destinationFile.FullName);\n+                    ZipFile.CreateFromDirectory(sourceDirectory.FullName, destinationFile.FullName);",
              "author": {
                "login": "Flithor"
              }
            }
          ]
        }
      }
    ]
  }
}