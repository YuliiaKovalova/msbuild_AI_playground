{
  "number": 10502,
  "title": "Extract EnvVariable check invocation from ProcessEvaluationFinishedEventArgs + add Build check events to binglog",
  "body": "Fixes #10431\r\n\r\n### Context\r\nWhen Property is defined inside of the target, it gets evaluated during the [IntrinsicTask](https://github.com/dotnet/msbuild/blob/2f39510e2abb49b27dcb11122088a678c51288cc/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs#L68) execution, and that happens **after** [ProjectEvaluationFinishedEventArgs](https://github.com/dotnet/msbuild/blob/2f39510e2abb49b27dcb11122088a678c51288cc/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs#L62)\r\n\r\n### Changes Made\r\nExtract EnvVariable check invocation from ProcessEvaluationFinishedEventArgs, but make reporting delayed due to dependency on scoping\r\n\r\n### Testing\r\nextended existing e2e tests\r\n",
  "state": "MERGED",
  "createdAt": "2024-08-08T15:55:14Z",
  "updatedAt": "2024-08-20T08:41:44Z",
  "closedAt": "2024-08-20T08:41:44Z",
  "mergedAt": "2024-08-20T08:41:44Z",
  "additions": 421,
  "deletions": 199,
  "changedFiles": 26,
  "headRefName": "dev/ykovalova/fix_missed_reports_for_envvar_check",
  "isDraft": false,
  "author": {
    "login": "YuliiaKovalova"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "acfd275a6fc4960849beb584c7c6cca7b0ba653d",
          "message": "add ProjectIntrinsicTasksExecutionFinishedEventArgs",
          "committedDate": "2024-08-08T15:48:38Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "81571b8d3b56d9444778529750ddb5e7c05f6d54",
          "message": "Merge branch 'main' into dev/ykovalova/fix_missed_reports_for_envvar_check",
          "committedDate": "2024-08-08T17:37:46Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b4f8ae20793be7010753ee47c251522933c63ffd",
          "message": "Revert \"add ProjectIntrinsicTasksExecutionFinishedEventArgs\"\n\nThis reverts commit acfd275a6fc4960849beb584c7c6cca7b0ba653d.",
          "committedDate": "2024-08-09T10:23:05Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "07c15ead44fedc1f1a04501b4a7a0ba30deccf13",
          "message": "merge",
          "committedDate": "2024-08-09T10:23:42Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1825d895e244f35396249854eafbb78d2b7f1c08",
          "message": "split reporting on env variable used with ProcessEvaluationFinishedEventArgs",
          "committedDate": "2024-08-09T11:05:45Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "63d56c68aed478dd3db6d4140215801eae6458ca",
          "message": "Merge branch 'main' into dev/ykovalova/fix_missed_reports_for_envvar_check",
          "committedDate": "2024-08-09T11:09:04Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "946f750f228275880b55a96f03f7ff7cbaed6a59",
          "message": "add information about new records to BinaryLogger",
          "committedDate": "2024-08-09T11:19:42Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "29b5776227e9df1b09a63e7af302321d1b81a8f2",
          "message": "fix missed case with scoping",
          "committedDate": "2024-08-12T09:20:38Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "48de04c7b014e3dceb75dd522f2374d54753d2d3",
          "message": "merge",
          "committedDate": "2024-08-12T09:40:40Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8398f15b597c45b729ede285ca1ad94e89b52fbb",
          "message": "cover case with e2e tests",
          "committedDate": "2024-08-12T13:33:49Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ff0c4404a7a509ec95c68cf4d51d6dac017798a2",
          "message": "fix reporting to binlog",
          "committedDate": "2024-08-13T16:07:40Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c02056bbe804da528d85b1535101d564849d3f1a",
          "message": "Merge branch 'main' into dev/ykovalova/fix_missed_reports_for_envvar_check",
          "committedDate": "2024-08-13T16:08:08Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "67e4f57a48bf8423bf24838c0f46848d89083535",
          "message": "fix review comments",
          "committedDate": "2024-08-14T10:43:51Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e6b9d8523d2b1243b0c1992aba4097ae6d17525a",
          "message": "Merge branch 'dev/ykovalova/fix_missed_reports_for_envvar_check' of https://github.com/YuliiaKovalova/msbuild into dev/ykovalova/fix_missed_reports_for_envvar_check",
          "committedDate": "2024-08-14T10:48:46Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f43a519099fc87bb74e19fb0527bad97110acf82",
          "message": "tune condition",
          "committedDate": "2024-08-14T11:12:34Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b2b179a06160ce31a2bfd05b83de5f793a1e47b5",
          "message": "fix tests",
          "committedDate": "2024-08-14T11:55:34Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c8a6662dc8c705488e511f0ff523cbacc0b5660a",
          "message": "undo changes in else",
          "committedDate": "2024-08-14T11:58:35Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "95e2bcb842dacc3bbe6aa9f6409fa76c7eaeb312",
          "message": "fix review comments",
          "committedDate": "2024-08-15T12:04:02Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b298ff90f09ca430d86fa5d1e699dcb359482dd1",
          "message": "Merge remote-tracking branch 'origin/main' into dev/ykovalova/fix_missed_reports_for_envvar_check",
          "committedDate": "2024-08-16T06:20:45Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f0fedb2fb89f1ced34a73a48021db0e79d7fe422",
          "message": "add event on scoping readiness in FileClassifier and other fixes",
          "committedDate": "2024-08-16T14:05:28Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "12b0227884956e4b71c0662683eae87313d9a32c",
          "message": "fix review comments",
          "committedDate": "2024-08-19T14:15:15Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "73e3e73df1b5918b9752736c3717199eda20ac89",
          "message": "fix review comments",
          "committedDate": "2024-08-19T18:36:29Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we use [IMSBuildElementLocation](https://github.com/dotnet/msbuild/blob/b7e76d1d171ef74adec2f3b5e79a5b586a7e7020/src/Shared/IElementLocation.cs#L23) here?",
              "createdAt": "2024-08-11T10:58:05Z",
              "path": "src/Build/BuildCheck/OM/EnvironmentVariableCheckData.cs",
              "diffHunk": "@@ -0,0 +1,23 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck;\n+\n+/// <summary>\n+/// BuildCheck OM data representing the environment variables used in a project file and its imports.\n+/// </summary>\n+public class EnvironmentVariableCheckData : CheckData\n+{\n+    internal EnvironmentVariableCheckData(\n+        string projectFilePath,\n+        int? projectConfigurationId,\n+        IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)> evaluatedEnvironmentVariables)\n+        : base(projectFilePath, projectConfigurationId) => EvaluatedEnvironmentVariables = evaluatedEnvironmentVariables;\n+\n+    /// <summary>\n+    /// Gets the evaluated environment variables and their metadata.\n+    /// </summary>\n+    public IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)> EvaluatedEnvironmentVariables { get; }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\u2764\ufe0f ",
              "createdAt": "2024-08-11T10:58:56Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -76,8 +76,9 @@ public sealed class BinaryLogger : ILogger\n         // version 22:\n         //    - extend EnvironmentVariableRead with location where environment variable was used.\n         // version 23:\n-        //    - new record kind: BuildSubmissionStartedEventArgs\n-        // This should be never changed.\n+        //    - new record kinds: BuildCheckMessageEvent, BuildCheckWarningEvent, BuildCheckErrorEvent,\n+        //    BuildCheckTracingEvent, BuildCheckAcquisitionEvent, BuildSubmissionStartedEvent",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The else part of this check pushes the data into the stack even if we already know we are not interested in data",
              "createdAt": "2024-08-13T16:33:17Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,39 +44,53 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += (string? projectFilePath) =>\n+        {\n+            while (_buildCheckResults.Count > 0)\n+            {\n+                BuildCheckResult result = _buildCheckResults.Pop();\n+                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, result.Location.File, projectFilePath ?? string.Empty))\n+                {\n+                    continue;\n+                }\n+\n+                _dataContext?.ReportResult(result);\n+            }\n+        };\n     }\n \n-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);\n \n-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)\n     {\n         if (context.Data.EvaluatedEnvironmentVariables.Count != 0)\n         {\n-            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)\n+            foreach (KeyValuePair<string, (string EnvVarValue, IMSBuildElementLocation Location)> envVariableData in context.Data.EvaluatedEnvironmentVariables)\n             {\n-                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.File,\n-                        context.Data.ProjectFilePath))\n-                {\n-                    continue;\n-                }\n-                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);\n+                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.Location);\n                 if (!_environmentVariablesReported.Contains(identityKey))\n                 {\n-                    if (_isVerboseEnvVarOutput)\n+                    string buildCheckResultMessageArgs = _isVerboseEnvVarOutput ? $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\" : $\"'{envVariableData.Key}'\";\n+\n+                    // Scope information is available after evaluation of the project file. If it is not ready, we will report the check later.\n+                    if (CheckScopeClassifier.IsScopingReady && CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.Location.File, context.Data.ProjectFilePath ?? string.Empty))",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Btw. it'd be bit hacky - but would improve perf significantly - how about resorting to stacking only if Scoping is set to `EvaluationCheckScope.WorkTreeImports`?\r\n\r\nIt is internal builtin check implementation - so we can afford count on internal behavior.\r\n\r\nAlternatively the `IsScopingReady` can be a function taking the scope parameter (as for some scopes the classifier is ready immediately)",
              "createdAt": "2024-08-13T17:09:34Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,39 +44,53 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += (string? projectFilePath) =>\n+        {\n+            while (_buildCheckResults.Count > 0)\n+            {\n+                BuildCheckResult result = _buildCheckResults.Pop();\n+                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, result.Location.File, projectFilePath ?? string.Empty))\n+                {\n+                    continue;\n+                }\n+\n+                _dataContext?.ReportResult(result);\n+            }\n+        };\n     }\n \n-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);\n \n-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)\n     {\n         if (context.Data.EvaluatedEnvironmentVariables.Count != 0)\n         {\n-            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)\n+            foreach (KeyValuePair<string, (string EnvVarValue, IMSBuildElementLocation Location)> envVariableData in context.Data.EvaluatedEnvironmentVariables)\n             {\n-                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.File,\n-                        context.Data.ProjectFilePath))\n-                {\n-                    continue;\n-                }\n-                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);\n+                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.Location);\n                 if (!_environmentVariablesReported.Contains(identityKey))\n                 {\n-                    if (_isVerboseEnvVarOutput)\n+                    string buildCheckResultMessageArgs = _isVerboseEnvVarOutput ? $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\" : $\"'{envVariableData.Key}'\";\n+\n+                    // Scope information is available after evaluation of the project file. If it is not ready, we will report the check later.\n+                    if (CheckScopeClassifier.IsScopingReady && CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.Location.File, context.Data.ProjectFilePath ?? string.Empty))",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Else part pushes everything because we don't know yet if the reported envvariable belongs to the configured  scope :)",
              "createdAt": "2024-08-14T10:31:05Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,39 +44,53 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += (string? projectFilePath) =>\n+        {\n+            while (_buildCheckResults.Count > 0)\n+            {\n+                BuildCheckResult result = _buildCheckResults.Pop();\n+                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, result.Location.File, projectFilePath ?? string.Empty))\n+                {\n+                    continue;\n+                }\n+\n+                _dataContext?.ReportResult(result);\n+            }\n+        };\n     }\n \n-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);\n \n-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)\n     {\n         if (context.Data.EvaluatedEnvironmentVariables.Count != 0)\n         {\n-            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)\n+            foreach (KeyValuePair<string, (string EnvVarValue, IMSBuildElementLocation Location)> envVariableData in context.Data.EvaluatedEnvironmentVariables)\n             {\n-                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.File,\n-                        context.Data.ProjectFilePath))\n-                {\n-                    continue;\n-                }\n-                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);\n+                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.Location);\n                 if (!_environmentVariablesReported.Contains(identityKey))\n                 {\n-                    if (_isVerboseEnvVarOutput)\n+                    string buildCheckResultMessageArgs = _isVerboseEnvVarOutput ? $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\" : $\"'{envVariableData.Key}'\";\n+\n+                    // Scope information is available after evaluation of the project file. If it is not ready, we will report the check later.\n+                    if (CheckScopeClassifier.IsScopingReady && CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.Location.File, context.Data.ProjectFilePath ?? string.Empty))",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "condition for EvaluationCheckScope.ProjectFileOnly is added",
              "createdAt": "2024-08-14T10:52:07Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,39 +44,53 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += (string? projectFilePath) =>\n+        {\n+            while (_buildCheckResults.Count > 0)\n+            {\n+                BuildCheckResult result = _buildCheckResults.Pop();\n+                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, result.Location.File, projectFilePath ?? string.Empty))\n+                {\n+                    continue;\n+                }\n+\n+                _dataContext?.ReportResult(result);\n+            }\n+        };\n     }\n \n-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);\n \n-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)\n     {\n         if (context.Data.EvaluatedEnvironmentVariables.Count != 0)\n         {\n-            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)\n+            foreach (KeyValuePair<string, (string EnvVarValue, IMSBuildElementLocation Location)> envVariableData in context.Data.EvaluatedEnvironmentVariables)\n             {\n-                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.File,\n-                        context.Data.ProjectFilePath))\n-                {\n-                    continue;\n-                }\n-                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);\n+                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.Location);\n                 if (!_environmentVariablesReported.Contains(identityKey))\n                 {\n-                    if (_isVerboseEnvVarOutput)\n+                    string buildCheckResultMessageArgs = _isVerboseEnvVarOutput ? $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\" : $\"'{envVariableData.Key}'\";\n+\n+                    // Scope information is available after evaluation of the project file. If it is not ready, we will report the check later.\n+                    if (CheckScopeClassifier.IsScopingReady && CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.Location.File, context.Data.ProjectFilePath ?? string.Empty))",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "now it doesn't look right, need to think more on these conditions.",
              "createdAt": "2024-08-14T11:31:13Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,39 +44,53 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += (string? projectFilePath) =>\n+        {\n+            while (_buildCheckResults.Count > 0)\n+            {\n+                BuildCheckResult result = _buildCheckResults.Pop();\n+                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, result.Location.File, projectFilePath ?? string.Empty))\n+                {\n+                    continue;\n+                }\n+\n+                _dataContext?.ReportResult(result);\n+            }\n+        };\n     }\n \n-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);\n \n-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)\n     {\n         if (context.Data.EvaluatedEnvironmentVariables.Count != 0)\n         {\n-            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)\n+            foreach (KeyValuePair<string, (string EnvVarValue, IMSBuildElementLocation Location)> envVariableData in context.Data.EvaluatedEnvironmentVariables)\n             {\n-                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.File,\n-                        context.Data.ProjectFilePath))\n-                {\n-                    continue;\n-                }\n-                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);\n+                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.Location);\n                 if (!_environmentVariablesReported.Contains(identityKey))\n                 {\n-                    if (_isVerboseEnvVarOutput)\n+                    string buildCheckResultMessageArgs = _isVerboseEnvVarOutput ? $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\" : $\"'{envVariableData.Key}'\";\n+\n+                    // Scope information is available after evaluation of the project file. If it is not ready, we will report the check later.\n+                    if (CheckScopeClassifier.IsScopingReady && CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.Location.File, context.Data.ProjectFilePath ?? string.Empty))",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How about subscribing a function (not anonymous one) - so that in a handler we can deregister ourselves?\r\nThat way we'd avoid double invocations and would be able to get rid of the Disposing logic",
              "createdAt": "2024-08-13T17:11:52Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,39 +44,53 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += (string? projectFilePath) =>",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I suppose we now want to send the reads one by one - correct?\r\n\r\nThen we should get rid of `_evaluatedEnvironmentVariables` alltogether and change the `EnvironmentVariableCheckData` to accomodate single read data",
              "createdAt": "2024-08-13T17:15:20Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs",
              "diffHunk": "@@ -91,11 +90,18 @@ public TaskKey(BuildEventContext context)\n     /// <summary>\n     /// The method collects events associated with the used environment variables in projects.\n     /// </summary>\n-    internal void ProcessEnvironmentVariableReadEventArgs(string envVarName, string envVarValue, string file, int line, int column)\n+    internal void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, string envVarName, string envVarValue, string file, int line, int column)\n     {\n         if (!_evaluatedEnvironmentVariables.ContainsKey(envVarName))\n         {\n-            _evaluatedEnvironmentVariables.Add(envVarName, (envVarValue, file, line, column));\n+            _evaluatedEnvironmentVariables.Add(envVarName, (envVarValue, ElementLocation.Create(file, line, column)));\n+\n+            EnvironmentVariableCheckData checkData =\n+               new(file,\n+                   checkContext.BuildEventContext?.ProjectInstanceId,\n+                   _evaluatedEnvironmentVariables);\n+\n+            _buildCheckCentralContext.RunEnvironmentVariableActions(checkData, checkContext, ReportResult);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Let's not mix static and instance usages.\r\nThe dispose on instance clears subscriptions on static class - that can lead to surprises.\r\n\r\nI'd suggest to keep this static and having the subscribers being responsible for deregistering (it's a common practice with events anyways)",
              "createdAt": "2024-08-13T17:19:26Z",
              "path": "src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs",
              "diffHunk": "@@ -7,8 +7,13 @@\n using Microsoft.Build.Shared;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n-internal static class CheckScopeClassifier\n+\n+internal class CheckScopeClassifier : IDisposable",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This feels incorrect. The `projectFile` argument should be indicating in which project file build context did the environment variable read occured - so it needs to be drawn from the environment variable read data. Instead here it is drawn from the project that finished evaluation - which can be completely unrelated. ",
              "createdAt": "2024-08-13T17:21:56Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,39 +44,53 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += (string? projectFilePath) =>\n+        {\n+            while (_buildCheckResults.Count > 0)\n+            {\n+                BuildCheckResult result = _buildCheckResults.Pop();\n+                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, result.Location.File, projectFilePath ?? string.Empty))",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "The trick is that EnvironmentRead event is aware of the file where this variable is detected (it might be an import), the source project is not visible from this event.",
              "createdAt": "2024-08-14T07:39:17Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,39 +44,53 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += (string? projectFilePath) =>\n+        {\n+            while (_buildCheckResults.Count > 0)\n+            {\n+                BuildCheckResult result = _buildCheckResults.Pop();\n+                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, result.Location.File, projectFilePath ?? string.Empty))",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we want to create results even for reads that we might be filtering out later on?",
              "createdAt": "2024-08-13T17:24:04Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,39 +44,53 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += (string? projectFilePath) =>\n+        {\n+            while (_buildCheckResults.Count > 0)\n+            {\n+                BuildCheckResult result = _buildCheckResults.Pop();\n+                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, result.Location.File, projectFilePath ?? string.Empty))\n+                {\n+                    continue;\n+                }\n+\n+                _dataContext?.ReportResult(result);\n+            }\n+        };\n     }\n \n-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);\n \n-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)\n     {\n         if (context.Data.EvaluatedEnvironmentVariables.Count != 0)\n         {\n-            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)\n+            foreach (KeyValuePair<string, (string EnvVarValue, IMSBuildElementLocation Location)> envVariableData in context.Data.EvaluatedEnvironmentVariables)\n             {\n-                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.File,\n-                        context.Data.ProjectFilePath))\n-                {\n-                    continue;\n-                }\n-                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);\n+                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.Location);\n                 if (!_environmentVariablesReported.Contains(identityKey))\n                 {\n-                    if (_isVerboseEnvVarOutput)\n+                    string buildCheckResultMessageArgs = _isVerboseEnvVarOutput ? $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\" : $\"'{envVariableData.Key}'\";\n+\n+                    // Scope information is available after evaluation of the project file. If it is not ready, we will report the check later.\n+                    if (CheckScopeClassifier.IsScopingReady && CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.Location.File, context.Data.ProjectFilePath ?? string.Empty))\n                     {\n                         context.ReportResult(BuildCheckResult.Create(\n                             SupportedRule,\n-                            ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),\n-                            $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\"));\n+                            ElementLocation.Create(envVariableData.Value.Location.File, envVariableData.Value.Location.Line, envVariableData.Value.Location.Column),\n+                            buildCheckResultMessageArgs));\n                     }\n                     else\n                     {\n-                        context.ReportResult(BuildCheckResult.Create(\n+                        _dataContext = context;\n+\n+                        _buildCheckResults.Push(BuildCheckResult.Create(",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "fixed",
              "createdAt": "2024-08-15T12:42:06Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,39 +44,53 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += (string? projectFilePath) =>\n+        {\n+            while (_buildCheckResults.Count > 0)\n+            {\n+                BuildCheckResult result = _buildCheckResults.Pop();\n+                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, result.Location.File, projectFilePath ?? string.Empty))\n+                {\n+                    continue;\n+                }\n+\n+                _dataContext?.ReportResult(result);\n+            }\n+        };\n     }\n \n-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);\n \n-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)\n     {\n         if (context.Data.EvaluatedEnvironmentVariables.Count != 0)\n         {\n-            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)\n+            foreach (KeyValuePair<string, (string EnvVarValue, IMSBuildElementLocation Location)> envVariableData in context.Data.EvaluatedEnvironmentVariables)\n             {\n-                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.File,\n-                        context.Data.ProjectFilePath))\n-                {\n-                    continue;\n-                }\n-                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);\n+                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.Location);\n                 if (!_environmentVariablesReported.Contains(identityKey))\n                 {\n-                    if (_isVerboseEnvVarOutput)\n+                    string buildCheckResultMessageArgs = _isVerboseEnvVarOutput ? $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\" : $\"'{envVariableData.Key}'\";\n+\n+                    // Scope information is available after evaluation of the project file. If it is not ready, we will report the check later.\n+                    if (CheckScopeClassifier.IsScopingReady && CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.Location.File, context.Data.ProjectFilePath ?? string.Empty))\n                     {\n                         context.ReportResult(BuildCheckResult.Create(\n                             SupportedRule,\n-                            ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),\n-                            $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\"));\n+                            ElementLocation.Create(envVariableData.Value.Location.File, envVariableData.Value.Location.Line, envVariableData.Value.Location.Column),\n+                            buildCheckResultMessageArgs));\n                     }\n                     else\n                     {\n-                        context.ReportResult(BuildCheckResult.Create(\n+                        _dataContext = context;\n+\n+                        _buildCheckResults.Push(BuildCheckResult.Create(",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "I still see creation of the results that might be filtered later on",
              "createdAt": "2024-08-16T10:30:11Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,39 +44,53 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += (string? projectFilePath) =>\n+        {\n+            while (_buildCheckResults.Count > 0)\n+            {\n+                BuildCheckResult result = _buildCheckResults.Pop();\n+                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, result.Location.File, projectFilePath ?? string.Empty))\n+                {\n+                    continue;\n+                }\n+\n+                _dataContext?.ReportResult(result);\n+            }\n+        };\n     }\n \n-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);\n \n-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)\n     {\n         if (context.Data.EvaluatedEnvironmentVariables.Count != 0)\n         {\n-            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)\n+            foreach (KeyValuePair<string, (string EnvVarValue, IMSBuildElementLocation Location)> envVariableData in context.Data.EvaluatedEnvironmentVariables)\n             {\n-                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.File,\n-                        context.Data.ProjectFilePath))\n-                {\n-                    continue;\n-                }\n-                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);\n+                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.Location);\n                 if (!_environmentVariablesReported.Contains(identityKey))\n                 {\n-                    if (_isVerboseEnvVarOutput)\n+                    string buildCheckResultMessageArgs = _isVerboseEnvVarOutput ? $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\" : $\"'{envVariableData.Key}'\";\n+\n+                    // Scope information is available after evaluation of the project file. If it is not ready, we will report the check later.\n+                    if (CheckScopeClassifier.IsScopingReady && CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.Location.File, context.Data.ProjectFilePath ?? string.Empty))\n                     {\n                         context.ReportResult(BuildCheckResult.Create(\n                             SupportedRule,\n-                            ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),\n-                            $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\"));\n+                            ElementLocation.Create(envVariableData.Value.Location.File, envVariableData.Value.Location.Line, envVariableData.Value.Location.Column),\n+                            buildCheckResultMessageArgs));\n                     }\n                     else\n                     {\n-                        context.ReportResult(BuildCheckResult.Create(\n+                        _dataContext = context;\n+\n+                        _buildCheckResults.Push(BuildCheckResult.Create(",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd suggest to create a separate PR for this.\r\n\r\nWhat we should really do is to keep passing the `IBuildCheckResult` here, and exposte the info required downstream via that interface and then properly consume it downstream. E.g. the `BuildCheckResultError` ctor doesn't properly populate location information into it's base constructor.",
              "createdAt": "2024-08-16T10:04:45Z",
              "path": "src/Build/BuildCheck/API/BuildCheckResult.cs",
              "diffHunk": "@@ -32,9 +28,9 @@ public BuildCheckResult(CheckRule checkConfig, IMSBuildElementLocation location,\n     internal BuildEventArgs ToEventArgs(CheckResultSeverity severity)\n         => severity switch\n         {\n-            CheckResultSeverity.Suggestion => new BuildCheckResultMessage(this),\n-            CheckResultSeverity.Warning => new BuildCheckResultWarning(this, CheckRule.Id),\n-            CheckResultSeverity.Error => new BuildCheckResultError(this, CheckRule.Id),\n+            CheckResultSeverity.Suggestion => new BuildCheckResultMessage(FormatMessage()),\n+            CheckResultSeverity.Warning => new BuildCheckResultWarning(FormatMessage(), CheckRule.Id),\n+            CheckResultSeverity.Error => new BuildCheckResultError(FormatMessage(), CheckRule.Id),",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I created https://github.com/dotnet/msbuild/issues/10529",
              "createdAt": "2024-08-16T10:08:11Z",
              "path": "src/Build/BuildCheck/API/BuildCheckResult.cs",
              "diffHunk": "@@ -32,9 +28,9 @@ public BuildCheckResult(CheckRule checkConfig, IMSBuildElementLocation location,\n     internal BuildEventArgs ToEventArgs(CheckResultSeverity severity)\n         => severity switch\n         {\n-            CheckResultSeverity.Suggestion => new BuildCheckResultMessage(this),\n-            CheckResultSeverity.Warning => new BuildCheckResultWarning(this, CheckRule.Id),\n-            CheckResultSeverity.Error => new BuildCheckResultError(this, CheckRule.Id),\n+            CheckResultSeverity.Suggestion => new BuildCheckResultMessage(FormatMessage()),\n+            CheckResultSeverity.Warning => new BuildCheckResultWarning(FormatMessage(), CheckRule.Id),\n+            CheckResultSeverity.Error => new BuildCheckResultError(FormatMessage(), CheckRule.Id),",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We probably should invoke this just once - once the readiness status changes from false to true.",
              "createdAt": "2024-08-16T10:24:33Z",
              "path": "src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs",
              "diffHunk": "@@ -52,9 +57,8 @@ internal static bool IsActionInObservedScope(\n         }\n     }\n \n-    private static bool IsGeneratedNugetImport(string file)\n-    {\n-        return file.EndsWith(\"nuget.g.props\", StringComparison.OrdinalIgnoreCase) ||\n-               file.EndsWith(\"nuget.g.targets\", StringComparison.OrdinalIgnoreCase);\n-    }\n+    internal static void RaiseNotifyOnScopingReadiness() => NotifyOnScopingReadiness?.Invoke();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How about the other scopes?\r\n`All` is as well always ready. And the `WorkTreeImports` is ready once the FileClassifier is ready",
              "createdAt": "2024-08-16T10:26:09Z",
              "path": "src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs",
              "diffHunk": "@@ -7,8 +7,13 @@\n using Microsoft.Build.Shared;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n-internal static class CheckScopeClassifier\n+\n+internal class CheckScopeClassifier\n {\n+    internal static event Action? NotifyOnScopingReadiness;\n+\n+    internal static Func<EvaluationCheckScope, bool> IsScopingReady => (scope) => scope == EvaluationCheckScope.ProjectFileOnly;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we expect and need more then one invocation of the event? If not, then we can deregister right away in the handler",
              "createdAt": "2024-08-16T10:26:54Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,44 +43,44 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += HandleScopeReadiness;\n     }\n \n-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);\n \n-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    public override void Dispose() => CheckScopeClassifier.NotifyOnScopingReadiness -= HandleScopeReadiness;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The context is valid for particular invocation. In case of multiple projects with multiple configuration the context will differ. Using mismatched context can lead to strange bugs (e.g. results having wrong severity for a specific project).\r\n\r\ntl;dr; - we'll need to queue the context together with the data",
              "createdAt": "2024-08-16T10:34:04Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,44 +43,44 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += HandleScopeReadiness;\n     }\n \n-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);\n \n-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    public override void Dispose() => CheckScopeClassifier.NotifyOnScopingReadiness -= HandleScopeReadiness;\n+\n+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)\n     {\n-        if (context.Data.EvaluatedEnvironmentVariables.Count != 0)\n+        EnvironmentVariableIdentityKey identityKey = new(context.Data.EvaluatedEnvironmentVariable.EnvVarValue, context.Data.EvaluatedEnvironmentVariable.Location);\n+        if (!_environmentVariablesCache.Contains(identityKey))\n         {\n-            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)\n+            string buildCheckResultMessageArgs = _isVerboseEnvVarOutput ? $\"'{context.Data.EvaluatedEnvironmentVariable.EnvVarKey}' with value: '{context.Data.EvaluatedEnvironmentVariable.EnvVarValue}'\" : $\"'{context.Data.EvaluatedEnvironmentVariable.EnvVarKey}'\";\n+\n+            // Scope information is available after evaluation of the project file. If it is not ready, we will report the check later.\n+            if (!CheckScopeClassifier.IsScopingReady(_scope))\n             {\n-                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.File,\n-                        context.Data.ProjectFilePath))\n-                {\n-                    continue;\n-                }\n-                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);\n-                if (!_environmentVariablesReported.Contains(identityKey))\n-                {\n-                    if (_isVerboseEnvVarOutput)\n-                    {\n-                        context.ReportResult(BuildCheckResult.Create(\n-                            SupportedRule,\n-                            ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),\n-                            $\"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'\"));\n-                    }\n-                    else\n-                    {\n-                        context.ReportResult(BuildCheckResult.Create(\n-                            SupportedRule,\n-                            ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),\n-                            $\"'{envVariableData.Key}'\"));\n-                    }\n-\n-                    _environmentVariablesReported.Add(identityKey);\n-                }\n+                _dataContext ??= context;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "For the in-proc node and worker nodes this happens after first evaluation is done:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/f422d8d7dfe0a7115b11b31470215ad6b7723138/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L1168\r\n\r\nHow about adding the state+event to `FileClassifier` - there flipping the state on first `RegisterKnownImmutableLocations` call, and in the `CheckScopeClassifier`  just passing through the chack and event subscription to the `FileClassifier`?\r\n\r\nSomething like (pseudocode):\r\n```csharp\r\ninternal class FileClassifier\r\n{\r\n   private bool _isInitialized;\r\n   public bool IsInitialized {get => _isInitialized; private set { if(!_isInitialized){ /* invoke event */ } _isInitialized = value; } }\r\n   public event Action? OnInitialized;\r\n\r\n   public void RegisterKnownImmutableLocations(/*...*/)\r\n  {\r\n    // ...\r\n   this.IsInitialized = true;\r\n  }\r\n}\r\n\r\ninternal static class CheckScopeClassifier\r\n{\r\n   internal bool IsInitialized => FileClassifier.Shared.IsInitialized;\r\n   internal static event Action? OnInitialized\r\n  {\r\n    add => FileClassifier.Shared.OnInitialized += value;\r\n    remove => FileClassifier.Shared.OnInitialized -= value;\r\n  }\r\n}\r\n```\r\n",
              "createdAt": "2024-08-16T10:48:10Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs",
              "diffHunk": "@@ -339,18 +339,25 @@ public void ProcessEvaluationFinishedEventArgs(\n \n             _buildEventsProcessor\n                 .ProcessEvaluationFinishedEventArgs(checkContext, evaluationFinishedEventArgs, propertiesLookup);\n+\n+            CheckScopeClassifier.RaiseNotifyOnScopingReadiness();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                if (!TryGetProjectFullPath(checkContext.BuildEventContext, out string projectPath))\r\n```",
              "createdAt": "2024-08-16T10:50:59Z",
              "path": "src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs",
              "diffHunk": "@@ -339,18 +339,25 @@ public void ProcessEvaluationFinishedEventArgs(\n \n             _buildEventsProcessor\n                 .ProcessEvaluationFinishedEventArgs(checkContext, evaluationFinishedEventArgs, propertiesLookup);\n+\n+            CheckScopeClassifier.RaiseNotifyOnScopingReadiness();\n         }\n \n         public void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)\n         {\n             if (projectEvaluationEventArgs is EnvironmentVariableReadEventArgs evr)\n             {\n-                _buildEventsProcessor.ProcessEnvironmentVariableReadEventArgs(\n-                    evr.EnvironmentVariableName,\n-                    evr.Message ?? string.Empty,\n-                    evr.File,\n-                    evr.LineNumber,\n-                    evr.ColumnNumber);\n+                TryGetProjectFullPath(checkContext.BuildEventContext, out string projectPath);\n+\n+                if (!string.IsNullOrEmpty(projectPath))",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just curious - why is this a tupple and not separate properties?",
              "createdAt": "2024-08-16T10:53:54Z",
              "path": "src/Build/BuildCheck/OM/EnvironmentVariableCheckData.cs",
              "diffHunk": "@@ -0,0 +1,23 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck;\n+\n+/// <summary>\n+/// BuildCheck OM data representing the environment variables used in a project file and its imports.\n+/// </summary>\n+public class EnvironmentVariableCheckData : CheckData\n+{\n+    internal EnvironmentVariableCheckData(\n+        string projectFilePath,\n+        int? projectConfigurationId,\n+        (string EnvVarKey, string EnvVarValue, IMSBuildElementLocation Location) evaluatedEnvironmentVariable)\n+        : base(projectFilePath, projectConfigurationId) => EvaluatedEnvironmentVariable = evaluatedEnvironmentVariable;\n+\n+    /// <summary>\n+    /// Gets the evaluated environment variable.\n+    /// </summary>\n+    public (string EnvVarKey, string EnvVarValue, IMSBuildElementLocation Location) EvaluatedEnvironmentVariable { get; }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "it was handy for the list of envvars before, but now I can change it",
              "createdAt": "2024-08-16T11:35:44Z",
              "path": "src/Build/BuildCheck/OM/EnvironmentVariableCheckData.cs",
              "diffHunk": "@@ -0,0 +1,23 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.BuildCheck;\n+\n+/// <summary>\n+/// BuildCheck OM data representing the environment variables used in a project file and its imports.\n+/// </summary>\n+public class EnvironmentVariableCheckData : CheckData\n+{\n+    internal EnvironmentVariableCheckData(\n+        string projectFilePath,\n+        int? projectConfigurationId,\n+        (string EnvVarKey, string EnvVarValue, IMSBuildElementLocation Location) evaluatedEnvironmentVariable)\n+        : base(projectFilePath, projectConfigurationId) => EvaluatedEnvironmentVariable = evaluatedEnvironmentVariable;\n+\n+    /// <summary>\n+    /// Gets the evaluated environment variable.\n+    /// </summary>\n+    public (string EnvVarKey, string EnvVarValue, IMSBuildElementLocation Location) EvaluatedEnvironmentVariable { get; }",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: the codepath allows setting to `false` as well. So just to be defensive\r\n\r\n```suggestion\r\n                if (!_isImmutablePathsInitialized && value)\r\n```",
              "createdAt": "2024-08-19T13:59:09Z",
              "path": "src/Framework/FileClassifier.cs",
              "diffHunk": "@@ -36,6 +36,30 @@ namespace Microsoft.Build.Framework\n     /// </remarks>\n     internal class FileClassifier\n     {\n+        private bool _isImmutablePathsInitialized;\n+\n+        /// <summary>\n+        /// This event notifies subscribers when the immutable paths have been initialized.\n+        /// </summary>\n+        public event Action? OnImmutablePathsInitialized;\n+\n+        /// <summary>\n+        ///  Tracks whether the immutable paths have been initialized.\n+        /// </summary>\n+        public bool IsImmutablePathsInitialized\n+        {\n+            get => _isImmutablePathsInitialized;\n+            private set\n+            {\n+                if (!_isImmutablePathsInitialized)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: The `SupportedRule` and `buildCheckResultMessageArgs` can be derived from the instance context - so the only data we really need to store is the location (instead of the whole result) - and we would safe couple dozens bytes in memory per each call here.",
              "createdAt": "2024-08-19T14:01:44Z",
              "path": "src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs",
              "diffHunk": "@@ -39,44 +41,41 @@ public override void Initialize(ConfigurationContext configurationContext)\n         foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)\n         {\n             bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);\n-            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           \n+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;\n         }\n+\n+        CheckScopeClassifier.NotifyOnScopingReadiness += HandleScopeReadiness;\n     }\n \n-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);\n+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);\n \n-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)\n+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)\n     {\n-        if (context.Data.EvaluatedEnvironmentVariables.Count != 0)\n+        EnvironmentVariableIdentityKey identityKey = new(context.Data.EnvironmentVariableName, context.Data.EnvironmentVariableLocation);\n+        if (!_environmentVariablesCache.Contains(identityKey))\n         {\n-            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)\n+            string buildCheckResultMessageArgs = _isVerboseEnvVarOutput ? $\"'{context.Data.EnvironmentVariableName}' with value: '{context.Data.EnvironmentVariableValue}'\" : $\"'{context.Data.EnvironmentVariableName}'\";\n+\n+            // Scope information is available after evaluation of the project file. If it is not ready, we will report the check later.\n+            if (!CheckScopeClassifier.IsScopingReady(_scope))\n+            {\n+                _buildCheckResults.Enqueue(\n+                    (context.Data.ProjectFilePath,\n+                    BuildCheckResult.Create(\n+                        SupportedRule,\n+                        context.Data.EnvironmentVariableLocation,\n+                        buildCheckResultMessageArgs),",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: I find the previous one easier a bit easier to read.\r\n```suggestion\r\n    private static bool IsGeneratedNugetImport(string file) => \r\n        file.EndsWith(\"nuget.g.props\", StringComparison.OrdinalIgnoreCase) ||\r\n        file.EndsWith(\"nuget.g.targets\", StringComparison.OrdinalIgnoreCase);\r\n```",
              "createdAt": "2024-08-19T17:58:36Z",
              "path": "src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs",
              "diffHunk": "@@ -52,9 +70,6 @@ internal static bool IsActionInObservedScope(\n         }\n     }\n \n-    private static bool IsGeneratedNugetImport(string file)\n-    {\n-        return file.EndsWith(\"nuget.g.props\", StringComparison.OrdinalIgnoreCase) ||\n-               file.EndsWith(\"nuget.g.targets\", StringComparison.OrdinalIgnoreCase);\n-    }\n+    private static bool IsGeneratedNugetImport(string file) => file.EndsWith(\"nuget.g.props\", StringComparison.OrdinalIgnoreCase) ||\n+        file.EndsWith(\"nuget.g.targets\", StringComparison.OrdinalIgnoreCase);",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Comment about `ForwardCompatibilityMinimalVersion` accidentally removed.",
              "createdAt": "2024-08-19T18:12:00Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -76,8 +76,9 @@ public sealed class BinaryLogger : ILogger\n         // version 22:\n         //    - extend EnvironmentVariableRead with location where environment variable was used.\n         // version 23:\n-        //    - new record kind: BuildSubmissionStartedEventArgs\n-        // This should be never changed.",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "From one test the timeout was removed and in this one it was added, which one are we going with? Yes timeout, no timeout?",
              "createdAt": "2024-08-19T18:19:18Z",
              "path": "src/BuildCheck.UnitTests/EndToEndTests.cs",
              "diffHunk": "@@ -236,9 +235,12 @@ public void NoEnvironmentVariableProperty_Test(bool? customConfigEnabled, string\n             customConfigData);\n \n         string output = RunnerUtilities.ExecBootstrapedMSBuild(\n-            $\"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check\", out bool success, false, _env.Output);\n+            $\"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check\", out bool success, false, _env.Output, timeoutMilliseconds: 12000_000);",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "No timeout is preferable (the utils will fallback to default 30 seconds timeout).\r\nHistoricaly some of the unittests were adding longer timeouts as we had a perf issue and it was an attempt to workaround - this is not legitimate reason anymore.\r\nSometimes (this is the case here likely) - devs are adding high timeouts to be able to debug bootstrapped msbuild, without runner utils killing it after timeout. The more prefered way is setting the `MSBuildDebugUnitTests` env var - which then stops enforcing any timeout at all. The env var can be set as a global variable on dev machine - so one doesnt have to care about it anymore",
              "createdAt": "2024-08-20T05:59:07Z",
              "path": "src/BuildCheck.UnitTests/EndToEndTests.cs",
              "diffHunk": "@@ -236,9 +235,12 @@ public void NoEnvironmentVariableProperty_Test(bool? customConfigEnabled, string\n             customConfigData);\n \n         string output = RunnerUtilities.ExecBootstrapedMSBuild(\n-            $\"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check\", out bool success, false, _env.Output);\n+            $\"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check\", out bool success, false, _env.Output, timeoutMilliseconds: 12000_000);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think that this is very hard to read right now. Could you please simplify the coding style?",
              "createdAt": "2024-08-19T18:22:29Z",
              "path": "src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs",
              "diffHunk": "@@ -7,8 +7,26 @@\n using Microsoft.Build.Shared;\n \n namespace Microsoft.Build.BuildCheck.Infrastructure;\n+\n internal static class CheckScopeClassifier\n {\n+    static CheckScopeClassifier() =>\n+        FileClassifier.Shared.OnImmutablePathsInitialized += () =>\n+        {\n+            NotifyOnScopingReadiness?.Invoke();\n+\n+            FileClassifier.Shared.OnImmutablePathsInitialized -= () => NotifyOnScopingReadiness?.Invoke();\n+        };",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      }
    ]
  }
}