{
  "number": 8287,
  "title": "Simpler loop structures",
  "body": "Review by commit",
  "state": "MERGED",
  "createdAt": "2023-01-09T19:16:10Z",
  "updatedAt": "2023-03-01T06:48:47Z",
  "closedAt": "2023-03-01T06:48:46Z",
  "mergedAt": "2023-03-01T06:48:46Z",
  "additions": 159,
  "deletions": 270,
  "changedFiles": 13,
  "headRefName": "simpler-loop-structures",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "966b08333fb3ac69b7b08f3d73f7059a336415f7",
          "message": "Simplify finding unscheduled request with greatest plan time\n\nThis created a dictionary to store all the configs then took a second pass to find the one with the longest planned time. This does both in one pass.",
          "committedDate": "2023-01-07T00:48:45Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d5d39af283cbbc8d1473873454eb471341887019",
          "message": "Delete unused methods\n\nThese were apparently never used.",
          "committedDate": "2023-01-07T00:49:09Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0bb00215c2eced6071825cb019c07ce0824d353b",
          "message": "Simplify method for finding greatest number of references",
          "committedDate": "2023-01-07T00:59:14Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4a60a82de7d7cbd4073b9d3c89e578e9d82a92ec",
          "message": "Simplify methods with LINQ",
          "committedDate": "2023-01-09T19:14:30Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eb06375f2f4104be956128e43a1637241b6ae76f",
          "message": "Loop over KeyValuePair instead of Key",
          "committedDate": "2023-01-09T19:14:51Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "109e3413dc7be56bd8cd4c6f4971428d881e51be",
          "message": "PR comments",
          "committedDate": "2023-01-10T19:15:23Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "599a43d9f2e277fc956f832546c61ef3fce7d29d",
          "message": "Avoid extra checks in TargetUpToDateChecker",
          "committedDate": "2023-01-19T01:21:17Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bf382b6e88eca7c6dc25b28eede2a7c1d7bfa960",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild into simpler-loop-structures",
          "committedDate": "2023-01-19T01:22:35Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1669eb77bef32d6f9feb90c215052ac1788ab1ed",
          "message": "Some fixes",
          "committedDate": "2023-01-24T00:23:27Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bf6b684b2e69f04e06e024afb9e56c3925c4e799",
          "message": "PR feedback",
          "committedDate": "2023-02-15T20:27:15Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "75fe746852fbcd80e017169fe0b0421d6e04ccd0",
          "message": "Add back using",
          "committedDate": "2023-02-16T06:51:12Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bc9a73a0977e96f9090749bdeede5b559d0cb47b",
          "message": "Undo simplification that should seldom be hit",
          "committedDate": "2023-02-16T21:36:16Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "449c43da39cf4f0a08ccab169ac4142dfd648abf",
          "message": "Collapse scheduling functions into one",
          "committedDate": "2023-02-17T19:53:38Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b2e497955b1027443b36397ff5e08fee6e9edf1b",
          "message": "Collapse more",
          "committedDate": "2023-02-17T19:58:39Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d440963a5dc37a6a134feaeb651c2cfd52cf5a08",
          "message": "Move empty check into separate function",
          "committedDate": "2023-02-17T20:27:13Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "03a388dc819afe553a085fceb23027736a956643",
          "message": "Merge branch 'main' into simpler-loop-structures",
          "committedDate": "2023-02-22T00:49:01Z",
          "author": {
            "name": "Forgind",
            "email": "12969783+Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0734ae6e17a562c8c363bd7929766264599c7303",
          "message": "Remove param tag",
          "committedDate": "2023-02-22T17:50:08Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This allocates a new copy of the dictionary, while the old was still using the same memory. Wouldn't this increase allocations?",
              "createdAt": "2023-01-10T17:15:22Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -1072,11 +1072,7 @@ public void ApplyModifications(MetadataModifications other)\n                 if (other._keepOnlySpecified)\n                 {\n                     // Any metadata not specified in other must be removed from this one.\n-                    var metadataToRemove = new List<string>(_modifications.Keys.Where(m => other[m].Remove));\n-                    foreach (var metadata in metadataToRemove)\n-                    {\n-                        _modifications.Remove(metadata);\n-                    }\n+                    _modifications = _modifications.Where(m => !other[m.Key].Remove).ToDictionary(x => x.Key, x => x.Value);",
              "author": {
                "login": "Therzok"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's the target dotnet framework? Dictionary.TryAdd could potentially be used.",
              "createdAt": "2023-01-10T17:25:14Z",
              "path": "src/Tasks/ResolveSDKReference.cs",
              "diffHunk": "@@ -1056,11 +1056,11 @@ private void GetSDKManifestAttributes()\n                 {\n                     if (_sdkManifest.AppxLocations != null)\n                     {\n-                        foreach (string key in _sdkManifest.AppxLocations.Keys)\n+                        foreach (KeyValuePair<string, string> kvp in _sdkManifest.AppxLocations)\n                         {\n-                            if (!AppxLocationsFromManifest.ContainsKey(key))\n+                            if (!AppxLocationsFromManifest.ContainsKey(kvp.Key))",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "net472 and netstandard2.0 are among the target frameworks, so we can't, sadly.",
              "createdAt": "2023-01-10T19:15:08Z",
              "path": "src/Tasks/ResolveSDKReference.cs",
              "diffHunk": "@@ -1056,11 +1056,11 @@ private void GetSDKManifestAttributes()\n                 {\n                     if (_sdkManifest.AppxLocations != null)\n                     {\n-                        foreach (string key in _sdkManifest.AppxLocations.Keys)\n+                        foreach (KeyValuePair<string, string> kvp in _sdkManifest.AppxLocations)\n                         {\n-                            if (!AppxLocationsFromManifest.ContainsKey(key))\n+                            if (!AppxLocationsFromManifest.ContainsKey(kvp.Key))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could inline the check in the loop so a struct enumerator is used here and allocations are avoided.",
              "createdAt": "2023-01-10T17:25:54Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2214,15 +2215,9 @@ private static void RemoveReferencesWithoutConflicts\n             Dictionary<string, List<AssemblyNameReference>> baseNameToReferences\n         )\n         {\n-            string[] baseNames = new string[baseNameToReferences.Count];\n-            baseNameToReferences.Keys.CopyTo(baseNames, 0);\n-\n-            foreach (string baseName in baseNames)\n+            foreach (KeyValuePair<string, List<AssemblyNameReference>> kvp in baseNameToReferences.Where(baseName => baseName.Value.Count != 1))",
              "author": {
                "login": "Therzok"
              }
            },
            {
              "body": "Good point; will change \ud83d\ude42",
              "createdAt": "2023-01-10T18:07:10Z",
              "path": "src/Tasks/AssemblyDependency/ReferenceTable.cs",
              "diffHunk": "@@ -2214,15 +2215,9 @@ private static void RemoveReferencesWithoutConflicts\n             Dictionary<string, List<AssemblyNameReference>> baseNameToReferences\n         )\n         {\n-            string[] baseNames = new string[baseNameToReferences.Count];\n-            baseNameToReferences.Keys.CopyTo(baseNames, 0);\n-\n-            foreach (string baseName in baseNames)\n+            foreach (KeyValuePair<string, List<AssemblyNameReference>> kvp in baseNameToReferences.Where(baseName => baseName.Value.Count != 1))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "delete",
              "createdAt": "2023-01-30T16:40:30Z",
              "path": "src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs",
              "diffHunk": "@@ -9,6 +9,7 @@\n using System.Diagnostics;\n \n using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;\n+using System.Linq;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\u2764\ufe0f ",
              "createdAt": "2023-02-06T09:53:07Z",
              "path": "src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs",
              "diffHunk": "@@ -290,15 +291,7 @@ public List<BuildRequestConfiguration> GetUnresolvedConfigurationsToIssue()\n         /// </summary>\n         public string[] GetActiveTargets()\n         {\n-            var activeTargets = new string[RequestConfiguration.ActivelyBuildingTargets.Count];\n-\n-            int index = 0;\n-            foreach (string target in RequestConfiguration.ActivelyBuildingTargets.Keys)\n-            {\n-                activeTargets[index++] = target;\n-            }\n-\n-            return activeTargets;\n+            return RequestConfiguration.ActivelyBuildingTargets.Keys.ToArray();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is the intended benefit of this change? It looks like the new code could only allocate more, because the `List` is created from unfiltered keys so potentially bigger than before.",
              "createdAt": "2023-02-06T09:59:42Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -1072,10 +1072,13 @@ public void ApplyModifications(MetadataModifications other)\n                 if (other._keepOnlySpecified)\n                 {\n                     // Any metadata not specified in other must be removed from this one.\n-                    var metadataToRemove = new List<string>(_modifications.Keys.Where(m => other[m].Remove));\n+                    var metadataToRemove = new List<string>(_modifications.Keys);\n                     foreach (var metadata in metadataToRemove)\n                     {\n-                        _modifications.Remove(metadata);\n+                        if (other[metadata].Remove)\n+                        {\n+                            _modifications.Remove(metadata);\n+                        }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I felt like this could be optimized, and this went through a few iterations:\r\nFirst was an attempt to remove Linq, since it allocates a little extra, and just Where the dictionary, but then I needed to allocate a new dictionary with ToDictionary.\r\nI also tried inlining the filter without creating an array, but that failed because it's illegal to modify the dictionary while enumerating over it.\r\nThen I fixed that last part by making the list but didn't change that I was checking Remove later.\r\n\r\nI think you're ultimately right, and none of those changes were actually helpful. I'll revert this part. Thanks!",
              "createdAt": "2023-02-15T19:52:14Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/Lookup.cs",
              "diffHunk": "@@ -1072,10 +1072,13 @@ public void ApplyModifications(MetadataModifications other)\n                 if (other._keepOnlySpecified)\n                 {\n                     // Any metadata not specified in other must be removed from this one.\n-                    var metadataToRemove = new List<string>(_modifications.Keys.Where(m => other[m].Remove));\n+                    var metadataToRemove = new List<string>(_modifications.Keys);\n                     foreach (var metadata in metadataToRemove)\n                     {\n-                        _modifications.Remove(metadata);\n+                        if (other[metadata].Remove)\n+                        {\n+                            _modifications.Remove(metadata);\n+                        }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is the newly added bool parameter actually passed by a caller?",
              "createdAt": "2023-02-06T10:09:30Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs",
              "diffHunk": "@@ -857,14 +857,19 @@ ElementLocation elementLocation\n         /// Retrieves the item-specs of all items in the given item vector collection.\n         /// </summary>\n         /// <param name=\"itemVectors\"></param>\n+        /// <param name=\"earlyExitIfNonEmpty\"></param>\n         /// <returns>list of item-specs</returns>\n-        private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors)\n+        private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors, bool earlyExitIfNonEmpty = false)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Thanks for pointing that out! I added that to optimize the VerifyThrow call that just checks if the Count > 0 but then forgot to actually modify that call. Will fix \ud83d\ude42",
              "createdAt": "2023-02-15T19:54:27Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs",
              "diffHunk": "@@ -857,14 +857,19 @@ ElementLocation elementLocation\n         /// Retrieves the item-specs of all items in the given item vector collection.\n         /// </summary>\n         /// <param name=\"itemVectors\"></param>\n+        /// <param name=\"earlyExitIfNonEmpty\"></param>\n         /// <returns>list of item-specs</returns>\n-        private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors)\n+        private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors, bool earlyExitIfNonEmpty = false)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Got it. Given that the method is fairly small, I think it would be slightly nicer to add something like `bool IsItemVectorEmpty` instead of repurposing `GetItemSpecsFromItemVectors`. Not a blocking comment.",
              "createdAt": "2023-02-17T10:38:06Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs",
              "diffHunk": "@@ -857,14 +857,19 @@ ElementLocation elementLocation\n         /// Retrieves the item-specs of all items in the given item vector collection.\n         /// </summary>\n         /// <param name=\"itemVectors\"></param>\n+        /// <param name=\"earlyExitIfNonEmpty\"></param>\n         /// <returns>list of item-specs</returns>\n-        private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors)\n+        private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors, bool earlyExitIfNonEmpty = false)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If we call `AssignUnscheduledRequestToNode` below, `bestConfig` must have been set to non-null. Isn't this assignment redundant? I.e. we seem to never use `bestRequest` unless we also set `bestConfig`.",
              "createdAt": "2023-02-06T10:19:09Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -939,23 +955,38 @@ private void AssignUnscheduledRequestsWithPlanByGreatestPlanTime(List<ScheduleRe\n         {\n             foreach (int idleNodeId in idleNodes)\n             {\n-                Dictionary<int, SchedulableRequest> configsWhichCanBeScheduledToThisNode = new Dictionary<int, SchedulableRequest>();\n+                SchedulingPlan.PlanConfigData bestConfig = null;\n+                SchedulableRequest bestRequest = null;\n \n                 // Find the most expensive request in the plan to schedule from among the ones available.\n                 foreach (SchedulableRequest request in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)\n                 {\n                     if (CanScheduleRequestToNode(request, idleNodeId))\n                     {\n-                        configsWhichCanBeScheduledToThisNode[request.BuildRequest.ConfigurationId] = request;\n+                        SchedulingPlan.PlanConfigData configToConsider = _schedulingPlan.GetConfiguration(request.BuildRequest.ConfigurationId);\n+                        if (configToConsider is null)\n+                        {\n+                            if (bestConfig is null)\n+                            {\n+                                // By default we assume configs we don't know about aren't as important, and will only schedule them\n+                                // if nothing else is suitable\n+                                bestRequest = request;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Same question about this logic in `AssignUnscheduledRequestsWithPlanByMostImmediateReferences`.",
              "createdAt": "2023-02-06T10:26:44Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -939,23 +955,38 @@ private void AssignUnscheduledRequestsWithPlanByGreatestPlanTime(List<ScheduleRe\n         {\n             foreach (int idleNodeId in idleNodes)\n             {\n-                Dictionary<int, SchedulableRequest> configsWhichCanBeScheduledToThisNode = new Dictionary<int, SchedulableRequest>();\n+                SchedulingPlan.PlanConfigData bestConfig = null;\n+                SchedulableRequest bestRequest = null;\n \n                 // Find the most expensive request in the plan to schedule from among the ones available.\n                 foreach (SchedulableRequest request in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)\n                 {\n                     if (CanScheduleRequestToNode(request, idleNodeId))\n                     {\n-                        configsWhichCanBeScheduledToThisNode[request.BuildRequest.ConfigurationId] = request;\n+                        SchedulingPlan.PlanConfigData configToConsider = _schedulingPlan.GetConfiguration(request.BuildRequest.ConfigurationId);\n+                        if (configToConsider is null)\n+                        {\n+                            if (bestConfig is null)\n+                            {\n+                                // By default we assume configs we don't know about aren't as important, and will only schedule them\n+                                // if nothing else is suitable\n+                                bestRequest = request;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Line 987 should say `if (bestRequest is not null)` instead of bestConfig, which makes this assignment relevant \ud83d\ude42\r\n\r\nIt looks like I got it right in AssignUnscheduledRequestsWithPlanByMostImmediateReferences, but I'll fix it here. Thanks!",
              "createdAt": "2023-02-15T20:26:35Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -939,23 +955,38 @@ private void AssignUnscheduledRequestsWithPlanByGreatestPlanTime(List<ScheduleRe\n         {\n             foreach (int idleNodeId in idleNodes)\n             {\n-                Dictionary<int, SchedulableRequest> configsWhichCanBeScheduledToThisNode = new Dictionary<int, SchedulableRequest>();\n+                SchedulingPlan.PlanConfigData bestConfig = null;\n+                SchedulableRequest bestRequest = null;\n \n                 // Find the most expensive request in the plan to schedule from among the ones available.\n                 foreach (SchedulableRequest request in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)\n                 {\n                     if (CanScheduleRequestToNode(request, idleNodeId))\n                     {\n-                        configsWhichCanBeScheduledToThisNode[request.BuildRequest.ConfigurationId] = request;\n+                        SchedulingPlan.PlanConfigData configToConsider = _schedulingPlan.GetConfiguration(request.BuildRequest.ConfigurationId);\n+                        if (configToConsider is null)\n+                        {\n+                            if (bestConfig is null)\n+                            {\n+                                // By default we assume configs we don't know about aren't as important, and will only schedule them\n+                                // if nothing else is suitable\n+                                bestRequest = request;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nice! I wish there was a code analyzer flagging this pattern.",
              "createdAt": "2023-02-06T10:31:13Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -562,9 +562,9 @@ internal static BuildResult FactoryForDeserialization(ITranslator translator)\n         /// </summary>\n         internal void CacheIfPossible()\n         {\n-            foreach (string target in _resultsByTarget.Keys)\n+            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget)\n             {\n-                _resultsByTarget[target].CacheItems(ConfigurationId, target);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "\u2764\ufe0f\r\n\r\n(This pattern was my initial impetus for the whole PR; the rest was when I got distracted)",
              "createdAt": "2023-02-15T19:57:08Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -562,9 +562,9 @@ internal static BuildResult FactoryForDeserialization(ITranslator translator)\n         /// </summary>\n         internal void CacheIfPossible()\n         {\n-            foreach (string target in _resultsByTarget.Keys)\n+            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget)\n             {\n-                _resultsByTarget[target].CacheItems(ConfigurationId, target);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can this not be simply\r\n```C#\r\ncustomMetadata.Select(metadatum => new KeyValuePair<string, string>(metadatum.Key, metadatum.Value)).ToArray();\r\n```\r\n?",
              "createdAt": "2023-02-06T10:38:01Z",
              "path": "src/Framework/ITaskItemExtensions.cs",
              "diffHunk": "@@ -39,26 +37,9 @@ internal static class ITaskItemExtensions\n             var list = new KeyValuePair<string, string>[customMetadata.Count];\n             int i = 0;\n \n-            foreach (string metadataName in customMetadata.Keys)\n+            foreach (KeyValuePair<string, string> metadatum in customMetadata)\n             {\n-                string valueOrError;\n-\n-                try\n-                {\n-                    valueOrError = taskItem.GetMetadata(metadataName);\n-                }\n-                // Temporarily try catch all to mitigate frequent NullReferenceExceptions in\n-                // the logging code until CopyOnWritePropertyDictionary is replaced with\n-                // ImmutableDictionary. Calling into Debug.Fail to crash the process in case\n-                // the exception occurres in Debug builds.\n-                catch (Exception e)\n-                {\n-                    valueOrError = e.Message;\n-                    Debug.Fail(e.ToString());\n-                }\n-\n-                list[i] = new KeyValuePair<string, string>(metadataName, valueOrError);\n-                i += 1;\n+                list[i++] = new KeyValuePair<string, string>(metadatum.Key, metadatum.Value);\n             }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I don't think so, but I'm honestly not 100% sure why not. I'll admit it looks kinda stupid. An IDictionary is an IEnumerable that contains a collection of key-value pairs, per its documentation, but it doesn't have those as its explicit types, so it's an IEnumerable but not an IEnumerable<...>. Since it's an IEnumerable, you can loop over it, but Linq only works on IEnumerable<...>, I guess? Either way, I don't think this code really executes in practice, so although it'd be nice if it could be cleaner, I'm not too worried about it.",
              "createdAt": "2023-02-15T20:10:49Z",
              "path": "src/Framework/ITaskItemExtensions.cs",
              "diffHunk": "@@ -39,26 +37,9 @@ internal static class ITaskItemExtensions\n             var list = new KeyValuePair<string, string>[customMetadata.Count];\n             int i = 0;\n \n-            foreach (string metadataName in customMetadata.Keys)\n+            foreach (KeyValuePair<string, string> metadatum in customMetadata)\n             {\n-                string valueOrError;\n-\n-                try\n-                {\n-                    valueOrError = taskItem.GetMetadata(metadataName);\n-                }\n-                // Temporarily try catch all to mitigate frequent NullReferenceExceptions in\n-                // the logging code until CopyOnWritePropertyDictionary is replaced with\n-                // ImmutableDictionary. Calling into Debug.Fail to crash the process in case\n-                // the exception occurres in Debug builds.\n-                catch (Exception e)\n-                {\n-                    valueOrError = e.Message;\n-                    Debug.Fail(e.ToString());\n-                }\n-\n-                list[i] = new KeyValuePair<string, string>(metadataName, valueOrError);\n-                i += 1;\n+                list[i++] = new KeyValuePair<string, string>(metadatum.Key, metadatum.Value);\n             }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Of course, you're right. I missed that it's the non-generic `IDictionary`. In that case, though, your new code would not work either. The `foreach` will fail to cast `DictionaryEntry` to `KeyValuePair<string, string>`.",
              "createdAt": "2023-02-16T08:04:22Z",
              "path": "src/Framework/ITaskItemExtensions.cs",
              "diffHunk": "@@ -39,26 +37,9 @@ internal static class ITaskItemExtensions\n             var list = new KeyValuePair<string, string>[customMetadata.Count];\n             int i = 0;\n \n-            foreach (string metadataName in customMetadata.Keys)\n+            foreach (KeyValuePair<string, string> metadatum in customMetadata)\n             {\n-                string valueOrError;\n-\n-                try\n-                {\n-                    valueOrError = taskItem.GetMetadata(metadataName);\n-                }\n-                // Temporarily try catch all to mitigate frequent NullReferenceExceptions in\n-                // the logging code until CopyOnWritePropertyDictionary is replaced with\n-                // ImmutableDictionary. Calling into Debug.Fail to crash the process in case\n-                // the exception occurres in Debug builds.\n-                catch (Exception e)\n-                {\n-                    valueOrError = e.Message;\n-                    Debug.Fail(e.ToString());\n-                }\n-\n-                list[i] = new KeyValuePair<string, string>(metadataName, valueOrError);\n-                i += 1;\n+                list[i++] = new KeyValuePair<string, string>(metadatum.Key, metadatum.Value);\n             }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I was thinking we're ok because all the implementations of CopyCustomMetadata outside tests and Deprecated return IDictionarys that also implement IDictionary<string, string>. That made me think that as long as this compiled, it was ok. On the other hand, someone could theoretically implement their own custom CopyCustomMetadata and return, say, a Hashtable, and then it might crash. I'll change this to work for that case. Thanks for taking a look!",
              "createdAt": "2023-02-16T21:32:46Z",
              "path": "src/Framework/ITaskItemExtensions.cs",
              "diffHunk": "@@ -39,26 +37,9 @@ internal static class ITaskItemExtensions\n             var list = new KeyValuePair<string, string>[customMetadata.Count];\n             int i = 0;\n \n-            foreach (string metadataName in customMetadata.Keys)\n+            foreach (KeyValuePair<string, string> metadatum in customMetadata)\n             {\n-                string valueOrError;\n-\n-                try\n-                {\n-                    valueOrError = taskItem.GetMetadata(metadataName);\n-                }\n-                // Temporarily try catch all to mitigate frequent NullReferenceExceptions in\n-                // the logging code until CopyOnWritePropertyDictionary is replaced with\n-                // ImmutableDictionary. Calling into Debug.Fail to crash the process in case\n-                // the exception occurres in Debug builds.\n-                catch (Exception e)\n-                {\n-                    valueOrError = e.Message;\n-                    Debug.Fail(e.ToString());\n-                }\n-\n-                list[i] = new KeyValuePair<string, string>(metadataName, valueOrError);\n-                i += 1;\n+                list[i++] = new KeyValuePair<string, string>(metadatum.Key, metadatum.Value);\n             }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Implementations that also support `IDictionary<string, string>` are caught by the `is IEnumerable<KeyValuePair<string, string>>` check above, so this code really deals with types that support only the non-generic `IDictionary`. Not sure how often it happens but it's safer to keep it in, for sure.",
              "createdAt": "2023-02-17T10:33:27Z",
              "path": "src/Framework/ITaskItemExtensions.cs",
              "diffHunk": "@@ -39,26 +37,9 @@ internal static class ITaskItemExtensions\n             var list = new KeyValuePair<string, string>[customMetadata.Count];\n             int i = 0;\n \n-            foreach (string metadataName in customMetadata.Keys)\n+            foreach (KeyValuePair<string, string> metadatum in customMetadata)\n             {\n-                string valueOrError;\n-\n-                try\n-                {\n-                    valueOrError = taskItem.GetMetadata(metadataName);\n-                }\n-                // Temporarily try catch all to mitigate frequent NullReferenceExceptions in\n-                // the logging code until CopyOnWritePropertyDictionary is replaced with\n-                // ImmutableDictionary. Calling into Debug.Fail to crash the process in case\n-                // the exception occurres in Debug builds.\n-                catch (Exception e)\n-                {\n-                    valueOrError = e.Message;\n-                    Debug.Fail(e.ToString());\n-                }\n-\n-                list[i] = new KeyValuePair<string, string>(metadataName, valueOrError);\n-                i += 1;\n+                list[i++] = new KeyValuePair<string, string>(metadatum.Key, metadatum.Value);\n             }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit:\r\n```suggestion\r\n                            bestRequest ??= request;\r\n```",
              "createdAt": "2023-02-17T10:42:13Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -911,23 +911,39 @@ private void AssignUnscheduledRequestsWithPlanByMostImmediateReferences(List<Sch\n         {\n             foreach (int idleNodeId in idleNodes)\n             {\n-                Dictionary<int, SchedulableRequest> configsWhichCanBeScheduledToThisNode = new Dictionary<int, SchedulableRequest>();\n+                SchedulingPlan.PlanConfigData bestConfig = null;\n+                SchedulableRequest bestRequest = null;\n \n                 // Find the most expensive request in the plan to schedule from among the ones available.\n                 foreach (SchedulableRequest request in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)\n                 {\n                     if (CanScheduleRequestToNode(request, idleNodeId))\n                     {\n-                        configsWhichCanBeScheduledToThisNode[request.BuildRequest.ConfigurationId] = request;\n+\n+                        SchedulingPlan.PlanConfigData configToConsider = _schedulingPlan.GetConfiguration(request.BuildRequest.ConfigurationId);\n+                        if (configToConsider is null)\n+                        {\n+                            // By default we assume configs we don't know about aren't as important, and will only schedule them\n+                            // if nothing else is suitable\n+                            if (bestRequest is null)\n+                            {\n+                                bestRequest = request;\n+                            }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}