{
  "number": 7387,
  "title": "Fix TaskHost loading issue Fixes #6461",
  "body": "Fixes #6461\r\n\r\n### Context\r\nGetting type information for a task that was supposed to be loaded in a TaskHost involves loading that assembly today. The point of TaskHost nodes is that they _don't_ lock the assembly, and they disappear quickly, releasing the lock from when we actually need to load the assembly to execute it. This will mean that we don't lock the assembly to read its type information, actually complying with the user's likely intent.\r\n\r\n## Changes Made\r\nIf the user asks for a TaskHost, use MetadataLoadContext to get its information rather than loading the assembly fully.\r\n\r\n### Testing\r\nUnit tests + building two representative projects with taskhost tasks.\r\n\r\n### Notes\r\nThis should not be merged until we have successfully demonstrated that we'll be able to insert it into VS without it complaining about a new assembly.",
  "state": "MERGED",
  "createdAt": "2022-02-11T20:50:18Z",
  "updatedAt": "2022-06-28T21:22:27Z",
  "closedAt": "2022-06-28T20:38:33Z",
  "mergedAt": "2022-06-28T20:38:33Z",
  "additions": 338,
  "deletions": 165,
  "changedFiles": 20,
  "headRefName": "mlc-taskhost-2",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": {
    "title": "VS 17.3"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "84e8c89d92c7ab7183108a0ff55bed2156c02731",
          "message": "Start",
          "committedDate": "2022-02-02T18:48:26Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "904a3983b2e51affb0ff1cd1206579fd49b229c0",
          "message": "Passed tests",
          "committedDate": "2022-02-10T01:27:29Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "09d41f256c20f8f7587f480aedef339d4de8dde6",
          "message": "Shrink diff and remove msbuild paths",
          "committedDate": "2022-02-18T23:19:00Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "21f4dd1adfc40362f02973fbf43c3e4132d0cd89",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild into mlc-taskhost-2",
          "committedDate": "2022-04-27T20:22:11Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "038b7c715b0452d14a1eddb9c9346d3ea2611e28",
          "message": "Fix loop",
          "committedDate": "2022-04-27T21:04:06Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e0c89b17799f8395ef0840968736a9c75700ad60",
          "message": "partially revert assembly loading change",
          "committedDate": "2022-04-28T21:59:37Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "99ac6ebedcbe01605f59d78cd4ecfc60573d8bca",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild into mlc-taskhost-2",
          "committedDate": "2022-04-28T22:00:32Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bff5429f498f4699d76ffaf4210b7abb6bef8bb8",
          "message": "Step",
          "committedDate": "2022-05-06T01:33:55Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a57c78ec203e384342f2a5e886c1c69c1228b877",
          "message": "Another step",
          "committedDate": "2022-05-07T02:40:36Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6c404bcb54b0b85b8faabb71b3befee08023c69e",
          "message": "Some PR feedback",
          "committedDate": "2022-05-07T03:40:07Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f796cb11b088e1f9743bf587aac71915de921a88",
          "message": "PR feedback",
          "committedDate": "2022-05-09T20:48:53Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "893def3790ef2cb7e31da61053a6d776cc3354a5",
          "message": "Merge branch 'mlc-taskhost-2' of https://github.com/forgind/msbuild into exp/full-mlc-change",
          "committedDate": "2022-05-09T20:51:11Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3c39900d53d23d6ffdc0aa2fdcaebef7c12cc916",
          "message": "Add binding redirects",
          "committedDate": "2022-05-11T18:39:31Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "33f651f943f5d369850befde79ab44a73b82ca18",
          "message": "Merge branch 'mlc-taskhost-2' of https://github.com/forgind/msbuild into exp/full-mlc-change",
          "committedDate": "2022-05-11T18:40:08Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f9437327177e84937e6c169d5775fd2ab6107d9a",
          "message": "PR comments",
          "committedDate": "2022-05-12T18:16:47Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6c8af6a190b40ca42a733f81c5a9639a008c34b3",
          "message": "Merge remote-tracking branch 'upstream/main' into mlc-taskhost-2\n\nConflicts:\n\teng/Packages.props",
          "committedDate": "2022-05-18T19:37:22Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "88d0089877aa1deac6f7f8be9b7e3bf0800c6089",
          "message": "Merge remote-tracking branch 'Forgind/mlc-taskhost-2' into exp/full-mlc-change",
          "committedDate": "2022-05-18T20:46:58Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8c11170e9c746910644e1b14b335c1141d06c32c",
          "message": "Merge remote-tracking branch 'upstream/main' into mlc-taskhost-2\n\nConflicts:\n\tsrc/Framework/MSBuildEventSource.cs",
          "committedDate": "2022-06-23T14:44:58Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "You have to pick 5 because moving to 6 would require an SCI upgrade too? That should be on the horizon.",
              "createdAt": "2022-02-11T22:27:52Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -22,7 +22,8 @@\n     <PackageReference Update=\"System.Configuration.ConfigurationManager\" Version=\"4.7.0\" />\n     <PackageReference Update=\"System.Net.Http\" Version=\"4.3.4\" />\n     <PackageReference Update=\"System.Memory\" Version=\"4.5.4\" />\n-    <PackageReference Update=\"System.Reflection.Metadata\" Version=\"1.6.0\" />\n+    <PackageReference Update=\"System.Reflection.Metadata\" Version=\"5.0.0\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "If 6 comes out before this, I can change it. S.R.M 5.0.0 is also the version used by roslyn, at least as of a week or so ago, and I figure we should align with them if we don't care too much.",
              "createdAt": "2022-02-11T23:37:45Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -22,7 +22,8 @@\n     <PackageReference Update=\"System.Configuration.ConfigurationManager\" Version=\"4.7.0\" />\n     <PackageReference Update=\"System.Net.Http\" Version=\"4.3.4\" />\n     <PackageReference Update=\"System.Memory\" Version=\"4.5.4\" />\n-    <PackageReference Update=\"System.Reflection.Metadata\" Version=\"1.6.0\" />\n+    <PackageReference Update=\"System.Reflection.Metadata\" Version=\"5.0.0\" />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is this change needed for?",
              "createdAt": "2022-02-11T22:28:24Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -1012,7 +1012,7 @@ private bool SetTaskParameter\n \n                 if (parameter != null)\n                 {\n-                    Type parameterType = parameter.PropertyType;\n+                    Type parameterType = Type.GetType(parameter.PropertyType.AssemblyQualifiedName);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "System.Reflection.MetadataLoadContext was making up its own identical but distinct types, which meant it couldn't recognize System.String as System.String, for example, and told me it couldn't convert one to the other. This replaces MLC-System.String with real System.String and does the same for other types. We shouldn't be using any types not already loaded.",
              "createdAt": "2022-02-11T23:40:59Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -1012,7 +1012,7 @@ private bool SetTaskParameter\n \n                 if (parameter != null)\n                 {\n-                    Type parameterType = parameter.PropertyType;\n+                    Type parameterType = Type.GetType(parameter.PropertyType.AssemblyQualifiedName);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> We shouldn't be using any types not already loaded.\r\n\r\nIf that's the case this sounds fine; how do you know/enforce that?",
              "createdAt": "2022-04-29T16:44:38Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -1012,7 +1012,7 @@ private bool SetTaskParameter\n \n                 if (parameter != null)\n                 {\n-                    Type parameterType = parameter.PropertyType;\n+                    Type parameterType = Type.GetType(parameter.PropertyType.AssemblyQualifiedName);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would it make sense to default this to false and not push it to most callers?",
              "createdAt": "2022-02-11T22:30:18Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -181,10 +209,11 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n         internal LoadedType Load\n         (\n             string typeName,\n-            AssemblyLoadInfo assembly\n+            AssemblyLoadInfo assembly,\n+            bool useTaskHost",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yeah, that's reasonable. Can fix.",
              "createdAt": "2022-02-11T23:41:33Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -181,10 +209,11 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n         internal LoadedType Load\n         (\n             string typeName,\n-            AssemblyLoadInfo assembly\n+            AssemblyLoadInfo assembly,\n+            bool useTaskHost",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: looks like the old overload got added back in .NET Core 2.0 so this could be unified.",
              "createdAt": "2022-02-11T22:34:17Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -139,26 +144,24 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)\n         /// <returns></returns>\n         private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n         {\n-            Assembly loadedAssembly = null;\n-\n             try\n             {\n                 if (assemblyLoadInfo.AssemblyName != null)\n                 {\n #if !FEATURE_ASSEMBLYLOADCONTEXT\n-                    loadedAssembly = Assembly.Load(assemblyLoadInfo.AssemblyName);\n+                    return Assembly.Load(assemblyLoadInfo.AssemblyName);\n #else\n-                    loadedAssembly = Assembly.Load(new AssemblyName(assemblyLoadInfo.AssemblyName));\n+                    return Assembly.Load(new AssemblyName(assemblyLoadInfo.AssemblyName));\n #endif",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I expected to see this disposed so that the file would no longer be locked after reading it. Is that not required?",
              "createdAt": "2022-02-11T22:35:39Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -169,8 +172,33 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again\n                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);\n             }\n+        }\n \n-            return loadedAssembly;\n+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)\n+        {\n+            string path = assemblyLoadInfo.AssemblyFile;\n+\n+            if (path is null)\n+            {\n+#if NETFRAMEWORK\n+                AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;\n+                setup.LoaderOptimization = LoaderOptimization.SingleDomain;\n+                AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\", null, setup);\n+                path = appDomain.Load(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                AppDomain.Unload(appDomain);\n+#else\n+                AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                path = alc.LoadFromAssemblyName(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                alc.Unload();\n+#endif\n+            }\n+\n+            string[] runtimePaths = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), \"*.dll\");\n+            List<string> localPaths = new(Directory.GetFiles(Path.GetDirectoryName(path), \"*.dll\"));\n+            localPaths.AddRange(runtimePaths);\n+\n+            MetadataLoadContext loadContext = new(new PathAssemblyResolver(localPaths));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I could at least move around the assembly after having used it, so I'd assume this works. I'm assuming it's automatically disposed of as soon as it goes out of scope.",
              "createdAt": "2022-02-11T23:44:03Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -169,8 +172,33 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again\n                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);\n             }\n+        }\n \n-            return loadedAssembly;\n+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)\n+        {\n+            string path = assemblyLoadInfo.AssemblyFile;\n+\n+            if (path is null)\n+            {\n+#if NETFRAMEWORK\n+                AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;\n+                setup.LoaderOptimization = LoaderOptimization.SingleDomain;\n+                AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\", null, setup);\n+                path = appDomain.Load(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                AppDomain.Unload(appDomain);\n+#else\n+                AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                path = alc.LoadFromAssemblyName(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                alc.Unload();\n+#endif\n+            }\n+\n+            string[] runtimePaths = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), \"*.dll\");\n+            List<string> localPaths = new(Directory.GetFiles(Path.GetDirectoryName(path), \"*.dll\"));\n+            localPaths.AddRange(runtimePaths);\n+\n+            MetadataLoadContext loadContext = new(new PathAssemblyResolver(localPaths));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> I'm assuming it's automatically disposed of as soon as it goes out of scope.\r\n\r\nThis is not how disposal works in .NET. You must manually dispose objects that are `IDisposable` to control the time that unmanaged resources get freed.\r\n\r\nTypically, the finalizer of an object will free resources at GC time, so that handles aren't leaked. That may be happening in your case, but we should not rely on it.",
              "createdAt": "2022-02-17T15:13:48Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -169,8 +172,33 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again\n                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);\n             }\n+        }\n \n-            return loadedAssembly;\n+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)\n+        {\n+            string path = assemblyLoadInfo.AssemblyFile;\n+\n+            if (path is null)\n+            {\n+#if NETFRAMEWORK\n+                AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;\n+                setup.LoaderOptimization = LoaderOptimization.SingleDomain;\n+                AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\", null, setup);\n+                path = appDomain.Load(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                AppDomain.Unload(appDomain);\n+#else\n+                AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                path = alc.LoadFromAssemblyName(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                alc.Unload();\n+#endif\n+            }\n+\n+            string[] runtimePaths = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), \"*.dll\");\n+            List<string> localPaths = new(Directory.GetFiles(Path.GetDirectoryName(path), \"*.dll\"));\n+            localPaths.AddRange(runtimePaths);\n+\n+            MetadataLoadContext loadContext = new(new PathAssemblyResolver(localPaths));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I checked what would happen if I explicitly disposed of the MetadataLoadContext before returning from this method, and it failed with:\r\nThis object is no longer valid because the MetadataLoadContext that created it has been disposed.\r\n\r\nNot a change I can make. My vague understanding is that MetadataLoadContext loads the assembly from a \"copied\" version of the assembly, in which case it never loads the \"real\" assembly, and it's fine for it to keep its lock on the fake one.",
              "createdAt": "2022-02-18T21:40:55Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -169,8 +172,33 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again\n                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);\n             }\n+        }\n \n-            return loadedAssembly;\n+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)\n+        {\n+            string path = assemblyLoadInfo.AssemblyFile;\n+\n+            if (path is null)\n+            {\n+#if NETFRAMEWORK\n+                AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;\n+                setup.LoaderOptimization = LoaderOptimization.SingleDomain;\n+                AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\", null, setup);\n+                path = appDomain.Load(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                AppDomain.Unload(appDomain);\n+#else\n+                AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                path = alc.LoadFromAssemblyName(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                alc.Unload();\n+#endif\n+            }\n+\n+            string[] runtimePaths = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), \"*.dll\");\n+            List<string> localPaths = new(Directory.GetFiles(Path.GetDirectoryName(path), \"*.dll\"));\n+            localPaths.AddRange(runtimePaths);\n+\n+            MetadataLoadContext loadContext = new(new PathAssemblyResolver(localPaths));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this work if the attribute is applied to a base class (like `AppDomainIsolatedTask`) instead of directly on the task type?",
              "createdAt": "2022-02-11T23:02:08Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,31 +38,47 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;\n+                }\n+            }\n+            catch (Exception) { }\n+            _type ??= type;\n             _assembly = assemblyLoadInfo;\n             _loadedAssembly = loadedAssembly;\n \n             CheckForHardcodedSTARequirement();\n-            HasLoadInSeparateAppDomainAttribute();\n-            HasSTAThreadAttribute();\n+            _hasLoadInSeparateAppDomainAttribute = loadedAssembly is null ?\n+                this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */) :\n+#if NET35\n+                false; // Should never reach here.\n+#else\n+                CustomAttributeData.GetCustomAttributes(type).Any(attr => attr.AttributeType.Name.Equals(\"LoadInSeparateAppDomainAttribute\"));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I'd verified that it built correctly but not that the LoadInSeparateAppDomainAttribute was applied. It appears that it was not applied correctly. What do you recommend for getting around that?",
              "createdAt": "2022-02-12T00:14:28Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,31 +38,47 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;\n+                }\n+            }\n+            catch (Exception) { }\n+            _type ??= type;\n             _assembly = assemblyLoadInfo;\n             _loadedAssembly = loadedAssembly;\n \n             CheckForHardcodedSTARequirement();\n-            HasLoadInSeparateAppDomainAttribute();\n-            HasSTAThreadAttribute();\n+            _hasLoadInSeparateAppDomainAttribute = loadedAssembly is null ?\n+                this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */) :\n+#if NET35\n+                false; // Should never reach here.\n+#else\n+                CustomAttributeData.GetCustomAttributes(type).Any(attr => attr.AttributeType.Name.Equals(\"LoadInSeparateAppDomainAttribute\"));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This is what PathAssemblyResolver is supposed to get around if you give it all the relevant assemblies, right? I'd initially had MSBuild in that list for cases like this, and it failed some test(s)\u2014I forget why exactly\u2014so I took it out. Maybe the solution is to add it back but with some condition?",
              "createdAt": "2022-02-12T00:23:18Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,31 +38,47 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;\n+                }\n+            }\n+            catch (Exception) { }\n+            _type ??= type;\n             _assembly = assemblyLoadInfo;\n             _loadedAssembly = loadedAssembly;\n \n             CheckForHardcodedSTARequirement();\n-            HasLoadInSeparateAppDomainAttribute();\n-            HasSTAThreadAttribute();\n+            _hasLoadInSeparateAppDomainAttribute = loadedAssembly is null ?\n+                this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */) :\n+#if NET35\n+                false; // Should never reach here.\n+#else\n+                CustomAttributeData.GetCustomAttributes(type).Any(attr => attr.AttributeType.Name.Equals(\"LoadInSeparateAppDomainAttribute\"));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Looking at it again, I had taken out those paths because it failed with an error about not loading the same assembly into a MetadataLoadContext twice. I put in a messy fix:\r\n```C#\r\nstring[] runtimePaths = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), \"*.dll\");\r\nstring[] msbuildPaths = Directory.GetFiles(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), \"*.dll\");\r\nList<string> localPaths = new(Directory.GetFiles(Path.GetDirectoryName(path), \"*.dll\").Where(localPath => !msbuildPaths.Any(msbuildPath => Path.GetFileName(msbuildPath).Equals(Path.GetFileName(localPath), StringComparison.OrdinalIgnoreCase))));\r\nlocalPaths.AddRange(msbuildPaths);\r\nlocalPaths.AddRange(runtimePaths.Where(runPath => !msbuildPaths.Any(msbuildPath => Path.GetFileName(msbuildPath).Equals(Path.GetFileName(runPath), StringComparison.OrdinalIgnoreCase))));\r\n```\r\n\r\nThat meant it was able to load the assembly, but it didn't help with getting LoadInSeparateAppDomainAttribute properly recognized. (I don't think it should matter which LoadInSeparateAppDomainAttribute we use\u2014that is, from which MSBuild assembly\u2014because I was just comparing based on name.)",
              "createdAt": "2022-02-12T00:56:48Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,31 +38,47 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;\n+                }\n+            }\n+            catch (Exception) { }\n+            _type ??= type;\n             _assembly = assemblyLoadInfo;\n             _loadedAssembly = loadedAssembly;\n \n             CheckForHardcodedSTARequirement();\n-            HasLoadInSeparateAppDomainAttribute();\n-            HasSTAThreadAttribute();\n+            _hasLoadInSeparateAppDomainAttribute = loadedAssembly is null ?\n+                this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */) :\n+#if NET35\n+                false; // Should never reach here.\n+#else\n+                CustomAttributeData.GetCustomAttributes(type).Any(attr => attr.AttributeType.Name.Equals(\"LoadInSeparateAppDomainAttribute\"));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why add a new-but-unused argument?",
              "createdAt": "2022-04-29T16:47:40Z",
              "path": "src/MSBuildTaskHost/TypeLoader.cs",
              "diffHunk": "@@ -130,7 +130,8 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)\n         internal LoadedType Load\n         (\n             string typeName,\n-            AssemblyLoadInfo assembly\n+            AssemblyLoadInfo assembly,\n+            bool _",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Ah: to match the signature of the full framework copy. Needs a comment please.",
              "createdAt": "2022-04-29T17:04:46Z",
              "path": "src/MSBuildTaskHost/TypeLoader.cs",
              "diffHunk": "@@ -130,7 +130,8 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)\n         internal LoadedType Load\n         (\n             string typeName,\n-            AssemblyLoadInfo assembly\n+            AssemblyLoadInfo assembly,\n+            bool _",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please comment this.",
              "createdAt": "2022-04-29T16:48:33Z",
              "path": "src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs",
              "diffHunk": "@@ -149,11 +150,20 @@ public bool Initialize(string taskName, IDictionary<string, string> factoryIdent\n         /// </summary>\n         public TaskPropertyInfo[] GetTaskParameters()\n         {\n-            PropertyInfo[] infos = _loadedType.Type.GetProperties(BindingFlags.Instance | BindingFlags.Public);\n-            var propertyInfos = new TaskPropertyInfo[infos.Length];\n-            for (int i = 0; i < infos.Length; i++)\n+            PropertyInfo[] properties = (_loadedType.LoadedAssembly?.GetType(_loadedType.Type.Name) ?? _loadedType.Type).GetProperties(BindingFlags.Instance | BindingFlags.Public);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I ended up deleting most of this and moving it into LoadedType.",
              "createdAt": "2022-05-07T02:44:37Z",
              "path": "src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs",
              "diffHunk": "@@ -149,11 +150,20 @@ public bool Initialize(string taskName, IDictionary<string, string> factoryIdent\n         /// </summary>\n         public TaskPropertyInfo[] GetTaskParameters()\n         {\n-            PropertyInfo[] infos = _loadedType.Type.GetProperties(BindingFlags.Instance | BindingFlags.Public);\n-            var propertyInfos = new TaskPropertyInfo[infos.Length];\n-            for (int i = 0; i < infos.Length; i++)\n+            PropertyInfo[] properties = (_loadedType.LoadedAssembly?.GetType(_loadedType.Type.Name) ?? _loadedType.Type).GetProperties(BindingFlags.Instance | BindingFlags.Public);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You need `System.Reflection.Metadata.dll` too, right?",
              "createdAt": "2022-04-29T16:50:19Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -40,6 +40,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config\n   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "We don't own inserting System.Reflection.Metadata, and it seems to get copied in anyway, presumably as a dependency. I can add it anyway\u2014I don't think it would hurt\u2014not sure about whether it's recommended or not.",
              "createdAt": "2022-04-29T19:33:57Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -40,6 +40,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config\n   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this _have_ to be `ngenPriority=1`? If not we should probably avoid it since it shouldn't be called on the critical VS startup codepaths.",
              "createdAt": "2022-04-29T16:51:55Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -40,6 +40,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config\n   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Honestly, I don't know what the priority means there. Should it be 0 or 2? (Not sure which is higher) What does that means in terms of when it gets ngen'd?",
              "createdAt": "2022-04-29T19:35:08Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -40,6 +40,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config\n   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Try separate insertion without ngen priority marked at all to see if it crashes and burns (for ngen'ing overnight instead of during setup)",
              "createdAt": "2022-05-09T15:28:08Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -40,6 +40,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config\n   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Did you figure out that this was required?",
              "createdAt": "2022-05-12T15:51:41Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -40,6 +40,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config\n   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Ping on this.",
              "createdAt": "2022-06-24T15:03:22Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -40,6 +40,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config\n   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I could've sworn I'd mentioned the results of this, but I guess not. It's required, apparently:\r\nhttps://dev.azure.com/devdiv/DevDiv/_git/VS/pullrequest/398885",
              "createdAt": "2022-06-28T21:22:12Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -40,6 +40,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config\n   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you comment this?",
              "createdAt": "2022-04-29T16:55:25Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,55 +38,78 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Now deleted.",
              "createdAt": "2022-05-07T02:56:57Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,55 +38,78 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I get what the code in this block is doing, but what's the reasoning behind this check?",
              "createdAt": "2022-04-29T16:59:51Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,55 +38,78 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;\n+                }\n+            }\n+            catch (Exception) { }\n+            _type ??= type;\n             _assembly = assemblyLoadInfo;\n             _loadedAssembly = loadedAssembly;\n \n-            CheckForHardcodedSTARequirement();\n-            HasLoadInSeparateAppDomainAttribute();\n-            HasSTAThreadAttribute();\n+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();\n+            if (loadedAssembly is null)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "loadedAssembly is null here if the assembly had previously been loaded and searched for types. In that case, we should've already loaded the type (for real), so we can pull information from it.",
              "createdAt": "2022-04-29T20:21:55Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,55 +38,78 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;\n+                }\n+            }\n+            catch (Exception) { }\n+            _type ??= type;\n             _assembly = assemblyLoadInfo;\n             _loadedAssembly = loadedAssembly;\n \n-            CheckForHardcodedSTARequirement();\n-            HasLoadInSeparateAppDomainAttribute();\n-            HasSTAThreadAttribute();\n+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();\n+            if (loadedAssembly is null)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                // If the type is already loaded, check for its attribute directly\r\n                HasLoadInSeparateAppDomainAttribute = this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */);\r\n```",
              "createdAt": "2022-04-29T17:00:32Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,55 +38,78 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;\n+                }\n+            }\n+            catch (Exception) { }\n+            _type ??= type;\n             _assembly = assemblyLoadInfo;\n             _loadedAssembly = loadedAssembly;\n \n-            CheckForHardcodedSTARequirement();\n-            HasLoadInSeparateAppDomainAttribute();\n-            HasSTAThreadAttribute();\n+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();\n+            if (loadedAssembly is null)\n+            {\n+                HasLoadInSeparateAppDomainAttribute = this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this cause problems in a TaskHost? If not, comment why please.",
              "createdAt": "2022-04-29T17:00:51Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,55 +38,78 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;\n+                }\n+            }\n+            catch (Exception) { }\n+            _type ??= type;\n             _assembly = assemblyLoadInfo;\n             _loadedAssembly = loadedAssembly;\n \n-            CheckForHardcodedSTARequirement();\n-            HasLoadInSeparateAppDomainAttribute();\n-            HasSTAThreadAttribute();\n+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();\n+            if (loadedAssembly is null)\n+            {\n+                HasLoadInSeparateAppDomainAttribute = this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */);\n+                HasSTAThreadAttribute = this.Type.GetTypeInfo().IsDefined(typeof(RunInSTAAttribute), true /* inherited */);\n+                IsMarshalByRef = this.Type.GetTypeInfo().IsMarshalByRef;\n+            }\n+            else\n+            {\n+#if !NET35",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                // MetadataLoadContext-loaded Type objects don't support testing\r\n                // for inherited attributes, so manually walk the BaseType chain\r\n\r\n                Type t = type;\r\n```",
              "createdAt": "2022-04-29T17:02:13Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,55 +38,78 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;\n+                }\n+            }\n+            catch (Exception) { }\n+            _type ??= type;\n             _assembly = assemblyLoadInfo;\n             _loadedAssembly = loadedAssembly;\n \n-            CheckForHardcodedSTARequirement();\n-            HasLoadInSeparateAppDomainAttribute();\n-            HasSTAThreadAttribute();\n+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();\n+            if (loadedAssembly is null)\n+            {\n+                HasLoadInSeparateAppDomainAttribute = this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */);\n+                HasSTAThreadAttribute = this.Type.GetTypeInfo().IsDefined(typeof(RunInSTAAttribute), true /* inherited */);\n+                IsMarshalByRef = this.Type.GetTypeInfo().IsMarshalByRef;\n+            }\n+            else\n+            {\n+#if !NET35\n+                Type t = type;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Tiny perf optimization possibility: walk the list only once and check for both attributes.",
              "createdAt": "2022-04-29T17:03:15Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -36,55 +38,78 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n \n-            _type = type;\n+            try\n+            {\n+                Type t = Type.GetType(type.AssemblyQualifiedName);\n+                if (t.Assembly.Location.Equals(loadedAssembly.Location, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    _type = t;\n+                }\n+            }\n+            catch (Exception) { }\n+            _type ??= type;\n             _assembly = assemblyLoadInfo;\n             _loadedAssembly = loadedAssembly;\n \n-            CheckForHardcodedSTARequirement();\n-            HasLoadInSeparateAppDomainAttribute();\n-            HasSTAThreadAttribute();\n+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();\n+            if (loadedAssembly is null)\n+            {\n+                HasLoadInSeparateAppDomainAttribute = this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */);\n+                HasSTAThreadAttribute = this.Type.GetTypeInfo().IsDefined(typeof(RunInSTAAttribute), true /* inherited */);\n+                IsMarshalByRef = this.Type.GetTypeInfo().IsMarshalByRef;\n+            }\n+            else\n+            {\n+#if !NET35\n+                Type t = type;\n+                while (t is not null)\n+                {\n+                    if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(\"LoadInSeparateAppDomainAttribute\")))\n+                    {\n+                        HasLoadInSeparateAppDomainAttribute = true;\n+                    }\n+\n+                    if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(\"RunInSTAAttribute\")))",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems very heavyweight. What would the implications be of only supporting this codepath when given a path?",
              "createdAt": "2022-04-29T17:18:03Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -169,8 +168,33 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again\n                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);\n             }\n+        }\n+\n+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)\n+        {\n+            string path = assemblyLoadInfo.AssemblyFile;\n+\n+            if (path is null)\n+            {\n+#if NETFRAMEWORK\n+                AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;\n+                setup.LoaderOptimization = LoaderOptimization.SingleDomain;\n+                AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\", null, setup);\n+                path = appDomain.Load(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                AppDomain.Unload(appDomain);\n+#else\n+                AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                path = alc.LoadFromAssemblyName(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                alc.Unload();\n+#endif",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "As I recall, you brought this up for the System.Reflection.Metadata version as well, and removing it made it fail some tests. I don't remember if we ultimately decided we needed it or not. I can look at the other PR at some point.",
              "createdAt": "2022-05-07T03:13:06Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -169,8 +168,33 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again\n                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);\n             }\n+        }\n+\n+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)\n+        {\n+            string path = assemblyLoadInfo.AssemblyFile;\n+\n+            if (path is null)\n+            {\n+#if NETFRAMEWORK\n+                AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;\n+                setup.LoaderOptimization = LoaderOptimization.SingleDomain;\n+                AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\", null, setup);\n+                path = appDomain.Load(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                AppDomain.Unload(appDomain);\n+#else\n+                AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                path = alc.LoadFromAssemblyName(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                alc.Unload();\n+#endif",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Did you figure this out?",
              "createdAt": "2022-05-12T15:53:54Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -169,8 +168,33 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again\n                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);\n             }\n+        }\n+\n+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)\n+        {\n+            string path = assemblyLoadInfo.AssemblyFile;\n+\n+            if (path is null)\n+            {\n+#if NETFRAMEWORK\n+                AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;\n+                setup.LoaderOptimization = LoaderOptimization.SingleDomain;\n+                AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\", null, setup);\n+                path = appDomain.Load(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                AppDomain.Unload(appDomain);\n+#else\n+                AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                path = alc.LoadFromAssemblyName(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                alc.Unload();\n+#endif",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can this be cached in a static so we don't have to grovel the disk for every UsingTask?",
              "createdAt": "2022-04-29T17:19:00Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -169,8 +168,33 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again\n                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);\n             }\n+        }\n+\n+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)\n+        {\n+            string path = assemblyLoadInfo.AssemblyFile;\n+\n+            if (path is null)\n+            {\n+#if NETFRAMEWORK\n+                AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;\n+                setup.LoaderOptimization = LoaderOptimization.SingleDomain;\n+                AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\", null, setup);\n+                path = appDomain.Load(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                AppDomain.Unload(appDomain);\n+#else\n+                AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                path = alc.LoadFromAssemblyName(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                alc.Unload();\n+#endif\n+            }\n+\n+            string[] runtimePaths = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), \"*.dll\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I tried doing this and using Concat as you suggested below, and MetadataLoadContext failed to load the assembly. Not even that the assembly was missing information; it just insta-failed. I have no idea why, since it seemed eminently reasonable.",
              "createdAt": "2022-05-07T03:49:15Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -169,8 +168,33 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again\n                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);\n             }\n+        }\n+\n+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)\n+        {\n+            string path = assemblyLoadInfo.AssemblyFile;\n+\n+            if (path is null)\n+            {\n+#if NETFRAMEWORK\n+                AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;\n+                setup.LoaderOptimization = LoaderOptimization.SingleDomain;\n+                AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\", null, setup);\n+                path = appDomain.Load(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                AppDomain.Unload(appDomain);\n+#else\n+                AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                path = alc.LoadFromAssemblyName(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                alc.Unload();\n+#endif\n+            }\n+\n+            string[] runtimePaths = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), \"*.dll\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Should we debug that? Explictly enumerating the same directory for every task (once we move to detecting taskhostness) seems likely to be expensive.",
              "createdAt": "2022-05-12T15:55:13Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -169,8 +168,33 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again\n                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);\n             }\n+        }\n+\n+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)\n+        {\n+            string path = assemblyLoadInfo.AssemblyFile;\n+\n+            if (path is null)\n+            {\n+#if NETFRAMEWORK\n+                AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;\n+                setup.LoaderOptimization = LoaderOptimization.SingleDomain;\n+                AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\", null, setup);\n+                path = appDomain.Load(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                AppDomain.Unload(appDomain);\n+#else\n+                AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                path = alc.LoadFromAssemblyName(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                alc.Unload();\n+#endif\n+            }\n+\n+            string[] runtimePaths = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), \"*.dll\");",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If you can do the cached static, I would actually use LINQ `Concat` here to avoid making a copy of the list.",
              "createdAt": "2022-04-29T17:21:24Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -169,8 +168,33 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)\n                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again\n                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);\n             }\n+        }\n+\n+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)\n+        {\n+            string path = assemblyLoadInfo.AssemblyFile;\n+\n+            if (path is null)\n+            {\n+#if NETFRAMEWORK\n+                AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;\n+                setup.LoaderOptimization = LoaderOptimization.SingleDomain;\n+                AppDomain appDomain = AppDomain.CreateDomain(\"appDomainToFindPath\", null, setup);\n+                path = appDomain.Load(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                AppDomain.Unload(appDomain);\n+#else\n+                AssemblyLoadContext alc = new(\"loadContextToFindPath\", true);\n+                path = alc.LoadFromAssemblyName(new AssemblyName(assemblyLoadInfo.AssemblyName)).Location;\n+                alc.Unload();\n+#endif\n+            }\n+\n+            string[] runtimePaths = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), \"*.dll\");\n+            List<string> localPaths = new(Directory.GetFiles(Path.GetDirectoryName(path), \"*.dll\"));\n+            localPaths.AddRange(runtimePaths);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "style nit: for bool args I always want\r\n\r\n```suggestion\r\n            return GetLoadedType(s_cacheOfReflectionOnlyLoadedTypesByFilter, typeName, assembly, useTaskHost: false);\r\n```",
              "createdAt": "2022-04-29T17:22:13Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -199,15 +224,15 @@ internal LoadedType ReflectionOnlyLoad\n             AssemblyLoadInfo assembly\n         )\n         {\n-            return GetLoadedType(s_cacheOfReflectionOnlyLoadedTypesByFilter, typeName, assembly);\n+            return GetLoadedType(s_cacheOfReflectionOnlyLoadedTypesByFilter, typeName, assembly, false);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wrap in ETW to see how long it takes and consider if it's worth it to eagerly get all the information about all the types rather than just the one.",
              "createdAt": "2022-05-09T15:11:35Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -336,14 +368,33 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)\n                     return null;\n                 });\n \n-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;\n+                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly ?? type.Assembly, loadedViaMetadataLoadContext: false) : null;\n+            }\n+\n+            private LoadedType GetLoadedTypeFromTypeNameUsingMetadataLoadContext(string typeName)\n+            {\n+                return _publicTypeNameToLoadedType.GetOrAdd(typeName, typeName =>",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "File bug on .NET Runtime for can't use old version here.",
              "createdAt": "2022-05-09T15:14:07Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -15,91 +19,149 @@ namespace Microsoft.Build.Shared\n     /// </summary>\n     internal sealed class LoadedType\n     {\n-        #region Constructors\n-\n-        /// <summary>\n-        /// Creates an instance of this class for the given type.\n-        /// </summary>\n-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo)\n-            : this(type, assemblyLoadInfo, null)\n-        {\n-        }\n+        #region Constructor\n \n         /// <summary>\n         /// Creates an instance of this class for the given type.\n         /// </summary>\n         /// <param name=\"type\">The Type to be loaded</param>\n         /// <param name=\"assemblyLoadInfo\">Information used to load the assembly</param>\n         /// <param name=\"loadedAssembly\">The assembly which has been loaded, if any</param>\n-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly)\n+        /// <param name=\"loadedViaMetadataLoadContext\">Whether this type was loaded via MetadataLoadContext</param>\n+        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly, bool loadedViaMetadataLoadContext = false)\n         {\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n+            ErrorUtilities.VerifyThrow(loadedAssembly is not null, \"The assembly should always be loaded even if only by MetadataLoadContext.\");\n+\n+            Type = type;\n+            Assembly = assemblyLoadInfo;\n+\n+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();\n+            LoadedAssemblyName = loadedAssembly.GetName();\n+            Path = loadedAssembly.Location;\n+            LoadedAssembly = loadedAssembly;\n+\n+#if !NET35\n+            // Properties set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the\n+            // properties and reflect over them without needing them to be fully loaded, so it also isn't need for TaskHosts.\n+            // MetadataLoadContext-loaded Type objects don't support testing for inherited attributes, so we manually walk the BaseType chain.\n+            Type t = type;\n+            while (t is not null)\n+            {\n+                if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(LoadInSeparateAppDomainAttribute))))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "https://github.com/dotnet/runtime/issues/69066",
              "createdAt": "2022-05-09T18:51:35Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -15,91 +19,149 @@ namespace Microsoft.Build.Shared\n     /// </summary>\n     internal sealed class LoadedType\n     {\n-        #region Constructors\n-\n-        /// <summary>\n-        /// Creates an instance of this class for the given type.\n-        /// </summary>\n-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo)\n-            : this(type, assemblyLoadInfo, null)\n-        {\n-        }\n+        #region Constructor\n \n         /// <summary>\n         /// Creates an instance of this class for the given type.\n         /// </summary>\n         /// <param name=\"type\">The Type to be loaded</param>\n         /// <param name=\"assemblyLoadInfo\">Information used to load the assembly</param>\n         /// <param name=\"loadedAssembly\">The assembly which has been loaded, if any</param>\n-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly)\n+        /// <param name=\"loadedViaMetadataLoadContext\">Whether this type was loaded via MetadataLoadContext</param>\n+        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly, bool loadedViaMetadataLoadContext = false)\n         {\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n+            ErrorUtilities.VerifyThrow(loadedAssembly is not null, \"The assembly should always be loaded even if only by MetadataLoadContext.\");\n+\n+            Type = type;\n+            Assembly = assemblyLoadInfo;\n+\n+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();\n+            LoadedAssemblyName = loadedAssembly.GetName();\n+            Path = loadedAssembly.Location;\n+            LoadedAssembly = loadedAssembly;\n+\n+#if !NET35\n+            // Properties set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the\n+            // properties and reflect over them without needing them to be fully loaded, so it also isn't need for TaskHosts.\n+            // MetadataLoadContext-loaded Type objects don't support testing for inherited attributes, so we manually walk the BaseType chain.\n+            Type t = type;\n+            while (t is not null)\n+            {\n+                if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(LoadInSeparateAppDomainAttribute))))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Ask about in what cases I could just check if a type \"is\" another type",
              "createdAt": "2022-05-09T15:21:09Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -15,91 +19,149 @@ namespace Microsoft.Build.Shared\n     /// </summary>\n     internal sealed class LoadedType\n     {\n-        #region Constructors\n-\n-        /// <summary>\n-        /// Creates an instance of this class for the given type.\n-        /// </summary>\n-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo)\n-            : this(type, assemblyLoadInfo, null)\n-        {\n-        }\n+        #region Constructor\n \n         /// <summary>\n         /// Creates an instance of this class for the given type.\n         /// </summary>\n         /// <param name=\"type\">The Type to be loaded</param>\n         /// <param name=\"assemblyLoadInfo\">Information used to load the assembly</param>\n         /// <param name=\"loadedAssembly\">The assembly which has been loaded, if any</param>\n-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly)\n+        /// <param name=\"loadedViaMetadataLoadContext\">Whether this type was loaded via MetadataLoadContext</param>\n+        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly, bool loadedViaMetadataLoadContext = false)\n         {\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n+            ErrorUtilities.VerifyThrow(loadedAssembly is not null, \"The assembly should always be loaded even if only by MetadataLoadContext.\");\n+\n+            Type = type;\n+            Assembly = assemblyLoadInfo;\n+\n+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();\n+            LoadedAssemblyName = loadedAssembly.GetName();\n+            Path = loadedAssembly.Location;\n+            LoadedAssembly = loadedAssembly;\n+\n+#if !NET35\n+            // Properties set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the\n+            // properties and reflect over them without needing them to be fully loaded, so it also isn't need for TaskHosts.\n+            // MetadataLoadContext-loaded Type objects don't support testing for inherited attributes, so we manually walk the BaseType chain.\n+            Type t = type;\n+            while (t is not null)\n+            {\n+                if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(LoadInSeparateAppDomainAttribute))))\n+                {\n+                    HasLoadInSeparateAppDomainAttribute = true;\n+                }\n+\n+                if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(RunInSTAAttribute))))\n+                {\n+                    HasSTAThreadAttribute = true;\n+                }\n+\n+                if (t.IsMarshalByRef)\n+                {\n+                    IsMarshalByRef = true;\n+                }\n+\n+                t = t.BaseType;\n+            }\n+\n+            PropertyInfo[] props = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);\n+            Properties = new ReflectableTaskPropertyInfo[props.Length];\n+            if (loadedViaMetadataLoadContext)\n+            {\n+                PropertyAssemblyQualifiedNames = new string[props.Length];\n+            }\n \n-            _type = type;\n-            _assembly = assemblyLoadInfo;\n-            _loadedAssembly = loadedAssembly;\n+            for (int i = 0; i < props.Length; i++)\n+            {\n+                bool outputAttribute = false;\n+                bool requiredAttribute = false;\n+                foreach (CustomAttributeData attr in CustomAttributeData.GetCustomAttributes(props[i]))\n+                {\n+                    if (attr.AttributeType.Name.Equals(nameof(OutputAttribute)))\n+                    {\n+                        outputAttribute = true;\n+                    }\n+                    else if (attr.AttributeType.Name.Equals(nameof(RequiredAttribute)))\n+                    {\n+                        requiredAttribute = true;\n+                    }\n+                }\n+\n+                bool isAssignableToITask = false;\n+\n+                // Check whether it's assignable to ITaskItem or ITaskItem[]. Simplify to just checking for ITaskItem.\n+                Type pt = props[i].PropertyType;\n+                if (pt.IsArray)\n+                {\n+                    pt = pt.GetElementType();\n+                }\n+\n+                // Microsoft.Build.Framework.ITaskItem is different when loaded normally versus via MetadataLoadContext. This is the only reliable way to see\n+                // whether this property derives from ITaskItem.\n+                while (pt is not null)\n+                {\n+                    if (pt.FullName.Equals(\"Microsoft.Build.Framework.ITaskItem\"))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "https://github.com/dotnet/docs/issues/29336",
              "createdAt": "2022-05-09T20:30:13Z",
              "path": "src/Shared/LoadedType.cs",
              "diffHunk": "@@ -15,91 +19,149 @@ namespace Microsoft.Build.Shared\n     /// </summary>\n     internal sealed class LoadedType\n     {\n-        #region Constructors\n-\n-        /// <summary>\n-        /// Creates an instance of this class for the given type.\n-        /// </summary>\n-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo)\n-            : this(type, assemblyLoadInfo, null)\n-        {\n-        }\n+        #region Constructor\n \n         /// <summary>\n         /// Creates an instance of this class for the given type.\n         /// </summary>\n         /// <param name=\"type\">The Type to be loaded</param>\n         /// <param name=\"assemblyLoadInfo\">Information used to load the assembly</param>\n         /// <param name=\"loadedAssembly\">The assembly which has been loaded, if any</param>\n-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly)\n+        /// <param name=\"loadedViaMetadataLoadContext\">Whether this type was loaded via MetadataLoadContext</param>\n+        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly, bool loadedViaMetadataLoadContext = false)\n         {\n             ErrorUtilities.VerifyThrow(type != null, \"We must have the type.\");\n             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, \"We must have the assembly the type was loaded from.\");\n+            ErrorUtilities.VerifyThrow(loadedAssembly is not null, \"The assembly should always be loaded even if only by MetadataLoadContext.\");\n+\n+            Type = type;\n+            Assembly = assemblyLoadInfo;\n+\n+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();\n+            LoadedAssemblyName = loadedAssembly.GetName();\n+            Path = loadedAssembly.Location;\n+            LoadedAssembly = loadedAssembly;\n+\n+#if !NET35\n+            // Properties set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the\n+            // properties and reflect over them without needing them to be fully loaded, so it also isn't need for TaskHosts.\n+            // MetadataLoadContext-loaded Type objects don't support testing for inherited attributes, so we manually walk the BaseType chain.\n+            Type t = type;\n+            while (t is not null)\n+            {\n+                if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(LoadInSeparateAppDomainAttribute))))\n+                {\n+                    HasLoadInSeparateAppDomainAttribute = true;\n+                }\n+\n+                if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(RunInSTAAttribute))))\n+                {\n+                    HasSTAThreadAttribute = true;\n+                }\n+\n+                if (t.IsMarshalByRef)\n+                {\n+                    IsMarshalByRef = true;\n+                }\n+\n+                t = t.BaseType;\n+            }\n+\n+            PropertyInfo[] props = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);\n+            Properties = new ReflectableTaskPropertyInfo[props.Length];\n+            if (loadedViaMetadataLoadContext)\n+            {\n+                PropertyAssemblyQualifiedNames = new string[props.Length];\n+            }\n \n-            _type = type;\n-            _assembly = assemblyLoadInfo;\n-            _loadedAssembly = loadedAssembly;\n+            for (int i = 0; i < props.Length; i++)\n+            {\n+                bool outputAttribute = false;\n+                bool requiredAttribute = false;\n+                foreach (CustomAttributeData attr in CustomAttributeData.GetCustomAttributes(props[i]))\n+                {\n+                    if (attr.AttributeType.Name.Equals(nameof(OutputAttribute)))\n+                    {\n+                        outputAttribute = true;\n+                    }\n+                    else if (attr.AttributeType.Name.Equals(nameof(RequiredAttribute)))\n+                    {\n+                        requiredAttribute = true;\n+                    }\n+                }\n+\n+                bool isAssignableToITask = false;\n+\n+                // Check whether it's assignable to ITaskItem or ITaskItem[]. Simplify to just checking for ITaskItem.\n+                Type pt = props[i].PropertyType;\n+                if (pt.IsArray)\n+                {\n+                    pt = pt.GetElementType();\n+                }\n+\n+                // Microsoft.Build.Framework.ITaskItem is different when loaded normally versus via MetadataLoadContext. This is the only reliable way to see\n+                // whether this property derives from ITaskItem.\n+                while (pt is not null)\n+                {\n+                    if (pt.FullName.Equals(\"Microsoft.Build.Framework.ITaskItem\"))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Add comment",
              "createdAt": "2022-05-09T15:31:14Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -1008,12 +1016,37 @@ private bool SetTaskParameter\n             try\n             {\n                 // check if the task has a .NET property corresponding to the parameter\n-                TaskPropertyInfo parameter = _taskFactoryWrapper.GetProperty(parameterName);\n+                LoadedType loadedType = _taskFactoryWrapper.TaskFactoryLoadedType;\n+                int indexOfParameter = -1;\n+                for (int i = 0; i < loadedType.Properties.Length; i++)\n+                {\n+                    if (loadedType.Properties[i].Name.Equals(parameterName))\n+                    {\n+                        indexOfParameter = i;\n+                        break;\n+                    }\n+                }\n \n-                if (parameter != null)\n+                TaskPropertyInfo parameter = null;\n+                Type parameterType = null;\n+                if (indexOfParameter != -1)\n+                {\n+                    parameter = loadedType.Properties[indexOfParameter];\n+                    parameterType = Type.GetType(\n+                        loadedType.PropertyAssemblyQualifiedNames?[indexOfParameter] ??\n+                        parameter.PropertyType.AssemblyQualifiedName);\n+                }\n+                else",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Add comment that I'm overriding the default value we figure out for IsAssignableToITask",
              "createdAt": "2022-05-09T15:34:07Z",
              "path": "src/Build/Instance/ReflectableTaskPropertyInfo.cs",
              "diffHunk": "@@ -52,6 +52,17 @@ internal ReflectableTaskPropertyInfo(PropertyInfo propertyInfo)\n             _propertyInfo = propertyInfo;\n         }\n \n+        internal ReflectableTaskPropertyInfo(PropertyInfo propertyInfo, bool output, bool required, bool IsAssignableToITaskItemType)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should these have a `codeBase` like the others do?",
              "createdAt": "2022-05-12T15:50:17Z",
              "path": "src/MSBuild/app.amd64.config",
              "diffHunk": "@@ -91,6 +91,14 @@\n           <bindingRedirect oldVersion=\"0.0.0.0-4.1.4.0\" newVersion=\"4.1.4.0\" />\n           <codeBase version=\"4.1.4.0\" href=\"..\\System.Numerics.Vectors.dll\"/>\n         </dependentAssembly>\n+        <dependentAssembly>\n+          <assemblyIdentity name=\"System.Reflection.Metadata\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\n+          <bindingRedirect oldVersion=\"0.0.0.0-5.0.0.0\" newVersion=\"5.0.0.0\" />\n+        </dependentAssembly>\n+        <dependentAssembly>\n+          <assemblyIdentity name=\"System.Reflection.MetadataLoadContext\" publicKeyToken=\"cc7b13ffcd2ddd51\" culture=\"neutral\" />\n+          <bindingRedirect oldVersion=\"0.0.0.0-5.0.0.0\" newVersion=\"5.0.0.0\" />",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a span that includes the `LoadAssemblyUsingMetadataLoadContext` call, to give us overall \"how slow is this?\" info?",
              "createdAt": "2022-05-12T15:56:20Z",
              "path": "src/Shared/TypeLoader.cs",
              "diffHunk": "@@ -336,14 +369,35 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)\n                     return null;\n                 });\n \n-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;\n+                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly ?? type.Assembly, loadedViaMetadataLoadContext: false) : null;\n+            }\n+\n+            private LoadedType GetLoadedTypeFromTypeNameUsingMetadataLoadContext(string typeName)\n+            {\n+                return _publicTypeNameToLoadedType.GetOrAdd(typeName, typeName =>\n+                {\n+                    Assembly loadedAssembly = LoadAssemblyUsingMetadataLoadContext(_assemblyLoadInfo);\n+                    foreach (Type publicType in loadedAssembly.GetExportedTypes())\n+                    {\n+                        if (_isDesiredType(publicType, null) && (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(publicType.FullName, typeName)))\n+                        {\n+                            MSBuildEventSource.Log.CreateLoadedTypeStart(loadedAssembly.FullName);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}