{
  "number": 7634,
  "title": "MSBuild server",
  "body": "Fixes #7315.\r\n\r\n### Context\r\nAdding an opt-in feature for executing the build in MSBuild server. With this feature turned on, MSBuild sends the build request for execution to the MSBuild server node. This approach avoids to execute targets and tasks into a short-living process from CLI tools like .NET SDK and MSBuild.exe.\r\n\r\n### Changes Made\r\nThis PR implements:\r\n- a new node that accepts build request from client. This approach avoids spawning a new MSBuild process for every build from CLI tools like .NET SDK.\r\n- a new MSBuild client classes able to communicate with MSBuild server node via the named pipe.\r\n- unit tests for the new code path (TODO).\r\n",
  "state": "MERGED",
  "createdAt": "2022-05-18T15:23:18Z",
  "updatedAt": "2022-07-13T19:52:14Z",
  "closedAt": "2022-07-13T19:37:10Z",
  "mergedAt": "2022-07-13T19:37:10Z",
  "additions": 3601,
  "deletions": 370,
  "changedFiles": 74,
  "headRefName": "feature/msbuild-server",
  "isDraft": false,
  "author": {
    "login": "AR-May"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Performance",
    "Area: Engine"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "b0a788d8f8e487e7f2708c309f074ad28df8c09f",
          "message": "[WIP-FEATURE] MSBuild server node (#7489)",
          "committedDate": "2022-04-21T12:24:17Z",
          "author": {
            "name": "MichalPavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3c24e9a54bbf75c5dea50a2a777f2e2dd489df01",
          "message": "Removed IHanshake interface and removed duplicate code from ServerNodeHandshake.",
          "committedDate": "2022-04-25T13:33:46Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3be5f95d8a2915df2e03b6ebfda28e8b85621a9f",
          "message": "[WIP-FEATURE] MSBuild client (#7540)\n\nFixes #7374, #7373\r\n\r\nContext\r\nMSBuild client is a new code path that is triggered with opt-in env variable. It sends the build request for execution to the MSBuild server node. This approach avoids to do execute targets and tasks into a short-living process from CLI tools like .NET SDK and MSBuild.exe.\r\n\r\nChanges Made\r\nThis PR implements a new MSBuild client classes able to communicate with MSBuild server node via the named pipe.\r\n\r\nTesting\r\nManually tested. Automatic tests will be added in another PR.\r\n\r\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>\r\nCo-authored-by: Roman Konecny <rokonecn@microsoft.com>",
          "committedDate": "2022-04-28T11:19:14Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cdacf78b5968eea55d5e15f4969ecfc54dafa118",
          "message": "Change server mutex name generationt to support posix",
          "committedDate": "2022-05-03T12:45:09Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e0a7bc8adb1df733b4e30ac5c15f8d4e511be11e",
          "message": "Fix appending FORCECONSOLECOLOR log parametr",
          "committedDate": "2022-05-09T11:54:55Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f97f022e03df0f8b697290d3eb26882e06a6b74c",
          "message": "Server instrumentation (#7602)\n\n* Some instrumentation\r\n\r\n* Add more details to ETW\r\n\r\n* Use class-wide variables",
          "committedDate": "2022-05-16T11:58:00Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5c2eead81edc4c6e01ce50b87470a3d75c5777fc",
          "message": "Added cancelation feature (#7638)\n\n* Added cancelation feature",
          "committedDate": "2022-05-24T11:22:56Z",
          "author": {
            "name": "MichalPavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5ade6268a8d372c316c0904b0aa32941759baffe",
          "message": "Fix control sequence emission (#7630)\n\n* Fix control sequence emission\r\n* Some cleanup",
          "committedDate": "2022-05-30T14:17:24Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8080b4c167af3a46db4092eac4a71e1b3545a969",
          "message": "Solving memory leak by reusing BuildManager and ProjectRoolElementCache",
          "committedDate": "2022-05-31T08:12:53Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e41cf8a6ff737fe197b89d7c856444a9f39b89b6",
          "message": "Do not clear project root element cache if in auto reload.",
          "committedDate": "2022-05-31T08:13:09Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "447225c121b96cdadf7bec6ca0e8d2ffb15900e2",
          "message": "Reduce if\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2022-05-31T08:13:21Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "836f6ef4d31f43ef7f37b7c99bf61a0bb914b9d0",
          "message": "Solving memory leak by reusing BuildManager and ProjectRoolElementCache (#7655)\n\n* Solving memory leak by reusing BuildManager and ProjectRoolElementCache\r\n* Do not clear project root element cache if in auto reload.",
          "committedDate": "2022-06-02T13:05:09Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "88f571c04e435c39c2617edd0e7e0e4098db54dc",
          "message": "Put msbuild server feature under ChangeWave 17.4. (#7661)",
          "committedDate": "2022-06-02T19:52:23Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "88f3410780d005e9876673bead8c4233346e8206",
          "message": "Add support for MSBUILDDEBUGONSTART env. var. for msbuild server client code path. (#7668)",
          "committedDate": "2022-06-02T19:53:05Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b4a34827a820976a41cd0b114835f2305f292b36",
          "message": "Fix msbuild server process launch. (#7673)",
          "committedDate": "2022-06-06T08:58:42Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "206f91857b144ce66c72663135e32689f34c6a4d",
          "message": "Add test for MSBuild Server (#7592)\n\n* Add giant test for MSBuild Server\r\n* Add comm traces\r\n* Remove test that uses MSBUILDNOINPROCNODE flag: it checks the wrong behavior.\r\n* Add comments about WaitForExit and set a timeout for the process execution.\r\n\r\nCo-authored-by: AR-May <67507805+AR-May@users.noreply.github.com>\r\nCo-authored-by: Roman Konecny <rokonecn@microsoft.com>",
          "committedDate": "2022-06-07T12:27:10Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c2691b13d7e734359fbbccc5c759844648ffbe19",
          "message": "Merge branch 'feature/msbuild-server' of https://github.com/dotnet/msbuild into feature/msbuild-server",
          "committedDate": "2022-06-07T12:57:54Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "90d6f322ac9e08ce654d0f764d1f5039fc8bf9ab",
          "message": "Added cancelation support for client. (#7659)\n\n* Added cancellation support for client.\r\n\r\n* Added cancellation support for client.\r\n\r\n* Fixing wrong merge\r\n\r\n* Removed \"Cancelled\" exit type\r\n\r\n* Resolving comments",
          "committedDate": "2022-06-07T15:17:05Z",
          "author": {
            "name": "MichalPavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4b42b69046ae70cf5490773e77334bd01fc32a88",
          "message": "Fix graceful disconnection (#7701)\n\n* Handle race condition\r\n* Clean running server nodes in tests.",
          "committedDate": "2022-06-16T12:08:10Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "39a56d0daa531e24aff5f04bcbd03dc20bcbec83",
          "message": "Moving public types not intended to use externally to \"Microsoft.Build.Experimental\" namespace. (#7688)",
          "committedDate": "2022-06-16T17:14:29Z",
          "author": {
            "name": "MichalPavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "60179f8bfc42219edee6158e0ab29363f05decdc",
          "message": "Merge branch 'feature/msbuild-server' of https://github.com/dotnet/msbuild into feature/msbuild-server",
          "committedDate": "2022-06-20T08:49:48Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1c9ed2757ed13e8b4af22913d5f9a2a2525270c2",
          "message": "Propagete Console properties to MSBuild Server (#7683)\n\nFixes #7658\r\n\r\nContext\r\nSee #7658\r\n\r\nChanges Made\r\nMSBuild Server clients detects: ConsoleBufferWidth, AcceptAnsiColorCodes, ConsoleIsScreen, ConsoleBackgroundColor of current console and sent it to Server in ServerNodeBuildCommand.\r\nServer overrides ConsoleConfigueation so our loggers can get target console configuration.\r\n\r\nTesting\r\nManual\r\n\r\nNotes\r\nThere are no expected functional changes for NON Server and hence also VS scenarios.\r\n\r\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>\r\nCo-authored-by: AR-May <67507805+AR-May@users.noreply.github.com>",
          "committedDate": "2022-06-20T17:04:07Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c9948384c7b338842d72602275ab4eee092a320d",
          "message": "Merge branch 'feature/msbuild-server' of https://github.com/dotnet/msbuild into feature/msbuild-server",
          "committedDate": "2022-06-21T14:14:56Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dec0fbc3beec227375d72693aac2b6c963a1fdc4",
          "message": "Fix arguments passing to MSBuild Server (#7723)\n\n* Send command line as string[] in dotnet builds.",
          "committedDate": "2022-06-21T18:27:41Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "324efc5066c22d4e93d4bdd54f84b7e8c2cadc57",
          "message": "Merge branch 'main' into feature/msbuild-server",
          "committedDate": "2022-06-23T16:20:18Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b92eeef502ee8f4797174104143726649bcea653",
          "message": "Fix wrong merge.",
          "committedDate": "2022-06-23T16:39:28Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8d2ea0f400c304778b1febe29c98cfc3bfb9166a",
          "message": "Make logging asynchronous",
          "committedDate": "2022-06-24T08:12:45Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8904e83cd24a88001f756c4593ee883e06ab0798",
          "message": "Merge branch 'feature/msbuild-server' of https://github.com/dotnet/msbuild into feature/msbuild-server",
          "committedDate": "2022-06-24T13:46:16Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "981a7bd678b85ad4a7cfdd93da948eb448046ca7",
          "message": "Update src/Build/BackEnd/Client/MSBuildClient.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2022-06-28T12:57:44Z",
          "author": {
            "name": "MichalPavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "93c62a398e01f5b5c6459dbfad6f8e3d609aaf57",
          "message": "MSBuild Server: Always run MSBuild nodes with MSBUILDUSESERVER disabled. (#7745)\n\n* Always run msbuild nodes with MSBUILDUSESERVER disabled.\r\n\r\n* Address PR comment.",
          "committedDate": "2022-06-28T22:26:54Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8032e698241a78222fd47b399aece71d815c4764",
          "message": "Fix copyright info. (#7758)",
          "committedDate": "2022-06-29T13:54:30Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "200fbb9a3eb065295cd7a934a6a9c8f50f4ec3f9",
          "message": "Fixed some commented issues (#7759)\n\n* Fixed some commented issues",
          "committedDate": "2022-06-30T08:06:58Z",
          "author": {
            "name": "MichalPavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "23fb4a6b3ea483d6948a34c28ca0031cf31c84c6",
          "message": "Update doc (#7740)\n\n* Update doc\r\n\r\n* Fixed typo\r\n\r\n* Fixed another typo\r\n\r\n* Update documentation/MSBuild-Server.md\r\n\r\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>\r\n\r\n* Update documentation/MSBuild-Server.md\r\n\r\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>\r\n\r\n* Update documentation/MSBuild-Server.md\r\n\r\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>\r\n\r\n* Update documentation/MSBuild-Server.md\r\n\r\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>\r\n\r\n* Update documentation/MSBuild-Server.md\r\n\r\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>\r\n\r\n* Update documentation/MSBuild-Server.md\r\n\r\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>\r\n\r\n* Resolving comments\r\n\r\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2022-07-01T08:34:21Z",
          "author": {
            "name": "MichalPavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a55907eead3770ecedea8c6882990861fdf56ea9",
          "message": "Merge branch 'main' into feature/msbuild-server",
          "committedDate": "2022-07-01T11:59:01Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7a293b27cfaeefe938662f49ba0f5ec01ccd13c6",
          "message": "Added argument null checking",
          "committedDate": "2022-07-11T14:41:25Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c9a1e6116a16540689d4fa542696228149e0fef1",
          "message": "Delete dead commented code",
          "committedDate": "2022-07-11T14:58:41Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "072b447518f95b2795aa200343cd4ecdde92dfaa",
          "message": "Delete dead code",
          "committedDate": "2022-07-11T15:05:31Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "265f3b71ef986a49b5092e72e9abf45a69352392",
          "message": "prefix mutexes name by msbuild",
          "committedDate": "2022-07-11T18:58:11Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2aa65bac191ca53756c5f383273c1e63f052c7ae",
          "message": "Reuse ConnectToPipeStream from NodeProviderOutOfProcBase",
          "committedDate": "2022-07-11T19:29:20Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ca8f9835ca8f0d3926883733b73a8bdb2b07c044",
          "message": "Merge branch 'feature/msbuild-server' of https://github.com/dotnet/msbuild into feature/msbuild-server\n\n# Conflicts:\n#\tsrc/Build/BackEnd/Client/MSBuildClient.cs",
          "committedDate": "2022-07-11T19:48:56Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e45470ae1d27d9b89199de7ff48c9296f1c4c0ca",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild into feature/msbuild-server\n\n# Conflicts:\n#\tsrc/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt",
          "committedDate": "2022-07-11T21:30:37Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "504f720b4fc99321d34f60169ed0e49a65a3802c",
          "message": "Unshipped api fix",
          "committedDate": "2022-07-11T22:25:42Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c625fc192476a6659e158202ada5707cdb94d84a",
          "message": "Reduces allocations in case the tracing is not enabled (#7814)\n\n* Reduces allocations in case the tracing is not enabled\r\n\r\n* Resolving comment",
          "committedDate": "2022-07-12T09:37:20Z",
          "author": {
            "name": "MichalPavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6d00e2bc08be6c27af5e4cde7356dd1d6ff61a81",
          "message": "Fix msbuild client exit type for connection errors. (#7816)",
          "committedDate": "2022-07-12T14:51:47Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "26b43b08342b1f82b6c5ad5a08814b3316b080b1",
          "message": "Emmit BuildTelemetry event (#7778)",
          "committedDate": "2022-07-12T18:42:49Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "60abe1f122ea18e5166a177ccdc5a2a38a963ab5",
          "message": "Increase console refresh to 25Hz",
          "committedDate": "2022-07-12T19:50:20Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ae46347220111a52978388facddbe5950360868b",
          "message": "Do not recover from TrySendBuildCommand failure",
          "committedDate": "2022-07-13T11:39:08Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9c2f0f3498db4904d3733eaedf134808023965b0",
          "message": "Move *ConcoleConfiguration classes to its own files",
          "committedDate": "2022-07-13T13:31:59Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aa17a3ffbdafecc1ec233c77178b615456708787",
          "message": "Change test timing",
          "committedDate": "2022-07-13T13:44:37Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b87a5bea0531c56b7229ea2e111a3f5dbc0f7c15",
          "message": "Add comment for graph build telemetry project",
          "committedDate": "2022-07-13T13:46:16Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "568e61fc1cc4f4c344b046e823c2a44afac8efde",
          "message": "Fix English in comment",
          "committedDate": "2022-07-13T13:46:39Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Notes from call with @rokonec going over the headlines on this:\r\n\r\n* Looked at MSBuild node stuff and some VBCSCompiler as-a-service stuff\r\n  * Mostly already reviewed\r\n* Some commands that get serialized\r\n* more complex stuff around console capture + serialization\r\n  * batched or 100ms timer\r\n  * could maybe test per-line/write to console\r\n* Commit about memory leak (don't dispose BuildManager in server mode)\r\n* Check ProjectRootElementCache if autoreload\r\n* complex stuff: console properties/redirection status has to be passed in build request, set where possible or stored in a static object instead of Console object itself <-- could be surprising if a logger checks this stuff\r\n* PrepareConsoleColor to use VT100 most of the time\r\n* (self) think about compat with new console logger project\r\n* (self) we should turn this on in the second-stage build",
        "createdAt": "2022-07-12T16:16:13Z",
        "author": {
          "login": "rainersigwald"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "consider setting the awaitable to false",
              "createdAt": "2022-05-18T15:26:03Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests\n+    {\n+        [Fact]\n+        public async Task EmitConsoleMessages()\n+        {\n+            StringBuilder sb = new StringBuilder();\n+            var writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text));\n+\n+            writer.WriteLine(\"Line 1\");\n+            await Task.Delay(300);",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Unit tests do not have synchronization context.",
              "createdAt": "2022-05-27T18:25:59Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests\n+    {\n+        [Fact]\n+        public async Task EmitConsoleMessages()\n+        {\n+            StringBuilder sb = new StringBuilder();\n+            var writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text));\n+\n+            writer.WriteLine(\"Line 1\");\n+            await Task.Delay(300);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: consider _using_ here\r\nhttps://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement",
              "createdAt": "2022-05-18T15:27:43Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests\n+    {\n+        [Fact]\n+        public async Task EmitConsoleMessages()\n+        {\n+            StringBuilder sb = new StringBuilder();\n+            var writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text));\n+\n+            writer.WriteLine(\"Line 1\");\n+            await Task.Delay(300);\n+            writer.Write(\"Line 2\");\n+            writer.Dispose();",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Since dispose call flush using would dispose it after Assert unless we enclose it in specific scope. \r\nI believe in this particular case explicit `Dispose` is better approach as it states intent of disposing object before accessing its mutated StringBuilder.",
              "createdAt": "2022-05-27T18:50:50Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests\n+    {\n+        [Fact]\n+        public async Task EmitConsoleMessages()\n+        {\n+            StringBuilder sb = new StringBuilder();\n+            var writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text));\n+\n+            writer.WriteLine(\"Line 1\");\n+            await Task.Delay(300);\n+            writer.Write(\"Line 2\");\n+            writer.Dispose();",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I used scope for it",
              "createdAt": "2022-06-30T08:09:32Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests\n+    {\n+        [Fact]\n+        public async Task EmitConsoleMessages()\n+        {\n+            StringBuilder sb = new StringBuilder();\n+            var writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text));\n+\n+            writer.WriteLine(\"Line 1\");\n+            await Task.Delay(300);\n+            writer.Write(\"Line 2\");\n+            writer.Dispose();",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: are msbuild test classes usually sealed?",
              "createdAt": "2022-05-18T15:28:26Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "They sometimes are and sometimes aren't. Seems to be correlations within assemblies, and this one mostly is not sealed, but I don't think it hurts.",
              "createdAt": "2022-05-18T17:29:33Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "By running some regex we have 360 non sealed test classes vs 101 sealed classes.\r\nPersonally I do not see any benefit from sealing test classes. In past we I have had derived from abstract test classes leveraging `Template Method design pattern`",
              "createdAt": "2022-05-27T18:47:20Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: consider the Async suffix for async methods\r\nhttps://docs.microsoft.com/en-us/dotnet/csharp/async",
              "createdAt": "2022-05-18T15:29:26Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests\n+    {\n+        [Fact]\n+        public async Task EmitConsoleMessages()",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Reason for Async suffix is to make user of that API get realize that this method shall be somehow awaited.\r\nSince this is unit test and no user will eve call it directly, Async suffix would just be be a noise.",
              "createdAt": "2022-05-27T18:32:05Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests\n+    {\n+        [Fact]\n+        public async Task EmitConsoleMessages()",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: could this be a struct?",
              "createdAt": "2022-05-18T15:30:14Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientExitResult.cs",
              "diffHunk": "@@ -0,0 +1,24 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// Enumeration of the various ways in which the MSBuildClient execution can exit.\n+    /// </summary>\n+    public sealed class MSBuildClientExitResult",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "IMO, in this particular situation using struct would not benefit us.",
              "createdAt": "2022-07-11T08:58:00Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientExitResult.cs",
              "diffHunk": "@@ -0,0 +1,24 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// Enumeration of the various ways in which the MSBuildClient execution can exit.\n+    /// </summary>\n+    public sealed class MSBuildClientExitResult",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "is this tracking both unable to connect & connection dropped?  Does it matter to distinguish?",
              "createdAt": "2022-05-18T15:31:50Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientExitType.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+namespace Microsoft.Build.Execution\n+{\n+    public enum MSBuildClientExitType\n+    {\n+        /// <summary>\n+        /// The MSBuild client successfully processed the build request.\n+        /// </summary>\n+        Success,\n+        /// <summary>\n+        /// Server is busy.\n+        /// </summary>\n+        ServerBusy,\n+        /// <summary>\n+        /// Client was unable to connect to the server.\n+        /// </summary>\n+        ConnectionError,",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Yes, there is a difference in behavior in these two cases. If unable to connected, than the regular build would be invoked as a fallback. It is some problem, it should not normally happen. But we are in the beginning and can afford just to call a regular build right away. If the connection has been dropped, then most probably it happen after some time of build execution (example: customer killed the server process). It is covered with `Unexpected` status. Then the fallback would not be called.",
              "createdAt": "2022-05-19T13:29:38Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientExitType.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+namespace Microsoft.Build.Execution\n+{\n+    public enum MSBuildClientExitType\n+    {\n+        /// <summary>\n+        /// The MSBuild client successfully processed the build request.\n+        /// </summary>\n+        Success,\n+        /// <summary>\n+        /// Server is busy.\n+        /// </summary>\n+        ServerBusy,\n+        /// <summary>\n+        /// Client was unable to connect to the server.\n+        /// </summary>\n+        ConnectionError,",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I think about should we add any warning about this happening. I do not want to make it error. We fallback to normal build often - when the server is busy is one case. And we might as well do it in this case too. \r\n",
              "createdAt": "2022-05-19T13:35:14Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientExitType.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+namespace Microsoft.Build.Execution\n+{\n+    public enum MSBuildClientExitType\n+    {\n+        /// <summary>\n+        /// The MSBuild client successfully processed the build request.\n+        /// </summary>\n+        Success,\n+        /// <summary>\n+        /// Server is busy.\n+        /// </summary>\n+        ServerBusy,\n+        /// <summary>\n+        /// Client was unable to connect to the server.\n+        /// </summary>\n+        ConnectionError,",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "We will have some visibility into it by new telemetry. It is also in comm logs and ETWs if needed.  I recommend to keep it as is.",
              "createdAt": "2022-07-11T14:59:55Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientExitType.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+namespace Microsoft.Build.Execution\n+{\n+    public enum MSBuildClientExitType\n+    {\n+        /// <summary>\n+        /// The MSBuild client successfully processed the build request.\n+        /// </summary>\n+        Success,\n+        /// <summary>\n+        /// Server is busy.\n+        /// </summary>\n+        ServerBusy,\n+        /// <summary>\n+        /// Client was unable to connect to the server.\n+        /// </summary>\n+        ConnectionError,",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "is this also tracking server error?",
              "createdAt": "2022-05-18T15:32:16Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientExitType.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+namespace Microsoft.Build.Execution\n+{\n+    public enum MSBuildClientExitType\n+    {\n+        /// <summary>\n+        /// The MSBuild client successfully processed the build request.\n+        /// </summary>\n+        Success,\n+        /// <summary>\n+        /// Server is busy.\n+        /// </summary>\n+        ServerBusy,\n+        /// <summary>\n+        /// Client was unable to connect to the server.\n+        /// </summary>\n+        ConnectionError,\n+        /// <summary>\n+        /// Client was unable to launch the server.\n+        /// </summary>\n+        LaunchError,\n+        /// <summary>\n+        /// The build stopped unexpectedly, for example,\n+        /// because a named pipe between the server and the client was unexpectedly closed.\n+        /// </summary>\n+        Unexpected,",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Some server errors are tracked here. Vast majority of server fault modes are caught and reported in console.",
              "createdAt": "2022-07-11T09:04:45Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientExitType.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+namespace Microsoft.Build.Execution\n+{\n+    public enum MSBuildClientExitType\n+    {\n+        /// <summary>\n+        /// The MSBuild client successfully processed the build request.\n+        /// </summary>\n+        Success,\n+        /// <summary>\n+        /// Server is busy.\n+        /// </summary>\n+        ServerBusy,\n+        /// <summary>\n+        /// Client was unable to connect to the server.\n+        /// </summary>\n+        ConnectionError,\n+        /// <summary>\n+        /// Client was unable to launch the server.\n+        /// </summary>\n+        LaunchError,\n+        /// <summary>\n+        /// The build stopped unexpectedly, for example,\n+        /// because a named pipe between the server and the client was unexpectedly closed.\n+        /// </summary>\n+        Unexpected,",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "are timeouts also tracked here?",
              "createdAt": "2022-05-18T15:32:47Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientExitType.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+namespace Microsoft.Build.Execution\n+{\n+    public enum MSBuildClientExitType\n+    {\n+        /// <summary>\n+        /// The MSBuild client successfully processed the build request.\n+        /// </summary>\n+        Success,\n+        /// <summary>\n+        /// Server is busy.\n+        /// </summary>\n+        ServerBusy,\n+        /// <summary>\n+        /// Client was unable to connect to the server.\n+        /// </summary>\n+        ConnectionError,\n+        /// <summary>\n+        /// Client was unable to launch the server.\n+        /// </summary>\n+        LaunchError,\n+        /// <summary>\n+        /// The build stopped unexpectedly, for example,\n+        /// because a named pipe between the server and the client was unexpectedly closed.\n+        /// </summary>\n+        Unexpected,",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "It will materialize as `MSBuildClientExitType.ConnectionError`\r\n",
              "createdAt": "2022-07-11T09:16:24Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientExitType.cs",
              "diffHunk": "@@ -0,0 +1,33 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+namespace Microsoft.Build.Execution\n+{\n+    public enum MSBuildClientExitType\n+    {\n+        /// <summary>\n+        /// The MSBuild client successfully processed the build request.\n+        /// </summary>\n+        Success,\n+        /// <summary>\n+        /// Server is busy.\n+        /// </summary>\n+        ServerBusy,\n+        /// <summary>\n+        /// Client was unable to connect to the server.\n+        /// </summary>\n+        ConnectionError,\n+        /// <summary>\n+        /// Client was unable to launch the server.\n+        /// </summary>\n+        LaunchError,\n+        /// <summary>\n+        /// The build stopped unexpectedly, for example,\n+        /// because a named pipe between the server and the client was unexpectedly closed.\n+        /// </summary>\n+        Unexpected,",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "should stream be validated?",
              "createdAt": "2022-05-18T15:33:27Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;",
              "author": {
                "login": "donJoseLuis"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: consider `_packetFactory = new ();`",
              "createdAt": "2022-05-18T15:34:36Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "I prefer to see the class name here, since this line has no declaration.",
              "createdAt": "2022-06-29T13:19:06Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I agree with Alina. I think it's better to use type name in this case, so we don't have to look at the field declaration.",
              "createdAt": "2022-06-30T08:11:24Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Are you sure `Thread` is a good abstraction for this case? In my previous org using Thread in new code was consider introducing legacy code.",
              "createdAt": "2022-05-18T15:37:03Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Well, most of this code I just got from the packetPump from the OutOfProc node. I thought that I might try to reuse it but after that decided that is easier to copy the necessary parts. I suppose you suggest to use tasks instead of threads here, as a more modern way? Or I misunderstood your intention? ",
              "createdAt": "2022-05-19T14:06:35Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Unfortunately, whenever I try to used long running tasks from TPL, some scenarios was hanging while MSBuild dll is hosted in VS. It seems that VS does some magic with thread scheduler and cause thread starvation or such.",
              "createdAt": "2022-05-27T18:36:09Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this also need to be finalized or disposed of or something like that? Or does that happen automatically?",
              "createdAt": "2022-05-18T18:49:09Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());\n+        }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        public void UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        public void RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        public void PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        public void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc)\n+            {\n+                IsBackground = true,\n+                Name = \"MSBuild Client Packet Pump\"\n+            };\n+            _packetPumpThread.Start();\n+        }\n+\n+        /// <summary>\n+        /// Stops the packet pump thread.\n+        /// </summary>\n+        public void Stop()\n+        {\n+            _packetPumpShutdownEvent.Set();\n+            _packetPumpThread?.Join();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It does not happen automatically. However, we have only one instance of this class per process life and it `Stop` is called on happy path. Consequence of not calling `Stop` on error paths are acceptable as it will mostly mean process is about to die and all its owned resources will be freed anyway.",
              "createdAt": "2022-05-27T18:59:02Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());\n+        }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        public void UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        public void RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        public void PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        public void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc)\n+            {\n+                IsBackground = true,\n+                Name = \"MSBuild Client Packet Pump\"\n+            };\n+            _packetPumpThread.Start();\n+        }\n+\n+        /// <summary>\n+        /// Stops the packet pump thread.\n+        /// </summary>\n+        public void Stop()\n+        {\n+            _packetPumpShutdownEvent.Set();\n+            _packetPumpThread?.Join();",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If readTask can be cast to an IAsyncResult anyway, maybe do that here so we don't need as many ifdefs later?",
              "createdAt": "2022-05-18T18:54:50Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());\n+        }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        public void UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        public void RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        public void PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        public void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc)\n+            {\n+                IsBackground = true,\n+                Name = \"MSBuild Client Packet Pump\"\n+            };\n+            _packetPumpThread.Start();\n+        }\n+\n+        /// <summary>\n+        /// Stops the packet pump thread.\n+        /// </summary>\n+        public void Stop()\n+        {\n+            _packetPumpShutdownEvent.Set();\n+            _packetPumpThread?.Join();\n+        }\n+\n+        /// <summary>\n+        /// This method handles the packet pump reading. It will terminate when the terminate event is\n+        /// set.\n+        /// </summary>\n+        /// <remarks>\n+        /// Instead of throwing an exception, puts it in <see cref=\"PacketPumpException\"/> and raises event <see cref=\"PacketPumpErrorEvent\"/>.\n+        /// </remarks>\n+        private void PacketPumpProc()\n+        {\n+            RunReadLoop(_stream, _packetPumpShutdownEvent);\n+        }\n+\n+        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)\n+        {\n+            CommunicationsUtilities.Trace(\"Entering read loop.\");\n+\n+            try\n+            {\n+                byte[] headerByte = new byte[5];\n+#if FEATURE_APM\n+                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Well, it is just one more ifdef. I prefer not to mix these cases with each other.",
              "createdAt": "2022-06-29T15:49:05Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());\n+        }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        public void UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        public void RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        public void PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        public void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc)\n+            {\n+                IsBackground = true,\n+                Name = \"MSBuild Client Packet Pump\"\n+            };\n+            _packetPumpThread.Start();\n+        }\n+\n+        /// <summary>\n+        /// Stops the packet pump thread.\n+        /// </summary>\n+        public void Stop()\n+        {\n+            _packetPumpShutdownEvent.Set();\n+            _packetPumpThread?.Join();\n+        }\n+\n+        /// <summary>\n+        /// This method handles the packet pump reading. It will terminate when the terminate event is\n+        /// set.\n+        /// </summary>\n+        /// <remarks>\n+        /// Instead of throwing an exception, puts it in <see cref=\"PacketPumpException\"/> and raises event <see cref=\"PacketPumpErrorEvent\"/>.\n+        /// </remarks>\n+        private void PacketPumpProc()\n+        {\n+            RunReadLoop(_stream, _packetPumpShutdownEvent);\n+        }\n+\n+        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)\n+        {\n+            CommunicationsUtilities.Trace(\"Entering read loop.\");\n+\n+            try\n+            {\n+                byte[] headerByte = new byte[5];\n+#if FEATURE_APM\n+                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "@AR-May, I'm not sure I understood your reply. I think Nathan proposed to use APM only and avoid TAP (Task asynchronous model), so we could remove all ifdefs in this method and make it more readable.\r\n\r\nAnother option would be copy `CommunicationsUtilities.ReadAsync` method here and use only TAP. But I'm not fan of copying code from project in same solution. I will start discussion what we can do to get rid of these ifdefs in whole repository.",
              "createdAt": "2022-07-01T09:09:40Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());\n+        }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        public void UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        public void RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        public void PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        public void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc)\n+            {\n+                IsBackground = true,\n+                Name = \"MSBuild Client Packet Pump\"\n+            };\n+            _packetPumpThread.Start();\n+        }\n+\n+        /// <summary>\n+        /// Stops the packet pump thread.\n+        /// </summary>\n+        public void Stop()\n+        {\n+            _packetPumpShutdownEvent.Set();\n+            _packetPumpThread?.Join();\n+        }\n+\n+        /// <summary>\n+        /// This method handles the packet pump reading. It will terminate when the terminate event is\n+        /// set.\n+        /// </summary>\n+        /// <remarks>\n+        /// Instead of throwing an exception, puts it in <see cref=\"PacketPumpException\"/> and raises event <see cref=\"PacketPumpErrorEvent\"/>.\n+        /// </remarks>\n+        private void PacketPumpProc()\n+        {\n+            RunReadLoop(_stream, _packetPumpShutdownEvent);\n+        }\n+\n+        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)\n+        {\n+            CommunicationsUtilities.Trace(\"Entering read loop.\");\n+\n+            try\n+            {\n+                byte[] headerByte = new byte[5];\n+#if FEATURE_APM\n+                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "In whole solution we have 22 `#ifdef FEATURE_APM` and only 5 of those in This class. \r\nIf we are gonna to fix it here we shall consider to fix it everywhere.\r\nIf we decide to do so, for safety reason I recommend to do it in different PR.\r\nNote: if I understand it correctly `FEATURE_APM` is on for mono build only. And I think it means mono desktop. \r\n@rainersigwald  Is there is a chance we will not going to support it any time soon?",
              "createdAt": "2022-07-01T09:58:02Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());\n+        }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        public void UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        public void RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        public void PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        public void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc)\n+            {\n+                IsBackground = true,\n+                Name = \"MSBuild Client Packet Pump\"\n+            };\n+            _packetPumpThread.Start();\n+        }\n+\n+        /// <summary>\n+        /// Stops the packet pump thread.\n+        /// </summary>\n+        public void Stop()\n+        {\n+            _packetPumpShutdownEvent.Set();\n+            _packetPumpThread?.Join();\n+        }\n+\n+        /// <summary>\n+        /// This method handles the packet pump reading. It will terminate when the terminate event is\n+        /// set.\n+        /// </summary>\n+        /// <remarks>\n+        /// Instead of throwing an exception, puts it in <see cref=\"PacketPumpException\"/> and raises event <see cref=\"PacketPumpErrorEvent\"/>.\n+        /// </remarks>\n+        private void PacketPumpProc()\n+        {\n+            RunReadLoop(_stream, _packetPumpShutdownEvent);\n+        }\n+\n+        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)\n+        {\n+            CommunicationsUtilities.Trace(\"Entering read loop.\");\n+\n+            try\n+            {\n+                byte[] headerByte = new byte[5];\n+#if FEATURE_APM\n+                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "@MichalPavlik I believe Forgind has another idea than you - to have an ifdef here and to cast readTask to an IAsyncResult and further use it to eliminate the next ifdef. I commented on it. It is not about elimination of APM or TAP case. I agree with rokonec, if we want to remove APM or TAP, better to do it in the whole solution and in separate PR.",
              "createdAt": "2022-07-01T11:52:27Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());\n+        }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        public void UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        public void RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        public void PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        public void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc)\n+            {\n+                IsBackground = true,\n+                Name = \"MSBuild Client Packet Pump\"\n+            };\n+            _packetPumpThread.Start();\n+        }\n+\n+        /// <summary>\n+        /// Stops the packet pump thread.\n+        /// </summary>\n+        public void Stop()\n+        {\n+            _packetPumpShutdownEvent.Set();\n+            _packetPumpThread?.Join();\n+        }\n+\n+        /// <summary>\n+        /// This method handles the packet pump reading. It will terminate when the terminate event is\n+        /// set.\n+        /// </summary>\n+        /// <remarks>\n+        /// Instead of throwing an exception, puts it in <see cref=\"PacketPumpException\"/> and raises event <see cref=\"PacketPumpErrorEvent\"/>.\n+        /// </remarks>\n+        private void PacketPumpProc()\n+        {\n+            RunReadLoop(_stream, _packetPumpShutdownEvent);\n+        }\n+\n+        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)\n+        {\n+            CommunicationsUtilities.Trace(\"Entering read loop.\");\n+\n+            try\n+            {\n+                byte[] headerByte = new byte[5];\n+#if FEATURE_APM\n+                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "@rokonec, I'm afraid it's not (only) for Mono, but mainly for .NET 3.5 which doesn't support TPL. I totally agree with removing of `FEATURE_APM` in whole codebase. It could be done in several different ways:\r\n\r\n1. Avoid TAP and use APM everywhere. This option is here for completeness. I don't want to go this way :)\r\n2. Reference TPL version backported to .NET 3.5 (for assemblies targeting .NET 3.5). Rx team had this backported version, but it seems there is no official package anymore.\r\n3. Use APM in types used in .NET 3.5 scenarios and implement TAP versions in different assembly, which is not referenced from assemblies with .NET 3.5 support.\r\n4. Use APM in types used in .NET 3.5 scenarios and invoke `TaskFactory.FromAsync` on callee side where possible. This option probably introduces additional allocations.\r\n\r\nI would prefer option 2, but we would need to have TPL for .NET 3.5 inside repository or maintain our own package.\r\n\r\n@AR-May, yes, my idea was slightly different. I was thinking about using only APM in this method as it's not `async` and it seems we don't need `Task` in this case.",
              "createdAt": "2022-07-07T07:51:20Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());\n+        }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        public void UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        public void RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        public void PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        public void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc)\n+            {\n+                IsBackground = true,\n+                Name = \"MSBuild Client Packet Pump\"\n+            };\n+            _packetPumpThread.Start();\n+        }\n+\n+        /// <summary>\n+        /// Stops the packet pump thread.\n+        /// </summary>\n+        public void Stop()\n+        {\n+            _packetPumpShutdownEvent.Set();\n+            _packetPumpThread?.Join();\n+        }\n+\n+        /// <summary>\n+        /// This method handles the packet pump reading. It will terminate when the terminate event is\n+        /// set.\n+        /// </summary>\n+        /// <remarks>\n+        /// Instead of throwing an exception, puts it in <see cref=\"PacketPumpException\"/> and raises event <see cref=\"PacketPumpErrorEvent\"/>.\n+        /// </remarks>\n+        private void PacketPumpProc()\n+        {\n+            RunReadLoop(_stream, _packetPumpShutdownEvent);\n+        }\n+\n+        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)\n+        {\n+            CommunicationsUtilities.Trace(\"Entering read loop.\");\n+\n+            try\n+            {\n+                byte[] headerByte = new byte[5];\n+#if FEATURE_APM\n+                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "@MichalPavlik This is great analysis. But, I do not recommend to do so in this PR. this PR I would like to use exactly same code as other part of msbuild to minimize regression in already rather big code changes of this PR.\r\nPlease create a new issue and put it in our backlog.",
              "createdAt": "2022-07-11T15:03:26Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());\n+        }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        public void UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        public void RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        public void PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        public void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc)\n+            {\n+                IsBackground = true,\n+                Name = \"MSBuild Client Packet Pump\"\n+            };\n+            _packetPumpThread.Start();\n+        }\n+\n+        /// <summary>\n+        /// Stops the packet pump thread.\n+        /// </summary>\n+        public void Stop()\n+        {\n+            _packetPumpShutdownEvent.Set();\n+            _packetPumpThread?.Join();\n+        }\n+\n+        /// <summary>\n+        /// This method handles the packet pump reading. It will terminate when the terminate event is\n+        /// set.\n+        /// </summary>\n+        /// <remarks>\n+        /// Instead of throwing an exception, puts it in <see cref=\"PacketPumpException\"/> and raises event <see cref=\"PacketPumpErrorEvent\"/>.\n+        /// </remarks>\n+        private void PacketPumpProc()\n+        {\n+            RunReadLoop(_stream, _packetPumpShutdownEvent);\n+        }\n+\n+        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)\n+        {\n+            CommunicationsUtilities.Trace(\"Entering read loop.\");\n+\n+            try\n+            {\n+                byte[] headerByte = new byte[5];\n+#if FEATURE_APM\n+                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Sure, I didn't plan to do it in this PR :)",
              "createdAt": "2022-07-12T08:29:27Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());\n+        }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        public void UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        public void RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        public void PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        public void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc)\n+            {\n+                IsBackground = true,\n+                Name = \"MSBuild Client Packet Pump\"\n+            };\n+            _packetPumpThread.Start();\n+        }\n+\n+        /// <summary>\n+        /// Stops the packet pump thread.\n+        /// </summary>\n+        public void Stop()\n+        {\n+            _packetPumpShutdownEvent.Set();\n+            _packetPumpThread?.Join();\n+        }\n+\n+        /// <summary>\n+        /// This method handles the packet pump reading. It will terminate when the terminate event is\n+        /// set.\n+        /// </summary>\n+        /// <remarks>\n+        /// Instead of throwing an exception, puts it in <see cref=\"PacketPumpException\"/> and raises event <see cref=\"PacketPumpErrorEvent\"/>.\n+        /// </remarks>\n+        private void PacketPumpProc()\n+        {\n+            RunReadLoop(_stream, _packetPumpShutdownEvent);\n+        }\n+\n+        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)\n+        {\n+            CommunicationsUtilities.Trace(\"Entering read loop.\");\n+\n+            try\n+            {\n+                byte[] headerByte = new byte[5];\n+#if FEATURE_APM\n+                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Tiny nit: fix alignment",
              "createdAt": "2022-05-18T18:57:20Z",
              "path": "src/Build/BackEnd/Client/MSBuildClientPacketPump.cs",
              "diffHunk": "@@ -0,0 +1,302 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+#if !FEATURE_APM\n+using System.Threading.Tasks;\n+#endif\n+\n+namespace Microsoft.Build.BackEnd.Client\n+{\n+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable\n+    {\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }\n+\n+        /// <summary>\n+        /// Set when packet pump receive packets and put them to <see cref=\"ReceivedPacketsQueue\"/>.\n+        /// </summary>\n+        public AutoResetEvent PacketReceivedEvent { get; }\n+\n+        /// <summary>\n+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).\n+        /// </summary>\n+        public ManualResetEvent PacketPumpErrorEvent { get; }\n+\n+        /// <summary>\n+        /// Exception appeared when the packet pump unexpectedly terminates.\n+        /// </summary>\n+        public Exception? PacketPumpException { get; set; }\n+\n+        /// <summary>\n+        /// Set when packet pump should shutdown.\n+        /// </summary>\n+        private readonly ManualResetEvent _packetPumpShutdownEvent;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The memory stream for a read buffer.\n+        /// </summary>\n+        private readonly MemoryStream _readBufferMemoryStream;\n+\n+        /// <summary>\n+        /// The thread which runs the asynchronous packet pump\n+        /// </summary>\n+        private Thread? _packetPumpThread;\n+\n+        /// <summary>\n+        /// The stream from where to read packets.\n+        /// </summary>\n+        private readonly Stream _stream;\n+\n+        /// <summary>\n+        /// The binary translator for reading packets.\n+        /// </summary>\n+        readonly ITranslator _binaryReadTranslator;\n+\n+        public MSBuildClientPacketPump(Stream stream)\n+        {\n+            _stream = stream;\n+            _packetFactory = new NodePacketFactory();\n+\n+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();\n+            PacketReceivedEvent = new AutoResetEvent(false);\n+            PacketPumpErrorEvent = new ManualResetEvent(false);\n+            _packetPumpShutdownEvent = new ManualResetEvent(false);\n+\n+            _readBufferMemoryStream = new MemoryStream();\n+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());\n+        }\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        public void UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        public void RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        public void PacketReceived(int node, INodePacket packet)\n+        {\n+            ReceivedPacketsQueue.Enqueue(packet);\n+            PacketReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        #region Packet Pump\n+        /// <summary>\n+        /// Initializes the packet pump thread.\n+        /// </summary>\n+        public void Start()\n+        {\n+            _packetPumpThread = new Thread(PacketPumpProc)\n+            {\n+                IsBackground = true,\n+                Name = \"MSBuild Client Packet Pump\"\n+            };\n+            _packetPumpThread.Start();\n+        }\n+\n+        /// <summary>\n+        /// Stops the packet pump thread.\n+        /// </summary>\n+        public void Stop()\n+        {\n+            _packetPumpShutdownEvent.Set();\n+            _packetPumpThread?.Join();\n+        }\n+\n+        /// <summary>\n+        /// This method handles the packet pump reading. It will terminate when the terminate event is\n+        /// set.\n+        /// </summary>\n+        /// <remarks>\n+        /// Instead of throwing an exception, puts it in <see cref=\"PacketPumpException\"/> and raises event <see cref=\"PacketPumpErrorEvent\"/>.\n+        /// </remarks>\n+        private void PacketPumpProc()\n+        {\n+            RunReadLoop(_stream, _packetPumpShutdownEvent);\n+        }\n+\n+        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)\n+        {\n+            CommunicationsUtilities.Trace(\"Entering read loop.\");\n+\n+            try\n+            {\n+                byte[] headerByte = new byte[5];\n+#if FEATURE_APM\n+                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);\n+#endif\n+\n+                bool continueReading = true;\n+                do\n+                {\n+                    // Ordering of the wait handles is important. The first signalled wait handle in the array \n+                    // will be returned by WaitAny if multiple wait handles are signalled. We prefer to have the\n+                    // terminate event triggered so that we cannot get into a situation where packets are being\n+                    // spammed to the client and it never gets an opportunity to shutdown.\n+                    WaitHandle[] handles = new WaitHandle[] {\n+                    localPacketPumpShutdownEvent,\n+#if FEATURE_APM\n+                    result.AsyncWaitHandle\n+#else\n+                    ((IAsyncResult)readTask).AsyncWaitHandle\n+#endif\n+                    };\n+                    int waitId = WaitHandle.WaitAny(handles);\n+                    switch (waitId)\n+                    {\n+                        case 0:\n+                            // Fulfill the request for shutdown of the message pump.\n+                            CommunicationsUtilities.Trace(\"Shutdown message pump thread.\");\n+                            continueReading = false;\n+                            break;\n+\n+                        case 1:\n+                            {\n+                                // Client recieved a packet header. Read the rest of it.\n+                                int headerBytesRead = 0;\n+#if FEATURE_APM\n+                                headerBytesRead = localStream.EndRead(result);\n+#else\n+                                headerBytesRead = readTask.Result;\n+#endif\n+\n+                                if ((headerBytesRead != headerByte.Length) && !localPacketPumpShutdownEvent.WaitOne(0))\n+                                {\n+                                    // Incomplete read. Abort.\n+                                    if (headerBytesRead == 0)\n+                                    {\n+                                        ErrorUtilities.ThrowInternalError(\"Server disconnected abruptly\");\n+                                    }\n+                                    else\n+                                    {\n+                                        ErrorUtilities.ThrowInternalError(\"Incomplete header read from server.  {0} of {1} bytes read\", headerBytesRead, headerByte.Length);\n+                                    }\n+                                }\n+\n+                                NodePacketType packetType = (NodePacketType)Enum.ToObject(typeof(NodePacketType), headerByte[0]);\n+\n+                                int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(headerByte, 1, 4));\n+                                int packetBytesRead = 0;\n+\n+                                _readBufferMemoryStream.Position = 0;\n+                                _readBufferMemoryStream.SetLength(packetLength);\n+                                byte[] packetData = _readBufferMemoryStream.GetBuffer();\n+\n+                                packetBytesRead = localStream.Read(packetData, 0, packetLength);\n+                                \n+                                if (packetBytesRead != packetLength)\n+                                {\n+                                    // Incomplete read.  Abort.\n+                                    ErrorUtilities.ThrowInternalError(\"Incomplete header read from server. {0} of {1} bytes read\", headerBytesRead, headerByte.Length);\n+                                }\n+\n+                                try\n+                                {\n+                                    _packetFactory.DeserializeAndRoutePacket(0, packetType, _binaryReadTranslator);\n+                                }\n+                                catch\n+                                {\n+                                    // Error while deserializing or handling packet. Logging additional info.\n+                                    CommunicationsUtilities.Trace(\"Packet factory failed to receive package. Exception while deserializing packet {0}.\", packetType);\n+                                    throw;\n+                                }\n+\n+                                if (packetType == NodePacketType.ServerNodeBuildResult)\n+                                {\n+                                    continueReading = false;\n+                                }\n+                                else\n+                                {\n+                                    // Start reading the next package header.\n+#if FEATURE_APM\n+                                    result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);\n+#else\n+                                readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: Shouldly?",
              "createdAt": "2022-05-18T18:58:10Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Execution;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests\n+    {\n+        [Fact]\n+        public async Task EmitConsoleMessages()\n+        {\n+            StringBuilder sb = new StringBuilder();\n+            var writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text));\n+\n+            writer.WriteLine(\"Line 1\");\n+            await Task.Delay(300);\n+            writer.Write(\"Line 2\");\n+            writer.Dispose();\n+\n+            Assert.Equal($\"Line 1{Environment.NewLine}Line 2\", sb.ToString());",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Before merge we need to verify that there is no version collision. \r\nNew events would be soon added in other PRs.",
              "createdAt": "2022-05-19T15:30:48Z",
              "path": "src/Framework/MSBuildEventSource.cs",
              "diffHunk": "@@ -599,6 +599,18 @@ public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(int submis\n             WriteEvent(80, submissionId, sdkName, solutionPath, projectPath, success, wasResultCached);\n         }\n \n+        [Event(81, Keywords = Keywords.All)]",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "We can use [`EventSourceAnalyzer`](https://github.com/microsoftarchive/semantic-logging/blob/master/source/Src/SemanticLogging.EventSourceAnalyzer/EventSourceAnalyzer.cs). I would prefer to copy this class as the project is archived and using Nuget package requires additional steps. I'm wondering if there is some problem with license. ",
              "createdAt": "2022-06-29T09:44:38Z",
              "path": "src/Framework/MSBuildEventSource.cs",
              "diffHunk": "@@ -599,6 +599,18 @@ public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(int submis\n             WriteEvent(80, submissionId, sdkName, solutionPath, projectPath, success, wasResultCached);\n         }\n \n+        [Event(81, Keywords = Keywords.All)]",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: can some of these tiny files be added to other files instead?",
              "createdAt": "2022-05-19T21:43:24Z",
              "path": "src/Build/BackEnd/Node/ConsoleOutput.cs",
              "diffHunk": "@@ -0,0 +1,12 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+namespace Microsoft.Build.BackEnd",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "There is one class - one file rule, which we do not follow always in this repo... But I see no problem for it to be separate here.",
              "createdAt": "2022-06-29T15:51:24Z",
              "path": "src/Build/BackEnd/Node/ConsoleOutput.cs",
              "diffHunk": "@@ -0,0 +1,12 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+namespace Microsoft.Build.BackEnd",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I also prefer one type per file.",
              "createdAt": "2022-06-30T08:48:27Z",
              "path": "src/Build/BackEnd/Node/ConsoleOutput.cs",
              "diffHunk": "@@ -0,0 +1,12 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+namespace Microsoft.Build.BackEnd",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "?",
              "createdAt": "2022-05-19T21:44:04Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,374 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please use the Trait (DebugNodeCommunication) instead",
              "createdAt": "2022-05-19T21:45:56Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,374 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@rokonec, do we need the _debugCommunications field at all? ",
              "createdAt": "2022-06-28T12:47:26Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,374 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Discussed offline - we don't.",
              "createdAt": "2022-06-30T08:12:50Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,374 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there no way to condense this into the previous Handshake? That'd be a lot cleaner in my view. Having two almost identical copies of code always feels wrong.",
              "createdAt": "2022-05-19T21:48:51Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -126,6 +128,72 @@ internal int[] RetrieveHandshakeComponents()\n                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)\n             };\n         }\n+\n+        public virtual string GetKey() => $\"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}\".ToString(CultureInfo.InvariantCulture);\n+\n+        public virtual byte? ExpectedVersionInFirstByte => CommunicationsUtilities.handshakeVersion;\n+    }\n+\n+    internal sealed class ServerNodeHandshake : Handshake",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I tried, but using inheritance with overriding looks more readable (at least for me :)).",
              "createdAt": "2022-06-28T12:49:14Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -126,6 +128,72 @@ internal int[] RetrieveHandshakeComponents()\n                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)\n             };\n         }\n+\n+        public virtual string GetKey() => $\"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}\".ToString(CultureInfo.InvariantCulture);\n+\n+        public virtual byte? ExpectedVersionInFirstByte => CommunicationsUtilities.handshakeVersion;\n+    }\n+\n+    internal sealed class ServerNodeHandshake : Handshake",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: add MSBuild to these?",
              "createdAt": "2022-05-19T21:50:48Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,374 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+        \n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param> \n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            ServerNodeHandshake handshake = new(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+\n+            _serverBusyMutexName = GetBusyServerMutexName(handshake);\n+\n+            // Handled race condition. If two processes spawn to start build Server one will die while\n+            // one Server client connects to the other one and run build on it.\n+            CommunicationsUtilities.Trace(\"Starting new server node with handshake {0}\", handshake);\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(GetRunningServerMutexName(handshake), out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(GetPipeName(handshake), handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        internal static string GetPipeName(ServerNodeHandshake handshake)\n+            => NamedPipeUtil.GetPlatformSpecificPipeName($\"MSBuildServer-{handshake.ComputeHash()}\");\n+\n+        internal static string GetRunningServerMutexName(ServerNodeHandshake handshake)\n+            => $@\"Global\\server-running-{handshake.ComputeHash()}\";",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Fixed",
              "createdAt": "2022-07-11T18:59:08Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,374 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+        \n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param> \n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            ServerNodeHandshake handshake = new(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+\n+            _serverBusyMutexName = GetBusyServerMutexName(handshake);\n+\n+            // Handled race condition. If two processes spawn to start build Server one will die while\n+            // one Server client connects to the other one and run build on it.\n+            CommunicationsUtilities.Trace(\"Starting new server node with handshake {0}\", handshake);\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(GetRunningServerMutexName(handshake), out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(GetPipeName(handshake), handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        internal static string GetPipeName(ServerNodeHandshake handshake)\n+            => NamedPipeUtil.GetPlatformSpecificPipeName($\"MSBuildServer-{handshake.ComputeHash()}\");\n+\n+        internal static string GetRunningServerMutexName(ServerNodeHandshake handshake)\n+            => $@\"Global\\server-running-{handshake.ComputeHash()}\";",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think you can just skip all of these if they don't do anything. Alternatively, condense them to one break;",
              "createdAt": "2022-05-19T21:52:50Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,374 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+        \n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param> \n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            ServerNodeHandshake handshake = new(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+\n+            _serverBusyMutexName = GetBusyServerMutexName(handshake);\n+\n+            // Handled race condition. If two processes spawn to start build Server one will die while\n+            // one Server client connects to the other one and run build on it.\n+            CommunicationsUtilities.Trace(\"Starting new server node with handshake {0}\", handshake);\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(GetRunningServerMutexName(handshake), out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(GetPipeName(handshake), handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        internal static string GetPipeName(ServerNodeHandshake handshake)\n+            => NamedPipeUtil.GetPlatformSpecificPipeName($\"MSBuildServer-{handshake.ComputeHash()}\");\n+\n+        internal static string GetRunningServerMutexName(ServerNodeHandshake handshake)\n+            => $@\"Global\\server-running-{handshake.ComputeHash()}\";\n+\n+        internal static string GetBusyServerMutexName(ServerNodeHandshake handshake)\n+            => $@\"Global\\server-busy-{handshake.ComputeHash()}\";\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I love switch statements, but this feels a bit much to me \ud83d\ude42\r\n```suggestion\r\n            if (packet.Type == NodePacketType.ServerNodeBuildCommand)\r\n            {\r\n                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\r\n            }\r\n```",
              "createdAt": "2022-05-19T21:53:54Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,374 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+        \n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param> \n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            ServerNodeHandshake handshake = new(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+\n+            _serverBusyMutexName = GetBusyServerMutexName(handshake);\n+\n+            // Handled race condition. If two processes spawn to start build Server one will die while\n+            // one Server client connects to the other one and run build on it.\n+            CommunicationsUtilities.Trace(\"Starting new server node with handshake {0}\", handshake);\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(GetRunningServerMutexName(handshake), out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(GetPipeName(handshake), handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        internal static string GetPipeName(ServerNodeHandshake handshake)\n+            => NamedPipeUtil.GetPlatformSpecificPipeName($\"MSBuildServer-{handshake.ComputeHash()}\");\n+\n+        internal static string GetRunningServerMutexName(ServerNodeHandshake handshake)\n+            => $@\"Global\\server-running-{handshake.ComputeHash()}\";\n+\n+        internal static string GetBusyServerMutexName(ServerNodeHandshake handshake)\n+            => $@\"Global\\server-busy-{handshake.ComputeHash()}\";\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuildCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+            }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It was prepared for additional packet type back then :)",
              "createdAt": "2022-06-28T12:51:41Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,374 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+        \n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param> \n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            ServerNodeHandshake handshake = new(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+\n+            _serverBusyMutexName = GetBusyServerMutexName(handshake);\n+\n+            // Handled race condition. If two processes spawn to start build Server one will die while\n+            // one Server client connects to the other one and run build on it.\n+            CommunicationsUtilities.Trace(\"Starting new server node with handshake {0}\", handshake);\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(GetRunningServerMutexName(handshake), out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(GetPipeName(handshake), handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        internal static string GetPipeName(ServerNodeHandshake handshake)\n+            => NamedPipeUtil.GetPlatformSpecificPipeName($\"MSBuildServer-{handshake.ComputeHash()}\");\n+\n+        internal static string GetRunningServerMutexName(ServerNodeHandshake handshake)\n+            => $@\"Global\\server-running-{handshake.ComputeHash()}\";\n+\n+        internal static string GetBusyServerMutexName(ServerNodeHandshake handshake)\n+            => $@\"Global\\server-busy-{handshake.ComputeHash()}\";\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuildCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+            }",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks like it means that if it already exists (i.e., server in use), that we find that out but then make the mutex invalid by disposing of it. Why are we disposing of it?",
              "createdAt": "2022-05-25T22:27:35Z",
              "path": "src/Build/BackEnd/Node/ServerNamedMutex.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal sealed class ServerNamedMutex : IDisposable\n+    {\n+        private readonly Mutex _serverMutex;\n+\n+        public bool IsDisposed { get; private set; }\n+\n+        public bool IsLocked { get; private set; }\n+\n+        public ServerNamedMutex(string mutexName, out bool createdNew)\n+        {\n+            _serverMutex = new Mutex(\n+                initiallyOwned: true,\n+                name: mutexName,\n+                createdNew: out createdNew);\n+\n+            if (createdNew)\n+            {\n+                IsLocked = true;\n+            }\n+        }\n+\n+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+        {\n+            // TODO: verify it is not needed anymore\n+            // if (PlatformInformation.IsRunningOnMono)\n+            // {\n+            //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);\n+            // }\n+            // else\n+\n+            return new ServerNamedMutex(name, out createdNew);\n+        }\n+\n+        public static bool WasOpen(string mutexName)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "When you acquire kernel object like Mutex it has to be disposed to return its resources back to OS. If we had not dispose it it would be disposed/collected by finalizer anyway.\r\n\r\nNOTE: This logic and code has been cloned from https://github.com/dotnet/roslyn/blob/579732c393b69462f489be05019ce2eaa329e648/src/Compilers/Shared/BuildServerConnection.cs#L844\r\nas it was used for VBCSCompiler which solves similar problem like MSBuild Server. I believe this code is correct and it was battle tested for years.",
              "createdAt": "2022-05-27T19:25:10Z",
              "path": "src/Build/BackEnd/Node/ServerNamedMutex.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal sealed class ServerNamedMutex : IDisposable\n+    {\n+        private readonly Mutex _serverMutex;\n+\n+        public bool IsDisposed { get; private set; }\n+\n+        public bool IsLocked { get; private set; }\n+\n+        public ServerNamedMutex(string mutexName, out bool createdNew)\n+        {\n+            _serverMutex = new Mutex(\n+                initiallyOwned: true,\n+                name: mutexName,\n+                createdNew: out createdNew);\n+\n+            if (createdNew)\n+            {\n+                IsLocked = true;\n+            }\n+        }\n+\n+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+        {\n+            // TODO: verify it is not needed anymore\n+            // if (PlatformInformation.IsRunningOnMono)\n+            // {\n+            //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);\n+            // }\n+            // else\n+\n+            return new ServerNamedMutex(name, out createdNew);\n+        }\n+\n+        public static bool WasOpen(string mutexName)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "@rokonec is correct, that is why this value is disposed",
              "createdAt": "2022-06-22T05:02:31Z",
              "path": "src/Build/BackEnd/Node/ServerNamedMutex.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal sealed class ServerNamedMutex : IDisposable\n+    {\n+        private readonly Mutex _serverMutex;\n+\n+        public bool IsDisposed { get; private set; }\n+\n+        public bool IsLocked { get; private set; }\n+\n+        public ServerNamedMutex(string mutexName, out bool createdNew)\n+        {\n+            _serverMutex = new Mutex(\n+                initiallyOwned: true,\n+                name: mutexName,\n+                createdNew: out createdNew);\n+\n+            if (createdNew)\n+            {\n+                IsLocked = true;\n+            }\n+        }\n+\n+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+        {\n+            // TODO: verify it is not needed anymore\n+            // if (PlatformInformation.IsRunningOnMono)\n+            // {\n+            //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);\n+            // }\n+            // else\n+\n+            return new ServerNamedMutex(name, out createdNew);\n+        }\n+\n+        public static bool WasOpen(string mutexName)",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this ever used?",
              "createdAt": "2022-05-25T22:27:58Z",
              "path": "src/Build/BackEnd/Node/ServerNamedMutex.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal sealed class ServerNamedMutex : IDisposable\n+    {\n+        private readonly Mutex _serverMutex;\n+\n+        public bool IsDisposed { get; private set; }\n+\n+        public bool IsLocked { get; private set; }\n+\n+        public ServerNamedMutex(string mutexName, out bool createdNew)\n+        {\n+            _serverMutex = new Mutex(\n+                initiallyOwned: true,\n+                name: mutexName,\n+                createdNew: out createdNew);\n+\n+            if (createdNew)\n+            {\n+                IsLocked = true;\n+            }\n+        }\n+\n+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+        {\n+            // TODO: verify it is not needed anymore\n+            // if (PlatformInformation.IsRunningOnMono)\n+            // {\n+            //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);\n+            // }\n+            // else\n+\n+            return new ServerNamedMutex(name, out createdNew);\n+        }\n+\n+        public static bool WasOpen(string mutexName)\n+        {\n+            bool result = Mutex.TryOpenExisting(mutexName, out Mutex? mutex);\n+            mutex?.Dispose();\n+\n+            return result;\n+        }\n+\n+        public bool TryLock(int timeoutMs)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Nope. But since I cloned that code from roslyn, I think we can keep it here - just for case.",
              "createdAt": "2022-05-27T19:26:23Z",
              "path": "src/Build/BackEnd/Node/ServerNamedMutex.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal sealed class ServerNamedMutex : IDisposable\n+    {\n+        private readonly Mutex _serverMutex;\n+\n+        public bool IsDisposed { get; private set; }\n+\n+        public bool IsLocked { get; private set; }\n+\n+        public ServerNamedMutex(string mutexName, out bool createdNew)\n+        {\n+            _serverMutex = new Mutex(\n+                initiallyOwned: true,\n+                name: mutexName,\n+                createdNew: out createdNew);\n+\n+            if (createdNew)\n+            {\n+                IsLocked = true;\n+            }\n+        }\n+\n+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+        {\n+            // TODO: verify it is not needed anymore\n+            // if (PlatformInformation.IsRunningOnMono)\n+            // {\n+            //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);\n+            // }\n+            // else\n+\n+            return new ServerNamedMutex(name, out createdNew);\n+        }\n+\n+        public static bool WasOpen(string mutexName)\n+        {\n+            bool result = Mutex.TryOpenExisting(mutexName, out Mutex? mutex);\n+            mutex?.Dispose();\n+\n+            return result;\n+        }\n+\n+        public bool TryLock(int timeoutMs)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "This is only used on Mono code paths. If you all remove Mono support, it's TODO'd above, then you can safely remove this. ",
              "createdAt": "2022-06-22T05:03:38Z",
              "path": "src/Build/BackEnd/Node/ServerNamedMutex.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal sealed class ServerNamedMutex : IDisposable\n+    {\n+        private readonly Mutex _serverMutex;\n+\n+        public bool IsDisposed { get; private set; }\n+\n+        public bool IsLocked { get; private set; }\n+\n+        public ServerNamedMutex(string mutexName, out bool createdNew)\n+        {\n+            _serverMutex = new Mutex(\n+                initiallyOwned: true,\n+                name: mutexName,\n+                createdNew: out createdNew);\n+\n+            if (createdNew)\n+            {\n+                IsLocked = true;\n+            }\n+        }\n+\n+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+        {\n+            // TODO: verify it is not needed anymore\n+            // if (PlatformInformation.IsRunningOnMono)\n+            // {\n+            //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);\n+            // }\n+            // else\n+\n+            return new ServerNamedMutex(name, out createdNew);\n+        }\n+\n+        public static bool WasOpen(string mutexName)\n+        {\n+            bool result = Mutex.TryOpenExisting(mutexName, out Mutex? mutex);\n+            mutex?.Dispose();\n+\n+            return result;\n+        }\n+\n+        public bool TryLock(int timeoutMs)",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "deleted",
              "createdAt": "2022-07-11T15:04:59Z",
              "path": "src/Build/BackEnd/Node/ServerNamedMutex.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal sealed class ServerNamedMutex : IDisposable\n+    {\n+        private readonly Mutex _serverMutex;\n+\n+        public bool IsDisposed { get; private set; }\n+\n+        public bool IsLocked { get; private set; }\n+\n+        public ServerNamedMutex(string mutexName, out bool createdNew)\n+        {\n+            _serverMutex = new Mutex(\n+                initiallyOwned: true,\n+                name: mutexName,\n+                createdNew: out createdNew);\n+\n+            if (createdNew)\n+            {\n+                IsLocked = true;\n+            }\n+        }\n+\n+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+        {\n+            // TODO: verify it is not needed anymore\n+            // if (PlatformInformation.IsRunningOnMono)\n+            // {\n+            //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);\n+            // }\n+            // else\n+\n+            return new ServerNamedMutex(name, out createdNew);\n+        }\n+\n+        public static bool WasOpen(string mutexName)\n+        {\n+            bool result = Mutex.TryOpenExisting(mutexName, out Mutex? mutex);\n+            mutex?.Dispose();\n+\n+            return result;\n+        }\n+\n+        public bool TryLock(int timeoutMs)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Looking at uses of IsLocked, how can it be false at this point? It's initially true, it wouldn't get this far if IsDisposed was true before the call to Dispose here, which means we can only get here the first time Dispose is called, so the IsLocked = false on line 84 can't have been called. And if IsLocked != IsDisposed (always), then even if TryLock were called, one of the two conditions would always throw. I'm confused about this whole thing.",
              "createdAt": "2022-05-25T22:32:08Z",
              "path": "src/Build/BackEnd/Node/ServerNamedMutex.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal sealed class ServerNamedMutex : IDisposable\n+    {\n+        private readonly Mutex _serverMutex;\n+\n+        public bool IsDisposed { get; private set; }\n+\n+        public bool IsLocked { get; private set; }\n+\n+        public ServerNamedMutex(string mutexName, out bool createdNew)\n+        {\n+            _serverMutex = new Mutex(\n+                initiallyOwned: true,\n+                name: mutexName,\n+                createdNew: out createdNew);\n+\n+            if (createdNew)\n+            {\n+                IsLocked = true;\n+            }\n+        }\n+\n+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+        {\n+            // TODO: verify it is not needed anymore\n+            // if (PlatformInformation.IsRunningOnMono)\n+            // {\n+            //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);\n+            // }\n+            // else\n+\n+            return new ServerNamedMutex(name, out createdNew);\n+        }\n+\n+        public static bool WasOpen(string mutexName)\n+        {\n+            bool result = Mutex.TryOpenExisting(mutexName, out Mutex? mutex);\n+            mutex?.Dispose();\n+\n+            return result;\n+        }\n+\n+        public bool TryLock(int timeoutMs)\n+        {\n+            if (IsDisposed)\n+            {\n+                throw new ObjectDisposedException(nameof(ServerNamedMutex));\n+            }\n+\n+            if (IsLocked)\n+            {\n+                throw new InvalidOperationException(\"Lock already held\");\n+            }\n+\n+            return IsLocked = _serverMutex.WaitOne(timeoutMs);\n+        }\n+\n+        public void Dispose()\n+        {\n+            if (IsDisposed)\n+            {\n+                return;\n+            }\n+\n+            IsDisposed = true;\n+\n+            try\n+            {\n+                if (IsLocked)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Constructor can create this mutex in not locked state.",
              "createdAt": "2022-05-27T19:28:00Z",
              "path": "src/Build/BackEnd/Node/ServerNamedMutex.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal sealed class ServerNamedMutex : IDisposable\n+    {\n+        private readonly Mutex _serverMutex;\n+\n+        public bool IsDisposed { get; private set; }\n+\n+        public bool IsLocked { get; private set; }\n+\n+        public ServerNamedMutex(string mutexName, out bool createdNew)\n+        {\n+            _serverMutex = new Mutex(\n+                initiallyOwned: true,\n+                name: mutexName,\n+                createdNew: out createdNew);\n+\n+            if (createdNew)\n+            {\n+                IsLocked = true;\n+            }\n+        }\n+\n+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+        {\n+            // TODO: verify it is not needed anymore\n+            // if (PlatformInformation.IsRunningOnMono)\n+            // {\n+            //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);\n+            // }\n+            // else\n+\n+            return new ServerNamedMutex(name, out createdNew);\n+        }\n+\n+        public static bool WasOpen(string mutexName)\n+        {\n+            bool result = Mutex.TryOpenExisting(mutexName, out Mutex? mutex);\n+            mutex?.Dispose();\n+\n+            return result;\n+        }\n+\n+        public bool TryLock(int timeoutMs)\n+        {\n+            if (IsDisposed)\n+            {\n+                throw new ObjectDisposedException(nameof(ServerNamedMutex));\n+            }\n+\n+            if (IsLocked)\n+            {\n+                throw new InvalidOperationException(\"Lock already held\");\n+            }\n+\n+            return IsLocked = _serverMutex.WaitOne(timeoutMs);\n+        }\n+\n+        public void Dispose()\n+        {\n+            if (IsDisposed)\n+            {\n+                return;\n+            }\n+\n+            IsDisposed = true;\n+\n+            try\n+            {\n+                if (IsLocked)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I haven't looked too closely, but I'm wondering if we could reuse some of the extant INodePackets for things like this. Maybe BuildRequest here and just tweak it a little?",
              "createdAt": "2022-05-25T22:36:01Z",
              "path": "src/Build/BackEnd/Node/ServerNodeBuildCommand.cs",
              "diffHunk": "@@ -0,0 +1,92 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// Contains all of the information necessary for a entry node to run a command line.\n+    /// </summary>\n+    internal sealed class ServerNodeBuildCommand : INodePacket",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I actually looked at BuildRequest and it was not reusable for our goals. We might in future want to extend our build command. We even did it during our work on this PR. In this case it is better to have a separate class for it. ",
              "createdAt": "2022-06-29T16:01:54Z",
              "path": "src/Build/BackEnd/Node/ServerNodeBuildCommand.cs",
              "diffHunk": "@@ -0,0 +1,92 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// Contains all of the information necessary for a entry node to run a command line.\n+    /// </summary>\n+    internal sealed class ServerNodeBuildCommand : INodePacket",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not a fan of this sort of thing. I believe this gives _commandLine an initial value of null then promises the compiler that it isn't null.",
              "createdAt": "2022-05-25T22:37:30Z",
              "path": "src/Build/BackEnd/Node/ServerNodeBuildCommand.cs",
              "diffHunk": "@@ -0,0 +1,92 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// Contains all of the information necessary for a entry node to run a command line.\n+    /// </summary>\n+    internal sealed class ServerNodeBuildCommand : INodePacket\n+    {\n+        private string _commandLine = default!;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "@Forgind  I agree, but ... is there another lightweight way how to solve it when we need private empty constructor for deserialization?\r\n\r\nIt is analyzed here: https://stackoverflow.com/questions/54902830/handling-temporarily-null-reference-types-when-deserializing-objects-in-c-sharp",
              "createdAt": "2022-07-11T15:12:33Z",
              "path": "src/Build/BackEnd/Node/ServerNodeBuildCommand.cs",
              "diffHunk": "@@ -0,0 +1,92 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// Contains all of the information necessary for a entry node to run a command line.\n+    /// </summary>\n+    internal sealed class ServerNodeBuildCommand : INodePacket\n+    {\n+        private string _commandLine = default!;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I'd prefer just disabling nullable here if that's viable, but it isn't critical.",
              "createdAt": "2022-07-13T16:23:56Z",
              "path": "src/Build/BackEnd/Node/ServerNodeBuildCommand.cs",
              "diffHunk": "@@ -0,0 +1,92 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// Contains all of the information necessary for a entry node to run a command line.\n+    /// </summary>\n+    internal sealed class ServerNodeBuildCommand : INodePacket\n+    {\n+        private string _commandLine = default!;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It would make more sense here to have three conditions: for RUNTIME_TYPE_NETCORE, MONO, and NETFRAMEWORK...though you can probably dispense with MONO.",
              "createdAt": "2022-05-25T22:39:15Z",
              "path": "src/MSBuild/MSBuildClientApp.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+using System.IO;\n+using System.Diagnostics;\n+#endif\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It\n+    /// 1. starts the MSBuild server in a separate process if it does not yet exist.\n+    /// 2. establishes a connection with MSBuild server and sends a build request.\n+    /// 3. if server is busy, it falls back to old build behavior.\n+    /// </summary>\n+    internal static class MSBuildClientApp\n+    {\n+        /// <summary>\n+        /// This is the entry point for the MSBuild client.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildApp.ExitType\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        /// <remarks>\n+        /// The locations of msbuild exe/dll and dotnet.exe would be automatically detected if called from dotnet or msbuild cli. Calling this function from other executables might not work.\n+        /// </remarks>\n+        public static MSBuildApp.ExitType Execute(\n+#if FEATURE_GET_COMMANDLINE\n+            string commandLine,\n+#else\n+            string[] commandLine,\n+#endif\n+            CancellationToken cancellationToken\n+            )\n+        {\n+            string? exeLocation;\n+            string? dllLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This part had new changes - I reused the initial code from where these lines came (that is msbuild node creation), instead of copying it here. I believe it is now more readable there.",
              "createdAt": "2022-07-11T16:30:24Z",
              "path": "src/MSBuild/MSBuildClientApp.cs",
              "diffHunk": "@@ -0,0 +1,153 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+using System.IO;\n+using System.Diagnostics;\n+#endif\n+\n+namespace Microsoft.Build.CommandLine\n+{\n+    /// <summary>\n+    /// This class implements client for MSBuild server. It\n+    /// 1. starts the MSBuild server in a separate process if it does not yet exist.\n+    /// 2. establishes a connection with MSBuild server and sends a build request.\n+    /// 3. if server is busy, it falls back to old build behavior.\n+    /// </summary>\n+    internal static class MSBuildClientApp\n+    {\n+        /// <summary>\n+        /// This is the entry point for the MSBuild client.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildApp.ExitType\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        /// <remarks>\n+        /// The locations of msbuild exe/dll and dotnet.exe would be automatically detected if called from dotnet or msbuild cli. Calling this function from other executables might not work.\n+        /// </remarks>\n+        public static MSBuildApp.ExitType Execute(\n+#if FEATURE_GET_COMMANDLINE\n+            string commandLine,\n+#else\n+            string[] commandLine,\n+#endif\n+            CancellationToken cancellationToken\n+            )\n+        {\n+            string? exeLocation;\n+            string? dllLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n```",
              "createdAt": "2022-05-25T22:47:35Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2629,6 +2655,49 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches, bool\n                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();\n                     shutdownReason = node.Run(out nodeException);\n                 }\n+                else if (nodeModeNumber == 8)\n+                {\n+                    // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly\n+                    // we have to pass down xmake build invocation to avoid circular dependency\n+                    Func<string, (int exitCode, string exitType)> buildFunction = (commandLine) =>\n+                    {\n+                        int exitCode;\n+                        ExitType exitType;\n+\n+                        if (!s_initialized)\n+                        {\n+                            exitType = ExitType.InitializationError;\n+                        }\n+                        else\n+                        {\n+                            exitType = Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                                    commandLine\n+#else\n+                                    QuotingUtilities.SplitUnquoted(commandLine).ToArray()\n+#endif\n+                                );\n+                            exitCode = exitType == ExitType.Success ? 0 : 1;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This wouldn't show up in any of our loggers, right?",
              "createdAt": "2022-05-25T22:48:48Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2629,6 +2655,49 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches, bool\n                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();\n                     shutdownReason = node.Run(out nodeException);\n                 }\n+                else if (nodeModeNumber == 8)\n+                {\n+                    // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly\n+                    // we have to pass down xmake build invocation to avoid circular dependency\n+                    Func<string, (int exitCode, string exitType)> buildFunction = (commandLine) =>\n+                    {\n+                        int exitCode;\n+                        ExitType exitType;\n+\n+                        if (!s_initialized)\n+                        {\n+                            exitType = ExitType.InitializationError;\n+                        }\n+                        else\n+                        {\n+                            exitType = Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                                    commandLine\n+#else\n+                                    QuotingUtilities.SplitUnquoted(commandLine).ToArray()\n+#endif\n+                                );\n+                            exitCode = exitType == ExitType.Success ? 0 : 1;\n+                        }\n+                        exitCode = exitType == ExitType.Success ? 0 : 1;\n+\n+                        return (exitCode, exitType.ToString());\n+                    };\n+\n+                    Action onCancel = () =>\n+                    {\n+                        Console.WriteLine(ResourceUtilities.GetResourceString(\"AbortingBuild\"));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This functionality was reworked",
              "createdAt": "2022-06-29T08:13:22Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2629,6 +2655,49 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches, bool\n                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();\n                     shutdownReason = node.Run(out nodeException);\n                 }\n+                else if (nodeModeNumber == 8)\n+                {\n+                    // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly\n+                    // we have to pass down xmake build invocation to avoid circular dependency\n+                    Func<string, (int exitCode, string exitType)> buildFunction = (commandLine) =>\n+                    {\n+                        int exitCode;\n+                        ExitType exitType;\n+\n+                        if (!s_initialized)\n+                        {\n+                            exitType = ExitType.InitializationError;\n+                        }\n+                        else\n+                        {\n+                            exitType = Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                                    commandLine\n+#else\n+                                    QuotingUtilities.SplitUnquoted(commandLine).ToArray()\n+#endif\n+                                );\n+                            exitCode = exitType == ExitType.Success ? 0 : 1;\n+                        }\n+                        exitCode = exitType == ExitType.Success ? 0 : 1;\n+\n+                        return (exitCode, exitType.ToString());\n+                    };\n+\n+                    Action onCancel = () =>\n+                    {\n+                        Console.WriteLine(ResourceUtilities.GetResourceString(\"AbortingBuild\"));",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We control whether anyPrefixingParameter is ever not null or empty but doesn't end in ';', and I'd say we should just make sure it always ends in ';' and not have this. It lets us miss any extra allocation.",
              "createdAt": "2022-05-25T22:54:46Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3019,6 +3088,12 @@ internal static string AggregateParameters(string anyPrefixingParameter, string[\n             // Join the logger parameters into one string separated by semicolons\n             string result = anyPrefixingParameter ?? string.Empty;\n \n+            // Ensure traling ';' so parametersToAggregate are properly separated\n+            if (!string.IsNullOrEmpty(result) && result[result.Length - 1] != ';')",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This is called sparsely - we do not need to optimize allocations in this method. ",
              "createdAt": "2022-07-11T18:36:52Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3019,6 +3088,12 @@ internal static string AggregateParameters(string anyPrefixingParameter, string[\n             // Join the logger parameters into one string separated by semicolons\n             string result = anyPrefixingParameter ?? string.Empty;\n \n+            // Ensure traling ';' so parametersToAggregate are properly separated\n+            if (!string.IsNullOrEmpty(result) && result[result.Length - 1] != ';')",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If you put this before the previous clause (which should also have its extra parentheses removed), you can just do \"consoleParameters += \"FORCECONSOLECOLOR;\"; and save an allocation.",
              "createdAt": "2022-05-25T22:56:10Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3124,6 +3199,12 @@ List<ILogger> loggers\n                     consoleParameters = AggregateParameters(consoleParameters, consoleLoggerParameters);\n                 }\n \n+                // Always use ANSI escape codes when the build is initiated by server\n+                if (s_isServerNode)\n+                {\n+                    consoleParameters = AggregateParameters(consoleParameters, new[] { \"FORCECONSOLECOLOR\" });",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd prefer not to do this. I'd prefer to not have extra overloads, especially when one is just called by the other.",
              "createdAt": "2022-05-25T23:10:02Z",
              "path": "src/Shared/NamedPipeUtil.cs",
              "diffHunk": "@@ -17,6 +17,11 @@ internal static string GetPipeNameOrPath(int? processId = null)\n \n             string pipeName = $\"MSBuild{processId}\";\n \n+            return GetPlatformSpecificPipeName(pipeName);\n+        }\n+",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I would prefer to have one method too, but `GetPlatformSpecificPipeName(string)` is used also outside this type.",
              "createdAt": "2022-06-29T08:39:09Z",
              "path": "src/Shared/NamedPipeUtil.cs",
              "diffHunk": "@@ -17,6 +17,11 @@ internal static string GetPipeNameOrPath(int? processId = null)\n \n             string pipeName = $\"MSBuild{processId}\";\n \n+            return GetPlatformSpecificPipeName(pipeName);\n+        }\n+",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't see a reference to Linq added?",
              "createdAt": "2022-05-25T23:10:41Z",
              "path": "src/Shared/NodeEndpointOutOfProcBase.cs",
              "diffHunk": "@@ -14,6 +14,7 @@\n using Microsoft.Build.Shared;\n #if FEATURE_SECURITY_PERMISSIONS || FEATURE_PIPE_SECURITY\n using System.Security.AccessControl;\n+using System.Linq;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks almost identical to TryConnectToProcess in NodeProviderOutOfProcBase.cs. We should use that. Of note, you missed a security feature when you copied it.",
              "createdAt": "2022-05-25T23:15:05Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,468 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Client;\n+using Microsoft.Build.Eventing;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client process.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        private readonly Dictionary<string, string> _serverEnvironmentVariables;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private readonly string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private readonly string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private readonly MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private readonly ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private readonly string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private readonly NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private readonly MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private readonly BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Used to estimate the size of the build with an ETW trace.\n+        /// </summary>\n+        private int _numConsoleWritePackets;\n+        private long _sizeOfConsoleWritePackets;\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            _serverEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken cancellationToken)\n+        {\n+            CommunicationsUtilities.Trace(\"Executing build with command line '{0}'\", commandLine);\n+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);\n+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);\n+\n+            // Start server it if is not running.\n+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverIsAlreadyRunning)\n+            {\n+                CommunicationsUtilities.Trace(\"Server was not running. Starting server now.\");\n+                if (!TryLaunchServer())\n+                {\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverIsAlreadyRunning ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicker deal with possible issues with connection to server.\n+            MSBuildEventSource.Log.MSBuildServerBuildStart(commandLine);\n+            if (!TrySendBuildCommand(commandLine))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            _numConsoleWritePackets = 0;\n+            _sizeOfConsoleWritePackets = 0;\n+\n+            try\n+            {\n+                // Start packet pump\n+                using MSBuildClientPacketPump packetPump = new(_nodeStream);\n+\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+                packetPump.Start();\n+\n+                WaitHandle[] waitHandles =\n+                {\n+                    cancellationToken.WaitHandle,\n+                    packetPump.PacketPumpErrorEvent,\n+                    packetPump.PacketReceivedEvent\n+                };\n+\n+                while (!_buildFinished)\n+                {\n+                    int index = WaitHandle.WaitAny(waitHandles);\n+                    switch (index)\n+                    {\n+                        case 0:\n+                            HandleCancellation();\n+                            break;\n+\n+                        case 1:\n+                            HandlePacketPumpError(packetPump);\n+                            break;\n+\n+                        case 2:\n+                            while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet) &&\n+                                   !_buildFinished &&\n+                                   !cancellationToken.IsCancellationRequested)\n+                            {\n+                                if (packet != null)\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                            }\n+\n+                            break;\n+                    }\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"MSBuild client error: problem during packet handling occurred: {0}.\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            }\n+\n+            MSBuildEventSource.Log.MSBuildServerBuildStop(commandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_handshake.ComputeHash()}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  _serverEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched with PID: {0}\", msbuildProcess.Id);\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch the msbuild server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        {\n+            CommunicationsUtilities.Trace(\"Launching server node from {0} with arguments {1}\", exeLocation, msBuildServerArguments);\n+            ProcessStartInfo processStartInfo = new() \n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env to enable MSBuild Server that might be equal to 1, so we do not get an infinite recursion here.\n+            processStartInfo.Environment[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to launch.\");\n+        }\n+\n+        private bool TrySendBuildCommand(string commandLine)\n+        {\n+            try\n+            {\n+                ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+                WritePacket(_nodeStream, buildCommand);\n+                CommunicationsUtilities.Trace(\"Build command sent...\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to send build command to server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+            Dictionary<string, string> envVars = new();\n+\n+            foreach (DictionaryEntry envVar in Environment.GetEnvironmentVariables())\n+            {\n+                envVars[(string)envVar.Key] = (envVar.Value as string) ?? string.Empty;\n+            }\n+\n+            foreach (var pair in _serverEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            return new ServerNodeHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+        }\n+\n+        /// <summary>\n+        /// Handle cancellation.\n+        /// </summary>\n+        private void HandleCancellation()\n+        {\n+            // TODO.\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            Console.WriteLine(\"MSBuild client cancelled.\");\n+            CommunicationsUtilities.Trace(\"MSBuild client cancelled.\");\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Cancelled;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Handle packet pump error.\n+        /// </summary>\n+        private void HandlePacketPumpError(MSBuildClientPacketPump packetPump)\n+        {\n+            CommunicationsUtilities.Trace(\"MSBuild client error: packet pump unexpectedly shut down: {0}\", packetPump.PacketPumpException);\n+            throw packetPump.PacketPumpException ?? new Exception(\"Packet pump unexpectedly shut down\");\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeConsoleWrite:\n+                    ServerNodeConsoleWrite writePacket = (packet as ServerNodeConsoleWrite)!;\n+                    HandleServerNodeConsoleWrite(writePacket);\n+                    _numConsoleWritePackets++;\n+                    _sizeOfConsoleWritePackets += writePacket.Text.Length;\n+                    break;\n+                case NodePacketType.ServerNodeBuildResult:\n+                    HandleServerNodeBuildResult((ServerNodeBuildResult)packet);\n+                    break;\n+                default: throw new InvalidOperationException($\"Unexpected packet type {packet.GetType().Name}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeConsoleWrite(ServerNodeConsoleWrite consoleWrite)\n+        {\n+            switch (consoleWrite.OutputType)\n+            {\n+                case ConsoleOutput.Standard:\n+                    Console.Write(consoleWrite.Text);\n+                    break;\n+                case ConsoleOutput.Error:\n+                    Console.Error.Write(consoleWrite.Text);\n+                    break;\n+                default:\n+                    throw new InvalidOperationException($\"Unexpected console output type {consoleWrite.OutputType}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildResult(ServerNodeBuildResult response)\n+        {\n+            CommunicationsUtilities.Trace(\"Build response received: exit code {0}, exit type '{1}'\", response.ExitCode, response.ExitType);\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Success;\n+            _exitResult.MSBuildAppExitTypeString = response.ExitType;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Connects to MSBuild server.\n+        /// </summary>\n+        /// <returns> Whether the client connected to MSBuild server successfully.</returns>\n+        private bool TryConnectToServer(int timeout)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Good catch. We have reused it.",
              "createdAt": "2022-07-11T19:24:15Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,468 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Client;\n+using Microsoft.Build.Eventing;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client process.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        private readonly Dictionary<string, string> _serverEnvironmentVariables;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private readonly string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private readonly string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private readonly MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private readonly ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private readonly string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private readonly NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private readonly MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private readonly BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Used to estimate the size of the build with an ETW trace.\n+        /// </summary>\n+        private int _numConsoleWritePackets;\n+        private long _sizeOfConsoleWritePackets;\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            _serverEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken cancellationToken)\n+        {\n+            CommunicationsUtilities.Trace(\"Executing build with command line '{0}'\", commandLine);\n+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);\n+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);\n+\n+            // Start server it if is not running.\n+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverIsAlreadyRunning)\n+            {\n+                CommunicationsUtilities.Trace(\"Server was not running. Starting server now.\");\n+                if (!TryLaunchServer())\n+                {\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverIsAlreadyRunning ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicker deal with possible issues with connection to server.\n+            MSBuildEventSource.Log.MSBuildServerBuildStart(commandLine);\n+            if (!TrySendBuildCommand(commandLine))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            _numConsoleWritePackets = 0;\n+            _sizeOfConsoleWritePackets = 0;\n+\n+            try\n+            {\n+                // Start packet pump\n+                using MSBuildClientPacketPump packetPump = new(_nodeStream);\n+\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+                packetPump.Start();\n+\n+                WaitHandle[] waitHandles =\n+                {\n+                    cancellationToken.WaitHandle,\n+                    packetPump.PacketPumpErrorEvent,\n+                    packetPump.PacketReceivedEvent\n+                };\n+\n+                while (!_buildFinished)\n+                {\n+                    int index = WaitHandle.WaitAny(waitHandles);\n+                    switch (index)\n+                    {\n+                        case 0:\n+                            HandleCancellation();\n+                            break;\n+\n+                        case 1:\n+                            HandlePacketPumpError(packetPump);\n+                            break;\n+\n+                        case 2:\n+                            while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet) &&\n+                                   !_buildFinished &&\n+                                   !cancellationToken.IsCancellationRequested)\n+                            {\n+                                if (packet != null)\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                            }\n+\n+                            break;\n+                    }\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"MSBuild client error: problem during packet handling occurred: {0}.\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            }\n+\n+            MSBuildEventSource.Log.MSBuildServerBuildStop(commandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_handshake.ComputeHash()}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  _serverEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched with PID: {0}\", msbuildProcess.Id);\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch the msbuild server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        {\n+            CommunicationsUtilities.Trace(\"Launching server node from {0} with arguments {1}\", exeLocation, msBuildServerArguments);\n+            ProcessStartInfo processStartInfo = new() \n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env to enable MSBuild Server that might be equal to 1, so we do not get an infinite recursion here.\n+            processStartInfo.Environment[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to launch.\");\n+        }\n+\n+        private bool TrySendBuildCommand(string commandLine)\n+        {\n+            try\n+            {\n+                ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+                WritePacket(_nodeStream, buildCommand);\n+                CommunicationsUtilities.Trace(\"Build command sent...\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to send build command to server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+            Dictionary<string, string> envVars = new();\n+\n+            foreach (DictionaryEntry envVar in Environment.GetEnvironmentVariables())\n+            {\n+                envVars[(string)envVar.Key] = (envVar.Value as string) ?? string.Empty;\n+            }\n+\n+            foreach (var pair in _serverEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            return new ServerNodeHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+        }\n+\n+        /// <summary>\n+        /// Handle cancellation.\n+        /// </summary>\n+        private void HandleCancellation()\n+        {\n+            // TODO.\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            Console.WriteLine(\"MSBuild client cancelled.\");\n+            CommunicationsUtilities.Trace(\"MSBuild client cancelled.\");\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Cancelled;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Handle packet pump error.\n+        /// </summary>\n+        private void HandlePacketPumpError(MSBuildClientPacketPump packetPump)\n+        {\n+            CommunicationsUtilities.Trace(\"MSBuild client error: packet pump unexpectedly shut down: {0}\", packetPump.PacketPumpException);\n+            throw packetPump.PacketPumpException ?? new Exception(\"Packet pump unexpectedly shut down\");\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeConsoleWrite:\n+                    ServerNodeConsoleWrite writePacket = (packet as ServerNodeConsoleWrite)!;\n+                    HandleServerNodeConsoleWrite(writePacket);\n+                    _numConsoleWritePackets++;\n+                    _sizeOfConsoleWritePackets += writePacket.Text.Length;\n+                    break;\n+                case NodePacketType.ServerNodeBuildResult:\n+                    HandleServerNodeBuildResult((ServerNodeBuildResult)packet);\n+                    break;\n+                default: throw new InvalidOperationException($\"Unexpected packet type {packet.GetType().Name}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeConsoleWrite(ServerNodeConsoleWrite consoleWrite)\n+        {\n+            switch (consoleWrite.OutputType)\n+            {\n+                case ConsoleOutput.Standard:\n+                    Console.Write(consoleWrite.Text);\n+                    break;\n+                case ConsoleOutput.Error:\n+                    Console.Error.Write(consoleWrite.Text);\n+                    break;\n+                default:\n+                    throw new InvalidOperationException($\"Unexpected console output type {consoleWrite.OutputType}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildResult(ServerNodeBuildResult response)\n+        {\n+            CommunicationsUtilities.Trace(\"Build response received: exit code {0}, exit type '{1}'\", response.ExitCode, response.ExitType);\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Success;\n+            _exitResult.MSBuildAppExitTypeString = response.ExitType;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Connects to MSBuild server.\n+        /// </summary>\n+        /// <returns> Whether the client connected to MSBuild server successfully.</returns>\n+        private bool TryConnectToServer(int timeout)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't understand the distinction here? Why are we just asserting that we succeeded?",
              "createdAt": "2022-05-25T23:16:41Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,468 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Client;\n+using Microsoft.Build.Eventing;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client process.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        private readonly Dictionary<string, string> _serverEnvironmentVariables;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private readonly string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private readonly string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private readonly MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private readonly ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private readonly string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private readonly NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private readonly MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private readonly BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Used to estimate the size of the build with an ETW trace.\n+        /// </summary>\n+        private int _numConsoleWritePackets;\n+        private long _sizeOfConsoleWritePackets;\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            _serverEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken cancellationToken)\n+        {\n+            CommunicationsUtilities.Trace(\"Executing build with command line '{0}'\", commandLine);\n+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);\n+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);\n+\n+            // Start server it if is not running.\n+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverIsAlreadyRunning)\n+            {\n+                CommunicationsUtilities.Trace(\"Server was not running. Starting server now.\");\n+                if (!TryLaunchServer())\n+                {\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverIsAlreadyRunning ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicker deal with possible issues with connection to server.\n+            MSBuildEventSource.Log.MSBuildServerBuildStart(commandLine);\n+            if (!TrySendBuildCommand(commandLine))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            _numConsoleWritePackets = 0;\n+            _sizeOfConsoleWritePackets = 0;\n+\n+            try\n+            {\n+                // Start packet pump\n+                using MSBuildClientPacketPump packetPump = new(_nodeStream);\n+\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+                packetPump.Start();\n+\n+                WaitHandle[] waitHandles =\n+                {\n+                    cancellationToken.WaitHandle,\n+                    packetPump.PacketPumpErrorEvent,\n+                    packetPump.PacketReceivedEvent\n+                };\n+\n+                while (!_buildFinished)\n+                {\n+                    int index = WaitHandle.WaitAny(waitHandles);\n+                    switch (index)\n+                    {\n+                        case 0:\n+                            HandleCancellation();\n+                            break;\n+\n+                        case 1:\n+                            HandlePacketPumpError(packetPump);\n+                            break;\n+\n+                        case 2:\n+                            while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet) &&\n+                                   !_buildFinished &&\n+                                   !cancellationToken.IsCancellationRequested)\n+                            {\n+                                if (packet != null)\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                            }\n+\n+                            break;\n+                    }\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"MSBuild client error: problem during packet handling occurred: {0}.\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            }\n+\n+            MSBuildEventSource.Log.MSBuildServerBuildStop(commandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_handshake.ComputeHash()}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  _serverEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched with PID: {0}\", msbuildProcess.Id);\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch the msbuild server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        {\n+            CommunicationsUtilities.Trace(\"Launching server node from {0} with arguments {1}\", exeLocation, msBuildServerArguments);\n+            ProcessStartInfo processStartInfo = new() \n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env to enable MSBuild Server that might be equal to 1, so we do not get an infinite recursion here.\n+            processStartInfo.Environment[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to launch.\");\n+        }\n+\n+        private bool TrySendBuildCommand(string commandLine)\n+        {\n+            try\n+            {\n+                ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+                WritePacket(_nodeStream, buildCommand);\n+                CommunicationsUtilities.Trace(\"Build command sent...\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to send build command to server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+            Dictionary<string, string> envVars = new();\n+\n+            foreach (DictionaryEntry envVar in Environment.GetEnvironmentVariables())\n+            {\n+                envVars[(string)envVar.Key] = (envVar.Value as string) ?? string.Empty;\n+            }\n+\n+            foreach (var pair in _serverEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            return new ServerNodeHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+        }\n+\n+        /// <summary>\n+        /// Handle cancellation.\n+        /// </summary>\n+        private void HandleCancellation()\n+        {\n+            // TODO.\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            Console.WriteLine(\"MSBuild client cancelled.\");\n+            CommunicationsUtilities.Trace(\"MSBuild client cancelled.\");\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Cancelled;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Handle packet pump error.\n+        /// </summary>\n+        private void HandlePacketPumpError(MSBuildClientPacketPump packetPump)\n+        {\n+            CommunicationsUtilities.Trace(\"MSBuild client error: packet pump unexpectedly shut down: {0}\", packetPump.PacketPumpException);\n+            throw packetPump.PacketPumpException ?? new Exception(\"Packet pump unexpectedly shut down\");\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeConsoleWrite:\n+                    ServerNodeConsoleWrite writePacket = (packet as ServerNodeConsoleWrite)!;\n+                    HandleServerNodeConsoleWrite(writePacket);\n+                    _numConsoleWritePackets++;\n+                    _sizeOfConsoleWritePackets += writePacket.Text.Length;\n+                    break;\n+                case NodePacketType.ServerNodeBuildResult:\n+                    HandleServerNodeBuildResult((ServerNodeBuildResult)packet);\n+                    break;\n+                default: throw new InvalidOperationException($\"Unexpected packet type {packet.GetType().Name}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeConsoleWrite(ServerNodeConsoleWrite consoleWrite)\n+        {\n+            switch (consoleWrite.OutputType)\n+            {\n+                case ConsoleOutput.Standard:\n+                    Console.Write(consoleWrite.Text);\n+                    break;\n+                case ConsoleOutput.Error:\n+                    Console.Error.Write(consoleWrite.Text);\n+                    break;\n+                default:\n+                    throw new InvalidOperationException($\"Unexpected console output type {consoleWrite.OutputType}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildResult(ServerNodeBuildResult response)\n+        {\n+            CommunicationsUtilities.Trace(\"Build response received: exit code {0}, exit type '{1}'\", response.ExitCode, response.ExitType);\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Success;\n+            _exitResult.MSBuildAppExitTypeString = response.ExitType;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`_exitResult.MSBuildClientExitType` is about how client communicated with server. If server fails to build but succeed to send response to client from client point of view its job has been done successfully.",
              "createdAt": "2022-07-11T19:32:15Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,468 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Client;\n+using Microsoft.Build.Eventing;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client process.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        private readonly Dictionary<string, string> _serverEnvironmentVariables;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private readonly string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private readonly string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private readonly MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private readonly ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private readonly string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private readonly NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private readonly MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private readonly BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Used to estimate the size of the build with an ETW trace.\n+        /// </summary>\n+        private int _numConsoleWritePackets;\n+        private long _sizeOfConsoleWritePackets;\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            _serverEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken cancellationToken)\n+        {\n+            CommunicationsUtilities.Trace(\"Executing build with command line '{0}'\", commandLine);\n+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);\n+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);\n+\n+            // Start server it if is not running.\n+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverIsAlreadyRunning)\n+            {\n+                CommunicationsUtilities.Trace(\"Server was not running. Starting server now.\");\n+                if (!TryLaunchServer())\n+                {\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverIsAlreadyRunning ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicker deal with possible issues with connection to server.\n+            MSBuildEventSource.Log.MSBuildServerBuildStart(commandLine);\n+            if (!TrySendBuildCommand(commandLine))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            _numConsoleWritePackets = 0;\n+            _sizeOfConsoleWritePackets = 0;\n+\n+            try\n+            {\n+                // Start packet pump\n+                using MSBuildClientPacketPump packetPump = new(_nodeStream);\n+\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+                packetPump.Start();\n+\n+                WaitHandle[] waitHandles =\n+                {\n+                    cancellationToken.WaitHandle,\n+                    packetPump.PacketPumpErrorEvent,\n+                    packetPump.PacketReceivedEvent\n+                };\n+\n+                while (!_buildFinished)\n+                {\n+                    int index = WaitHandle.WaitAny(waitHandles);\n+                    switch (index)\n+                    {\n+                        case 0:\n+                            HandleCancellation();\n+                            break;\n+\n+                        case 1:\n+                            HandlePacketPumpError(packetPump);\n+                            break;\n+\n+                        case 2:\n+                            while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet) &&\n+                                   !_buildFinished &&\n+                                   !cancellationToken.IsCancellationRequested)\n+                            {\n+                                if (packet != null)\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                            }\n+\n+                            break;\n+                    }\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"MSBuild client error: problem during packet handling occurred: {0}.\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            }\n+\n+            MSBuildEventSource.Log.MSBuildServerBuildStop(commandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_handshake.ComputeHash()}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  _serverEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched with PID: {0}\", msbuildProcess.Id);\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch the msbuild server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        {\n+            CommunicationsUtilities.Trace(\"Launching server node from {0} with arguments {1}\", exeLocation, msBuildServerArguments);\n+            ProcessStartInfo processStartInfo = new() \n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env to enable MSBuild Server that might be equal to 1, so we do not get an infinite recursion here.\n+            processStartInfo.Environment[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to launch.\");\n+        }\n+\n+        private bool TrySendBuildCommand(string commandLine)\n+        {\n+            try\n+            {\n+                ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+                WritePacket(_nodeStream, buildCommand);\n+                CommunicationsUtilities.Trace(\"Build command sent...\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to send build command to server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+            Dictionary<string, string> envVars = new();\n+\n+            foreach (DictionaryEntry envVar in Environment.GetEnvironmentVariables())\n+            {\n+                envVars[(string)envVar.Key] = (envVar.Value as string) ?? string.Empty;\n+            }\n+\n+            foreach (var pair in _serverEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            return new ServerNodeHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+        }\n+\n+        /// <summary>\n+        /// Handle cancellation.\n+        /// </summary>\n+        private void HandleCancellation()\n+        {\n+            // TODO.\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            Console.WriteLine(\"MSBuild client cancelled.\");\n+            CommunicationsUtilities.Trace(\"MSBuild client cancelled.\");\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Cancelled;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Handle packet pump error.\n+        /// </summary>\n+        private void HandlePacketPumpError(MSBuildClientPacketPump packetPump)\n+        {\n+            CommunicationsUtilities.Trace(\"MSBuild client error: packet pump unexpectedly shut down: {0}\", packetPump.PacketPumpException);\n+            throw packetPump.PacketPumpException ?? new Exception(\"Packet pump unexpectedly shut down\");\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeConsoleWrite:\n+                    ServerNodeConsoleWrite writePacket = (packet as ServerNodeConsoleWrite)!;\n+                    HandleServerNodeConsoleWrite(writePacket);\n+                    _numConsoleWritePackets++;\n+                    _sizeOfConsoleWritePackets += writePacket.Text.Length;\n+                    break;\n+                case NodePacketType.ServerNodeBuildResult:\n+                    HandleServerNodeBuildResult((ServerNodeBuildResult)packet);\n+                    break;\n+                default: throw new InvalidOperationException($\"Unexpected packet type {packet.GetType().Name}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeConsoleWrite(ServerNodeConsoleWrite consoleWrite)\n+        {\n+            switch (consoleWrite.OutputType)\n+            {\n+                case ConsoleOutput.Standard:\n+                    Console.Write(consoleWrite.Text);\n+                    break;\n+                case ConsoleOutput.Error:\n+                    Console.Error.Write(consoleWrite.Text);\n+                    break;\n+                default:\n+                    throw new InvalidOperationException($\"Unexpected console output type {consoleWrite.OutputType}\");\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildResult(ServerNodeBuildResult response)\n+        {\n+            CommunicationsUtilities.Trace(\"Build response received: exit code {0}, exit type '{1}'\", response.ExitCode, response.ExitType);\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Success;\n+            _exitResult.MSBuildAppExitTypeString = response.ExitType;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n                default:\r\n                    throw new InvalidOperationException($\"Unexpected packet type {packet.GetType().Name}\");\r\n```",
              "createdAt": "2022-05-25T23:18:41Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,468 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Client;\n+using Microsoft.Build.Eventing;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client process.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        private readonly Dictionary<string, string> _serverEnvironmentVariables;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private readonly string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private readonly string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private readonly MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private readonly ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private readonly string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private readonly NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private readonly MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private readonly BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Used to estimate the size of the build with an ETW trace.\n+        /// </summary>\n+        private int _numConsoleWritePackets;\n+        private long _sizeOfConsoleWritePackets;\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            _serverEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken cancellationToken)\n+        {\n+            CommunicationsUtilities.Trace(\"Executing build with command line '{0}'\", commandLine);\n+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);\n+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);\n+\n+            // Start server it if is not running.\n+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverIsAlreadyRunning)\n+            {\n+                CommunicationsUtilities.Trace(\"Server was not running. Starting server now.\");\n+                if (!TryLaunchServer())\n+                {\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverIsAlreadyRunning ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicker deal with possible issues with connection to server.\n+            MSBuildEventSource.Log.MSBuildServerBuildStart(commandLine);\n+            if (!TrySendBuildCommand(commandLine))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            _numConsoleWritePackets = 0;\n+            _sizeOfConsoleWritePackets = 0;\n+\n+            try\n+            {\n+                // Start packet pump\n+                using MSBuildClientPacketPump packetPump = new(_nodeStream);\n+\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+                packetPump.Start();\n+\n+                WaitHandle[] waitHandles =\n+                {\n+                    cancellationToken.WaitHandle,\n+                    packetPump.PacketPumpErrorEvent,\n+                    packetPump.PacketReceivedEvent\n+                };\n+\n+                while (!_buildFinished)\n+                {\n+                    int index = WaitHandle.WaitAny(waitHandles);\n+                    switch (index)\n+                    {\n+                        case 0:\n+                            HandleCancellation();\n+                            break;\n+\n+                        case 1:\n+                            HandlePacketPumpError(packetPump);\n+                            break;\n+\n+                        case 2:\n+                            while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet) &&\n+                                   !_buildFinished &&\n+                                   !cancellationToken.IsCancellationRequested)\n+                            {\n+                                if (packet != null)\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                            }\n+\n+                            break;\n+                    }\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"MSBuild client error: problem during packet handling occurred: {0}.\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            }\n+\n+            MSBuildEventSource.Log.MSBuildServerBuildStop(commandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_handshake.ComputeHash()}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  _serverEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched with PID: {0}\", msbuildProcess.Id);\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch the msbuild server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        {\n+            CommunicationsUtilities.Trace(\"Launching server node from {0} with arguments {1}\", exeLocation, msBuildServerArguments);\n+            ProcessStartInfo processStartInfo = new() \n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env to enable MSBuild Server that might be equal to 1, so we do not get an infinite recursion here.\n+            processStartInfo.Environment[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to launch.\");\n+        }\n+\n+        private bool TrySendBuildCommand(string commandLine)\n+        {\n+            try\n+            {\n+                ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+                WritePacket(_nodeStream, buildCommand);\n+                CommunicationsUtilities.Trace(\"Build command sent...\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to send build command to server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+            Dictionary<string, string> envVars = new();\n+\n+            foreach (DictionaryEntry envVar in Environment.GetEnvironmentVariables())\n+            {\n+                envVars[(string)envVar.Key] = (envVar.Value as string) ?? string.Empty;\n+            }\n+\n+            foreach (var pair in _serverEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            return new ServerNodeHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+        }\n+\n+        /// <summary>\n+        /// Handle cancellation.\n+        /// </summary>\n+        private void HandleCancellation()\n+        {\n+            // TODO.\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            Console.WriteLine(\"MSBuild client cancelled.\");\n+            CommunicationsUtilities.Trace(\"MSBuild client cancelled.\");\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Cancelled;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Handle packet pump error.\n+        /// </summary>\n+        private void HandlePacketPumpError(MSBuildClientPacketPump packetPump)\n+        {\n+            CommunicationsUtilities.Trace(\"MSBuild client error: packet pump unexpectedly shut down: {0}\", packetPump.PacketPumpException);\n+            throw packetPump.PacketPumpException ?? new Exception(\"Packet pump unexpectedly shut down\");\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeConsoleWrite:\n+                    ServerNodeConsoleWrite writePacket = (packet as ServerNodeConsoleWrite)!;\n+                    HandleServerNodeConsoleWrite(writePacket);\n+                    _numConsoleWritePackets++;\n+                    _sizeOfConsoleWritePackets += writePacket.Text.Length;\n+                    break;\n+                case NodePacketType.ServerNodeBuildResult:\n+                    HandleServerNodeBuildResult((ServerNodeBuildResult)packet);\n+                    break;\n+                default: throw new InvalidOperationException($\"Unexpected packet type {packet.GetType().Name}\");",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "InternalErrorException?",
              "createdAt": "2022-05-25T23:19:32Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,468 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Client;\n+using Microsoft.Build.Eventing;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client process.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        private readonly Dictionary<string, string> _serverEnvironmentVariables;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private readonly string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private readonly string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private readonly MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private readonly ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private readonly string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private readonly NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private readonly MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private readonly BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Used to estimate the size of the build with an ETW trace.\n+        /// </summary>\n+        private int _numConsoleWritePackets;\n+        private long _sizeOfConsoleWritePackets;\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            _serverEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken cancellationToken)\n+        {\n+            CommunicationsUtilities.Trace(\"Executing build with command line '{0}'\", commandLine);\n+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);\n+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);\n+\n+            // Start server it if is not running.\n+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverIsAlreadyRunning)\n+            {\n+                CommunicationsUtilities.Trace(\"Server was not running. Starting server now.\");\n+                if (!TryLaunchServer())\n+                {\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverIsAlreadyRunning ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicker deal with possible issues with connection to server.\n+            MSBuildEventSource.Log.MSBuildServerBuildStart(commandLine);\n+            if (!TrySendBuildCommand(commandLine))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            _numConsoleWritePackets = 0;\n+            _sizeOfConsoleWritePackets = 0;\n+\n+            try\n+            {\n+                // Start packet pump\n+                using MSBuildClientPacketPump packetPump = new(_nodeStream);\n+\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+                packetPump.Start();\n+\n+                WaitHandle[] waitHandles =\n+                {\n+                    cancellationToken.WaitHandle,\n+                    packetPump.PacketPumpErrorEvent,\n+                    packetPump.PacketReceivedEvent\n+                };\n+\n+                while (!_buildFinished)\n+                {\n+                    int index = WaitHandle.WaitAny(waitHandles);\n+                    switch (index)\n+                    {\n+                        case 0:\n+                            HandleCancellation();\n+                            break;\n+\n+                        case 1:\n+                            HandlePacketPumpError(packetPump);\n+                            break;\n+\n+                        case 2:\n+                            while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet) &&\n+                                   !_buildFinished &&\n+                                   !cancellationToken.IsCancellationRequested)\n+                            {\n+                                if (packet != null)\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                            }\n+\n+                            break;\n+                    }\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"MSBuild client error: problem during packet handling occurred: {0}.\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            }\n+\n+            MSBuildEventSource.Log.MSBuildServerBuildStop(commandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_handshake.ComputeHash()}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  _serverEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched with PID: {0}\", msbuildProcess.Id);\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch the msbuild server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        {\n+            CommunicationsUtilities.Trace(\"Launching server node from {0} with arguments {1}\", exeLocation, msBuildServerArguments);\n+            ProcessStartInfo processStartInfo = new() \n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env to enable MSBuild Server that might be equal to 1, so we do not get an infinite recursion here.\n+            processStartInfo.Environment[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to launch.\");\n+        }\n+\n+        private bool TrySendBuildCommand(string commandLine)\n+        {\n+            try\n+            {\n+                ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+                WritePacket(_nodeStream, buildCommand);\n+                CommunicationsUtilities.Trace(\"Build command sent...\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to send build command to server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+            Dictionary<string, string> envVars = new();\n+\n+            foreach (DictionaryEntry envVar in Environment.GetEnvironmentVariables())\n+            {\n+                envVars[(string)envVar.Key] = (envVar.Value as string) ?? string.Empty;\n+            }\n+\n+            foreach (var pair in _serverEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            return new ServerNodeHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+        }\n+\n+        /// <summary>\n+        /// Handle cancellation.\n+        /// </summary>\n+        private void HandleCancellation()\n+        {\n+            // TODO.\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            Console.WriteLine(\"MSBuild client cancelled.\");\n+            CommunicationsUtilities.Trace(\"MSBuild client cancelled.\");\n+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Cancelled;\n+            _buildFinished = true;\n+        }\n+\n+        /// <summary>\n+        /// Handle packet pump error.\n+        /// </summary>\n+        private void HandlePacketPumpError(MSBuildClientPacketPump packetPump)\n+        {\n+            CommunicationsUtilities.Trace(\"MSBuild client error: packet pump unexpectedly shut down: {0}\", packetPump.PacketPumpException);\n+            throw packetPump.PacketPumpException ?? new Exception(\"Packet pump unexpectedly shut down\");",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm wondering about whether we should be writing here\u2014it reveals different behavior to the user depending on whether they're using the server, and my understanding was that it should invisibly make your builds faster.",
              "createdAt": "2022-05-25T23:20:29Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,468 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Client;\n+using Microsoft.Build.Eventing;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client process.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        private readonly Dictionary<string, string> _serverEnvironmentVariables;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private readonly string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private readonly string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private readonly MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private readonly ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private readonly string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private readonly NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private readonly MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private readonly BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Used to estimate the size of the build with an ETW trace.\n+        /// </summary>\n+        private int _numConsoleWritePackets;\n+        private long _sizeOfConsoleWritePackets;\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            _serverEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken cancellationToken)\n+        {\n+            CommunicationsUtilities.Trace(\"Executing build with command line '{0}'\", commandLine);\n+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);\n+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);\n+\n+            // Start server it if is not running.\n+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverIsAlreadyRunning)\n+            {\n+                CommunicationsUtilities.Trace(\"Server was not running. Starting server now.\");\n+                if (!TryLaunchServer())\n+                {\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverIsAlreadyRunning ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicker deal with possible issues with connection to server.\n+            MSBuildEventSource.Log.MSBuildServerBuildStart(commandLine);\n+            if (!TrySendBuildCommand(commandLine))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            _numConsoleWritePackets = 0;\n+            _sizeOfConsoleWritePackets = 0;\n+\n+            try\n+            {\n+                // Start packet pump\n+                using MSBuildClientPacketPump packetPump = new(_nodeStream);\n+\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+                packetPump.Start();\n+\n+                WaitHandle[] waitHandles =\n+                {\n+                    cancellationToken.WaitHandle,\n+                    packetPump.PacketPumpErrorEvent,\n+                    packetPump.PacketReceivedEvent\n+                };\n+\n+                while (!_buildFinished)\n+                {\n+                    int index = WaitHandle.WaitAny(waitHandles);\n+                    switch (index)\n+                    {\n+                        case 0:\n+                            HandleCancellation();\n+                            break;\n+\n+                        case 1:\n+                            HandlePacketPumpError(packetPump);\n+                            break;\n+\n+                        case 2:\n+                            while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet) &&\n+                                   !_buildFinished &&\n+                                   !cancellationToken.IsCancellationRequested)\n+                            {\n+                                if (packet != null)\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                            }\n+\n+                            break;\n+                    }\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"MSBuild client error: problem during packet handling occurred: {0}.\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            }\n+\n+            MSBuildEventSource.Log.MSBuildServerBuildStop(commandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_handshake.ComputeHash()}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  _serverEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched with PID: {0}\", msbuildProcess.Id);\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch the msbuild server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        {\n+            CommunicationsUtilities.Trace(\"Launching server node from {0} with arguments {1}\", exeLocation, msBuildServerArguments);\n+            ProcessStartInfo processStartInfo = new() \n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env to enable MSBuild Server that might be equal to 1, so we do not get an infinite recursion here.\n+            processStartInfo.Environment[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to launch.\");\n+        }\n+\n+        private bool TrySendBuildCommand(string commandLine)\n+        {\n+            try\n+            {\n+                ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+                WritePacket(_nodeStream, buildCommand);\n+                CommunicationsUtilities.Trace(\"Build command sent...\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to send build command to server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+            Dictionary<string, string> envVars = new();\n+\n+            foreach (DictionaryEntry envVar in Environment.GetEnvironmentVariables())\n+            {\n+                envVars[(string)envVar.Key] = (envVar.Value as string) ?? string.Empty;\n+            }\n+\n+            foreach (var pair in _serverEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            return new ServerNodeBuildCommand(\n+                        commandLine,\n+                        startupDirectory: Directory.GetCurrentDirectory(),\n+                        buildProcessEnvironment: envVars,\n+                        CultureInfo.CurrentCulture,\n+                        CultureInfo.CurrentUICulture);\n+        }\n+\n+        private ServerNodeHandshake GetHandshake()\n+        {\n+            return new ServerNodeHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));\n+        }\n+\n+        /// <summary>\n+        /// Handle cancellation.\n+        /// </summary>\n+        private void HandleCancellation()\n+        {\n+            // TODO.\n+            // Send cancellation command to server.\n+            // SendCancelCommand(_nodeStream);\n+\n+            Console.WriteLine(\"MSBuild client cancelled.\");",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think it's a little cleaner to just undefine it.",
              "createdAt": "2022-05-25T23:21:05Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,468 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Client;\n+using Microsoft.Build.Eventing;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client process.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        private readonly Dictionary<string, string> _serverEnvironmentVariables;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private readonly string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private readonly string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private readonly MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private readonly ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private readonly string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private readonly NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private readonly MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private readonly BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Used to estimate the size of the build with an ETW trace.\n+        /// </summary>\n+        private int _numConsoleWritePackets;\n+        private long _sizeOfConsoleWritePackets;\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            _serverEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken cancellationToken)\n+        {\n+            CommunicationsUtilities.Trace(\"Executing build with command line '{0}'\", commandLine);\n+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);\n+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);\n+\n+            // Start server it if is not running.\n+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverIsAlreadyRunning)\n+            {\n+                CommunicationsUtilities.Trace(\"Server was not running. Starting server now.\");\n+                if (!TryLaunchServer())\n+                {\n+                    return _exitResult;\n+                }\n+            }\n+\n+            // Check that server is not busy.\n+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);\n+            if (serverWasBusy)\n+            {\n+                CommunicationsUtilities.Trace(\"Server is busy, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return _exitResult;\n+            }\n+\n+            // Connect to server.\n+            if (!TryConnectToServer(serverIsAlreadyRunning ? 1_000 : 20_000))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            // Send build command.\n+            // Let's send it outside the packet pump so that we easier and quicker deal with possible issues with connection to server.\n+            MSBuildEventSource.Log.MSBuildServerBuildStart(commandLine);\n+            if (!TrySendBuildCommand(commandLine))\n+            {\n+                CommunicationsUtilities.Trace(\"Failure to connect to a server.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return _exitResult;\n+            }\n+\n+            _numConsoleWritePackets = 0;\n+            _sizeOfConsoleWritePackets = 0;\n+\n+            try\n+            {\n+                // Start packet pump\n+                using MSBuildClientPacketPump packetPump = new(_nodeStream);\n+\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);\n+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);\n+                packetPump.Start();\n+\n+                WaitHandle[] waitHandles =\n+                {\n+                    cancellationToken.WaitHandle,\n+                    packetPump.PacketPumpErrorEvent,\n+                    packetPump.PacketReceivedEvent\n+                };\n+\n+                while (!_buildFinished)\n+                {\n+                    int index = WaitHandle.WaitAny(waitHandles);\n+                    switch (index)\n+                    {\n+                        case 0:\n+                            HandleCancellation();\n+                            break;\n+\n+                        case 1:\n+                            HandlePacketPumpError(packetPump);\n+                            break;\n+\n+                        case 2:\n+                            while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet) &&\n+                                   !_buildFinished &&\n+                                   !cancellationToken.IsCancellationRequested)\n+                            {\n+                                if (packet != null)\n+                                {\n+                                    HandlePacket(packet);\n+                                }\n+                            }\n+\n+                            break;\n+                    }\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"MSBuild client error: problem during packet handling occurred: {0}.\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;\n+            }\n+\n+            MSBuildEventSource.Log.MSBuildServerBuildStop(commandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);\n+            CommunicationsUtilities.Trace(\"Build finished.\");\n+            return _exitResult;\n+        }\n+\n+        private void SendCancelCommand(NamedPipeClientStream nodeStream) => throw new NotImplementedException();\n+\n+        /// <summary>\n+        /// Launches MSBuild server. \n+        /// </summary>\n+        /// <returns> Whether MSBuild server was started successfully.</returns>\n+        private bool TryLaunchServer()\n+        {\n+            string serverLaunchMutexName = $@\"Global\\server-launch-{_handshake.ComputeHash()}\";\n+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.\n+                CommunicationsUtilities.Trace(\"Another process launching the msbuild server, falling back to former behavior.\");\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;\n+                return false;\n+            }\n+\n+            string[] msBuildServerOptions = new string[] {\n+                _dllLocation,\n+                \"/nologo\",\n+                \"/nodemode:8\"\n+            };\n+\n+            try\n+            {\n+                Process msbuildProcess = LaunchNode(_exeLocation, string.Join(\" \", msBuildServerOptions),  _serverEnvironmentVariables);\n+                CommunicationsUtilities.Trace(\"Server is launched with PID: {0}\", msbuildProcess.Id);\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to launch the msbuild server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private Process LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)\n+        {\n+            CommunicationsUtilities.Trace(\"Launching server node from {0} with arguments {1}\", exeLocation, msBuildServerArguments);\n+            ProcessStartInfo processStartInfo = new() \n+            {\n+                FileName = exeLocation,\n+                Arguments = msBuildServerArguments,\n+                UseShellExecute = false\n+            };\n+\n+            foreach (var entry in serverEnvironmentVariables)\n+            {\n+                processStartInfo.Environment[entry.Key] = entry.Value;\n+            }\n+\n+            // We remove env to enable MSBuild Server that might be equal to 1, so we do not get an infinite recursion here.\n+            processStartInfo.Environment[Traits.UseMSBuildServerEnvVarName] = \"0\";\n+\n+            processStartInfo.CreateNoWindow = true;\n+            processStartInfo.UseShellExecute = false;\n+\n+            return Process.Start(processStartInfo) ?? throw new InvalidOperationException(\"MSBuild server node failed to launch.\");\n+        }\n+\n+        private bool TrySendBuildCommand(string commandLine)\n+        {\n+            try\n+            {\n+                ServerNodeBuildCommand buildCommand = GetServerNodeBuildCommand(commandLine);\n+                WritePacket(_nodeStream, buildCommand);\n+                CommunicationsUtilities.Trace(\"Build command sent...\");\n+            }\n+            catch (Exception ex)\n+            {\n+                CommunicationsUtilities.Trace(\"Failed to send build command to server: {0}\", ex);\n+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ConnectionError;\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        private ServerNodeBuildCommand GetServerNodeBuildCommand(string commandLine)\n+        {\n+            Dictionary<string, string> envVars = new();\n+\n+            foreach (DictionaryEntry envVar in Environment.GetEnvironmentVariables())\n+            {\n+                envVars[(string)envVar.Key] = (envVar.Value as string) ?? string.Empty;\n+            }\n+\n+            foreach (var pair in _serverEnvironmentVariables)\n+            {\n+                envVars[pair.Key] = pair.Value;\n+            }\n+\n+            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here. \n+            envVars[Traits.UseMSBuildServerEnvVarName] = \"0\";",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This calls the hash function on _handshake twice. It'd be nice to cache that. At minimum, we should move the calculation for serverBusyMutexName below the serverIsAlreadyRunning block so it doesn't have to execute if we'll never use it.",
              "createdAt": "2022-05-25T23:24:45Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,468 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Client;\n+using Microsoft.Build.Eventing;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client process.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        private readonly Dictionary<string, string> _serverEnvironmentVariables;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private readonly string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private readonly string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private readonly MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private readonly ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private readonly string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private readonly NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private readonly MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private readonly BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Used to estimate the size of the build with an ETW trace.\n+        /// </summary>\n+        private int _numConsoleWritePackets;\n+        private long _sizeOfConsoleWritePackets;\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            _serverEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken cancellationToken)\n+        {\n+            CommunicationsUtilities.Trace(\"Executing build with command line '{0}'\", commandLine);\n+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);\n+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The hash is cached inside the `ServerNodeHandshake` after first use.",
              "createdAt": "2022-06-28T13:00:41Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,468 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Client;\n+using Microsoft.Build.Eventing;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client process.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        private readonly Dictionary<string, string> _serverEnvironmentVariables;\n+\n+        /// <summary>\n+        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.\n+        /// </summary>\n+        private readonly string _exeLocation;\n+\n+        /// <summary>\n+        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.\n+        /// </summary>\n+        private readonly string _dllLocation;\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private readonly MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private readonly ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private readonly string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private readonly NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private readonly MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private readonly BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Used to estimate the size of the build with an ETW trace.\n+        /// </summary>\n+        private int _numConsoleWritePackets;\n+        private long _sizeOfConsoleWritePackets;\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"exeLocation\">Location of executable file to launch the server process.\n+        /// That should be either dotnet.exe or MSBuild.exe location.</param>\n+        /// <param name=\"dllLocation\">Location of dll file to launch the server process if needed.\n+        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>\n+        public MSBuildClient(string exeLocation, string dllLocation)\n+        {\n+            _serverEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _exeLocation = exeLocation;\n+            _dllLocation = dllLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and\n+        /// is ignored.</param>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(string commandLine, CancellationToken cancellationToken)\n+        {\n+            CommunicationsUtilities.Trace(\"Executing build with command line '{0}'\", commandLine);\n+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);\n+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wrong license. Fix it in all classes.",
              "createdAt": "2022-06-16T16:06:28Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,29 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm equally unsure if this is needed or not anymore. This was primarily used for the Mono toolset in VS4Mac code paths. It was added years ago and I'm unsure if it's still used or not. @lambdageek may know who to ask here. Essentially do we still have places where we drive modern versions of MSBuild with Mono",
              "createdAt": "2022-06-22T05:05:11Z",
              "path": "src/Build/BackEnd/Node/ServerNamedMutex.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal sealed class ServerNamedMutex : IDisposable\n+    {\n+        private readonly Mutex _serverMutex;\n+\n+        public bool IsDisposed { get; private set; }\n+\n+        public bool IsLocked { get; private set; }\n+\n+        public ServerNamedMutex(string mutexName, out bool createdNew)\n+        {\n+            _serverMutex = new Mutex(\n+                initiallyOwned: true,\n+                name: mutexName,\n+                createdNew: out createdNew);\n+\n+            if (createdNew)\n+            {\n+                IsLocked = true;\n+            }\n+        }\n+\n+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+        {\n+            // TODO: verify it is not needed anymore",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "After discussion with Rainer it seems msbuild do not run on Mono runtime anymore - deleted",
              "createdAt": "2022-07-11T14:43:42Z",
              "path": "src/Build/BackEnd/Node/ServerNamedMutex.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    internal sealed class ServerNamedMutex : IDisposable\n+    {\n+        private readonly Mutex _serverMutex;\n+\n+        public bool IsDisposed { get; private set; }\n+\n+        public bool IsLocked { get; private set; }\n+\n+        public ServerNamedMutex(string mutexName, out bool createdNew)\n+        {\n+            _serverMutex = new Mutex(\n+                initiallyOwned: true,\n+                name: mutexName,\n+                createdNew: out createdNew);\n+\n+            if (createdNew)\n+            {\n+                IsLocked = true;\n+            }\n+        }\n+\n+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+        {\n+            // TODO: verify it is not needed anymore",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why do you not set `_exitResult.MSBuildClientExitType` to `LaunchError` here?",
              "createdAt": "2022-06-22T05:15:13Z",
              "path": "src/Build/BackEnd/Client/MSBuildClient.cs",
              "diffHunk": "@@ -0,0 +1,576 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.IO.Pipes;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.BackEnd.Client;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Eventing;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental\n+{\n+    /// <summary>\n+    /// This class is the public entry point for executing builds in msbuild server.\n+    /// It processes command-line arguments and invokes the build engine.\n+    /// </summary>\n+    public sealed class MSBuildClient\n+    {\n+        /// <summary>\n+        /// The build inherits all the environment variables from the client process.\n+        /// This property allows to add extra environment variables or reset some of the existing ones.\n+        /// </summary>\n+        private readonly Dictionary<string, string> _serverEnvironmentVariables;\n+\n+        /// <summary>\n+        /// Full path to current MSBuild.exe if executable is MSBuild.exe,\n+        /// or to version of MSBuild.dll found to be associated with the current process.\n+        /// </summary>\n+        private readonly string _msbuildLocation;\n+\n+        /// <summary>\n+        /// The command line to process.\n+        /// The first argument on the command line is assumed to be the name/path of the executable, and is ignored.\n+        /// </summary>\n+#if FEATURE_GET_COMMANDLINE\n+        private readonly string _commandLine;\n+#else\n+        private readonly string[] _commandLine;\n+#endif\n+\n+        /// <summary>\n+        /// The MSBuild client execution result.\n+        /// </summary>\n+        private readonly MSBuildClientExitResult _exitResult;\n+\n+        /// <summary>\n+        /// Whether MSBuild server finished the build.\n+        /// </summary>\n+        private bool _buildFinished = false;\n+\n+        /// <summary>\n+        /// Handshake between server and client.\n+        /// </summary>\n+        private readonly ServerNodeHandshake _handshake;\n+\n+        /// <summary>\n+        /// The named pipe name for client-server communication.\n+        /// </summary>\n+        private readonly string _pipeName;\n+\n+        /// <summary>\n+        /// The named pipe stream for client-server communication.\n+        /// </summary>\n+        private readonly NamedPipeClientStream _nodeStream;\n+\n+        /// <summary>\n+        /// A way to cache a byte array when writing out packets\n+        /// </summary>\n+        private readonly MemoryStream _packetMemoryStream;\n+\n+        /// <summary>\n+        /// A binary writer to help write into <see cref=\"_packetMemoryStream\"/>\n+        /// </summary>\n+        private readonly BinaryWriter _binaryWriter;\n+\n+        /// <summary>\n+        /// Used to estimate the size of the build with an ETW trace.\n+        /// </summary>\n+        private int _numConsoleWritePackets;\n+        private long _sizeOfConsoleWritePackets;\n+\n+        /// <summary>\n+        /// Capture configuration of Client Console.\n+        /// </summary>\n+        private TargetConsoleConfiguration? _consoleConfiguration;\n+\n+        /// <summary>\n+        /// Public constructor with parameters.\n+        /// </summary>\n+        /// <param name=\"commandLine\">The command line to process. The first argument\n+        /// on the command line is assumed to be the name/path of the executable, and is ignored</param>\n+        /// <param name=\"msbuildLocation\"> Full path to current MSBuild.exe if executable is MSBuild.exe,\n+        /// or to version of MSBuild.dll found to be associated with the current process.</param>\n+        public MSBuildClient(\n+#if FEATURE_GET_COMMANDLINE\n+            string commandLine,\n+#else\n+            string[] commandLine,\n+#endif\n+            string msbuildLocation)\n+        {\n+            _serverEnvironmentVariables = new();\n+            _exitResult = new();\n+\n+            // dll & exe locations\n+            _commandLine = commandLine;\n+            _msbuildLocation = msbuildLocation;\n+\n+            // Client <-> Server communication stream\n+            _handshake = GetHandshake();\n+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);\n+            _nodeStream = new NamedPipeClientStream(\".\", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous\n+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY\n+                                                                         | PipeOptions.CurrentUserOnly\n+#endif\n+            );\n+\n+            _packetMemoryStream = new MemoryStream();\n+            _binaryWriter = new BinaryWriter(_packetMemoryStream);\n+        }\n+\n+        /// <summary>\n+        /// Orchestrates the execution of the build on the server,\n+        /// responsible for client-server communication.\n+        /// </summary>\n+        /// <param name=\"cancellationToken\">Cancellation token.</param>\n+        /// <returns>A value of type <see cref=\"MSBuildClientExitResult\"/> that indicates whether the build succeeded,\n+        /// or the manner in which it failed.</returns>\n+        public MSBuildClientExitResult Execute(CancellationToken cancellationToken)\n+        {\n+            // Command line in one string used only in human readable content.\n+            string descriptiveCommandLine =\n+#if FEATURE_GET_COMMANDLINE\n+                _commandLine;\n+#else\n+                string.Join(\" \", _commandLine);\n+#endif\n+\n+            CommunicationsUtilities.Trace(\"Executing build with command line '{0}'\", descriptiveCommandLine);\n+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);\n+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);\n+\n+            // Start server it if is not running.\n+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);\n+            if (!serverIsAlreadyRunning)\n+            {\n+                CommunicationsUtilities.Trace(\"Server was not running. Starting server now.\");\n+                if (!TryLaunchServer())\n+                {",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                await Task.Delay(80); // should be somehow bigger than `RedirectConsoleWriter` flush period - see its constructor\r\n```",
              "createdAt": "2022-07-13T10:36:30Z",
              "path": "src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs",
              "diffHunk": "@@ -0,0 +1,31 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Experimental;\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.Build.Engine.UnitTests.BackEnd\n+{\n+    public class RedirectConsoleWriter_Tests\n+    {\n+        [Fact]\n+        public async Task EmitConsoleMessages()\n+        {\n+            StringBuilder sb = new StringBuilder();\n+\n+            using (TextWriter writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text)))\n+            {\n+                writer.WriteLine(\"Line 1\");\n+                await Task.Delay(300);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    // Project graph can have multiple entry points, for purposes of identifying event for same build project,\r\n                    // we believe that including only one entry point will provide enough precision.\r\n                    KnownTelemetry.BuildTelemetry.Project ??= requestData.ProjectGraphEntryPoints?.FirstOrDefault().ProjectFile;\r\n```",
              "createdAt": "2022-07-13T10:40:30Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -817,6 +833,13 @@ public GraphBuildSubmission PendBuildRequest(GraphBuildRequestData requestData)\n                 VerifyStateInternal(BuildManagerState.Building);\n \n                 var newSubmission = new GraphBuildSubmission(this, GetNextSubmissionId(), requestData);\n+\n+                if (KnownTelemetry.BuildTelemetry != null)\n+                {\n+                    KnownTelemetry.BuildTelemetry.Project ??= requestData.ProjectGraphEntryPoints?.FirstOrDefault().ProjectFile;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                            // Clean telemetry to make it ready for next build submission.\r\n```",
              "createdAt": "2022-07-13T10:45:46Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -965,6 +988,35 @@ public void EndBuild()\n                         }\n \n                         loggingService.LogBuildFinished(_overallBuildSuccess);\n+\n+                        if (KnownTelemetry.BuildTelemetry != null)\n+                        {\n+                            KnownTelemetry.BuildTelemetry.FinishedAt = DateTime.UtcNow;\n+                            KnownTelemetry.BuildTelemetry.Success = _overallBuildSuccess;\n+                            KnownTelemetry.BuildTelemetry.Version = ProjectCollection.Version;\n+                            KnownTelemetry.BuildTelemetry.DisplayVersion = ProjectCollection.DisplayVersion;\n+                            KnownTelemetry.BuildTelemetry.FrameworkName = NativeMethodsShared.FrameworkName;\n+\n+                            string host = null;\n+                            if (BuildEnvironmentState.s_runningInVisualStudio)\n+                            {\n+                                host = \"VS\";\n+                            }\n+                            else if (!string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILD_HOST_NAME\")))\n+                            {\n+                                host = Environment.GetEnvironmentVariable(\"MSBUILD_HOST_NAME\");\n+                            }\n+                            else if (!string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"VSCODE_CWD\")) || Environment.GetEnvironmentVariable(\"TERM_PROGRAM\") == \"vscode\")\n+                            {\n+                                host = \"VSCode\";\n+                            }\n+                            KnownTelemetry.BuildTelemetry.Host = host;\n+\n+                            KnownTelemetry.BuildTelemetry.UpdateEventProperties();\n+                            loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.BuildTelemetry.EventName, KnownTelemetry.BuildTelemetry.Properties);\n+                            // Clean telemetry which makes it ready for next build submission.",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    processStartInfo.CreateNoWindow = (creationFlags & BackendNativeMethods.CREATENOWINDOW) == BackendNativeMethods.CREATENOWINDOW;\r\n```\r\n?",
              "createdAt": "2022-07-13T16:18:16Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,211 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal class NodeLauncher\n+    {\n+        /// <summary>\n+        /// Creates a new MSBuild process\n+        /// </summary>\n+        public Process Start(string msbuildLocation, string commandLineArgs)\n+        {\n+            // Disable MSBuild server for a child process.\n+            // In case of starting msbuild server it prevents an infinite recurson. In case of starting msbuild node we also do not want this variable to be set.\n+            return DisableMSBuildServer(() => StartInternal(msbuildLocation, commandLineArgs));\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process\n+        /// </summary>\n+        private Process StartInternal(string msbuildLocation, string commandLineArgs)\n+        {\n+            // Should always have been set already.\n+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));\n+\n+            if (!FileSystems.Default.FileExists(msbuildLocation))\n+            {\n+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n+            }\n+\n+            // Repeat the executable name as the first token of the command line because the command line\n+            // parser logic expects it and will otherwise skip the first argument\n+            commandLineArgs = $\"\\\"{msbuildLocation}\\\" {commandLineArgs}\";\n+\n+            BackendNativeMethods.STARTUP_INFO startInfo = new();\n+            startInfo.cb = Marshal.SizeOf<BackendNativeMethods.STARTUP_INFO>();\n+\n+            // Null out the process handles so that the parent process does not wait for the child process\n+            // to exit before it can exit.\n+            uint creationFlags = 0;\n+            if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)\n+            {\n+                creationFlags = BackendNativeMethods.NORMALPRIORITYCLASS;\n+            }\n+\n+            if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDNODEWINDOW\")))\n+            {\n+                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)\n+                {\n+                    // Redirect the streams of worker nodes so that this MSBuild.exe's\n+                    // parent doesn't wait on idle worker nodes to close streams\n+                    // after the build is complete.\n+                    startInfo.hStdError = BackendNativeMethods.InvalidHandle;\n+                    startInfo.hStdInput = BackendNativeMethods.InvalidHandle;\n+                    startInfo.hStdOutput = BackendNativeMethods.InvalidHandle;\n+                    startInfo.dwFlags = BackendNativeMethods.STARTFUSESTDHANDLES;\n+                    creationFlags |= BackendNativeMethods.CREATENOWINDOW;\n+                }\n+            }\n+            else\n+            {\n+                creationFlags |= BackendNativeMethods.CREATE_NEW_CONSOLE;\n+            }\n+\n+            CommunicationsUtilities.Trace(\"Launching node from {0}\", msbuildLocation);\n+\n+            string exeName = msbuildLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+            // Mono automagically uses the current mono, to execute a managed assembly\n+            if (!NativeMethodsShared.IsMono)\n+            {\n+                // Run the child process with the same host as the currently-running process.\n+                exeName = CurrentHost.GetCurrentHost();\n+            }\n+#endif\n+\n+            if (!NativeMethodsShared.IsWindows)\n+            {\n+                ProcessStartInfo processStartInfo = new ProcessStartInfo();\n+                processStartInfo.FileName = exeName;\n+                processStartInfo.Arguments = commandLineArgs;\n+                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)\n+                {\n+                    // Redirect the streams of worker nodes so that this MSBuild.exe's\n+                    // parent doesn't wait on idle worker nodes to close streams\n+                    // after the build is complete.\n+                    processStartInfo.RedirectStandardInput = true;\n+                    processStartInfo.RedirectStandardOutput = true;\n+                    processStartInfo.RedirectStandardError = true;\n+                    processStartInfo.CreateNoWindow = (creationFlags | BackendNativeMethods.CREATENOWINDOW) == BackendNativeMethods.CREATENOWINDOW;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm unsure if it's better to break into the client or just wait to break into the server...it's useful to be able to debug anything that might be going wrong, but server was supposed to be mostly invisible, and that'd be visible.",
              "createdAt": "2022-07-13T16:33:15Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -209,21 +216,44 @@ string[] args\n #endif\n             )\n         {\n+            // Initialize new build telemetry and record start of this build.\n+            KnownTelemetry.BuildTelemetry = new BuildTelemetry { StartAt = DateTime.UtcNow };\n+\n             using PerformanceLogEventListener eventListener = PerformanceLogEventListener.Create();\n \n             if (Environment.GetEnvironmentVariable(\"MSBUILDDUMPPROCESSCOUNTERS\") == \"1\")\n             {\n                 DumpCounters(true /* initialize only */);\n             }\n \n-            // return 0 on success, non-zero on failure\n-            int exitCode = ((s_initialized && Execute(\n+            int exitCode;\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) && Environment.GetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName) == \"1\")\n+            {\n+                Console.CancelKeyPress += Console_CancelKeyPress;\n+\n+                DebuggerLaunchCheck();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}