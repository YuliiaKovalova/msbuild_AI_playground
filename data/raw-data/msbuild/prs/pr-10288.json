{
  "number": 10288,
  "title": "Add version to BuildResult 2",
  "body": "Fixes #10208\r\n\r\n### Context\r\nWe are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases (meaning the newer VS can read a cache created by older VS). The cache is not forwards compatible (older versions of VS cannot read cache created by newer versions). The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\r\n\r\nExecution plan:\r\n- 1st step (done): Add a special key to the _savedEnvironmentVariables dictionary during the serialization. A workaround overload of the TranslateDictionary function is created to achieve it. The presence of this key will indicate that the version is serialized next. When serializing, add a key to the dictionary and serialize a version field. Do not actually save the special key to dictionary during the deserialization but read a version as a next field if it presents.\r\n\r\n- 2nd step: Stop serialize a special key with the dictionary _savedEnvironmentVariables using the TranslateDictionary function workaround overload. Always serialize and de-serialize the version field. Continue to deserialize _savedEnvironmentVariables with the TranslateDictionary function workaround overload in order not to deserialize dictionary with the special keys.\r\n\r\n- 3rd step: Stop using the TranslateDictionary function workaround overload during _savedEnvironmentVariables deserialization.\r\n\r\n\r\n### Changes Made\r\n1st step from above description.\r\n\r\n### Testing\r\nUnit tests, manual tests, experimental insertion",
  "state": "MERGED",
  "createdAt": "2024-06-24T16:02:48Z",
  "updatedAt": "2024-06-27T11:46:51Z",
  "closedAt": "2024-06-27T11:46:51Z",
  "mergedAt": "2024-06-27T11:46:51Z",
  "additions": 277,
  "deletions": 10,
  "changedFiles": 7,
  "headRefName": "fix-results-cache-versioning-3",
  "isDraft": false,
  "author": {
    "login": "AR-May"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "AR-May"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "1f494b95096806742a303eaf8f63e10925526ddf",
          "message": "Add version to BuildResult",
          "committedDate": "2024-06-17T11:05:51Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "547e719bdfe3aaf8c6db2e3ae15582cfe9e6c2dc",
          "message": "Fix comments.",
          "committedDate": "2024-06-17T11:14:40Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9eeeb1c48d9c4d1655f14890ee00bc40b1177441",
          "message": "Fix setting the version.",
          "committedDate": "2024-06-17T16:06:36Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "189f4e2d74609aa06ba84aae475faf2e3665fd87",
          "message": "Add tests.",
          "committedDate": "2024-06-18T08:33:14Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e4b818e54f4d93ad8a99ea2dc294692b05791d3f",
          "message": "Key name fix",
          "committedDate": "2024-06-24T12:23:31Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "72cb1c1d86b15732e2e7bf11fd742eaad1770712",
          "message": "Implement a custom Translation",
          "committedDate": "2024-06-24T15:50:45Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1ef833a533c19353df900bac33e01ee3ef866741",
          "message": "Fix comments",
          "committedDate": "2024-06-24T16:03:54Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d99567d7debf6f4a8341a48c5c77266f4931628e",
          "message": "Merge remote-tracking branch 'upstream/vs17.11' into fix-results-cache-versioning-3",
          "committedDate": "2024-06-24T16:16:23Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8c60710f67f45ec6d587d4ed095432483833b299",
          "message": "Add version bump",
          "committedDate": "2024-06-24T16:17:12Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "93ccb62fb86afc775bf5b673beec39e06ce64d94",
          "message": "Remove unnecessary variable",
          "committedDate": "2024-06-24T16:43:57Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6a0e28322e163acd7e7c87703a54ddd5e6a27167",
          "message": "Remove unnecessary cast",
          "committedDate": "2024-06-24T16:46:39Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "39bf50b7355116ae76e3f96510e869a99b94537f",
          "message": "Add more comments",
          "committedDate": "2024-06-25T17:23:44Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8ec8f848c6513a1606c25682476c24f9999e03d5",
          "message": "Fix comments to resolve build errors",
          "committedDate": "2024-06-25T19:06:58Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5677e0cd1315e36dd31cc15fa9ae0f0746438b10",
          "message": "Address PR comments",
          "committedDate": "2024-06-26T15:19:20Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe also have an assert on count that this is the only key?",
              "createdAt": "2024-06-24T21:44:55Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -590,6 +598,46 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua\n                 dictionary = (Dictionary<string, string>)copy;\n             }\n \n+            /// <summary>\n+            /// Translates a dictionary of { string, string } adding extra entries.\n+            /// </summary>\n+            /// <param name=\"dictionary\">The dictionary to be translated.</param>\n+            /// <param name=\"comparer\">The comparer used to instantiate the dictionary.</param>\n+            /// <param name=\"additionalEntries\">Additional entries to be translated</param>\n+            /// <param name=\"additionalEntriesKeys\">Additional entries keys</param>\n+            public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer, ref Dictionary<string, string> additionalEntries, HashSet<string> additionalEntriesKeys)\n+            {\n+                if (!TranslateNullable(dictionary))\n+                {\n+                    return;\n+                }\n+\n+                int count = _reader.ReadInt32();\n+                dictionary = new Dictionary<string, string>(count, comparer);\n+                additionalEntries = new();\n+\n+                for (int i = 0; i < count; i++)\n+                {\n+                    string key = null;\n+                    Translate(ref key);\n+                    string value = null;\n+                    Translate(ref value);\n+                    if (additionalEntriesKeys.Contains(key))\n+                    {\n+                        additionalEntries[key] = value;\n+                    }\n+                    else if (comparer.Equals(key, SpecialKeyForDictionaryBeingNull))\n+                    {\n+                        // Presence of special key SpecialKeyForDictionaryBeingNull indicates that the dictionary was null.\n+                        dictionary = null;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Well, this would not be the only key, there should be additional key about the version being present in serialization also. We can have an assert that we have 2 entries in this case. In the Debug, not Release.",
              "createdAt": "2024-06-26T14:50:06Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -590,6 +598,46 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua\n                 dictionary = (Dictionary<string, string>)copy;\n             }\n \n+            /// <summary>\n+            /// Translates a dictionary of { string, string } adding extra entries.\n+            /// </summary>\n+            /// <param name=\"dictionary\">The dictionary to be translated.</param>\n+            /// <param name=\"comparer\">The comparer used to instantiate the dictionary.</param>\n+            /// <param name=\"additionalEntries\">Additional entries to be translated</param>\n+            /// <param name=\"additionalEntriesKeys\">Additional entries keys</param>\n+            public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer, ref Dictionary<string, string> additionalEntries, HashSet<string> additionalEntriesKeys)\n+            {\n+                if (!TranslateNullable(dictionary))\n+                {\n+                    return;\n+                }\n+\n+                int count = _reader.ReadInt32();\n+                dictionary = new Dictionary<string, string>(count, comparer);\n+                additionalEntries = new();\n+\n+                for (int i = 0; i < count; i++)\n+                {\n+                    string key = null;\n+                    Translate(ref key);\n+                    string value = null;\n+                    Translate(ref value);\n+                    if (additionalEntriesKeys.Contains(key))\n+                    {\n+                        additionalEntries[key] = value;\n+                    }\n+                    else if (comparer.Equals(key, SpecialKeyForDictionaryBeingNull))\n+                    {\n+                        // Presence of special key SpecialKeyForDictionaryBeingNull indicates that the dictionary was null.\n+                        dictionary = null;",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe some more explanation for this?\r\n\r\n```suggestion\r\n            /// Translates a dictionary of { string, string } that may be null despite being populated.\r\n```",
              "createdAt": "2024-06-24T21:45:50Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -590,6 +598,46 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua\n                 dictionary = (Dictionary<string, string>)copy;\n             }\n \n+            /// <summary>\n+            /// Translates a dictionary of { string, string } adding extra entries.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It allows to add a list of additional entries, in our case - SpecialKeyForVersion, this function is not about hadnling the case of dictionary being null, although it handles it correctly.",
              "createdAt": "2024-06-26T15:00:33Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -590,6 +598,46 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua\n                 dictionary = (Dictionary<string, string>)copy;\n             }\n \n+            /// <summary>\n+            /// Translates a dictionary of { string, string } adding extra entries.",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could you please explain this scenario? \r\nWhy when the request data flags is null results that there are equal? ",
              "createdAt": "2024-06-25T07:32:06Z",
              "path": "src/Build/BackEnd/Components/Caching/ResultsCache.cs",
              "diffHunk": "@@ -350,9 +350,14 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS\n         /// <param name=\"buildResult\">The candidate build result.</param>\n         /// <returns>True if the flags and project state filter of the build request is compatible with the build result.</returns>\n         private static bool AreBuildResultFlagsCompatible(BuildRequest buildRequest, BuildResult buildResult)\n-        {\n+        { \n+            if (buildResult.BuildRequestDataFlags is null)",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "Absent `BuildRequestDataFlags` data means it was not read from a results cache, we need to fall back to the previous behavior when this information was not available. From [this line](https://github.com/dotnet/msbuild/blob/c7904f283c2a5d4490916e09c4db6fe546c27e3d/src/Build/BackEnd/Components/Caching/ResultsCache.cs#L175) it is clear that we should consider the flags equal as this is behavior prior PR #9987",
              "createdAt": "2024-06-25T08:36:47Z",
              "path": "src/Build/BackEnd/Components/Caching/ResultsCache.cs",
              "diffHunk": "@@ -350,9 +350,14 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS\n         /// <param name=\"buildResult\">The candidate build result.</param>\n         /// <returns>True if the flags and project state filter of the build request is compatible with the build result.</returns>\n         private static bool AreBuildResultFlagsCompatible(BuildRequest buildRequest, BuildResult buildResult)\n-        {\n+        { \n+            if (buildResult.BuildRequestDataFlags is null)",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "could you please let me know, what is going to happen if the newer version of the msbuild tries to deserialize the cache from the release older that 2 previous? ",
              "createdAt": "2024-06-25T07:35:49Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +626,55 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "We were told that support of 2 previous versions is good enough. So, we are allowed to crash/disregard the entries. We will need to compare versions to show a meaningful warning/error, but that's with the next PRs. With the cache that has no version, our only option will be most probably a crash.",
              "createdAt": "2024-06-25T08:24:19Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +626,55 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "We will need to document which versions of caches we support.",
              "createdAt": "2024-06-25T08:24:48Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +626,55 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just to understand: how the order of the keys is ensured? ",
              "createdAt": "2024-06-25T07:53:36Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -1261,6 +1309,65 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua\n                 TranslateDictionary(ref copy, (NodePacketCollectionCreator<IDictionary<string, string>>)null);\n             }\n \n+            /// <summary>\n+            /// Translates a dictionary of { string, string } adding extra entries.\n+            /// </summary>\n+            /// <param name=\"dictionary\">The dictionary to be translated.</param>\n+            /// <param name=\"comparer\">The comparer used to instantiate the dictionary.</param>\n+            /// <param name=\"additionalEntries\">Additional entries to be translated.</param>\n+            /// <param name=\"additionalEntriesKeys\">Additional entries keys.</param>\n+            public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer, ref Dictionary<string, string> additionalEntries, HashSet<string> additionalEntriesKeys)\n+            {\n+                // Translate whether object is Null\n+                if ((dictionary is null) && ((additionalEntries is null) || (additionalEntries.Count == 0)))\n+                {\n+                    _writer.Write(false);\n+                    return;\n+                }\n+                else\n+                {\n+                    // Translate that object is not null\n+                    _writer.Write(true);\n+                }\n+\n+                // Writing dictionary, extra entries and special key if copy dictionary was null\n+                int count = (dictionary is null ? 0 : dictionary.Count) + (additionalEntries is null ? 0 : additionalEntries.Count) + (dictionary is null ? 1 : 0);\n+                _writer.Write(count);\n+\n+                // If the dictionary was null, add a special key SpecialKeyForDictionaryBeingNull to the dictionary.\n+                if (dictionary is null)\n+                {\n+                    string key = SpecialKeyForDictionaryBeingNull;\n+                    Translate(ref key);\n+                    string value = string.Empty;\n+                    Translate(ref value);\n+                }\n+\n+                if (additionalEntries is not null)\n+                {\n+                    // Translate extra entries\n+                    foreach (KeyValuePair<string, string> pair in additionalEntries)\n+                    {\n+                        string key = pair.Key;\n+                        Translate(ref key);\n+                        string value = pair.Value;\n+                        Translate(ref value);\n+                    }\n+                }\n+\n+                if (dictionary is not null)\n+                {\n+                    // Translate dictionary\n+                    foreach (KeyValuePair<string, string> pair in dictionary)\n+                    {\n+                        string key = pair.Key;\n+                        Translate(ref key);\n+                        string value = pair.Value;\n+                        Translate(ref value);\n+                    }\n+                }",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "The order should not matter there, it is a dictionary.",
              "createdAt": "2024-06-25T08:25:58Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -1261,6 +1309,65 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua\n                 TranslateDictionary(ref copy, (NodePacketCollectionCreator<IDictionary<string, string>>)null);\n             }\n \n+            /// <summary>\n+            /// Translates a dictionary of { string, string } adding extra entries.\n+            /// </summary>\n+            /// <param name=\"dictionary\">The dictionary to be translated.</param>\n+            /// <param name=\"comparer\">The comparer used to instantiate the dictionary.</param>\n+            /// <param name=\"additionalEntries\">Additional entries to be translated.</param>\n+            /// <param name=\"additionalEntriesKeys\">Additional entries keys.</param>\n+            public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer, ref Dictionary<string, string> additionalEntries, HashSet<string> additionalEntriesKeys)\n+            {\n+                // Translate whether object is Null\n+                if ((dictionary is null) && ((additionalEntries is null) || (additionalEntries.Count == 0)))\n+                {\n+                    _writer.Write(false);\n+                    return;\n+                }\n+                else\n+                {\n+                    // Translate that object is not null\n+                    _writer.Write(true);\n+                }\n+\n+                // Writing dictionary, extra entries and special key if copy dictionary was null\n+                int count = (dictionary is null ? 0 : dictionary.Count) + (additionalEntries is null ? 0 : additionalEntries.Count) + (dictionary is null ? 1 : 0);\n+                _writer.Write(count);\n+\n+                // If the dictionary was null, add a special key SpecialKeyForDictionaryBeingNull to the dictionary.\n+                if (dictionary is null)\n+                {\n+                    string key = SpecialKeyForDictionaryBeingNull;\n+                    Translate(ref key);\n+                    string value = string.Empty;\n+                    Translate(ref value);\n+                }\n+\n+                if (additionalEntries is not null)\n+                {\n+                    // Translate extra entries\n+                    foreach (KeyValuePair<string, string> pair in additionalEntries)\n+                    {\n+                        string key = pair.Key;\n+                        Translate(ref key);\n+                        string value = pair.Value;\n+                        Translate(ref value);\n+                    }\n+                }\n+\n+                if (dictionary is not null)\n+                {\n+                    // Translate dictionary\n+                    foreach (KeyValuePair<string, string> pair in dictionary)\n+                    {\n+                        string key = pair.Key;\n+                        Translate(ref key);\n+                        string value = pair.Value;\n+                        Translate(ref value);\n+                    }\n+                }",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I thought the order should matter in case of translating, Thank you! ",
              "createdAt": "2024-06-25T08:46:01Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -1261,6 +1309,65 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua\n                 TranslateDictionary(ref copy, (NodePacketCollectionCreator<IDictionary<string, string>>)null);\n             }\n \n+            /// <summary>\n+            /// Translates a dictionary of { string, string } adding extra entries.\n+            /// </summary>\n+            /// <param name=\"dictionary\">The dictionary to be translated.</param>\n+            /// <param name=\"comparer\">The comparer used to instantiate the dictionary.</param>\n+            /// <param name=\"additionalEntries\">Additional entries to be translated.</param>\n+            /// <param name=\"additionalEntriesKeys\">Additional entries keys.</param>\n+            public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer, ref Dictionary<string, string> additionalEntries, HashSet<string> additionalEntriesKeys)\n+            {\n+                // Translate whether object is Null\n+                if ((dictionary is null) && ((additionalEntries is null) || (additionalEntries.Count == 0)))\n+                {\n+                    _writer.Write(false);\n+                    return;\n+                }\n+                else\n+                {\n+                    // Translate that object is not null\n+                    _writer.Write(true);\n+                }\n+\n+                // Writing dictionary, extra entries and special key if copy dictionary was null\n+                int count = (dictionary is null ? 0 : dictionary.Count) + (additionalEntries is null ? 0 : additionalEntries.Count) + (dictionary is null ? 1 : 0);\n+                _writer.Write(count);\n+\n+                // If the dictionary was null, add a special key SpecialKeyForDictionaryBeingNull to the dictionary.\n+                if (dictionary is null)\n+                {\n+                    string key = SpecialKeyForDictionaryBeingNull;\n+                    Translate(ref key);\n+                    string value = string.Empty;\n+                    Translate(ref value);\n+                }\n+\n+                if (additionalEntries is not null)\n+                {\n+                    // Translate extra entries\n+                    foreach (KeyValuePair<string, string> pair in additionalEntries)\n+                    {\n+                        string key = pair.Key;\n+                        Translate(ref key);\n+                        string value = pair.Value;\n+                        Translate(ref value);\n+                    }\n+                }\n+\n+                if (dictionary is not null)\n+                {\n+                    // Translate dictionary\n+                    foreach (KeyValuePair<string, string> pair in dictionary)\n+                    {\n+                        string key = pair.Key;\n+                        Translate(ref key);\n+                        string value = pair.Value;\n+                        Translate(ref value);\n+                    }\n+                }",
              "author": {
                "login": "f-alizada"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could you please clarify which scenario is failing during the deserialization of the dictionary?",
              "createdAt": "2024-06-25T07:55:23Z",
              "path": "src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs",
              "diffHunk": "@@ -393,12 +394,49 @@ public void TestResultsCacheTranslation(object obj)\n \n             var copy = new ResultsCache(TranslationHelpers.GetReadTranslator());\n \n-            copy.ResultsDictionary.Keys.ToHashSet().SetEquals(resultsCache.ResultsDictionary.Keys.ToHashSet()).ShouldBeTrue();\n+            CompareResultsCache(resultsCache, copy);\n+        }\n+\n+        [Theory]\n+        [InlineData(1, 1)] // Serialize version 0 and deserialize version 0 \n+        [InlineData(1, 0)] // Serialize version 0 and deserialize latest version\n+        public void TestResultsCacheTranslationAcrossVersions(int envValue1, int envValue2)",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "Currently, without this fix the scenario \"Serialize version 0 and deserialize latest version\" will fail. The cache is produced by older version of VS than consumer VS.",
              "createdAt": "2024-06-25T08:29:55Z",
              "path": "src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs",
              "diffHunk": "@@ -393,12 +394,49 @@ public void TestResultsCacheTranslation(object obj)\n \n             var copy = new ResultsCache(TranslationHelpers.GetReadTranslator());\n \n-            copy.ResultsDictionary.Keys.ToHashSet().SetEquals(resultsCache.ResultsDictionary.Keys.ToHashSet()).ShouldBeTrue();\n+            CompareResultsCache(resultsCache, copy);\n+        }\n+\n+        [Theory]\n+        [InlineData(1, 1)] // Serialize version 0 and deserialize version 0 \n+        [InlineData(1, 0)] // Serialize version 0 and deserialize latest version\n+        public void TestResultsCacheTranslationAcrossVersions(int envValue1, int envValue2)",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Thank you! Could you please provide the example of actually failing when the env variable is not provided? \r\n",
              "createdAt": "2024-06-25T08:47:02Z",
              "path": "src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs",
              "diffHunk": "@@ -393,12 +394,49 @@ public void TestResultsCacheTranslation(object obj)\n \n             var copy = new ResultsCache(TranslationHelpers.GetReadTranslator());\n \n-            copy.ResultsDictionary.Keys.ToHashSet().SetEquals(resultsCache.ResultsDictionary.Keys.ToHashSet()).ShouldBeTrue();\n+            CompareResultsCache(resultsCache, copy);\n+        }\n+\n+        [Theory]\n+        [InlineData(1, 1)] // Serialize version 0 and deserialize version 0 \n+        [InlineData(1, 0)] // Serialize version 0 and deserialize latest version\n+        public void TestResultsCacheTranslationAcrossVersions(int envValue1, int envValue2)",
              "author": {
                "login": "f-alizada"
              }
            },
            {
              "body": "when the environment variable is not provided - it is the previous test and it works. It is case \"serialize latest version and deserialize latest version\". The only case that does not is \"serialize latest version and deserialize version 0\". I have not added a negative test for that, because it is some random serialization error that will appear.",
              "createdAt": "2024-06-25T11:09:49Z",
              "path": "src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs",
              "diffHunk": "@@ -393,12 +394,49 @@ public void TestResultsCacheTranslation(object obj)\n \n             var copy = new ResultsCache(TranslationHelpers.GetReadTranslator());\n \n-            copy.ResultsDictionary.Keys.ToHashSet().SetEquals(resultsCache.ResultsDictionary.Keys.ToHashSet()).ShouldBeTrue();\n+            CompareResultsCache(resultsCache, copy);\n+        }\n+\n+        [Theory]\n+        [InlineData(1, 1)] // Serialize version 0 and deserialize version 0 \n+        [InlineData(1, 0)] // Serialize version 0 and deserialize latest version\n+        public void TestResultsCacheTranslationAcrossVersions(int envValue1, int envValue2)",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It would be nice to specify the workaround if possible.",
              "createdAt": "2024-06-25T12:03:25Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -22,6 +22,14 @@ namespace Microsoft.Build.BackEnd\n     /// </summary>\n     internal static class BinaryTranslator\n     {\n+        /// <summary>\n+        /// Presence of this key in the dictionary indicates that it was null.\n+        /// </summary>\n+        /// <remarks>\n+        /// This is needed for a workaround.",
              "author": {
                "login": "maridematte"
              }
            },
            {
              "body": "Added more information to comments.",
              "createdAt": "2024-06-25T17:24:39Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -22,6 +22,14 @@ namespace Microsoft.Build.BackEnd\n     /// </summary>\n     internal static class BinaryTranslator\n     {\n+        /// <summary>\n+        /// Presence of this key in the dictionary indicates that it was null.\n+        /// </summary>\n+        /// <remarks>\n+        /// This is needed for a workaround.",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Mention main case(s) where it's omitted?",
              "createdAt": "2024-06-26T14:37:26Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -119,6 +136,9 @@ public class BuildResult : INodePacket, IBuildResults\n         /// <summary>\n         /// The flags provide additional control over the build results and may affect the cached value.\n         /// </summary>\n+        /// <remarks>\n+        /// Is optional.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "should this be a `static readonly` to minimize garbage when running through this method?",
              "createdAt": "2024-06-26T14:39:14Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +626,66 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.\n+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\n+            //\n+            // 1st step (done): Add a special key to the _savedEnvironmentVariables dictionary during the serialization. A workaround overload of the TranslateDictionary function is created to achieve it.\n+            // The presence of this key will indicate that the version is serialized next.\n+            // When serializing, add a key to the dictionary and serialize a version field.\n+            // Do not actually save the special key to dictionary during the deserialization, but read a version as a next field if it presents.\n+            //\n+            // 2nd step: Stop serialize a special key with the dictionary _savedEnvironmentVariables using the TranslateDictionary function workaround overload. Always serialize and de-serialize the version field.\n+            // Continue to deserialize _savedEnvironmentVariables with the TranslateDictionary function workaround overload in order not to deserialize dictionary with the special keys.\n+            //\n+            // 3rd step: Stop using the TranslateDictionary function workaround overload during _savedEnvironmentVariables deserialization.\n+            if (_version == 0)\n+            {\n+                // Escape hatch: serialize/deserialize without version field.\n+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+            }\n+            else\n+            {\n+                Dictionary<string, string> additionalEntries = new();\n+                HashSet<string> additionalEntriesKeys = new HashSet<string>\n+                {\n+                    VersionKeyName\n+                };",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Right, thanks!\r\n",
              "createdAt": "2024-06-26T14:50:43Z",
              "path": "src/Build/BackEnd/Shared/BuildResult.cs",
              "diffHunk": "@@ -598,8 +626,66 @@ void ITranslatable.Translate(ITranslator translator)\n             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);\n             translator.Translate(ref _savedCurrentDirectory);\n             translator.Translate(ref _schedulerInducedError);\n-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);\n+\n+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208\n+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.\n+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.\n+            //\n+            // 1st step (done): Add a special key to the _savedEnvironmentVariables dictionary during the serialization. A workaround overload of the TranslateDictionary function is created to achieve it.\n+            // The presence of this key will indicate that the version is serialized next.\n+            // When serializing, add a key to the dictionary and serialize a version field.\n+            // Do not actually save the special key to dictionary during the deserialization, but read a version as a next field if it presents.\n+            //\n+            // 2nd step: Stop serialize a special key with the dictionary _savedEnvironmentVariables using the TranslateDictionary function workaround overload. Always serialize and de-serialize the version field.\n+            // Continue to deserialize _savedEnvironmentVariables with the TranslateDictionary function workaround overload in order not to deserialize dictionary with the special keys.\n+            //\n+            // 3rd step: Stop using the TranslateDictionary function workaround overload during _savedEnvironmentVariables deserialization.\n+            if (_version == 0)\n+            {\n+                // Escape hatch: serialize/deserialize without version field.\n+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);\n+            }\n+            else\n+            {\n+                Dictionary<string, string> additionalEntries = new();\n+                HashSet<string> additionalEntriesKeys = new HashSet<string>\n+                {\n+                    VersionKeyName\n+                };",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      }
    ]
  }
}