{
  "number": 6155,
  "title": "Introduce TaskParameterEventArgs",
  "body": "Instead of just logging a BuildMessageEventArgs with a list of all items and metadata concatenated into a large string (often 5 MB in size or more) it keeps a structured representation of items and metadata. TaskParameterEventArgs inherits from BuildMessageEventArgs and the Message implementation materializes the large string on demand. However when only the BinaryLogger is present the Message is never accessed, thus saving on allocations. The Message is also never sent across the nodes nor written into the binlog.\r\n\r\nTaskParameterEventArgs is instantiated in 5 locations: ItemGroup Include and Remove inside targets, task inputs, and two cases for task outputs.\r\n\r\nStoring smaller strings in the binlog results in very significant savings from string deduplication. A 22 MB binlog goes down to 3.5 MB in size. We're also seeing build speed improvements from 33 seconds to 30 seconds. Significant reduction in memory allocations since we no longer need to allocate the large strings and send them across the nodes.\r\n\r\nThis also shares some extension methods for reading and writing things between the node packet serialization and binary logger. It also shares a new internal type, TaskItemData, used as a holder for deserialized items. The actual ProjectItemInstance.TaskItem is too heavyweight for this.\r\n\r\nBinary logger format version goes all the way to 11. The viewer already supports the new format. An additional benefit is that the viewer no longer has to parse the large text messages to recover structure, it will now be more reliable when reading multi-line properties, items and metadata values.\r\n\r\nI've replayed the binlog produced by this version and diffed with the old binlog and all information appears to be preserved.",
  "state": "MERGED",
  "createdAt": "2021-02-14T02:26:21Z",
  "updatedAt": "2021-03-04T01:49:40Z",
  "closedAt": "2021-03-04T01:49:39Z",
  "mergedAt": "2021-03-04T01:49:39Z",
  "additions": 1371,
  "deletions": 284,
  "changedFiles": 32,
  "headRefName": "dev/kirillo/taskParameterEventArgs",
  "isDraft": false,
  "author": {
    "login": "KirillOsenkov"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "KirillOsenkov"
      }
    ]
  },
  "labels": [
    "Area: Performance",
    "Area: Logging",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "3d9cca367776fde3b8e6fce0be1c3a3337452437",
          "message": "Introduce TaskParameterEventArgs.\n\nInstead of just logging a BuildMessageEventArgs with a list of all items and metadata concatenated into a large string (often 5 MB in size or more) it keeps a structured representation of items and metadata. TaskParameterEventArgs inherits from BuildMessageEventArgs and the Message implementation materializes the large string on demands. However when only the BinaryLogger is present the Message is never accessed, thus saving on allocations.\n\nIt is instantiated in 5 locations: ItemGroup Include and Remove inside targets, task inputs, and two cases for task outputs.\n\nStoring smaller strings in the binlog results in very significant savings from string deduplication. A 22 MB binlog goes down to 3.5 MB in size. We're also seeing build speed improvements from 33 seconds to 30 seconds. Significant reduction in memory allocations since we no longer need to allocate the large strings and send them across the nodes.\n\nThis also shares some extension methods for reading and writing things between the node packet serialization and binary logger. It also shares a new internal type, TaskItemData, used as a holder for deserialized items. The actual ProjectItemInstance.TaskItem is too heavyweight for this.\n\nBinary logger format version goes all the way to 11. The viewer already supports the new format. An additional benefit is that the viewer no longer has to parse the large text messages to recover structure, it will now be more reliable when reading multi-line properties, items and metadata values.",
          "committedDate": "2021-02-26T20:26:25Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ec7542132f2a9792111c4e95cf3a0be6c3db2281",
          "message": "Touch ItemGroupLoggingHelper from LoggingService.\n\nThis is needed to ensure the static constructor runs.",
          "committedDate": "2021-03-01T05:57:31Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f13f0bde7fb66e4003ab91963c30703ae757635a",
          "message": "Rename itemName -> itemType.",
          "committedDate": "2021-03-01T17:40:40Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e1ca2760081f369572ced493af3ea9b714ad98be",
          "message": "Rename to IMetadataContainer.EnumerateMetadata()",
          "committedDate": "2021-03-01T18:00:21Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e12a5eae806f44f53f630721a98aeca168d3258d",
          "message": "Add copyright headers.\n\nRename SmallDictionary -> ArrayDictionary.",
          "committedDate": "2021-03-02T02:29:47Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ffc3113f81d2cecee955ab1631e54bf226402bc1",
          "message": "Code review feedback.",
          "committedDate": "2021-03-02T03:39:51Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Fixes https://github.com/dotnet/msbuild/issues/6007",
        "createdAt": "2021-02-14T02:57:50Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Fixes https://github.com/dotnet/msbuild/issues/5211",
        "createdAt": "2021-02-14T03:00:27Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Fixes https://github.com/dotnet/msbuild/issues/3966",
        "createdAt": "2021-02-14T03:02:34Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Potentially fixes https://github.com/dotnet/msbuild/issues/3577 (at least the hope is to significantly reduce allocations)",
        "createdAt": "2021-02-14T03:05:46Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Potentially fixes https://github.com/dotnet/msbuild/issues/2200",
        "createdAt": "2021-02-14T03:06:46Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Partially fixes https://github.com/dotnet/msbuild/issues/2168",
        "createdAt": "2021-02-14T03:07:55Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I've noticed that the ref api didn't regenerate and discovered that that functionality got disabled accidentally. After this fix merges I'll need to rebase and regenerate the public API: \r\nhttps://github.com/dotnet/msbuild/pull/6157",
        "createdAt": "2021-02-16T03:18:38Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Here are some stats from a binlog produced from this PR and an equivalent binlog from master:\r\n\r\n```\r\nPR #6155:\r\n\r\nStatistics:                   \t\t\tTotal size: 8,858,154\t\t\tCount: 158,861\t\t\tLargest: 29,767\r\n    TaskParameter                 \t\t\tTotal size: 3,453,513\t\t\tCount: 29,379\t\t\tLargest: 27,124\r\n    BuildMessage                  \t\t\tTotal size: 3,183,360\t\t\tCount: 94,828\t\t\tLargest: 53\r\n        Other                         \t\t\tTotal size: 3,114,633\t\t\tCount: 92,461\t\t\tLargest: 53\r\n        Task Input Item               \t\t\tTotal size: 68,727\t\t\tCount: 2,367\t\t\tLargest: 30\r\n    ProjectStarted                \t\t\tTotal size: 686,356\t\t\tCount: 1,953\t\t\tLargest: 29,767\r\n    TargetFinished                \t\t\tTotal size: 401,366\t\t\tCount: 5,214\t\t\tLargest: 2,926\r\n    ProjectImported               \t\t\tTotal size: 367,541\t\t\tCount: 7,616\t\t\tLargest: 53\r\n    TargetSkipped                 \t\t\tTotal size: 327,088\t\t\tCount: 7,970\t\t\tLargest: 44\r\n    TargetStarted                 \t\t\tTotal size: 211,301\t\t\tCount: 5,214\t\t\tLargest: 44\r\n    TaskFinished                  \t\t\tTotal size: 80,053\t\t\tCount: 2,302\t\t\tLargest: 37\r\n    TaskStarted                   \t\t\tTotal size: 77,751\t\t\tCount: 2,302\t\t\tLargest: 36\r\n    ProjectFinished               \t\t\tTotal size: 64,482\t\t\tCount: 1,953\t\t\tLargest: 35\r\n    ProjectEvaluationFinished     \t\t\tTotal size: 1,949\t\t\tCount: 48\t\t\tLargest: 42\r\n    ProjectEvaluationStarted      \t\t\tTotal size: 1,901\t\t\tCount: 48\t\t\tLargest: 41\r\n    BuildWarning                  \t\t\tTotal size: 1,421\t\t\tCount: 31\t\t\tLargest: 47\r\n    TaskCommandLine               \t\t\tTotal size: 42\t\t\tCount: 1\t\t\tLargest: 42\r\n    BuildFinished                 \t\t\tTotal size: 16\t\t\tCount: 1\t\t\tLargest: 16\r\n    BuildStarted                  \t\t\tTotal size: 14\t\t\tCount: 1\t\t\tLargest: 14\r\n    Strings                       \t\t\tTotal size: 7,132,418\t\t\tCount: 34,149\t\t\tLargest: 42,934\r\n    NameValueLists                \t\t\tTotal size: 2,228,938\t\t\tCount: 26,616\t\t\tLargest: 3,283\r\n    Blobs                         \t\t\tTotal size: 431,379\t\t\tCount: 1\t\t\tLargest: 431,379\r\n\r\n\r\nmaster:\r\nStatistics:                   \t\t\tTotal size: 6,348,629\t\t\tCount: 158,861\t\t\tLargest: 30,204\r\n    BuildMessage                  \t\t\tTotal size: 4,120,183\t\t\tCount: 124,207\t\t\tLargest: 53\r\n        Other                         \t\t\tTotal size: 3,131,717\t\t\tCount: 92,896\t\t\tLargest: 53\r\n        Added Item                    \t\t\tTotal size: 779,517\t\t\tCount: 24,266\t\t\tLargest: 33\r\n        Task Input Item               \t\t\tTotal size: 131,294\t\t\tCount: 4,500\t\t\tLargest: 30\r\n        Task Output Item              \t\t\tTotal size: 47,982\t\t\tCount: 1,628\t\t\tLargest: 30\r\n        Removed Item                  \t\t\tTotal size: 29,673\t\t\tCount: 917\t\t\tLargest: 33\r\n    ProjectStarted                \t\t\tTotal size: 692,727\t\t\tCount: 1,953\t\t\tLargest: 30,204\r\n    TargetFinished                \t\t\tTotal size: 401,558\t\t\tCount: 5,214\t\t\tLargest: 2,815\r\n    ProjectImported               \t\t\tTotal size: 367,614\t\t\tCount: 7,616\t\t\tLargest: 53\r\n    TargetSkipped                 \t\t\tTotal size: 327,094\t\t\tCount: 7,970\t\t\tLargest: 44\r\n    TargetStarted                 \t\t\tTotal size: 211,457\t\t\tCount: 5,214\t\t\tLargest: 44\r\n    TaskFinished                  \t\t\tTotal size: 80,053\t\t\tCount: 2,302\t\t\tLargest: 37\r\n    TaskStarted                   \t\t\tTotal size: 77,751\t\t\tCount: 2,302\t\t\tLargest: 36\r\n    ProjectFinished               \t\t\tTotal size: 64,837\t\t\tCount: 1,953\t\t\tLargest: 35\r\n    ProjectEvaluationFinished     \t\t\tTotal size: 1,955\t\t\tCount: 48\t\t\tLargest: 42\r\n    ProjectEvaluationStarted      \t\t\tTotal size: 1,907\t\t\tCount: 48\t\t\tLargest: 41\r\n    BuildWarning                  \t\t\tTotal size: 1,421\t\t\tCount: 31\t\t\tLargest: 47\r\n    TaskCommandLine               \t\t\tTotal size: 42\t\t\tCount: 1\t\t\tLargest: 42\r\n    BuildFinished                 \t\t\tTotal size: 16\t\t\tCount: 1\t\t\tLargest: 16\r\n    BuildStarted                  \t\t\tTotal size: 14\t\t\tCount: 1\t\t\tLargest: 14\r\n    Strings                       \t\t\tTotal size: 334,527,525\t\t\tCount: 38,934\t\t\tLargest: 8,591,869\r\n    NameValueLists                \t\t\tTotal size: 467,005\t\t\tCount: 5,416\t\t\tLargest: 3,291\r\n    Blobs                         \t\t\tTotal size: 431,572\t\t\tCount: 1\t\t\tLargest: 431,572\r\n```\r\n\r\nNote how we have 34,149 strings totalling 7 MB, and master has 38,934 strings totalling 334 MB. Turns out if you crumble those extra ~4,800 strings down they basically disappear.\r\n\r\nBinlog size here goes from 11.6 MB to 3.6 MB. An equivalent binlog from 16.8 (no dedup at all) is ~22 MB.\r\n\r\nUncompressed stream inside the binlog goes from 341 MB to 18 MB.\r\n\r\nAlso note how the largest string goes from 8.6 MB to 43 KB. This completely avoids the Large Object Heap at 85 KB threshold.",
        "createdAt": "2021-02-16T06:23:38Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I tried to make a histogram of string sizes before and after, but it's not visible very well (maybe I should do logarithmic?)\r\nBefore:\r\n![image](https://user-images.githubusercontent.com/679326/108033253-92beb680-6fe8-11eb-9a15-66c0d70c96ce.png)\r\n\r\nAfter:\r\n![image](https://user-images.githubusercontent.com/679326/108033278-9c481e80-6fe8-11eb-885b-4f1c9f92a26f.png)\r\n",
        "createdAt": "2021-02-16T07:50:51Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Unfortunately I'm seeing both perf and allocations when deserializing packets in the main node:\r\n![image](https://user-images.githubusercontent.com/679326/108155106-22b93a80-7093-11eb-82fe-61392efe8a64.png)\r\n\r\nWe now get tons of small strings instead of one giant string for task parameter and we're interning each one and it shows. I'll need to think if I have any ideas here. ",
        "createdAt": "2021-02-17T04:12:34Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Oh, duh, I was profiling debug \ud83e\udd26 \r\n\r\n![image](https://user-images.githubusercontent.com/679326/108156091-e38be900-7094-11eb-9ce2-6816af737e90.png)\r\n\r\nNEVER MIND.",
        "createdAt": "2021-02-17T04:23:57Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I got some more perf numbers.\r\n\r\n`/m /bl` is 22s on 16.8 and master, and 18-19s with this PR\r\n`/bl` is 41s on 16.8, 32s on master and 27s with this PR\r\n\r\nThis PR appears to be slower than 16.8 for /m and no log:\r\n12s on 16.8, 13s on master and 14s this PR. I'm not sure how to explain or confirm this yet. This PR shouldn't affect non-binlog builds. Multi-proc builds generally have higher variance so I'm not worried about it too much.\r\n\r\n/m /bl | 16.8 | master | 4547f7309 | SmallDictionary\r\n-- | -- | -- | -- | --\r\n\u00a0 | 22.624 | 22.961 | 21.198 | 19.227\r\n\u00a0 | 22.503 | 22.497 | 19.676 | 18.518\r\n\u00a0 | 22.624 | 22.975 | 18.69 | 19.348\r\n\u00a0 | 22.938 | 20.303 | 18.079 | 20.938\r\n\u00a0 | 22.633 | 20.479 | 18.284 | 18.646\r\n\u00a0 | \u00a0 | \u00a0 | \u00a0 | \u00a0\r\n/bl | 40.213 | 33.56 | \u00a0 | 30.977\r\n\u00a0 | 42.092 | 31.87 | \u00a0 | 27.332\r\n\u00a0 | 42.475 | 31.888 | \u00a0 | 28.057\r\n\u00a0 | 41.307 | 32.533 | \u00a0 | 26.813\r\n\u00a0 | 40.923 | 32.634 | \u00a0 | 27.081\r\n\u00a0 | \u00a0 | \u00a0 | \u00a0 | \u00a0\r\nno log no /m | 20.251 | 19.627 | \u00a0 | 21.761\r\n\u00a0 | 19.741 | 21.286 | \u00a0 | 19.75\r\n\u00a0 | 19.357 | 19.81 | \u00a0 | 19.774\r\n\u00a0 | \u00a0 | \u00a0 | \u00a0 | \u00a0\r\nno log /m | 14.071 | 13.931 | \u00a0 | 15.038\r\n\u00a0 | 12.292 | 13.718 | \u00a0 | 14.481\r\n\u00a0 | 13.162 | 13.517 | \u00a0 | 14.167\r\n\u00a0 | 11.929 | 13.782 | \u00a0 | 14.193\r\n\u00a0 | 12.5 | 13.583 | \u00a0 | 14.042\r\n\r\n",
        "createdAt": "2021-02-17T07:01:50Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I'm seeing very favorable allocations picture with this PR.\r\n\r\nmaster branch:\r\n![image](https://user-images.githubusercontent.com/679326/108473473-ed534f00-7242-11eb-9bf3-72055f527dce.png)\r\n\r\nthis PR:\r\n![image](https://user-images.githubusercontent.com/679326/108473577-0d830e00-7243-11eb-9358-80466dac38fd.png)\r\n\r\nLOH allocations are significantly reduced:\r\nmaster branch:\r\n![image](https://user-images.githubusercontent.com/679326/108473809-5fc42f00-7243-11eb-9281-aaf447e9884e.png)\r\n\r\nthis PR:\r\n![image](https://user-images.githubusercontent.com/679326/108473771-520ea980-7243-11eb-9b44-186b8c64845e.png)\r\n",
        "createdAt": "2021-02-19T07:45:35Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@KirillOsenkov If you compare against the msbuild binaries shipping with VS, those are also ngened and use profile guided optimizations. Best to compare against your own built msbuild from the [16.8 branch](https://github.com/dotnet/msbuild/tree/vs16.8)",
        "createdAt": "2021-02-19T22:10:30Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "@KirillOsenkov regarding the newly added ton of small string allocations for all the items and their metadata, how about not deserializing `TaskParameterEventArgs.Items` and only lazily deserialize it when somebody asks for it?",
        "createdAt": "2021-02-20T01:11:08Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "That would hold on to a byte[] and I guess when LogTaskInputs is set and this whole machinery runs, we're guaranteed to consume every event via a logger. So might as well read it eagerly, plus most strings will be interned by InterningBinaryReader.",
        "createdAt": "2021-02-20T01:32:11Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Some decent perf improvements from the last 5 commits:\r\n\r\n\u00a0 | 16.8.5 | PR | fix\r\n-- | -- | -- | --\r\n/m /bl | \u00a0 | 15.51 | 12.467\r\n\u00a0 | \u00a0 | 14.75 | 13.257\r\n\u00a0 | \u00a0 | 13.522 | 13.004\r\n\u00a0 | \u00a0 | 13.262 | 13.42\r\n\u00a0 | \u00a0 | 13.206 | 14.031\r\n\u00a0 | \u00a0 | 13.226 | 12.63\r\n/bl | \u00a0 | \u00a0 | \u00a0\r\n\u00a0 | 32.192 | 22.458 | 20.772\r\n\u00a0 | 32.015 | 20.955 | 20.253\r\n\u00a0 | 31.873 | 20.898 | 20.156\r\n\u00a0 | \u00a0 | 21.177 | 20.061\r\n\u00a0 | \u00a0 | 21.121 | 19.993\r\n\r\n",
        "createdAt": "2021-02-20T06:15:45Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "There are a few oustanding questions with this PR that I'd like to resolve, and I'll respond separately when it's ready for proper review. It's getting closer though. Just need to decide whether it's worth the risk of exposing a couple internals for raw speed.",
        "createdAt": "2021-02-20T06:17:24Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Latest allocations:\r\n\r\nA few commits back:\r\n![image](https://user-images.githubusercontent.com/679326/108473577-0d830e00-7243-11eb-9358-80466dac38fd.png)\r\n\r\nLatest:\r\n![image](https://user-images.githubusercontent.com/679326/108609864-c2bddf00-7385-11eb-8069-6b32d0fe1b7d.png)\r\n\r\nA few commits back:\r\n![image](https://user-images.githubusercontent.com/679326/108473771-520ea980-7243-11eb-9b44-186b8c64845e.png)\r\n\r\nLatest:\r\n![image](https://user-images.githubusercontent.com/679326/108609831-7ecada00-7385-11eb-9e92-a45c95bc18f0.png)\r\n",
        "createdAt": "2021-02-20T22:13:54Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "You can see `Dictionary<K,V>` disappeared and `SmallDictionary` is just two `string[]` arrays.\r\n\r\nWe also see reduced copies of items during enumeration since we now bypass the enumerator Proxy that DeepClones items.\r\n\r\n`byte[]` have reduced, but I can't remember which optimization did this.\r\n\r\nI apologize for measuring 16.8 again, but please indulge me, it brings me great joy: ;) This is 16.8.5:\r\n\r\n![image](https://user-images.githubusercontent.com/679326/108610041-40361f00-7387-11eb-869b-ba0de516f8b6.png)\r\n\r\n![image](https://user-images.githubusercontent.com/679326/108610029-27c60480-7387-11eb-9642-0ba9db90bbb4.png)\r\n\r\nCheck that LOH",
        "createdAt": "2021-02-20T22:24:01Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "This should now be ready for review.",
        "createdAt": "2021-02-26T20:41:44Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I'm starting to have concerns about how node packet serialization works in this PR. The whole problem starts because we want to shoehorn the implementation of serialization into the declarations assembly (MS.B.Framework).\r\n\r\nI think it might be cleaner if we move the serialization out to Microsoft.Build. This way SmallDictionary, TaskItemData and potentially even IMetadataContainer can move out to Microsoft.Build as well. There won't be a need for static constructors then.",
        "createdAt": "2021-03-01T05:34:33Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Nah, I've just tried and it won't solve the Message problem.",
        "createdAt": "2021-03-01T06:17:33Z",
        "author": {
          "login": "KirillOsenkov"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "An alternative to the static state would be a factory class that gets the message getter and the dictionary factory.",
              "createdAt": "2021-02-20T00:45:29Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemName,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemName = itemName;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemName { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I wouldn't necessarily want to introduce an entity unnecessarily. But it might be warranted here as it encapsulates logic and adding more in the future might be cleaner if it's wrapped in an abstraction. On the other hand nothing really wrong with the current approach. \r\n\r\nThe real problem you have correctly pointed out is the need to make sure these are always initialized. I tried passing these explicitly but quickly ran into a problem of public vs. internal API and IVT. Feels like the Framework should be clean and \"closed\" in terms of API... I'll need to think more about this.",
              "createdAt": "2021-02-20T06:12:00Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemName,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemName = itemName;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemName { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: inconsistency between itemName and itemType in the calling method above. Personally I prefer itemType since it seems to better distinguish from itemSpec",
              "createdAt": "2021-02-20T00:50:30Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -203,5 +216,56 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob\n                 ErrorUtilities.ThrowInternalErrorUnreachable();\n             }\n         }\n+\n+        internal static void LogTaskParameter(\n+            LoggingContext loggingContext,\n+            TaskParameterMessageKind messageKind,\n+            string itemType,\n+            IList items,\n+            bool logItemMetadata)\n+        {\n+            var args = CreateTaskParameterEventArgs(loggingContext.BuildEventContext, messageKind, itemType, items, logItemMetadata, DateTime.UtcNow);\n+            loggingContext.LogBuildEvent(args);\n+        }\n+\n+        internal static TaskParameterEventArgs CreateTaskParameterEventArgs(\n+            BuildEventContext buildEventContext,\n+            TaskParameterMessageKind messageKind,\n+            string itemName,",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "itemType feels like it's something about the type of the item, like \"value type\" or \"string\" or \"ITaskItem\". itemName is less ambiguous so I'll unify on itemName.",
              "createdAt": "2021-02-20T06:07:00Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -203,5 +216,56 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob\n                 ErrorUtilities.ThrowInternalErrorUnreachable();\n             }\n         }\n+\n+        internal static void LogTaskParameter(\n+            LoggingContext loggingContext,\n+            TaskParameterMessageKind messageKind,\n+            string itemType,\n+            IList items,\n+            bool logItemMetadata)\n+        {\n+            var args = CreateTaskParameterEventArgs(loggingContext.BuildEventContext, messageKind, itemType, items, logItemMetadata, DateTime.UtcNow);\n+            loggingContext.LogBuildEvent(args);\n+        }\n+\n+        internal static TaskParameterEventArgs CreateTaskParameterEventArgs(\n+            BuildEventContext buildEventContext,\n+            TaskParameterMessageKind messageKind,\n+            string itemName,",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "actually @cdmihai you are right, from reading the code it looks like the canonical term for this is `ItemType` as seen here https://source.dot.net/#Microsoft.Build/Instance/ProjectItemInstance.cs,af383bff89575c65.\r\n\r\nShould I go and rename itemName to itemType everywhere?",
              "createdAt": "2021-02-27T05:55:36Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -203,5 +216,56 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob\n                 ErrorUtilities.ThrowInternalErrorUnreachable();\n             }\n         }\n+\n+        internal static void LogTaskParameter(\n+            LoggingContext loggingContext,\n+            TaskParameterMessageKind messageKind,\n+            string itemType,\n+            IList items,\n+            bool logItemMetadata)\n+        {\n+            var args = CreateTaskParameterEventArgs(loggingContext.BuildEventContext, messageKind, itemType, items, logItemMetadata, DateTime.UtcNow);\n+            loggingContext.LogBuildEvent(args);\n+        }\n+\n+        internal static TaskParameterEventArgs CreateTaskParameterEventArgs(\n+            BuildEventContext buildEventContext,\n+            TaskParameterMessageKind messageKind,\n+            string itemName,",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "It would probably settle it once and for all. Unless there exists another public API that uses 'ItemName` :)",
              "createdAt": "2021-03-01T16:07:58Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -203,5 +216,56 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob\n                 ErrorUtilities.ThrowInternalErrorUnreachable();\n             }\n         }\n+\n+        internal static void LogTaskParameter(\n+            LoggingContext loggingContext,\n+            TaskParameterMessageKind messageKind,\n+            string itemType,\n+            IList items,\n+            bool logItemMetadata)\n+        {\n+            var args = CreateTaskParameterEventArgs(loggingContext.BuildEventContext, messageKind, itemType, items, logItemMetadata, DateTime.UtcNow);\n+            loggingContext.LogBuildEvent(args);\n+        }\n+\n+        internal static TaskParameterEventArgs CreateTaskParameterEventArgs(\n+            BuildEventContext buildEventContext,\n+            TaskParameterMessageKind messageKind,\n+            string itemName,",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a way in which this will cause null pointer exceptions or the breaking change where API users got the message before whereas now they'll get null? Some scenarios I'm thinking about:\r\n- Is there a way to log this event without having the static fields initialized? Like a project without any actual tasks, just target itemgroups.\r\n- If other API users replay the binlog, they won't be able to rebuild the message since there's no TaskExecutionHost to init the statics.",
              "createdAt": "2021-02-20T01:01:21Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemName,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemName = itemName;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemName { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.\n+        /// </summary>\n+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args => null;",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "This is a very good point and I'll need to think about ways to ensure these are initialized reliably. I had to touch the type manually from a unit-test and I didn't like it.",
              "createdAt": "2021-02-20T06:08:52Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemName,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemName = itemName;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemName { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.\n+        /// </summary>\n+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args => null;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "So, the logging part is easy. To log a TaskParameterEventArgs you have to go through ItemGroupLoggingHelper. Item group add/remove also goes through it.",
              "createdAt": "2021-02-21T02:04:45Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemName,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemName = itemName;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemName { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.\n+        /// </summary>\n+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args => null;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I came up with nothing better than calling the static ctor from BinaryLogReplayEventArgs :) It's a little smelly but does the job.",
              "createdAt": "2021-02-21T02:37:30Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemName,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemName = itemName;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemName { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.\n+        /// </summary>\n+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args => null;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "worth sanity checking the types and throwing when it's not a string or ValueType?",
              "createdAt": "2021-02-20T01:08:35Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemName,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemName = itemName;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemName { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.\n+        /// </summary>\n+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args => null;\n+\n+        internal static Func<int, IDictionary<string, string>> DictionaryFactory = capacity => new Dictionary<string, string>(capacity);\n+\n+        internal override void CreateFromStream(BinaryReader reader, int version)\n+        {\n+            RawTimestamp = reader.ReadTimestamp();\n+            BuildEventContext = reader.ReadOptionalBuildEventContext();\n+            Kind = (TaskParameterMessageKind)reader.Read7BitEncodedInt();\n+            ItemName = reader.ReadString();\n+            Items = ReadItems(reader);\n+        }\n+\n+        private IList ReadItems(BinaryReader reader)\n+        {\n+            var list = new ArrayList();\n+\n+            int count = reader.Read7BitEncodedInt();\n+            for (int i = 0; i < count; i++)\n+            {\n+                var item = ReadItem(reader);\n+                list.Add(item);\n+            }\n+\n+            return list;\n+        }\n+\n+        private object ReadItem(BinaryReader reader)\n+        {\n+            string itemSpec = reader.ReadString();\n+            int metadataCount = reader.Read7BitEncodedInt();\n+            if (metadataCount == 0)\n+            {\n+                return new TaskItemData(itemSpec, metadata: null);\n+            }\n+\n+            var metadata = DictionaryFactory(metadataCount);\n+            for (int i = 0; i < metadataCount; i++)\n+            {\n+                string key = reader.ReadString();\n+                string value = reader.ReadString();\n+                if (key != null)\n+                {\n+                    metadata[key] = value;\n+                }\n+            }\n+\n+            var taskItem = new TaskItemData(itemSpec, metadata);\n+            return taskItem;\n+        }\n+\n+        internal override void WriteToStream(BinaryWriter writer)\n+        {\n+            writer.WriteTimestamp(RawTimestamp);\n+            writer.WriteOptionalBuildEventContext(BuildEventContext);\n+            writer.Write7BitEncodedInt((int)Kind);\n+            writer.Write(ItemName);\n+            WriteItems(writer, Items);\n+        }\n+\n+        private void WriteItems(BinaryWriter writer, IList items)\n+        {\n+            if (items == null)\n+            {\n+                writer.Write7BitEncodedInt(0);\n+                return;\n+            }\n+\n+            int count = items.Count;\n+            writer.Write7BitEncodedInt(count);\n+\n+            for (int i = 0; i < count; i++)\n+            {\n+                var item = items[i];\n+                WriteItem(writer, item);\n+            }\n+        }\n+\n+        private void WriteItem(BinaryWriter writer, object item)\n+        {\n+            if (item is ITaskItem taskItem)\n+            {\n+                writer.Write(taskItem.ItemSpec);\n+                if (LogItemMetadata)\n+                {\n+                    WriteMetadata(writer, taskItem.CloneCustomMetadata());\n+                }\n+                else\n+                {\n+                    writer.Write7BitEncodedInt(0);\n+                }\n+            }\n+            else // string or ValueType",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Perf. As long as it's not null we'll just call ToString() and it's good enough for our purposes here.",
              "createdAt": "2021-02-20T01:30:32Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemName,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemName = itemName;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemName { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.\n+        /// </summary>\n+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args => null;\n+\n+        internal static Func<int, IDictionary<string, string>> DictionaryFactory = capacity => new Dictionary<string, string>(capacity);\n+\n+        internal override void CreateFromStream(BinaryReader reader, int version)\n+        {\n+            RawTimestamp = reader.ReadTimestamp();\n+            BuildEventContext = reader.ReadOptionalBuildEventContext();\n+            Kind = (TaskParameterMessageKind)reader.Read7BitEncodedInt();\n+            ItemName = reader.ReadString();\n+            Items = ReadItems(reader);\n+        }\n+\n+        private IList ReadItems(BinaryReader reader)\n+        {\n+            var list = new ArrayList();\n+\n+            int count = reader.Read7BitEncodedInt();\n+            for (int i = 0; i < count; i++)\n+            {\n+                var item = ReadItem(reader);\n+                list.Add(item);\n+            }\n+\n+            return list;\n+        }\n+\n+        private object ReadItem(BinaryReader reader)\n+        {\n+            string itemSpec = reader.ReadString();\n+            int metadataCount = reader.Read7BitEncodedInt();\n+            if (metadataCount == 0)\n+            {\n+                return new TaskItemData(itemSpec, metadata: null);\n+            }\n+\n+            var metadata = DictionaryFactory(metadataCount);\n+            for (int i = 0; i < metadataCount; i++)\n+            {\n+                string key = reader.ReadString();\n+                string value = reader.ReadString();\n+                if (key != null)\n+                {\n+                    metadata[key] = value;\n+                }\n+            }\n+\n+            var taskItem = new TaskItemData(itemSpec, metadata);\n+            return taskItem;\n+        }\n+\n+        internal override void WriteToStream(BinaryWriter writer)\n+        {\n+            writer.WriteTimestamp(RawTimestamp);\n+            writer.WriteOptionalBuildEventContext(BuildEventContext);\n+            writer.Write7BitEncodedInt((int)Kind);\n+            writer.Write(ItemName);\n+            WriteItems(writer, Items);\n+        }\n+\n+        private void WriteItems(BinaryWriter writer, IList items)\n+        {\n+            if (items == null)\n+            {\n+                writer.Write7BitEncodedInt(0);\n+                return;\n+            }\n+\n+            int count = items.Count;\n+            writer.Write7BitEncodedInt(count);\n+\n+            for (int i = 0; i < count; i++)\n+            {\n+                var item = items[i];\n+                WriteItem(writer, item);\n+            }\n+        }\n+\n+        private void WriteItem(BinaryWriter writer, object item)\n+        {\n+            if (item is ITaskItem taskItem)\n+            {\n+                writer.Write(taskItem.ItemSpec);\n+                if (LogItemMetadata)\n+                {\n+                    WriteMetadata(writer, taskItem.CloneCustomMetadata());\n+                }\n+                else\n+                {\n+                    writer.Write7BitEncodedInt(0);\n+                }\n+            }\n+            else // string or ValueType",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Naming nit: There's an existing [IItem<IMetadatum>.Metadata](https://github.com/dotnet/msbuild/blob/6819f7ab06c3f43e83ff4059d417395e0af06c01/src/Build/Evaluation/Conditionals/IItem.cs#L30). ProjectItem and ProjectItemInstance both implement it, so by having them implement IMetadataContainer as well they'll end up with two members called `Metadata`, which sounds confusing. Suggestions for the IMetadataContainer member name: `MetadataValues` `RawMetadata`",
              "createdAt": "2021-02-28T22:52:13Z",
              "path": "src/Framework/IMetadataContainer.cs",
              "diffHunk": "@@ -0,0 +1,22 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Provides a way to efficiently enumerate item metadata\n+    /// </summary>\n+    internal interface IMetadataContainer\n+    {\n+        /// <summary>\n+        /// Returns a list of metadata names and unescaped values, including\n+        /// metadata from item definition groups, but not including built-in\n+        /// metadata. Implementations should be low-overhead as the method\n+        /// is used for serialization (in node packet translator) as well as\n+        /// in the binary logger.\n+        /// </summary>\n+        IEnumerable<KeyValuePair<string, string>> Metadata { get; }",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Yes, I had to implement Metadata explicitly on ProjectItemInstance. I think when ProjectItem gets the implementation we can think about renaming. Also it's possible we'll need to rename anyway when Rainer gets back ;)\r\n\r\nHaving some doubts about MetadataValues (what about names?). RawMetadata on the interface looks a little bit like the interface is a hack to add stuff around something else (and it kind of is...)\r\n\r\nWe could name it CustomMetadata though. Or convert to a method EnumerateMetadata() or GetCustomMetadata().\r\n\r\nLet's see what others think.",
              "createdAt": "2021-03-01T05:32:33Z",
              "path": "src/Framework/IMetadataContainer.cs",
              "diffHunk": "@@ -0,0 +1,22 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Provides a way to efficiently enumerate item metadata\n+    /// </summary>\n+    internal interface IMetadataContainer\n+    {\n+        /// <summary>\n+        /// Returns a list of metadata names and unescaped values, including\n+        /// metadata from item definition groups, but not including built-in\n+        /// metadata. Implementations should be low-overhead as the method\n+        /// is used for serialization (in node packet translator) as well as\n+        /// in the binary logger.\n+        /// </summary>\n+        IEnumerable<KeyValuePair<string, string>> Metadata { get; }",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I like `EnumerateMetadata`. CustomMetadata might throw the user off thinking there's another type of metadata besides direct, item definition, and built-in.",
              "createdAt": "2021-03-01T16:58:52Z",
              "path": "src/Framework/IMetadataContainer.cs",
              "diffHunk": "@@ -0,0 +1,22 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Provides a way to efficiently enumerate item metadata\n+    /// </summary>\n+    internal interface IMetadataContainer\n+    {\n+        /// <summary>\n+        /// Returns a list of metadata names and unescaped values, including\n+        /// metadata from item definition groups, but not including built-in\n+        /// metadata. Implementations should be low-overhead as the method\n+        /// is used for serialization (in node packet translator) as well as\n+        /// in the binary logger.\n+        /// </summary>\n+        IEnumerable<KeyValuePair<string, string>> Metadata { get; }",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "For consistency's sake, worth making `ProjectItem` implement `IMetadataContainer` as well? I bet CPS will appreciate the zero allocation member.",
              "createdAt": "2021-02-28T22:54:21Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -28,7 +28,13 @@ namespace Microsoft.Build.Execution\n     /// and evaluation has already been performed, so it is unnecessary bulk.\n     /// </remarks>\n     [DebuggerDisplay(\"{ItemType}={EvaluatedInclude} #DirectMetadata={DirectMetadataCount})\")]\n-    public class ProjectItemInstance : IItem<ProjectMetadataInstance>, ITaskItem2, IMetadataTable, ITranslatable, IDeepCloneable<ProjectItemInstance>\n+    public class ProjectItemInstance :",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "This opens a whole 'nother can of worms :) I started on this but quickly ran into viral things such as ProjectItemLink etc. I think this should be a separate PR ideally driven by an actual scenario that we can test and tune.",
              "createdAt": "2021-03-01T05:25:54Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -28,7 +28,13 @@ namespace Microsoft.Build.Execution\n     /// and evaluation has already been performed, so it is unnecessary bulk.\n     /// </remarks>\n     [DebuggerDisplay(\"{ItemType}={EvaluatedInclude} #DirectMetadata={DirectMetadataCount})\")]\n-    public class ProjectItemInstance : IItem<ProjectMetadataInstance>, ITaskItem2, IMetadataTable, ITranslatable, IDeepCloneable<ProjectItemInstance>\n+    public class ProjectItemInstance :",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would the static constructor get called if somebody does a build with the inproc node turned off, with no binlogger, but using custom loggers that handle the new TaskParameterEventArgs? Or would they end up with the generic implementation. I wonder if it's worth touching the static constructor from the BuildManager as well to cover all possible cases (in addition to this place, not instead of).",
              "createdAt": "2021-02-28T23:00:27Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs",
              "diffHunk": "@@ -14,6 +15,14 @@ namespace Microsoft.Build.Logging\n     /// <remarks>The class is public so that we can call it from MSBuild.exe when replaying a log file.</remarks>\n     public sealed class BinaryLogReplayEventSource : EventArgsDispatcher\n     {\n+        /// Touches the <see cref=\"ItemGroupLoggingHelper\"/> static constructor\n+        /// to ensure it initializes <see cref=\"TaskParameterEventArgs.MessageGetter\"/>\n+        /// and <see cref=\"TaskParameterEventArgs.DictionaryFactory\"/>\n+        static BinaryLogReplayEventSource()\n+        {\n+            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Devious scenario, very clever ;) I decided to touch the static constructor from LoggingService, which will likely achieve the same effect. If this is still not enough, then those exotic loggers are responsible for doing it themselves ;)",
              "createdAt": "2021-03-01T05:59:06Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs",
              "diffHunk": "@@ -14,6 +15,14 @@ namespace Microsoft.Build.Logging\n     /// <remarks>The class is public so that we can call it from MSBuild.exe when replaying a log file.</remarks>\n     public sealed class BinaryLogReplayEventSource : EventArgsDispatcher\n     {\n+        /// Touches the <see cref=\"ItemGroupLoggingHelper\"/> static constructor\n+        /// to ensure it initializes <see cref=\"TaskParameterEventArgs.MessageGetter\"/>\n+        /// and <see cref=\"TaskParameterEventArgs.DictionaryFactory\"/>\n+        static BinaryLogReplayEventSource()\n+        {\n+            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If this is going into a log, should it be DateTime.Now?",
              "createdAt": "2021-03-01T22:18:52Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -203,5 +216,62 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob\n                 ErrorUtilities.ThrowInternalErrorUnreachable();\n             }\n         }\n+\n+        internal static void LogTaskParameter(\n+            LoggingContext loggingContext,\n+            TaskParameterMessageKind messageKind,\n+            string itemType,\n+            IList items,\n+            bool logItemMetadata)\n+        {\n+            var args = CreateTaskParameterEventArgs(\n+                loggingContext.BuildEventContext,\n+                messageKind,\n+                itemType,\n+                items,\n+                logItemMetadata,\n+                DateTime.UtcNow);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I checked and the existing code uses UtcNow everywhere: https://github.com/dotnet/msbuild/blob/6819f7ab06c3f43e83ff4059d417395e0af06c01/src/Framework/BuildEventArgs.cs#L62",
              "createdAt": "2021-03-02T02:24:43Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -203,5 +216,62 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob\n                 ErrorUtilities.ThrowInternalErrorUnreachable();\n             }\n         }\n+\n+        internal static void LogTaskParameter(\n+            LoggingContext loggingContext,\n+            TaskParameterMessageKind messageKind,\n+            string itemType,\n+            IList items,\n+            bool logItemMetadata)\n+        {\n+            var args = CreateTaskParameterEventArgs(\n+                loggingContext.BuildEventContext,\n+                messageKind,\n+                itemType,\n+                items,\n+                logItemMetadata,\n+                DateTime.UtcNow);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: maybe inline this as outputs.Any(e => e != null)?",
              "createdAt": "2021-03-01T22:21:42Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -1426,11 +1426,16 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN\n             {\n                 if (outputTargetIsItem)\n                 {\n+                    // Only count non-null elements. We sometimes have a single-element array where the element is null\n+                    bool hasElements = false;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "No, this is very perf sensitive, and this tries very hard to enumerate only once and not allocate enumerators unless necessary.",
              "createdAt": "2021-03-02T00:38:34Z",
              "path": "src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs",
              "diffHunk": "@@ -1426,11 +1426,16 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN\n             {\n                 if (outputTargetIsItem)\n                 {\n+                    // Only count non-null elements. We sometimes have a single-element array where the element is null\n+                    bool hasElements = false;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "copyright header",
              "createdAt": "2021-03-01T22:22:22Z",
              "path": "src/Build/Collections/SmallDictionary.cs",
              "diffHunk": "@@ -0,0 +1,257 @@\n+using System;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "tiny nit:\r\n```suggestion\r\n                count++;\r\n```",
              "createdAt": "2021-03-01T22:25:01Z",
              "path": "src/Build/Collections/SmallDictionary.cs",
              "diffHunk": "@@ -0,0 +1,257 @@\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Collections\n+{\n+    /// <summary>\n+    /// Small, lightweight, read-only IDictionary implementation using two arrays\n+    /// and O(n) lookup. Requires specifying capacity at construction and does not\n+    /// support reallocation to increase capacity.\n+    /// </summary>\n+    /// <typeparam name=\"TKey\">Type of keys</typeparam>\n+    /// <typeparam name=\"TValue\">Type of values</typeparam>\n+    internal class SmallDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary\n+    {\n+        private TKey[] keys;\n+        private TValue[] values;\n+\n+        private int count;\n+\n+        public SmallDictionary(int capacity)\n+        {\n+            keys = new TKey[capacity];\n+            values = new TValue[capacity];\n+        }\n+\n+        public static IDictionary<TKey, TValue> Create(int capacity)\n+        {\n+            return new SmallDictionary<TKey, TValue>(capacity);\n+        }\n+\n+        public TValue this[TKey key]\n+        {\n+            get\n+            {\n+                TryGetValue(key, out var value);\n+                return value;\n+            }\n+\n+            set\n+            {\n+                var comparer = KeyComparer;\n+                for (int i = 0; i < count; i++)\n+                {\n+                    if (comparer.Equals(key, keys[i]))\n+                    {\n+                        values[i] = value;\n+                        return;\n+                    }\n+                }\n+\n+                Add(key, value);\n+            }\n+        }\n+\n+        object IDictionary.this[object key]\n+        {\n+            get => this[(TKey)key];\n+            set => this[(TKey)key] = (TValue)value;\n+        }\n+\n+        public ICollection<TKey> Keys => keys;\n+\n+        ICollection IDictionary.Keys => keys;\n+\n+        public ICollection<TValue> Values => values;\n+\n+        ICollection IDictionary.Values => values;\n+\n+        private IEqualityComparer<TKey> KeyComparer => EqualityComparer<TKey>.Default;\n+\n+        private IEqualityComparer<TValue> ValueComparer => EqualityComparer<TValue>.Default;\n+\n+        public int Count => count;\n+\n+        public bool IsReadOnly => true;\n+\n+        bool IDictionary.IsFixedSize => true;\n+\n+        object ICollection.SyncRoot => this;\n+\n+        bool ICollection.IsSynchronized => false;\n+\n+        public void Add(TKey key, TValue value)\n+        {\n+            if (count < keys.Length)\n+            {\n+                keys[count] = key;\n+                values[count] = value;\n+                count += 1;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I thought Rainer and I agreed that we prefer += 1 stylistically ;)",
              "createdAt": "2021-03-02T00:39:32Z",
              "path": "src/Build/Collections/SmallDictionary.cs",
              "diffHunk": "@@ -0,0 +1,257 @@\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Collections\n+{\n+    /// <summary>\n+    /// Small, lightweight, read-only IDictionary implementation using two arrays\n+    /// and O(n) lookup. Requires specifying capacity at construction and does not\n+    /// support reallocation to increase capacity.\n+    /// </summary>\n+    /// <typeparam name=\"TKey\">Type of keys</typeparam>\n+    /// <typeparam name=\"TValue\">Type of values</typeparam>\n+    internal class SmallDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary\n+    {\n+        private TKey[] keys;\n+        private TValue[] values;\n+\n+        private int count;\n+\n+        public SmallDictionary(int capacity)\n+        {\n+            keys = new TKey[capacity];\n+            values = new TValue[capacity];\n+        }\n+\n+        public static IDictionary<TKey, TValue> Create(int capacity)\n+        {\n+            return new SmallDictionary<TKey, TValue>(capacity);\n+        }\n+\n+        public TValue this[TKey key]\n+        {\n+            get\n+            {\n+                TryGetValue(key, out var value);\n+                return value;\n+            }\n+\n+            set\n+            {\n+                var comparer = KeyComparer;\n+                for (int i = 0; i < count; i++)\n+                {\n+                    if (comparer.Equals(key, keys[i]))\n+                    {\n+                        values[i] = value;\n+                        return;\n+                    }\n+                }\n+\n+                Add(key, value);\n+            }\n+        }\n+\n+        object IDictionary.this[object key]\n+        {\n+            get => this[(TKey)key];\n+            set => this[(TKey)key] = (TValue)value;\n+        }\n+\n+        public ICollection<TKey> Keys => keys;\n+\n+        ICollection IDictionary.Keys => keys;\n+\n+        public ICollection<TValue> Values => values;\n+\n+        ICollection IDictionary.Values => values;\n+\n+        private IEqualityComparer<TKey> KeyComparer => EqualityComparer<TKey>.Default;\n+\n+        private IEqualityComparer<TValue> ValueComparer => EqualityComparer<TValue>.Default;\n+\n+        public int Count => count;\n+\n+        public bool IsReadOnly => true;\n+\n+        bool IDictionary.IsFixedSize => true;\n+\n+        object ICollection.SyncRoot => this;\n+\n+        bool ICollection.IsSynchronized => false;\n+\n+        public void Add(TKey key, TValue value)\n+        {\n+            if (count < keys.Length)\n+            {\n+                keys[count] = key;\n+                values[count] = value;\n+                count += 1;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I certainly hope not...but I won't complain too much.",
              "createdAt": "2021-03-02T16:09:30Z",
              "path": "src/Build/Collections/SmallDictionary.cs",
              "diffHunk": "@@ -0,0 +1,257 @@\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Collections\n+{\n+    /// <summary>\n+    /// Small, lightweight, read-only IDictionary implementation using two arrays\n+    /// and O(n) lookup. Requires specifying capacity at construction and does not\n+    /// support reallocation to increase capacity.\n+    /// </summary>\n+    /// <typeparam name=\"TKey\">Type of keys</typeparam>\n+    /// <typeparam name=\"TValue\">Type of values</typeparam>\n+    internal class SmallDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary\n+    {\n+        private TKey[] keys;\n+        private TValue[] values;\n+\n+        private int count;\n+\n+        public SmallDictionary(int capacity)\n+        {\n+            keys = new TKey[capacity];\n+            values = new TValue[capacity];\n+        }\n+\n+        public static IDictionary<TKey, TValue> Create(int capacity)\n+        {\n+            return new SmallDictionary<TKey, TValue>(capacity);\n+        }\n+\n+        public TValue this[TKey key]\n+        {\n+            get\n+            {\n+                TryGetValue(key, out var value);\n+                return value;\n+            }\n+\n+            set\n+            {\n+                var comparer = KeyComparer;\n+                for (int i = 0; i < count; i++)\n+                {\n+                    if (comparer.Equals(key, keys[i]))\n+                    {\n+                        values[i] = value;\n+                        return;\n+                    }\n+                }\n+\n+                Add(key, value);\n+            }\n+        }\n+\n+        object IDictionary.this[object key]\n+        {\n+            get => this[(TKey)key];\n+            set => this[(TKey)key] = (TValue)value;\n+        }\n+\n+        public ICollection<TKey> Keys => keys;\n+\n+        ICollection IDictionary.Keys => keys;\n+\n+        public ICollection<TValue> Values => values;\n+\n+        ICollection IDictionary.Values => values;\n+\n+        private IEqualityComparer<TKey> KeyComparer => EqualityComparer<TKey>.Default;\n+\n+        private IEqualityComparer<TValue> ValueComparer => EqualityComparer<TValue>.Default;\n+\n+        public int Count => count;\n+\n+        public bool IsReadOnly => true;\n+\n+        bool IDictionary.IsFixedSize => true;\n+\n+        object ICollection.SyncRoot => this;\n+\n+        bool ICollection.IsSynchronized => false;\n+\n+        public void Add(TKey key, TValue value)\n+        {\n+            if (count < keys.Length)\n+            {\n+                keys[count] = key;\n+                values[count] = value;\n+                count += 1;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this a good name? The salient characteristic to me isn't that it's small but rather than it doesn't support efficient lookups or reallocations. So maybe KeyValuePairArray?",
              "createdAt": "2021-03-01T22:27:16Z",
              "path": "src/Build/Collections/SmallDictionary.cs",
              "diffHunk": "@@ -0,0 +1,257 @@\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Collections\n+{\n+    /// <summary>\n+    /// Small, lightweight, read-only IDictionary implementation using two arrays\n+    /// and O(n) lookup. Requires specifying capacity at construction and does not\n+    /// support reallocation to increase capacity.\n+    /// </summary>\n+    /// <typeparam name=\"TKey\">Type of keys</typeparam>\n+    /// <typeparam name=\"TValue\">Type of values</typeparam>\n+    internal class SmallDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, ListDictionary perhaps",
              "createdAt": "2021-03-02T00:39:56Z",
              "path": "src/Build/Collections/SmallDictionary.cs",
              "diffHunk": "@@ -0,0 +1,257 @@\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Collections\n+{\n+    /// <summary>\n+    /// Small, lightweight, read-only IDictionary implementation using two arrays\n+    /// and O(n) lookup. Requires specifying capacity at construction and does not\n+    /// support reallocation to increase capacity.\n+    /// </summary>\n+    /// <typeparam name=\"TKey\">Type of keys</typeparam>\n+    /// <typeparam name=\"TValue\">Type of values</typeparam>\n+    internal class SmallDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Decided on ArrayDictionary. How's that?",
              "createdAt": "2021-03-02T02:30:05Z",
              "path": "src/Build/Collections/SmallDictionary.cs",
              "diffHunk": "@@ -0,0 +1,257 @@\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Collections\n+{\n+    /// <summary>\n+    /// Small, lightweight, read-only IDictionary implementation using two arrays\n+    /// and O(n) lookup. Requires specifying capacity at construction and does not\n+    /// support reallocation to increase capacity.\n+    /// </summary>\n+    /// <typeparam name=\"TKey\">Type of keys</typeparam>\n+    /// <typeparam name=\"TValue\">Type of values</typeparam>\n+    internal class SmallDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I have no better suggestions, so \ud83d\udc4d",
              "createdAt": "2021-03-02T16:10:24Z",
              "path": "src/Build/Collections/SmallDictionary.cs",
              "diffHunk": "@@ -0,0 +1,257 @@\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Collections\n+{\n+    /// <summary>\n+    /// Small, lightweight, read-only IDictionary implementation using two arrays\n+    /// and O(n) lookup. Requires specifying capacity at construction and does not\n+    /// support reallocation to increase capacity.\n+    /// </summary>\n+    /// <typeparam name=\"TKey\">Type of keys</typeparam>\n+    /// <typeparam name=\"TValue\">Type of values</typeparam>\n+    internal class SmallDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It looks like MetadataCollection already does this check on line 1067, now 1109.\r\n\r\nWhy does it need a deep clone in the first place? If it's a readonly copy, shouldn't it be fine if it's the actual copy? Maybe add a separate property that is readonly but also might change if the MetadataCollection changes? I imagine that could be used in most scenarios where this is used.",
              "createdAt": "2021-03-01T22:39:47Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1045,6 +1057,36 @@ internal int DirectMetadataCount\n                 get { return (_directMetadata == null) ? 0 : _directMetadata.Count; }\n             }\n \n+            /// <summary>\n+            /// Efficient way to retrieve metadata used by packet serialization\n+            /// and binary logger.\n+            /// </summary>\n+            public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()\n+            {\n+                // If we have item definitions, call the expensive property that does the right thing.\n+                // Otherwise use _directMetadata to avoid allocations caused by DeepClone().\n+                var list = _itemDefinitions != null ? MetadataCollection : _directMetadata;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yeah not sure on why the existing code was like that. Yes, it had the check but it did DeepClone and I wasn't confident enough to change that.",
              "createdAt": "2021-03-02T02:31:20Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1045,6 +1057,36 @@ internal int DirectMetadataCount\n                 get { return (_directMetadata == null) ? 0 : _directMetadata.Count; }\n             }\n \n+            /// <summary>\n+            /// Efficient way to retrieve metadata used by packet serialization\n+            /// and binary logger.\n+            /// </summary>\n+            public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()\n+            {\n+                // If we have item definitions, call the expensive property that does the right thing.\n+                // Otherwise use _directMetadata to avoid allocations caused by DeepClone().\n+                var list = _itemDefinitions != null ? MetadataCollection : _directMetadata;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Honestly the whole collections to store properties and items need another hard look. I know Rainer did the ImmutableCow \ud83d\udc04 and perhaps he had further plans. Unfortunately refactoring this place is like doing open heart surgery on a patient who's running a marathon.",
              "createdAt": "2021-03-02T03:49:23Z",
              "path": "src/Build/Instance/ProjectItemInstance.cs",
              "diffHunk": "@@ -1045,6 +1057,36 @@ internal int DirectMetadataCount\n                 get { return (_directMetadata == null) ? 0 : _directMetadata.Count; }\n             }\n \n+            /// <summary>\n+            /// Efficient way to retrieve metadata used by packet serialization\n+            /// and binary logger.\n+            /// </summary>\n+            public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()\n+            {\n+                // If we have item definitions, call the expensive property that does the right thing.\n+                // Otherwise use _directMetadata to avoid allocations caused by DeepClone().\n+                var list = _itemDefinitions != null ? MetadataCollection : _directMetadata;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We can add `<see cref=\"\"/>` annotations for these sorts of things, right?",
              "createdAt": "2021-03-01T23:46:33Z",
              "path": "src/Framework/TaskItemData.cs",
              "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Lightweight specialized implementation of ITaskItem only used for deserializing items.\n+    /// The goal is to minimize overhead when representing deserialized items.\n+    /// Used by node packet translator and binary logger.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, for symbols that are accessible from this code. I added a cref for ITaskItem, but node packet translator and binary logger are in Microsoft.Build.dll, which is not referenced from Microsoft.Build.Framework.dll, so I can't cref those.",
              "createdAt": "2021-03-02T02:33:02Z",
              "path": "src/Framework/TaskItemData.cs",
              "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Lightweight specialized implementation of ITaskItem only used for deserializing items.\n+    /// The goal is to minimize overhead when representing deserialized items.\n+    /// Used by node packet translator and binary logger.",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could we avoid cloning if we had a separate method that just returned it? I don't think modification is an issue here.",
              "createdAt": "2021-03-01T23:49:21Z",
              "path": "src/Framework/ITaskItemExtensions.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    internal static class ITaskItemExtensions\n+    {\n+        /// <summary>\n+        /// Provides a way to efficiently enumerate custom metadata of an item, without built-in metadata.\n+        /// </summary>\n+        /// <param name=\"taskItem\">TaskItem implementation to return metadata from</param>\n+        /// <remarks>WARNING: do NOT use List`1.AddRange to iterate over this collection.\n+        /// CopyOnWriteDictionary from Microsoft.Build.Utilities.v4.0.dll is broken.</remarks>\n+        /// <returns>A non-null (but possibly empty) enumerable of item metadata.</returns>\n+        public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this ITaskItem taskItem)\n+        {\n+            if (taskItem is IMetadataContainer container)\n+            {\n+                // This is the common case: most implementations should implement this for quick access\n+                return container.EnumerateMetadata();\n+            }\n+\n+            // This runs if ITaskItem is Microsoft.Build.Utilities.TaskItem from Microsoft.Build.Utilities.v4.0.dll\n+            // that is loaded from the GAC.\n+            IDictionary customMetadata = taskItem.CloneCustomMetadata();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Unfortunately this is only called on instances of types declared in Microsoft.Build.Utilities.v4.0.dll loaded from the GAC, and that .dll is ancient and it doesn't have recent modifications. CloneCustomMetadata() is the only way we can retrieve metadata from there. Fortunately this is almost never called (unless you have a situation where our binary is loaded from the GAC).",
              "createdAt": "2021-03-02T02:34:58Z",
              "path": "src/Framework/ITaskItemExtensions.cs",
              "diffHunk": "@@ -0,0 +1,65 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    internal static class ITaskItemExtensions\n+    {\n+        /// <summary>\n+        /// Provides a way to efficiently enumerate custom metadata of an item, without built-in metadata.\n+        /// </summary>\n+        /// <param name=\"taskItem\">TaskItem implementation to return metadata from</param>\n+        /// <remarks>WARNING: do NOT use List`1.AddRange to iterate over this collection.\n+        /// CopyOnWriteDictionary from Microsoft.Build.Utilities.v4.0.dll is broken.</remarks>\n+        /// <returns>A non-null (but possibly empty) enumerable of item metadata.</returns>\n+        public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this ITaskItem taskItem)\n+        {\n+            if (taskItem is IMetadataContainer container)\n+            {\n+                // This is the common case: most implementations should implement this for quick access\n+                return container.EnumerateMetadata();\n+            }\n+\n+            // This runs if ITaskItem is Microsoft.Build.Utilities.TaskItem from Microsoft.Build.Utilities.v4.0.dll\n+            // that is loaded from the GAC.\n+            IDictionary customMetadata = taskItem.CloneCustomMetadata();",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: Should remarks and /remarks be on a separate line?",
              "createdAt": "2021-03-01T23:50:48Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,225 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemType,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemType = itemType;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemType { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework.dll\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build.dll\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.\n+        /// </summary>\n+        /// <remarks>Note that the current implementation never runs and is provided merely",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Indeed, looks cleaner that way. Changed.",
              "createdAt": "2021-03-02T02:35:46Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,225 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemType,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemType = itemType;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemType { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework.dll\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build.dll\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.\n+        /// </summary>\n+        /// <remarks>Note that the current implementation never runs and is provided merely",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm a little confused\u2014doesn't this just return a normal dictionary?",
              "createdAt": "2021-03-01T23:58:34Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,225 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemType,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemType = itemType;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemType { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework.dll\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build.dll\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.\n+        /// </summary>\n+        /// <remarks>Note that the current implementation never runs and is provided merely\n+        /// as a safeguard in case MessageGetter isn't set for some reason.</remarks>\n+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args =>\n+        {\n+            var sb = new StringBuilder();\n+            sb.AppendLine($\"{args.Kind}: {args.ItemType}\");\n+            foreach (var item in args.Items)\n+            {\n+                sb.AppendLine(item.ToString());\n+            }\n+\n+            return sb.ToString();\n+        };\n+\n+        /// <summary>\n+        /// Provides a way for Microsoft.Build.dll to provide a more efficient dictionary factory\n+        /// (using SmallDictionary`2). Since that is an implementation detail, it is not included\n+        /// in Microsoft.Build.Framework.dll so we need this extensibility point here.\n+        /// </summary>\n+        internal static Func<int, IDictionary<string, string>> DictionaryFactory = capacity => new Dictionary<string, string>(capacity);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "this is the default implementation only used as a safeguard if the static ctor never runs",
              "createdAt": "2021-03-02T00:40:48Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,225 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemType,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemType = itemType;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemType { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework.dll\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build.dll\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.\n+        /// </summary>\n+        /// <remarks>Note that the current implementation never runs and is provided merely\n+        /// as a safeguard in case MessageGetter isn't set for some reason.</remarks>\n+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args =>\n+        {\n+            var sb = new StringBuilder();\n+            sb.AppendLine($\"{args.Kind}: {args.ItemType}\");\n+            foreach (var item in args.Items)\n+            {\n+                sb.AppendLine(item.ToString());\n+            }\n+\n+            return sb.ToString();\n+        };\n+\n+        /// <summary>\n+        /// Provides a way for Microsoft.Build.dll to provide a more efficient dictionary factory\n+        /// (using SmallDictionary`2). Since that is an implementation detail, it is not included\n+        /// in Microsoft.Build.Framework.dll so we need this extensibility point here.\n+        /// </summary>\n+        internal static Func<int, IDictionary<string, string>> DictionaryFactory = capacity => new Dictionary<string, string>(capacity);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Here's where it's being overwritten (and that static constructor runs when the LoggingService is created):\r\nhttps://github.com/dotnet/msbuild/pull/6155/files#diff-0c91217fff65dd0e1d6111f4e634450ef7b5a7af5c148fae58e12c5ea5e7db7cR44",
              "createdAt": "2021-03-02T03:46:49Z",
              "path": "src/Framework/TaskParameterEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,225 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Text;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public enum TaskParameterMessageKind\n+    {\n+        TaskInput,\n+        TaskOutput,\n+        AddItem,\n+        RemoveItem,\n+    }\n+\n+    /// <summary>\n+    /// This class is used by tasks to log their parameters (input, output).\n+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also\n+    /// uses this class.\n+    /// </summary>\n+    public class TaskParameterEventArgs : BuildMessageEventArgs\n+    {\n+        /// <summary>\n+        /// Creates an instance of this class for the given task parameter.\n+        /// </summary>\n+        public TaskParameterEventArgs\n+        (\n+            TaskParameterMessageKind kind,\n+            string itemType,\n+            IList items,\n+            bool logItemMetadata,\n+            DateTime eventTimestamp\n+        )\n+            : base(null, null, null, MessageImportance.Low, eventTimestamp)\n+        {\n+            Kind = kind;\n+            ItemType = itemType;\n+            Items = items;\n+            LogItemMetadata = logItemMetadata;\n+        }\n+\n+        public TaskParameterMessageKind Kind { get; private set; }\n+        public string ItemType { get; private set; }\n+        public IList Items { get; private set; }\n+        public bool LogItemMetadata { get; private set; }\n+\n+        /// <summary>\n+        /// The <see cref=\"TaskParameterEventArgs\"/> type is declared in Microsoft.Build.Framework.dll\n+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build.dll\n+        /// which is an implementations assembly. This seems like the easiest way to inject the\n+        /// implementation for realizing the Message.\n+        /// </summary>\n+        /// <remarks>Note that the current implementation never runs and is provided merely\n+        /// as a safeguard in case MessageGetter isn't set for some reason.</remarks>\n+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args =>\n+        {\n+            var sb = new StringBuilder();\n+            sb.AppendLine($\"{args.Kind}: {args.ItemType}\");\n+            foreach (var item in args.Items)\n+            {\n+                sb.AppendLine(item.ToString());\n+            }\n+\n+            return sb.ToString();\n+        };\n+\n+        /// <summary>\n+        /// Provides a way for Microsoft.Build.dll to provide a more efficient dictionary factory\n+        /// (using SmallDictionary`2). Since that is an implementation detail, it is not included\n+        /// in Microsoft.Build.Framework.dll so we need this extensibility point here.\n+        /// </summary>\n+        internal static Func<int, IDictionary<string, string>> DictionaryFactory = capacity => new Dictionary<string, string>(capacity);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It looks like it takes the escaped form if it were available had you not added this. Why does this switch to unescaped?",
              "createdAt": "2021-03-02T00:03:04Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -751,6 +756,20 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()\n                 IDictionary clonedDictionary = new Dictionary<string, string>(_customEscapedMetadata);\n                 return clonedDictionary;\n             }\n+\n+            public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()\n+            {\n+                if (_customEscapedMetadata == null)\n+                {\n+                    yield break;\n+                }\n+\n+                foreach (var kvp in _customEscapedMetadata)\n+                {\n+                    var unescaped = new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.UnescapeAll(kvp.Value));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "We unify on Unescaped everywhere for logging",
              "createdAt": "2021-03-02T00:41:36Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -751,6 +756,20 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()\n                 IDictionary clonedDictionary = new Dictionary<string, string>(_customEscapedMetadata);\n                 return clonedDictionary;\n             }\n+\n+            public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()\n+            {\n+                if (_customEscapedMetadata == null)\n+                {\n+                    yield break;\n+                }\n+\n+                foreach (var kvp in _customEscapedMetadata)\n+                {\n+                    var unescaped = new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.UnescapeAll(kvp.Value));",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I wish I didn't have to do this as it made things slower than just returning `_customEscapedMetadata` so I had to write this loop explicitly in two places. Good to be consistently returning unescaped strings everywhere.",
              "createdAt": "2021-03-02T02:37:38Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -751,6 +756,20 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()\n                 IDictionary clonedDictionary = new Dictionary<string, string>(_customEscapedMetadata);\n                 return clonedDictionary;\n             }\n+\n+            public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()\n+            {\n+                if (_customEscapedMetadata == null)\n+                {\n+                    yield break;\n+                }\n+\n+                foreach (var kvp in _customEscapedMetadata)\n+                {\n+                    var unescaped = new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.UnescapeAll(kvp.Value));",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why no copyright header?",
              "createdAt": "2021-03-02T00:03:59Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -1,13 +1,16 @@\n-\ufeffusing System;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "forgot, will add :)",
              "createdAt": "2021-03-02T00:41:51Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -1,13 +1,16 @@\n-\ufeffusing System;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could this whole thing be turned into a switch statement? But also: \ud83d\udc4d",
              "createdAt": "2021-03-02T00:04:44Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -129,57 +132,57 @@ public void Write(BuildEventArgs e)\n         private void WriteCore(BuildEventArgs e)\n         {\n             // the cases are ordered by most used first for performance\n-            if (e is BuildMessageEventArgs)\n+            if (e is BuildMessageEventArgs buildMessage)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I\u2019ll need to measure which is faster",
              "createdAt": "2021-03-02T00:42:19Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -129,57 +132,57 @@ public void Write(BuildEventArgs e)\n         private void WriteCore(BuildEventArgs e)\n         {\n             // the cases are ordered by most used first for performance\n-            if (e is BuildMessageEventArgs)\n+            if (e is BuildMessageEventArgs buildMessage)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Indeed, a switch statement is slightly faster: \r\nhttps://github.com/KirillOsenkov/Benchmarks/blob/7d6d9323374a58994e5dfc3fb6e01c6bfda3f3c7/Benchmarks/Tests/SwitchStatement.cs#L7-L8",
              "createdAt": "2021-03-02T03:28:15Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -129,57 +132,57 @@ public void Write(BuildEventArgs e)\n         private void WriteCore(BuildEventArgs e)\n         {\n             // the cases are ordered by most used first for performance\n-            if (e is BuildMessageEventArgs)\n+            if (e is BuildMessageEventArgs buildMessage)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Switched to a switch statement ;P",
              "createdAt": "2021-03-02T03:45:16Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -129,57 +132,57 @@ public void Write(BuildEventArgs e)\n         private void WriteCore(BuildEventArgs e)\n         {\n             // the cases are ordered by most used first for performance\n-            if (e is BuildMessageEventArgs)\n+            if (e is BuildMessageEventArgs buildMessage)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I did something like that in several places in Evaluator at one point. It ran a lot. That alone saved like 2% of evaluate time.",
              "createdAt": "2021-03-02T16:16:32Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -129,57 +132,57 @@ public void Write(BuildEventArgs e)\n         private void WriteCore(BuildEventArgs e)\n         {\n             // the cases are ordered by most used first for performance\n-            if (e is BuildMessageEventArgs)\n+            if (e is BuildMessageEventArgs buildMessage)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this not covered by the previous case?",
              "createdAt": "2021-03-02T00:15:36Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -681,21 +699,68 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr\n             return flags;\n         }\n \n-        private void WriteTaskItemList(IEnumerable items)\n+        private readonly List<object> reusableItemsList = new List<object>();\n+\n+        private void WriteTaskItemList(IEnumerable items, bool writeMetadata = true)\n         {\n-            var taskItems = items as IEnumerable<ITaskItem>;\n-            if (taskItems == null)\n+            if (items == null)\n             {\n                 Write(false);\n                 return;\n             }\n \n-            Write(taskItems.Count());\n+            // For target outputs bypass copying of all items to save on performance.\n+            // The proxy creates a deep clone of each item to protect against writes,\n+            // but since we're not writing we don't need the deep cloning.\n+            // Additionally, it is safe to access the underlying List<ITaskItem> as it's allocated\n+            // in a single location and noboby else mutates it after that:\n+            // https://github.com/dotnet/msbuild/blob/f0eebf2872d76ab0cd43fdc4153ba636232b222f/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs#L564\n+            if (items is TargetLoggingContext.TargetOutputItemsInstanceEnumeratorProxy proxy)\n+            {\n+                items = proxy.BackingItems;\n+            }\n+\n+            int count;\n+\n+            if (items is ICollection arrayList)\n+            {\n+                count = arrayList.Count;\n+            }\n+            else if (items is ICollection<ITaskItem> genericList)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Nope, there are generic collections that don\u2019t implement the non-generic one",
              "createdAt": "2021-03-02T00:42:58Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -681,21 +699,68 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr\n             return flags;\n         }\n \n-        private void WriteTaskItemList(IEnumerable items)\n+        private readonly List<object> reusableItemsList = new List<object>();\n+\n+        private void WriteTaskItemList(IEnumerable items, bool writeMetadata = true)\n         {\n-            var taskItems = items as IEnumerable<ITaskItem>;\n-            if (taskItems == null)\n+            if (items == null)\n             {\n                 Write(false);\n                 return;\n             }\n \n-            Write(taskItems.Count());\n+            // For target outputs bypass copying of all items to save on performance.\n+            // The proxy creates a deep clone of each item to protect against writes,\n+            // but since we're not writing we don't need the deep cloning.\n+            // Additionally, it is safe to access the underlying List<ITaskItem> as it's allocated\n+            // in a single location and noboby else mutates it after that:\n+            // https://github.com/dotnet/msbuild/blob/f0eebf2872d76ab0cd43fdc4153ba636232b222f/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs#L564\n+            if (items is TargetLoggingContext.TargetOutputItemsInstanceEnumeratorProxy proxy)\n+            {\n+                items = proxy.BackingItems;\n+            }\n+\n+            int count;\n+\n+            if (items is ICollection arrayList)\n+            {\n+                count = arrayList.Count;\n+            }\n+            else if (items is ICollection<ITaskItem> genericList)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "For example, Linq Grouping (the bucket for GroupBy operations) doesn't implement ICollection:\r\nhttps://referencesource.microsoft.com/#System.Core/System/Linq/Enumerable.cs,7bb231e0604c79e3",
              "createdAt": "2021-03-02T03:44:15Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -681,21 +699,68 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr\n             return flags;\n         }\n \n-        private void WriteTaskItemList(IEnumerable items)\n+        private readonly List<object> reusableItemsList = new List<object>();\n+\n+        private void WriteTaskItemList(IEnumerable items, bool writeMetadata = true)\n         {\n-            var taskItems = items as IEnumerable<ITaskItem>;\n-            if (taskItems == null)\n+            if (items == null)\n             {\n                 Write(false);\n                 return;\n             }\n \n-            Write(taskItems.Count());\n+            // For target outputs bypass copying of all items to save on performance.\n+            // The proxy creates a deep clone of each item to protect against writes,\n+            // but since we're not writing we don't need the deep cloning.\n+            // Additionally, it is safe to access the underlying List<ITaskItem> as it's allocated\n+            // in a single location and noboby else mutates it after that:\n+            // https://github.com/dotnet/msbuild/blob/f0eebf2872d76ab0cd43fdc4153ba636232b222f/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs#L564\n+            if (items is TargetLoggingContext.TargetOutputItemsInstanceEnumeratorProxy proxy)\n+            {\n+                items = proxy.BackingItems;\n+            }\n+\n+            int count;\n+\n+            if (items is ICollection arrayList)\n+            {\n+                count = arrayList.Count;\n+            }\n+            else if (items is ICollection<ITaskItem> genericList)",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      }
    ]
  }
}