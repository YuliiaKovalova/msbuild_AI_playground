{
  "number": 7597,
  "title": "Adding accepted SDK name match pattern to SDK manifests.",
  "body": "Fixes #7293\r\n\r\n### Context\r\nPreviously all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavior since ChangeWave 17.4. Now the resolvers might specify the name pattern for sdks they intend to resolve. If sdk name does not match, we would not unnecessary load the resolver.\r\n\r\n### Changes Made\r\n- The manifest file now could have NamePattern of the resolvers specified. The change is backward but not forward compatible.\r\n- The resolving algorithm works in two passes. On the first pass all the specific resolvers that match the given sdk name would be loaded (if needed), ordered by priority and tried one after one. If the sdk is not found, on the second pass all general resolvers would be loaded (if needed), ordered by priority and tried one after one. This change is under the ChangeWave 17.4.\r\n\r\nThis change of algorithm might lead to a change in sdk resolution in the following situation:\r\n- we have two resolvers A and B, priority of A is higher than priority of B, but A is general and B is specific.\r\n- the sdk of the project might be resolved by two resolvers, A and B.\r\n\r\nThen before the change the project is resolved by resolver A and after with resolver B.\r\n\r\n### Testing\r\n- Old & new unit tests\r\n- Manual tests.\r\n- DDRITs",
  "state": "MERGED",
  "createdAt": "2022-05-04T09:31:10Z",
  "updatedAt": "2022-05-25T15:17:50Z",
  "closedAt": "2022-05-25T15:17:50Z",
  "mergedAt": "2022-05-25T15:17:50Z",
  "additions": 656,
  "deletions": 57,
  "changedFiles": 10,
  "headRefName": "add-name-match-pattern-to-sdk-resolvers",
  "isDraft": false,
  "author": {
    "login": "AR-May"
  },
  "milestone": {
    "title": "VS 17.3"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "9ba29b61ed1dbf0853fac4a7a2a4127202cb73c7",
          "message": "Add NamePattern field to sdk resolver manifest.",
          "committedDate": "2022-05-04T09:24:02Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb1d895c9c1375e2a33d301b46de1c358a2f6829",
          "message": "Add changewave 17.3 and move the new sdk-resolving algorithm under it.",
          "committedDate": "2022-05-04T09:27:06Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "19e21a58bf7cfc001829479f895ce28c4242d246",
          "message": "Refactor resolver finding.",
          "committedDate": "2022-05-04T09:27:11Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dee9746e06db47c4dcd330f0fb2e5bd7e4a58461",
          "message": "Add new resolving algo.",
          "committedDate": "2022-05-04T09:27:11Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f882d2371f4e7a875225dbd473b0434967a39cb0",
          "message": "Fix tests.",
          "committedDate": "2022-05-09T17:58:37Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "713bc9bba3582a2e0b149553cc009002bce9290f",
          "message": "Fix resolver algo.",
          "committedDate": "2022-05-09T18:20:08Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "330e3c66119949bfbed1f7506c319fe2b67a17a2",
          "message": "Address comments.",
          "committedDate": "2022-05-09T18:20:08Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e2dcbc107467c1196e2debfeef3637337c21afe2",
          "message": "Add comments.",
          "committedDate": "2022-05-10T12:46:37Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0f3fa49a1c0dc1714bf81dbf263e917ffd254453",
          "message": "Add spec for the new sdk resolvers algo.",
          "committedDate": "2022-05-10T14:20:00Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1f894c11b376ae6756370692259ddebb2ef3f2dc",
          "message": "Add PR link to changewaves wiki; adjust a unit test.",
          "committedDate": "2022-05-11T14:15:09Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "14da67c8c98e274a5e1e8cdd54c1ba53d3d0ea36",
          "message": "Merge branch 'main' into add-name-match-pattern-to-sdk-resolvers",
          "committedDate": "2022-05-11T14:18:31Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5c7bf49ce29df98478c4c60c30e3172b14922fb8",
          "message": "Address comments.",
          "committedDate": "2022-05-13T18:12:52Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "110b3581c80657de486055bbc001bafcba336a4a",
          "message": "Update src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2022-05-16T07:47:41Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "916b66db1b29001a81a80c2f96ca5ed1874ec86f",
          "message": "Fix MSBuildToolsDirectoryRoot when BuildEnvironmentMode is None.",
          "committedDate": "2022-05-16T17:21:17Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "05c6f2577895a30bb1b2b92fb5b3dc42be0e85fe",
          "message": "Prefer manifest file over assembly.",
          "committedDate": "2022-05-19T00:01:55Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b23c531ab7ddcbf2419bd8d91ea14533977a46de",
          "message": "Address some feedback - 1.",
          "committedDate": "2022-05-19T00:01:55Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b9f4653b9d651bf42dcc2c89080c14775bbe7340",
          "message": "Address some feedback - 2.",
          "committedDate": "2022-05-19T16:02:12Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dcfe6cfb233d2aa2dafa0805974be0432f66134c",
          "message": "Update event-source.md",
          "committedDate": "2022-05-20T13:04:01Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "65ca3066495958e909a1ef42442b76854246962a",
          "message": "Update my exceptions.",
          "committedDate": "2022-05-20T14:15:27Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c777af850358704cd3c920d7cda568f6b7ef1e44",
          "message": "address comments",
          "committedDate": "2022-05-24T18:04:54Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Not quite sure how better to call this field. maybe \"NamePatternRegex\"? Any good suggestions?",
              "createdAt": "2022-05-10T16:24:17Z",
              "path": "documentation/specs/sdk-resolvers-algorithm.md",
              "diffHunk": "@@ -0,0 +1,22 @@\n+## SDK Resolution Algorithm\n+Since ChangeWave 17.4 the sdk resolution algorithm is changed.\n+\n+### Reason for change\n+Previously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavoir since ChangeWave 17.4.\n+\n+### New SDK Resolution Algorithm\n+Since ChangeWave 17.4 all the resolvers divides into two groups:\n+- Specific resolvers, i.e. resolvers with specified name pattern\n+- General resolvers, i.e. resolvers without specified name pattern\n+\n+The resolving algorithm works in two passes. \n+- On the first pass all the specific resolvers that match the given sdk name would be loaded (if needed), ordered by priority and tried one after one. \n+- If the sdk is not found, on the second pass all general resolvers would be loaded (if needed), ordered by priority and tried one after one.\n+\n+By default the resolvers are general. To make all the resolvers from some dll specific, in the corresponding manifest (xml file) one need to specify the `NamePattern` using C# regex format:\n+```\n+<SdkResolver>\n+  <Path>MySdkResolver.dll</Path>\n+  <NamePattern>MySdk.*</NamePattern>",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Some ideas\r\n\r\n* `ResolvableSdkPattern`\r\n* `MatchableSdkNames`\r\n\r\n@baronfel, want to chime in? This is for an optional field containing a regex string for \"if the SDK to be resolved matches this pattern, we will call the resolver\".",
              "createdAt": "2022-05-11T20:58:14Z",
              "path": "documentation/specs/sdk-resolvers-algorithm.md",
              "diffHunk": "@@ -0,0 +1,22 @@\n+## SDK Resolution Algorithm\n+Since ChangeWave 17.4 the sdk resolution algorithm is changed.\n+\n+### Reason for change\n+Previously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavoir since ChangeWave 17.4.\n+\n+### New SDK Resolution Algorithm\n+Since ChangeWave 17.4 all the resolvers divides into two groups:\n+- Specific resolvers, i.e. resolvers with specified name pattern\n+- General resolvers, i.e. resolvers without specified name pattern\n+\n+The resolving algorithm works in two passes. \n+- On the first pass all the specific resolvers that match the given sdk name would be loaded (if needed), ordered by priority and tried one after one. \n+- If the sdk is not found, on the second pass all general resolvers would be loaded (if needed), ordered by priority and tried one after one.\n+\n+By default the resolvers are general. To make all the resolvers from some dll specific, in the corresponding manifest (xml file) one need to specify the `NamePattern` using C# regex format:\n+```\n+<SdkResolver>\n+  <Path>MySdkResolver.dll</Path>\n+  <NamePattern>MySdk.*</NamePattern>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "`ResolvableSdkPattern` is more self-descriptive, I agree.",
              "createdAt": "2022-05-12T14:57:50Z",
              "path": "documentation/specs/sdk-resolvers-algorithm.md",
              "diffHunk": "@@ -0,0 +1,22 @@\n+## SDK Resolution Algorithm\n+Since ChangeWave 17.4 the sdk resolution algorithm is changed.\n+\n+### Reason for change\n+Previously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavoir since ChangeWave 17.4.\n+\n+### New SDK Resolution Algorithm\n+Since ChangeWave 17.4 all the resolvers divides into two groups:\n+- Specific resolvers, i.e. resolvers with specified name pattern\n+- General resolvers, i.e. resolvers without specified name pattern\n+\n+The resolving algorithm works in two passes. \n+- On the first pass all the specific resolvers that match the given sdk name would be loaded (if needed), ordered by priority and tried one after one. \n+- If the sdk is not found, on the second pass all general resolvers would be loaded (if needed), ordered by priority and tried one after one.\n+\n+By default the resolvers are general. To make all the resolvers from some dll specific, in the corresponding manifest (xml file) one need to specify the `NamePattern` using C# regex format:\n+```\n+<SdkResolver>\n+  <Path>MySdkResolver.dll</Path>\n+  <NamePattern>MySdk.*</NamePattern>",
              "author": {
                "login": "baronfel"
              }
            },
            {
              "body": "Don't forget to update this doc :)",
              "createdAt": "2022-05-13T19:20:06Z",
              "path": "documentation/specs/sdk-resolvers-algorithm.md",
              "diffHunk": "@@ -0,0 +1,22 @@\n+## SDK Resolution Algorithm\n+Since ChangeWave 17.4 the sdk resolution algorithm is changed.\n+\n+### Reason for change\n+Previously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavoir since ChangeWave 17.4.\n+\n+### New SDK Resolution Algorithm\n+Since ChangeWave 17.4 all the resolvers divides into two groups:\n+- Specific resolvers, i.e. resolvers with specified name pattern\n+- General resolvers, i.e. resolvers without specified name pattern\n+\n+The resolving algorithm works in two passes. \n+- On the first pass all the specific resolvers that match the given sdk name would be loaded (if needed), ordered by priority and tried one after one. \n+- If the sdk is not found, on the second pass all general resolvers would be loaded (if needed), ordered by priority and tried one after one.\n+\n+By default the resolvers are general. To make all the resolvers from some dll specific, in the corresponding manifest (xml file) one need to specify the `NamePattern` using C# regex format:\n+```\n+<SdkResolver>\n+  <Path>MySdkResolver.dll</Path>\n+  <NamePattern>MySdk.*</NamePattern>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I am thinking about should I use `RegexOptions.CultureInvariant` / `RegexOptions.IgnoreCase` here.",
              "createdAt": "2022-05-10T16:33:23Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,139 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_resolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = _resolversManifestsRegistry\n+                .Where(r => !string.IsNullOrEmpty(r.NamePattern) && Regex.IsMatch(sdk.Name, r.NamePattern, RegexOptions.None, TimeSpan.FromMilliseconds(ResolverNamePatternRegexTimeoutMsc)))",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I'd say `CultureInvariant` but not `IgnoreCase` -- the resolver author can always throw a `(?i)` into their pattern.",
              "createdAt": "2022-05-11T19:58:35Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,139 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_resolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = _resolversManifestsRegistry\n+                .Where(r => !string.IsNullOrEmpty(r.NamePattern) && Regex.IsMatch(sdk.Name, r.NamePattern, RegexOptions.None, TimeSpan.FromMilliseconds(ResolverNamePatternRegexTimeoutMsc)))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I agree.",
              "createdAt": "2022-05-12T14:45:43Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,139 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_resolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = _resolversManifestsRegistry\n+                .Where(r => !string.IsNullOrEmpty(r.NamePattern) && Regex.IsMatch(sdk.Name, r.NamePattern, RegexOptions.None, TimeSpan.FromMilliseconds(ResolverNamePatternRegexTimeoutMsc)))",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nPreviously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavior in 17.3 under ChangeWave 17.4.\r\n```",
              "createdAt": "2022-05-11T19:51:28Z",
              "path": "documentation/specs/sdk-resolvers-algorithm.md",
              "diffHunk": "@@ -0,0 +1,22 @@\n+## SDK Resolution Algorithm\n+Since ChangeWave 17.4 the sdk resolution algorithm is changed.\n+\n+### Reason for change\n+Previously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavoir since ChangeWave 17.4.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Document reasoning for this number (even if it's just \"total guess that seemed reasonable\"). That way, if it ever seems like it needs to be changed, future maintainers have a way to evaluate the change.",
              "createdAt": "2022-05-11T19:54:57Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -41,7 +43,25 @@ internal class SdkResolverService : ISdkResolverService\n         /// <summary>\n         /// Stores the list of SDK resolvers which were loaded.\n         /// </summary>\n-        private IList<SdkResolver> _resolvers;\n+        /// <remarks>\n+        /// Need it for supporting the ChangeWave less than <see cref=\"ChangeWaves.Wave17_4\"/>. Remove when move out Wave17_4.\n+        /// </remarks>\n+        private IList<SdkResolver> _resolversList;\n+\n+        /// <summary>\n+        /// Stores the loaded SDK resolvers.\n+        /// </summary>\n+        private Dictionary<SdkResolverManifest, IList<SdkResolver>> _resolversDict;\n+\n+        /// <summary>\n+        /// Stores the list of manifests of SDK resolvers which could be loaded.\n+        /// </summary>\n+        private IList<SdkResolverManifest> _resolversManifestsRegistry;\n+\n+        /// <summary>\n+        /// The time-out interval for the name pattern regex in milliseconds.\n+        /// </summary>\n+        private const int ResolverNamePatternRegexTimeoutMsc = 500;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Well, this number is indeed problematic. I am not sure that the current one is reasonable too. It probably should be less. The main concern that this number addresses - we need somehow catch early the situation when we have got an infinite or way too long regex. I will update the summary.",
              "createdAt": "2022-05-12T15:27:47Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -41,7 +43,25 @@ internal class SdkResolverService : ISdkResolverService\n         /// <summary>\n         /// Stores the list of SDK resolvers which were loaded.\n         /// </summary>\n-        private IList<SdkResolver> _resolvers;\n+        /// <remarks>\n+        /// Need it for supporting the ChangeWave less than <see cref=\"ChangeWaves.Wave17_4\"/>. Remove when move out Wave17_4.\n+        /// </remarks>\n+        private IList<SdkResolver> _resolversList;\n+\n+        /// <summary>\n+        /// Stores the loaded SDK resolvers.\n+        /// </summary>\n+        private Dictionary<SdkResolverManifest, IList<SdkResolver>> _resolversDict;\n+\n+        /// <summary>\n+        /// Stores the list of manifests of SDK resolvers which could be loaded.\n+        /// </summary>\n+        private IList<SdkResolverManifest> _resolversManifestsRegistry;\n+\n+        /// <summary>\n+        /// The time-out interval for the name pattern regex in milliseconds.\n+        /// </summary>\n+        private const int ResolverNamePatternRegexTimeoutMsc = 500;",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you create a persistent regex object per resolver and create it with `RegexOptions.Compiled`? We'll be running these on many inputs and I'd suspect the startup cost would be worth paying.",
              "createdAt": "2022-05-11T19:59:36Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,139 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_resolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = _resolversManifestsRegistry\n+                .Where(r => !string.IsNullOrEmpty(r.NamePattern) && Regex.IsMatch(sdk.Name, r.NamePattern, RegexOptions.None, TimeSpan.FromMilliseconds(ResolverNamePatternRegexTimeoutMsc)))",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "LINQ is generally frowned upon in our codebase because of occasional but hard-to-predict perf problems, especially around allocation.\r\n\r\nThis isn't called enough to be super concerning, but I might still avoid it here in favor of walking over the list and splitting it, something like\r\n\r\n```suggestion\r\n            List<SdkResolverManifest> matchingResolversManifests = new();\r\n            List<SdkResolverManifest> otherResolversManifests = new();\r\n            foreach (SdkResolverManifest manifest in _resolversManifestsRegistry)\r\n            {\r\n                if (string.IsNullOrEmpty(manifest.NamePattern))\r\n                {\r\n                    otherResolversManifests.Add(manifest);\r\n                }\r\n                else if (Regex.IsMatch(sdk.Name, manifest.NamePattern, RegexOptions.None, TimeSpan.FromMilliseconds(ResolverNamePatternRegexTimeoutMsc)))\r\n                {\r\n                    matchingResolversManifests.Add(manifest);\r\n                }\r\n            }\r\n```\r\n",
              "createdAt": "2022-05-11T20:29:15Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,139 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_resolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = _resolversManifestsRegistry\n+                .Where(r => !string.IsNullOrEmpty(r.NamePattern) && Regex.IsMatch(sdk.Name, r.NamePattern, RegexOptions.None, TimeSpan.FromMilliseconds(ResolverNamePatternRegexTimeoutMsc)))\n+                .ToList();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Ah, that is why I do not see much of LINQ in the repo. Sure, I will change that.",
              "createdAt": "2022-05-12T14:54:03Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,139 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_resolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = _resolversManifestsRegistry\n+                .Where(r => !string.IsNullOrEmpty(r.NamePattern) && Regex.IsMatch(sdk.Name, r.NamePattern, RegexOptions.None, TimeSpan.FromMilliseconds(ResolverNamePatternRegexTimeoutMsc)))\n+                .ToList();",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this event mean the same thing any more? Is it now the span over loading manifests but not assemblies, where before it included assemblies?",
              "createdAt": "2022-05-11T20:32:18Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -232,14 +391,33 @@ private void Initialize(LoggingContext loggingContext, ElementLocation location)\n         {\n             lock (_lockObject)\n             {\n-                if (_resolvers != null)\n+                if (_resolversList != null)\n                 {\n                     return;\n                 }\n \n                 MSBuildEventSource.Log.SdkResolverServiceInitializeStart();\n-                _resolvers = _sdkResolverLoader.LoadResolvers(loggingContext, location);\n-                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolvers.Count);\n+                _resolversList = _sdkResolverLoader.LoadResolvers(loggingContext, location);\n+                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolversList.Count);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Ah, it does mean the same thing but it isn't called all the time now. Can you please add events for the other path?",
              "createdAt": "2022-05-11T20:35:10Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -232,14 +391,33 @@ private void Initialize(LoggingContext loggingContext, ElementLocation location)\n         {\n             lock (_lockObject)\n             {\n-                if (_resolvers != null)\n+                if (_resolversList != null)\n                 {\n                     return;\n                 }\n \n                 MSBuildEventSource.Log.SdkResolverServiceInitializeStart();\n-                _resolvers = _sdkResolverLoader.LoadResolvers(loggingContext, location);\n-                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolvers.Count);\n+                _resolversList = _sdkResolverLoader.LoadResolvers(loggingContext, location);\n+                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolversList.Count);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        // This parsing code is very specific and not forward compatible, but since resolvers generally ship in the same release vehicle as MSBuild itself, only backward compatibility is required.\r\n```",
              "createdAt": "2022-05-11T20:38:02Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs",
              "diffHunk": "@@ -47,22 +62,34 @@ internal static SdkResolverManifest Load(string filePath)\n             return null;\n         }\n \n+        // This parsing code is very specific and not forward compatible, but it should be all right.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I would think about making this a `Regex` so that\r\n\r\n1. We only carry one regex/manifest, ever, and\r\n2. We can throw at manifest-parse time if the regex is invalid.",
              "createdAt": "2022-05-11T20:40:57Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs",
              "diffHunk": "@@ -11,8 +11,23 @@ namespace Microsoft.Build.BackEnd.SdkResolution\n     /// </summary>\n     internal class SdkResolverManifest\n     {\n+        public SdkResolverManifest()\n+        {\n+        }\n+\n+        public SdkResolverManifest(string name, string path, string namePattern)\n+        {\n+            Name = name;\n+            Path = path;\n+            NamePattern = namePattern;\n+        }\n+\n+        internal string Name { get; set; }\n+\n         internal string Path { get; set; }\n \n+        internal string NamePattern { get; set; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Did it. I now throw internal errors on the creation (in case of compile problems) and when we apply (in case of timeout). I decided the internal exceptions should be fine, based on the thought that we provide no option to register custom resolvers on the MSBuild other than modifying its files.",
              "createdAt": "2022-05-13T18:22:28Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs",
              "diffHunk": "@@ -11,8 +11,23 @@ namespace Microsoft.Build.BackEnd.SdkResolution\n     /// </summary>\n     internal class SdkResolverManifest\n     {\n+        public SdkResolverManifest()\n+        {\n+        }\n+\n+        public SdkResolverManifest(string name, string path, string namePattern)\n+        {\n+            Name = name;\n+            Path = path;\n+            NamePattern = namePattern;\n+        }\n+\n+        internal string Name { get; set; }\n+\n         internal string Path { get; set; }\n \n+        internal string NamePattern { get; set; }",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                Path.Combine(BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot, \"SdkResolvers\"), location);\r\n```\r\n\r\n(this is the new one we invented to avoid some confusion, today it has the same value as `ToolsDirectory32` but it communicates intent more clearly)",
              "createdAt": "2022-05-11T20:43:39Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -57,6 +66,13 @@ internal class SdkResolverLoader\n             return resolvers.OrderBy(t => t.Priority).ToList();\n         }\n \n+        internal virtual IList<SdkResolverManifest> GetResolversManifests(LoggingContext loggingContext,\n+            ElementLocation location)\n+        {\n+            return FindPotentialSdkResolversManifests(\n+                Path.Combine(BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, \"SdkResolvers\"), location);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Promote\r\n\r\n```C#\r\n!String.Equals(IncludeDefaultResolver, \"false\", StringComparison.OrdinalIgnoreCase)\r\n```\r\n\r\nInto a bool field and compute it only once?",
              "createdAt": "2022-05-11T20:46:26Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -34,6 +34,15 @@ internal class SdkResolverLoader\n #endif\n             ) ?? Environment.GetEnvironmentVariable(\"MSBUILDADDITIONALSDKRESOLVERSFOLDER\");\n \n+        internal virtual IList<SdkResolver> LoadDefaultResolvers(LoggingContext loggingContext, ElementLocation location)\n+        {\n+            var resolvers = !String.Equals(IncludeDefaultResolver, \"false\", StringComparison.OrdinalIgnoreCase) ?",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "There is no need: this whole function is part of the lazy initialization and already called only once per SdkResolverLoader object creation.",
              "createdAt": "2022-05-12T14:44:31Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -34,6 +34,15 @@ internal class SdkResolverLoader\n #endif\n             ) ?? Environment.GetEnvironmentVariable(\"MSBUILDADDITIONALSDKRESOLVERSFOLDER\");\n \n+        internal virtual IList<SdkResolver> LoadDefaultResolvers(LoggingContext loggingContext, ElementLocation location)\n+        {\n+            var resolvers = !String.Equals(IncludeDefaultResolver, \"false\", StringComparison.OrdinalIgnoreCase) ?",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: create modern tuples with element names so you don't have to do the ugly `Item1`/`Item2` stuff below\r\n\r\n```suggestion\r\n            private List<(string NamePattern, SdkResolver Resolver)> _resolversWithPatterns;\r\n```",
              "createdAt": "2022-05-11T20:53:52Z",
              "path": "src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs",
              "diffHunk": "@@ -539,29 +603,82 @@ public void IsRunningInVisualStudioIsSetForResolverContext()\n \n         private class MockLoaderStrategy : SdkResolverLoader\n         {\n-            private readonly bool _includeErrorResolver;\n+            private List<SdkResolver> _resolvers;\n+            private List<Tuple<string, SdkResolver>> _resolversWithPatterns;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "About this line I am not sure I would like it this way. Previously at this moment we knew the total number of resolvers and could set the dictionary well. Now we do not know the number of resolvers, only number of manifests, each could in theory have >1 resolver. I wonder that it might be better not to specify the capacity at all than specify and underestimate it. ",
              "createdAt": "2022-05-13T18:17:57Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -250,7 +461,9 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta\n             {\n                 ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(\n                     submissionId,\n-                    _ => new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));\n+                    _ => new ConcurrentDictionary<SdkResolver, object>(\n+                        NativeMethodsShared.GetLogicalCoreCount(),\n+                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) ? _specificResolversManifestsRegistry.Count + _generalResolversManifestsRegistry.Count : _resolversList.Count));",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "The penalty for growing a list isn't huge, it's just best avoided if possible. Here we have a pretty good guess so I'd say it's worth leaving as you've implemented it.",
              "createdAt": "2022-05-13T19:22:30Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -250,7 +461,9 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta\n             {\n                 ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(\n                     submissionId,\n-                    _ => new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));\n+                    _ => new ConcurrentDictionary<SdkResolver, object>(\n+                        NativeMethodsShared.GetLogicalCoreCount(),\n+                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) ? _specificResolversManifestsRegistry.Count + _generalResolversManifestsRegistry.Count : _resolversList.Count));",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I agree with making this an `InternalError`; those are not supposed to be able to be thrown because of MSBuild inputs, but I think in this case since it's in a manifest that is, from the user's perspective, \"part of MSBuild\", it's a reasonable choice here.\r\n\r\nHowever, can you check the error output with this overload, which should preserve more information?\r\n\r\n```suggestion\r\n                                        ErrorUtilities.ThrowInternalError(\"A regular expression parsing error occurred while parsing {0}.\", ex, filePath);\r\n```",
              "createdAt": "2022-05-13T19:35:56Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs",
              "diffHunk": "@@ -47,22 +82,43 @@ internal static SdkResolverManifest Load(string filePath)\n             return null;\n         }\n \n-        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader)\n+        // This parsing code is very specific and not forward compatible, but since resolvers generally ship in the same release vehicle as MSBuild itself, only backward compatibility is required.\n+        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader, string filePath)\n         {\n             SdkResolverManifest manifest = new SdkResolverManifest();\n+            manifest.Name = filePath;\n \n-            while (reader.Read())\n+            reader.Read();\n+            while (!reader.EOF)\n             {\n                 switch (reader.NodeType)\n                 {\n                     case XmlNodeType.Element:\n                         {\n-                            manifest.Path = reader.Name switch\n+                            switch (reader.Name)\n                             {\n-                                \"Path\" => reader.ReadElementContentAsString(),\n-                                _ => throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"UnrecognizedElement\", reader.Name)),\n-                            };\n+                                case \"Path\":\n+                                    manifest.Path = reader.ReadElementContentAsString();\n+                                    break;\n+                                case \"ResolvableSdkPattern\":\n+                                    string pattern = reader.ReadElementContentAsString();\n+                                    try\n+                                    {\n+                                        manifest.ResolvableSdkRegex = new Regex(pattern, RegexOptions.Compiled | RegexOptions.CultureInvariant, TimeSpan.FromMilliseconds(SdkResolverPatternRegexTimeoutMsc));\n+                                    }\n+                                    catch (ArgumentException ex)\n+                                    {\n+                                        ErrorUtilities.ThrowInternalError(\"A regular expression parsing error occurred while parsing {0}. Error message: {1}\", filePath, ex.Message);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes, this one have more info, I will use it.",
              "createdAt": "2022-05-20T14:14:36Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs",
              "diffHunk": "@@ -47,22 +82,43 @@ internal static SdkResolverManifest Load(string filePath)\n             return null;\n         }\n \n-        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader)\n+        // This parsing code is very specific and not forward compatible, but since resolvers generally ship in the same release vehicle as MSBuild itself, only backward compatibility is required.\n+        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader, string filePath)\n         {\n             SdkResolverManifest manifest = new SdkResolverManifest();\n+            manifest.Name = filePath;\n \n-            while (reader.Read())\n+            reader.Read();\n+            while (!reader.EOF)\n             {\n                 switch (reader.NodeType)\n                 {\n                     case XmlNodeType.Element:\n                         {\n-                            manifest.Path = reader.Name switch\n+                            switch (reader.Name)\n                             {\n-                                \"Path\" => reader.ReadElementContentAsString(),\n-                                _ => throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"UnrecognizedElement\", reader.Name)),\n-                            };\n+                                case \"Path\":\n+                                    manifest.Path = reader.ReadElementContentAsString();\n+                                    break;\n+                                case \"ResolvableSdkPattern\":\n+                                    string pattern = reader.ReadElementContentAsString();\n+                                    try\n+                                    {\n+                                        manifest.ResolvableSdkRegex = new Regex(pattern, RegexOptions.Compiled | RegexOptions.CultureInvariant, TimeSpan.FromMilliseconds(SdkResolverPatternRegexTimeoutMsc));\n+                                    }\n+                                    catch (ArgumentException ex)\n+                                    {\n+                                        ErrorUtilities.ThrowInternalError(\"A regular expression parsing error occurred while parsing {0}. Error message: {1}\", filePath, ex.Message);",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How can this have more than one element at this stage? In other words, what does the ordering do?",
              "createdAt": "2022-05-14T22:17:19Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -34,7 +34,16 @@ internal class SdkResolverLoader\n #endif\n             ) ?? Environment.GetEnvironmentVariable(\"MSBUILDADDITIONALSDKRESOLVERSFOLDER\");\n \n-        internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,\n+        internal virtual IList<SdkResolver> LoadDefaultResolvers(LoggingContext loggingContext, ElementLocation location)\n+        {\n+            var resolvers = !String.Equals(IncludeDefaultResolver, \"false\", StringComparison.OrdinalIgnoreCase) ?\n+                new List<SdkResolver> {new DefaultSdkResolver()}\n+                : new List<SdkResolver>();\n+\n+            return resolvers.OrderBy(t => t.Priority).ToList();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "hm, some leftover code here, right! We do not care of the ordering in this function at all, and there could be only one element max anyway.",
              "createdAt": "2022-05-18T14:23:34Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -34,7 +34,16 @@ internal class SdkResolverLoader\n #endif\n             ) ?? Environment.GetEnvironmentVariable(\"MSBUILDADDITIONALSDKRESOLVERSFOLDER\");\n \n-        internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,\n+        internal virtual IList<SdkResolver> LoadDefaultResolvers(LoggingContext loggingContext, ElementLocation location)\n+        {\n+            var resolvers = !String.Equals(IncludeDefaultResolver, \"false\", StringComparison.OrdinalIgnoreCase) ?\n+                new List<SdkResolver> {new DefaultSdkResolver()}\n+                : new List<SdkResolver>();\n+\n+            return resolvers.OrderBy(t => t.Priority).ToList();",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This doesn't feel like an internal error to me.",
              "createdAt": "2022-05-17T18:40:01Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,153 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = new();\n+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n+            {\n+                try\n+                {\n+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))\n+                    {\n+                        matchingResolversManifests.Add(manifest);\n+                    }\n+                }\n+                catch (RegexMatchTimeoutException ex)\n+                {\n+                    ErrorUtilities.ThrowInternalError(\"Regular expression parsing exceeds timeout for manifest {0}. Error message: {1}\", manifest.Name, ex.Message);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I was also torn but the only real alternative is `InvalidProjectFileException` and since this is a problem with the SDK resolver I think `InternalError` is a better choice.",
              "createdAt": "2022-05-17T18:58:59Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,153 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = new();\n+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n+            {\n+                try\n+                {\n+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))\n+                    {\n+                        matchingResolversManifests.Add(manifest);\n+                    }\n+                }\n+                catch (RegexMatchTimeoutException ex)\n+                {\n+                    ErrorUtilities.ThrowInternalError(\"Regular expression parsing exceeds timeout for manifest {0}. Error message: {1}\", manifest.Name, ex.Message);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I agree Internal > InvalidProjectFile, but why are those the only options? Internal makes it sound like it's a bug in MSBuild. It might be a bug in one of our SDK resolvers, but it might not be, and in fact, since we've tested ours, it presumably isn't. It's a fix-your-own-build problem.",
              "createdAt": "2022-05-17T23:12:40Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,153 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = new();\n+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n+            {\n+                try\n+                {\n+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))\n+                    {\n+                        matchingResolversManifests.Add(manifest);\n+                    }\n+                }\n+                catch (RegexMatchTimeoutException ex)\n+                {\n+                    ErrorUtilities.ThrowInternalError(\"Regular expression parsing exceeds timeout for manifest {0}. Error message: {1}\", manifest.Name, ex.Message);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Well, it is not fix-your-own-build, rather fix-your-own-msbuild-cause-you-broke-it. I do not know a way to do that out of the project files. There is an option to specify additional folder for sdk resolvers and where customer's resolvers could be in theory located, but it is my understanding that it is a non-documented [env variables](https://github.com/dotnet/msbuild/blob/b3626202175e5c91998eaca0dc0881cb7f2e5da5/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs#L29).",
              "createdAt": "2022-05-18T16:02:22Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,153 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = new();\n+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n+            {\n+                try\n+                {\n+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))\n+                    {\n+                        matchingResolversManifests.Add(manifest);\n+                    }\n+                }\n+                catch (RegexMatchTimeoutException ex)\n+                {\n+                    ErrorUtilities.ThrowInternalError(\"Regular expression parsing exceeds timeout for manifest {0}. Error message: {1}\", manifest.Name, ex.Message);",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                if (!_resolversDict.TryGetValue(resolverManifest, out IList<SdkResolver> resolvers))\r\n```",
              "createdAt": "2022-05-17T18:46:00Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,153 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = new();\n+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n+            {\n+                try\n+                {\n+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))\n+                    {\n+                        matchingResolversManifests.Add(manifest);\n+                    }\n+                }\n+                catch (RegexMatchTimeoutException ex)\n+                {\n+                    ErrorUtilities.ThrowInternalError(\"Regular expression parsing exceeds timeout for manifest {0}. Error message: {1}\", manifest.Name, ex.Message);\n+                }\n+            }\n+\n+            List<SdkResolver> resolvers;\n+            SdkResult sdkResult;\n+            if (matchingResolversManifests.Count != 0)\n+            {\n+                // First pass.\n+                resolvers = GetResolvers(matchingResolversManifests, loggingContext, sdkReferenceLocation);\n+\n+                if (TryResolveSdkUsingSpecifiedResolvers(\n+                    resolvers,\n+                    submissionId,\n+                    sdk,\n+                    loggingContext,\n+                    sdkReferenceLocation,\n+                    solutionPath,\n+                    projectPath,\n+                    interactive,\n+                    isRunningInVisualStudio,\n+                    out sdkResult))\n+                {\n+                    return sdkResult;\n+                }\n+            }\n+\n+            // Second pass: fallback to general resolvers. \n+            resolvers = GetResolvers(\n+                _generalResolversManifestsRegistry,\n+                loggingContext,\n+                sdkReferenceLocation).ToList();\n+\n+            if (TryResolveSdkUsingSpecifiedResolvers(\n+                resolvers,\n+                submissionId,\n+                sdk,\n+                loggingContext,\n+                sdkReferenceLocation,\n+                solutionPath,\n+                projectPath,\n+                interactive,\n+                isRunningInVisualStudio,\n+                out sdkResult))\n+            {\n+                return sdkResult;\n+            }\n+\n+            // No resolvers resolved the sdk.\n+            return new SdkResult(sdk, null, null);\n+        }\n+\n+        private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)\n+        {\n+            // Create a sorted by priority list of resolvers. Load them if needed.\n+            List<SdkResolver> resolvers = new List<SdkResolver>();\n+            foreach (var resolverManifest in resolversManifests)\n+            {\n+                if (!_resolversDict.ContainsKey(resolverManifest))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm wondering if we could eliminate some LINQ in places. Seems a bit allocate-y. Probably not a big deal.",
              "createdAt": "2022-05-17T18:47:29Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,153 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = new();\n+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n+            {\n+                try\n+                {\n+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))\n+                    {\n+                        matchingResolversManifests.Add(manifest);\n+                    }\n+                }\n+                catch (RegexMatchTimeoutException ex)\n+                {\n+                    ErrorUtilities.ThrowInternalError(\"Regular expression parsing exceeds timeout for manifest {0}. Error message: {1}\", manifest.Name, ex.Message);\n+                }\n+            }\n+\n+            List<SdkResolver> resolvers;\n+            SdkResult sdkResult;\n+            if (matchingResolversManifests.Count != 0)\n+            {\n+                // First pass.\n+                resolvers = GetResolvers(matchingResolversManifests, loggingContext, sdkReferenceLocation);\n+\n+                if (TryResolveSdkUsingSpecifiedResolvers(\n+                    resolvers,\n+                    submissionId,\n+                    sdk,\n+                    loggingContext,\n+                    sdkReferenceLocation,\n+                    solutionPath,\n+                    projectPath,\n+                    interactive,\n+                    isRunningInVisualStudio,\n+                    out sdkResult))\n+                {\n+                    return sdkResult;\n+                }\n+            }\n+\n+            // Second pass: fallback to general resolvers. \n+            resolvers = GetResolvers(\n+                _generalResolversManifestsRegistry,\n+                loggingContext,\n+                sdkReferenceLocation).ToList();\n+\n+            if (TryResolveSdkUsingSpecifiedResolvers(\n+                resolvers,\n+                submissionId,\n+                sdk,\n+                loggingContext,\n+                sdkReferenceLocation,\n+                solutionPath,\n+                projectPath,\n+                interactive,\n+                isRunningInVisualStudio,\n+                out sdkResult))\n+            {\n+                return sdkResult;\n+            }\n+\n+            // No resolvers resolved the sdk.\n+            return new SdkResult(sdk, null, null);\n+        }\n+\n+        private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)\n+        {\n+            // Create a sorted by priority list of resolvers. Load them if needed.\n+            List<SdkResolver> resolvers = new List<SdkResolver>();\n+            foreach (var resolverManifest in resolversManifests)\n+            {\n+                if (!_resolversDict.ContainsKey(resolverManifest))\n+                {\n+                    lock (_lockObject)\n+                    {\n+                        if (!_resolversDict.ContainsKey(resolverManifest))\n+                        {\n+                            // Loading of the needed resolvers.\n+                            MSBuildEventSource.Log.SdkResolverServiceLoadResolversStart();\n+                            IList<SdkResolver> newResolvers = _sdkResolverLoader.LoadResolversFromManifest(resolverManifest, loggingContext, sdkReferenceLocation);\n+                            _resolversDict[resolverManifest] = newResolvers;\n+                            MSBuildEventSource.Log.SdkResolverServiceLoadResolversStop(newResolvers.Count);\n+                        }\n+                    }\n+                }\n+\n+                resolvers.AddRange(_resolversDict[resolverManifest]);\n+            }\n+            return resolvers.OrderBy(t => t.Priority).ToList();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\ud83e\udd26\ud83c\udffb\u200d\u2642\ufe0f Nice catch! cc @BenVillalobos",
              "createdAt": "2022-05-17T18:54:12Z",
              "path": "src/Shared/BuildEnvironmentHelper.cs",
              "diffHunk": "@@ -526,6 +526,7 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,\n                 CurrentMSBuildConfigurationFile = string.Concat(currentMSBuildExePath, \".config\");\n                 MSBuildToolsDirectory32 = CurrentMSBuildToolsDirectory;\n                 MSBuildToolsDirectory64 = CurrentMSBuildToolsDirectory;\n+                MSBuildToolsDirectoryRoot = CurrentMSBuildToolsDirectory;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This will conflict with my instrumentation PR. Up the version preemptively? Also, can you add these to the doc?",
              "createdAt": "2022-05-17T23:14:44Z",
              "path": "src/Framework/MSBuildEventSource.cs",
              "diffHunk": "@@ -599,6 +599,30 @@ public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(int submis\n             WriteEvent(80, submissionId, sdkName, solutionPath, projectPath, success, wasResultCached);\n         }\n \n+        [Event(81, Keywords = Keywords.All)]",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This PR will go in earlier, I believe, so I'd better bump it later in the instrumentation PR. We might want to add more events during the review process, so I would not know to which number I need to up the version now. I will add a comment to our MSBuild server PR, so we do not forget to bump it there. I will add it to the doc, thank you for mentioning, I was unaware of its existence. ",
              "createdAt": "2022-05-19T15:27:28Z",
              "path": "src/Framework/MSBuildEventSource.cs",
              "diffHunk": "@@ -599,6 +599,30 @@ public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(int submis\n             WriteEvent(80, submissionId, sdkName, solutionPath, projectPath, success, wasResultCached);\n         }\n \n+        [Event(81, Keywords = Keywords.All)]",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is the name of an sdkmanifest the full path to the file, name of the file, or unique name of the resolver itself? It looks like _all of the above_ \ud83e\udd14",
              "createdAt": "2022-05-23T22:42:37Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -133,51 +169,53 @@ public int GetHashCode(DirectoryInfo value)\n             }\n         }\n \n-        private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)\n+        private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)\n         {\n             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;\n \n-            string path = null;\n-\n+            SdkResolverManifest manifest = null;\n             try\n             {\n                 // <SdkResolver>\n                 //   <Path>...</Path>\n+                //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>\n                 // </SdkResolver>\n-                var manifest = SdkResolverManifest.Load(pathToManifest);\n+                manifest = SdkResolverManifest.Load(pathToManifest);\n \n                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))\n                 {\n                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, string.Empty);\n                 }\n \n-                path = FileUtilities.FixFilePath(manifest.Path);\n+                manifest.Path = FileUtilities.FixFilePath(manifest.Path);\n             }\n             catch (XmlException e)\n             {\n                 // Note: Not logging e.ToString() as most of the information is not useful, the Message will contain what is wrong with the XML file.\n                 ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e, \"SdkResolverManifestInvalid\", pathToManifest, e.Message);\n             }\n \n-            if (!Path.IsPathRooted(path))\n+            if (!Path.IsPathRooted(manifest.Path))\n             {\n-                path = Path.Combine(manifestFolder, path);\n-                path = Path.GetFullPath(path);\n+                manifest.Path = Path.Combine(manifestFolder, manifest.Path);\n+                manifest.Path = Path.GetFullPath(manifest.Path);\n             }\n \n-            if (!TryAddAssembly(path, assembliesList))\n+            if (string.IsNullOrEmpty(manifest.Path) || !FileUtilities.FileExistsNoThrow(manifest.Path))\n             {\n-                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, path);\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, manifest.Path);\n             }\n \n+            manifestsList.Add(manifest);\n+\n             return true;\n         }\n \n-        private bool TryAddAssembly(string assemblyPath, List<string> assembliesList)\n+        private bool TryAddAssemblyManifestFromDll(string assemblyPath, List<SdkResolverManifest> manifestsList)\n         {\n             if (string.IsNullOrEmpty(assemblyPath) || !FileUtilities.FileExistsNoThrow(assemblyPath)) return false;\n \n-            assembliesList.Add(assemblyPath);\n+            manifestsList.Add(new SdkResolverManifest(assemblyPath, assemblyPath, null));",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Resolvers currently come from two possible places: They could be loaded from some dll, and they could be added directly, as default resolver, for example. I need some unique identifier for the resolvers manifests for both cases. It could be path of dll for the loaded ones, but for the default I can not use it. I might rename field somehow. Hm, or maybe I could use the path to current msbuild assembly as path, as an option, and use it as the ID.",
              "createdAt": "2022-05-24T09:04:02Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -133,51 +169,53 @@ public int GetHashCode(DirectoryInfo value)\n             }\n         }\n \n-        private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)\n+        private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)\n         {\n             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;\n \n-            string path = null;\n-\n+            SdkResolverManifest manifest = null;\n             try\n             {\n                 // <SdkResolver>\n                 //   <Path>...</Path>\n+                //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>\n                 // </SdkResolver>\n-                var manifest = SdkResolverManifest.Load(pathToManifest);\n+                manifest = SdkResolverManifest.Load(pathToManifest);\n \n                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))\n                 {\n                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, string.Empty);\n                 }\n \n-                path = FileUtilities.FixFilePath(manifest.Path);\n+                manifest.Path = FileUtilities.FixFilePath(manifest.Path);\n             }\n             catch (XmlException e)\n             {\n                 // Note: Not logging e.ToString() as most of the information is not useful, the Message will contain what is wrong with the XML file.\n                 ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e, \"SdkResolverManifestInvalid\", pathToManifest, e.Message);\n             }\n \n-            if (!Path.IsPathRooted(path))\n+            if (!Path.IsPathRooted(manifest.Path))\n             {\n-                path = Path.Combine(manifestFolder, path);\n-                path = Path.GetFullPath(path);\n+                manifest.Path = Path.Combine(manifestFolder, manifest.Path);\n+                manifest.Path = Path.GetFullPath(manifest.Path);\n             }\n \n-            if (!TryAddAssembly(path, assembliesList))\n+            if (string.IsNullOrEmpty(manifest.Path) || !FileUtilities.FileExistsNoThrow(manifest.Path))\n             {\n-                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, path);\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, manifest.Path);\n             }\n \n+            manifestsList.Add(manifest);\n+\n             return true;\n         }\n \n-        private bool TryAddAssembly(string assemblyPath, List<string> assembliesList)\n+        private bool TryAddAssemblyManifestFromDll(string assemblyPath, List<SdkResolverManifest> manifestsList)\n         {\n             if (string.IsNullOrEmpty(assemblyPath) || !FileUtilities.FileExistsNoThrow(assemblyPath)) return false;\n \n-            assembliesList.Add(assemblyPath);\n+            manifestsList.Add(new SdkResolverManifest(assemblyPath, assemblyPath, null));",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Ah, I remember why I wanted to have additional field. I needed somehow distinguish the different manifests which indeed came from the same path, and same dll - for testing. I might do two things about that. I might remove the Name field and work a bit with the tests. As an ID I would use Path in this case. Or I could add a property to manifest, that would allow to specify the name of resolver. But this is not good as well: what if in future we get a collision in names somehow. If we decide to allow customers to specify the resolvers, for example.",
              "createdAt": "2022-05-24T09:21:47Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -133,51 +169,53 @@ public int GetHashCode(DirectoryInfo value)\n             }\n         }\n \n-        private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)\n+        private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)\n         {\n             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;\n \n-            string path = null;\n-\n+            SdkResolverManifest manifest = null;\n             try\n             {\n                 // <SdkResolver>\n                 //   <Path>...</Path>\n+                //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>\n                 // </SdkResolver>\n-                var manifest = SdkResolverManifest.Load(pathToManifest);\n+                manifest = SdkResolverManifest.Load(pathToManifest);\n \n                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))\n                 {\n                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, string.Empty);\n                 }\n \n-                path = FileUtilities.FixFilePath(manifest.Path);\n+                manifest.Path = FileUtilities.FixFilePath(manifest.Path);\n             }\n             catch (XmlException e)\n             {\n                 // Note: Not logging e.ToString() as most of the information is not useful, the Message will contain what is wrong with the XML file.\n                 ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e, \"SdkResolverManifestInvalid\", pathToManifest, e.Message);\n             }\n \n-            if (!Path.IsPathRooted(path))\n+            if (!Path.IsPathRooted(manifest.Path))\n             {\n-                path = Path.Combine(manifestFolder, path);\n-                path = Path.GetFullPath(path);\n+                manifest.Path = Path.Combine(manifestFolder, manifest.Path);\n+                manifest.Path = Path.GetFullPath(manifest.Path);\n             }\n \n-            if (!TryAddAssembly(path, assembliesList))\n+            if (string.IsNullOrEmpty(manifest.Path) || !FileUtilities.FileExistsNoThrow(manifest.Path))\n             {\n-                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, path);\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, manifest.Path);\n             }\n \n+            manifestsList.Add(manifest);\n+\n             return true;\n         }\n \n-        private bool TryAddAssembly(string assemblyPath, List<string> assembliesList)\n+        private bool TryAddAssemblyManifestFromDll(string assemblyPath, List<SdkResolverManifest> manifestsList)\n         {\n             if (string.IsNullOrEmpty(assemblyPath) || !FileUtilities.FileExistsNoThrow(assemblyPath)) return false;\n \n-            assembliesList.Add(assemblyPath);\n+            manifestsList.Add(new SdkResolverManifest(assemblyPath, assemblyPath, null));",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Well, i looked at this Name & Path fields once more. Sorry, forget unique identification, all is good with it without the name at the end. There was another reason. Yeah, it is all the above and it is ok. And the reason for it is actually that this filed is for display and for logging and not for any automatic processing. ",
              "createdAt": "2022-05-24T16:55:00Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -133,51 +169,53 @@ public int GetHashCode(DirectoryInfo value)\n             }\n         }\n \n-        private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)\n+        private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)\n         {\n             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;\n \n-            string path = null;\n-\n+            SdkResolverManifest manifest = null;\n             try\n             {\n                 // <SdkResolver>\n                 //   <Path>...</Path>\n+                //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>\n                 // </SdkResolver>\n-                var manifest = SdkResolverManifest.Load(pathToManifest);\n+                manifest = SdkResolverManifest.Load(pathToManifest);\n \n                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))\n                 {\n                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, string.Empty);\n                 }\n \n-                path = FileUtilities.FixFilePath(manifest.Path);\n+                manifest.Path = FileUtilities.FixFilePath(manifest.Path);\n             }\n             catch (XmlException e)\n             {\n                 // Note: Not logging e.ToString() as most of the information is not useful, the Message will contain what is wrong with the XML file.\n                 ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e, \"SdkResolverManifestInvalid\", pathToManifest, e.Message);\n             }\n \n-            if (!Path.IsPathRooted(path))\n+            if (!Path.IsPathRooted(manifest.Path))\n             {\n-                path = Path.Combine(manifestFolder, path);\n-                path = Path.GetFullPath(path);\n+                manifest.Path = Path.Combine(manifestFolder, manifest.Path);\n+                manifest.Path = Path.GetFullPath(manifest.Path);\n             }\n \n-            if (!TryAddAssembly(path, assembliesList))\n+            if (string.IsNullOrEmpty(manifest.Path) || !FileUtilities.FileExistsNoThrow(manifest.Path))\n             {\n-                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, path);\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, manifest.Path);\n             }\n \n+            manifestsList.Add(manifest);\n+\n             return true;\n         }\n \n-        private bool TryAddAssembly(string assemblyPath, List<string> assembliesList)\n+        private bool TryAddAssemblyManifestFromDll(string assemblyPath, List<SdkResolverManifest> manifestsList)\n         {\n             if (string.IsNullOrEmpty(assemblyPath) || !FileUtilities.FileExistsNoThrow(assemblyPath)) return false;\n \n-            assembliesList.Add(assemblyPath);\n+            manifestsList.Add(new SdkResolverManifest(assemblyPath, assemblyPath, null));",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I will make comments in code to clarify this.",
              "createdAt": "2022-05-24T16:55:36Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -133,51 +169,53 @@ public int GetHashCode(DirectoryInfo value)\n             }\n         }\n \n-        private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)\n+        private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)\n         {\n             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;\n \n-            string path = null;\n-\n+            SdkResolverManifest manifest = null;\n             try\n             {\n                 // <SdkResolver>\n                 //   <Path>...</Path>\n+                //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>\n                 // </SdkResolver>\n-                var manifest = SdkResolverManifest.Load(pathToManifest);\n+                manifest = SdkResolverManifest.Load(pathToManifest);\n \n                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))\n                 {\n                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, string.Empty);\n                 }\n \n-                path = FileUtilities.FixFilePath(manifest.Path);\n+                manifest.Path = FileUtilities.FixFilePath(manifest.Path);\n             }\n             catch (XmlException e)\n             {\n                 // Note: Not logging e.ToString() as most of the information is not useful, the Message will contain what is wrong with the XML file.\n                 ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e, \"SdkResolverManifestInvalid\", pathToManifest, e.Message);\n             }\n \n-            if (!Path.IsPathRooted(path))\n+            if (!Path.IsPathRooted(manifest.Path))\n             {\n-                path = Path.Combine(manifestFolder, path);\n-                path = Path.GetFullPath(path);\n+                manifest.Path = Path.Combine(manifestFolder, manifest.Path);\n+                manifest.Path = Path.GetFullPath(manifest.Path);\n             }\n \n-            if (!TryAddAssembly(path, assembliesList))\n+            if (string.IsNullOrEmpty(manifest.Path) || !FileUtilities.FileExistsNoThrow(manifest.Path))\n             {\n-                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, path);\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, manifest.Path);\n             }\n \n+            manifestsList.Add(manifest);\n+\n             return true;\n         }\n \n-        private bool TryAddAssembly(string assemblyPath, List<string> assembliesList)\n+        private bool TryAddAssemblyManifestFromDll(string assemblyPath, List<SdkResolverManifest> manifestsList)\n         {\n             if (string.IsNullOrEmpty(assemblyPath) || !FileUtilities.FileExistsNoThrow(assemblyPath)) return false;\n \n-            assembliesList.Add(assemblyPath);\n+            manifestsList.Add(new SdkResolverManifest(assemblyPath, assemblyPath, null));",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: The naming within SdkResolverManifest is somewhat confusing, I would have expected `filePath` to corrrespond to `Path`, not `Name`.",
              "createdAt": "2022-05-23T22:43:45Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs",
              "diffHunk": "@@ -47,22 +82,42 @@ internal static SdkResolverManifest Load(string filePath)\n             return null;\n         }\n \n-        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader)\n+        // This parsing code is very specific and not forward compatible, but since resolvers generally ship in the same release vehicle as MSBuild itself, only backward compatibility is required.\n+        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader, string filePath)\n         {\n-            SdkResolverManifest manifest = new SdkResolverManifest();\n+            SdkResolverManifest manifest = new SdkResolverManifest(filePath);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Sometimes, for test cases and for default cases it is indeed name. For those resolvers which are loaded from dll, the path fully describes it.",
              "createdAt": "2022-05-24T09:06:25Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs",
              "diffHunk": "@@ -47,22 +82,42 @@ internal static SdkResolverManifest Load(string filePath)\n             return null;\n         }\n \n-        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader)\n+        // This parsing code is very specific and not forward compatible, but since resolvers generally ship in the same release vehicle as MSBuild itself, only backward compatibility is required.\n+        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader, string filePath)\n         {\n-            SdkResolverManifest manifest = new SdkResolverManifest();\n+            SdkResolverManifest manifest = new SdkResolverManifest(filePath);",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: Do we ever need `Path` without it being ran through `FileUtilities.FixFilePath`? Looks like it could be file-path-fixed during the `Load`.",
              "createdAt": "2022-05-23T23:24:15Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -133,51 +169,53 @@ public int GetHashCode(DirectoryInfo value)\n             }\n         }\n \n-        private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)\n+        private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)\n         {\n             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;\n \n-            string path = null;\n-\n+            SdkResolverManifest manifest = null;\n             try\n             {\n                 // <SdkResolver>\n                 //   <Path>...</Path>\n+                //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>\n                 // </SdkResolver>\n-                var manifest = SdkResolverManifest.Load(pathToManifest);\n+                manifest = SdkResolverManifest.Load(pathToManifest);\n \n                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))\n                 {\n                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, string.Empty);\n                 }\n \n-                path = FileUtilities.FixFilePath(manifest.Path);\n+                manifest.Path = FileUtilities.FixFilePath(manifest.Path);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Reading through the code I get the feeling that a lot of the path-fixing logic could be done inside `SdkResolverManifest.Load(pathToManifest);`",
              "createdAt": "2022-05-23T23:27:03Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -133,51 +169,53 @@ public int GetHashCode(DirectoryInfo value)\n             }\n         }\n \n-        private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)\n+        private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)\n         {\n             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;\n \n-            string path = null;\n-\n+            SdkResolverManifest manifest = null;\n             try\n             {\n                 // <SdkResolver>\n                 //   <Path>...</Path>\n+                //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>\n                 // </SdkResolver>\n-                var manifest = SdkResolverManifest.Load(pathToManifest);\n+                manifest = SdkResolverManifest.Load(pathToManifest);\n \n                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))\n                 {\n                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, string.Empty);\n                 }\n \n-                path = FileUtilities.FixFilePath(manifest.Path);\n+                manifest.Path = FileUtilities.FixFilePath(manifest.Path);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I did not have a goal to improve this function actually. These changes were only needed so that I divide loading resolvers into two steps - getting a valid manifest for all of them and loading them. I agree - it seems that we never need to have a path without it being \"fixed\". Should I spend any time to move the path fixing logic one level below? I am not sure, here is not a bad place also. ",
              "createdAt": "2022-05-24T09:34:32Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs",
              "diffHunk": "@@ -133,51 +169,53 @@ public int GetHashCode(DirectoryInfo value)\n             }\n         }\n \n-        private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)\n+        private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)\n         {\n             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;\n \n-            string path = null;\n-\n+            SdkResolverManifest manifest = null;\n             try\n             {\n                 // <SdkResolver>\n                 //   <Path>...</Path>\n+                //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>\n                 // </SdkResolver>\n-                var manifest = SdkResolverManifest.Load(pathToManifest);\n+                manifest = SdkResolverManifest.Load(pathToManifest);\n \n                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))\n                 {\n                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), \"SdkResolverDllInManifestMissing\", pathToManifest, string.Empty);\n                 }\n \n-                path = FileUtilities.FixFilePath(manifest.Path);\n+                manifest.Path = FileUtilities.FixFilePath(manifest.Path);",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you explain the logic here? It looks like a hopeful first attempt, followed by a guaranteed-but-slower second attempt.",
              "createdAt": "2022-05-23T23:44:56Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,155 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = new();\n+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n+            {\n+                try\n+                {\n+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))\n+                    {\n+                        matchingResolversManifests.Add(manifest);\n+                    }\n+                }\n+                catch (RegexMatchTimeoutException ex)\n+                {\n+                    ErrorUtilities.ThrowInternalError(\"Timeout exceeded matching sdk \\\"{0}\\\" to <ResolvableSdkPattern> from sdk resolver manifest {1}.\", ex, sdk.Name, manifest.Name);\n+                }\n+            }\n+\n+            List<SdkResolver> resolvers;\n+            SdkResult sdkResult;\n+            if (matchingResolversManifests.Count != 0)\n+            {\n+                // First pass.\n+                resolvers = GetResolvers(matchingResolversManifests, loggingContext, sdkReferenceLocation);\n+\n+                if (TryResolveSdkUsingSpecifiedResolvers(\n+                    resolvers,\n+                    submissionId,\n+                    sdk,\n+                    loggingContext,\n+                    sdkReferenceLocation,\n+                    solutionPath,\n+                    projectPath,\n+                    interactive,\n+                    isRunningInVisualStudio,\n+                    out sdkResult))\n+                {\n+                    return sdkResult;\n+                }\n+            }\n+\n+            // Second pass: fallback to general resolvers. \n+            resolvers = GetResolvers(\n+                _generalResolversManifestsRegistry,\n+                loggingContext,\n+                sdkReferenceLocation).ToList();\n+\n+            if (TryResolveSdkUsingSpecifiedResolvers(\n+                resolvers,\n+                submissionId,\n+                sdk,\n+                loggingContext,\n+                sdkReferenceLocation,\n+                solutionPath,\n+                projectPath,\n+                interactive,\n+                isRunningInVisualStudio,\n+                out sdkResult))\n+            {\n+                return sdkResult;\n+            }\n+\n+            // No resolvers resolved the sdk.\n+            return new SdkResult(sdk, null, null);\n+        }\n+\n+        private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)\n+        {\n+            // Create a sorted by priority list of resolvers. Load them if needed.\n+            List<SdkResolver> resolvers = new List<SdkResolver>();\n+            foreach (var resolverManifest in resolversManifests)\n+            {\n+                if (!_resolversDict.TryGetValue(resolverManifest, out IList<SdkResolver> newResolvers))\n+                {\n+                    lock (_lockObject)\n+                    {\n+                        if (!_resolversDict.TryGetValue(resolverManifest, out newResolvers))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "The second check happens after a lock in the case of race condition. It prevents to have a second load when another thread already loaded those resolvers between the first check and the lock.",
              "createdAt": "2022-05-24T09:10:14Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,155 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = new();\n+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n+            {\n+                try\n+                {\n+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))\n+                    {\n+                        matchingResolversManifests.Add(manifest);\n+                    }\n+                }\n+                catch (RegexMatchTimeoutException ex)\n+                {\n+                    ErrorUtilities.ThrowInternalError(\"Timeout exceeded matching sdk \\\"{0}\\\" to <ResolvableSdkPattern> from sdk resolver manifest {1}.\", ex, sdk.Name, manifest.Name);\n+                }\n+            }\n+\n+            List<SdkResolver> resolvers;\n+            SdkResult sdkResult;\n+            if (matchingResolversManifests.Count != 0)\n+            {\n+                // First pass.\n+                resolvers = GetResolvers(matchingResolversManifests, loggingContext, sdkReferenceLocation);\n+\n+                if (TryResolveSdkUsingSpecifiedResolvers(\n+                    resolvers,\n+                    submissionId,\n+                    sdk,\n+                    loggingContext,\n+                    sdkReferenceLocation,\n+                    solutionPath,\n+                    projectPath,\n+                    interactive,\n+                    isRunningInVisualStudio,\n+                    out sdkResult))\n+                {\n+                    return sdkResult;\n+                }\n+            }\n+\n+            // Second pass: fallback to general resolvers. \n+            resolvers = GetResolvers(\n+                _generalResolversManifestsRegistry,\n+                loggingContext,\n+                sdkReferenceLocation).ToList();\n+\n+            if (TryResolveSdkUsingSpecifiedResolvers(\n+                resolvers,\n+                submissionId,\n+                sdk,\n+                loggingContext,\n+                sdkReferenceLocation,\n+                solutionPath,\n+                projectPath,\n+                interactive,\n+                isRunningInVisualStudio,\n+                out sdkResult))\n+            {\n+                return sdkResult;\n+            }\n+\n+            // No resolvers resolved the sdk.\n+            return new SdkResult(sdk, null, null);\n+        }\n+\n+        private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)\n+        {\n+            // Create a sorted by priority list of resolvers. Load them if needed.\n+            List<SdkResolver> resolvers = new List<SdkResolver>();\n+            foreach (var resolverManifest in resolversManifests)\n+            {\n+                if (!_resolversDict.TryGetValue(resolverManifest, out IList<SdkResolver> newResolvers))\n+                {\n+                    lock (_lockObject)\n+                    {\n+                        if (!_resolversDict.TryGetValue(resolverManifest, out newResolvers))",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "@BenVillalobos this is the [double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking) pattern; we use it in quite a few places. \"hopeful first attempt, followed by a guaranteed-but-slower second attempt\" is a good description of how it works, but there's a subtlety: the `lock` ensures that the second part is done only once:\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    autonumber\r\n    Thread1->>Thread1: TryGet\r\n    Thread2->>Thread2: TryGet\r\n    Thread1->>+Thread1: Lock\r\n    Thread2->>Thread1: Lock\r\n    Thread1->>Thread1: TryGet\r\n    Thread1->>Thread1: Do actual work\r\n\r\n    Thread1->>-Thread2: Lock\r\n\r\n    Thread2->>Thread2: TryGet\r\n\r\n    Thread2->>Thread2: return\r\n    Thread1->>Thread1: return\r\n\r\n```",
              "createdAt": "2022-05-24T14:34:08Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,155 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = new();\n+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n+            {\n+                try\n+                {\n+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))\n+                    {\n+                        matchingResolversManifests.Add(manifest);\n+                    }\n+                }\n+                catch (RegexMatchTimeoutException ex)\n+                {\n+                    ErrorUtilities.ThrowInternalError(\"Timeout exceeded matching sdk \\\"{0}\\\" to <ResolvableSdkPattern> from sdk resolver manifest {1}.\", ex, sdk.Name, manifest.Name);\n+                }\n+            }\n+\n+            List<SdkResolver> resolvers;\n+            SdkResult sdkResult;\n+            if (matchingResolversManifests.Count != 0)\n+            {\n+                // First pass.\n+                resolvers = GetResolvers(matchingResolversManifests, loggingContext, sdkReferenceLocation);\n+\n+                if (TryResolveSdkUsingSpecifiedResolvers(\n+                    resolvers,\n+                    submissionId,\n+                    sdk,\n+                    loggingContext,\n+                    sdkReferenceLocation,\n+                    solutionPath,\n+                    projectPath,\n+                    interactive,\n+                    isRunningInVisualStudio,\n+                    out sdkResult))\n+                {\n+                    return sdkResult;\n+                }\n+            }\n+\n+            // Second pass: fallback to general resolvers. \n+            resolvers = GetResolvers(\n+                _generalResolversManifestsRegistry,\n+                loggingContext,\n+                sdkReferenceLocation).ToList();\n+\n+            if (TryResolveSdkUsingSpecifiedResolvers(\n+                resolvers,\n+                submissionId,\n+                sdk,\n+                loggingContext,\n+                sdkReferenceLocation,\n+                solutionPath,\n+                projectPath,\n+                interactive,\n+                isRunningInVisualStudio,\n+                out sdkResult))\n+            {\n+                return sdkResult;\n+            }\n+\n+            // No resolvers resolved the sdk.\n+            return new SdkResult(sdk, null, null);\n+        }\n+\n+        private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)\n+        {\n+            // Create a sorted by priority list of resolvers. Load them if needed.\n+            List<SdkResolver> resolvers = new List<SdkResolver>();\n+            foreach (var resolverManifest in resolversManifests)\n+            {\n+                if (!_resolversDict.TryGetValue(resolverManifest, out IList<SdkResolver> newResolvers))\n+                {\n+                    lock (_lockObject)\n+                    {\n+                        if (!_resolversDict.TryGetValue(resolverManifest, out newResolvers))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I had no idea that this pattern has some naming. Yeah, here I use it exactly for the lazy load. So, most of the cases we just would quickly get the result.",
              "createdAt": "2022-05-24T17:10:51Z",
              "path": "src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs",
              "diffHunk": "@@ -92,20 +112,155 @@ public virtual void ClearCaches()\n         /// <inheritdoc cref=\"ISdkResolverService.ResolveSdk\"/>\n         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n         {\n-            // Lazy initialize the SDK resolvers\n-            if (_resolvers == null)\n+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))\n+            {\n+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+            else\n+            {\n+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);\n+            }\n+        }\n+\n+        /// <remarks>\n+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.\n+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.\n+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.\n+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.\n+        /// </remarks>\n+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)\n+        {\n+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)\n+            {\n+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);\n+            }\n+\n+            // Pick up the matching specific resolvers from the list of resolvers.\n+            List<SdkResolverManifest> matchingResolversManifests = new();\n+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)\n+            {\n+                try\n+                {\n+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))\n+                    {\n+                        matchingResolversManifests.Add(manifest);\n+                    }\n+                }\n+                catch (RegexMatchTimeoutException ex)\n+                {\n+                    ErrorUtilities.ThrowInternalError(\"Timeout exceeded matching sdk \\\"{0}\\\" to <ResolvableSdkPattern> from sdk resolver manifest {1}.\", ex, sdk.Name, manifest.Name);\n+                }\n+            }\n+\n+            List<SdkResolver> resolvers;\n+            SdkResult sdkResult;\n+            if (matchingResolversManifests.Count != 0)\n+            {\n+                // First pass.\n+                resolvers = GetResolvers(matchingResolversManifests, loggingContext, sdkReferenceLocation);\n+\n+                if (TryResolveSdkUsingSpecifiedResolvers(\n+                    resolvers,\n+                    submissionId,\n+                    sdk,\n+                    loggingContext,\n+                    sdkReferenceLocation,\n+                    solutionPath,\n+                    projectPath,\n+                    interactive,\n+                    isRunningInVisualStudio,\n+                    out sdkResult))\n+                {\n+                    return sdkResult;\n+                }\n+            }\n+\n+            // Second pass: fallback to general resolvers. \n+            resolvers = GetResolvers(\n+                _generalResolversManifestsRegistry,\n+                loggingContext,\n+                sdkReferenceLocation).ToList();\n+\n+            if (TryResolveSdkUsingSpecifiedResolvers(\n+                resolvers,\n+                submissionId,\n+                sdk,\n+                loggingContext,\n+                sdkReferenceLocation,\n+                solutionPath,\n+                projectPath,\n+                interactive,\n+                isRunningInVisualStudio,\n+                out sdkResult))\n+            {\n+                return sdkResult;\n+            }\n+\n+            // No resolvers resolved the sdk.\n+            return new SdkResult(sdk, null, null);\n+        }\n+\n+        private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)\n+        {\n+            // Create a sorted by priority list of resolvers. Load them if needed.\n+            List<SdkResolver> resolvers = new List<SdkResolver>();\n+            foreach (var resolverManifest in resolversManifests)\n+            {\n+                if (!_resolversDict.TryGetValue(resolverManifest, out IList<SdkResolver> newResolvers))\n+                {\n+                    lock (_lockObject)\n+                    {\n+                        if (!_resolversDict.TryGetValue(resolverManifest, out newResolvers))",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      }
    ]
  }
}