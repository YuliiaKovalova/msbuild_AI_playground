{
  "number": 4327,
  "title": "[Static graph] Changes to enable building roslyn",
  "body": "Things needed to build `roslyn/Compilers.sln` with no changes to the roslyn repo.",
  "state": "MERGED",
  "createdAt": "2019-04-20T01:00:16Z",
  "updatedAt": "2020-12-30T22:53:47Z",
  "closedAt": "2019-06-05T20:44:01Z",
  "mergedAt": "2019-06-05T20:44:01Z",
  "additions": 1137,
  "deletions": 492,
  "changedFiles": 12,
  "headRefName": "roslynStaticGraph",
  "isDraft": false,
  "author": {
    "login": "cdmihai"
  },
  "milestone": {
    "title": "MSBuild 16.2"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "7cf37de765d938845b370f55039dc41c7a8bc18c",
          "message": "Make node edge operations bidirectional",
          "committedDate": "2019-05-23T17:40:32Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a4ed682fe666206daf0fddece89fa1a8f7c3fc25",
          "message": "Documentation",
          "committedDate": "2019-05-23T17:40:32Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "467853d3f3dcc65a558f535ede271e2ba8dc1a11",
          "message": "Deduplicate edges to same node",
          "committedDate": "2019-05-23T17:40:33Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "967ab78b4650b5f4a571afb6d269aa37653cd24c",
          "message": "Add reference spec for Publish\n\nupdate",
          "committedDate": "2019-05-23T17:40:33Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "49c4484dbd13cc841142ee743f5953620d25ca70",
          "message": "Extract graph construction to separate class",
          "committedDate": "2019-05-23T17:40:33Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "54d21f80f0f2389fed1a9e539e3b7970995d8564",
          "message": "Read ProjectReferenceItem.Targets\n\nPreserve edges from graph construction in order to retrieve ProjectReferenceItem.Targets at target computation time.",
          "committedDate": "2019-05-23T17:40:35Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8e52f2d44334dabef105392240d5fcbb24525984",
          "message": "Add Debugger Display",
          "committedDate": "2019-05-23T17:40:36Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f5e00979db6e9098917d71afc16b78a887341f9f",
          "message": "update public api",
          "committedDate": "2019-05-23T17:40:37Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5f8b4eff4c6be43efb4336459f8e2c347b7a42e5",
          "message": "Feedback\n\nCo-Authored-By: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2019-05-23T17:40:37Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "36a14ff8d4a7cfe1a5f1a9844684ac305b764bcd",
          "message": "do not use MAXPATH to estimate string size",
          "committedDate": "2019-05-23T17:40:37Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "07d163b2330ddd1709ef46adfea30ecd1a4e9338",
          "message": "avoid manual iteration",
          "committedDate": "2019-05-23T17:40:38Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "37193b7ea06c62b4ae6d409f556babc41f2e0778",
          "message": "Trim excess elements",
          "committedDate": "2019-05-23T17:40:38Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "67b7bda6911fd53db7e17fd96e20b3be5f38e959",
          "message": "add new line",
          "committedDate": "2019-05-23T17:40:38Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fa369eea6cc5b41393d690123bcb784212841d44",
          "message": "skip correct count of elements",
          "committedDate": "2019-05-23T17:40:38Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ba3ce60c0eb06d08200f2feb02b8a6d2d2b4bce4",
          "message": "update comment",
          "committedDate": "2019-05-23T17:40:38Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0d5624be0077f4c30f9988d61c0bd616b0d160b1",
          "message": "Replace ToString with private method",
          "committedDate": "2019-05-23T17:40:38Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9349bf9c084881dd50ff247f48e33ba3124a3727",
          "message": "make parameter private",
          "committedDate": "2019-05-23T17:40:38Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "cc @AndyGerlicher @smera ",
        "createdAt": "2019-04-20T01:05:59Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "> Can you lay out what the problems were when building Roslyn that you've resolved here? That would help place the review.\r\n> \r\n> The commit `Read ProjectReferenceItem.Targets` is not landing for me clearly. I think I understand the goal but not the implementation.\r\n\r\nSome Roslyn projects set the `Targets` metadata on certain `ProjectReference` items. Static graph did not initially take this metadata into account, and therefore it inferred the wrong entry targets for the references which had that metadata set. So then, in addition to the `.default` symbol I also added `.projectReferenceTargetsOrDefault` and updated the target protocol to use it instead of `.default`.\r\n\r\nThe actual change implies remembering the project reference metadata from graph construction, so it can be read by `ProjectGraph.GetTargetLists` when it infers entry targets. ",
        "createdAt": "2019-05-21T20:58:17Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "@livarcocc @rainersigwald, I responded to all feedback",
        "createdAt": "2019-05-23T16:45:13Z",
        "author": {
          "login": "cdmihai"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                ErrorUtilities.VerifyThrow(reference._referencingProjects.Contains(this), \"references should point to the nodes referencing them\");\r\n```",
              "createdAt": "2019-05-21T19:15:10Z",
              "path": "src/Build/Graph/ProjectGraphNode.cs",
              "diffHunk": "@@ -35,12 +39,34 @@ internal ProjectGraphNode(ProjectInstance projectInstance)\n         /// </summary>\n         public ProjectInstance ProjectInstance { get; }\n \n-        internal void AddProjectReference(ProjectGraphNode projectGraphNode) => _projectReferences.Add(projectGraphNode);\n+        public override string ToString()\n+        {\n+            var truncatedProjectFile = FileUtilities.TruncatePathToTrailingSegments(ProjectInstance.FullPath, 2);\n \n-        internal void RemoveReferences() => _projectReferences.Clear();\n+            return\n+                $\"{truncatedProjectFile}, #GlobalProps={ProjectInstance.GlobalProperties.Count}, #Props={ProjectInstance.Properties.Count}, #Items={ProjectInstance.Items.Count}, #in={ReferencingProjects.Count}, #out={ProjectReferences.Count}\";\n+        }\n \n-        internal void RemoveProjectReference(ProjectGraphNode projectGraphNode) => _projectReferences.Remove(projectGraphNode);\n+        internal void AddProjectReference(ProjectGraphNode reference, ProjectItemInstance projectReferenceItem, GraphBuilder.GraphEdges edges)\n+        {\n+            _projectReferences.Add(reference);\n+            reference._referencingProjects.Add(this);\n+\n+            // First edge wins, in accordance with vanilla msbuild behaviour when multiple msbuild tasks call into the same logical project\n+            edges[(this, reference)] = projectReferenceItem;\n+        }\n \n-        internal void AddReferencingProject(ProjectGraphNode projectGraphNode) => _referencingProjects.Add(projectGraphNode);\n+        internal void RemoveReferences(GraphBuilder.GraphEdges edges)\n+        {\n+            foreach (var reference in _projectReferences)\n+            {\n+                ErrorUtilities.VerifyThrow(reference._referencingProjects.Contains(this), \"references should point the nodes referencing them\");",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This data type raises some concerns for me. Can you expand on why it's needed?",
              "createdAt": "2019-05-21T19:25:53Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -0,0 +1,397 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal class GraphBuilder\n+    {\n+        private ProjectInterpretation ProjectInterpretation { get; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> RootNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }\n+\n+        public GraphEdges Edges { get; private set; }\n+\n+        public GraphBuilder(ProjectInterpretation projectInterpretation)\n+        {\n+            ProjectInterpretation = projectInterpretation;\n+        }\n+\n+        public void BuildGraph(\n+            IEnumerable<ProjectGraphEntryPoint> entryPoints,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory\n+            )\n+        {\n+            var entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(entryPoints);\n+\n+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();\n+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();\n+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();\n+\n+            foreach (var entryPoint in entryPointConfigurationMetadata)\n+            {\n+                projectsToEvaluate.Enqueue(entryPoint);\n+            }\n+\n+            if (FindGraphNodes(\n+                projectsToEvaluate,\n+                projectCollection,\n+                tasksInProgress,\n+                projectInstanceFactory,\n+                ProjectInterpretation,\n+                allParsedProjects,\n+                out var exceptions))\n+            {\n+                Edges = new GraphEdges();\n+\n+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, ProjectInterpretation, allParsedProjects, Edges);\n+\n+                ProjectInterpretation.PostProcess(allParsedProjects, this);\n+\n+                EntryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();\n+                RootNodes = GetGraphRoots(EntryPointNodes);\n+                ProjectNodes = allParsedProjects.Values.ToList();\n+            }\n+            else\n+            {\n+                throw new AggregateException(exceptions);\n+            }\n+\n+            IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection<ProjectGraphNode> entryPointNodes)\n+            {\n+                var graphRoots = new List<ProjectGraphNode>(entryPointNodes.Count);\n+\n+                foreach (var entryPointNode in entryPointNodes)\n+                {\n+                    if (entryPointNode.ReferencingProjects.Count == 0)\n+                    {\n+                        graphRoots.Add(entryPointNode);\n+                    }\n+                }\n+\n+                return graphRoots;\n+            }\n+        }\n+\n+        private static List<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable<ProjectGraphEntryPoint> entryPoints)\n+        {\n+            {\n+                var entryPointConfigurationMetadata = new List<ConfigurationMetadata>();\n+\n+                foreach (var entryPoint in entryPoints)\n+                {\n+                    var globalPropertyDictionary = CreatePropertyDictionary(entryPoint.GlobalProperties);\n+\n+                    AddGraphBuildGlobalVariable(globalPropertyDictionary);\n+\n+                    var configurationMetadata = new ConfigurationMetadata(FileUtilities.NormalizePath(entryPoint.ProjectFile), globalPropertyDictionary);\n+                    entryPointConfigurationMetadata.Add(configurationMetadata);\n+                }\n+                return entryPointConfigurationMetadata;\n+            }\n+\n+            void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> globalPropertyDictionary)\n+            {\n+                if (globalPropertyDictionary.GetProperty(PropertyNames.IsGraphBuild) == null)\n+                {\n+                    globalPropertyDictionary[PropertyNames.IsGraphBuild] = ProjectPropertyInstance.Create(PropertyNames.IsGraphBuild, \"true\");\n+                }\n+            }\n+        }\n+\n+        /// <remarks>\n+        ///     Traverse the found nodes and add edges.\n+        ///     Maintain the state of each node (InProcess and Processed) to detect cycles.\n+        ///     Returns false if cycles were detected.\n+        /// </remarks>\n+        private void CreateEdgesAndDetectCycles(\n+            List<ConfigurationMetadata> entryPointConfigurationMetadata,\n+            ProjectInterpretation sdkInfo,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,\n+            GraphEdges edges)\n+        {\n+            var nodeStates = new Dictionary<ProjectGraphNode, NodeVisitationState>();\n+\n+            foreach (var entrypointConfig in entryPointConfigurationMetadata)\n+            {\n+                var entryPointNode = allParsedProjects[entrypointConfig];\n+\n+                if (!nodeStates.ContainsKey(entryPointNode))\n+                {\n+                    CreateEdgesAndDetectCyclesForRoot(entryPointNode, entrypointConfig, nodeStates);\n+                }\n+                else\n+                {\n+                    ErrorUtilities.VerifyThrow(\n+                        nodeStates[entryPointNode] == NodeVisitationState.Processed,\n+                        \"entrypoints should get processed after a call to detect cycles\");\n+                }\n+            }\n+\n+            return;\n+\n+            (bool success, List<string> projectsInCycle) CreateEdgesAndDetectCyclesForRoot(\n+                ProjectGraphNode node,\n+                ConfigurationMetadata nodeConfig,\n+                IDictionary<ProjectGraphNode, NodeVisitationState> nodeState)\n+            {\n+                nodeState[node] = NodeVisitationState.InProcess;\n+\n+                foreach (var (referenceConfig, projectReferenceItem) in sdkInfo.GetReferences(node.ProjectInstance))\n+                {\n+                    var referenceNode = allParsedProjects[referenceConfig];\n+\n+                    if (nodeState.TryGetValue(referenceNode, out var projectReferenceNodeState))\n+                    {\n+                        // Because this is a depth-first search, we should only encounter new nodes or nodes whose subgraph has been completely processed.\n+                        // If we encounter a node that is currently being processed(InProcess state), it must be one of the ancestors in a circular dependency.\n+                        if (projectReferenceNodeState == NodeVisitationState.InProcess)\n+                        {\n+                            if (node.Equals(referenceNode))\n+                            {\n+                                // the project being evaluated has a reference to itself\n+                                var selfReferencingProjectString =\n+                                    FormatCircularDependencyError(new List<string> {node.ProjectInstance.FullPath, node.ProjectInstance.FullPath});\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        selfReferencingProjectString));\n+                            }\n+                            // the project being evaluated has a circular dependency involving multiple projects\n+                            // add this project to the list of projects involved in cycle \n+                            var projectsInCycle = new List<string> {referenceConfig.ProjectFullPath};\n+                            return (false, projectsInCycle);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        // recursively process newly discovered references\n+                        var loadReference = CreateEdgesAndDetectCyclesForRoot(referenceNode, referenceConfig, nodeState);\n+                        if (!loadReference.success)\n+                        {\n+                            if (loadReference.projectsInCycle[0].Equals(node.ProjectInstance.FullPath))\n+                            {\n+                                // we have reached the nth project in the cycle, form error message and throw\n+                                loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                                loadReference.projectsInCycle.Add(node.ProjectInstance.FullPath);\n+                                var errorMessage = FormatCircularDependencyError(loadReference.projectsInCycle);\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        errorMessage));\n+                            }\n+                            // this is one of the projects in the circular dependency\n+                            // update the list of projects in cycle and return the list to the caller\n+                            loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                            return (false, loadReference.projectsInCycle);\n+                        }\n+                    }\n+\n+                    node.AddProjectReference(referenceNode, projectReferenceItem, edges);\n+                }\n+\n+                nodeState[node] = NodeVisitationState.Processed;\n+                return (true, null);\n+            }\n+        }\n+\n+        private ProjectGraphNode CreateNewNode(\n+            ConfigurationMetadata configurationMetadata,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects)\n+        {\n+            // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n+            var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n+\n+            var projectInstance = projectInstanceFactory(\n+                configurationMetadata.ProjectFullPath,\n+                globalProperties,\n+                projectCollection);\n+            if (projectInstance == null)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n+            }\n+\n+            var graphNode = new ProjectGraphNode(\n+                projectInstance);\n+            allParsedProjects[configurationMetadata] = graphNode;\n+            return graphNode;\n+        }\n+\n+        /// <summary>\n+        ///     Load a graph with root node at entryProjectFile\n+        ///     Maintain a queue of projects to be processed and evaluate projects in parallel\n+        ///     Returns false if loading the graph is not successful\n+        /// </summary>\n+        private bool FindGraphNodes(\n+            ConcurrentQueue<ConfigurationMetadata> projectsToEvaluate,\n+            ProjectCollection projectCollection,\n+            ConcurrentDictionary<ConfigurationMetadata, object> tasksInProgress,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory,\n+            ProjectInterpretation projectInterpretation,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,\n+            out List<Exception> exceptions)\n+        {\n+            var exceptionsInTasks = new ConcurrentBag<Exception>();\n+            var evaluationWaitHandle = new AutoResetEvent(false);\n+\n+            while (projectsToEvaluate.Count != 0 || tasksInProgress.Count != 0)\n+            {\n+                ConfigurationMetadata projectToEvaluate;\n+                if (projectsToEvaluate.Count != 0)\n+                {\n+                    projectToEvaluate = projectsToEvaluate.Dequeue();\n+                    var task = new Task(\n+                        () =>\n+                        {\n+                            var parsedProject = CreateNewNode(projectToEvaluate, projectCollection, projectInstanceFactory, allParsedProjects);\n+\n+                            foreach (var (referenceConfig, _) in projectInterpretation.GetReferences(parsedProject.ProjectInstance))\n+                            {\n+                                /*todo: fix the following double check-then-act concurrency bug: one thread can pass the two checks, loose context,\n+                             meanwhile another thread passes the same checks with the same data and inserts its reference. The initial thread regains context\n+                             and duplicates the information, leading to wasted work\n+                             */\n+                                if (!tasksInProgress.ContainsKey(referenceConfig))\n+                                {\n+                                    if (!allParsedProjects.ContainsKey(referenceConfig))\n+                                    {\n+                                        projectsToEvaluate.Enqueue(referenceConfig);\n+                                        evaluationWaitHandle.Set();\n+                                    }\n+                                }\n+                            }\n+                        });\n+\n+                    if (tasksInProgress.TryAdd(projectToEvaluate, null))\n+                    {\n+                        // once the task completes, remove it from tasksInProgress using a chained task\n+                        // signal the wait handle to process new projects that have been discovered by this task or exit if all projects have been evaluated\n+                        task.ContinueWith(\n+                            _ =>\n+                            {\n+                                if (task.IsFaulted)\n+                                {\n+                                    exceptionsInTasks.Add(task.Exception.InnerException);\n+                                }\n+                                tasksInProgress.TryRemove(projectToEvaluate, out var _);\n+                                evaluationWaitHandle.Set();\n+                            });\n+                        task.Start();\n+                    }\n+                }\n+                else\n+                {\n+                    // if projectsToEvaluate is empty but there are tasks in progress, there is nothing to do till a task completes and discovers new projects\n+                    // wait till a task completes and sends a signal\n+                    evaluationWaitHandle.WaitOne();\n+                }\n+            }\n+\n+            if (exceptionsInTasks.Count != 0)\n+            {\n+                exceptions = exceptionsInTasks.ToList();\n+                return false;\n+            }\n+\n+            exceptions = null;\n+            return true;\n+        }\n+\n+        internal static string FormatCircularDependencyError(List<string> projectsInCycle)\n+        {\n+            const int MAX_PATH = 260;\n+            var errorMessage = new StringBuilder(projectsInCycle.Count * MAX_PATH);\n+            errorMessage.AppendLine();\n+            for (var i = projectsInCycle.Count - 1; i >= 0; i--)\n+            {\n+                if (i != 0)\n+                {\n+                    errorMessage.Append(projectsInCycle[i])\n+                        .Append(\" ->\")\n+                        .AppendLine();\n+                }\n+                else\n+                {\n+                    errorMessage.Append(projectsInCycle[i]);\n+                }\n+            }\n+\n+            return errorMessage.ToString();\n+        }\n+\n+        private static PropertyDictionary<ProjectPropertyInstance> CreatePropertyDictionary(IDictionary<string, string> properties)\n+        {\n+            PropertyDictionary<ProjectPropertyInstance> propertyDictionary;\n+            if (properties == null)\n+            {\n+                propertyDictionary = new PropertyDictionary<ProjectPropertyInstance>(0);\n+            }\n+            else\n+            {\n+                propertyDictionary = new PropertyDictionary<ProjectPropertyInstance>(properties.Count);\n+                foreach (var entry in properties)\n+                {\n+                    propertyDictionary[entry.Key] = ProjectPropertyInstance.Create(entry.Key, entry.Value);\n+                }\n+            }\n+\n+            return propertyDictionary;\n+        }\n+\n+        internal class GraphEdges\n+        {\n+            private ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstance> ReferenceItems =\n+                new ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstance>();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "The change requires keeping extra state for each edge (the project reference metadata for each reference). There's two ways to keep it:\r\n1. Enhance the OM by adding a GraphEdge class, and then have ProjectGraphNode reference lists of GraphEdge objects, rather than directly referencing parent/child ProjectGraphNodes\r\n2. Hack it out by introducing a dictionary.\r\n\r\n1 implies either changing the public API to add GraphEdge, or making it private by adding a dictionary on each node, which is memory wasteful. Since it's not clear whether anyone would find the extra public API useful, I decided to just go with 2. and keep everything private. If, in the future, somebody needs to access this data, then we can spend more energy in designing some cute looking API.",
              "createdAt": "2019-05-21T21:03:59Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -0,0 +1,397 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal class GraphBuilder\n+    {\n+        private ProjectInterpretation ProjectInterpretation { get; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> RootNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }\n+\n+        public GraphEdges Edges { get; private set; }\n+\n+        public GraphBuilder(ProjectInterpretation projectInterpretation)\n+        {\n+            ProjectInterpretation = projectInterpretation;\n+        }\n+\n+        public void BuildGraph(\n+            IEnumerable<ProjectGraphEntryPoint> entryPoints,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory\n+            )\n+        {\n+            var entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(entryPoints);\n+\n+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();\n+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();\n+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();\n+\n+            foreach (var entryPoint in entryPointConfigurationMetadata)\n+            {\n+                projectsToEvaluate.Enqueue(entryPoint);\n+            }\n+\n+            if (FindGraphNodes(\n+                projectsToEvaluate,\n+                projectCollection,\n+                tasksInProgress,\n+                projectInstanceFactory,\n+                ProjectInterpretation,\n+                allParsedProjects,\n+                out var exceptions))\n+            {\n+                Edges = new GraphEdges();\n+\n+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, ProjectInterpretation, allParsedProjects, Edges);\n+\n+                ProjectInterpretation.PostProcess(allParsedProjects, this);\n+\n+                EntryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();\n+                RootNodes = GetGraphRoots(EntryPointNodes);\n+                ProjectNodes = allParsedProjects.Values.ToList();\n+            }\n+            else\n+            {\n+                throw new AggregateException(exceptions);\n+            }\n+\n+            IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection<ProjectGraphNode> entryPointNodes)\n+            {\n+                var graphRoots = new List<ProjectGraphNode>(entryPointNodes.Count);\n+\n+                foreach (var entryPointNode in entryPointNodes)\n+                {\n+                    if (entryPointNode.ReferencingProjects.Count == 0)\n+                    {\n+                        graphRoots.Add(entryPointNode);\n+                    }\n+                }\n+\n+                return graphRoots;\n+            }\n+        }\n+\n+        private static List<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable<ProjectGraphEntryPoint> entryPoints)\n+        {\n+            {\n+                var entryPointConfigurationMetadata = new List<ConfigurationMetadata>();\n+\n+                foreach (var entryPoint in entryPoints)\n+                {\n+                    var globalPropertyDictionary = CreatePropertyDictionary(entryPoint.GlobalProperties);\n+\n+                    AddGraphBuildGlobalVariable(globalPropertyDictionary);\n+\n+                    var configurationMetadata = new ConfigurationMetadata(FileUtilities.NormalizePath(entryPoint.ProjectFile), globalPropertyDictionary);\n+                    entryPointConfigurationMetadata.Add(configurationMetadata);\n+                }\n+                return entryPointConfigurationMetadata;\n+            }\n+\n+            void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> globalPropertyDictionary)\n+            {\n+                if (globalPropertyDictionary.GetProperty(PropertyNames.IsGraphBuild) == null)\n+                {\n+                    globalPropertyDictionary[PropertyNames.IsGraphBuild] = ProjectPropertyInstance.Create(PropertyNames.IsGraphBuild, \"true\");\n+                }\n+            }\n+        }\n+\n+        /// <remarks>\n+        ///     Traverse the found nodes and add edges.\n+        ///     Maintain the state of each node (InProcess and Processed) to detect cycles.\n+        ///     Returns false if cycles were detected.\n+        /// </remarks>\n+        private void CreateEdgesAndDetectCycles(\n+            List<ConfigurationMetadata> entryPointConfigurationMetadata,\n+            ProjectInterpretation sdkInfo,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,\n+            GraphEdges edges)\n+        {\n+            var nodeStates = new Dictionary<ProjectGraphNode, NodeVisitationState>();\n+\n+            foreach (var entrypointConfig in entryPointConfigurationMetadata)\n+            {\n+                var entryPointNode = allParsedProjects[entrypointConfig];\n+\n+                if (!nodeStates.ContainsKey(entryPointNode))\n+                {\n+                    CreateEdgesAndDetectCyclesForRoot(entryPointNode, entrypointConfig, nodeStates);\n+                }\n+                else\n+                {\n+                    ErrorUtilities.VerifyThrow(\n+                        nodeStates[entryPointNode] == NodeVisitationState.Processed,\n+                        \"entrypoints should get processed after a call to detect cycles\");\n+                }\n+            }\n+\n+            return;\n+\n+            (bool success, List<string> projectsInCycle) CreateEdgesAndDetectCyclesForRoot(\n+                ProjectGraphNode node,\n+                ConfigurationMetadata nodeConfig,\n+                IDictionary<ProjectGraphNode, NodeVisitationState> nodeState)\n+            {\n+                nodeState[node] = NodeVisitationState.InProcess;\n+\n+                foreach (var (referenceConfig, projectReferenceItem) in sdkInfo.GetReferences(node.ProjectInstance))\n+                {\n+                    var referenceNode = allParsedProjects[referenceConfig];\n+\n+                    if (nodeState.TryGetValue(referenceNode, out var projectReferenceNodeState))\n+                    {\n+                        // Because this is a depth-first search, we should only encounter new nodes or nodes whose subgraph has been completely processed.\n+                        // If we encounter a node that is currently being processed(InProcess state), it must be one of the ancestors in a circular dependency.\n+                        if (projectReferenceNodeState == NodeVisitationState.InProcess)\n+                        {\n+                            if (node.Equals(referenceNode))\n+                            {\n+                                // the project being evaluated has a reference to itself\n+                                var selfReferencingProjectString =\n+                                    FormatCircularDependencyError(new List<string> {node.ProjectInstance.FullPath, node.ProjectInstance.FullPath});\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        selfReferencingProjectString));\n+                            }\n+                            // the project being evaluated has a circular dependency involving multiple projects\n+                            // add this project to the list of projects involved in cycle \n+                            var projectsInCycle = new List<string> {referenceConfig.ProjectFullPath};\n+                            return (false, projectsInCycle);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        // recursively process newly discovered references\n+                        var loadReference = CreateEdgesAndDetectCyclesForRoot(referenceNode, referenceConfig, nodeState);\n+                        if (!loadReference.success)\n+                        {\n+                            if (loadReference.projectsInCycle[0].Equals(node.ProjectInstance.FullPath))\n+                            {\n+                                // we have reached the nth project in the cycle, form error message and throw\n+                                loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                                loadReference.projectsInCycle.Add(node.ProjectInstance.FullPath);\n+                                var errorMessage = FormatCircularDependencyError(loadReference.projectsInCycle);\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        errorMessage));\n+                            }\n+                            // this is one of the projects in the circular dependency\n+                            // update the list of projects in cycle and return the list to the caller\n+                            loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                            return (false, loadReference.projectsInCycle);\n+                        }\n+                    }\n+\n+                    node.AddProjectReference(referenceNode, projectReferenceItem, edges);\n+                }\n+\n+                nodeState[node] = NodeVisitationState.Processed;\n+                return (true, null);\n+            }\n+        }\n+\n+        private ProjectGraphNode CreateNewNode(\n+            ConfigurationMetadata configurationMetadata,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects)\n+        {\n+            // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n+            var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n+\n+            var projectInstance = projectInstanceFactory(\n+                configurationMetadata.ProjectFullPath,\n+                globalProperties,\n+                projectCollection);\n+            if (projectInstance == null)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n+            }\n+\n+            var graphNode = new ProjectGraphNode(\n+                projectInstance);\n+            allParsedProjects[configurationMetadata] = graphNode;\n+            return graphNode;\n+        }\n+\n+        /// <summary>\n+        ///     Load a graph with root node at entryProjectFile\n+        ///     Maintain a queue of projects to be processed and evaluate projects in parallel\n+        ///     Returns false if loading the graph is not successful\n+        /// </summary>\n+        private bool FindGraphNodes(\n+            ConcurrentQueue<ConfigurationMetadata> projectsToEvaluate,\n+            ProjectCollection projectCollection,\n+            ConcurrentDictionary<ConfigurationMetadata, object> tasksInProgress,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory,\n+            ProjectInterpretation projectInterpretation,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,\n+            out List<Exception> exceptions)\n+        {\n+            var exceptionsInTasks = new ConcurrentBag<Exception>();\n+            var evaluationWaitHandle = new AutoResetEvent(false);\n+\n+            while (projectsToEvaluate.Count != 0 || tasksInProgress.Count != 0)\n+            {\n+                ConfigurationMetadata projectToEvaluate;\n+                if (projectsToEvaluate.Count != 0)\n+                {\n+                    projectToEvaluate = projectsToEvaluate.Dequeue();\n+                    var task = new Task(\n+                        () =>\n+                        {\n+                            var parsedProject = CreateNewNode(projectToEvaluate, projectCollection, projectInstanceFactory, allParsedProjects);\n+\n+                            foreach (var (referenceConfig, _) in projectInterpretation.GetReferences(parsedProject.ProjectInstance))\n+                            {\n+                                /*todo: fix the following double check-then-act concurrency bug: one thread can pass the two checks, loose context,\n+                             meanwhile another thread passes the same checks with the same data and inserts its reference. The initial thread regains context\n+                             and duplicates the information, leading to wasted work\n+                             */\n+                                if (!tasksInProgress.ContainsKey(referenceConfig))\n+                                {\n+                                    if (!allParsedProjects.ContainsKey(referenceConfig))\n+                                    {\n+                                        projectsToEvaluate.Enqueue(referenceConfig);\n+                                        evaluationWaitHandle.Set();\n+                                    }\n+                                }\n+                            }\n+                        });\n+\n+                    if (tasksInProgress.TryAdd(projectToEvaluate, null))\n+                    {\n+                        // once the task completes, remove it from tasksInProgress using a chained task\n+                        // signal the wait handle to process new projects that have been discovered by this task or exit if all projects have been evaluated\n+                        task.ContinueWith(\n+                            _ =>\n+                            {\n+                                if (task.IsFaulted)\n+                                {\n+                                    exceptionsInTasks.Add(task.Exception.InnerException);\n+                                }\n+                                tasksInProgress.TryRemove(projectToEvaluate, out var _);\n+                                evaluationWaitHandle.Set();\n+                            });\n+                        task.Start();\n+                    }\n+                }\n+                else\n+                {\n+                    // if projectsToEvaluate is empty but there are tasks in progress, there is nothing to do till a task completes and discovers new projects\n+                    // wait till a task completes and sends a signal\n+                    evaluationWaitHandle.WaitOne();\n+                }\n+            }\n+\n+            if (exceptionsInTasks.Count != 0)\n+            {\n+                exceptions = exceptionsInTasks.ToList();\n+                return false;\n+            }\n+\n+            exceptions = null;\n+            return true;\n+        }\n+\n+        internal static string FormatCircularDependencyError(List<string> projectsInCycle)\n+        {\n+            const int MAX_PATH = 260;\n+            var errorMessage = new StringBuilder(projectsInCycle.Count * MAX_PATH);\n+            errorMessage.AppendLine();\n+            for (var i = projectsInCycle.Count - 1; i >= 0; i--)\n+            {\n+                if (i != 0)\n+                {\n+                    errorMessage.Append(projectsInCycle[i])\n+                        .Append(\" ->\")\n+                        .AppendLine();\n+                }\n+                else\n+                {\n+                    errorMessage.Append(projectsInCycle[i]);\n+                }\n+            }\n+\n+            return errorMessage.ToString();\n+        }\n+\n+        private static PropertyDictionary<ProjectPropertyInstance> CreatePropertyDictionary(IDictionary<string, string> properties)\n+        {\n+            PropertyDictionary<ProjectPropertyInstance> propertyDictionary;\n+            if (properties == null)\n+            {\n+                propertyDictionary = new PropertyDictionary<ProjectPropertyInstance>(0);\n+            }\n+            else\n+            {\n+                propertyDictionary = new PropertyDictionary<ProjectPropertyInstance>(properties.Count);\n+                foreach (var entry in properties)\n+                {\n+                    propertyDictionary[entry.Key] = ProjectPropertyInstance.Create(entry.Key, entry.Value);\n+                }\n+            }\n+\n+            return propertyDictionary;\n+        }\n+\n+        internal class GraphEdges\n+        {\n+            private ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstance> ReferenceItems =\n+                new ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstance>();",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why not just pass the entryPointConfigurationMetadata to the ConcurrentQueue constructor? It is a List and therefore an IEnumerable. If you do that you won't need the foreach below.",
              "createdAt": "2019-05-21T19:27:17Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -0,0 +1,397 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal class GraphBuilder\n+    {\n+        private ProjectInterpretation ProjectInterpretation { get; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> RootNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }\n+\n+        public GraphEdges Edges { get; private set; }\n+\n+        public GraphBuilder(ProjectInterpretation projectInterpretation)\n+        {\n+            ProjectInterpretation = projectInterpretation;\n+        }\n+\n+        public void BuildGraph(\n+            IEnumerable<ProjectGraphEntryPoint> entryPoints,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory\n+            )\n+        {\n+            var entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(entryPoints);\n+\n+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();\n+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();\n+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();",
              "author": {
                "login": "livarcocc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`defaultTargets` or `expandedTargets`?",
              "createdAt": "2019-05-21T19:27:58Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -573,6 +530,20 @@ private static ImmutableList<string> ExpandDefaultTargets(ImmutableList<string>\n                         .InsertRange(i, defaultTargets);\n                     i += defaultTargets.Count;\n                 }\n+                else if (targets[i].Equals(MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    var targetsString = graphEdge.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);\n+\n+                    var expandedTargets = string.IsNullOrEmpty(targetsString)\n+                        ? defaultTargets\n+                        : ExpressionShredder.SplitSemiColonSeparatedList(targetsString).ToList();\n+\n+                    targets = targets\n+                        .RemoveAt(i)\n+                        .InsertRange(i, expandedTargets);\n+\n+                    i += defaultTargets.Count;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Good catch! Fortunately the defect does not affect correctness.",
              "createdAt": "2019-05-21T21:09:04Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -573,6 +530,20 @@ private static ImmutableList<string> ExpandDefaultTargets(ImmutableList<string>\n                         .InsertRange(i, defaultTargets);\n                     i += defaultTargets.Count;\n                 }\n+                else if (targets[i].Equals(MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, StringComparison.OrdinalIgnoreCase))\n+                {\n+                    var targetsString = graphEdge.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);\n+\n+                    var expandedTargets = string.IsNullOrEmpty(targetsString)\n+                        ? defaultTargets\n+                        : ExpressionShredder.SplitSemiColonSeparatedList(targetsString).ToList();\n+\n+                    targets = targets\n+                        .RemoveAt(i)\n+                        .InsertRange(i, expandedTargets);\n+\n+                    i += defaultTargets.Count;",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't understand. It sounds like \"it starts outer->inner, but at build time it's actually outer->inner\", but that doesn't make sense. Can you rephrase?",
              "createdAt": "2019-05-21T19:30:21Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -115,7 +115,12 @@ internal static ProjectType GetProjectType(ProjectInstance project)\n                     : ProjectType.NonMultitargeting;\n         }\n \n-        public static void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)\n+        /// <summary>\n+        /// To avoid calling nuget at graph construction time, the graph is initially constructed with outer build nodes referencing inner build nodes.\n+        /// However, at build time, for non root outer builds, the inner builds are NOT referenced by the outer build, but by the nodes referencing the\n+        /// outer build. Change the graph to mimic this behaviour.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Updated comment with example.",
              "createdAt": "2019-05-21T21:19:40Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -115,7 +115,12 @@ internal static ProjectType GetProjectType(ProjectInstance project)\n                     : ProjectType.NonMultitargeting;\n         }\n \n-        public static void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)\n+        /// <summary>\n+        /// To avoid calling nuget at graph construction time, the graph is initially constructed with outer build nodes referencing inner build nodes.\n+        /// However, at build time, for non root outer builds, the inner builds are NOT referenced by the outer build, but by the nodes referencing the\n+        /// outer build. Change the graph to mimic this behaviour.",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Ok to waste memory here if not all entryPoints end up being root?",
              "createdAt": "2019-05-21T19:31:10Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -0,0 +1,397 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal class GraphBuilder\n+    {\n+        private ProjectInterpretation ProjectInterpretation { get; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> RootNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }\n+\n+        public GraphEdges Edges { get; private set; }\n+\n+        public GraphBuilder(ProjectInterpretation projectInterpretation)\n+        {\n+            ProjectInterpretation = projectInterpretation;\n+        }\n+\n+        public void BuildGraph(\n+            IEnumerable<ProjectGraphEntryPoint> entryPoints,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory\n+            )\n+        {\n+            var entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(entryPoints);\n+\n+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();\n+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();\n+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();\n+\n+            foreach (var entryPoint in entryPointConfigurationMetadata)\n+            {\n+                projectsToEvaluate.Enqueue(entryPoint);\n+            }\n+\n+            if (FindGraphNodes(\n+                projectsToEvaluate,\n+                projectCollection,\n+                tasksInProgress,\n+                projectInstanceFactory,\n+                ProjectInterpretation,\n+                allParsedProjects,\n+                out var exceptions))\n+            {\n+                Edges = new GraphEdges();\n+\n+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, ProjectInterpretation, allParsedProjects, Edges);\n+\n+                ProjectInterpretation.PostProcess(allParsedProjects, this);\n+\n+                EntryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();\n+                RootNodes = GetGraphRoots(EntryPointNodes);\n+                ProjectNodes = allParsedProjects.Values.ToList();\n+            }\n+            else\n+            {\n+                throw new AggregateException(exceptions);\n+            }\n+\n+            IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection<ProjectGraphNode> entryPointNodes)\n+            {\n+                var graphRoots = new List<ProjectGraphNode>(entryPointNodes.Count);",
              "author": {
                "login": "livarcocc"
              }
            },
            {
              "body": "Trimmed the excess memory.",
              "createdAt": "2019-05-21T20:45:11Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -0,0 +1,397 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal class GraphBuilder\n+    {\n+        private ProjectInterpretation ProjectInterpretation { get; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> RootNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }\n+\n+        public GraphEdges Edges { get; private set; }\n+\n+        public GraphBuilder(ProjectInterpretation projectInterpretation)\n+        {\n+            ProjectInterpretation = projectInterpretation;\n+        }\n+\n+        public void BuildGraph(\n+            IEnumerable<ProjectGraphEntryPoint> entryPoints,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory\n+            )\n+        {\n+            var entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(entryPoints);\n+\n+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();\n+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();\n+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();\n+\n+            foreach (var entryPoint in entryPointConfigurationMetadata)\n+            {\n+                projectsToEvaluate.Enqueue(entryPoint);\n+            }\n+\n+            if (FindGraphNodes(\n+                projectsToEvaluate,\n+                projectCollection,\n+                tasksInProgress,\n+                projectInstanceFactory,\n+                ProjectInterpretation,\n+                allParsedProjects,\n+                out var exceptions))\n+            {\n+                Edges = new GraphEdges();\n+\n+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, ProjectInterpretation, allParsedProjects, Edges);\n+\n+                ProjectInterpretation.PostProcess(allParsedProjects, this);\n+\n+                EntryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();\n+                RootNodes = GetGraphRoots(EntryPointNodes);\n+                ProjectNodes = allParsedProjects.Values.ToList();\n+            }\n+            else\n+            {\n+                throw new AggregateException(exceptions);\n+            }\n+\n+            IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection<ProjectGraphNode> entryPointNodes)\n+            {\n+                var graphRoots = new List<ProjectGraphNode>(entryPointNodes.Count);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: empty line after closing bracket.",
              "createdAt": "2019-05-21T19:32:25Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -0,0 +1,397 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal class GraphBuilder\n+    {\n+        private ProjectInterpretation ProjectInterpretation { get; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> RootNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }\n+\n+        public GraphEdges Edges { get; private set; }\n+\n+        public GraphBuilder(ProjectInterpretation projectInterpretation)\n+        {\n+            ProjectInterpretation = projectInterpretation;\n+        }\n+\n+        public void BuildGraph(\n+            IEnumerable<ProjectGraphEntryPoint> entryPoints,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory\n+            )\n+        {\n+            var entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(entryPoints);\n+\n+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();\n+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();\n+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();\n+\n+            foreach (var entryPoint in entryPointConfigurationMetadata)\n+            {\n+                projectsToEvaluate.Enqueue(entryPoint);\n+            }\n+\n+            if (FindGraphNodes(\n+                projectsToEvaluate,\n+                projectCollection,\n+                tasksInProgress,\n+                projectInstanceFactory,\n+                ProjectInterpretation,\n+                allParsedProjects,\n+                out var exceptions))\n+            {\n+                Edges = new GraphEdges();\n+\n+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, ProjectInterpretation, allParsedProjects, Edges);\n+\n+                ProjectInterpretation.PostProcess(allParsedProjects, this);\n+\n+                EntryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();\n+                RootNodes = GetGraphRoots(EntryPointNodes);\n+                ProjectNodes = allParsedProjects.Values.ToList();\n+            }\n+            else\n+            {\n+                throw new AggregateException(exceptions);\n+            }\n+\n+            IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection<ProjectGraphNode> entryPointNodes)\n+            {\n+                var graphRoots = new List<ProjectGraphNode>(entryPointNodes.Count);\n+\n+                foreach (var entryPointNode in entryPointNodes)\n+                {\n+                    if (entryPointNode.ReferencingProjects.Count == 0)\n+                    {\n+                        graphRoots.Add(entryPointNode);\n+                    }\n+                }\n+\n+                return graphRoots;\n+            }\n+        }\n+\n+        private static List<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable<ProjectGraphEntryPoint> entryPoints)\n+        {\n+            {\n+                var entryPointConfigurationMetadata = new List<ConfigurationMetadata>();\n+\n+                foreach (var entryPoint in entryPoints)\n+                {\n+                    var globalPropertyDictionary = CreatePropertyDictionary(entryPoint.GlobalProperties);\n+\n+                    AddGraphBuildGlobalVariable(globalPropertyDictionary);\n+\n+                    var configurationMetadata = new ConfigurationMetadata(FileUtilities.NormalizePath(entryPoint.ProjectFile), globalPropertyDictionary);\n+                    entryPointConfigurationMetadata.Add(configurationMetadata);\n+                }\n+                return entryPointConfigurationMetadata;",
              "author": {
                "login": "livarcocc"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "May I beg you for a diagram of this?",
              "createdAt": "2019-05-21T19:36:58Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -769,6 +851,78 @@ public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()\n             }\n         }\n \n+        [Fact]\n+        public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBuilds()",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "![image](https://user-images.githubusercontent.com/2255729/58132013-10b41a80-7bd5-11e9-9c92-0b192b112416.png)\r\n",
              "createdAt": "2019-05-21T21:31:40Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -769,6 +851,78 @@ public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()\n             }\n         }\n \n+        [Fact]\n+        public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBuilds()",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this be LoadGraphNodes instead? Find seems to imply a search and I would not expect modifications.",
              "createdAt": "2019-05-21T19:40:13Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -0,0 +1,397 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal class GraphBuilder\n+    {\n+        private ProjectInterpretation ProjectInterpretation { get; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> RootNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }\n+\n+        public GraphEdges Edges { get; private set; }\n+\n+        public GraphBuilder(ProjectInterpretation projectInterpretation)\n+        {\n+            ProjectInterpretation = projectInterpretation;\n+        }\n+\n+        public void BuildGraph(\n+            IEnumerable<ProjectGraphEntryPoint> entryPoints,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory\n+            )\n+        {\n+            var entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(entryPoints);\n+\n+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();\n+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();\n+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();\n+\n+            foreach (var entryPoint in entryPointConfigurationMetadata)\n+            {\n+                projectsToEvaluate.Enqueue(entryPoint);\n+            }\n+\n+            if (FindGraphNodes(\n+                projectsToEvaluate,\n+                projectCollection,\n+                tasksInProgress,\n+                projectInstanceFactory,\n+                ProjectInterpretation,\n+                allParsedProjects,\n+                out var exceptions))\n+            {\n+                Edges = new GraphEdges();\n+\n+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, ProjectInterpretation, allParsedProjects, Edges);\n+\n+                ProjectInterpretation.PostProcess(allParsedProjects, this);\n+\n+                EntryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();\n+                RootNodes = GetGraphRoots(EntryPointNodes);\n+                ProjectNodes = allParsedProjects.Values.ToList();\n+            }\n+            else\n+            {\n+                throw new AggregateException(exceptions);\n+            }\n+\n+            IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection<ProjectGraphNode> entryPointNodes)\n+            {\n+                var graphRoots = new List<ProjectGraphNode>(entryPointNodes.Count);\n+\n+                foreach (var entryPointNode in entryPointNodes)\n+                {\n+                    if (entryPointNode.ReferencingProjects.Count == 0)\n+                    {\n+                        graphRoots.Add(entryPointNode);\n+                    }\n+                }\n+\n+                return graphRoots;\n+            }\n+        }\n+\n+        private static List<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable<ProjectGraphEntryPoint> entryPoints)\n+        {\n+            {\n+                var entryPointConfigurationMetadata = new List<ConfigurationMetadata>();\n+\n+                foreach (var entryPoint in entryPoints)\n+                {\n+                    var globalPropertyDictionary = CreatePropertyDictionary(entryPoint.GlobalProperties);\n+\n+                    AddGraphBuildGlobalVariable(globalPropertyDictionary);\n+\n+                    var configurationMetadata = new ConfigurationMetadata(FileUtilities.NormalizePath(entryPoint.ProjectFile), globalPropertyDictionary);\n+                    entryPointConfigurationMetadata.Add(configurationMetadata);\n+                }\n+                return entryPointConfigurationMetadata;\n+            }\n+\n+            void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> globalPropertyDictionary)\n+            {\n+                if (globalPropertyDictionary.GetProperty(PropertyNames.IsGraphBuild) == null)\n+                {\n+                    globalPropertyDictionary[PropertyNames.IsGraphBuild] = ProjectPropertyInstance.Create(PropertyNames.IsGraphBuild, \"true\");\n+                }\n+            }\n+        }\n+\n+        /// <remarks>\n+        ///     Traverse the found nodes and add edges.\n+        ///     Maintain the state of each node (InProcess and Processed) to detect cycles.\n+        ///     Returns false if cycles were detected.\n+        /// </remarks>\n+        private void CreateEdgesAndDetectCycles(\n+            List<ConfigurationMetadata> entryPointConfigurationMetadata,\n+            ProjectInterpretation sdkInfo,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,\n+            GraphEdges edges)\n+        {\n+            var nodeStates = new Dictionary<ProjectGraphNode, NodeVisitationState>();\n+\n+            foreach (var entrypointConfig in entryPointConfigurationMetadata)\n+            {\n+                var entryPointNode = allParsedProjects[entrypointConfig];\n+\n+                if (!nodeStates.ContainsKey(entryPointNode))\n+                {\n+                    CreateEdgesAndDetectCyclesForRoot(entryPointNode, entrypointConfig, nodeStates);\n+                }\n+                else\n+                {\n+                    ErrorUtilities.VerifyThrow(\n+                        nodeStates[entryPointNode] == NodeVisitationState.Processed,\n+                        \"entrypoints should get processed after a call to detect cycles\");\n+                }\n+            }\n+\n+            return;\n+\n+            (bool success, List<string> projectsInCycle) CreateEdgesAndDetectCyclesForRoot(\n+                ProjectGraphNode node,\n+                ConfigurationMetadata nodeConfig,\n+                IDictionary<ProjectGraphNode, NodeVisitationState> nodeState)\n+            {\n+                nodeState[node] = NodeVisitationState.InProcess;\n+\n+                foreach (var (referenceConfig, projectReferenceItem) in sdkInfo.GetReferences(node.ProjectInstance))\n+                {\n+                    var referenceNode = allParsedProjects[referenceConfig];\n+\n+                    if (nodeState.TryGetValue(referenceNode, out var projectReferenceNodeState))\n+                    {\n+                        // Because this is a depth-first search, we should only encounter new nodes or nodes whose subgraph has been completely processed.\n+                        // If we encounter a node that is currently being processed(InProcess state), it must be one of the ancestors in a circular dependency.\n+                        if (projectReferenceNodeState == NodeVisitationState.InProcess)\n+                        {\n+                            if (node.Equals(referenceNode))\n+                            {\n+                                // the project being evaluated has a reference to itself\n+                                var selfReferencingProjectString =\n+                                    FormatCircularDependencyError(new List<string> {node.ProjectInstance.FullPath, node.ProjectInstance.FullPath});\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        selfReferencingProjectString));\n+                            }\n+                            // the project being evaluated has a circular dependency involving multiple projects\n+                            // add this project to the list of projects involved in cycle \n+                            var projectsInCycle = new List<string> {referenceConfig.ProjectFullPath};\n+                            return (false, projectsInCycle);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        // recursively process newly discovered references\n+                        var loadReference = CreateEdgesAndDetectCyclesForRoot(referenceNode, referenceConfig, nodeState);\n+                        if (!loadReference.success)\n+                        {\n+                            if (loadReference.projectsInCycle[0].Equals(node.ProjectInstance.FullPath))\n+                            {\n+                                // we have reached the nth project in the cycle, form error message and throw\n+                                loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                                loadReference.projectsInCycle.Add(node.ProjectInstance.FullPath);\n+                                var errorMessage = FormatCircularDependencyError(loadReference.projectsInCycle);\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        errorMessage));\n+                            }\n+                            // this is one of the projects in the circular dependency\n+                            // update the list of projects in cycle and return the list to the caller\n+                            loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                            return (false, loadReference.projectsInCycle);\n+                        }\n+                    }\n+\n+                    node.AddProjectReference(referenceNode, projectReferenceItem, edges);\n+                }\n+\n+                nodeState[node] = NodeVisitationState.Processed;\n+                return (true, null);\n+            }\n+        }\n+\n+        private ProjectGraphNode CreateNewNode(\n+            ConfigurationMetadata configurationMetadata,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects)\n+        {\n+            // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n+            var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n+\n+            var projectInstance = projectInstanceFactory(\n+                configurationMetadata.ProjectFullPath,\n+                globalProperties,\n+                projectCollection);\n+            if (projectInstance == null)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n+            }\n+\n+            var graphNode = new ProjectGraphNode(\n+                projectInstance);\n+            allParsedProjects[configurationMetadata] = graphNode;\n+            return graphNode;\n+        }\n+\n+        /// <summary>\n+        ///     Load a graph with root node at entryProjectFile\n+        ///     Maintain a queue of projects to be processed and evaluate projects in parallel\n+        ///     Returns false if loading the graph is not successful\n+        /// </summary>\n+        private bool FindGraphNodes(",
              "author": {
                "login": "livarcocc"
              }
            },
            {
              "body": "It finds and loads them, but does not connect them. What do you think about `FindAndLoadGraphNodes`? Seems a bit superfluous.",
              "createdAt": "2019-05-21T20:49:52Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -0,0 +1,397 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal class GraphBuilder\n+    {\n+        private ProjectInterpretation ProjectInterpretation { get; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> RootNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }\n+\n+        public GraphEdges Edges { get; private set; }\n+\n+        public GraphBuilder(ProjectInterpretation projectInterpretation)\n+        {\n+            ProjectInterpretation = projectInterpretation;\n+        }\n+\n+        public void BuildGraph(\n+            IEnumerable<ProjectGraphEntryPoint> entryPoints,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory\n+            )\n+        {\n+            var entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(entryPoints);\n+\n+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();\n+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();\n+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();\n+\n+            foreach (var entryPoint in entryPointConfigurationMetadata)\n+            {\n+                projectsToEvaluate.Enqueue(entryPoint);\n+            }\n+\n+            if (FindGraphNodes(\n+                projectsToEvaluate,\n+                projectCollection,\n+                tasksInProgress,\n+                projectInstanceFactory,\n+                ProjectInterpretation,\n+                allParsedProjects,\n+                out var exceptions))\n+            {\n+                Edges = new GraphEdges();\n+\n+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, ProjectInterpretation, allParsedProjects, Edges);\n+\n+                ProjectInterpretation.PostProcess(allParsedProjects, this);\n+\n+                EntryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();\n+                RootNodes = GetGraphRoots(EntryPointNodes);\n+                ProjectNodes = allParsedProjects.Values.ToList();\n+            }\n+            else\n+            {\n+                throw new AggregateException(exceptions);\n+            }\n+\n+            IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection<ProjectGraphNode> entryPointNodes)\n+            {\n+                var graphRoots = new List<ProjectGraphNode>(entryPointNodes.Count);\n+\n+                foreach (var entryPointNode in entryPointNodes)\n+                {\n+                    if (entryPointNode.ReferencingProjects.Count == 0)\n+                    {\n+                        graphRoots.Add(entryPointNode);\n+                    }\n+                }\n+\n+                return graphRoots;\n+            }\n+        }\n+\n+        private static List<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable<ProjectGraphEntryPoint> entryPoints)\n+        {\n+            {\n+                var entryPointConfigurationMetadata = new List<ConfigurationMetadata>();\n+\n+                foreach (var entryPoint in entryPoints)\n+                {\n+                    var globalPropertyDictionary = CreatePropertyDictionary(entryPoint.GlobalProperties);\n+\n+                    AddGraphBuildGlobalVariable(globalPropertyDictionary);\n+\n+                    var configurationMetadata = new ConfigurationMetadata(FileUtilities.NormalizePath(entryPoint.ProjectFile), globalPropertyDictionary);\n+                    entryPointConfigurationMetadata.Add(configurationMetadata);\n+                }\n+                return entryPointConfigurationMetadata;\n+            }\n+\n+            void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> globalPropertyDictionary)\n+            {\n+                if (globalPropertyDictionary.GetProperty(PropertyNames.IsGraphBuild) == null)\n+                {\n+                    globalPropertyDictionary[PropertyNames.IsGraphBuild] = ProjectPropertyInstance.Create(PropertyNames.IsGraphBuild, \"true\");\n+                }\n+            }\n+        }\n+\n+        /// <remarks>\n+        ///     Traverse the found nodes and add edges.\n+        ///     Maintain the state of each node (InProcess and Processed) to detect cycles.\n+        ///     Returns false if cycles were detected.\n+        /// </remarks>\n+        private void CreateEdgesAndDetectCycles(\n+            List<ConfigurationMetadata> entryPointConfigurationMetadata,\n+            ProjectInterpretation sdkInfo,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,\n+            GraphEdges edges)\n+        {\n+            var nodeStates = new Dictionary<ProjectGraphNode, NodeVisitationState>();\n+\n+            foreach (var entrypointConfig in entryPointConfigurationMetadata)\n+            {\n+                var entryPointNode = allParsedProjects[entrypointConfig];\n+\n+                if (!nodeStates.ContainsKey(entryPointNode))\n+                {\n+                    CreateEdgesAndDetectCyclesForRoot(entryPointNode, entrypointConfig, nodeStates);\n+                }\n+                else\n+                {\n+                    ErrorUtilities.VerifyThrow(\n+                        nodeStates[entryPointNode] == NodeVisitationState.Processed,\n+                        \"entrypoints should get processed after a call to detect cycles\");\n+                }\n+            }\n+\n+            return;\n+\n+            (bool success, List<string> projectsInCycle) CreateEdgesAndDetectCyclesForRoot(\n+                ProjectGraphNode node,\n+                ConfigurationMetadata nodeConfig,\n+                IDictionary<ProjectGraphNode, NodeVisitationState> nodeState)\n+            {\n+                nodeState[node] = NodeVisitationState.InProcess;\n+\n+                foreach (var (referenceConfig, projectReferenceItem) in sdkInfo.GetReferences(node.ProjectInstance))\n+                {\n+                    var referenceNode = allParsedProjects[referenceConfig];\n+\n+                    if (nodeState.TryGetValue(referenceNode, out var projectReferenceNodeState))\n+                    {\n+                        // Because this is a depth-first search, we should only encounter new nodes or nodes whose subgraph has been completely processed.\n+                        // If we encounter a node that is currently being processed(InProcess state), it must be one of the ancestors in a circular dependency.\n+                        if (projectReferenceNodeState == NodeVisitationState.InProcess)\n+                        {\n+                            if (node.Equals(referenceNode))\n+                            {\n+                                // the project being evaluated has a reference to itself\n+                                var selfReferencingProjectString =\n+                                    FormatCircularDependencyError(new List<string> {node.ProjectInstance.FullPath, node.ProjectInstance.FullPath});\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        selfReferencingProjectString));\n+                            }\n+                            // the project being evaluated has a circular dependency involving multiple projects\n+                            // add this project to the list of projects involved in cycle \n+                            var projectsInCycle = new List<string> {referenceConfig.ProjectFullPath};\n+                            return (false, projectsInCycle);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        // recursively process newly discovered references\n+                        var loadReference = CreateEdgesAndDetectCyclesForRoot(referenceNode, referenceConfig, nodeState);\n+                        if (!loadReference.success)\n+                        {\n+                            if (loadReference.projectsInCycle[0].Equals(node.ProjectInstance.FullPath))\n+                            {\n+                                // we have reached the nth project in the cycle, form error message and throw\n+                                loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                                loadReference.projectsInCycle.Add(node.ProjectInstance.FullPath);\n+                                var errorMessage = FormatCircularDependencyError(loadReference.projectsInCycle);\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        errorMessage));\n+                            }\n+                            // this is one of the projects in the circular dependency\n+                            // update the list of projects in cycle and return the list to the caller\n+                            loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                            return (false, loadReference.projectsInCycle);\n+                        }\n+                    }\n+\n+                    node.AddProjectReference(referenceNode, projectReferenceItem, edges);\n+                }\n+\n+                nodeState[node] = NodeVisitationState.Processed;\n+                return (true, null);\n+            }\n+        }\n+\n+        private ProjectGraphNode CreateNewNode(\n+            ConfigurationMetadata configurationMetadata,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects)\n+        {\n+            // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n+            var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n+\n+            var projectInstance = projectInstanceFactory(\n+                configurationMetadata.ProjectFullPath,\n+                globalProperties,\n+                projectCollection);\n+            if (projectInstance == null)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n+            }\n+\n+            var graphNode = new ProjectGraphNode(\n+                projectInstance);\n+            allParsedProjects[configurationMetadata] = graphNode;\n+            return graphNode;\n+        }\n+\n+        /// <summary>\n+        ///     Load a graph with root node at entryProjectFile\n+        ///     Maintain a queue of projects to be processed and evaluate projects in parallel\n+        ///     Returns false if loading the graph is not successful\n+        /// </summary>\n+        private bool FindGraphNodes(",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wait, why no edge for outer->inner of the same project?",
              "createdAt": "2019-05-21T19:43:45Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -1239,6 +1419,13 @@ private static void AssertOuterBuildAsNonRoot(ProjectGraphNode outerBuild, Dicti\n \n                     innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);\n                     innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);\n+\n+                    graph.TestOnly_Edges.TestOnly_HasEdge((outerBuild, innerBuild)).ShouldBeFalse();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "These are outer builds that are not roots. For non-root outerbuilds, the project that references the outer build also references the inner builds.",
              "createdAt": "2019-05-21T21:34:40Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -1239,6 +1419,13 @@ private static void AssertOuterBuildAsNonRoot(ProjectGraphNode outerBuild, Dicti\n \n                     innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);\n                     innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);\n+\n+                    graph.TestOnly_Edges.TestOnly_HasEdge((outerBuild, innerBuild)).ShouldBeFalse();",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why does FindGraphNodes need to take tasksInProgress as a parameter if it is not used outside of this method and is used just for bookkeeping inside the method itself?",
              "createdAt": "2019-05-21T19:44:09Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -0,0 +1,397 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal class GraphBuilder\n+    {\n+        private ProjectInterpretation ProjectInterpretation { get; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> RootNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }\n+\n+        public GraphEdges Edges { get; private set; }\n+\n+        public GraphBuilder(ProjectInterpretation projectInterpretation)\n+        {\n+            ProjectInterpretation = projectInterpretation;\n+        }\n+\n+        public void BuildGraph(\n+            IEnumerable<ProjectGraphEntryPoint> entryPoints,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory\n+            )\n+        {\n+            var entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(entryPoints);\n+\n+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();\n+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();\n+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();\n+\n+            foreach (var entryPoint in entryPointConfigurationMetadata)\n+            {\n+                projectsToEvaluate.Enqueue(entryPoint);\n+            }\n+\n+            if (FindGraphNodes(\n+                projectsToEvaluate,\n+                projectCollection,\n+                tasksInProgress,\n+                projectInstanceFactory,\n+                ProjectInterpretation,\n+                allParsedProjects,\n+                out var exceptions))\n+            {\n+                Edges = new GraphEdges();\n+\n+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, ProjectInterpretation, allParsedProjects, Edges);\n+\n+                ProjectInterpretation.PostProcess(allParsedProjects, this);\n+\n+                EntryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();\n+                RootNodes = GetGraphRoots(EntryPointNodes);\n+                ProjectNodes = allParsedProjects.Values.ToList();\n+            }\n+            else\n+            {\n+                throw new AggregateException(exceptions);\n+            }\n+\n+            IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection<ProjectGraphNode> entryPointNodes)\n+            {\n+                var graphRoots = new List<ProjectGraphNode>(entryPointNodes.Count);\n+\n+                foreach (var entryPointNode in entryPointNodes)\n+                {\n+                    if (entryPointNode.ReferencingProjects.Count == 0)\n+                    {\n+                        graphRoots.Add(entryPointNode);\n+                    }\n+                }\n+\n+                return graphRoots;\n+            }\n+        }\n+\n+        private static List<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable<ProjectGraphEntryPoint> entryPoints)\n+        {\n+            {\n+                var entryPointConfigurationMetadata = new List<ConfigurationMetadata>();\n+\n+                foreach (var entryPoint in entryPoints)\n+                {\n+                    var globalPropertyDictionary = CreatePropertyDictionary(entryPoint.GlobalProperties);\n+\n+                    AddGraphBuildGlobalVariable(globalPropertyDictionary);\n+\n+                    var configurationMetadata = new ConfigurationMetadata(FileUtilities.NormalizePath(entryPoint.ProjectFile), globalPropertyDictionary);\n+                    entryPointConfigurationMetadata.Add(configurationMetadata);\n+                }\n+                return entryPointConfigurationMetadata;\n+            }\n+\n+            void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> globalPropertyDictionary)\n+            {\n+                if (globalPropertyDictionary.GetProperty(PropertyNames.IsGraphBuild) == null)\n+                {\n+                    globalPropertyDictionary[PropertyNames.IsGraphBuild] = ProjectPropertyInstance.Create(PropertyNames.IsGraphBuild, \"true\");\n+                }\n+            }\n+        }\n+\n+        /// <remarks>\n+        ///     Traverse the found nodes and add edges.\n+        ///     Maintain the state of each node (InProcess and Processed) to detect cycles.\n+        ///     Returns false if cycles were detected.\n+        /// </remarks>\n+        private void CreateEdgesAndDetectCycles(\n+            List<ConfigurationMetadata> entryPointConfigurationMetadata,\n+            ProjectInterpretation sdkInfo,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,\n+            GraphEdges edges)\n+        {\n+            var nodeStates = new Dictionary<ProjectGraphNode, NodeVisitationState>();\n+\n+            foreach (var entrypointConfig in entryPointConfigurationMetadata)\n+            {\n+                var entryPointNode = allParsedProjects[entrypointConfig];\n+\n+                if (!nodeStates.ContainsKey(entryPointNode))\n+                {\n+                    CreateEdgesAndDetectCyclesForRoot(entryPointNode, entrypointConfig, nodeStates);\n+                }\n+                else\n+                {\n+                    ErrorUtilities.VerifyThrow(\n+                        nodeStates[entryPointNode] == NodeVisitationState.Processed,\n+                        \"entrypoints should get processed after a call to detect cycles\");\n+                }\n+            }\n+\n+            return;\n+\n+            (bool success, List<string> projectsInCycle) CreateEdgesAndDetectCyclesForRoot(\n+                ProjectGraphNode node,\n+                ConfigurationMetadata nodeConfig,\n+                IDictionary<ProjectGraphNode, NodeVisitationState> nodeState)\n+            {\n+                nodeState[node] = NodeVisitationState.InProcess;\n+\n+                foreach (var (referenceConfig, projectReferenceItem) in sdkInfo.GetReferences(node.ProjectInstance))\n+                {\n+                    var referenceNode = allParsedProjects[referenceConfig];\n+\n+                    if (nodeState.TryGetValue(referenceNode, out var projectReferenceNodeState))\n+                    {\n+                        // Because this is a depth-first search, we should only encounter new nodes or nodes whose subgraph has been completely processed.\n+                        // If we encounter a node that is currently being processed(InProcess state), it must be one of the ancestors in a circular dependency.\n+                        if (projectReferenceNodeState == NodeVisitationState.InProcess)\n+                        {\n+                            if (node.Equals(referenceNode))\n+                            {\n+                                // the project being evaluated has a reference to itself\n+                                var selfReferencingProjectString =\n+                                    FormatCircularDependencyError(new List<string> {node.ProjectInstance.FullPath, node.ProjectInstance.FullPath});\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        selfReferencingProjectString));\n+                            }\n+                            // the project being evaluated has a circular dependency involving multiple projects\n+                            // add this project to the list of projects involved in cycle \n+                            var projectsInCycle = new List<string> {referenceConfig.ProjectFullPath};\n+                            return (false, projectsInCycle);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        // recursively process newly discovered references\n+                        var loadReference = CreateEdgesAndDetectCyclesForRoot(referenceNode, referenceConfig, nodeState);\n+                        if (!loadReference.success)\n+                        {\n+                            if (loadReference.projectsInCycle[0].Equals(node.ProjectInstance.FullPath))\n+                            {\n+                                // we have reached the nth project in the cycle, form error message and throw\n+                                loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                                loadReference.projectsInCycle.Add(node.ProjectInstance.FullPath);\n+                                var errorMessage = FormatCircularDependencyError(loadReference.projectsInCycle);\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        errorMessage));\n+                            }\n+                            // this is one of the projects in the circular dependency\n+                            // update the list of projects in cycle and return the list to the caller\n+                            loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                            return (false, loadReference.projectsInCycle);\n+                        }\n+                    }\n+\n+                    node.AddProjectReference(referenceNode, projectReferenceItem, edges);\n+                }\n+\n+                nodeState[node] = NodeVisitationState.Processed;\n+                return (true, null);\n+            }\n+        }\n+\n+        private ProjectGraphNode CreateNewNode(\n+            ConfigurationMetadata configurationMetadata,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects)\n+        {\n+            // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n+            var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n+\n+            var projectInstance = projectInstanceFactory(\n+                configurationMetadata.ProjectFullPath,\n+                globalProperties,\n+                projectCollection);\n+            if (projectInstance == null)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n+            }\n+\n+            var graphNode = new ProjectGraphNode(\n+                projectInstance);\n+            allParsedProjects[configurationMetadata] = graphNode;\n+            return graphNode;\n+        }\n+\n+        /// <summary>\n+        ///     Load a graph with root node at entryProjectFile\n+        ///     Maintain a queue of projects to be processed and evaluate projects in parallel\n+        ///     Returns false if loading the graph is not successful\n+        /// </summary>\n+        private bool FindGraphNodes(",
              "author": {
                "login": "livarcocc"
              }
            },
            {
              "body": "Good question. Moved it inside the method.",
              "createdAt": "2019-05-21T21:46:35Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -0,0 +1,397 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal class GraphBuilder\n+    {\n+        private ProjectInterpretation ProjectInterpretation { get; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> RootNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }\n+\n+        public GraphEdges Edges { get; private set; }\n+\n+        public GraphBuilder(ProjectInterpretation projectInterpretation)\n+        {\n+            ProjectInterpretation = projectInterpretation;\n+        }\n+\n+        public void BuildGraph(\n+            IEnumerable<ProjectGraphEntryPoint> entryPoints,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory\n+            )\n+        {\n+            var entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(entryPoints);\n+\n+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();\n+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();\n+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();\n+\n+            foreach (var entryPoint in entryPointConfigurationMetadata)\n+            {\n+                projectsToEvaluate.Enqueue(entryPoint);\n+            }\n+\n+            if (FindGraphNodes(\n+                projectsToEvaluate,\n+                projectCollection,\n+                tasksInProgress,\n+                projectInstanceFactory,\n+                ProjectInterpretation,\n+                allParsedProjects,\n+                out var exceptions))\n+            {\n+                Edges = new GraphEdges();\n+\n+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, ProjectInterpretation, allParsedProjects, Edges);\n+\n+                ProjectInterpretation.PostProcess(allParsedProjects, this);\n+\n+                EntryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();\n+                RootNodes = GetGraphRoots(EntryPointNodes);\n+                ProjectNodes = allParsedProjects.Values.ToList();\n+            }\n+            else\n+            {\n+                throw new AggregateException(exceptions);\n+            }\n+\n+            IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection<ProjectGraphNode> entryPointNodes)\n+            {\n+                var graphRoots = new List<ProjectGraphNode>(entryPointNodes.Count);\n+\n+                foreach (var entryPointNode in entryPointNodes)\n+                {\n+                    if (entryPointNode.ReferencingProjects.Count == 0)\n+                    {\n+                        graphRoots.Add(entryPointNode);\n+                    }\n+                }\n+\n+                return graphRoots;\n+            }\n+        }\n+\n+        private static List<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable<ProjectGraphEntryPoint> entryPoints)\n+        {\n+            {\n+                var entryPointConfigurationMetadata = new List<ConfigurationMetadata>();\n+\n+                foreach (var entryPoint in entryPoints)\n+                {\n+                    var globalPropertyDictionary = CreatePropertyDictionary(entryPoint.GlobalProperties);\n+\n+                    AddGraphBuildGlobalVariable(globalPropertyDictionary);\n+\n+                    var configurationMetadata = new ConfigurationMetadata(FileUtilities.NormalizePath(entryPoint.ProjectFile), globalPropertyDictionary);\n+                    entryPointConfigurationMetadata.Add(configurationMetadata);\n+                }\n+                return entryPointConfigurationMetadata;\n+            }\n+\n+            void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> globalPropertyDictionary)\n+            {\n+                if (globalPropertyDictionary.GetProperty(PropertyNames.IsGraphBuild) == null)\n+                {\n+                    globalPropertyDictionary[PropertyNames.IsGraphBuild] = ProjectPropertyInstance.Create(PropertyNames.IsGraphBuild, \"true\");\n+                }\n+            }\n+        }\n+\n+        /// <remarks>\n+        ///     Traverse the found nodes and add edges.\n+        ///     Maintain the state of each node (InProcess and Processed) to detect cycles.\n+        ///     Returns false if cycles were detected.\n+        /// </remarks>\n+        private void CreateEdgesAndDetectCycles(\n+            List<ConfigurationMetadata> entryPointConfigurationMetadata,\n+            ProjectInterpretation sdkInfo,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,\n+            GraphEdges edges)\n+        {\n+            var nodeStates = new Dictionary<ProjectGraphNode, NodeVisitationState>();\n+\n+            foreach (var entrypointConfig in entryPointConfigurationMetadata)\n+            {\n+                var entryPointNode = allParsedProjects[entrypointConfig];\n+\n+                if (!nodeStates.ContainsKey(entryPointNode))\n+                {\n+                    CreateEdgesAndDetectCyclesForRoot(entryPointNode, entrypointConfig, nodeStates);\n+                }\n+                else\n+                {\n+                    ErrorUtilities.VerifyThrow(\n+                        nodeStates[entryPointNode] == NodeVisitationState.Processed,\n+                        \"entrypoints should get processed after a call to detect cycles\");\n+                }\n+            }\n+\n+            return;\n+\n+            (bool success, List<string> projectsInCycle) CreateEdgesAndDetectCyclesForRoot(\n+                ProjectGraphNode node,\n+                ConfigurationMetadata nodeConfig,\n+                IDictionary<ProjectGraphNode, NodeVisitationState> nodeState)\n+            {\n+                nodeState[node] = NodeVisitationState.InProcess;\n+\n+                foreach (var (referenceConfig, projectReferenceItem) in sdkInfo.GetReferences(node.ProjectInstance))\n+                {\n+                    var referenceNode = allParsedProjects[referenceConfig];\n+\n+                    if (nodeState.TryGetValue(referenceNode, out var projectReferenceNodeState))\n+                    {\n+                        // Because this is a depth-first search, we should only encounter new nodes or nodes whose subgraph has been completely processed.\n+                        // If we encounter a node that is currently being processed(InProcess state), it must be one of the ancestors in a circular dependency.\n+                        if (projectReferenceNodeState == NodeVisitationState.InProcess)\n+                        {\n+                            if (node.Equals(referenceNode))\n+                            {\n+                                // the project being evaluated has a reference to itself\n+                                var selfReferencingProjectString =\n+                                    FormatCircularDependencyError(new List<string> {node.ProjectInstance.FullPath, node.ProjectInstance.FullPath});\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        selfReferencingProjectString));\n+                            }\n+                            // the project being evaluated has a circular dependency involving multiple projects\n+                            // add this project to the list of projects involved in cycle \n+                            var projectsInCycle = new List<string> {referenceConfig.ProjectFullPath};\n+                            return (false, projectsInCycle);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        // recursively process newly discovered references\n+                        var loadReference = CreateEdgesAndDetectCyclesForRoot(referenceNode, referenceConfig, nodeState);\n+                        if (!loadReference.success)\n+                        {\n+                            if (loadReference.projectsInCycle[0].Equals(node.ProjectInstance.FullPath))\n+                            {\n+                                // we have reached the nth project in the cycle, form error message and throw\n+                                loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                                loadReference.projectsInCycle.Add(node.ProjectInstance.FullPath);\n+                                var errorMessage = FormatCircularDependencyError(loadReference.projectsInCycle);\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        errorMessage));\n+                            }\n+                            // this is one of the projects in the circular dependency\n+                            // update the list of projects in cycle and return the list to the caller\n+                            loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                            return (false, loadReference.projectsInCycle);\n+                        }\n+                    }\n+\n+                    node.AddProjectReference(referenceNode, projectReferenceItem, edges);\n+                }\n+\n+                nodeState[node] = NodeVisitationState.Processed;\n+                return (true, null);\n+            }\n+        }\n+\n+        private ProjectGraphNode CreateNewNode(\n+            ConfigurationMetadata configurationMetadata,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects)\n+        {\n+            // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n+            var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n+\n+            var projectInstance = projectInstanceFactory(\n+                configurationMetadata.ProjectFullPath,\n+                globalProperties,\n+                projectCollection);\n+            if (projectInstance == null)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n+            }\n+\n+            var graphNode = new ProjectGraphNode(\n+                projectInstance);\n+            allParsedProjects[configurationMetadata] = graphNode;\n+            return graphNode;\n+        }\n+\n+        /// <summary>\n+        ///     Load a graph with root node at entryProjectFile\n+        ///     Maintain a queue of projects to be processed and evaluate projects in parallel\n+        ///     Returns false if loading the graph is not successful\n+        /// </summary>\n+        private bool FindGraphNodes(",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "You could do this without exposing `ToString()` as public API by calling the method something else; might be worth doing.",
              "createdAt": "2019-05-21T19:47:04Z",
              "path": "src/Build/Graph/ProjectGraphNode.cs",
              "diffHunk": "@@ -10,6 +11,7 @@ namespace Microsoft.Build.Experimental.Graph\n     /// <summary>\n     /// Represents the node for a particular project in a project graph.\n     /// </summary>\n+    [DebuggerDisplay(@\"{ToString()}\")]",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is MAX_PATH still applicable here?",
              "createdAt": "2019-05-21T19:52:45Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -0,0 +1,397 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal class GraphBuilder\n+    {\n+        private ProjectInterpretation ProjectInterpretation { get; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> RootNodes { get; private set; }\n+\n+        public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }\n+\n+        public GraphEdges Edges { get; private set; }\n+\n+        public GraphBuilder(ProjectInterpretation projectInterpretation)\n+        {\n+            ProjectInterpretation = projectInterpretation;\n+        }\n+\n+        public void BuildGraph(\n+            IEnumerable<ProjectGraphEntryPoint> entryPoints,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory\n+            )\n+        {\n+            var entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(entryPoints);\n+\n+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();\n+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();\n+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();\n+\n+            foreach (var entryPoint in entryPointConfigurationMetadata)\n+            {\n+                projectsToEvaluate.Enqueue(entryPoint);\n+            }\n+\n+            if (FindGraphNodes(\n+                projectsToEvaluate,\n+                projectCollection,\n+                tasksInProgress,\n+                projectInstanceFactory,\n+                ProjectInterpretation,\n+                allParsedProjects,\n+                out var exceptions))\n+            {\n+                Edges = new GraphEdges();\n+\n+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, ProjectInterpretation, allParsedProjects, Edges);\n+\n+                ProjectInterpretation.PostProcess(allParsedProjects, this);\n+\n+                EntryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();\n+                RootNodes = GetGraphRoots(EntryPointNodes);\n+                ProjectNodes = allParsedProjects.Values.ToList();\n+            }\n+            else\n+            {\n+                throw new AggregateException(exceptions);\n+            }\n+\n+            IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection<ProjectGraphNode> entryPointNodes)\n+            {\n+                var graphRoots = new List<ProjectGraphNode>(entryPointNodes.Count);\n+\n+                foreach (var entryPointNode in entryPointNodes)\n+                {\n+                    if (entryPointNode.ReferencingProjects.Count == 0)\n+                    {\n+                        graphRoots.Add(entryPointNode);\n+                    }\n+                }\n+\n+                return graphRoots;\n+            }\n+        }\n+\n+        private static List<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable<ProjectGraphEntryPoint> entryPoints)\n+        {\n+            {\n+                var entryPointConfigurationMetadata = new List<ConfigurationMetadata>();\n+\n+                foreach (var entryPoint in entryPoints)\n+                {\n+                    var globalPropertyDictionary = CreatePropertyDictionary(entryPoint.GlobalProperties);\n+\n+                    AddGraphBuildGlobalVariable(globalPropertyDictionary);\n+\n+                    var configurationMetadata = new ConfigurationMetadata(FileUtilities.NormalizePath(entryPoint.ProjectFile), globalPropertyDictionary);\n+                    entryPointConfigurationMetadata.Add(configurationMetadata);\n+                }\n+                return entryPointConfigurationMetadata;\n+            }\n+\n+            void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> globalPropertyDictionary)\n+            {\n+                if (globalPropertyDictionary.GetProperty(PropertyNames.IsGraphBuild) == null)\n+                {\n+                    globalPropertyDictionary[PropertyNames.IsGraphBuild] = ProjectPropertyInstance.Create(PropertyNames.IsGraphBuild, \"true\");\n+                }\n+            }\n+        }\n+\n+        /// <remarks>\n+        ///     Traverse the found nodes and add edges.\n+        ///     Maintain the state of each node (InProcess and Processed) to detect cycles.\n+        ///     Returns false if cycles were detected.\n+        /// </remarks>\n+        private void CreateEdgesAndDetectCycles(\n+            List<ConfigurationMetadata> entryPointConfigurationMetadata,\n+            ProjectInterpretation sdkInfo,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,\n+            GraphEdges edges)\n+        {\n+            var nodeStates = new Dictionary<ProjectGraphNode, NodeVisitationState>();\n+\n+            foreach (var entrypointConfig in entryPointConfigurationMetadata)\n+            {\n+                var entryPointNode = allParsedProjects[entrypointConfig];\n+\n+                if (!nodeStates.ContainsKey(entryPointNode))\n+                {\n+                    CreateEdgesAndDetectCyclesForRoot(entryPointNode, entrypointConfig, nodeStates);\n+                }\n+                else\n+                {\n+                    ErrorUtilities.VerifyThrow(\n+                        nodeStates[entryPointNode] == NodeVisitationState.Processed,\n+                        \"entrypoints should get processed after a call to detect cycles\");\n+                }\n+            }\n+\n+            return;\n+\n+            (bool success, List<string> projectsInCycle) CreateEdgesAndDetectCyclesForRoot(\n+                ProjectGraphNode node,\n+                ConfigurationMetadata nodeConfig,\n+                IDictionary<ProjectGraphNode, NodeVisitationState> nodeState)\n+            {\n+                nodeState[node] = NodeVisitationState.InProcess;\n+\n+                foreach (var (referenceConfig, projectReferenceItem) in sdkInfo.GetReferences(node.ProjectInstance))\n+                {\n+                    var referenceNode = allParsedProjects[referenceConfig];\n+\n+                    if (nodeState.TryGetValue(referenceNode, out var projectReferenceNodeState))\n+                    {\n+                        // Because this is a depth-first search, we should only encounter new nodes or nodes whose subgraph has been completely processed.\n+                        // If we encounter a node that is currently being processed(InProcess state), it must be one of the ancestors in a circular dependency.\n+                        if (projectReferenceNodeState == NodeVisitationState.InProcess)\n+                        {\n+                            if (node.Equals(referenceNode))\n+                            {\n+                                // the project being evaluated has a reference to itself\n+                                var selfReferencingProjectString =\n+                                    FormatCircularDependencyError(new List<string> {node.ProjectInstance.FullPath, node.ProjectInstance.FullPath});\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        selfReferencingProjectString));\n+                            }\n+                            // the project being evaluated has a circular dependency involving multiple projects\n+                            // add this project to the list of projects involved in cycle \n+                            var projectsInCycle = new List<string> {referenceConfig.ProjectFullPath};\n+                            return (false, projectsInCycle);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        // recursively process newly discovered references\n+                        var loadReference = CreateEdgesAndDetectCyclesForRoot(referenceNode, referenceConfig, nodeState);\n+                        if (!loadReference.success)\n+                        {\n+                            if (loadReference.projectsInCycle[0].Equals(node.ProjectInstance.FullPath))\n+                            {\n+                                // we have reached the nth project in the cycle, form error message and throw\n+                                loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                                loadReference.projectsInCycle.Add(node.ProjectInstance.FullPath);\n+                                var errorMessage = FormatCircularDependencyError(loadReference.projectsInCycle);\n+                                throw new CircularDependencyException(\n+                                    string.Format(\n+                                        ResourceUtilities.GetResourceString(\"CircularDependencyInProjectGraph\"),\n+                                        errorMessage));\n+                            }\n+                            // this is one of the projects in the circular dependency\n+                            // update the list of projects in cycle and return the list to the caller\n+                            loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);\n+                            return (false, loadReference.projectsInCycle);\n+                        }\n+                    }\n+\n+                    node.AddProjectReference(referenceNode, projectReferenceItem, edges);\n+                }\n+\n+                nodeState[node] = NodeVisitationState.Processed;\n+                return (true, null);\n+            }\n+        }\n+\n+        private ProjectGraphNode CreateNewNode(\n+            ConfigurationMetadata configurationMetadata,\n+            ProjectCollection projectCollection,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects)\n+        {\n+            // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n+            var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n+\n+            var projectInstance = projectInstanceFactory(\n+                configurationMetadata.ProjectFullPath,\n+                globalProperties,\n+                projectCollection);\n+            if (projectInstance == null)\n+            {\n+                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n+            }\n+\n+            var graphNode = new ProjectGraphNode(\n+                projectInstance);\n+            allParsedProjects[configurationMetadata] = graphNode;\n+            return graphNode;\n+        }\n+\n+        /// <summary>\n+        ///     Load a graph with root node at entryProjectFile\n+        ///     Maintain a queue of projects to be processed and evaluate projects in parallel\n+        ///     Returns false if loading the graph is not successful\n+        /// </summary>\n+        private bool FindGraphNodes(\n+            ConcurrentQueue<ConfigurationMetadata> projectsToEvaluate,\n+            ProjectCollection projectCollection,\n+            ConcurrentDictionary<ConfigurationMetadata, object> tasksInProgress,\n+            ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory,\n+            ProjectInterpretation projectInterpretation,\n+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,\n+            out List<Exception> exceptions)\n+        {\n+            var exceptionsInTasks = new ConcurrentBag<Exception>();\n+            var evaluationWaitHandle = new AutoResetEvent(false);\n+\n+            while (projectsToEvaluate.Count != 0 || tasksInProgress.Count != 0)\n+            {\n+                ConfigurationMetadata projectToEvaluate;\n+                if (projectsToEvaluate.Count != 0)\n+                {\n+                    projectToEvaluate = projectsToEvaluate.Dequeue();\n+                    var task = new Task(\n+                        () =>\n+                        {\n+                            var parsedProject = CreateNewNode(projectToEvaluate, projectCollection, projectInstanceFactory, allParsedProjects);\n+\n+                            foreach (var (referenceConfig, _) in projectInterpretation.GetReferences(parsedProject.ProjectInstance))\n+                            {\n+                                /*todo: fix the following double check-then-act concurrency bug: one thread can pass the two checks, loose context,\n+                             meanwhile another thread passes the same checks with the same data and inserts its reference. The initial thread regains context\n+                             and duplicates the information, leading to wasted work\n+                             */\n+                                if (!tasksInProgress.ContainsKey(referenceConfig))\n+                                {\n+                                    if (!allParsedProjects.ContainsKey(referenceConfig))\n+                                    {\n+                                        projectsToEvaluate.Enqueue(referenceConfig);\n+                                        evaluationWaitHandle.Set();\n+                                    }\n+                                }\n+                            }\n+                        });\n+\n+                    if (tasksInProgress.TryAdd(projectToEvaluate, null))\n+                    {\n+                        // once the task completes, remove it from tasksInProgress using a chained task\n+                        // signal the wait handle to process new projects that have been discovered by this task or exit if all projects have been evaluated\n+                        task.ContinueWith(\n+                            _ =>\n+                            {\n+                                if (task.IsFaulted)\n+                                {\n+                                    exceptionsInTasks.Add(task.Exception.InnerException);\n+                                }\n+                                tasksInProgress.TryRemove(projectToEvaluate, out var _);\n+                                evaluationWaitHandle.Set();\n+                            });\n+                        task.Start();\n+                    }\n+                }\n+                else\n+                {\n+                    // if projectsToEvaluate is empty but there are tasks in progress, there is nothing to do till a task completes and discovers new projects\n+                    // wait till a task completes and sends a signal\n+                    evaluationWaitHandle.WaitOne();\n+                }\n+            }\n+\n+            if (exceptionsInTasks.Count != 0)\n+            {\n+                exceptions = exceptionsInTasks.ToList();\n+                return false;\n+            }\n+\n+            exceptions = null;\n+            return true;\n+        }\n+\n+        internal static string FormatCircularDependencyError(List<string> projectsInCycle)\n+        {\n+            const int MAX_PATH = 260;",
              "author": {
                "login": "livarcocc"
              }
            }
          ]
        }
      }
    ]
  }
}