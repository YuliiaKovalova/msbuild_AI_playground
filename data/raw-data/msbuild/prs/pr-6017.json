{
  "number": 6017,
  "title": "Deduplicate strings in binlogs",
  "body": "When writing out a binary log we now deduplicate strings and dictionaries. This results in a significant performance increase and binlog size reduction. Performance increase is about 2x on average, size reduction is about 4x on average, but up to 30x for large binlogs.\r\n\r\nAdd two new record kinds: String and NameValueList. A string record is written the first time we encounter a string we need to serialize. The next time we see the string we only write its index in the total list of strings.\r\n\r\nSimilarly, NameValueList is a list of key and value strings, used for Properties, environment variables and Item metadata. The first time we're writing out a list we write a record, and subsequent times just the index.\r\n\r\nThis keeps the binlog format streaming, so if the logging is interrupted midway, we will be able to read everything up to that point.\r\n\r\nWe do not hold on to strings we encountered. Instead we hash them and only preserve the hash code. We rely on the hash function resulting in no collisions, otherwise it could happen that a random string in a binlog would be substituted instead of another one. The hashtables do not significantly add to MSBuild memory usage (20-30 MB for our largest binlogs).\r\n\r\nFNV-1a (64-bit hash size) was a carefully chosen hash function for its simplicity, performance, and lack of collisions on all binlogs tested so far. 32-bit hash size (such as string.GetHashCode() was not sufficient and resulted in ~800 collisions for our largest binlog with 2.7 million strings.\r\n\r\nThis change includes other performance improvements such as inserting a BufferedStream around the stream we're reading or writing. This results in a significant performance improvement.\r\n\r\nWe introduce a new StringStorage data structure in the binlog reader, for storing the strings on disk instead of reading them all into memory. Strings are loaded into memory on demand. This prevents OOM in 32-bit MSBuild processes when playing back large binlogs. This keeps the memory usage relatively flat when reading.\r\n\r\n### Testing\r\n\r\nI've done extensive testing for correctness, performance, and hash collisions and performance.\r\n\r\nHash function selection is documented here:\r\nhttps://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing\r\nIn summary, Fnv-1a provides no collisions with 64-bit hash size, and very decent performance (11 seconds to hash all the strings in our largest binlog, 2.7 million strings). Additionally it's very simple and minimal code.\r\n\r\nPlayback:\r\nI've tested various scenarios for playback:\r\n 1. binlog format\r\n   - playing back a legacy binlog (format version < 10), with no String or NameValueList records\r\n   - playing back version 10 binlog\r\n 2. process bitness\r\n   - on 32-bit we need to use the StringStorage helper class when reading new binlogs, to avoid OOM\r\n   - on 32-bit we're fine when reading legacy binlogs as they're fully streaming\r\n   - on 64-bit we just store all strings in memory, and it results in much faster performance\r\n \r\nThe data looks good:\r\n![image](https://user-images.githubusercontent.com/679326/104138799-5f3e9b80-535b-11eb-8362-3dcfd3d73ed8.png)\r\n\r\n### Binlog size reduction:\r\n\r\nStrings: | Binlog: | Legacy binlog size (KB) | New binlog size (KB)\r\n-- | -- | -- | --\r\n2,744,490 | vswin.binlog | 703,863 | 274,714\r\n2,711,714 | 790.binlog | 791,488 | 283,364\r\n1,633,734 | 23GB.binlog | 22,558,820 | 172,617\r\n681,346 | mmitche.binlog | 590,938 | 157,915\r\n302,685 | roslyn.binlog | 194,354 | 49,277\r\n288,136 | dotnet.binlog | 64,577 | 24,599\r\n220,177 | vsmac.binlog | 143,178 | 35,095\r\n42,658 | Ide.binlog | 20,753 | 12,334\r\n\r\nPlayback of binlog into binlog, perf improvement:\r\nPlayback of legacy vswin.binlog by legacy: 6:54\r\nPlayback of legacy vswin.binlog by new: 2:56\r\nPlayback of new vswin.binlog on 32-bit: 3:17\r\nPlayback of new vswin.binlog on 64-bit: 2:13\r\n\r\nIn summary, I expect builds to be faster (up to 4 minutes improvement for really large builds) and binlogs to be smaller (up to 50% for small binlogs, 2-4x for medium size, and 131x (from 23 GB to 172 MB) for our most extreme binlog.\r\n\r\n\r\n",
  "state": "MERGED",
  "createdAt": "2021-01-10T23:56:00Z",
  "updatedAt": "2021-02-08T17:01:32Z",
  "closedAt": "2021-02-08T17:00:46Z",
  "mergedAt": "2021-02-08T17:00:46Z",
  "additions": 841,
  "deletions": 184,
  "changedFiles": 8,
  "headRefName": "dev/kirillo/dedup",
  "isDraft": false,
  "author": {
    "login": "KirillOsenkov"
  },
  "milestone": {
    "title": "MSBuild 16.10"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Performance",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "aa6fbabeecd08de504640f3832e0299d65d78aca",
          "message": "Deduplicate strings in binlogs\n\nWhen writing out a binary log we now deduplicate strings and dictionaries. This results in a significant performance increase and binlog size reduction. Performance increase is about 2x on average, size reduction is about 4x on average, but up to 30x for large binlogs.\n\nAdd two new record kinds: String and NameValueList. A string record is written the first time we encounter a string we need to serialize. The next time we see the string we only write its index in the total list of strings.\n\nSimilarly, NameValueList is a list of key and value strings, used for Properties, environment variables and Item metadata. The first time we're writing out a list we write a record, and subsequent times just the index.\n\nThis keeps the binlog format streaming, so if the logging is interrupted midway, we will be able to read everything up to that point.\n\nWe do not hold on to strings we encountered. Instead we hash them and only preserve the hash code. We rely on the hash function resulting in no collisions, otherwise it could happen that a random string in a binlog would be substituted instead of another one. The hashtables do not significantly add to MSBuild memory usage (20-30 MB for our largest binlogs).\n\nFNV-1a (64-bit hash size) was a carefully chosen hash function for its simplicity, performance, and lack of collisions on all binlogs tested so far. 32-bit hash size (such as string.GetHashCode() was not sufficient and resulted in ~800 collisions for our largest binlog with 2.7 million strings.\n\nThis change includes other performance improvements such as inserting a BufferedStream around the stream we're reading or writing. This results in a significant performance improvement.\n\nWe introduce a new StringStorage data structure in the binlog reader, for storing the strings on disk instead of reading them all into memory. Strings are loaded into memory on demand. This prevents OOM in 32-bit MSBuild processes when playing back large binlogs. This keeps the memory usage relatively flat when reading.",
          "committedDate": "2021-01-11T20:11:56Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b324bad839816b26f916957152116b5ae73ff510",
          "message": "Add some comments.",
          "committedDate": "2021-01-15T00:26:08Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e6ee9a5ac26df58fce81ac18a2d9f91912105189",
          "message": "Throw exception for invalid string and NameValueTable index",
          "committedDate": "2021-01-15T02:01:45Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9d8f857101e9b67099e64ebe125ca8787d00bf99",
          "message": "Make some fields readonly.\n\nReduce maximum strings allocated in memory to 2GB (1 billion chars).",
          "committedDate": "2021-01-17T03:14:38Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9ba9c9e767e2d091b25b27d8e8287386b1021e34",
          "message": "Introduce a RedirectionScope in BuildEventArgsWriter\n\nThis avoids manually switching from currentRecordWriter to originalBinaryWriter in three different places. It's also easier this way to find the places where the switch happens.",
          "committedDate": "2021-01-17T03:18:35Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "77a4ff36bfa49cff3a7f8d4f9f92708ea277c337",
          "message": "Clear the list unconditionally.",
          "committedDate": "2021-01-17T03:21:02Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "The latest viewer version (2.1.300) has already been updated to read the binlog format version 10.",
        "createdAt": "2021-01-11T00:32:25Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Hey @mmitche your binlog goes down in size from 590 MB to 157 MB.\r\n\r\n@aolszowka I'm probably too late with this, but your binlog goes down from 23 GB to 172 MB! You get the first prize!",
        "createdAt": "2021-01-11T00:38:43Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "> @aolszowka I'm probably too late with this, but your binlog goes down from 23 GB to 172 MB! You get the first prize!\r\n\r\nThis is a HUGE win, I'll make sure to pass it along and keep it in my toolbox :) Thank you!",
        "createdAt": "2021-01-11T13:13:23Z",
        "author": {
          "login": "aolszowka"
        }
      },
      {
        "body": "I'm personally not in a rush for 16.9 so I'd rather just wait until we fork for 16.9 and then just merge into master so we have lots of runway to dogfood for 16.10. This way if we have to tweak the file format we'll have more time.",
        "createdAt": "2021-01-11T17:58:51Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I actually discovered that the CLSCompliant warnings have disappeared. Maybe in early iterations the types I added were public and that's why I added the NoWarns? But just removing them now seems to be fine.",
        "createdAt": "2021-01-11T19:57:46Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@ladipro I totally agree on your point about hash collisions. It's a very valid concern.\r\n\r\nWithout relying on hashes though, we'd have to hold on to all strings we saw because that's the only way to be absolutely sure the strings match. Holding on to strings is absolutely not an option in a 32-bit process (as we have gigabytes of them), even if we choose a single string per hashcode as a \"sample\". Writing them to a page file like I do with Reader is an option, but you'd need to constantly seek to read out a string from disk for every new string you encounter. It would absolutely kill perf and defeat the purpose.\r\n\r\nI'm afraid that if we want the perf wins, we have to allow a small possibility of a collision, where in a random binlog (1) a random string you happened to be looking at (2) is switched to another random string. You only look at a tiny small fraction of all strings in the binlog (there are millions), and chances are that you happened to look at the corrupt one are infinitesimally small (given that I haven't seen any collisions in our top 10 largest binlogs). I say it's worth the risk!",
        "createdAt": "2021-01-13T20:18:36Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I guess we could also store the string length and the first character (in addition to hash), to further drastically reduce the chance of collision. But honestly I don't think it's even worth it.",
        "createdAt": "2021-01-13T20:20:57Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Regarding the hash problem and the large memory required to store the strings, wouldn't using msbuild's string interner (maybe using @ladipro's [rewritten version of it](https://github.com/dotnet/msbuild/pull/5663)) fix the problem? The interner also dedupes strings, so the in-memory string size should be the same as the deduped string size from the binlog",
        "createdAt": "2021-01-14T00:25:47Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "> Writing them to a page file like I do with Reader is an option, but you'd need to constantly seek to read out a string from disk for every new string you encounter. It would absolutely kill perf and defeat the purpose.\r\n\r\nIf there was a big concern about a collision what about a post process step? So you opt in to \"do it fast with a hash\" but allow a slower pass that captured all the strings then performed this process, at that point if there was a collision you could bark, but if there was no collision you reap the gains when sharing the binlog?\r\n\r\nDoes nothing for the perf though which is what I assume was driving a lot of this?\r\n\r\nI suspect the big concern is trying to capture this one off, realistically though by the time we're digging though the bin logs its probably reproducible on our end so its not like we're totally out of luck.\r\n",
        "createdAt": "2021-01-14T00:26:41Z",
        "author": {
          "login": "aolszowka"
        }
      },
      {
        "body": "> Regarding the hash problem and the large memory required to store the strings, wouldn't using msbuild's string interner (maybe using @ladipro's rewritten version of it) fix the problem? \r\n\r\nThe interner holds on to strings only as long as something else is keeping them alive so it wouldn't guarantee correctness either. It's basically a cache of recently seen and not yet collected strings, not of all strings.",
        "createdAt": "2021-01-14T08:09:15Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "> I guess we could also store the string length and the first character (in addition to hash), to further drastically reduce the chance of collision. But honestly I don't think it's even worth it.\r\n\r\nAgreed that it wouldn't be worth it. It's basically like using a wider hashcode but with poorer collision characteristics.\r\n\r\n> I'm afraid that if we want the perf wins, we have to allow a small possibility of a collision, where in a random binlog (1) a random string you happened to be looking at (2) is switched to another random string. You only look at a tiny small fraction of all strings in the binlog (there are millions), and chances are that you happened to look at the corrupt one are infinitesimally small (given that I haven't seen any collisions in our top 10 largest binlogs). I say it's worth the risk!\r\n\r\nLet's do it!",
        "createdAt": "2021-01-14T08:12:40Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "I think I've answered or resolved all comments, but let me know if you have more or disagree with some of my resolutions. Meanwhile I'll do some more final testing on it.",
        "createdAt": "2021-01-17T03:24:49Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I'm happy to report a nice performance improvement from this PR.\r\nmaster is 32s with /bl, this PR is 26s.\r\nPure MSBuild without any logging is 15s, with text file diagnostic log 55s.\r\n\r\nmaster | #6017 | no /bl | /flp1:v=diag\r\n-- | -- | -- | --\r\n32.377 | 27.737 | 15.476 | 55.61\r\n31.758 | 26.561 | 15.416 | 56.145\r\n31.481 | 26.486 | 15.536 | 55.72\r\n\r\n(all single-core build). We see that /bl makes it twice as slow, but diag text log is almost 4x as slow. I think we can reduce binlog overhead further.",
        "createdAt": "2021-01-26T06:13:24Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Shall we merge this?",
        "createdAt": "2021-02-08T05:39:40Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Yep!\r\n\r\nI'm still trying to merge things in a gradual way, but I'll get to your other PR in the next few days.",
        "createdAt": "2021-02-08T17:01:32Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        internal readonly struct HashKey : IEquatable<HashKey>\r\n        {\r\n            private readonly ulong value;\r\n```",
              "createdAt": "2021-01-11T04:50:46Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -788,5 +1003,89 @@ private void Write(ProfiledLocation e)\n             Write(e.ExclusiveTime);\n             Write(e.InclusiveTime);\n         }\n+\n+        internal struct HashKey : IEquatable<HashKey>\n+        {\n+            private ulong value;",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "I was actually thinking of deleting the HashKey struct and just using ulong directly... still on the fence. Thoughts?",
              "createdAt": "2021-01-11T16:43:08Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -788,5 +1003,89 @@ private void Write(ProfiledLocation e)\n             Write(e.ExclusiveTime);\n             Write(e.InclusiveTime);\n         }\n+\n+        internal struct HashKey : IEquatable<HashKey>\n+        {\n+            private ulong value;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                return unchecked((int)value);\r\n```",
              "createdAt": "2021-01-11T04:51:01Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -788,5 +1003,89 @@ private void Write(ProfiledLocation e)\n             Write(e.ExclusiveTime);\n             Write(e.InclusiveTime);\n         }\n+\n+        internal struct HashKey : IEquatable<HashKey>\n+        {\n+            private ulong value;\n+\n+            private HashKey(ulong i)\n+            {\n+                value = i;\n+            }\n+\n+            public HashKey(string text)\n+            {\n+                if (text == null)\n+                {\n+                    value = 0;\n+                }\n+                else\n+                {\n+                    value = FnvHash64.GetHashCode(text);\n+                }\n+            }\n+\n+            public static HashKey Combine(HashKey left, HashKey right)\n+            {\n+                return new HashKey(FnvHash64.Combine(left.value, right.value));\n+            }\n+\n+            public HashKey Add(HashKey other) => Combine(this, other);\n+\n+            public bool Equals(HashKey other)\n+            {\n+                return value == other.value;\n+            }\n+\n+            public override bool Equals(object obj)\n+            {\n+                if (obj is HashKey other)\n+                {\n+                    return Equals(other);\n+                }\n+\n+                return false;\n+            }\n+\n+            public override int GetHashCode()\n+            {\n+                return (int)value;",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wouldn't it be better to mark the assembly as not CLS compliant? I'm probably missing something here.",
              "createdAt": "2021-01-11T04:52:18Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -26,6 +26,10 @@\n \n     <!-- Do not generate a warning that our 'stable' package should not have a prerelease dependency. -->\n     <NoWarn>$(NoWarn);NU5104</NoWarn>\n+\n+    <!-- Fnv-1a 64-bit hash we use in BuildEventArgsWriter to deduplicate strings uses UInt64 which is not CLS-compliant -->\n+    <NoWarn>$(NoWarn);CS3001;CS3002;CS3003</NoWarn>",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "No, I just don't know about CLS compliance? I'd be happy to. How do I do that?",
              "createdAt": "2021-01-11T16:42:06Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -26,6 +26,10 @@\n \n     <!-- Do not generate a warning that our 'stable' package should not have a prerelease dependency. -->\n     <NoWarn>$(NoWarn);NU5104</NoWarn>\n+\n+    <!-- Fnv-1a 64-bit hash we use in BuildEventArgsWriter to deduplicate strings uses UInt64 which is not CLS-compliant -->\n+    <NoWarn>$(NoWarn);CS3001;CS3002;CS3003</NoWarn>",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Can you instead wrap that implementation in `#pragma warning disable`/`#pragma warning restore`?",
              "createdAt": "2021-01-11T16:46:10Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -26,6 +26,10 @@\n \n     <!-- Do not generate a warning that our 'stable' package should not have a prerelease dependency. -->\n     <NoWarn>$(NoWarn);NU5104</NoWarn>\n+\n+    <!-- Fnv-1a 64-bit hash we use in BuildEventArgsWriter to deduplicate strings uses UInt64 which is not CLS-compliant -->\n+    <NoWarn>$(NoWarn);CS3001;CS3002;CS3003</NoWarn>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "pragmas are messy and I'd have to do it in a few places. Any concerns with changing the assembly to CLSCompliant(false)?\r\nhttps://github.com/dotnet/msbuild/blob/74eb87c20d2495f81788e1bc7bb27203474818f4/src/Build/AssemblyInfo.cs#L39\r\n\r\nUnless I'm missing anything CLS compliance was never useful for anything.",
              "createdAt": "2021-01-11T19:34:11Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -26,6 +26,10 @@\n \n     <!-- Do not generate a warning that our 'stable' package should not have a prerelease dependency. -->\n     <NoWarn>$(NoWarn);NU5104</NoWarn>\n+\n+    <!-- Fnv-1a 64-bit hash we use in BuildEventArgsWriter to deduplicate strings uses UInt64 which is not CLS-compliant -->\n+    <NoWarn>$(NoWarn);CS3001;CS3002;CS3003</NoWarn>",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Actually turns out we don't need any of these.",
              "createdAt": "2021-01-11T20:02:06Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -26,6 +26,10 @@\n \n     <!-- Do not generate a warning that our 'stable' package should not have a prerelease dependency. -->\n     <NoWarn>$(NoWarn);NU5104</NoWarn>\n+\n+    <!-- Fnv-1a 64-bit hash we use in BuildEventArgsWriter to deduplicate strings uses UInt64 which is not CLS-compliant -->\n+    <NoWarn>$(NoWarn);CS3001;CS3002;CS3003</NoWarn>",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Comment magic number please.",
              "createdAt": "2021-01-11T16:43:40Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs",
              "diffHunk": "@@ -33,7 +33,8 @@ public void Replay(string sourceFilePath, CancellationToken cancellationToken)\n             using (var stream = new FileStream(sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))\n             {\n                 var gzipStream = new GZipStream(stream, CompressionMode.Decompress, leaveOpen: true);\n-                var binaryReader = new BinaryReader(gzipStream);\n+                var bufferedStream = new BufferedStream(gzipStream, 32768);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Question for @dotnet/msbuild: should the new features (and this version) be behind a change wave? Since it's a big change there's risk.",
              "createdAt": "2021-01-11T16:47:14Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -35,7 +35,13 @@ public sealed class BinaryLogger : ILogger\n         //   - This was used in a now-reverted change but is the same as 9.\n         // version 9:\n         //   - new record kinds: EnvironmentVariableRead, PropertyReassignment, UninitializedPropertyRead\n-        internal const int FileFormatVersion = 9;\n+        // version 10:\n+        //   - new record kinds:\n+        //      * String - deduplicate strings by hashing and write a string record before it's used\n+        //      * NameValueList - deduplicate arrays of name-value pairs such as properties, items and metadata\n+        //                        in a separate record and refer to those records from regular records\n+        //                        where a list used to be written in-place\n+        internal const int FileFormatVersion = 10;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n\r\n```suggestion\r\n        /// then flush to the originalStream. This is needed so that if we discover\r\n```",
              "createdAt": "2021-01-11T16:48:09Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -15,21 +16,114 @@ namespace Microsoft.Build.Logging\n     /// </summary>\n     internal class BuildEventArgsWriter\n     {\n-        private readonly BinaryWriter binaryWriter;\n+        private readonly Stream originalStream;\n+\n+        /// <summary>\n+        /// When writing the current record, first write it to a memory stream,\n+        /// then flush to the originalStream. This is need so that if we discover",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Comment magic number",
              "createdAt": "2021-01-11T16:51:19Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -15,21 +16,114 @@ namespace Microsoft.Build.Logging\n     /// </summary>\n     internal class BuildEventArgsWriter\n     {\n-        private readonly BinaryWriter binaryWriter;\n+        private readonly Stream originalStream;\n+\n+        /// <summary>\n+        /// When writing the current record, first write it to a memory stream,\n+        /// then flush to the originalStream. This is need so that if we discover\n+        /// that we need to write a string record in the middle of writing the\n+        /// current record, we will write the string record to the original stream\n+        /// and the current record will end up after the string record.\n+        /// </summary>\n+        private readonly MemoryStream currentRecordStream;\n+\n+        /// <summary>\n+        /// The binary writer around the originalStream.\n+        /// </summary>\n+        private readonly BinaryWriter originalBinaryWriter;\n+\n+        /// <summary>\n+        /// The binary writer around the currentRecordStream.\n+        /// </summary>\n+        private readonly BinaryWriter currentRecordWriter;\n+\n+        /// <summary>\n+        /// The binary writer we're currently using. Is pointing at the currentRecordWriter usually,\n+        /// but sometimes we repoint it to the originalBinaryWriter temporarily, when writing string\n+        /// and name-value records.\n+        /// </summary>\n+        private BinaryWriter binaryWriter;\n+\n+        /// <summary>\n+        /// Hashtable used for deduplicating strings. When we need to write a string,\n+        /// we check in this hashtable first, and if we've seen the string before,\n+        /// just write out its index. Otherwise write out a string record, and then\n+        /// write the string index. A string record is guaranteed to precede its first\n+        /// usage.\n+        /// The reader will read the string records first and then be able to retrieve\n+        /// a string by its index. This allows us to keep the format streaming instead\n+        /// of writing one giant string table at the end. If a binlog is interrupted\n+        /// we'll be able to use all the information we've discovered thus far.\n+        /// </summary>\n+        private readonly Dictionary<HashKey, int> stringHashes = new Dictionary<HashKey, int>();\n+\n+        /// <summary>\n+        /// Hashtable used for deduplicating name-value lists. Same as strings.\n+        /// </summary>\n+        private readonly Dictionary<HashKey, int> nameValueListHashes = new Dictionary<HashKey, int>();\n+\n+        /// <summary>\n+        /// Index 0 is null, Index 1 is the empty string.\n+        /// Reserve indices 2-9 for future use. Start indexing actual strings at 10.\n+        /// </summary>\n+        internal const int StringStartIndex = 10;\n+\n+        /// <summary>\n+        /// Let's reserve a few indices for future use.\n+        /// </summary>\n+        internal const int NameValueRecordStartIndex = 10;\n+\n+        /// <summary>\n+        /// 0 is null, 1 is empty string\n+        /// 2-9 are reserved for future use.\n+        /// Start indexing at 10.\n+        /// </summary>\n+        private int stringRecordId = StringStartIndex;\n+\n+        /// <summary>\n+        /// The index of the next record to be written.\n+        /// </summary>\n+        private int nameValueRecordId = NameValueRecordStartIndex;\n+\n+        /// <summary>\n+        /// A temporary buffer we use when writing a NameValueList record. Avoids allocating a list each time.\n+        /// </summary>\n+        private readonly List<KeyValuePair<string, string>> nameValueListBuffer = new List<KeyValuePair<string, string>>(1024);\n+\n+        /// <summary>\n+        /// A temporary buffer we use when hashing a NameValueList record. Stores the indices of hashed strings\n+        /// instead of the actual names and values.\n+        /// </summary>\n+        private readonly List<KeyValuePair<int, int>> nameValueIndexListBuffer = new List<KeyValuePair<int, int>>(1024);\n \n         /// <summary>\n         /// Initializes a new instance of BuildEventArgsWriter with a BinaryWriter\n         /// </summary>\n         /// <param name=\"binaryWriter\">A BinaryWriter to write the BuildEventArgs instances to</param>\n         public BuildEventArgsWriter(BinaryWriter binaryWriter)\n         {\n-            this.binaryWriter = binaryWriter;\n+            this.originalStream = binaryWriter.BaseStream;\n+            this.currentRecordStream = new MemoryStream(65536);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could this name have been preserved? I like the new name but it did add to the diff and tripped me up a bit.\r\n\r\n(I'm not saying \"go back and change this\", just asking if there's a reason it had to be this way)",
              "createdAt": "2021-01-11T16:59:58Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -718,34 +904,63 @@ private void Write(byte[] bytes)\n             binaryWriter.Write(bytes);\n         }\n \n+        private void Write(byte b)\n+        {\n+            binaryWriter.Write(b);\n+        }\n+\n         private void Write(bool boolean)\n         {\n             binaryWriter.Write(boolean);\n         }\n \n-        private void Write(string text)\n+        private void WriteDeduplicatedString(string text)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Technically I could rename Write to WriteRaw (it's only called once) and rename WriteDeduplicatedString back to Write to minimize the diff. But in about half the cases there'll still be a diff because half the cases call WriteOptionalString.",
              "createdAt": "2021-01-11T18:01:35Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -718,34 +904,63 @@ private void Write(byte[] bytes)\n             binaryWriter.Write(bytes);\n         }\n \n+        private void Write(byte b)\n+        {\n+            binaryWriter.Write(b);\n+        }\n+\n         private void Write(bool boolean)\n         {\n             binaryWriter.Write(boolean);\n         }\n \n-        private void Write(string text)\n+        private void WriteDeduplicatedString(string text)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "WriteOptionalString is no longer needed because WriteDeduplicatedString has the ability to write null by just using reserved index 0.",
              "createdAt": "2021-01-11T18:02:24Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -718,34 +904,63 @@ private void Write(byte[] bytes)\n             binaryWriter.Write(bytes);\n         }\n \n+        private void Write(byte b)\n+        {\n+            binaryWriter.Write(b);\n+        }\n+\n         private void Write(bool boolean)\n         {\n             binaryWriter.Write(boolean);\n         }\n \n-        private void Write(string text)\n+        private void WriteDeduplicatedString(string text)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "The historical reason is I first wasn't sure whether deduping all strings would be worse or better, so I deduped just some of them. But gradually I deduped more and more and it got better and better, so deduping all ended up being optimal. Of course I didn't know that from the outset so I kept a parallel name all the way.",
              "createdAt": "2021-01-11T18:03:57Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -718,34 +904,63 @@ private void Write(byte[] bytes)\n             binaryWriter.Write(bytes);\n         }\n \n+        private void Write(byte b)\n+        {\n+            binaryWriter.Write(b);\n+        }\n+\n         private void Write(bool boolean)\n         {\n             binaryWriter.Write(boolean);\n         }\n \n-        private void Write(string text)\n+        private void WriteDeduplicatedString(string text)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Thanks for explaining!",
              "createdAt": "2021-01-11T23:30:01Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -718,34 +904,63 @@ private void Write(byte[] bytes)\n             binaryWriter.Write(bytes);\n         }\n \n+        private void Write(byte b)\n+        {\n+            binaryWriter.Write(b);\n+        }\n+\n         private void Write(bool boolean)\n         {\n             binaryWriter.Write(boolean);\n         }\n \n-        private void Write(string text)\n+        private void WriteDeduplicatedString(string text)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why do this manipulation here rather than just adding the empty slots so the logical and physical indices match?",
              "createdAt": "2021-01-11T17:28:00Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -864,28 +1004,68 @@ private IEnumerable ReadItemList()\n \n             for (int i = 0; i < count; i++)\n             {\n-                ITaskItem item = ReadItem();\n+                ITaskItem item = ReadTaskItem();\n                 list.Add(item);\n             }\n \n             return list;\n         }\n \n+        private string ReadString()\n+        {\n+            return binaryReader.ReadString();\n+        }\n+\n         private string ReadOptionalString()\n         {\n-            if (ReadBoolean())\n+            if (fileFormatVersion < 10)\n             {\n-                return ReadString();\n+                if (ReadBoolean())\n+                {\n+                    return ReadString();\n+                }\n+                else\n+                {\n+                    return null;\n+                }\n             }\n-            else\n+\n+            return ReadDeduplicatedString();\n+        }\n+\n+        private string ReadDeduplicatedString()\n+        {\n+            if (fileFormatVersion < 10)\n             {\n-                return null;\n+                return ReadString();\n             }\n+\n+            int index = ReadInt32();\n+            return GetStringFromRecord(index);\n         }\n \n-        private string ReadString()\n+        private string GetStringFromRecord(int index)\n         {\n-            return binaryReader.ReadString();\n+            if (index == 0)\n+            {\n+                return null;\n+            }\n+            else if (index == 1)\n+            {\n+                return string.Empty;\n+            }\n+\n+            // we reserve numbers 2-9 for future use.\n+            // the writer assigns 10 as the index of the first string\n+            index -= BuildEventArgsWriter.StringStartIndex;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Adding the empty slots felt wasteful ;) Also 10 is a number I pulled out of my hat. I doubt we'll use these special slots in the future I'm always scared of painting myself in a corner. Maybe it's just FUD though.",
              "createdAt": "2021-01-11T17:57:31Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -864,28 +1004,68 @@ private IEnumerable ReadItemList()\n \n             for (int i = 0; i < count; i++)\n             {\n-                ITaskItem item = ReadItem();\n+                ITaskItem item = ReadTaskItem();\n                 list.Add(item);\n             }\n \n             return list;\n         }\n \n+        private string ReadString()\n+        {\n+            return binaryReader.ReadString();\n+        }\n+\n         private string ReadOptionalString()\n         {\n-            if (ReadBoolean())\n+            if (fileFormatVersion < 10)\n             {\n-                return ReadString();\n+                if (ReadBoolean())\n+                {\n+                    return ReadString();\n+                }\n+                else\n+                {\n+                    return null;\n+                }\n             }\n-            else\n+\n+            return ReadDeduplicatedString();\n+        }\n+\n+        private string ReadDeduplicatedString()\n+        {\n+            if (fileFormatVersion < 10)\n             {\n-                return null;\n+                return ReadString();\n             }\n+\n+            int index = ReadInt32();\n+            return GetStringFromRecord(index);\n         }\n \n-        private string ReadString()\n+        private string GetStringFromRecord(int index)\n         {\n-            return binaryReader.ReadString();\n+            if (index == 0)\n+            {\n+                return null;\n+            }\n+            else if (index == 1)\n+            {\n+                return string.Empty;\n+            }\n+\n+            // we reserve numbers 2-9 for future use.\n+            // the writer assigns 10 as the index of the first string\n+            index -= BuildEventArgsWriter.StringStartIndex;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Are there some strings (other than null and empty) that are far more common than others? I'm wondering if it would reduce the size of the binlog to have a Huffman encoding where the first bit being 0 indicates \"special string\" and 1 is other, and special means one of the most common strings and involves fewer bits. Probably too complicated to be worth it anyway.",
              "createdAt": "2021-01-11T19:34:22Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -864,28 +1004,68 @@ private IEnumerable ReadItemList()\n \n             for (int i = 0; i < count; i++)\n             {\n-                ITaskItem item = ReadItem();\n+                ITaskItem item = ReadTaskItem();\n                 list.Add(item);\n             }\n \n             return list;\n         }\n \n+        private string ReadString()\n+        {\n+            return binaryReader.ReadString();\n+        }\n+\n         private string ReadOptionalString()\n         {\n-            if (ReadBoolean())\n+            if (fileFormatVersion < 10)\n             {\n-                return ReadString();\n+                if (ReadBoolean())\n+                {\n+                    return ReadString();\n+                }\n+                else\n+                {\n+                    return null;\n+                }\n             }\n-            else\n+\n+            return ReadDeduplicatedString();\n+        }\n+\n+        private string ReadDeduplicatedString()\n+        {\n+            if (fileFormatVersion < 10)\n             {\n-                return null;\n+                return ReadString();\n             }\n+\n+            int index = ReadInt32();\n+            return GetStringFromRecord(index);\n         }\n \n-        private string ReadString()\n+        private string GetStringFromRecord(int index)\n         {\n-            return binaryReader.ReadString();\n+            if (index == 0)\n+            {\n+                return null;\n+            }\n+            else if (index == 1)\n+            {\n+                return string.Empty;\n+            }\n+\n+            // we reserve numbers 2-9 for future use.\n+            // the writer assigns 10 as the index of the first string\n+            index -= BuildEventArgsWriter.StringStartIndex;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yeah, a bit too complicated. Remember that the entire thing is also compressed by GZipStream.",
              "createdAt": "2021-01-11T19:53:49Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -864,28 +1004,68 @@ private IEnumerable ReadItemList()\n \n             for (int i = 0; i < count; i++)\n             {\n-                ITaskItem item = ReadItem();\n+                ITaskItem item = ReadTaskItem();\n                 list.Add(item);\n             }\n \n             return list;\n         }\n \n+        private string ReadString()\n+        {\n+            return binaryReader.ReadString();\n+        }\n+\n         private string ReadOptionalString()\n         {\n-            if (ReadBoolean())\n+            if (fileFormatVersion < 10)\n             {\n-                return ReadString();\n+                if (ReadBoolean())\n+                {\n+                    return ReadString();\n+                }\n+                else\n+                {\n+                    return null;\n+                }\n             }\n-            else\n+\n+            return ReadDeduplicatedString();\n+        }\n+\n+        private string ReadDeduplicatedString()\n+        {\n+            if (fileFormatVersion < 10)\n             {\n-                return null;\n+                return ReadString();\n             }\n+\n+            int index = ReadInt32();\n+            return GetStringFromRecord(index);\n         }\n \n-        private string ReadString()\n+        private string GetStringFromRecord(int index)\n         {\n-            return binaryReader.ReadString();\n+            if (index == 0)\n+            {\n+                return null;\n+            }\n+            else if (index == 1)\n+            {\n+                return string.Empty;\n+            }\n+\n+            // we reserve numbers 2-9 for future use.\n+            // the writer assigns 10 as the index of the first string\n+            index -= BuildEventArgsWriter.StringStartIndex;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "The index is a signed integer so you could have treated all negative numbers as reserved and have the (non-negative) indices for real strings match logical vs. physical.\r\n\r\nE.g. `-1` for `null`, `-2` for `String.Empty`",
              "createdAt": "2021-01-12T09:39:13Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -864,28 +1004,68 @@ private IEnumerable ReadItemList()\n \n             for (int i = 0; i < count; i++)\n             {\n-                ITaskItem item = ReadItem();\n+                ITaskItem item = ReadTaskItem();\n                 list.Add(item);\n             }\n \n             return list;\n         }\n \n+        private string ReadString()\n+        {\n+            return binaryReader.ReadString();\n+        }\n+\n         private string ReadOptionalString()\n         {\n-            if (ReadBoolean())\n+            if (fileFormatVersion < 10)\n             {\n-                return ReadString();\n+                if (ReadBoolean())\n+                {\n+                    return ReadString();\n+                }\n+                else\n+                {\n+                    return null;\n+                }\n             }\n-            else\n+\n+            return ReadDeduplicatedString();\n+        }\n+\n+        private string ReadDeduplicatedString()\n+        {\n+            if (fileFormatVersion < 10)\n             {\n-                return null;\n+                return ReadString();\n             }\n+\n+            int index = ReadInt32();\n+            return GetStringFromRecord(index);\n         }\n \n-        private string ReadString()\n+        private string GetStringFromRecord(int index)\n         {\n-            return binaryReader.ReadString();\n+            if (index == 0)\n+            {\n+                return null;\n+            }\n+            else if (index == 1)\n+            {\n+                return string.Empty;\n+            }\n+\n+            // we reserve numbers 2-9 for future use.\n+            // the writer assigns 10 as the index of the first string\n+            index -= BuildEventArgsWriter.StringStartIndex;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Oh, I see, that would waste space because of the 7bit encoding, never mind!",
              "createdAt": "2021-01-12T09:45:00Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -864,28 +1004,68 @@ private IEnumerable ReadItemList()\n \n             for (int i = 0; i < count; i++)\n             {\n-                ITaskItem item = ReadItem();\n+                ITaskItem item = ReadTaskItem();\n                 list.Add(item);\n             }\n \n             return list;\n         }\n \n+        private string ReadString()\n+        {\n+            return binaryReader.ReadString();\n+        }\n+\n         private string ReadOptionalString()\n         {\n-            if (ReadBoolean())\n+            if (fileFormatVersion < 10)\n             {\n-                return ReadString();\n+                if (ReadBoolean())\n+                {\n+                    return ReadString();\n+                }\n+                else\n+                {\n+                    return null;\n+                }\n             }\n-            else\n+\n+            return ReadDeduplicatedString();\n+        }\n+\n+        private string ReadDeduplicatedString()\n+        {\n+            if (fileFormatVersion < 10)\n             {\n-                return null;\n+                return ReadString();\n             }\n+\n+            int index = ReadInt32();\n+            return GetStringFromRecord(index);\n         }\n \n-        private string ReadString()\n+        private string GetStringFromRecord(int index)\n         {\n-            return binaryReader.ReadString();\n+            if (index == 0)\n+            {\n+                return null;\n+            }\n+            else if (index == 1)\n+            {\n+                return string.Empty;\n+            }\n+\n+            // we reserve numbers 2-9 for future use.\n+            // the writer assigns 10 as the index of the first string\n+            index -= BuildEventArgsWriter.StringStartIndex;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Comment catch-all please",
              "createdAt": "2021-01-11T17:30:04Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1152,145 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096,\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);\n+                    streamWriter.AutoFlush = true;\n+                    streamReader = new StreamReader(stream, utf8noBom);\n+                    stringBuilder = new StringBuilder();\n+                }\n+            }\n+\n+            private long totalAllocatedShortStrings = 0;\n+\n+            public object Add(string text)\n+            {\n+                if (filePath == null)\n+                {\n+                    // on 64-bit, we have as much memory as we want\n+                    // so no need to write to the file at all\n+                    return text;\n+                }\n+\n+                // Tradeoff between not crashing with OOM on large binlogs and\n+                // keeping the playback of smaller binlogs relatively fast.\n+                // It is slow to store all small strings in the file and constantly\n+                // seek to retrieve them. Instead we'll keep storing small strings\n+                // in memory until we allocate 2 GB. After that, all strings go to\n+                // the file.\n+                // Win-win: small binlog playback is fast and large binlog playback\n+                // doesn't OOM.\n+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 2_000_000_000)\n+                {\n+                    // note that we write strings in UTF8 so we don't need to multiply by 2 as chars\n+                    // will be 1 byte on average\n+                    totalAllocatedShortStrings += text.Length;\n+                    return text;\n+                }\n+\n+                var stringPosition = new StringPosition();\n+\n+                stringPosition.FilePosition = stream.Position;\n+\n+                streamWriter.Write(text);\n+\n+                stringPosition.StringLength = text.Length;\n+                return stringPosition;\n+            }\n+\n+            public string Get(object storedString)\n+            {\n+                if (storedString is string text)\n+                {\n+                    return text;\n+                }\n+\n+                var position = (StringPosition)storedString;\n+\n+                stream.Position = position.FilePosition;\n+                stringBuilder.Length = position.StringLength;\n+                for (int i = 0; i < position.StringLength; i++)\n+                {\n+                    char ch = (char)streamReader.Read();\n+                    stringBuilder[i] = ch;\n+                }\n+\n+                stream.Position = stream.Length;\n+                streamReader.DiscardBufferedData();\n+\n+                string result = stringBuilder.ToString();\n+                stringBuilder.Clear();\n+                return result;\n+            }\n+\n+            public void Dispose()\n+            {\n+                try\n+                {\n+                    if (streamWriter != null)\n+                    {\n+                        streamWriter.Dispose();\n+                        streamWriter = null;\n+                    }\n+\n+                    if (stream != null)\n+                    {\n+                        stream.Dispose();\n+                        stream = null;\n+                    }\n+                }\n+                catch\n+                {\n+                }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "If I comment it it won't catch exceptions ;P",
              "createdAt": "2021-01-11T18:05:24Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1152,145 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096,\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);\n+                    streamWriter.AutoFlush = true;\n+                    streamReader = new StreamReader(stream, utf8noBom);\n+                    stringBuilder = new StringBuilder();\n+                }\n+            }\n+\n+            private long totalAllocatedShortStrings = 0;\n+\n+            public object Add(string text)\n+            {\n+                if (filePath == null)\n+                {\n+                    // on 64-bit, we have as much memory as we want\n+                    // so no need to write to the file at all\n+                    return text;\n+                }\n+\n+                // Tradeoff between not crashing with OOM on large binlogs and\n+                // keeping the playback of smaller binlogs relatively fast.\n+                // It is slow to store all small strings in the file and constantly\n+                // seek to retrieve them. Instead we'll keep storing small strings\n+                // in memory until we allocate 2 GB. After that, all strings go to\n+                // the file.\n+                // Win-win: small binlog playback is fast and large binlog playback\n+                // doesn't OOM.\n+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 2_000_000_000)\n+                {\n+                    // note that we write strings in UTF8 so we don't need to multiply by 2 as chars\n+                    // will be 1 byte on average\n+                    totalAllocatedShortStrings += text.Length;\n+                    return text;\n+                }\n+\n+                var stringPosition = new StringPosition();\n+\n+                stringPosition.FilePosition = stream.Position;\n+\n+                streamWriter.Write(text);\n+\n+                stringPosition.StringLength = text.Length;\n+                return stringPosition;\n+            }\n+\n+            public string Get(object storedString)\n+            {\n+                if (storedString is string text)\n+                {\n+                    return text;\n+                }\n+\n+                var position = (StringPosition)storedString;\n+\n+                stream.Position = position.FilePosition;\n+                stringBuilder.Length = position.StringLength;\n+                for (int i = 0; i < position.StringLength; i++)\n+                {\n+                    char ch = (char)streamReader.Read();\n+                    stringBuilder[i] = ch;\n+                }\n+\n+                stream.Position = stream.Length;\n+                streamReader.DiscardBufferedData();\n+\n+                string result = stringBuilder.ToString();\n+                stringBuilder.Clear();\n+                return result;\n+            }\n+\n+            public void Dispose()\n+            {\n+                try\n+                {\n+                    if (streamWriter != null)\n+                    {\n+                        streamWriter.Dispose();\n+                        streamWriter = null;\n+                    }\n+\n+                    if (stream != null)\n+                    {\n+                        stream.Dispose();\n+                        stream = null;\n+                    }\n+                }\n+                catch\n+                {\n+                }",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "j/k will add",
              "createdAt": "2021-01-11T18:05:34Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1152,145 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096,\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);\n+                    streamWriter.AutoFlush = true;\n+                    streamReader = new StreamReader(stream, utf8noBom);\n+                    stringBuilder = new StringBuilder();\n+                }\n+            }\n+\n+            private long totalAllocatedShortStrings = 0;\n+\n+            public object Add(string text)\n+            {\n+                if (filePath == null)\n+                {\n+                    // on 64-bit, we have as much memory as we want\n+                    // so no need to write to the file at all\n+                    return text;\n+                }\n+\n+                // Tradeoff between not crashing with OOM on large binlogs and\n+                // keeping the playback of smaller binlogs relatively fast.\n+                // It is slow to store all small strings in the file and constantly\n+                // seek to retrieve them. Instead we'll keep storing small strings\n+                // in memory until we allocate 2 GB. After that, all strings go to\n+                // the file.\n+                // Win-win: small binlog playback is fast and large binlog playback\n+                // doesn't OOM.\n+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 2_000_000_000)\n+                {\n+                    // note that we write strings in UTF8 so we don't need to multiply by 2 as chars\n+                    // will be 1 byte on average\n+                    totalAllocatedShortStrings += text.Length;\n+                    return text;\n+                }\n+\n+                var stringPosition = new StringPosition();\n+\n+                stringPosition.FilePosition = stream.Position;\n+\n+                streamWriter.Write(text);\n+\n+                stringPosition.StringLength = text.Length;\n+                return stringPosition;\n+            }\n+\n+            public string Get(object storedString)\n+            {\n+                if (storedString is string text)\n+                {\n+                    return text;\n+                }\n+\n+                var position = (StringPosition)storedString;\n+\n+                stream.Position = position.FilePosition;\n+                stringBuilder.Length = position.StringLength;\n+                for (int i = 0; i < position.StringLength; i++)\n+                {\n+                    char ch = (char)streamReader.Read();\n+                    stringBuilder[i] = ch;\n+                }\n+\n+                stream.Position = stream.Length;\n+                streamReader.DiscardBufferedData();\n+\n+                string result = stringBuilder.ToString();\n+                stringBuilder.Clear();\n+                return result;\n+            }\n+\n+            public void Dispose()\n+            {\n+                try\n+                {\n+                    if (streamWriter != null)\n+                    {\n+                        streamWriter.Dispose();\n+                        streamWriter = null;\n+                    }\n+\n+                    if (stream != null)\n+                    {\n+                        stream.Dispose();\n+                        stream = null;\n+                    }\n+                }\n+                catch\n+                {\n+                }",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this ordered by how frequently each kind of record appears?",
              "createdAt": "2021-01-11T17:48:22Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -49,9 +78,23 @@ public BuildEventArgs Read()\n         {\n             BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();\n \n-            while (IsBlob(recordKind))\n+            // Skip over data storage records since they don't result in a BuildEventArgs.\n+            // just ingest their data and continue.\n+            while (IsAuxiliaryRecord(recordKind))\n             {\n-                ReadBlob(recordKind);\n+                // these are ordered by commonality\n+                if (recordKind == BinaryLogRecordKind.String)\n+                {\n+                    ReadStringRecord();\n+                }\n+                else if (recordKind == BinaryLogRecordKind.NameValueList)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yup, see above: // these are ordered by commonality",
              "createdAt": "2021-01-11T19:51:43Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -49,9 +78,23 @@ public BuildEventArgs Read()\n         {\n             BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();\n \n-            while (IsBlob(recordKind))\n+            // Skip over data storage records since they don't result in a BuildEventArgs.\n+            // just ingest their data and continue.\n+            while (IsAuxiliaryRecord(recordKind))\n             {\n-                ReadBlob(recordKind);\n+                // these are ordered by commonality\n+                if (recordKind == BinaryLogRecordKind.String)\n+                {\n+                    ReadStringRecord();\n+                }\n+                else if (recordKind == BinaryLogRecordKind.NameValueList)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "\ud83e\udd10 I promise I know how to read.",
              "createdAt": "2021-01-11T20:04:04Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -49,9 +78,23 @@ public BuildEventArgs Read()\n         {\n             BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();\n \n-            while (IsBlob(recordKind))\n+            // Skip over data storage records since they don't result in a BuildEventArgs.\n+            // just ingest their data and continue.\n+            while (IsAuxiliaryRecord(recordKind))\n             {\n-                ReadBlob(recordKind);\n+                // these are ordered by commonality\n+                if (recordKind == BinaryLogRecordKind.String)\n+                {\n+                    ReadStringRecord();\n+                }\n+                else if (recordKind == BinaryLogRecordKind.NameValueList)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: Copy the previous comment explaining this magic number. Or make a const var for it.",
              "createdAt": "2021-01-12T02:38:24Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -137,6 +143,7 @@ public void Initialize(IEventSource eventSource)\n             }\n \n             stream = new GZipStream(stream, CompressionLevel.Optimal);\n+            stream = new BufferedStream(stream, bufferSize: 32768);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Done",
              "createdAt": "2021-01-15T00:27:01Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -137,6 +143,7 @@ public void Initialize(IEventSource eventSource)\n             }\n \n             stream = new GZipStream(stream, CompressionLevel.Optimal);\n+            stream = new BufferedStream(stream, bufferSize: 32768);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Comment magic number or create a var for it.",
              "createdAt": "2021-01-12T02:54:17Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1152,149 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096,\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Done",
              "createdAt": "2021-01-15T00:26:54Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1152,149 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096,\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "So this is where an inconsistency is detected. Shouldn't it throw `FormatException` like `Read7BitEncodedInt` does, instead of swallowing?",
              "createdAt": "2021-01-12T09:47:02Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -864,28 +1004,68 @@ private IEnumerable ReadItemList()\n \n             for (int i = 0; i < count; i++)\n             {\n-                ITaskItem item = ReadItem();\n+                ITaskItem item = ReadTaskItem();\n                 list.Add(item);\n             }\n \n             return list;\n         }\n \n+        private string ReadString()\n+        {\n+            return binaryReader.ReadString();\n+        }\n+\n         private string ReadOptionalString()\n         {\n-            if (ReadBoolean())\n+            if (fileFormatVersion < 10)\n             {\n-                return ReadString();\n+                if (ReadBoolean())\n+                {\n+                    return ReadString();\n+                }\n+                else\n+                {\n+                    return null;\n+                }\n             }\n-            else\n+\n+            return ReadDeduplicatedString();\n+        }\n+\n+        private string ReadDeduplicatedString()\n+        {\n+            if (fileFormatVersion < 10)\n             {\n-                return null;\n+                return ReadString();\n             }\n+\n+            int index = ReadInt32();\n+            return GetStringFromRecord(index);\n         }\n \n-        private string ReadString()\n+        private string GetStringFromRecord(int index)\n         {\n-            return binaryReader.ReadString();\n+            if (index == 0)\n+            {\n+                return null;\n+            }\n+            else if (index == 1)\n+            {\n+                return string.Empty;\n+            }\n+\n+            // we reserve numbers 2-9 for future use.\n+            // the writer assigns 10 as the index of the first string\n+            index -= BuildEventArgsWriter.StringStartIndex;\n+            if (index >= 0 && index < this.stringRecords.Count)\n+            {\n+                object storedString = stringRecords[index];\n+                string result = stringStorage.Get(storedString);\n+                return result;\n+            }\n+\n+            return string.Empty;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I think you're right, it's better to crash as soon as you noticed that something has gone wrong. I'll add an informative exception.",
              "createdAt": "2021-01-13T20:11:36Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -864,28 +1004,68 @@ private IEnumerable ReadItemList()\n \n             for (int i = 0; i < count; i++)\n             {\n-                ITaskItem item = ReadItem();\n+                ITaskItem item = ReadTaskItem();\n                 list.Add(item);\n             }\n \n             return list;\n         }\n \n+        private string ReadString()\n+        {\n+            return binaryReader.ReadString();\n+        }\n+\n         private string ReadOptionalString()\n         {\n-            if (ReadBoolean())\n+            if (fileFormatVersion < 10)\n             {\n-                return ReadString();\n+                if (ReadBoolean())\n+                {\n+                    return ReadString();\n+                }\n+                else\n+                {\n+                    return null;\n+                }\n             }\n-            else\n+\n+            return ReadDeduplicatedString();\n+        }\n+\n+        private string ReadDeduplicatedString()\n+        {\n+            if (fileFormatVersion < 10)\n             {\n-                return null;\n+                return ReadString();\n             }\n+\n+            int index = ReadInt32();\n+            return GetStringFromRecord(index);\n         }\n \n-        private string ReadString()\n+        private string GetStringFromRecord(int index)\n         {\n-            return binaryReader.ReadString();\n+            if (index == 0)\n+            {\n+                return null;\n+            }\n+            else if (index == 1)\n+            {\n+                return string.Empty;\n+            }\n+\n+            // we reserve numbers 2-9 for future use.\n+            // the writer assigns 10 as the index of the first string\n+            index -= BuildEventArgsWriter.StringStartIndex;\n+            if (index >= 0 && index < this.stringRecords.Count)\n+            {\n+                object storedString = stringRecords[index];\n+                string result = stringStorage.Get(storedString);\n+                return result;\n+            }\n+\n+            return string.Empty;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I changed it to throw an exception.",
              "createdAt": "2021-01-15T02:02:04Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -864,28 +1004,68 @@ private IEnumerable ReadItemList()\n \n             for (int i = 0; i < count; i++)\n             {\n-                ITaskItem item = ReadItem();\n+                ITaskItem item = ReadTaskItem();\n                 list.Add(item);\n             }\n \n             return list;\n         }\n \n+        private string ReadString()\n+        {\n+            return binaryReader.ReadString();\n+        }\n+\n         private string ReadOptionalString()\n         {\n-            if (ReadBoolean())\n+            if (fileFormatVersion < 10)\n             {\n-                return ReadString();\n+                if (ReadBoolean())\n+                {\n+                    return ReadString();\n+                }\n+                else\n+                {\n+                    return null;\n+                }\n             }\n-            else\n+\n+            return ReadDeduplicatedString();\n+        }\n+\n+        private string ReadDeduplicatedString()\n+        {\n+            if (fileFormatVersion < 10)\n             {\n-                return null;\n+                return ReadString();\n             }\n+\n+            int index = ReadInt32();\n+            return GetStringFromRecord(index);\n         }\n \n-        private string ReadString()\n+        private string GetStringFromRecord(int index)\n         {\n-            return binaryReader.ReadString();\n+            if (index == 0)\n+            {\n+                return null;\n+            }\n+            else if (index == 1)\n+            {\n+                return string.Empty;\n+            }\n+\n+            // we reserve numbers 2-9 for future use.\n+            // the writer assigns 10 as the index of the first string\n+            index -= BuildEventArgsWriter.StringStartIndex;\n+            if (index >= 0 && index < this.stringRecords.Count)\n+            {\n+                object storedString = stringRecords[index];\n+                string result = stringStorage.Get(storedString);\n+                return result;\n+            }\n+\n+            return string.Empty;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Some of these fields can be `readonly`.",
              "createdAt": "2021-01-15T12:49:51Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1161,152 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Fixed",
              "createdAt": "2021-01-17T03:23:31Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1161,152 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Dispose of the `streamReader` here as well?",
              "createdAt": "2021-01-15T12:51:24Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1161,152 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096, // 4096 seems to have the best performance on SSD\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+\n+                    // 65536 has no particular significance, and maybe could be tuned\n+                    // but 65536 performs well enough and isn't a lot of memory for a singleton\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);\n+                    streamWriter.AutoFlush = true;\n+                    streamReader = new StreamReader(stream, utf8noBom);\n+                    stringBuilder = new StringBuilder();\n+                }\n+            }\n+\n+            private long totalAllocatedShortStrings = 0;\n+\n+            public object Add(string text)\n+            {\n+                if (filePath == null)\n+                {\n+                    // on 64-bit, we have as much memory as we want\n+                    // so no need to write to the file at all\n+                    return text;\n+                }\n+\n+                // Tradeoff between not crashing with OOM on large binlogs and\n+                // keeping the playback of smaller binlogs relatively fast.\n+                // It is slow to store all small strings in the file and constantly\n+                // seek to retrieve them. Instead we'll keep storing small strings\n+                // in memory until we allocate 2 GB. After that, all strings go to\n+                // the file.\n+                // Win-win: small binlog playback is fast and large binlog playback\n+                // doesn't OOM.\n+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 2_000_000_000)\n+                {\n+                    // note that we write strings in UTF8 so we don't need to multiply by 2 as chars\n+                    // will be 1 byte on average\n+                    totalAllocatedShortStrings += text.Length;\n+                    return text;\n+                }\n+\n+                var stringPosition = new StringPosition();\n+\n+                stringPosition.FilePosition = stream.Position;\n+\n+                streamWriter.Write(text);\n+\n+                stringPosition.StringLength = text.Length;\n+                return stringPosition;\n+            }\n+\n+            public string Get(object storedString)\n+            {\n+                if (storedString is string text)\n+                {\n+                    return text;\n+                }\n+\n+                var position = (StringPosition)storedString;\n+\n+                stream.Position = position.FilePosition;\n+                stringBuilder.Length = position.StringLength;\n+                for (int i = 0; i < position.StringLength; i++)\n+                {\n+                    char ch = (char)streamReader.Read();\n+                    stringBuilder[i] = ch;\n+                }\n+\n+                stream.Position = stream.Length;\n+                streamReader.DiscardBufferedData();\n+\n+                string result = stringBuilder.ToString();\n+                stringBuilder.Clear();\n+                return result;\n+            }\n+\n+            public void Dispose()\n+            {\n+                try\n+                {\n+                    if (streamWriter != null)\n+                    {\n+                        streamWriter.Dispose();\n+                        streamWriter = null;\n+                    }\n+",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Nothing interesting happens in StreamReader.Dispose(): https://referencesource.microsoft.com/#mscorlib/system/io/streamreader.cs,011147a163b10458",
              "createdAt": "2021-01-17T03:23:19Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1161,152 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096, // 4096 seems to have the best performance on SSD\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+\n+                    // 65536 has no particular significance, and maybe could be tuned\n+                    // but 65536 performs well enough and isn't a lot of memory for a singleton\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);\n+                    streamWriter.AutoFlush = true;\n+                    streamReader = new StreamReader(stream, utf8noBom);\n+                    stringBuilder = new StringBuilder();\n+                }\n+            }\n+\n+            private long totalAllocatedShortStrings = 0;\n+\n+            public object Add(string text)\n+            {\n+                if (filePath == null)\n+                {\n+                    // on 64-bit, we have as much memory as we want\n+                    // so no need to write to the file at all\n+                    return text;\n+                }\n+\n+                // Tradeoff between not crashing with OOM on large binlogs and\n+                // keeping the playback of smaller binlogs relatively fast.\n+                // It is slow to store all small strings in the file and constantly\n+                // seek to retrieve them. Instead we'll keep storing small strings\n+                // in memory until we allocate 2 GB. After that, all strings go to\n+                // the file.\n+                // Win-win: small binlog playback is fast and large binlog playback\n+                // doesn't OOM.\n+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 2_000_000_000)\n+                {\n+                    // note that we write strings in UTF8 so we don't need to multiply by 2 as chars\n+                    // will be 1 byte on average\n+                    totalAllocatedShortStrings += text.Length;\n+                    return text;\n+                }\n+\n+                var stringPosition = new StringPosition();\n+\n+                stringPosition.FilePosition = stream.Position;\n+\n+                streamWriter.Write(text);\n+\n+                stringPosition.StringLength = text.Length;\n+                return stringPosition;\n+            }\n+\n+            public string Get(object storedString)\n+            {\n+                if (storedString is string text)\n+                {\n+                    return text;\n+                }\n+\n+                var position = (StringPosition)storedString;\n+\n+                stream.Position = position.FilePosition;\n+                stringBuilder.Length = position.StringLength;\n+                for (int i = 0; i < position.StringLength; i++)\n+                {\n+                    char ch = (char)streamReader.Read();\n+                    stringBuilder[i] = ch;\n+                }\n+\n+                stream.Position = stream.Length;\n+                streamReader.DiscardBufferedData();\n+\n+                string result = stringBuilder.ToString();\n+                stringBuilder.Clear();\n+                return result;\n+            }\n+\n+            public void Dispose()\n+            {\n+                try\n+                {\n+                    if (streamWriter != null)\n+                    {\n+                        streamWriter.Dispose();\n+                        streamWriter = null;\n+                    }\n+",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Strings are stored in UTF-16 in memory, though, so when you hit 2 billion characters you will have exhausted the 32-bit address space. I think you want to multiply by 2 here.",
              "createdAt": "2021-01-15T12:56:12Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1161,152 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096, // 4096 seems to have the best performance on SSD\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+\n+                    // 65536 has no particular significance, and maybe could be tuned\n+                    // but 65536 performs well enough and isn't a lot of memory for a singleton\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);\n+                    streamWriter.AutoFlush = true;\n+                    streamReader = new StreamReader(stream, utf8noBom);\n+                    stringBuilder = new StringBuilder();\n+                }\n+            }\n+\n+            private long totalAllocatedShortStrings = 0;\n+\n+            public object Add(string text)\n+            {\n+                if (filePath == null)\n+                {\n+                    // on 64-bit, we have as much memory as we want\n+                    // so no need to write to the file at all\n+                    return text;\n+                }\n+\n+                // Tradeoff between not crashing with OOM on large binlogs and\n+                // keeping the playback of smaller binlogs relatively fast.\n+                // It is slow to store all small strings in the file and constantly\n+                // seek to retrieve them. Instead we'll keep storing small strings\n+                // in memory until we allocate 2 GB. After that, all strings go to\n+                // the file.\n+                // Win-win: small binlog playback is fast and large binlog playback\n+                // doesn't OOM.\n+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 2_000_000_000)\n+                {\n+                    // note that we write strings in UTF8 so we don't need to multiply by 2 as chars\n+                    // will be 1 byte on average\n+                    totalAllocatedShortStrings += text.Length;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "MSBuild sets the LargeAddressAware flag that lets it address up to 4GB. I've seen MSBuild.exe easily with 2.8 GB commit memory. The thinking here is that MSBuild.exe can't be doing anything other than binlog playback so we're free to spend most of the process memory on caching as many strings we can.\r\nHowever your point that strings are two bytes per char in memory is valid, so I reduced to 1 billion instead.",
              "createdAt": "2021-01-17T02:52:30Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1161,152 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096, // 4096 seems to have the best performance on SSD\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+\n+                    // 65536 has no particular significance, and maybe could be tuned\n+                    // but 65536 performs well enough and isn't a lot of memory for a singleton\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);\n+                    streamWriter.AutoFlush = true;\n+                    streamReader = new StreamReader(stream, utf8noBom);\n+                    stringBuilder = new StringBuilder();\n+                }\n+            }\n+\n+            private long totalAllocatedShortStrings = 0;\n+\n+            public object Add(string text)\n+            {\n+                if (filePath == null)\n+                {\n+                    // on 64-bit, we have as much memory as we want\n+                    // so no need to write to the file at all\n+                    return text;\n+                }\n+\n+                // Tradeoff between not crashing with OOM on large binlogs and\n+                // keeping the playback of smaller binlogs relatively fast.\n+                // It is slow to store all small strings in the file and constantly\n+                // seek to retrieve them. Instead we'll keep storing small strings\n+                // in memory until we allocate 2 GB. After that, all strings go to\n+                // the file.\n+                // Win-win: small binlog playback is fast and large binlog playback\n+                // doesn't OOM.\n+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 2_000_000_000)\n+                {\n+                    // note that we write strings in UTF8 so we don't need to multiply by 2 as chars\n+                    // will be 1 byte on average\n+                    totalAllocatedShortStrings += text.Length;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "@KirillOsenkov \r\n\r\n>MSBuild sets the LargeAddressAware flag that lets it address up to 4GB. I've seen MSBuild.exe easily with 2.8 GB commit memory. The thinking here is that MSBuild.exe can't be doing anything other than binlog playback so we're free to spend most of the process memory on caching as many strings we can.\r\n\r\nI would be careful with this thought. So sometimes there is a poorly written MSBuild Project extension that does all types of nasty things (such as a poor logger or something else), or if they cache a large number of properties or projects. We were encountering the 3.8gb or whatever it was limitation in 32bit MSBuild causing us to switch to MSBuild64 to allow us to address more memory. It was not unusual to see msbuild.exe usage in the 8-9gb territory for us per node (multiply that out by the number of nodes when using `/maxCPU`). \r\n\r\nBasically the third party vendor was doing the equivalent of this, for every single project the changing the properties polluting the cache:\r\n\r\n`ProjectCollection.LoadProject(string)`\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/microsoft.build.evaluation.projectcollection.loadproject?view=msbuild-16-netcore#Microsoft_Build_Evaluation_ProjectCollection_LoadProject_System_String_\r\n\r\nWhile I believe the vendor eventually fixed it it took them well over 4 years to do so, and I still think they have not fixed everywhere they did this pattern. @madkat.\r\n",
              "createdAt": "2021-01-17T13:59:16Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1161,152 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096, // 4096 seems to have the best performance on SSD\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+\n+                    // 65536 has no particular significance, and maybe could be tuned\n+                    // but 65536 performs well enough and isn't a lot of memory for a singleton\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);\n+                    streamWriter.AutoFlush = true;\n+                    streamReader = new StreamReader(stream, utf8noBom);\n+                    stringBuilder = new StringBuilder();\n+                }\n+            }\n+\n+            private long totalAllocatedShortStrings = 0;\n+\n+            public object Add(string text)\n+            {\n+                if (filePath == null)\n+                {\n+                    // on 64-bit, we have as much memory as we want\n+                    // so no need to write to the file at all\n+                    return text;\n+                }\n+\n+                // Tradeoff between not crashing with OOM on large binlogs and\n+                // keeping the playback of smaller binlogs relatively fast.\n+                // It is slow to store all small strings in the file and constantly\n+                // seek to retrieve them. Instead we'll keep storing small strings\n+                // in memory until we allocate 2 GB. After that, all strings go to\n+                // the file.\n+                // Win-win: small binlog playback is fast and large binlog playback\n+                // doesn't OOM.\n+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 2_000_000_000)\n+                {\n+                    // note that we write strings in UTF8 so we don't need to multiply by 2 as chars\n+                    // will be 1 byte on average\n+                    totalAllocatedShortStrings += text.Length;",
              "author": {
                "login": "aolszowka"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Why not use `StreamReader.Read(Char[], Int32, Int32)` to read into an array and then `new String(Char[])`?",
              "createdAt": "2021-01-15T13:01:29Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1161,152 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096, // 4096 seems to have the best performance on SSD\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+\n+                    // 65536 has no particular significance, and maybe could be tuned\n+                    // but 65536 performs well enough and isn't a lot of memory for a singleton\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);\n+                    streamWriter.AutoFlush = true;\n+                    streamReader = new StreamReader(stream, utf8noBom);\n+                    stringBuilder = new StringBuilder();\n+                }\n+            }\n+\n+            private long totalAllocatedShortStrings = 0;\n+\n+            public object Add(string text)\n+            {\n+                if (filePath == null)\n+                {\n+                    // on 64-bit, we have as much memory as we want\n+                    // so no need to write to the file at all\n+                    return text;\n+                }\n+\n+                // Tradeoff between not crashing with OOM on large binlogs and\n+                // keeping the playback of smaller binlogs relatively fast.\n+                // It is slow to store all small strings in the file and constantly\n+                // seek to retrieve them. Instead we'll keep storing small strings\n+                // in memory until we allocate 2 GB. After that, all strings go to\n+                // the file.\n+                // Win-win: small binlog playback is fast and large binlog playback\n+                // doesn't OOM.\n+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 2_000_000_000)\n+                {\n+                    // note that we write strings in UTF8 so we don't need to multiply by 2 as chars\n+                    // will be 1 byte on average\n+                    totalAllocatedShortStrings += text.Length;\n+                    return text;\n+                }\n+\n+                var stringPosition = new StringPosition();\n+\n+                stringPosition.FilePosition = stream.Position;\n+\n+                streamWriter.Write(text);\n+\n+                stringPosition.StringLength = text.Length;\n+                return stringPosition;\n+            }\n+\n+            public string Get(object storedString)\n+            {\n+                if (storedString is string text)\n+                {\n+                    return text;\n+                }\n+\n+                var position = (StringPosition)storedString;\n+\n+                stream.Position = position.FilePosition;\n+                stringBuilder.Length = position.StringLength;\n+                for (int i = 0; i < position.StringLength; i++)\n+                {\n+                    char ch = (char)streamReader.Read();\n+                    stringBuilder[i] = ch;\n+                }",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Then I'd have to manage the char array myself (reuse to avoid reallocating and preallocated proper size). This way I let StringBuilder manage and reuse the char array chains it allocates. Once our StringBuilder reaches the threshold length here, it continues with no allocations except to create the final string.",
              "createdAt": "2021-01-17T02:55:27Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs",
              "diffHunk": "@@ -972,10 +1161,152 @@ private EvaluationLocation ReadEvaluationLocation()\n                 {\n                     parentId = ReadInt64();\n                 }\n+\n                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n             }\n \n             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);\n         }\n+\n+        /// <summary>\n+        /// Locates the string in the page file.\n+        /// </summary>\n+        internal class StringPosition\n+        {\n+            /// <summary>\n+            /// Offset in the file.\n+            /// </summary>\n+            public long FilePosition;\n+\n+            /// <summary>\n+            /// The length of the string in chars (not bytes).\n+            /// </summary>\n+            public int StringLength;\n+        }\n+\n+        /// <summary>\n+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.\n+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.\n+        /// </summary>\n+        internal class StringStorage : IDisposable\n+        {\n+            private string filePath;\n+            private FileStream stream;\n+            private StreamWriter streamWriter;\n+            private StreamReader streamReader;\n+            private StringBuilder stringBuilder;\n+\n+            public const int StringSizeThreshold = 1024;\n+\n+            public StringStorage()\n+            {\n+                if (!Environment.Is64BitProcess)\n+                {\n+                    filePath = Path.GetTempFileName();\n+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);\n+                    stream = new FileStream(\n+                        filePath,\n+                        FileMode.OpenOrCreate,\n+                        FileAccess.ReadWrite,\n+                        FileShare.None,\n+                        bufferSize: 4096, // 4096 seems to have the best performance on SSD\n+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);\n+\n+                    // 65536 has no particular significance, and maybe could be tuned\n+                    // but 65536 performs well enough and isn't a lot of memory for a singleton\n+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);\n+                    streamWriter.AutoFlush = true;\n+                    streamReader = new StreamReader(stream, utf8noBom);\n+                    stringBuilder = new StringBuilder();\n+                }\n+            }\n+\n+            private long totalAllocatedShortStrings = 0;\n+\n+            public object Add(string text)\n+            {\n+                if (filePath == null)\n+                {\n+                    // on 64-bit, we have as much memory as we want\n+                    // so no need to write to the file at all\n+                    return text;\n+                }\n+\n+                // Tradeoff between not crashing with OOM on large binlogs and\n+                // keeping the playback of smaller binlogs relatively fast.\n+                // It is slow to store all small strings in the file and constantly\n+                // seek to retrieve them. Instead we'll keep storing small strings\n+                // in memory until we allocate 2 GB. After that, all strings go to\n+                // the file.\n+                // Win-win: small binlog playback is fast and large binlog playback\n+                // doesn't OOM.\n+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 2_000_000_000)\n+                {\n+                    // note that we write strings in UTF8 so we don't need to multiply by 2 as chars\n+                    // will be 1 byte on average\n+                    totalAllocatedShortStrings += text.Length;\n+                    return text;\n+                }\n+\n+                var stringPosition = new StringPosition();\n+\n+                stringPosition.FilePosition = stream.Position;\n+\n+                streamWriter.Write(text);\n+\n+                stringPosition.StringLength = text.Length;\n+                return stringPosition;\n+            }\n+\n+            public string Get(object storedString)\n+            {\n+                if (storedString is string text)\n+                {\n+                    return text;\n+                }\n+\n+                var position = (StringPosition)storedString;\n+\n+                stream.Position = position.FilePosition;\n+                stringBuilder.Length = position.StringLength;\n+                for (int i = 0; i < position.StringLength; i++)\n+                {\n+                    char ch = (char)streamReader.Read();\n+                    stringBuilder[i] = ch;\n+                }",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Just `Clear()` unconditionally for brevity?",
              "createdAt": "2021-01-15T13:07:23Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -635,26 +744,29 @@ private void WriteProperties(IEnumerable properties)\n                 return;\n             }\n \n+            if (nameValueListBuffer.Count > 0)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Clear() also increments the internal `version` field of the list. I'm sure it doesn't matter at all and it's OK either way, but I thought of the version field overflowing (it's an int32) and decided to do this instead :) Call me paranoid :)",
              "createdAt": "2021-01-17T02:57:04Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -635,26 +744,29 @@ private void WriteProperties(IEnumerable properties)\n                 return;\n             }\n \n+            if (nameValueListBuffer.Count > 0)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Haah, you're right. Simpler is better. Fixed.",
              "createdAt": "2021-01-17T03:21:23Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -635,26 +744,29 @@ private void WriteProperties(IEnumerable properties)\n                 return;\n             }\n \n+            if (nameValueListBuffer.Count > 0)",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Worth adding something like this, given that the pattern is repeated throughout this file?\r\n\r\n```C#\r\n        private struct RedirectionHolder : IDisposable\r\n        {\r\n            private readonly BuildEventArgsWriter _writer;\r\n\r\n            public RedirectionHolder(BuildEventArgsWriter writer)\r\n            {\r\n                _writer = writer;\r\n                _writer.binaryWriter = _writer.originalBinaryWriter;\r\n            }\r\n\r\n            public void Dispose()\r\n            {\r\n                _writer.binaryWriter = _writer.currentRecordWriter;\r\n            }\r\n        }\r\n```\r\n\r\nIt would then allow you to write:\r\n\r\n```suggestion\r\n            using var redirection = RedirectWritesToOriginalBinaryWriter();\r\n```",
              "createdAt": "2021-01-15T13:20:56Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -718,34 +907,63 @@ private void Write(byte[] bytes)\n             binaryWriter.Write(bytes);\n         }\n \n+        private void Write(byte b)\n+        {\n+            binaryWriter.Write(b);\n+        }\n+\n         private void Write(bool boolean)\n         {\n             binaryWriter.Write(boolean);\n         }\n \n-        private void Write(string text)\n+        private void WriteDeduplicatedString(string text)\n         {\n-            if (text != null)\n-            {\n-                binaryWriter.Write(text);\n-            }\n-            else\n-            {\n-                binaryWriter.Write(false);\n-            }\n+            var (recordId, _) = HashString(text);\n+            Write(recordId);\n         }\n \n-        private void WriteOptionalString(string text)\n+        /// <summary>\n+        /// Hash the string and write a String record if not already hashed.\n+        /// </summary>\n+        /// <returns>Returns the string record index as well as the hash.</returns>\n+        private (int index, HashKey hash) HashString(string text)\n         {\n             if (text == null)\n             {\n-                Write(false);\n+                return (0, default);\n             }\n-            else\n+            else if (text.Length == 0)\n             {\n-                Write(true);\n-                Write(text);\n+                return (1, default);\n+            }\n+\n+            var hash = new HashKey(text);\n+            if (!stringHashes.TryGetValue(hash, out var recordId))\n+            {\n+                recordId = stringRecordId;\n+                stringHashes[hash] = stringRecordId;\n+\n+                WriteStringRecord(text);\n+\n+                stringRecordId += 1;\n             }\n+\n+            return (recordId, hash);\n+        }\n+\n+        private void WriteStringRecord(string text)\n+        {\n+            // Switch the binaryWriter used by the Write* methods to the direct underlying stream writer.\n+            // We want this record to precede the record we're currently writing to currentRecordWriter\n+            // which is backed by a MemoryStream buffer\n+            binaryWriter = this.originalBinaryWriter;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Neat idea, done.",
              "createdAt": "2021-01-17T03:18:51Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -718,34 +907,63 @@ private void Write(byte[] bytes)\n             binaryWriter.Write(bytes);\n         }\n \n+        private void Write(byte b)\n+        {\n+            binaryWriter.Write(b);\n+        }\n+\n         private void Write(bool boolean)\n         {\n             binaryWriter.Write(boolean);\n         }\n \n-        private void Write(string text)\n+        private void WriteDeduplicatedString(string text)\n         {\n-            if (text != null)\n-            {\n-                binaryWriter.Write(text);\n-            }\n-            else\n-            {\n-                binaryWriter.Write(false);\n-            }\n+            var (recordId, _) = HashString(text);\n+            Write(recordId);\n         }\n \n-        private void WriteOptionalString(string text)\n+        /// <summary>\n+        /// Hash the string and write a String record if not already hashed.\n+        /// </summary>\n+        /// <returns>Returns the string record index as well as the hash.</returns>\n+        private (int index, HashKey hash) HashString(string text)\n         {\n             if (text == null)\n             {\n-                Write(false);\n+                return (0, default);\n             }\n-            else\n+            else if (text.Length == 0)\n             {\n-                Write(true);\n-                Write(text);\n+                return (1, default);\n+            }\n+\n+            var hash = new HashKey(text);\n+            if (!stringHashes.TryGetValue(hash, out var recordId))\n+            {\n+                recordId = stringRecordId;\n+                stringHashes[hash] = stringRecordId;\n+\n+                WriteStringRecord(text);\n+\n+                stringRecordId += 1;\n             }\n+\n+            return (recordId, hash);\n+        }\n+\n+        private void WriteStringRecord(string text)\n+        {\n+            // Switch the binaryWriter used by the Write* methods to the direct underlying stream writer.\n+            // We want this record to precede the record we're currently writing to currentRecordWriter\n+            // which is backed by a MemoryStream buffer\n+            binaryWriter = this.originalBinaryWriter;",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      }
    ]
  }
}