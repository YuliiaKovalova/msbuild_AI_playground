{
  "number": 7480,
  "title": "Implement Platform Negotiation in ProjectGraph",
  "body": "Fixes #\r\n\r\n### Context\r\n\r\nThe release of a new project reference protocol in msbuild allowed for projects to negotiate setplatform metadata in the projectreference that linked them. seen [here](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md#:~:text=The%20ProjectReference%20Protocol%201%20Projects%20that%20have%20references.,6%20Getting%20additional%20properties%20from%20referenced%20projects.%20). This feature however does not take the same effect on the build graph which forces the projectgraph to not be a good representation when this protocol is used.\r\n\r\n\r\n### Changes Made\r\nAdded in the same platform negotiation logic from the msbuild target to the projectgraph so the project graph will accurately reflect the build graph.\r\n\r\n### Testing\r\n\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2022-03-21T18:50:20Z",
  "updatedAt": "2023-01-21T07:12:22Z",
  "closedAt": "2022-06-02T20:35:20Z",
  "mergedAt": "2022-06-02T20:35:20Z",
  "additions": 430,
  "deletions": 100,
  "changedFiles": 8,
  "headRefName": "main",
  "isDraft": false,
  "author": {
    "login": "MIchaelRShea"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "c01407beb378b7deca2d22177de6a463d57c9b88",
          "message": "Adding setplatform negotitation logic to build graph",
          "committedDate": "2022-03-24T19:05:43Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4acdeef41fab673b8b3323ec5873ba315fb8ad43",
          "message": "changing target framework",
          "committedDate": "2022-03-24T19:12:21Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "81fe00b7e6c24f4c35485a1a2c6c615b1e597542",
          "message": "changing target framework",
          "committedDate": "2022-03-24T19:19:47Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "804125beeb825ec85c7af22fe17c3acaedbd3145",
          "message": "did some reverts",
          "committedDate": "2022-03-24T21:26:59Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a299afc2b2a1b7e449a63f8f587732c49da17a09",
          "message": "uneeded variable cleanup",
          "committedDate": "2022-03-24T23:42:19Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "28cfb269c22da2b4daeaaead0cd863ff5822c1fd",
          "message": "Moving location of additional validation",
          "committedDate": "2022-03-29T21:07:33Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f97bff09836f45b909e9528feed9b616746e218c",
          "message": "remove use of global property",
          "committedDate": "2022-03-29T21:20:08Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d5c764bd8024cfc90a6b9fe20d76370c09e95ef4",
          "message": "cleanup",
          "committedDate": "2022-03-30T21:12:38Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a55bfb0a9fc2f0bc608ec74bd3b4947b8b8d0a72",
          "message": "code cleanup",
          "committedDate": "2022-03-30T21:14:04Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7b14019c627160815050f414437ab508e2e9774e",
          "message": "updating conditional to include empty strings",
          "committedDate": "2022-03-30T22:27:40Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb6d3f125661424bd466c7e735e31bf5d9de4a91",
          "message": "using bools and strings",
          "committedDate": "2022-03-30T22:32:01Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aa67aaf11a0f55821e82f43d33bab70639aeb94d",
          "message": "reverting changes in project interpretation",
          "committedDate": "2022-03-30T22:36:01Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8388b0ed7b11d2a8b844d6484a38fb2761b26646",
          "message": "Adding setplatform negotitation logic to build graph",
          "committedDate": "2022-05-16T18:18:15Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e951a08c18fabc5d0139906d4e9beba5ee4c9319",
          "message": "changing target framework",
          "committedDate": "2022-05-16T18:18:15Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dab8244df0836c8c4c924467328aa36872f1d1cc",
          "message": "changing target framework",
          "committedDate": "2022-05-16T18:18:15Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3f5a41ce06cc629d6d7237fb85dff5e387d61b9a",
          "message": "did some reverts",
          "committedDate": "2022-05-16T18:18:15Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e1761a0690c5e53d8dd7041d368af91077113bfc",
          "message": "uneeded variable cleanup",
          "committedDate": "2022-05-16T18:18:15Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eca8e334961215bd2b8b566a4dfb1927a800bd28",
          "message": "Moving location of additional validation",
          "committedDate": "2022-05-16T18:18:15Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "30b17e51c9a3a52fe437b31b6618f020cfe51e45",
          "message": "remove use of global property",
          "committedDate": "2022-05-16T18:18:15Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "19c9f3d6de7c7bce46f20279904fd680a4797aac",
          "message": "cleanup",
          "committedDate": "2022-05-16T18:18:16Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cbf0ccd97c528ad9d6b18a6d54e67500fa01e150",
          "message": "code cleanup",
          "committedDate": "2022-05-16T18:18:16Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b4861270ec84977a6abe4eb5cf7a725589e442e9",
          "message": "updating conditional to include empty strings",
          "committedDate": "2022-05-16T18:18:16Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "51332f606d2868edd95bc9fc67ee1f3f420f412c",
          "message": "using bools and strings",
          "committedDate": "2022-05-16T18:18:16Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2858691d0a8ecc9d2844b3eac47844e1d299a7b2",
          "message": "reverting changes in project interpretation",
          "committedDate": "2022-05-16T18:18:16Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a49e558b8044804955635f543481dc559daac776",
          "message": "rebasing with main",
          "committedDate": "2022-05-16T18:21:25Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1acaf5e5581d06d64da4c9507a67e032e11df3b0",
          "message": "merge with main",
          "committedDate": "2022-05-16T19:26:25Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "020c346203d63d93b7caa0854a5059fb1ea8baf6",
          "message": "Reworking graph setplatform negotiation to take default platform into account, in line with build task",
          "committedDate": "2022-05-24T17:17:12Z",
          "author": {
            "name": "Michael Shea",
            "email": "michaelshea@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4b21537a854d82e58a5193f3a6eba3e71b927693",
          "message": "making stylistic changes in line with dfederm comments",
          "committedDate": "2022-05-27T18:42:58Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5911362b9f84bb468952d08e1fac26c9b7cfe09",
          "message": "Update src/Shared/PlatformNegotiation.cs\n\nCo-authored-by: Ben Villalobos <4691428+BenVillalobos@users.noreply.github.com>",
          "committedDate": "2022-05-27T19:00:12Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cd8ce2c1c6c705b5b78d0f65692aca107fe77593",
          "message": "Update src/Shared/PlatformNegotiation.cs\n\nCo-authored-by: Ben Villalobos <4691428+BenVillalobos@users.noreply.github.com>",
          "committedDate": "2022-05-27T19:00:41Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3b2682308f08839e8356b37e4fa5e6a963c6b7c1",
          "message": "making changes based on benVillalobos comments",
          "committedDate": "2022-05-27T19:09:50Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59cf36d5ccd38228e53b79e61e9fa4a9e733691b",
          "message": "Merge branch 'main' of https://github.com/MIchaelRShea/msbuild into MIchaelRShea/main",
          "committedDate": "2022-05-27T19:30:57Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c9eb263b7c8f1614a19039c00b8794f00185a8f7",
          "message": "making is dynamic platform negotiation a global variable",
          "committedDate": "2022-05-27T19:36:03Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2032d0bfd29180405417fe8013e5ed42de56bee4",
          "message": "fixing logic",
          "committedDate": "2022-05-27T19:54:22Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bfc9c59499b18279ac6fc43dd06f0ac0ecd95d1b",
          "message": "fixing nits",
          "committedDate": "2022-05-31T15:27:50Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dbe59e06b2bcacf05aa61a749bb5f4dd41d6b27e",
          "message": "Update src/Shared/PlatformNegotiation.cs\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2022-05-31T16:19:19Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5517bb07b8a5f0544c45e5715ecd7934b7897372",
          "message": "making some changes based on rainers comments",
          "committedDate": "2022-05-31T18:42:08Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "66a9d0c15241ec3e2e942b80fcf02c9dbaff332e",
          "message": "Merge branch 'main' of https://github.com/MIchaelRShea/msbuild into MIchaelRShea/main",
          "committedDate": "2022-05-31T18:42:32Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b5de677cbac1fbf6ce6bfe1c30b52df84fd95a90",
          "message": "Changing variable name",
          "committedDate": "2022-05-31T18:46:34Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "89abf51df49ab994ee5c1e1521884603e8a8fe6a",
          "message": "reusing contructor",
          "committedDate": "2022-05-31T18:49:22Z",
          "author": {
            "name": "Michael Shea",
            "email": "78166458+MIchaelRShea@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "[![CLA assistant check](https://cla.dotnetfoundation.org/pull/badge/signed)](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=7480) <br/>All CLA requirements met.",
        "createdAt": "2022-03-21T18:50:34Z",
        "author": {
          "login": "dnfadmin"
        }
      },
      {
        "body": "[![CLA assistant check](https://cla.dotnetfoundation.org/pull/badge/not_signed)](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=7480) <br/>Thank you for your submission, we really appreciate it. Like many open source projects, we ask that you sign our [Contributor License Agreement](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=7480) before we can accept your contribution.<br/><br/>:x: MIchaelRShea [sign now](https://cla.dotnetfoundation.org/dotnet/msbuild?pullRequest=7480)<br/><sub>You have signed the CLA already but the status is still pending? Let us [recheck](https://cla.dotnetfoundation.org/check/dotnet/msbuild?pullRequest=7480) it.</sub>",
        "createdAt": "2022-03-21T18:50:34Z",
        "author": {
          "login": "dnfadmin"
        }
      },
      {
        "body": "Please add UTs",
        "createdAt": "2022-03-21T20:11:49Z",
        "author": {
          "login": "dfederm"
        }
      },
      {
        "body": "> Please add UTs\r\n\r\nJust another reminder that you need to add UTs",
        "createdAt": "2022-03-23T00:02:02Z",
        "author": {
          "login": "dfederm"
        }
      },
      {
        "body": "> Please add UTs\r\n\r\nAdded in Unit tests",
        "createdAt": "2022-03-24T23:43:04Z",
        "author": {
          "login": "MIchaelRShea"
        }
      },
      {
        "body": "> We talked a bunch offline about this. It looks like it'll work but needs clear documentation because it works differently than the current tasks/targets do things.\r\n> \r\n> ## At a high level here's how it works today (for reviewers)\r\n> ### Current tasks/targets\r\n> A->B (project A references project B)\r\n> \r\n> During the build, A calls the MSBuild task on B (causing an eval number 1) to get its `Platforms` property value. **A** performs platform negotiation with **B's** info. A then tells B to build with `SetPlatform=foo` B will evaluate a second time before it gets built because of the new set of global properties.\r\n> \r\n> ### In this graph version\r\n> A evaluates A starts parsing references B evaluates **B** performs platform negotiation based on **A's** info If it found a preferred platform, B evaluates a second time with the preferred platform B lives a happy life.\r\n> \r\n> It's backwards from how it works today, which isn't intuitive and should be documented in the code and in the static graph docs.\r\n> \r\n> The biggest change I'd like to see is projects evaluating with no global properties when extracting `Platforms` metadata. That should make sure massive project graphs reuse the same project eval as much as possible.\r\n\r\nWhat happens when C -> B as well. Does B do an additional 2 evaluations? Or are those cached and reused?\r\n\r\nDuring execution, the platform negotiation eval would happen only once globally. And in general B would evaluate N+1 times at most, where N is the number of supported platforms. Furthermore, it seems that the `GetTargetFrameworks` eval *is* that eval, so really there was never an additional evaluation for multitargeting projects for this feature at all. It basically piggy-backed off the outer build.",
        "createdAt": "2022-03-30T21:13:03Z",
        "author": {
          "login": "dfederm"
        }
      },
      {
        "body": "> Does B do an additional 2 evaluations? Or are those cached and reused?\r\n\r\nIt depends, but it will generally be cached.\r\n\r\nNo matter how many projects reference B, B should do an eval with no global properties. That should be shared. What won't be shared is when B needs to eval with a new platform global property.\r\n\r\n> It basically piggy-backed off the outer build.\r\n\r\nExactly. We're hoping the graph build will be similar in-that it should pass null/empty global props when extracting information from a project.",
        "createdAt": "2022-03-30T21:22:03Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> It depends, but it will generally be cached.\r\n\r\nI'm not seeing where this happens here. In fact, from what I see, when a unique configuration of B is seen, it is parsed and may alter its platform based on the referencing project and re-evaluate. That re-evaluation gets cached with the *original* configuration, which would lead to incorrect behavior. Now if we parsed any other project referencing B, we'd get the cached evaluation with the adjusted platform, which could be incorrect for the new referencing project.\r\n\r\n> Exactly. We're hoping the graph build will be similar in-that it should pass null/empty global props when extracting information from a project.\r\n\r\nShouldn't be null/empty global props but instead whatever GetTargetFrameworks does, so just remove `TargetFramework` and `RuntimeIdentifier` (in addition to the normally removed stuff based on `GlobalPropertiesToRemove`)\r\n\r\nIMHO, and what I've been suggesting the approach be all along, is that this be treated similar to how Target Framework negotiation works in Project Graph. There is effectively a 2-phase approach where the first phase does all the evaluations for each TF (or in this case, Platform), and then a 2nd pass which \"fixes up\" the edges. IE, for the A -> B example, the A -> B edge would be initially incorrect, and B would have N nodes in the graph (1 for each platform it supports), and in the 2nd pass the A -> B edge gets replaced with the correct one.",
        "createdAt": "2022-03-30T21:35:04Z",
        "author": {
          "login": "dfederm"
        }
      },
      {
        "body": "> Shouldn't be null/empty global props but instead whatever GetTargetFrameworks does, so just remove TargetFramework and RuntimeIdentifier (in addition to the normally removed stuff based on GlobalPropertiesToRemove)\r\n\r\nAgreed, the set of global props passed should match whatever the \"most generic\" MSBuild call is to prevent another full eval. Which makes me wonder if we're approaching a world where we should have any \"information gathering\" MSBuild calls use no global properties at all \ud83e\udd14 but I digress\r\n\r\n> That re-evaluation gets cached with the original configuration, which would lead to incorrect behavior\r\n\r\nEven if we could fix the caching issue and get this version to work, David's suggestion keeps things consistent which we should try to do.",
        "createdAt": "2022-03-30T22:39:16Z",
        "author": {
          "login": "benvillalobos"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Use `ConversionUtilities.ConvertStringToBool` for `EnableDynamicPlatformResolutionMetadataName`",
              "createdAt": "2022-03-21T20:13:30Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +230,10 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                if(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName).Equals(\"true\") && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Thank you for this tip. I implemented it",
              "createdAt": "2022-03-22T21:09:15Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +230,10 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                if(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName).Equals(\"true\") && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Avoid these. Either use nullable in the whole file or don't (ideally you would, but the file currently isn't)",
              "createdAt": "2022-03-21T20:14:43Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -239,10 +246,89 @@ ProjectItemInstance projectReference\n                         $\"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}\").ToImmutableDictionary();\n                 }\n             }\n-\n             return new GlobalPropertyPartsForMSBuildTask(newProperties, defaultParts.AdditionalProperties, newUndefineProperties);\n         }\n \n+        private static string GetCompatiblePlatform(ProjectItemInstance projectReference){\n+                \n+                var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                string projectReferencePlatformMetadata =  ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);\n+                var platformLookupTable = projectReference.Project.GetPropertyValue(PlatformLookupTableMetadataName);\n+                var referencedLookupTableMetadata = ReferencedProject.GetPropertyValue(PlatformLookupTableMetadataName);\n+\n+#nullable enable",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "removed and fixed here",
              "createdAt": "2022-03-22T21:08:53Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -239,10 +246,89 @@ ProjectItemInstance projectReference\n                         $\"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}\").ToImmutableDictionary();\n                 }\n             }\n-\n             return new GlobalPropertyPartsForMSBuildTask(newProperties, defaultParts.AdditionalProperties, newUndefineProperties);\n         }\n \n+        private static string GetCompatiblePlatform(ProjectItemInstance projectReference){\n+                \n+                var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                string projectReferencePlatformMetadata =  ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);\n+                var platformLookupTable = projectReference.Project.GetPropertyValue(PlatformLookupTableMetadataName);\n+                var referencedLookupTableMetadata = ReferencedProject.GetPropertyValue(PlatformLookupTableMetadataName);\n+\n+#nullable enable",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is copied from the `GetCompatiblePlatform` task. This code should be shared instead of duplicated to avoid divergence.",
              "createdAt": "2022-03-21T20:16:16Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -239,10 +246,89 @@ ProjectItemInstance projectReference\n                         $\"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}\").ToImmutableDictionary();\n                 }\n             }\n-\n             return new GlobalPropertyPartsForMSBuildTask(newProperties, defaultParts.AdditionalProperties, newUndefineProperties);\n         }\n \n+        private static string GetCompatiblePlatform(ProjectItemInstance projectReference){\n+                \n+                var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                string projectReferencePlatformMetadata =  ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);\n+                var platformLookupTable = projectReference.Project.GetPropertyValue(PlatformLookupTableMetadataName);\n+                var referencedLookupTableMetadata = ReferencedProject.GetPropertyValue(PlatformLookupTableMetadataName);\n+\n+#nullable enable\n+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(platformLookupTable);\n+#nullable disable          \n+#nullable enable\n+            Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(referencedLookupTableMetadata);\n+#nullable disable\n+            HashSet<string> projectReferencePlatforms = new HashSet<string>();\n+\n+\n+                foreach (string s in projectReferencePlatformMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Moved to a shared location\r\n",
              "createdAt": "2022-03-22T21:08:35Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -239,10 +246,89 @@ ProjectItemInstance projectReference\n                         $\"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}\").ToImmutableDictionary();\n                 }\n             }\n-\n             return new GlobalPropertyPartsForMSBuildTask(newProperties, defaultParts.AdditionalProperties, newUndefineProperties);\n         }\n \n+        private static string GetCompatiblePlatform(ProjectItemInstance projectReference){\n+                \n+                var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                string projectReferencePlatformMetadata =  ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);\n+                var platformLookupTable = projectReference.Project.GetPropertyValue(PlatformLookupTableMetadataName);\n+                var referencedLookupTableMetadata = ReferencedProject.GetPropertyValue(PlatformLookupTableMetadataName);\n+\n+#nullable enable\n+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(platformLookupTable);\n+#nullable disable          \n+#nullable enable\n+            Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(referencedLookupTableMetadata);\n+#nullable disable\n+            HashSet<string> projectReferencePlatforms = new HashSet<string>();\n+\n+\n+                foreach (string s in projectReferencePlatformMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "talked offline, but this compile item is in an itemgroup conditioned on .NET Framework",
              "createdAt": "2022-03-22T18:07:33Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -611,6 +611,10 @@\n       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>\n     </Compile>\n     <Compile Include=\"RCWForCurrentContext.cs\" />\n+    <Compile Include=\"..\\Shared\\PlatformNegotiation.cs\">",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "moving this to an unconditioned item group did the trick",
              "createdAt": "2022-03-22T21:06:40Z",
              "path": "src/Tasks/Microsoft.Build.Tasks.csproj",
              "diffHunk": "@@ -611,6 +611,10 @@\n       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>\n     </Compile>\n     <Compile Include=\"RCWForCurrentContext.cs\" />\n+    <Compile Include=\"..\\Shared\\PlatformNegotiation.cs\">",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: prefer `string` over `String`",
              "createdAt": "2022-03-22T18:12:54Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +230,19 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                if(ConversionUtilities.ConvertStringToBool(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)) && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))\n+                {\n+                    projectReference.SetMetadata(SetPlatformMetadataName, GetCompatiblePlatform2(projectReference));\n+\n+                    var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                    var projectReferencePlatformMetadata = ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                    var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);\n+                    var platformLookupTable = projectReference.Project.GetPropertyValue(PlatformLookupTableMetadataName);\n+                    var referencedLookupTableMetadata = ReferencedProject.GetPropertyValue(PlatformLookupTableMetadataName);\n+\n+\n+                    String SelectedPlatform = PlatformNegotiation.GetPlatformString(projectReferencePlatformMetadata, referencedLookupTableMetadata, CurrentProjectPlatform, platformLookupTable, projectReference.EvaluatedInclude);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "ended up using var here to match convention\r\n",
              "createdAt": "2022-03-22T21:27:57Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +230,19 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                if(ConversionUtilities.ConvertStringToBool(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)) && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))\n+                {\n+                    projectReference.SetMetadata(SetPlatformMetadataName, GetCompatiblePlatform2(projectReference));\n+\n+                    var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                    var projectReferencePlatformMetadata = ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                    var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);\n+                    var platformLookupTable = projectReference.Project.GetPropertyValue(PlatformLookupTableMetadataName);\n+                    var referencedLookupTableMetadata = ReferencedProject.GetPropertyValue(PlatformLookupTableMetadataName);\n+\n+\n+                    String SelectedPlatform = PlatformNegotiation.GetPlatformString(projectReferencePlatformMetadata, referencedLookupTableMetadata, CurrentProjectPlatform, platformLookupTable, projectReference.EvaluatedInclude);",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's this \"2\" method? Shouldn't you be using `PlatformNetotiation`?",
              "createdAt": "2022-03-22T18:14:39Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -239,10 +255,85 @@ ProjectItemInstance projectReference\n                         $\"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}\").ToImmutableDictionary();\n                 }\n             }\n-\n             return new GlobalPropertyPartsForMSBuildTask(newProperties, defaultParts.AdditionalProperties, newUndefineProperties);\n         }\n \n+        private static string GetCompatiblePlatform2(ProjectItemInstance projectReference){",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "this was prior to extracting it to a shared location. removed",
              "createdAt": "2022-03-22T21:09:41Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -239,10 +255,85 @@ ProjectItemInstance projectReference\n                         $\"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}\").ToImmutableDictionary();\n                 }\n             }\n-\n             return new GlobalPropertyPartsForMSBuildTask(newProperties, defaultParts.AdditionalProperties, newUndefineProperties);\n         }\n \n+        private static string GetCompatiblePlatform2(ProjectItemInstance projectReference){",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: variable name capitalization",
              "createdAt": "2022-03-22T18:15:01Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +230,19 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                if(ConversionUtilities.ConvertStringToBool(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)) && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))\n+                {\n+                    projectReference.SetMetadata(SetPlatformMetadataName, GetCompatiblePlatform2(projectReference));\n+\n+                    var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                    var projectReferencePlatformMetadata = ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                    var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Fixed here to lowercamelcase",
              "createdAt": "2022-03-22T21:25:35Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +230,19 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                if(ConversionUtilities.ConvertStringToBool(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)) && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))\n+                {\n+                    projectReference.SetMetadata(SetPlatformMetadataName, GetCompatiblePlatform2(projectReference));\n+\n+                    var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                    var projectReferencePlatformMetadata = ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                    var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Remove extra newlines",
              "createdAt": "2022-03-22T18:15:15Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +230,19 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                if(ConversionUtilities.ConvertStringToBool(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)) && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))\n+                {\n+                    projectReference.SetMetadata(SetPlatformMetadataName, GetCompatiblePlatform2(projectReference));\n+\n+                    var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                    var projectReferencePlatformMetadata = ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                    var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);\n+                    var platformLookupTable = projectReference.Project.GetPropertyValue(PlatformLookupTableMetadataName);\n+                    var referencedLookupTableMetadata = ReferencedProject.GetPropertyValue(PlatformLookupTableMetadataName);\n+\n+",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "cleaned up extra lines",
              "createdAt": "2022-03-22T21:26:43Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +230,19 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                if(ConversionUtilities.ConvertStringToBool(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)) && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))\n+                {\n+                    projectReference.SetMetadata(SetPlatformMetadataName, GetCompatiblePlatform2(projectReference));\n+\n+                    var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                    var projectReferencePlatformMetadata = ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                    var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);\n+                    var platformLookupTable = projectReference.Project.GetPropertyValue(PlatformLookupTableMetadataName);\n+                    var referencedLookupTableMetadata = ReferencedProject.GetPropertyValue(PlatformLookupTableMetadataName);\n+\n+",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "use `string` instead of `String`",
              "createdAt": "2022-03-22T18:15:27Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +230,19 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                if(ConversionUtilities.ConvertStringToBool(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)) && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))\n+                {\n+                    projectReference.SetMetadata(SetPlatformMetadataName, GetCompatiblePlatform2(projectReference));\n+\n+                    var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                    var projectReferencePlatformMetadata = ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                    var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);\n+                    var platformLookupTable = projectReference.Project.GetPropertyValue(PlatformLookupTableMetadataName);\n+                    var referencedLookupTableMetadata = ReferencedProject.GetPropertyValue(PlatformLookupTableMetadataName);\n+\n+\n+                    String SelectedPlatform = PlatformNegotiation.GetPlatformString(projectReferencePlatformMetadata, referencedLookupTableMetadata, CurrentProjectPlatform, platformLookupTable, projectReference.EvaluatedInclude);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "ended up using var here to match convention",
              "createdAt": "2022-03-22T21:27:36Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +230,19 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                if(ConversionUtilities.ConvertStringToBool(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)) && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))\n+                {\n+                    projectReference.SetMetadata(SetPlatformMetadataName, GetCompatiblePlatform2(projectReference));\n+\n+                    var ReferencedProject = new Project(projectReference.EvaluatedInclude);\n+                    var projectReferencePlatformMetadata = ReferencedProject.GetPropertyValue(PlatformMetadataName);\n+                    var CurrentProjectPlatform = projectReference.Project.GetPropertyValue(PlatformMetadataName);\n+                    var platformLookupTable = projectReference.Project.GetPropertyValue(PlatformLookupTableMetadataName);\n+                    var referencedLookupTableMetadata = ReferencedProject.GetPropertyValue(PlatformLookupTableMetadataName);\n+\n+\n+                    String SelectedPlatform = PlatformNegotiation.GetPlatformString(projectReferencePlatformMetadata, referencedLookupTableMetadata, CurrentProjectPlatform, platformLookupTable, projectReference.EvaluatedInclude);",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "ExtractLookupTable is called in `PlatformNegotiation.GetPlatformString`, this isn't necessary.",
              "createdAt": "2022-03-22T18:18:00Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -51,7 +51,7 @@ public GetCompatiblePlatform()\n \n         public override bool Execute()\n         {\n-            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(PlatformLookupTable);\n+            Dictionary<string, string>? currentProjectLookupTable = PlatformNegotiation.ExtractLookupTable(PlatformLookupTable, Log);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "this was prior to extracting it to a shared location. removed",
              "createdAt": "2022-03-22T21:07:46Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -51,7 +51,7 @@ public GetCompatiblePlatform()\n \n         public override bool Execute()\n         {\n-            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(PlatformLookupTable);\n+            Dictionary<string, string>? currentProjectLookupTable = PlatformNegotiation.ExtractLookupTable(PlatformLookupTable, Log);",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "These metadata calls can be called from `PlatformNegotiation.GetPlatformString` instead of here. `PlatformNegotiation.GetPlatformString` is essentially the implementation of this task now, so you can remove all the metadata calls and just pass `PlatformNegotiation.GetPlatformString` the `AssignedProjectsWithPlatform` and extract metadata there.",
              "createdAt": "2022-03-22T18:19:42Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -60,60 +60,11 @@ public override bool Execute()\n \n                 string projectReferencePlatformMetadata = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "So I did some digging and debugging. there is no place in the graph build where both the project and the project it is referencing are both evaluated. so we need to evaluate the referenced project before we do the negotiation. this is similar to how \"new TaskItem(AnnotatedProjects[i])\" is run in getCompatablePlatform.cs(58). ",
              "createdAt": "2022-03-24T23:46:52Z",
              "path": "src/Tasks/GetCompatiblePlatform.cs",
              "diffHunk": "@@ -60,60 +60,11 @@ public override bool Execute()\n \n                 string projectReferencePlatformMetadata = AssignedProjectsWithPlatform[i].GetMetadata(\"Platforms\");",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should probably be renamed to `GetNearestPlatform` or something similar.",
              "createdAt": "2022-03-22T18:22:42Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are useful throughout many\n+    /// of the XMake classes and don't really belong in any specific class.   \n+    /// </summary>\n+    internal static class PlatformNegotiation\n+    {\n+        public static string? GetPlatformString(String projectReferencePlatformMetadata, String projectReferenceLookupTableMetadata, String CurrentProjectPlatform, String PlatformLookupTable, String ProjectPath, TaskLoggingHelper? Log = null)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Also, does do we need the TaskLoggingHelper to be marked as nullable?",
              "createdAt": "2022-03-22T18:23:09Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are useful throughout many\n+    /// of the XMake classes and don't really belong in any specific class.   \n+    /// </summary>\n+    internal static class PlatformNegotiation\n+    {\n+        public static string? GetPlatformString(String projectReferencePlatformMetadata, String projectReferenceLookupTableMetadata, String CurrentProjectPlatform, String PlatformLookupTable, String ProjectPath, TaskLoggingHelper? Log = null)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "it needs to be marked nullable as its not available in Microsoft.Build, only available in microsoft.build.tasks",
              "createdAt": "2022-03-24T23:44:10Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are useful throughout many\n+    /// of the XMake classes and don't really belong in any specific class.   \n+    /// </summary>\n+    internal static class PlatformNegotiation\n+    {\n+        public static string? GetPlatformString(String projectReferencePlatformMetadata, String projectReferenceLookupTableMetadata, String CurrentProjectPlatform, String PlatformLookupTable, String ProjectPath, TaskLoggingHelper? Log = null)",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "why this change? Should we just update `SystemResourcesExtensionsPackageVersion` to `4.6.0`?",
              "createdAt": "2022-03-22T18:25:09Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -23,7 +23,7 @@\n     <PackageReference Update=\"System.Net.Http\" Version=\"4.3.4\" />\n     <PackageReference Update=\"System.Memory\" Version=\"4.5.4\" />\n     <PackageReference Update=\"System.Reflection.Metadata\" Version=\"1.6.0\" />\n-    <PackageReference Update=\"System.Resources.Extensions\" Version=\"$(SystemResourcesExtensionsPackageVersion)\" />",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "reverted this. SystemResourcesExtensionsPackageVersion was not being defined on my machine and this change accidentally got pushed",
              "createdAt": "2022-03-22T21:17:24Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -23,7 +23,7 @@\n     <PackageReference Update=\"System.Net.Http\" Version=\"4.3.4\" />\n     <PackageReference Update=\"System.Memory\" Version=\"4.5.4\" />\n     <PackageReference Update=\"System.Reflection.Metadata\" Version=\"1.6.0\" />\n-    <PackageReference Update=\"System.Resources.Extensions\" Version=\"$(SystemResourcesExtensionsPackageVersion)\" />",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Add a comment which calls out that it's mimicking the target, so that it's there for reference",
              "createdAt": "2022-03-23T00:01:01Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +232,16 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                if(ConversionUtilities.ValidBooleanTrue(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)) && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can avoid double lookup here.\r\n\r\n```suggestion\r\n                    projectReferenceLookupTable.TryGetValue(CurrentProjectPlatformMetadata, out var projectReference) &&\r\n                    projectReferencePlatforms.Contains(projectReference))\r\n```\r\n\r\nDitto below.",
              "createdAt": "2022-03-23T00:24:16Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are useful throughout many\n+    /// of the XMake classes and don't really belong in any specific class.   \n+    /// </summary>\n+    static internal class PlatformNegotiation\n+    {\n+        internal static string? GetPlatformString(String projectReferencePlatformMetadata, String projectReferenceLookupTableMetadata, String CurrentProjectPlatformMetadata, String CurrentPlatformLookupTableMetadata, String ProjectPath, TaskLoggingHelper? Log = null)\n+        {\n+            \n+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(CurrentPlatformLookupTableMetadata, Log);\n+\n+            if (string.IsNullOrEmpty(projectReferencePlatformMetadata))\n+            {\n+                if(Log != null)\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", ProjectPath);\n+                }\n+                return null;\n+            }\n+            Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata, Log);\n+            HashSet<string> projectReferencePlatforms = new HashSet<string>();\n+            foreach (string s in projectReferencePlatformMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+            {\n+                projectReferencePlatforms.Add(s);\n+            }\n+\n+            string buildProjectReferenceAs = string.Empty;\n+\n+            if (projectReferencePlatforms.Contains(CurrentProjectPlatformMetadata))\n+            {\n+                buildProjectReferenceAs = CurrentProjectPlatformMetadata;\n+                if (Log != null)\n+                {\n+                    Log.LogMessageFromResources(MessageImportance.Low, \"GetCompatiblePlatform.SamePlatform\");\n+                }\n+            }\n+            // Prioritize PlatformLookupTable **metadata** attached to the ProjectReference item\n+            // before the current project's table. We do this to allow per-ProjectReference fine tuning.\n+            else if (projectReferenceLookupTable != null &&\n+                    projectReferenceLookupTable.ContainsKey(CurrentProjectPlatformMetadata) &&\n+                    projectReferencePlatforms.Contains(projectReferenceLookupTable[CurrentProjectPlatformMetadata]))",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "For these log statements, you can write:\r\n\r\n```suggestion\r\n                Log?.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", ProjectPath);\r\n```",
              "createdAt": "2022-03-23T00:25:25Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are useful throughout many\n+    /// of the XMake classes and don't really belong in any specific class.   \n+    /// </summary>\n+    static internal class PlatformNegotiation\n+    {\n+        internal static string? GetPlatformString(String projectReferencePlatformMetadata, String projectReferenceLookupTableMetadata, String CurrentProjectPlatformMetadata, String CurrentPlatformLookupTableMetadata, String ProjectPath, TaskLoggingHelper? Log = null)\n+        {\n+            \n+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(CurrentPlatformLookupTableMetadata, Log);\n+\n+            if (string.IsNullOrEmpty(projectReferencePlatformMetadata))\n+            {\n+                if(Log != null)\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", ProjectPath);\n+                }",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "Much cleaner, thank you",
              "createdAt": "2022-03-23T16:30:16Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are useful throughout many\n+    /// of the XMake classes and don't really belong in any specific class.   \n+    /// </summary>\n+    static internal class PlatformNegotiation\n+    {\n+        internal static string? GetPlatformString(String projectReferencePlatformMetadata, String projectReferenceLookupTableMetadata, String CurrentProjectPlatformMetadata, String CurrentPlatformLookupTableMetadata, String ProjectPath, TaskLoggingHelper? Log = null)\n+        {\n+            \n+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(CurrentPlatformLookupTableMetadata, Log);\n+\n+            if (string.IsNullOrEmpty(projectReferencePlatformMetadata))\n+            {\n+                if(Log != null)\n+                {\n+                    Log.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", ProjectPath);\n+                }",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is XMake an old name? Should it be used in the docs of a new class?",
              "createdAt": "2022-03-23T00:27:43Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are useful throughout many\n+    /// of the XMake classes and don't really belong in any specific class.   ",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "Yes this doc has been updated to reflect what it actually does",
              "createdAt": "2022-03-23T16:29:53Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are useful throughout many\n+    /// of the XMake classes and don't really belong in any specific class.   ",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This doesnt seem right.\r\n\r\nIn any case, you should be using `ProjectInstance` if anything, and you should be using the same settings used elsewhere like the shared evaluation context",
              "createdAt": "2022-03-25T19:55:22Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +233,14 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                // This mimics the _GetProjectReferenceTargetFrameworkProperties task in order to properly reflect what the build graph looks like in\n+                // a traversal in which EnableDynamicPlatformResolution is turned on\n+                if (ConversionUtilities.ValidBooleanTrue(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)) && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))\n+                {\n+                    var referencedProject = new Project(projectReference.EvaluatedInclude);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "It doesn't look like you should be doing this evaluation at all. This also seems very incorrect as you're reading `PlatformsMetadataName` as a *Property*, not metadata.",
              "createdAt": "2022-03-25T20:04:33Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +233,14 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                // This mimics the _GetProjectReferenceTargetFrameworkProperties task in order to properly reflect what the build graph looks like in\n+                // a traversal in which EnableDynamicPlatformResolution is turned on\n+                if (ConversionUtilities.ValidBooleanTrue(projectReference.Project.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)) && String.IsNullOrEmpty(projectReference.GetMetadataValue(SetPlatformMetadataName)))\n+                {\n+                    var referencedProject = new Project(projectReference.EvaluatedInclude);",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Doesn't seem like you're considering `UseDefaultPlatformLookupTables`",
              "createdAt": "2022-03-25T20:25:02Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -19,6 +21,10 @@ namespace Microsoft.Build.Graph\n {\n     internal sealed class ProjectInterpretation\n     {\n+        private const string PlatformLookupTableMetadataName = \"PlatformLookupTable\";",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This looks like a leftover local change",
              "createdAt": "2022-03-29T22:02:55Z",
              "path": "build.sh",
              "diffHunk": "@@ -8,4 +8,4 @@ while [ -h \"$SOURCE\" ]; do # resolve $SOURCE until the file is no longer a symli\n done\n ScriptRoot=\"$( cd -P \"$( dirname \"$SOURCE\" )\" && pwd )\"\n \n-. \"$ScriptRoot/eng/common/build.sh\" --build --restore \"$@\"",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "removed this",
              "createdAt": "2022-03-30T21:13:21Z",
              "path": "build.sh",
              "diffHunk": "@@ -8,4 +8,4 @@ while [ -h \"$SOURCE\" ]; do # resolve $SOURCE until the file is no longer a symli\n done\n ScriptRoot=\"$( cd -P \"$( dirname \"$SOURCE\" )\" && pwd )\"\n \n-. \"$ScriptRoot/eng/common/build.sh\" --build --restore \"$@\"",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It'd be nice to have this script in the repo, I'd remove it from this PR though",
              "createdAt": "2022-03-29T22:05:01Z",
              "path": "scripts/killnodereuse.bat",
              "diffHunk": "@@ -0,0 +1,4 @@\n+taskkill /f /im msbuild.exe",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "removed",
              "createdAt": "2022-03-30T22:24:27Z",
              "path": "scripts/killnodereuse.bat",
              "diffHunk": "@@ -0,0 +1,4 @@\n+taskkill /f /im msbuild.exe",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please comment how project negotiation happens backwards compared to how it works in tasks/targets. A comment containing a simple diagram (A->B) would be great here, since what's happening isn't intuitive.",
              "createdAt": "2022-03-29T22:28:51Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){\n+                \n+                var Platforms = projectInstance.GetProperty(\"Platforms\");",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Remove the unused variables\r\n\r\nI've seen this crash when a property doesn't exist. I think it was the PlatformLookupTable.",
              "createdAt": "2022-03-29T22:31:04Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){\n+                \n+                var Platforms = projectInstance.GetProperty(\"Platforms\");\n+                var Platform = projectInstance.GetProperty(\"Platform\");\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), globalProperties[PlatformMetadataName], \"\", projectInstance.FullPath);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "removed",
              "createdAt": "2022-03-30T22:24:57Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){\n+                \n+                var Platforms = projectInstance.GetProperty(\"Platforms\");\n+                var Platform = projectInstance.GetProperty(\"Platform\");\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), globalProperties[PlatformMetadataName], \"\", projectInstance.FullPath);",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This line won't work if we hit the `else` case in `GetNearestPlatform` where you would return string.empty.",
              "createdAt": "2022-03-29T22:32:25Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){\n+                \n+                var Platforms = projectInstance.GetProperty(\"Platforms\");\n+                var Platform = projectInstance.GetProperty(\"Platform\");\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), globalProperties[PlatformMetadataName], \"\", projectInstance.FullPath);\n+\n+\n+                if (SelectedPlatform != null)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "changed to string.isnullorempty",
              "createdAt": "2022-03-30T22:28:46Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){\n+                \n+                var Platforms = projectInstance.GetProperty(\"Platforms\");\n+                var Platform = projectInstance.GetProperty(\"Platform\");\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), globalProperties[PlatformMetadataName], \"\", projectInstance.FullPath);\n+\n+\n+                if (SelectedPlatform != null)",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Note to self: Fairly sure this \"globalProperties\" is \"global\" only to the current project instance.",
              "createdAt": "2022-03-29T22:35:23Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){\n+                \n+                var Platforms = projectInstance.GetProperty(\"Platforms\");\n+                var Platform = projectInstance.GetProperty(\"Platform\");\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), globalProperties[PlatformMetadataName], \"\", projectInstance.FullPath);\n+\n+\n+                if (SelectedPlatform != null)\n+                {\n+                    // configurationMetadata.GlobalProperties.GetProperty(\"platform\").EvaluatedValue = SelectedPlatform;\n+                    globalProperties[\"platform\"] = SelectedPlatform;",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Doesn't this effectively do 2 evaluations for every single project? That doesn't seem like a reasonable approach.",
              "createdAt": "2022-03-30T15:59:22Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){\n+                \n+                var Platforms = projectInstance.GetProperty(\"Platforms\");\n+                var Platform = projectInstance.GetProperty(\"Platform\");\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), globalProperties[PlatformMetadataName], \"\", projectInstance.FullPath);\n+\n+\n+                if (SelectedPlatform != null)\n+                {\n+                    // configurationMetadata.GlobalProperties.GetProperty(\"platform\").EvaluatedValue = SelectedPlatform;\n+                    globalProperties[\"platform\"] = SelectedPlatform;\n+                }\n+\n+                projectInstance = _projectInstanceFactory(",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Er, 2 evaluations per project reference I mean",
              "createdAt": "2022-03-30T16:05:49Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){\n+                \n+                var Platforms = projectInstance.GetProperty(\"Platforms\");\n+                var Platform = projectInstance.GetProperty(\"Platform\");\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), globalProperties[PlatformMetadataName], \"\", projectInstance.FullPath);\n+\n+\n+                if (SelectedPlatform != null)\n+                {\n+                    // configurationMetadata.GlobalProperties.GetProperty(\"platform\").EvaluatedValue = SelectedPlatform;\n+                    globalProperties[\"platform\"] = SelectedPlatform;\n+                }\n+\n+                projectInstance = _projectInstanceFactory(",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Yes it does. But this is unavoidable. I spoke with Rainer and ben and they are fine with the extra evaluation as long as it is a opt in only approach. which is it as you need to turn on dynamic resolution. I ran a graph build with and without this feature in VS from the root of the repo(So lots of projects to parse)  and it only changed build time by 5%.",
              "createdAt": "2022-03-30T16:08:34Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){\n+                \n+                var Platforms = projectInstance.GetProperty(\"Platforms\");\n+                var Platform = projectInstance.GetProperty(\"Platform\");\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), globalProperties[PlatformMetadataName], \"\", projectInstance.FullPath);\n+\n+\n+                if (SelectedPlatform != null)\n+                {\n+                    // configurationMetadata.GlobalProperties.GetProperty(\"platform\").EvaluatedValue = SelectedPlatform;\n+                    globalProperties[\"platform\"] = SelectedPlatform;\n+                }\n+\n+                projectInstance = _projectInstanceFactory(",
              "author": {
                "login": "MIchaelRShea"
              }
            },
            {
              "body": "Since we cache evaluations it does not have a large effect on build time",
              "createdAt": "2022-03-30T16:10:24Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){\n+                \n+                var Platforms = projectInstance.GetProperty(\"Platforms\");\n+                var Platform = projectInstance.GetProperty(\"Platform\");\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), globalProperties[PlatformMetadataName], \"\", projectInstance.FullPath);\n+\n+\n+                if (SelectedPlatform != null)\n+                {\n+                    // configurationMetadata.GlobalProperties.GetProperty(\"platform\").EvaluatedValue = SelectedPlatform;\n+                    globalProperties[\"platform\"] = SelectedPlatform;\n+                }\n+\n+                projectInstance = _projectInstanceFactory(",
              "author": {
                "login": "MIchaelRShea"
              }
            },
            {
              "body": "For the record, this is how things work today in tasks/targets.\r\n\r\nA->B\r\n\r\nB will have two evaluations:\r\n1. Without any (or at least without platform/TF) global properties so we can get `Platforms` (among other properties) out of the project so we can negotiate\r\n2. The evaluation of B, with the acquired/negotiated platform as a global propety",
              "createdAt": "2022-03-30T20:23:45Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){\n+                \n+                var Platforms = projectInstance.GetProperty(\"Platforms\");\n+                var Platform = projectInstance.GetProperty(\"Platform\");\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), globalProperties[PlatformMetadataName], \"\", projectInstance.FullPath);\n+\n+\n+                if (SelectedPlatform != null)\n+                {\n+                    // configurationMetadata.GlobalProperties.GetProperty(\"platform\").EvaluatedValue = SelectedPlatform;\n+                    globalProperties[\"platform\"] = SelectedPlatform;\n+                }\n+\n+                projectInstance = _projectInstanceFactory(",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "can we use lowercase types? `bool` and `string`",
              "createdAt": "2022-03-30T20:15:52Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -517,7 +521,7 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, Boolean enableDynamicPlatformResolution)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "converted",
              "createdAt": "2022-03-30T22:32:11Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -517,7 +521,7 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, Boolean enableDynamicPlatformResolution)",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                // This mimics the _GetProjectReferenceTargetFrameworkProperties target\r\n```\r\n\r\nIt's not just for dynamic platform scenarios",
              "createdAt": "2022-03-30T20:27:35Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -227,6 +230,8 @@ ProjectItemInstance projectReference\n             // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n             if (newProperties.Count == 0)\n             {\n+                // This mimics the _GetProjectReferenceTargetFrameworkProperties task in order to properly reflect what the build graph looks like in",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: keep the newline",
              "createdAt": "2022-03-30T20:27:58Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -239,7 +244,6 @@ ProjectItemInstance projectReference\n                         $\"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}\").ToImmutableDictionary();\n                 }\n             }\n-",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "reverted all changes in this file as it is no longer where the negotiation takes place",
              "createdAt": "2022-03-30T22:36:32Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -239,7 +244,6 @@ ProjectItemInstance projectReference\n                         $\"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}\").ToImmutableDictionary();\n                 }\n             }\n-",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: empty first line",
              "createdAt": "2022-03-30T20:28:09Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,107 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Evaluation;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are used in both the \n+    /// tasks and graph projects in order for two projects to negotiate which platform a projectreference\n+    /// should be built as.\n+    /// </summary>\n+    static internal class PlatformNegotiation\n+    {\n+\n+        internal static string? GetNearestPlatform(String projectReferencePlatformMetadata, String projectReferenceLookupTableMetadata, String currentProjectPlatformMetadata, String currentPlatformLookupTableMetadata, String projectPath, TaskLoggingHelper? Log = null)\n+        {\n+",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: newline before if statement",
              "createdAt": "2022-03-30T20:29:58Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -532,9 +536,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n+\n+\n             var graphNode = new ProjectGraphNode(projectInstance);\n+            if(enableDynamicPlatformResolution){",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: This and same code from 'else' cloud of outside of this if at line 571",
              "createdAt": "2022-04-28T12:14:01Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -517,24 +521,56 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n \n-            var projectInstance = _projectInstanceFactory(\n-                configurationMetadata.ProjectFullPath,\n-                globalProperties,\n-                _projectCollection);\n+            if (enableDynamicPlatformResolution){\n \n-            if (projectInstance == null)\n-            {\n-                throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n+                projectInstance = _projectInstanceFactory(\n+                    configurationMetadata.ProjectFullPath,\n+                    null,\n+                    _projectCollection);\n+\n+                if (projectInstance == null)\n+                {\n+                    throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n+                }\n+\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), globalProperties[PlatformMetadataName], \"\", projectInstance.FullPath);\n+\n+                if (!string.IsNullOrEmpty(SelectedPlatform))\n+                {\n+                    globalProperties[\"platform\"] = SelectedPlatform;\n+                }\n+\n+                projectInstance = _projectInstanceFactory(\n+                    configurationMetadata.ProjectFullPath,\n+                    globalProperties,\n+                    _projectCollection);\n+\n+                graphNode = new ProjectGraphNode(projectInstance);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would it be possibly to move `PlatformNegotiation` into Microsoft.Build.Framework assembly and do not use Shared for it. \r\nIn long term we would like to get rid of this Shared files shenanigans.",
              "createdAt": "2022-04-28T12:28:27Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -122,6 +122,10 @@\n     <Compile Include=\"..\\Shared\\NodeShutdown.cs\" />\n     <Compile Include=\"..\\Shared\\NamedPipeUtil.cs\" />\n     <Compile Include=\"..\\Shared\\ProcessExtensions.cs\" />\n+    <Compile Include=\"..\\Shared\\PlatformNegotiation.cs\">",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't this only re-evaluate if the `Platform` global property was set? Looks like this should be moved into the if statement above.",
              "createdAt": "2022-05-16T21:38:49Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -510,9 +513,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n-            var graphNode = new ProjectGraphNode(projectInstance);\n+            if (enableDynamicPlatformResolution)\n+            {\n+                string referencedProjectPlatform = projectInstance.GetPropertyValue(PlatformMetadataName);\n+                string projectReferencePlatformsMetadata = projectInstance.GetPropertyValue(PlatformsMetadataName);\n+                string projectReferenceLookupTableMetadata = projectInstance.GetPropertyValue(PlatformLookupTableMetadataName);\n+                String projectPath = projectInstance.FullPath;\n+                String platformLookupTable;\n+                globalProperties.TryGetValue(PlatformLookupTableMetadataName, out platformLookupTable);\n+                String CurrentProjectPlatform;\n+                globalProperties.TryGetValue(PlatformMetadataName, out CurrentProjectPlatform);\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, platformLookupTable, projectPath, CurrentProjectPlatform);\n+\n+                if (!string.IsNullOrEmpty(SelectedPlatform))\n+                {\n+                    globalProperties[\"platform\"] = SelectedPlatform;\n+                }\n+\n+                projectInstance = _projectInstanceFactory(",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "it needs to be reevaluated anyways because we need to put its platformlookuptable in its global props in order to passdown.",
              "createdAt": "2022-05-20T15:36:28Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -510,9 +513,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n-            var graphNode = new ProjectGraphNode(projectInstance);\n+            if (enableDynamicPlatformResolution)\n+            {\n+                string referencedProjectPlatform = projectInstance.GetPropertyValue(PlatformMetadataName);\n+                string projectReferencePlatformsMetadata = projectInstance.GetPropertyValue(PlatformsMetadataName);\n+                string projectReferenceLookupTableMetadata = projectInstance.GetPropertyValue(PlatformLookupTableMetadataName);\n+                String projectPath = projectInstance.FullPath;\n+                String platformLookupTable;\n+                globalProperties.TryGetValue(PlatformLookupTableMetadataName, out platformLookupTable);\n+                String CurrentProjectPlatform;\n+                globalProperties.TryGetValue(PlatformMetadataName, out CurrentProjectPlatform);\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, platformLookupTable, projectPath, CurrentProjectPlatform);\n+\n+                if (!string.IsNullOrEmpty(SelectedPlatform))\n+                {\n+                    globalProperties[\"platform\"] = SelectedPlatform;\n+                }\n+\n+                projectInstance = _projectInstanceFactory(",
              "author": {
                "login": "MIchaelRShea"
              }
            },
            {
              "body": "I also added in all the tests from GetCompatiblePlatform_Tests to GetCompatiblePlatformgraph_Tests and they all pass. so the behavior is the same here",
              "createdAt": "2022-05-20T15:37:41Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -510,9 +513,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n-            var graphNode = new ProjectGraphNode(projectInstance);\n+            if (enableDynamicPlatformResolution)\n+            {\n+                string referencedProjectPlatform = projectInstance.GetPropertyValue(PlatformMetadataName);\n+                string projectReferencePlatformsMetadata = projectInstance.GetPropertyValue(PlatformsMetadataName);\n+                string projectReferenceLookupTableMetadata = projectInstance.GetPropertyValue(PlatformLookupTableMetadataName);\n+                String projectPath = projectInstance.FullPath;\n+                String platformLookupTable;\n+                globalProperties.TryGetValue(PlatformLookupTableMetadataName, out platformLookupTable);\n+                String CurrentProjectPlatform;\n+                globalProperties.TryGetValue(PlatformMetadataName, out CurrentProjectPlatform);\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, platformLookupTable, projectPath, CurrentProjectPlatform);\n+\n+                if (!string.IsNullOrEmpty(SelectedPlatform))\n+                {\n+                    globalProperties[\"platform\"] = SelectedPlatform;\n+                }\n+\n+                projectInstance = _projectInstanceFactory(",
              "author": {
                "login": "MIchaelRShea"
              }
            },
            {
              "body": "Unresolving this. The re-evaluation can go into the if statement (tested on my machine)\r\n\r\n> it needs to be reevaluated anyways because we need to put its platformlookuptable in its global props in order to passdown.\r\n\r\nThis isn't necessary, I think it must have been before you created `PreviousPlatformXYZ` vars",
              "createdAt": "2022-05-25T20:55:09Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -510,9 +513,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n-            var graphNode = new ProjectGraphNode(projectInstance);\n+            if (enableDynamicPlatformResolution)\n+            {\n+                string referencedProjectPlatform = projectInstance.GetPropertyValue(PlatformMetadataName);\n+                string projectReferencePlatformsMetadata = projectInstance.GetPropertyValue(PlatformsMetadataName);\n+                string projectReferenceLookupTableMetadata = projectInstance.GetPropertyValue(PlatformLookupTableMetadataName);\n+                String projectPath = projectInstance.FullPath;\n+                String platformLookupTable;\n+                globalProperties.TryGetValue(PlatformLookupTableMetadataName, out platformLookupTable);\n+                String CurrentProjectPlatform;\n+                globalProperties.TryGetValue(PlatformMetadataName, out CurrentProjectPlatform);\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, platformLookupTable, projectPath, CurrentProjectPlatform);\n+\n+                if (!string.IsNullOrEmpty(SelectedPlatform))\n+                {\n+                    globalProperties[\"platform\"] = SelectedPlatform;\n+                }\n+\n+                projectInstance = _projectInstanceFactory(",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "^ Correcting myself. The second evaluation is _always_ needed no matter what, because under `EnableDynamicPlatformResolution=true` you always start with the \"empty eval\". Next, imagine platform negotiation fails and you didn't add `Platform` to the global props. **You still need to do the second eval** with whatever global props may have been passed in. Re-resolving :)",
              "createdAt": "2022-05-25T21:02:41Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -510,9 +513,32 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n-            var graphNode = new ProjectGraphNode(projectInstance);\n+            if (enableDynamicPlatformResolution)\n+            {\n+                string referencedProjectPlatform = projectInstance.GetPropertyValue(PlatformMetadataName);\n+                string projectReferencePlatformsMetadata = projectInstance.GetPropertyValue(PlatformsMetadataName);\n+                string projectReferenceLookupTableMetadata = projectInstance.GetPropertyValue(PlatformLookupTableMetadataName);\n+                String projectPath = projectInstance.FullPath;\n+                String platformLookupTable;\n+                globalProperties.TryGetValue(PlatformLookupTableMetadataName, out platformLookupTable);\n+                String CurrentProjectPlatform;\n+                globalProperties.TryGetValue(PlatformMetadataName, out CurrentProjectPlatform);\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, platformLookupTable, projectPath, CurrentProjectPlatform);\n+\n+                if (!string.IsNullOrEmpty(SelectedPlatform))\n+                {\n+                    globalProperties[\"platform\"] = SelectedPlatform;\n+                }\n+\n+                projectInstance = _projectInstanceFactory(",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Based on offline discussion, I think `!isGraphBuild` should be removed.",
              "createdAt": "2022-05-20T17:24:47Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,110 @@\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Evaluation;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are used in both the \n+    /// tasks and graph projects in order for two projects to negotiate which platform a projectreference\n+    /// should be built as.\n+    /// </summary>\n+    static internal class PlatformNegotiation\n+    {\n+        internal static string? GetNearestPlatform(string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, String platformLookupTable, String projectPath, String CurrentProjectPlatform, bool isGraphBuild, TaskLoggingHelper? log = null)\n+        {\n+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(platformLookupTable, log);\n+\n+            if (string.IsNullOrEmpty(projectReferencePlatformsMetadata) && string.IsNullOrEmpty(referencedProjectPlatform))\n+                {\n+                    log?.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", projectPath);\n+                    return \"\";\n+                }\n+\n+                // Pull platformLookupTable metadata from the referenced project. This allows custom\n+                // mappings on a per-ProjectReference basis.\n+                Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata, log);\n+\n+                HashSet<string> projectReferencePlatforms = new HashSet<string>();\n+                foreach (string s in projectReferencePlatformsMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    projectReferencePlatforms.Add(s);\n+                }\n+\n+                string buildProjectReferenceAs = string.Empty;\n+\n+                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.\n+                // Don't set `buildProjectReferenceAs` and the `_GetProjectReferencePlatformProperties` target will handle the rest.\n+                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(CurrentProjectPlatform, StringComparison.OrdinalIgnoreCase) && !isGraphBuild)",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "removed",
              "createdAt": "2022-05-20T19:42:20Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,110 @@\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Evaluation;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are used in both the \n+    /// tasks and graph projects in order for two projects to negotiate which platform a projectreference\n+    /// should be built as.\n+    /// </summary>\n+    static internal class PlatformNegotiation\n+    {\n+        internal static string? GetNearestPlatform(string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, String platformLookupTable, String projectPath, String CurrentProjectPlatform, bool isGraphBuild, TaskLoggingHelper? log = null)\n+        {\n+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(platformLookupTable, log);\n+\n+            if (string.IsNullOrEmpty(projectReferencePlatformsMetadata) && string.IsNullOrEmpty(referencedProjectPlatform))\n+                {\n+                    log?.LogWarningWithCodeFromResources(\"GetCompatiblePlatform.NoPlatformsListed\", projectPath);\n+                    return \"\";\n+                }\n+\n+                // Pull platformLookupTable metadata from the referenced project. This allows custom\n+                // mappings on a per-ProjectReference basis.\n+                Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata, log);\n+\n+                HashSet<string> projectReferencePlatforms = new HashSet<string>();\n+                foreach (string s in projectReferencePlatformsMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))\n+                {\n+                    projectReferencePlatforms.Add(s);\n+                }\n+\n+                string buildProjectReferenceAs = string.Empty;\n+\n+                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.\n+                // Don't set `buildProjectReferenceAs` and the `_GetProjectReferencePlatformProperties` target will handle the rest.\n+                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(CurrentProjectPlatform, StringComparison.OrdinalIgnoreCase) && !isGraphBuild)",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`CurrentProjectPlatform` -> `currentProjectPlatform`",
              "createdAt": "2022-05-20T17:38:37Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,110 @@\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Evaluation;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are used in both the \n+    /// tasks and graph projects in order for two projects to negotiate which platform a projectreference\n+    /// should be built as.\n+    /// </summary>\n+    static internal class PlatformNegotiation\n+    {\n+        internal static string? GetNearestPlatform(string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, String platformLookupTable, String projectPath, String CurrentProjectPlatform, bool isGraphBuild, TaskLoggingHelper? log = null)",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "changed",
              "createdAt": "2022-05-20T19:42:11Z",
              "path": "src/Shared/PlatformNegotiation.cs",
              "diffHunk": "@@ -0,0 +1,110 @@\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Utilities;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Evaluation;\n+\n+namespace Microsoft.Build.Shared\n+{\n+    /// <summary>\n+    /// This class contains only static methods, which are used in both the \n+    /// tasks and graph projects in order for two projects to negotiate which platform a projectreference\n+    /// should be built as.\n+    /// </summary>\n+    static internal class PlatformNegotiation\n+    {\n+        internal static string? GetNearestPlatform(string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, String platformLookupTable, String projectPath, String CurrentProjectPlatform, bool isGraphBuild, TaskLoggingHelper? log = null)",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`CurrentProjectPlatform` -> `currentProjectPlatform`",
              "createdAt": "2022-05-20T17:38:59Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));\n+                // We need this second evauation if the project is the first in a chain with setplatform negotitation as it needs to passdown its platform and its lookup table\n+                if (ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))\n+                {\n+                    globalProperties[\"platform\"] = projectInstance.GetPropertyValue(PlatformMetadataName);\n+                    globalProperties[PlatformLookupTableMetadataName] = projectInstance.GetPropertyValue(PlatformLookupTableMetadataName);\n+                    projectInstance = _projectInstanceFactory(\n+                                        configurationMetadata.ProjectFullPath,\n+                                        globalProperties,\n+                                        _projectCollection);\n+                }\n+            }\n+            else\n+            {\n+                projectInstance = _projectInstanceFactory(\n+                configurationMetadata.ProjectFullPath,\n+                null,\n+                _projectCollection);\n+            }\n \n             if (projectInstance == null)\n             {\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n-            var graphNode = new ProjectGraphNode(projectInstance);\n+            if (enableDynamicPlatformResolution)\n+            {\n+                String platformLookupTable;\n+                globalProperties.TryGetValue(PlatformLookupTableMetadataName, out platformLookupTable);\n+                String CurrentProjectPlatform;",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "removed this variable",
              "createdAt": "2022-05-20T19:41:33Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));\n+                // We need this second evauation if the project is the first in a chain with setplatform negotitation as it needs to passdown its platform and its lookup table\n+                if (ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))\n+                {\n+                    globalProperties[\"platform\"] = projectInstance.GetPropertyValue(PlatformMetadataName);\n+                    globalProperties[PlatformLookupTableMetadataName] = projectInstance.GetPropertyValue(PlatformLookupTableMetadataName);\n+                    projectInstance = _projectInstanceFactory(\n+                                        configurationMetadata.ProjectFullPath,\n+                                        globalProperties,\n+                                        _projectCollection);\n+                }\n+            }\n+            else\n+            {\n+                projectInstance = _projectInstanceFactory(\n+                configurationMetadata.ProjectFullPath,\n+                null,\n+                _projectCollection);\n+            }\n \n             if (projectInstance == null)\n             {\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n-            var graphNode = new ProjectGraphNode(projectInstance);\n+            if (enableDynamicPlatformResolution)\n+            {\n+                String platformLookupTable;\n+                globalProperties.TryGetValue(PlatformLookupTableMetadataName, out platformLookupTable);\n+                String CurrentProjectPlatform;",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Unused",
              "createdAt": "2022-05-20T17:45:51Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "removed",
              "createdAt": "2022-05-20T19:41:07Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Seemingly many indentation issues here. Unless GitHub's PR UI is just being terrible",
              "createdAt": "2022-05-20T17:46:21Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "fixed the indentation in last commit",
              "createdAt": "2022-05-20T21:24:22Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not sure why this needs to be passes as a global property. I don't see where that happens in `Microsoft.Common.CurrentVersion.targets`",
              "createdAt": "2022-05-20T17:49:06Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));\n+                // We need this second evauation if the project is the first in a chain with setplatform negotitation as it needs to passdown its platform and its lookup table\n+                if (ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))\n+                {\n+                    globalProperties[\"platform\"] = projectInstance.GetPropertyValue(PlatformMetadataName);\n+                    globalProperties[PlatformLookupTableMetadataName] = projectInstance.GetPropertyValue(PlatformLookupTableMetadataName);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "refactored to remove passing this as a global",
              "createdAt": "2022-05-20T19:40:39Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));\n+                // We need this second evauation if the project is the first in a chain with setplatform negotitation as it needs to passdown its platform and its lookup table\n+                if (ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))\n+                {\n+                    globalProperties[\"platform\"] = projectInstance.GetPropertyValue(PlatformMetadataName);\n+                    globalProperties[PlatformLookupTableMetadataName] = projectInstance.GetPropertyValue(PlatformLookupTableMetadataName);",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Use `PlatformMetadataName ` instead of `\"platform\"`",
              "createdAt": "2022-05-20T17:49:39Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));\n+                // We need this second evauation if the project is the first in a chain with setplatform negotitation as it needs to passdown its platform and its lookup table\n+                if (ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))\n+                {\n+                    globalProperties[\"platform\"] = projectInstance.GetPropertyValue(PlatformMetadataName);\n+                    globalProperties[PlatformLookupTableMetadataName] = projectInstance.GetPropertyValue(PlatformLookupTableMetadataName);\n+                    projectInstance = _projectInstanceFactory(\n+                                        configurationMetadata.ProjectFullPath,\n+                                        globalProperties,\n+                                        _projectCollection);\n+                }\n+            }\n+            else\n+            {\n+                projectInstance = _projectInstanceFactory(\n+                configurationMetadata.ProjectFullPath,\n+                null,\n+                _projectCollection);\n+            }\n \n             if (projectInstance == null)\n             {\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n-            var graphNode = new ProjectGraphNode(projectInstance);\n+            if (enableDynamicPlatformResolution)\n+            {\n+                String platformLookupTable;\n+                globalProperties.TryGetValue(PlatformLookupTableMetadataName, out platformLookupTable);\n+                String CurrentProjectPlatform;\n+                globalProperties.TryGetValue(PlatformMetadataName, out CurrentProjectPlatform);\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), platformLookupTable, projectInstance.FullPath, CurrentProjectPlatform, true);\n+\n+                if (SelectedPlatform != null)\n+                {\n+                    globalProperties[\"platform\"] = SelectedPlatform;",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "changed",
              "createdAt": "2022-05-20T19:40:24Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));\n+                // We need this second evauation if the project is the first in a chain with setplatform negotitation as it needs to passdown its platform and its lookup table\n+                if (ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))\n+                {\n+                    globalProperties[\"platform\"] = projectInstance.GetPropertyValue(PlatformMetadataName);\n+                    globalProperties[PlatformLookupTableMetadataName] = projectInstance.GetPropertyValue(PlatformLookupTableMetadataName);\n+                    projectInstance = _projectInstanceFactory(\n+                                        configurationMetadata.ProjectFullPath,\n+                                        globalProperties,\n+                                        _projectCollection);\n+                }\n+            }\n+            else\n+            {\n+                projectInstance = _projectInstanceFactory(\n+                configurationMetadata.ProjectFullPath,\n+                null,\n+                _projectCollection);\n+            }\n \n             if (projectInstance == null)\n             {\n                 throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"NullReferenceFromProjectInstanceFactory\"));\n             }\n \n-            var graphNode = new ProjectGraphNode(projectInstance);\n+            if (enableDynamicPlatformResolution)\n+            {\n+                String platformLookupTable;\n+                globalProperties.TryGetValue(PlatformLookupTableMetadataName, out platformLookupTable);\n+                String CurrentProjectPlatform;\n+                globalProperties.TryGetValue(PlatformMetadataName, out CurrentProjectPlatform);\n+                var SelectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), platformLookupTable, projectInstance.FullPath, CurrentProjectPlatform, true);\n+\n+                if (SelectedPlatform != null)\n+                {\n+                    globalProperties[\"platform\"] = SelectedPlatform;",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "use `PlatformMetadataName` instead of `\"platform\"`",
              "createdAt": "2022-05-20T17:50:12Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));\n+                // We need this second evauation if the project is the first in a chain with setplatform negotitation as it needs to passdown its platform and its lookup table\n+                if (ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))\n+                {\n+                    globalProperties[\"platform\"] = projectInstance.GetPropertyValue(PlatformMetadataName);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "changed",
              "createdAt": "2022-05-20T19:40:08Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));\n+                // We need this second evauation if the project is the first in a chain with setplatform negotitation as it needs to passdown its platform and its lookup table\n+                if (ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))\n+                {\n+                    globalProperties[\"platform\"] = projectInstance.GetPropertyValue(PlatformMetadataName);",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\"passdown\" -> \"pass down\"",
              "createdAt": "2022-05-20T17:50:53Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));\n+                // We need this second evauation if the project is the first in a chain with setplatform negotitation as it needs to passdown its platform and its lookup table",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "removed this logic and the comment during refactoring",
              "createdAt": "2022-05-20T19:39:29Z",
              "path": "src/Build/Graph/GraphBuilder.cs",
              "diffHunk": "@@ -495,24 +496,68 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo\n             }\n         }\n \n-        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)\n+        private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata, bool enableDynamicPlatformResolution)\n         {\n             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.\n             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();\n-\n-            var projectInstance = _projectInstanceFactory(\n+            ProjectGraphNode graphNode;\n+            ProjectInstance projectInstance;\n+           \n+            if (!enableDynamicPlatformResolution)\n+            {\n+                projectInstance = _projectInstanceFactory(\n                 configurationMetadata.ProjectFullPath,\n                 globalProperties,\n                 _projectCollection);\n+                var dynamic = ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));\n+                // We need this second evauation if the project is the first in a chain with setplatform negotitation as it needs to passdown its platform and its lookup table",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        public ConfigurationMetadata(string projectFullPath, PropertyDictionary<ProjectPropertyInstance> globalProperties, string PreviousPlatform, string PreviousPlatformLookupTable)\r\n        {\r\n            ErrorUtilities.VerifyThrowArgumentLength(projectFullPath, nameof(projectFullPath));\r\n            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));\r\n\r\n            _projectFullPath = projectFullPath;\r\n            _toolsVersion = MSBuildConstants.CurrentToolsVersion;\r\n            _globalProperties = globalProperties;\r\n            _PreviousPlatform = previousPlatform;\r\n            _PreviousPlatformLookupTable = previousPlatformLookupTable;\r\n        }\r\n```\r\nIn general, parameters aren't pascal-cased. Does `_PreviousPlatform` need to exist?  It doesn't seem to me that the property needs a backing variable in this class.",
              "createdAt": "2022-05-23T15:20:18Z",
              "path": "src/Build/BackEnd/Shared/ConfigurationMetadata.cs",
              "diffHunk": "@@ -57,11 +61,26 @@ public ConfigurationMetadata(string projectFullPath, PropertyDictionary<ProjectP\n             _projectFullPath = projectFullPath;\n             _toolsVersion = MSBuildConstants.CurrentToolsVersion;\n             _globalProperties = globalProperties;\n+            _PreviousPlatform = \"\";\n+            _PreviousPlatformLookupTable = \"\";\n+        }\n+        public ConfigurationMetadata(string projectFullPath, PropertyDictionary<ProjectPropertyInstance> globalProperties, string PreviousPlatform, string PreviousPlatformLookupTable)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentLength(projectFullPath, nameof(projectFullPath));\n+            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));\n+\n+            _projectFullPath = projectFullPath;\n+            _toolsVersion = MSBuildConstants.CurrentToolsVersion;\n+            _globalProperties = globalProperties;\n+            _PreviousPlatform = PreviousPlatform;\n+            _PreviousPlatformLookupTable = PreviousPlatformLookupTable;\n         }",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "changed to normal public variables ",
              "createdAt": "2022-05-23T17:35:54Z",
              "path": "src/Build/BackEnd/Shared/ConfigurationMetadata.cs",
              "diffHunk": "@@ -57,11 +61,26 @@ public ConfigurationMetadata(string projectFullPath, PropertyDictionary<ProjectP\n             _projectFullPath = projectFullPath;\n             _toolsVersion = MSBuildConstants.CurrentToolsVersion;\n             _globalProperties = globalProperties;\n+            _PreviousPlatform = \"\";\n+            _PreviousPlatformLookupTable = \"\";\n+        }\n+        public ConfigurationMetadata(string projectFullPath, PropertyDictionary<ProjectPropertyInstance> globalProperties, string PreviousPlatform, string PreviousPlatformLookupTable)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentLength(projectFullPath, nameof(projectFullPath));\n+            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));\n+\n+            _projectFullPath = projectFullPath;\n+            _toolsVersion = MSBuildConstants.CurrentToolsVersion;\n+            _globalProperties = globalProperties;\n+            _PreviousPlatform = PreviousPlatform;\n+            _PreviousPlatformLookupTable = PreviousPlatformLookupTable;\n         }",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please add a note here that these tests mirror the ones in GetCompatiblePlatform_Tests",
              "createdAt": "2022-05-23T15:30:29Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text.RegularExpressions;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Graph.UnitTests",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Added in a description. and note about mirroring",
              "createdAt": "2022-05-23T16:41:33Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text.RegularExpressions;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Graph.UnitTests",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Project 3 doesn't need to exist here.",
              "createdAt": "2022-05-23T15:35:39Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text.RegularExpressions;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Graph.UnitTests\n+{\n+    public class ProjectGraphSetPlatformTests\n+    {\n+\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x64\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaProjectReferencesPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                        <PlatformLookupTable>win32=x86</PlatformLookupTable>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaAnyCPUDefault()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"AnyCPU\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaSamePlatform()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable></PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    <ItemGroup>\n+                                                        <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                        </ProjectReference>\n+                                                    </ItemGroup>\n+                                                    </Project>\");\n+\n+                var file2 = env.CreateFile(\"3.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "removed",
              "createdAt": "2022-05-23T16:41:16Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text.RegularExpressions;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Graph.UnitTests\n+{\n+    public class ProjectGraphSetPlatformTests\n+    {\n+\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x64\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaProjectReferencesPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                        <PlatformLookupTable>win32=x86</PlatformLookupTable>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaAnyCPUDefault()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"AnyCPU\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaSamePlatform()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable></PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    <ItemGroup>\n+                                                        <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                        </ProjectReference>\n+                                                    </ItemGroup>\n+                                                    </Project>\");\n+\n+                var file2 = env.CreateFile(\"3.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Here we need to make sure 2.proj ends up with `x64`. ",
              "createdAt": "2022-05-23T15:42:23Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text.RegularExpressions;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Graph.UnitTests\n+{\n+    public class ProjectGraphSetPlatformTests\n+    {\n+\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x64\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaProjectReferencesPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                        <PlatformLookupTable>win32=x86</PlatformLookupTable>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaAnyCPUDefault()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"AnyCPU\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaSamePlatform()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable></PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    <ItemGroup>\n+                                                        <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                        </ProjectReference>\n+                                                    </ItemGroup>\n+                                                    </Project>\");\n+\n+                var file2 = env.CreateFile(\"3.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void FailsToResolve()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsWhenProjectReferenceHasNoPlatformOptions()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable></PlatformLookupTable>\n+                                                        <Platforms></Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsOnInvalidFormatLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>AnyCPU</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=;A=B</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"AnyCPU\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsOnInvalidFormatProjectReferenceLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>AnyCPU</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x86;A=B</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable>x86=;b=d</PlatformLookupTable>\n+                                                        <Platforms>x64;x86</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"AnyCPU\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void PlatformIsChosenAsDefault()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x64</Platform>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <platform>x64</platform>\n+                                                        <Platforms>x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x64\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "you mean the evaluated property should be x64 right? not the global property.",
              "createdAt": "2022-05-23T16:40:18Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text.RegularExpressions;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Graph.UnitTests\n+{\n+    public class ProjectGraphSetPlatformTests\n+    {\n+\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x64\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaProjectReferencesPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                        <PlatformLookupTable>win32=x86</PlatformLookupTable>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaAnyCPUDefault()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"AnyCPU\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaSamePlatform()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable></PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    <ItemGroup>\n+                                                        <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                        </ProjectReference>\n+                                                    </ItemGroup>\n+                                                    </Project>\");\n+\n+                var file2 = env.CreateFile(\"3.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void FailsToResolve()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsWhenProjectReferenceHasNoPlatformOptions()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable></PlatformLookupTable>\n+                                                        <Platforms></Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsOnInvalidFormatLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>AnyCPU</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=;A=B</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"AnyCPU\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsOnInvalidFormatProjectReferenceLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>AnyCPU</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x86;A=B</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable>x86=;b=d</PlatformLookupTable>\n+                                                        <Platforms>x64;x86</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"AnyCPU\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void PlatformIsChosenAsDefault()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x64</Platform>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <platform>x64</platform>\n+                                                        <Platforms>x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x64\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);",
              "author": {
                "login": "MIchaelRShea"
              }
            },
            {
              "body": "Scratch this comment. 2.proj's global prop for `platform` _should_ be empty because it'll evaluate to `x64` anyway. Can we add a check to verify that its evaluated `Platform` matches 1's platform?",
              "createdAt": "2022-05-23T16:49:36Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text.RegularExpressions;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Graph.UnitTests\n+{\n+    public class ProjectGraphSetPlatformTests\n+    {\n+\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x64\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaProjectReferencesPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                        <PlatformLookupTable>win32=x86</PlatformLookupTable>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaAnyCPUDefault()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"AnyCPU\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaSamePlatform()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable></PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    <ItemGroup>\n+                                                        <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                        </ProjectReference>\n+                                                    </ItemGroup>\n+                                                    </Project>\");\n+\n+                var file2 = env.CreateFile(\"3.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void FailsToResolve()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsWhenProjectReferenceHasNoPlatformOptions()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable></PlatformLookupTable>\n+                                                        <Platforms></Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsOnInvalidFormatLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>AnyCPU</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=;A=B</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"AnyCPU\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsOnInvalidFormatProjectReferenceLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>AnyCPU</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x86;A=B</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable>x86=;b=d</PlatformLookupTable>\n+                                                        <Platforms>x64;x86</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"AnyCPU\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void PlatformIsChosenAsDefault()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x64</Platform>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <platform>x64</platform>\n+                                                        <Platforms>x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x64\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "added in ",
              "createdAt": "2022-05-23T17:08:41Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text.RegularExpressions;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Graph.UnitTests\n+{\n+    public class ProjectGraphSetPlatformTests\n+    {\n+\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x64\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaProjectReferencesPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                        <PlatformLookupTable>win32=x86</PlatformLookupTable>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaAnyCPUDefault()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"AnyCPU\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void ResolvesViaSamePlatform()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable></PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    <ItemGroup>\n+                                                        <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)3.proj\"\" >\n+                                                        </ProjectReference>\n+                                                    </ItemGroup>\n+                                                    </Project>\");\n+\n+                var file2 = env.CreateFile(\"3.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>\n+                                                        <Platforms>x86;x64;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void FailsToResolve()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsWhenProjectReferenceHasNoPlatformOptions()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x86</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable></PlatformLookupTable>\n+                                                        <Platforms></Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x86\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsOnInvalidFormatLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>AnyCPU</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=;A=B</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"AnyCPU\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);\n+            }\n+        }\n+\n+        [Fact]\n+        public void WarnsOnInvalidFormatProjectReferenceLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>AnyCPU</Platform>\n+                                                                                                <PlatformLookupTable>AnyCPU=x86;A=B</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <PlatformLookupTable>x86=;b=d</PlatformLookupTable>\n+                                                        <Platforms>x64;x86</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"AnyCPU\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(\"x86\");\n+            }\n+        }\n+\n+        [Fact]\n+        public void PlatformIsChosenAsDefault()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>x64</Platform>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <platform>x64</platform>\n+                                                        <Platforms>x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"x64\");\n+                ProjectGraph graph = new ProjectGraph(entryProject.Path, globalProperties: globals);\n+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties[\"Platform\"].ShouldBe(String.Empty);",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't there be no global properties at the start of the graph build?",
              "createdAt": "2022-05-23T15:43:30Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text.RegularExpressions;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Graph.UnitTests\n+{\n+    public class ProjectGraphSetPlatformTests\n+    {\n+\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Yes your correct. removed these as they were due to an older way I was passing platform",
              "createdAt": "2022-05-23T16:41:03Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Text.RegularExpressions;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;\n+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Graph.UnitTests\n+{\n+    public class ProjectGraphSetPlatformTests\n+    {\n+\n+\n+        [Fact]\n+        public void ResolvesViaPlatformLookupTable()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                // PlatformLookupTable always takes priority. It is typically user-defined.\n+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @\"<PropertyGroup>\n+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>\n+                                                                                                <Platform>win32</Platform>\n+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>\n+                                                                                            </PropertyGroup>\n+                                                                                            <ItemGroup>\n+                                                                                                <ProjectReference Include=\"\"$(MSBuildThisFileDirectory)2.proj\"\" >\n+                                                                                                </ProjectReference>\n+                                                                                            </ItemGroup>\");\n+                var file = env.CreateFile(\"2.proj\", @\"\n+                                                    <Project>\n+                                                    <PropertyGroup>\n+                                                        <Platforms>x64;x86;AnyCPU</Platforms>\n+                                                    </PropertyGroup>\n+                                                    </Project>\");\n+\n+                IDictionary<string, string> globals = new Dictionary<string, string>();\n+                globals.Add(\"Platform\", \"win32\");",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "low pri nit to only do if you're going to make another commit anyway: no need for this var",
              "createdAt": "2022-05-23T17:45:47Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -51,7 +55,6 @@ public void ResolvesViaPlatformLookupTable()\n                                                     </Project>\");\n \n                 IDictionary<string, string> globals = new Dictionary<string, string>();",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "removed. going to do a squash once i have all the changes made",
              "createdAt": "2022-05-23T20:37:57Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -51,7 +55,6 @@ public void ResolvesViaPlatformLookupTable()\n                                                     </Project>\");\n \n                 IDictionary<string, string> globals = new Dictionary<string, string>();",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this necessary?",
              "createdAt": "2022-05-23T17:47:14Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -7,6 +7,7 @@\n using System.Diagnostics;\n using System.IO;\n using System.Linq;\n+using System.Runtime.CompilerServices;",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "it is not, removed",
              "createdAt": "2022-05-23T20:37:35Z",
              "path": "src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs",
              "diffHunk": "@@ -7,6 +7,7 @@\n using System.Diagnostics;\n using System.IO;\n using System.Linq;\n+using System.Runtime.CompilerServices;",
              "author": {
                "login": "MIchaelRShea"
              }
            }
          ]
        }
      }
    ]
  }
}