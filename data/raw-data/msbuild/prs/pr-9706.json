{
  "number": 9706,
  "title": "Improve msbuild logger for testing workloads",
  "body": "Part of https://github.com/microsoft/vstest/issues/4843\r\nNeeds https://github.com/microsoft/vstest/pull/4877 to work, but does not break without it.\r\n\r\n### Context\r\nTerminal logger is reporting build, but when tests run via MSBuild there is very little feedback about what is going on. \r\n\r\n![logger](https://github.com/dotnet/msbuild/assets/5735905/51a0dfcc-c7ec-46ee-b167-cdb2623bd883)\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/5735905/51f97322-9260-4e2a-a7f0-e629a7179204)\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/5735905/530a4333-78b2-426f-b5eb-8f4394475800)\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/5735905/850a4736-3c93-48b6-928c-82017c1a8189)\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/5735905/4246258f-4544-420e-a2a6-60b3c4e0b26c)\r\n\r\n### Changes Made\r\nAdds colored test results where targets are normally.\r\nWrites summary for tests after the test run. \r\nWrites result for every test projects, no matter if it fails or succeeds. \r\n\r\n### Testing\r\nyup.\r\n\r\n### Notes\r\nIn comments.",
  "state": "MERGED",
  "createdAt": "2024-02-02T15:08:52Z",
  "updatedAt": "2024-02-21T11:34:06Z",
  "closedAt": "2024-02-19T13:57:32Z",
  "mergedAt": "2024-02-19T13:57:32Z",
  "additions": 1095,
  "deletions": 207,
  "changedFiles": 31,
  "headRefName": "exp/terminal-logger-for-vstest",
  "isDraft": false,
  "author": {
    "login": "nohwnd"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "21f8e47c431777f36a3b7db11fabecd176a09044",
          "message": "First take",
          "committedDate": "2024-01-30T16:36:15Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4ecf48666e54a8f54ffa1ec0dcc43f90fc166c1e",
          "message": "Fix timing and use extended messages",
          "committedDate": "2024-02-02T15:00:46Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "591a51e901ad425c736d0c9e9cfd81009afd5768",
          "message": "Remove unused class",
          "committedDate": "2024-02-06T10:34:15Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8a34eb886500729009ac995f01c6e47ed8ced922",
          "message": "doc and rename messages",
          "committedDate": "2024-02-07T16:49:36Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b53ee1cce38e637f9aa417f6db79e92c53710142",
          "message": "Fix colored target bug, and add tests",
          "committedDate": "2024-02-08T12:59:01Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e4e4baaaaa1635cce887dcb49e09df2dc990fb0e",
          "message": "Compile the regex",
          "committedDate": "2024-02-08T13:02:40Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "43e54297ba4f25c8d93bb165a621314bdc432e87",
          "message": "verified renamed",
          "committedDate": "2024-02-08T14:03:57Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9de8600b89f9d4cbcb2cf9c3e62706ba59184ea9",
          "message": "Fix class name",
          "committedDate": "2024-02-08T14:07:15Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4a1696b05038eb52c4f24947edcfe4a72bc6588b",
          "message": "Fix rendering without target",
          "committedDate": "2024-02-08T14:15:56Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "40339e4007c6543f36d6688afeaf6ecb1262d178",
          "message": "Localize",
          "committedDate": "2024-02-08T14:51:08Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "41afb1bb396f67f204c3fa43fb54be921542543c",
          "message": "Merge branch 'main' into exp/terminal-logger-for-vstest",
          "committedDate": "2024-02-08T14:52:14Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e3687319a10f729f2df41009d6a03429cd6d4a87",
          "message": "Merge conflict",
          "committedDate": "2024-02-08T15:40:06Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "11248b188203c6665232b90e5445479bf4a4b5bc",
          "message": "duration fix",
          "committedDate": "2024-02-08T16:31:19Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "828745e47f6a3d218dc83bdae3eb36162bba32fd",
          "message": "Pass colored parts of target separately",
          "committedDate": "2024-02-16T07:29:55Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3d2b1616c151a448eaa183708f2ef379dad1e8cc",
          "message": "Document node status ctors, to make it more obvious what the parameters are for",
          "committedDate": "2024-02-16T07:38:36Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a150ae8a12c754d5c01b6d5343068b969b448fc8",
          "message": "Apply suggestions from code review",
          "committedDate": "2024-02-16T08:07:23Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2e8c3c29c5a1c66150fa38d6379f185af419f1bf",
          "message": "Update src/Framework/Logging/AnsiCodes.cs",
          "committedDate": "2024-02-16T08:07:50Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "809092096f3ed6672b8b6512bcae976008c66c98",
          "message": "Fix extra space",
          "committedDate": "2024-02-16T15:59:44Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fd23994caa1c85f336b3c80871baf00c80cca7df",
          "message": "Merge branch 'exp/terminal-logger-for-vstest' of https://github.com/dotnet/msbuild into exp/terminal-logger-for-vstest",
          "committedDate": "2024-02-16T15:59:52Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bbf5b798ed945127b2468afdd36aaafddeaad65e",
          "message": "Suppress nullcheck because we check it above",
          "committedDate": "2024-02-19T09:15:03Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      },
      {
        "commit": {
          "oid": "11b8d55add4b9d38fd510795c50d90c162c22a30",
          "message": "Fix nits",
          "committedDate": "2024-02-19T12:58:29Z",
          "author": {
            "name": "Jakub Jare\u0161",
            "email": "me@jakubjares.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@rainersigwald aren't we working on removing the project prefix for each error report or something?",
        "createdAt": "2024-02-02T18:49:24Z",
        "author": {
          "login": "baronfel"
        }
      },
      {
        "body": "@baronfel @rainersigwald @rokonec I am close to happy. Would love to know if I need to change something significantly. ",
        "createdAt": "2024-02-08T16:34:24Z",
        "author": {
          "login": "nohwnd"
        }
      },
      {
        "body": "Available in dotnet/installer since 9.0.100-preview.2.24121.2 if anyone wants to try.",
        "createdAt": "2024-02-21T11:34:05Z",
        "author": {
          "login": "nohwnd"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This outputs powershell code that you can put into your terminal, and see all the ANSI code transitions in slow motion. Super helpful when debugging / validating the behavior.\r\n\r\n![ansi](https://github.com/dotnet/msbuild/assets/5735905/710302e4-18b0-490e-90f7-dc55ec179721)\r\n",
              "createdAt": "2024-02-08T14:56:56Z",
              "path": "src/MSBuild.UnitTests/NodeStatus_Transition_Tests.cs",
              "diffHunk": "@@ -0,0 +1,171 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Text.RegularExpressions;\n+using System.Threading.Tasks;\n+\n+using Microsoft.Build.Logging.TerminalLogger;\n+\n+using VerifyTests;\n+using VerifyXunit;\n+using Xunit;\n+\n+using static VerifyXunit.Verifier;\n+\n+\n+namespace Microsoft.Build.CommandLine.UnitTests;\n+\n+[UsesVerify]\n+public class NodeStatus_Transition_Tests\n+{\n+    public NodeStatus_Transition_Tests()\n+    {\n+        UseProjectRelativeDirectory(\"Snapshots\");\n+    }\n+\n+    [Fact]\n+    public async Task NodeTargetChanges()\n+    {\n+        var rendered = Animate(\n+            [\n+                new(\"Namespace.Project\", \"TargetFramework\", \"Build\", new MockStopwatch())\n+            ],\n+            [\n+               new(\"Namespace.Project\", \"TargetFramework\", \"Testing\", new MockStopwatch())\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    [Fact]\n+    public async Task NodeTargetUpdatesTime()\n+    {\n+        // This test look like there is no change between the frames, but we ask the stopwatch for time they will increase the number.\n+        // We need this because animations check that NodeStatus reference is the same.\n+        // And we cannot use MockStopwatch because we don't know when to call Tick on them, and if we do it right away, the time will update in \"both\" nodes.\n+        NodeStatus node = new(\"Namespace.Project\", \"TargetFramework\", \"Build\", new TickingStopwatch());\n+        var rendered = Animate(\n+            [\n+                node,\n+            ],\n+            [\n+               node,\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    [Fact]\n+    public async Task NodeTargetChangesToColoredTarget()\n+    {\n+        var rendered = Animate(\n+            [\n+                new(\"Namespace.Project\", \"TargetFramework\", \"Testing\", new MockStopwatch())\n+            ],\n+            [\n+               new(\"Namespace.Project\", \"TargetFramework\", $\"{AnsiCodes.Colorize(\"failed\", TerminalColor.Red)} MyTestName1\", new MockStopwatch())\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    [Fact]\n+    public async Task NodeWithColoredTargetUpdatesTime()\n+    {\n+        // This test look like there is no change between the frames, but we ask the stopwatch for time they will increase the number.\n+        // We need this because animations check that NodeStatus reference is the same.\n+        // And we cannot use MockStopwatch because we don't know when to call Tick on them, and if we do it right away, the time will update in \"both\" nodes.\n+        NodeStatus node = new(\"Namespace.Project\", \"TargetFramework\", $\"{AnsiCodes.Colorize(\"passed\", TerminalColor.Green)} MyTestName1\", new TickingStopwatch());\n+        var rendered = Animate(\n+            [\n+                node,\n+            ],\n+            [\n+               node\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    /// <summary>\n+    /// Chains and renders node status updates and outputs replay able string of all the transitions.\n+    /// </summary>\n+    /// <param name=\"nodeStatusesUpdates\">Takes array of arrays. The inner array is collection of nodes that are currently running. The outer array is how they update over time.</param>\n+    /// <returns></returns>\n+    private string Animate(params NodeStatus[][] nodeStatusesUpdates)\n+    {\n+        var width = 80;\n+        var height = 1;\n+\n+        NodesFrame previousFrame = new(Array.Empty<NodeStatus>(), 0, 0);\n+        StringBuilder result = new StringBuilder();\n+        foreach (var nodeStatuses in nodeStatusesUpdates)\n+        {\n+            NodesFrame currentFrame = new NodesFrame(nodeStatuses, width, height);\n+            result.Append(currentFrame.Render(previousFrame));\n+            previousFrame = currentFrame;\n+        }\n+\n+        return result.ToString();\n+    }\n+\n+    private async Task VerifyReplay(string rendered)\n+    {\n+        try\n+        {\n+            await Verify(rendered);\n+        }\n+        catch (Exception ex)\n+        {\n+            if (ex.GetType().Name != \"VerifyException\")\n+            {\n+                throw;\n+            }\n+\n+            if (!ex.Message.StartsWith(\"Directory:\"))\n+            {\n+                throw;\n+            }\n+\n+            string? directory = null;\n+            string? received = null;\n+            string? verified = null;\n+            foreach (var line in ex.Message.Split('\\n'))\n+            {\n+                var trimmed = line.TrimStart(' ', '-');\n+                Extract(trimmed, \"Directory\", ref directory);\n+                Extract(trimmed, \"Received\", ref received);\n+                Extract(trimmed, \"Verified\", ref verified);\n+            }\n+\n+            if (directory == null || received == null || verified == null)\n+            {\n+                throw;\n+            }\n+\n+            var pipeline = $$\"\"\" | % { \"`n`n\" } { $_ -split \"(?=`e)\" | % { Write-Host -NoNewline $_; Start-Sleep 0.5 }; Write-Host }\"\"\";\n+            throw new Exception($$\"\"\"\n+                {{ex.Message.TrimEnd('\\n')}}\n+\n+                Received replay:\n+                    Get-Content {{Path.Combine(directory, received)}} {{pipeline}}",
              "author": {
                "login": "nohwnd"
              }
            },
            {
              "body": "\ud83d\ude0d",
              "createdAt": "2024-02-15T16:21:00Z",
              "path": "src/MSBuild.UnitTests/NodeStatus_Transition_Tests.cs",
              "diffHunk": "@@ -0,0 +1,171 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Text.RegularExpressions;\n+using System.Threading.Tasks;\n+\n+using Microsoft.Build.Logging.TerminalLogger;\n+\n+using VerifyTests;\n+using VerifyXunit;\n+using Xunit;\n+\n+using static VerifyXunit.Verifier;\n+\n+\n+namespace Microsoft.Build.CommandLine.UnitTests;\n+\n+[UsesVerify]\n+public class NodeStatus_Transition_Tests\n+{\n+    public NodeStatus_Transition_Tests()\n+    {\n+        UseProjectRelativeDirectory(\"Snapshots\");\n+    }\n+\n+    [Fact]\n+    public async Task NodeTargetChanges()\n+    {\n+        var rendered = Animate(\n+            [\n+                new(\"Namespace.Project\", \"TargetFramework\", \"Build\", new MockStopwatch())\n+            ],\n+            [\n+               new(\"Namespace.Project\", \"TargetFramework\", \"Testing\", new MockStopwatch())\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    [Fact]\n+    public async Task NodeTargetUpdatesTime()\n+    {\n+        // This test look like there is no change between the frames, but we ask the stopwatch for time they will increase the number.\n+        // We need this because animations check that NodeStatus reference is the same.\n+        // And we cannot use MockStopwatch because we don't know when to call Tick on them, and if we do it right away, the time will update in \"both\" nodes.\n+        NodeStatus node = new(\"Namespace.Project\", \"TargetFramework\", \"Build\", new TickingStopwatch());\n+        var rendered = Animate(\n+            [\n+                node,\n+            ],\n+            [\n+               node,\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    [Fact]\n+    public async Task NodeTargetChangesToColoredTarget()\n+    {\n+        var rendered = Animate(\n+            [\n+                new(\"Namespace.Project\", \"TargetFramework\", \"Testing\", new MockStopwatch())\n+            ],\n+            [\n+               new(\"Namespace.Project\", \"TargetFramework\", $\"{AnsiCodes.Colorize(\"failed\", TerminalColor.Red)} MyTestName1\", new MockStopwatch())\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    [Fact]\n+    public async Task NodeWithColoredTargetUpdatesTime()\n+    {\n+        // This test look like there is no change between the frames, but we ask the stopwatch for time they will increase the number.\n+        // We need this because animations check that NodeStatus reference is the same.\n+        // And we cannot use MockStopwatch because we don't know when to call Tick on them, and if we do it right away, the time will update in \"both\" nodes.\n+        NodeStatus node = new(\"Namespace.Project\", \"TargetFramework\", $\"{AnsiCodes.Colorize(\"passed\", TerminalColor.Green)} MyTestName1\", new TickingStopwatch());\n+        var rendered = Animate(\n+            [\n+                node,\n+            ],\n+            [\n+               node\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    /// <summary>\n+    /// Chains and renders node status updates and outputs replay able string of all the transitions.\n+    /// </summary>\n+    /// <param name=\"nodeStatusesUpdates\">Takes array of arrays. The inner array is collection of nodes that are currently running. The outer array is how they update over time.</param>\n+    /// <returns></returns>\n+    private string Animate(params NodeStatus[][] nodeStatusesUpdates)\n+    {\n+        var width = 80;\n+        var height = 1;\n+\n+        NodesFrame previousFrame = new(Array.Empty<NodeStatus>(), 0, 0);\n+        StringBuilder result = new StringBuilder();\n+        foreach (var nodeStatuses in nodeStatusesUpdates)\n+        {\n+            NodesFrame currentFrame = new NodesFrame(nodeStatuses, width, height);\n+            result.Append(currentFrame.Render(previousFrame));\n+            previousFrame = currentFrame;\n+        }\n+\n+        return result.ToString();\n+    }\n+\n+    private async Task VerifyReplay(string rendered)\n+    {\n+        try\n+        {\n+            await Verify(rendered);\n+        }\n+        catch (Exception ex)\n+        {\n+            if (ex.GetType().Name != \"VerifyException\")\n+            {\n+                throw;\n+            }\n+\n+            if (!ex.Message.StartsWith(\"Directory:\"))\n+            {\n+                throw;\n+            }\n+\n+            string? directory = null;\n+            string? received = null;\n+            string? verified = null;\n+            foreach (var line in ex.Message.Split('\\n'))\n+            {\n+                var trimmed = line.TrimStart(' ', '-');\n+                Extract(trimmed, \"Directory\", ref directory);\n+                Extract(trimmed, \"Received\", ref received);\n+                Extract(trimmed, \"Verified\", ref verified);\n+            }\n+\n+            if (directory == null || received == null || verified == null)\n+            {\n+                throw;\n+            }\n+\n+            var pipeline = $$\"\"\" | % { \"`n`n\" } { $_ -split \"(?=`e)\" | % { Write-Host -NoNewline $_; Start-Sleep 0.5 }; Write-Host }\"\"\";\n+            throw new Exception($$\"\"\"\n+                {{ex.Message.TrimEnd('\\n')}}\n+\n+                Received replay:\n+                    Get-Content {{Path.Combine(directory, received)}} {{pipeline}}",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "\u2764\ufe0f ",
              "createdAt": "2024-02-19T11:12:23Z",
              "path": "src/MSBuild.UnitTests/NodeStatus_Transition_Tests.cs",
              "diffHunk": "@@ -0,0 +1,171 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Text.RegularExpressions;\n+using System.Threading.Tasks;\n+\n+using Microsoft.Build.Logging.TerminalLogger;\n+\n+using VerifyTests;\n+using VerifyXunit;\n+using Xunit;\n+\n+using static VerifyXunit.Verifier;\n+\n+\n+namespace Microsoft.Build.CommandLine.UnitTests;\n+\n+[UsesVerify]\n+public class NodeStatus_Transition_Tests\n+{\n+    public NodeStatus_Transition_Tests()\n+    {\n+        UseProjectRelativeDirectory(\"Snapshots\");\n+    }\n+\n+    [Fact]\n+    public async Task NodeTargetChanges()\n+    {\n+        var rendered = Animate(\n+            [\n+                new(\"Namespace.Project\", \"TargetFramework\", \"Build\", new MockStopwatch())\n+            ],\n+            [\n+               new(\"Namespace.Project\", \"TargetFramework\", \"Testing\", new MockStopwatch())\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    [Fact]\n+    public async Task NodeTargetUpdatesTime()\n+    {\n+        // This test look like there is no change between the frames, but we ask the stopwatch for time they will increase the number.\n+        // We need this because animations check that NodeStatus reference is the same.\n+        // And we cannot use MockStopwatch because we don't know when to call Tick on them, and if we do it right away, the time will update in \"both\" nodes.\n+        NodeStatus node = new(\"Namespace.Project\", \"TargetFramework\", \"Build\", new TickingStopwatch());\n+        var rendered = Animate(\n+            [\n+                node,\n+            ],\n+            [\n+               node,\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    [Fact]\n+    public async Task NodeTargetChangesToColoredTarget()\n+    {\n+        var rendered = Animate(\n+            [\n+                new(\"Namespace.Project\", \"TargetFramework\", \"Testing\", new MockStopwatch())\n+            ],\n+            [\n+               new(\"Namespace.Project\", \"TargetFramework\", $\"{AnsiCodes.Colorize(\"failed\", TerminalColor.Red)} MyTestName1\", new MockStopwatch())\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    [Fact]\n+    public async Task NodeWithColoredTargetUpdatesTime()\n+    {\n+        // This test look like there is no change between the frames, but we ask the stopwatch for time they will increase the number.\n+        // We need this because animations check that NodeStatus reference is the same.\n+        // And we cannot use MockStopwatch because we don't know when to call Tick on them, and if we do it right away, the time will update in \"both\" nodes.\n+        NodeStatus node = new(\"Namespace.Project\", \"TargetFramework\", $\"{AnsiCodes.Colorize(\"passed\", TerminalColor.Green)} MyTestName1\", new TickingStopwatch());\n+        var rendered = Animate(\n+            [\n+                node,\n+            ],\n+            [\n+               node\n+            ]);\n+\n+        await VerifyReplay(rendered);\n+    }\n+\n+    /// <summary>\n+    /// Chains and renders node status updates and outputs replay able string of all the transitions.\n+    /// </summary>\n+    /// <param name=\"nodeStatusesUpdates\">Takes array of arrays. The inner array is collection of nodes that are currently running. The outer array is how they update over time.</param>\n+    /// <returns></returns>\n+    private string Animate(params NodeStatus[][] nodeStatusesUpdates)\n+    {\n+        var width = 80;\n+        var height = 1;\n+\n+        NodesFrame previousFrame = new(Array.Empty<NodeStatus>(), 0, 0);\n+        StringBuilder result = new StringBuilder();\n+        foreach (var nodeStatuses in nodeStatusesUpdates)\n+        {\n+            NodesFrame currentFrame = new NodesFrame(nodeStatuses, width, height);\n+            result.Append(currentFrame.Render(previousFrame));\n+            previousFrame = currentFrame;\n+        }\n+\n+        return result.ToString();\n+    }\n+\n+    private async Task VerifyReplay(string rendered)\n+    {\n+        try\n+        {\n+            await Verify(rendered);\n+        }\n+        catch (Exception ex)\n+        {\n+            if (ex.GetType().Name != \"VerifyException\")\n+            {\n+                throw;\n+            }\n+\n+            if (!ex.Message.StartsWith(\"Directory:\"))\n+            {\n+                throw;\n+            }\n+\n+            string? directory = null;\n+            string? received = null;\n+            string? verified = null;\n+            foreach (var line in ex.Message.Split('\\n'))\n+            {\n+                var trimmed = line.TrimStart(' ', '-');\n+                Extract(trimmed, \"Directory\", ref directory);\n+                Extract(trimmed, \"Received\", ref received);\n+                Extract(trimmed, \"Verified\", ref verified);\n+            }\n+\n+            if (directory == null || received == null || verified == null)\n+            {\n+                throw;\n+            }\n+\n+            var pipeline = $$\"\"\" | % { \"`n`n\" } { $_ -split \"(?=`e)\" | % { Write-Host -NoNewline $_; Start-Sleep 0.5 }; Write-Host }\"\"\";\n+            throw new Exception($$\"\"\"\n+                {{ex.Message.TrimEnd('\\n')}}\n+\n+                Received replay:\n+                    Get-Content {{Path.Combine(directory, received)}} {{pipeline}}",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Moved this here because then we can use this in unit tests and see how the cursor actually moves when we write this to terminal.",
              "createdAt": "2024-02-08T14:58:26Z",
              "path": "src/MSBuild/TerminalLogger/NodesFrame.cs",
              "diffHunk": "@@ -92,6 +100,9 @@ public string Render(NodesFrame previousFrame)\n         StringBuilder sb = _renderBuilder;\n         sb.Clear();\n \n+        // Move cursor back to 1st line of nodes.\n+        sb.AppendLine($\"{AnsiCodes.CSI}{previousFrame.NodesCount + 1}{AnsiCodes.MoveUpToLineStart}\");",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "would have used Clear, but it is not available in netstandard. So I grab the items and then overwrite the instance. I was also not sure if multithreading is an issue here. If not, a List is okay for me, or aggregating the numbers in place without additional structures.",
              "createdAt": "2024-02-08T14:59:25Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -271,6 +294,9 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)\n \n         _projects.Clear();\n \n+        var testRunSummaries = _testRunSummaries.ToList();\n+        _testRunSummaries = new ConcurrentBag<TestSummary>();",
              "author": {
                "login": "nohwnd"
              }
            },
            {
              "body": "Loggers Events are invoked in serial fashion. AFAIK there is no need for thread safety - `List<T>` will do.",
              "createdAt": "2024-02-19T12:16:50Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -271,6 +294,9 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)\n \n         _projects.Clear();\n \n+        var testRunSummaries = _testRunSummaries.ToList();\n+        _testRunSummaries = new ConcurrentBag<TestSummary>();",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "done",
              "createdAt": "2024-02-19T12:52:19Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -271,6 +294,9 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)\n \n         _projects.Clear();\n \n+        var testRunSummaries = _testRunSummaries.ToList();\n+        _testRunSummaries = new ConcurrentBag<TestSummary>();",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This avoid showing ugly internal name, until first test result arrives.  Targets are not normally localized, so I also don't localize this.",
              "createdAt": "2024-02-08T15:01:03Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -503,7 +574,22 @@ private void TargetStarted(object sender, TargetStartedEventArgs e)\n             project.Stopwatch.Start();\n \n             string projectFile = Path.GetFileNameWithoutExtension(e.ProjectFile);\n-            NodeStatus nodeStatus = new(projectFile, project.TargetFramework, e.TargetName, project.Stopwatch);\n+\n+            var isTestTarget = e.TargetName == _testTarget;\n+\n+            var targetName = isTestTarget ? \"Testing\" : e.TargetName;",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This will inspect every target on update, maybe this is too heavy and we should pass some structure that describes the output and colorization rather than reparsing ANSI out of string?",
              "createdAt": "2024-02-08T15:02:58Z",
              "path": "src/Framework/Logging/AnsiCodes.cs",
              "diffHunk": "@@ -122,6 +124,11 @@ internal static class AnsiCodes\n     /// </remarks>\n     public const string RemoveProgress = \"\\x1b]9;4;0;\\x1b\\\\\";\n \n+    /// <summary>\n+    /// Remove all ANSI escape codes from a string.\n+    /// </summary>\n+    private static readonly Regex RemoveAnsiRegex = new Regex(@\"\\x1B\\[[^@-~]*[@-~]\", RegexOptions.Compiled);",
              "author": {
                "login": "nohwnd"
              }
            },
            {
              "body": "This does seem pretty heavy to me. Would it be possible to put the colorized string in metadata, and use that if it exists?",
              "createdAt": "2024-02-15T16:59:42Z",
              "path": "src/Framework/Logging/AnsiCodes.cs",
              "diffHunk": "@@ -122,6 +124,11 @@ internal static class AnsiCodes\n     /// </remarks>\n     public const string RemoveProgress = \"\\x1b]9;4;0;\\x1b\\\\\";\n \n+    /// <summary>\n+    /// Remove all ANSI escape codes from a string.\n+    /// </summary>\n+    private static readonly Regex RemoveAnsiRegex = new Regex(@\"\\x1B\\[[^@-~]*[@-~]\", RegexOptions.Compiled);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "solved",
              "createdAt": "2024-02-19T13:50:50Z",
              "path": "src/Framework/Logging/AnsiCodes.cs",
              "diffHunk": "@@ -122,6 +124,11 @@ internal static class AnsiCodes\n     /// </remarks>\n     public const string RemoveProgress = \"\\x1b]9;4;0;\\x1b\\\\\";\n \n+    /// <summary>\n+    /// Remove all ANSI escape codes from a string.\n+    /// </summary>\n+    private static readonly Regex RemoveAnsiRegex = new Regex(@\"\\x1B\\[[^@-~]*[@-~]\", RegexOptions.Compiled);",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Moved into rendering the node update string so we can see it in unit tests. Kept hide cursor and show cursor here, for the same reason.",
              "createdAt": "2024-02-08T15:06:54Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -709,8 +855,6 @@ internal void DisplayNodes()\n         Terminal.Write(AnsiCodes.HideCursor);\n         try\n         {\n-            // Move cursor back to 1st line of nodes.\n-            Terminal.WriteLine($\"{AnsiCodes.CSI}{_currentFrame.NodesCount + 1}{AnsiCodes.MoveUpToLineStart}\");",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Instead of these test-specific message types I wonder if we should smuggle some sort of progress thing here and prerender the status messages in the task itself. That feels more like what I was envisioning for the final state . . .",
              "createdAt": "2024-02-15T16:39:27Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -556,25 +644,80 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)\n         string? message = e.Message;\n         if (message is not null && e.Importance == MessageImportance.High)\n         {\n+            var hasProject = _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project);\n             // Detect project output path by matching high-importance messages against the \"$(MSBuildProjectName) -> ...\"\n             // pattern used by the CopyFilesToOutputDirectory target.\n             int index = message.IndexOf(FilePathPattern, StringComparison.Ordinal);\n             if (index > 0)\n             {\n                 var projectFileName = Path.GetFileName(e.ProjectFile.AsSpan());\n                 if (!projectFileName.IsEmpty &&\n-                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) &&\n-                    _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))\n+                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) && hasProject)\n                 {\n                     ReadOnlyMemory<char> outputPath = e.Message.AsMemory().Slice(index + 4);\n-                    project.OutputPath = outputPath;\n+                    project!.OutputPath = outputPath;\n                 }\n             }\n \n             if (IsImmediateMessage(message))\n             {\n                 RenderImmediateMessage(message);\n             }\n+            else if (hasProject && project!.IsTestProject)\n+            {\n+                var node = _nodes[NodeIndexForContext(buildEventContext)];\n+\n+                // Consumes test update messages produced by VSTest and MSTest runner.\n+                if (node != null && e is IExtendedBuildEventArgs extendedMessage)\n+                {\n+                    switch (extendedMessage.ExtendedType)\n+                    {\n+                        case \"TLTESTPASSED\":",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I can change this to be a bit more generic, but I would like to see the progress api fleshed out and agreed upon. I think we might have different needs for tests than for a \"generic\" progress.  Can we keep this for P2, please?\r\n\r\nRight now this is reporting work that just finished, and it stays on screen until next work finishes. But I would like to see ability to report work that just finished, and then after some time revert to work that is running (1-2 seconds), @rokonec had this proposal IIRC and I really like it. But I can think about other scenarios, like 1 project running 12 tests in parallel, or 12 project running 12 tests in parallel, and they each have their own reporting needs (or at least possibilities).\r\n\r\n> prerender the status messages in the task itself.\r\n\r\nI am passing the pieces here, because I want the indicator be localized and colored. This cannot be rendered before (if by _rendered_ you mean converted to text with ansi codes), because then the math in Render method does not work. \r\n\r\n(My confusion about \"rendered\" comes from thinking about it as what is finally shown on the screen, where the ansi codes don't render as is, but are converted to colors and styles. That is why I am clarifying rendered.)",
              "createdAt": "2024-02-16T07:58:54Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -556,25 +644,80 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)\n         string? message = e.Message;\n         if (message is not null && e.Importance == MessageImportance.High)\n         {\n+            var hasProject = _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project);\n             // Detect project output path by matching high-importance messages against the \"$(MSBuildProjectName) -> ...\"\n             // pattern used by the CopyFilesToOutputDirectory target.\n             int index = message.IndexOf(FilePathPattern, StringComparison.Ordinal);\n             if (index > 0)\n             {\n                 var projectFileName = Path.GetFileName(e.ProjectFile.AsSpan());\n                 if (!projectFileName.IsEmpty &&\n-                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) &&\n-                    _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))\n+                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) && hasProject)\n                 {\n                     ReadOnlyMemory<char> outputPath = e.Message.AsMemory().Slice(index + 4);\n-                    project.OutputPath = outputPath;\n+                    project!.OutputPath = outputPath;\n                 }\n             }\n \n             if (IsImmediateMessage(message))\n             {\n                 RenderImmediateMessage(message);\n             }\n+            else if (hasProject && project!.IsTestProject)\n+            {\n+                var node = _nodes[NodeIndexForContext(buildEventContext)];\n+\n+                // Consumes test update messages produced by VSTest and MSTest runner.\n+                if (node != null && e is IExtendedBuildEventArgs extendedMessage)\n+                {\n+                    switch (extendedMessage.ExtendedType)\n+                    {\n+                        case \"TLTESTPASSED\":",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Using length directly, so we don't create a string only to measure it.",
              "createdAt": "2024-02-16T07:31:14Z",
              "path": "src/MSBuild/TerminalLogger/NodesFrame.cs",
              "diffHunk": "@@ -53,13 +53,21 @@ internal ReadOnlySpan<char> RenderNodeStatus(int i)\n         string project = status.Project;\n         string? targetFramework = status.TargetFramework;\n         string target = status.Target;\n+        string? targetPrefix = status.TargetPrefix;\n+        TerminalColor targetPrefixColor = status.TargetPrefixColor;\n \n-        int renderedWidth = Length(durationString, project, targetFramework, target);\n+        var targetWithoutAnsiLength = targetPrefix != null",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n```",
              "createdAt": "2024-02-16T07:59:32Z",
              "path": "src/Framework/Logging/AnsiCodes.cs",
              "diffHunk": "@@ -1,6 +1,8 @@\n \ufeff// Licensed to the .NET Foundation under one or more agreements.\n // The .NET Foundation licenses this file to you under the MIT license.\n \n+using System.Text.RegularExpressions;",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@rainersigwald  I've replaced the regex with passing the pieces directly, and coloring them later, this way I don't need to strip the ansi codes, or allocate additional structures to represent a string with colors. I did the bare minimum to not make the math in Render become a nightmare. \r\n\r\nI am not super happy with the 2 constructors, let me know if you'd prefer to have just this one, and replace the calls to the other one.",
              "createdAt": "2024-02-16T08:04:30Z",
              "path": "src/MSBuild/TerminalLogger/NodeStatus.cs",
              "diffHunk": "@@ -13,13 +13,42 @@ internal class NodeStatus\n {\n     public string Project { get; }\n     public string? TargetFramework { get; }\n+    public TerminalColor TargetPrefixColor { get; } = TerminalColor.Default;\n+    public string? TargetPrefix { get; }\n     public string Target { get; }\n     public StopwatchAbstraction Stopwatch { get; }\n \n+    /// <summary>\n+    /// Status of a node that is currently doing work.\n+    /// </summary>\n+    /// <param name=\"project\">The project that is written on left side.</param>\n+    /// <param name=\"targetFramework\">Target framework that is colorized and written on left side after project.</param>\n+    /// <param name=\"target\">The currently running work, usually the currently running target. Written on right.</param>\n+    /// <param name=\"stopwatch\">Duration of the current step. Written on right after target.</param>\n     public NodeStatus(string project, string? targetFramework, string target, StopwatchAbstraction stopwatch)\n+    {\n+        Debug.Assert(!target.Contains(\"\\x1B\"), \"Target should not contain any escape codes, if you want to colorize target use the other constructor.\");\n+        Project = project;\n+        TargetFramework = targetFramework;\n+        Target = target;\n+        Stopwatch = stopwatch;\n+    }\n+\n+    /// <summary>\n+    /// Status of a node that is currently doing work.\n+    /// </summary>\n+    /// <param name=\"project\">The project that is written on left side.</param>\n+    /// <param name=\"targetFramework\">Target framework that is colorized and written on left side after project.</param>\n+    /// <param name=\"targetPrefixColor\">Color for the status of the currently running work written on right.</param>\n+    /// <param name=\"targetPrefix\">Colorized status for the currently running work, written on right, before target, and separated by 1 space from it.</param>\n+    /// <param name=\"target\">The currently running work, usually the currently runnig target. Written on right.</param>\n+    /// <param name=\"stopwatch\">Duration of the current step. Written on right after target.</param>\n+    public NodeStatus(string project, string? targetFramework, TerminalColor targetPrefixColor, string targetPrefix, string target, StopwatchAbstraction stopwatch)",
              "author": {
                "login": "nohwnd"
              }
            },
            {
              "body": "NIT: Please consider calling the other constructor by  `: this()` . There already is that `if (target.Contains(\"\\x1B\"))` debug assertions which is missed in this constructor\r\n",
              "createdAt": "2024-02-19T12:05:48Z",
              "path": "src/MSBuild/TerminalLogger/NodeStatus.cs",
              "diffHunk": "@@ -13,13 +13,42 @@ internal class NodeStatus\n {\n     public string Project { get; }\n     public string? TargetFramework { get; }\n+    public TerminalColor TargetPrefixColor { get; } = TerminalColor.Default;\n+    public string? TargetPrefix { get; }\n     public string Target { get; }\n     public StopwatchAbstraction Stopwatch { get; }\n \n+    /// <summary>\n+    /// Status of a node that is currently doing work.\n+    /// </summary>\n+    /// <param name=\"project\">The project that is written on left side.</param>\n+    /// <param name=\"targetFramework\">Target framework that is colorized and written on left side after project.</param>\n+    /// <param name=\"target\">The currently running work, usually the currently running target. Written on right.</param>\n+    /// <param name=\"stopwatch\">Duration of the current step. Written on right after target.</param>\n     public NodeStatus(string project, string? targetFramework, string target, StopwatchAbstraction stopwatch)\n+    {\n+        Debug.Assert(!target.Contains(\"\\x1B\"), \"Target should not contain any escape codes, if you want to colorize target use the other constructor.\");\n+        Project = project;\n+        TargetFramework = targetFramework;\n+        Target = target;\n+        Stopwatch = stopwatch;\n+    }\n+\n+    /// <summary>\n+    /// Status of a node that is currently doing work.\n+    /// </summary>\n+    /// <param name=\"project\">The project that is written on left side.</param>\n+    /// <param name=\"targetFramework\">Target framework that is colorized and written on left side after project.</param>\n+    /// <param name=\"targetPrefixColor\">Color for the status of the currently running work written on right.</param>\n+    /// <param name=\"targetPrefix\">Colorized status for the currently running work, written on right, before target, and separated by 1 space from it.</param>\n+    /// <param name=\"target\">The currently running work, usually the currently runnig target. Written on right.</param>\n+    /// <param name=\"stopwatch\">Duration of the current step. Written on right after target.</param>\n+    public NodeStatus(string project, string? targetFramework, TerminalColor targetPrefixColor, string targetPrefix, string target, StopwatchAbstraction stopwatch)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "done",
              "createdAt": "2024-02-19T12:50:40Z",
              "path": "src/MSBuild/TerminalLogger/NodeStatus.cs",
              "diffHunk": "@@ -13,13 +13,42 @@ internal class NodeStatus\n {\n     public string Project { get; }\n     public string? TargetFramework { get; }\n+    public TerminalColor TargetPrefixColor { get; } = TerminalColor.Default;\n+    public string? TargetPrefix { get; }\n     public string Target { get; }\n     public StopwatchAbstraction Stopwatch { get; }\n \n+    /// <summary>\n+    /// Status of a node that is currently doing work.\n+    /// </summary>\n+    /// <param name=\"project\">The project that is written on left side.</param>\n+    /// <param name=\"targetFramework\">Target framework that is colorized and written on left side after project.</param>\n+    /// <param name=\"target\">The currently running work, usually the currently running target. Written on right.</param>\n+    /// <param name=\"stopwatch\">Duration of the current step. Written on right after target.</param>\n     public NodeStatus(string project, string? targetFramework, string target, StopwatchAbstraction stopwatch)\n+    {\n+        Debug.Assert(!target.Contains(\"\\x1B\"), \"Target should not contain any escape codes, if you want to colorize target use the other constructor.\");\n+        Project = project;\n+        TargetFramework = targetFramework;\n+        Target = target;\n+        Stopwatch = stopwatch;\n+    }\n+\n+    /// <summary>\n+    /// Status of a node that is currently doing work.\n+    /// </summary>\n+    /// <param name=\"project\">The project that is written on left side.</param>\n+    /// <param name=\"targetFramework\">Target framework that is colorized and written on left side after project.</param>\n+    /// <param name=\"targetPrefixColor\">Color for the status of the currently running work written on right.</param>\n+    /// <param name=\"targetPrefix\">Colorized status for the currently running work, written on right, before target, and separated by 1 space from it.</param>\n+    /// <param name=\"target\">The currently running work, usually the currently runnig target. Written on right.</param>\n+    /// <param name=\"stopwatch\">Duration of the current step. Written on right after target.</param>\n+    public NodeStatus(string project, string? targetFramework, TerminalColor targetPrefixColor, string targetPrefix, string target, StopwatchAbstraction stopwatch)",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        // This is testing a Debug.Assert, which won't throw in Release mode.\r\n        Func<NodeStatus> newNodeStatus = () => new NodeStatus(\"project\", \"tfm\", AnsiCodes.Colorize(\"colorized target\", TerminalColor.Green), new MockStopwatch());\r\n```",
              "createdAt": "2024-02-16T08:06:26Z",
              "path": "src/MSBuild.UnitTests/NodeStatus_Transition_Tests.cs",
              "diffHunk": "@@ -0,0 +1,180 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Text.RegularExpressions;\n+using System.Threading.Tasks;\n+\n+using Microsoft.Build.Logging.TerminalLogger;\n+using Shouldly;\n+using VerifyTests;\n+using VerifyXunit;\n+using Xunit;\n+\n+using static VerifyXunit.Verifier;\n+\n+\n+namespace Microsoft.Build.CommandLine.UnitTests;\n+\n+[UsesVerify]\n+public class NodeStatus_Transition_Tests\n+{\n+    public NodeStatus_Transition_Tests()\n+    {\n+        UseProjectRelativeDirectory(\"Snapshots\");\n+    }\n+\n+    [Fact]\n+    public void NodeStatusTargetThrowsForInputWithAnsi()\n+    {\n+#if DEBUG\n+        Func<NodeStatus> newNodeStatus = () => new NodeStatus(\"project\", \"tfm\", AnsiCodes.Colorize(\"colorized target\", TerminalColor.Green), new MockStopwatch());",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n```",
              "createdAt": "2024-02-16T08:07:44Z",
              "path": "src/Framework/Logging/AnsiCodes.cs",
              "diffHunk": "@@ -1,6 +1,7 @@\n \ufeff// Licensed to the .NET Foundation under one or more agreements.\n // The .NET Foundation licenses this file to you under the MIT license.\n ",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: Are those two new using needed?",
              "createdAt": "2024-02-19T10:13:25Z",
              "path": "src/MSBuild.UnitTests/NodeStatus_SizeChange_Tests.cs",
              "diffHunk": "@@ -3,8 +3,10 @@\n \n using System;\n using System.Collections.Generic;\n+using System.IO;\n using System.Linq;\n using System.Text;\n+using System.Text.RegularExpressions;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "no, removed",
              "createdAt": "2024-02-19T12:49:19Z",
              "path": "src/MSBuild.UnitTests/NodeStatus_SizeChange_Tests.cs",
              "diffHunk": "@@ -3,8 +3,10 @@\n \n using System;\n using System.Collections.Generic;\n+using System.IO;\n using System.Linq;\n using System.Text;\n+using System.Text.RegularExpressions;",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: Please consider to use `Debug.Assert` instead. I believe it is more consistent with our code base",
              "createdAt": "2024-02-19T12:05:23Z",
              "path": "src/MSBuild/TerminalLogger/NodeStatus.cs",
              "diffHunk": "@@ -13,13 +14,47 @@ internal class NodeStatus\n {\n     public string Project { get; }\n     public string? TargetFramework { get; }\n+    public TerminalColor TargetPrefixColor { get; } = TerminalColor.Default;\n+    public string? TargetPrefix { get; }\n     public string Target { get; }\n     public StopwatchAbstraction Stopwatch { get; }\n \n+    /// <summary>\n+    /// Status of a node that is currently doing work.\n+    /// </summary>\n+    /// <param name=\"project\">The project that is written on left side.</param>\n+    /// <param name=\"targetFramework\">Target framework that is colorized and written on left side after project.</param>\n+    /// <param name=\"target\">The currently running work, usually the currently running target. Written on right.</param>\n+    /// <param name=\"stopwatch\">Duration of the current step. Written on right after target.</param>\n     public NodeStatus(string project, string? targetFramework, string target, StopwatchAbstraction stopwatch)\n+    {\n+#if DEBUG",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I did in the past, but it will show a pop-up dialog in tests and block test execution when running in VS. And the test result depends on which button you click in the Assert UI.",
              "createdAt": "2024-02-19T12:45:23Z",
              "path": "src/MSBuild/TerminalLogger/NodeStatus.cs",
              "diffHunk": "@@ -13,13 +14,47 @@ internal class NodeStatus\n {\n     public string Project { get; }\n     public string? TargetFramework { get; }\n+    public TerminalColor TargetPrefixColor { get; } = TerminalColor.Default;\n+    public string? TargetPrefix { get; }\n     public string Target { get; }\n     public StopwatchAbstraction Stopwatch { get; }\n \n+    /// <summary>\n+    /// Status of a node that is currently doing work.\n+    /// </summary>\n+    /// <param name=\"project\">The project that is written on left side.</param>\n+    /// <param name=\"targetFramework\">Target framework that is colorized and written on left side after project.</param>\n+    /// <param name=\"target\">The currently running work, usually the currently running target. Written on right.</param>\n+    /// <param name=\"stopwatch\">Duration of the current step. Written on right after target.</param>\n     public NodeStatus(string project, string? targetFramework, string target, StopwatchAbstraction stopwatch)\n+    {\n+#if DEBUG",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\ud83d\udc4d ",
              "createdAt": "2024-02-19T12:23:19Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -556,25 +644,78 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)\n         string? message = e.Message;\n         if (message is not null && e.Importance == MessageImportance.High)\n         {\n+            var hasProject = _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project);\n             // Detect project output path by matching high-importance messages against the \"$(MSBuildProjectName) -> ...\"\n             // pattern used by the CopyFilesToOutputDirectory target.\n             int index = message.IndexOf(FilePathPattern, StringComparison.Ordinal);\n             if (index > 0)\n             {\n                 var projectFileName = Path.GetFileName(e.ProjectFile.AsSpan());\n                 if (!projectFileName.IsEmpty &&\n-                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) &&\n-                    _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))\n+                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) && hasProject)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I suppose this is just to shush imperfect possible null warnings check, as it can never be null here, right?",
              "createdAt": "2024-02-19T12:27:09Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -556,25 +644,78 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)\n         string? message = e.Message;\n         if (message is not null && e.Importance == MessageImportance.High)\n         {\n+            var hasProject = _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project);\n             // Detect project output path by matching high-importance messages against the \"$(MSBuildProjectName) -> ...\"\n             // pattern used by the CopyFilesToOutputDirectory target.\n             int index = message.IndexOf(FilePathPattern, StringComparison.Ordinal);\n             if (index > 0)\n             {\n                 var projectFileName = Path.GetFileName(e.ProjectFile.AsSpan());\n                 if (!projectFileName.IsEmpty &&\n-                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) &&\n-                    _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))\n+                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) && hasProject)\n                 {\n                     ReadOnlyMemory<char> outputPath = e.Message.AsMemory().Slice(index + 4);\n-                    project.OutputPath = outputPath;\n+                    project!.OutputPath = outputPath;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Yes.",
              "createdAt": "2024-02-19T12:46:22Z",
              "path": "src/MSBuild/TerminalLogger/TerminalLogger.cs",
              "diffHunk": "@@ -556,25 +644,78 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)\n         string? message = e.Message;\n         if (message is not null && e.Importance == MessageImportance.High)\n         {\n+            var hasProject = _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project);\n             // Detect project output path by matching high-importance messages against the \"$(MSBuildProjectName) -> ...\"\n             // pattern used by the CopyFilesToOutputDirectory target.\n             int index = message.IndexOf(FilePathPattern, StringComparison.Ordinal);\n             if (index > 0)\n             {\n                 var projectFileName = Path.GetFileName(e.ProjectFile.AsSpan());\n                 if (!projectFileName.IsEmpty &&\n-                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) &&\n-                    _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))\n+                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) && hasProject)\n                 {\n                     ReadOnlyMemory<char> outputPath = e.Message.AsMemory().Slice(index + 4);\n-                    project.OutputPath = outputPath;\n+                    project!.OutputPath = outputPath;",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: We are trying to minimize setters abundance. Please consider using `readonly record struct TestSummary(int Totall, ...);`",
              "createdAt": "2024-02-19T12:35:18Z",
              "path": "src/MSBuild/TerminalLogger/TestSummary.cs",
              "diffHunk": "@@ -0,0 +1,15 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Logging.TerminalLogger\n+{\n+    internal class TestSummary",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "done",
              "createdAt": "2024-02-19T12:55:24Z",
              "path": "src/MSBuild/TerminalLogger/TestSummary.cs",
              "diffHunk": "@@ -0,0 +1,15 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Logging.TerminalLogger\n+{\n+    internal class TestSummary",
              "author": {
                "login": "nohwnd"
              }
            }
          ]
        }
      }
    ]
  }
}