{
  "number": 7513,
  "title": "Parallelize Node Spawning",
  "body": "Fixes #7379\r\n\r\n### Context\r\nMSBuild builds with Out Of Proc nodes which requires spawning processes.  Each node takes time to spawn and is serial.  This can lead to a slow start on machine with many cores.  \r\n\r\n### Changes Made\r\nParallelize Node spawn.\r\nChanged interface in `INodeProvider` to specify number of nodes to be created and let particular implementation of `INodeProvider` decide if it does it concurrently. This way the scope of thread safety is limited and manageable.\r\n\r\nI tried to keep current logic as much in tact as possible. For example old logic allowed to call `INodeManager` to spawn multiple in-proc nodes but then it fails anyway. That does not make much sense to me, and if we want to address it please let me know.\r\n\r\n### Testing\r\nVarious manual testing including scenarios with TaskHost.\r\n\r\n### Notes\r\nWhen nodereuse and nodes are still running the difference is not significant about 20ms per node as connecting to existing processes is quite fast.\r\nIn cold scenarios, either /nr=false or nodes have had terminated after 15 minutes of idling, the difference is 150ms per node.\r\nSo on my 24 cores machine, incremental building of orchard code in cold scenario were about 20% faster, in hot scenarios (reusing still running nodes) about 4% faster.\r\n\r\n",
  "state": "MERGED",
  "createdAt": "2022-04-02T00:16:16Z",
  "updatedAt": "2024-02-22T22:28:30Z",
  "closedAt": "2022-04-25T17:14:39Z",
  "mergedAt": "2022-04-25T17:14:38Z",
  "additions": 328,
  "deletions": 234,
  "changedFiles": 11,
  "headRefName": "dev/yuehuang/main_parallelspawn",
  "isDraft": false,
  "author": {
    "login": "yuehuang010"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "rokonec"
      }
    ]
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "7324358f78bfe43387940860f9d4fe91ce3401ae",
          "message": "Parallelize Node Spawning",
          "committedDate": "2022-04-02T00:11:24Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6626ac2dbc62cd1f2c46bb763a245f655bf108d3",
          "message": "Fix concurrent bugs.",
          "committedDate": "2022-04-09T20:19:59Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "413aac6e746474d8f5e887f60c52e2d090fe01df",
          "message": "Concurrent spawn also for nodereuse builds",
          "committedDate": "2022-04-13T11:04:42Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "77e00d09f7f437faa4a5613e6ff80cc023473e37",
          "message": "Self code review changes.",
          "committedDate": "2022-04-13T11:59:33Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "01c87bad2ef8d4a6bf72dec03bf7a79a994e0c50",
          "message": "Self code review changes.",
          "committedDate": "2022-04-13T12:00:43Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9baaaf3abf6ccd22031c9a9f95a5bec065f0bc23",
          "message": "Conflict",
          "committedDate": "2022-04-13T12:01:54Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0f0270f03caba7776ba364b95b6ea3cfe966979e",
          "message": "Remove duplicate error check",
          "committedDate": "2022-04-14T18:24:31Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ee8eeb4f13c0bcfd0d63f5fe6b0d7f223735b991",
          "message": "Addressing review comments, Nathan #1",
          "committedDate": "2022-04-14T19:28:45Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "755eaf4ef96b6f7c81aefcb9278846c010b9b373",
          "message": "Fix error with unacessable StartInfo",
          "committedDate": "2022-04-14T21:40:35Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ebed29413830b597548d01d6e5f757c6e85bf898",
          "message": "Apply suggestions from code review. Rainer #1\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2022-04-18T18:29:05Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0439b04f16cd4667fe9dd37d17b0b65e19892783",
          "message": "Merge branch 'main' into dev/yuehuang/main_parallelspawn",
          "committedDate": "2022-04-20T21:14:38Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "292cee40ab84e374571ac2cd64e5e1676b05f539",
          "message": "Update src/Build/BackEnd/Components/Communications/INodeProvider.cs",
          "committedDate": "2022-04-20T21:25:38Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dfaef8b3c7bd5badb346905c9bd3b067c6d28976",
          "message": "Update src/Build/BackEnd/Components/Communications/NodeManager.cs",
          "committedDate": "2022-04-20T21:25:45Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b06e8905149f8c01f5541cf688f731d006d65a37",
          "message": "Update src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs",
          "committedDate": "2022-04-20T21:25:51Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "03b6f32e4382c84ba4e981c4d93aaf428e42777e",
          "message": "Update src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs",
          "committedDate": "2022-04-20T21:26:25Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b4a684a11c6f0e7ed26f0e44b6715774320c2114",
          "message": "fix null check",
          "committedDate": "2022-04-20T22:43:47Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "52ad1a908292103311f1127035e693f2a16d5154",
          "message": "Update src/Build/BackEnd/Components/Communications/NodeManager.cs",
          "committedDate": "2022-04-21T03:08:30Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cf144b3ffdac39147e0d164520f68fb56009f20a",
          "message": "Nullability warnings",
          "committedDate": "2022-04-21T07:15:02Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I'm wondering about making this work for situations with node reuse. Maybe worth trying to connect to some, and if you run out of nodes to connect to, make the rest in parallel?",
        "createdAt": "2022-04-02T18:16:14Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> I'm wondering about making this work for situations with node reuse. Maybe worth trying to connect to some, and if you run out of nodes to connect to, make the rest in parallel?\r\n\r\nIdeally, Yes.  However, that would require more refactoring than I am comfortable with.  Node reuse when \"reusing\" is already fast.    Plus, the risk and reward is lower.  ",
        "createdAt": "2022-04-02T20:09:27Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "Earlier work:\r\nhttps://github.com/dotnet/msbuild/pull/4905",
        "createdAt": "2022-04-04T15:34:45Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "It was reworked and it now support also `node reuse` scenarios.",
        "createdAt": "2022-04-13T12:46:10Z",
        "author": {
          "login": "rokonec"
        }
      },
      {
        "body": "Yes, I am super happy!",
        "createdAt": "2022-04-22T22:49:00Z",
        "author": {
          "login": "yuehuang010"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we move any of this into the parallel part? Make it a helper function?",
              "createdAt": "2022-04-02T18:07:32Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2602,17 +2602,29 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n                         break;\n \n                     case ScheduleActionType.CreateNode:\n-                        var newNodes = new List<NodeInfo>();\n+                        var newNodes = new NodeInfo[response.NumberOfNodesToCreate];\n+                        var nodeConfig = GetNodeConfiguration();\n+\n+                        // Parallelize node spawning if OOP and NodeReuse is not enabled.\n+                        if (response.RequiredNodeType == NodeAffinity.OutOfProc && !_buildParameters.EnableNodeReuse)\n+                        {\n+                            Parallel.For(0, response.NumberOfNodesToCreate, (i) =>\n+                            {\n+                                newNodes[i] = _nodeManager.CreateNode(nodeConfig, response.RequiredNodeType);\n+                            });\n+                        }\n \n                         for (int i = 0; i < response.NumberOfNodesToCreate; i++)\n                         {\n-                            NodeInfo createdNode = _nodeManager.CreateNode(GetNodeConfiguration(), response.RequiredNodeType);\n+                            if (response.RequiredNodeType != NodeAffinity.OutOfProc || _buildParameters.EnableNodeReuse)\n+                            {\n+                                newNodes[i] = _nodeManager.CreateNode(nodeConfig, response.RequiredNodeType);\n+                            }\n \n-                            if (createdNode != null)\n+                            if (newNodes[i] != null)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "No need.  The results are just added to final data structure and is thus fast.  Trying to make this parallel safe is more refactoring and risk.",
              "createdAt": "2022-04-02T20:04:05Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2602,17 +2602,29 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n                         break;\n \n                     case ScheduleActionType.CreateNode:\n-                        var newNodes = new List<NodeInfo>();\n+                        var newNodes = new NodeInfo[response.NumberOfNodesToCreate];\n+                        var nodeConfig = GetNodeConfiguration();\n+\n+                        // Parallelize node spawning if OOP and NodeReuse is not enabled.\n+                        if (response.RequiredNodeType == NodeAffinity.OutOfProc && !_buildParameters.EnableNodeReuse)\n+                        {\n+                            Parallel.For(0, response.NumberOfNodesToCreate, (i) =>\n+                            {\n+                                newNodes[i] = _nodeManager.CreateNode(nodeConfig, response.RequiredNodeType);\n+                            });\n+                        }\n \n                         for (int i = 0; i < response.NumberOfNodesToCreate; i++)\n                         {\n-                            NodeInfo createdNode = _nodeManager.CreateNode(GetNodeConfiguration(), response.RequiredNodeType);\n+                            if (response.RequiredNodeType != NodeAffinity.OutOfProc || _buildParameters.EnableNodeReuse)\n+                            {\n+                                newNodes[i] = _nodeManager.CreateNode(nodeConfig, response.RequiredNodeType);\n+                            }\n \n-                            if (createdNode != null)\n+                            if (newNodes[i] != null)",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this important for the change?",
              "createdAt": "2022-04-02T18:12:55Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -275,7 +275,10 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n \n                 // Create the node process\n                 Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);\n-                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id));\n+                if (_componentHost.BuildParameters.EnableNodeReuse)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I couldn't prove it, but document says Hashset is not threadsafe.",
              "createdAt": "2022-04-02T19:53:01Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -275,7 +275,10 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n \n                 // Create the node process\n                 Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);\n-                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id));\n+                if (_componentHost.BuildParameters.EnableNodeReuse)",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since I can't comment unchanged line I comment it here:\r\nLine: https://github.com/dotnet/msbuild/blob/7324358f78bfe43387940860f9d4fe91ce3401ae/src/Build/BackEnd/Components/Communications/NodeManager.cs#L347 is not safe as _nodeIdToProvider is non thread safe collection `Dictionary`. Please consider to change it into `ConcurrentDictionary` and `TryAdd; TryRemove`.",
              "createdAt": "2022-04-06T18:14:06Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -329,8 +330,7 @@ private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration node\n             }\n             else\n             {\n-                nodeId = _nextNodeId;\n-                _nextNodeId++;\n+                nodeId = Interlocked.Increment(ref _nextNodeId) - 1;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since I can't comment unchanged line I am commenting it here:\r\nhttps://github.com/dotnet/msbuild/blob/7324358f78bfe43387940860f9d4fe91ce3401ae/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs#L82\r\nand\r\nhttps://github.com/dotnet/msbuild/blob/7324358f78bfe43387940860f9d4fe91ce3401ae/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs#L102\r\nAre using non thread safe `Dictionary`.\r\nPlease consider to switch it into `ConcurrentDictionary`.\r\nAlso https://github.com/dotnet/msbuild/blob/7324358f78bfe43387940860f9d4fe91ce3401ae/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs#L82\r\nis wrong check in concurrent scenario as it will be mostly miss because all node creation threads will get past this check and be doing time consuming node creation at line 98 and only after they will add to `_nodeContext`. I recommend to put `_nodeContexts[nodeId] = null` before line 82 to set count to expected value after and change condition at line 82 from `>=` to `>`.\r\n",
              "createdAt": "2022-04-06T18:41:38Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -275,7 +275,10 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n \n                 // Create the node process\n                 Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);\n-                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id));\n+                if (_componentHost.BuildParameters.EnableNodeReuse)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`_processesToIgnore` is important perf optimization. It is hard to rationalize if this conditional adding might have some perf impact as I do not know all VS usage patterns.\r\nI recommend to change it from `HashSet` to `ConcurrentDictionary<string, /*void*/ byte>` and remove this condition.",
              "createdAt": "2022-04-06T18:49:42Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -275,7 +275,10 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n \n                 // Create the node process\n                 Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);\n-                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id));\n+                if (_componentHost.BuildParameters.EnableNodeReuse)\n+                {\n+                    _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id));",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "> Please fix those few concurrency bugs I have mentioned in comments.\r\n> \r\n> Why is this change isolated to `/nr:false` path only? Since `nodeReuse` is on by default, we are missing a big customer segment with this optimization.\r\n\r\nI have tried those changes and hit threading issues, so I have scoped down the feature to /nr:false.  Our development environment has /nr:false in the build scripts so to us, it is the default.  @Forgind PR #4905 is more comprehensive to address nodeReuse.",
              "createdAt": "2022-04-06T19:50:52Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -275,7 +275,10 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n \n                 // Create the node process\n                 Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);\n-                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id));\n+                if (_componentHost.BuildParameters.EnableNodeReuse)\n+                {\n+                    _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id));",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could there be a case where multiple requester ask for max nodes, but only a subset would spawn?",
              "createdAt": "2022-04-13T18:16:52Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2602,27 +2602,22 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n                         break;\n \n                     case ScheduleActionType.CreateNode:\n-                        var newNodes = new List<NodeInfo>();\n+                        IList<NodeInfo> newNodes = _nodeManager.CreateNodes(GetNodeConfiguration(), response.RequiredNodeType, response.NumberOfNodesToCreate);\n \n-                        for (int i = 0; i < response.NumberOfNodesToCreate; i++)\n+                        if (newNodes?.Count != response.NumberOfNodesToCreate || newNodes.Any(n => n == null))",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "In previous code, when it was called in for loop, if any of loop iteration had failed to acquire node, whole build have had failed on `BuildAbortedException`. From this I have drawn logical conclusion that if not all nodes are crated new code is supposed to fail the same way.",
              "createdAt": "2022-04-13T18:57:06Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2602,27 +2602,22 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n                         break;\n \n                     case ScheduleActionType.CreateNode:\n-                        var newNodes = new List<NodeInfo>();\n+                        IList<NodeInfo> newNodes = _nodeManager.CreateNodes(GetNodeConfiguration(), response.RequiredNodeType, response.NumberOfNodesToCreate);\n \n-                        for (int i = 0; i < response.NumberOfNodesToCreate; i++)\n+                        if (newNodes?.Count != response.NumberOfNodesToCreate || newNodes.Any(n => n == null))",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This feels like a very unnecessary check to me\u2014we already verified that the number of nodes in newNodes is equal to the number requested, so for this to fail, we'd have a for loop failing, Add failing, or they only requested 0 nodes. The first two are extreme enough that a build failure isn't an issue, and the third seems like it should've been noticed well before this point. (I recognize it was already there, so I don't mind if you want to leave it.)",
              "createdAt": "2022-04-13T23:35:11Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2602,27 +2602,22 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n                         break;\n \n                     case ScheduleActionType.CreateNode:\n-                        var newNodes = new List<NodeInfo>();\n+                        IList<NodeInfo> newNodes = _nodeManager.CreateNodes(GetNodeConfiguration(), response.RequiredNodeType, response.NumberOfNodesToCreate);\n \n-                        for (int i = 0; i < response.NumberOfNodesToCreate; i++)\n+                        if (newNodes?.Count != response.NumberOfNodesToCreate || newNodes.Any(n => n == null))\n                         {\n-                            NodeInfo createdNode = _nodeManager.CreateNode(GetNodeConfiguration(), response.RequiredNodeType);\n+                            BuildEventContext buildEventContext = new BuildEventContext(0, Scheduler.VirtualNode, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);\n+                            ((IBuildComponentHost)this).LoggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty), \"UnableToCreateNode\", response.RequiredNodeType.ToString(\"G\"));\n \n-                            if (createdNode != null)\n-                            {\n-                                _noNodesActiveEvent.Reset();\n-                                _activeNodes.Add(createdNode.NodeId);\n-                                newNodes.Add(createdNode);\n-                                ErrorUtilities.VerifyThrow(_activeNodes.Count != 0, \"Still 0 nodes after asking for a new node.  Build cannot proceed.\");\n-                            }\n-                            else\n-                            {\n-                                BuildEventContext buildEventContext = new BuildEventContext(0, Scheduler.VirtualNode, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);\n-                                ((IBuildComponentHost)this).LoggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty), \"UnableToCreateNode\", response.RequiredNodeType.ToString(\"G\"));\n+                            throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"UnableToCreateNode\", response.RequiredNodeType.ToString(\"G\")));\n+                        }\n \n-                                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"UnableToCreateNode\", response.RequiredNodeType.ToString(\"G\")));\n-                            }\n+                        foreach (var node in newNodes)\n+                        {\n+                            _noNodesActiveEvent.Reset();\n+                            _activeNodes.Add(node.NodeId);\n                         }\n+                        ErrorUtilities.VerifyThrow(_activeNodes.Count != 0, \"Still 0 nodes after asking for a new node.  Build cannot proceed.\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I was strictly following logic of former code. Check former line 2616. There is a test even though couple of lines above we add to the tested collection so it is guaranteed that test be always true.\r\nIn my code this line will could possible throw if `NumberOfNodesToCreate` == 0. \r\nBut it is nonsense. I will remove it.",
              "createdAt": "2022-04-14T08:01:02Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2602,27 +2602,22 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n                         break;\n \n                     case ScheduleActionType.CreateNode:\n-                        var newNodes = new List<NodeInfo>();\n+                        IList<NodeInfo> newNodes = _nodeManager.CreateNodes(GetNodeConfiguration(), response.RequiredNodeType, response.NumberOfNodesToCreate);\n \n-                        for (int i = 0; i < response.NumberOfNodesToCreate; i++)\n+                        if (newNodes?.Count != response.NumberOfNodesToCreate || newNodes.Any(n => n == null))\n                         {\n-                            NodeInfo createdNode = _nodeManager.CreateNode(GetNodeConfiguration(), response.RequiredNodeType);\n+                            BuildEventContext buildEventContext = new BuildEventContext(0, Scheduler.VirtualNode, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);\n+                            ((IBuildComponentHost)this).LoggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty), \"UnableToCreateNode\", response.RequiredNodeType.ToString(\"G\"));\n \n-                            if (createdNode != null)\n-                            {\n-                                _noNodesActiveEvent.Reset();\n-                                _activeNodes.Add(createdNode.NodeId);\n-                                newNodes.Add(createdNode);\n-                                ErrorUtilities.VerifyThrow(_activeNodes.Count != 0, \"Still 0 nodes after asking for a new node.  Build cannot proceed.\");\n-                            }\n-                            else\n-                            {\n-                                BuildEventContext buildEventContext = new BuildEventContext(0, Scheduler.VirtualNode, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);\n-                                ((IBuildComponentHost)this).LoggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty), \"UnableToCreateNode\", response.RequiredNodeType.ToString(\"G\"));\n+                            throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"UnableToCreateNode\", response.RequiredNodeType.ToString(\"G\")));\n+                        }\n \n-                                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"UnableToCreateNode\", response.RequiredNodeType.ToString(\"G\")));\n-                            }\n+                        foreach (var node in newNodes)\n+                        {\n+                            _noNodesActiveEvent.Reset();\n+                            _activeNodes.Add(node.NodeId);\n                         }\n+                        ErrorUtilities.VerifyThrow(_activeNodes.Count != 0, \"Still 0 nodes after asking for a new node.  Build cannot proceed.\");",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This only ever produces at most one node, right?",
              "createdAt": "2022-04-13T23:37:16Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -92,32 +86,31 @@ private NodeManager()\n         /// </summary>\n         /// <param name=\"configuration\">The configuration to use for the remote node.</param>\n         /// <param name=\"nodeAffinity\">The <see cref=\"NodeAffinity\"/> to use.</param>\n+        /// <param name=\"numberOfNodesToCreate\">Number of nodes to be reused ot created.</param>\n         /// <returns>A NodeInfo describing the node created, or null if none could be created.</returns>\n-        public NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAffinity)\n+        public IList<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity nodeAffinity, int numberOfNodesToCreate)\n         {\n             // We will prefer to make nodes on the \"closest\" providers first; in-proc, then\n             // out-of-proc, then remote.\n             // When we support distributed build, we will also consider the remote provider.\n-            int nodeId = InvalidNodeId;\n-            if ((nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.InProc) && !_componentHost.BuildParameters.DisableInProcNode)\n+            List<NodeInfo> nodes = new();\n+            if ((nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.InProc) && !_componentHost!.BuildParameters.DisableInProcNode)\n             {\n-                nodeId = AttemptCreateNode(_inProcNodeProvider, configuration);\n+                nodes.AddRange(AttemptCreateNode(_inProcNodeProvider!, configuration, numberOfNodesToCreate));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes. In current implementation it does. However I wanted to make this method to be agnostic to the current rule `only-on-inproc-node`.  Since `AttemptCreateNode` uses passed `INodeProvider` which now supports multiple node creation, this code seems to be both readable and future proof.",
              "createdAt": "2022-04-14T18:34:53Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -92,32 +86,31 @@ private NodeManager()\n         /// </summary>\n         /// <param name=\"configuration\">The configuration to use for the remote node.</param>\n         /// <param name=\"nodeAffinity\">The <see cref=\"NodeAffinity\"/> to use.</param>\n+        /// <param name=\"numberOfNodesToCreate\">Number of nodes to be reused ot created.</param>\n         /// <returns>A NodeInfo describing the node created, or null if none could be created.</returns>\n-        public NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAffinity)\n+        public IList<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity nodeAffinity, int numberOfNodesToCreate)\n         {\n             // We will prefer to make nodes on the \"closest\" providers first; in-proc, then\n             // out-of-proc, then remote.\n             // When we support distributed build, we will also consider the remote provider.\n-            int nodeId = InvalidNodeId;\n-            if ((nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.InProc) && !_componentHost.BuildParameters.DisableInProcNode)\n+            List<NodeInfo> nodes = new();\n+            if ((nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.InProc) && !_componentHost!.BuildParameters.DisableInProcNode)\n             {\n-                nodeId = AttemptCreateNode(_inProcNodeProvider, configuration);\n+                nodes.AddRange(AttemptCreateNode(_inProcNodeProvider!, configuration, numberOfNodesToCreate));",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "newNodes is never null here, right? Do you need the null check, or is it just there in case something unexpected happens?",
              "createdAt": "2022-04-13T23:39:36Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2602,27 +2602,22 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n                         break;\n \n                     case ScheduleActionType.CreateNode:\n-                        var newNodes = new List<NodeInfo>();\n+                        IList<NodeInfo> newNodes = _nodeManager.CreateNodes(GetNodeConfiguration(), response.RequiredNodeType, response.NumberOfNodesToCreate);\n \n-                        for (int i = 0; i < response.NumberOfNodesToCreate; i++)\n+                        if (newNodes?.Count != response.NumberOfNodesToCreate || newNodes.Any(n => n == null))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It is not supposed to be null on current code state. It is there however to cover possible future deviation/bug in code.",
              "createdAt": "2022-04-14T07:56:33Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2602,27 +2602,22 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)\n                         break;\n \n                     case ScheduleActionType.CreateNode:\n-                        var newNodes = new List<NodeInfo>();\n+                        IList<NodeInfo> newNodes = _nodeManager.CreateNodes(GetNodeConfiguration(), response.RequiredNodeType, response.NumberOfNodesToCreate);\n \n-                        for (int i = 0; i < response.NumberOfNodesToCreate; i++)\n+                        if (newNodes?.Count != response.NumberOfNodesToCreate || newNodes.Any(n => n == null))",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "host is already non-null, right?",
              "createdAt": "2022-04-13T23:40:27Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -176,7 +169,7 @@ public void InitializeComponent(IBuildComponentHost host)\n         {\n             ErrorUtilities.VerifyThrow(_componentHost == null, \"NodeManager already initialized.\");\n             ErrorUtilities.VerifyThrow(host != null, \"We can't create a NodeManager with a null componentHost\");\n-            _componentHost = host;\n+            _componentHost = host!;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "For one reason or another, I was getting compiler warning here:\r\n![image](https://user-images.githubusercontent.com/25249058/163455777-5e349a81-fc49-49b4-b33a-986ff2a6d660.png)\r\nSeem to me like bug in analyzer. However, until we remove condition in:\r\n![image](https://user-images.githubusercontent.com/25249058/163455958-b17111c9-9985-4cae-a569-dc906ffae072.png)\r\nI can't take analyzer results seriously.\r\n",
              "createdAt": "2022-04-14T18:42:58Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -176,7 +169,7 @@ public void InitializeComponent(IBuildComponentHost host)\n         {\n             ErrorUtilities.VerifyThrow(_componentHost == null, \"NodeManager already initialized.\");\n             ErrorUtilities.VerifyThrow(host != null, \"We can't create a NodeManager with a null componentHost\");\n-            _componentHost = host;\n+            _componentHost = host!;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Gotcha and fair \ud83d\ude04 ",
              "createdAt": "2022-04-14T21:28:58Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -176,7 +169,7 @@ public void InitializeComponent(IBuildComponentHost host)\n         {\n             ErrorUtilities.VerifyThrow(_componentHost == null, \"NodeManager already initialized.\");\n             ErrorUtilities.VerifyThrow(host != null, \"We can't create a NodeManager with a null componentHost\");\n-            _componentHost = host;\n+            _componentHost = host!;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            CommunicationsUtilities.Trace(\"Starting to acquire {1} new or existing node(s) to establish nodes from ID {0} to {2}...\", nextNodeId, numberOfNodesToCreate, nexNodeId + numberOfNodesToCreate - 1);\r\n```",
              "createdAt": "2022-04-13T23:47:08Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs",
              "diffHunk": "@@ -73,44 +74,56 @@ internal static Handshake GetHandshake(bool enableNodeReuse, bool enableLowPrior\n         }\n \n         /// <summary>\n-        /// Instantiates a new MSBuild process acting as a child node.\n+        /// Instantiates a new MSBuild processes acting as a child nodes or connect to existing ones.\n         /// </summary>\n-        public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)\n+        public IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory factory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));\n \n-            if (_nodeContexts.Count >= ComponentHost.BuildParameters.MaxNodeCount)\n+            // This can run concurrently. To be properly detect internal bug when we create more nodes than allowed\n+            //   we add into _nodeContexts premise of future node and verify that it will not cross limits.\n+            if (_nodeContexts.Count + numberOfNodesToCreate > ComponentHost.BuildParameters.MaxNodeCount)\n             {\n-                ErrorUtilities.ThrowInternalError(\"All allowable nodes already created ({0}).\", _nodeContexts.Count);\n-                return false;\n+                ErrorUtilities.ThrowInternalError(\"Exceeded max node count of '{0}', current count is '{1}' \", ComponentHost.BuildParameters.MaxNodeCount, _nodeContexts.Count);\n+                return new List<NodeInfo>();\n             }\n \n+            ConcurrentBag<NodeInfo> nodes = new();\n+\n             // Start the new process.  We pass in a node mode with a node number of 1, to indicate that we\n             // want to start up just a standard MSBuild out-of-proc node.\n             // Note: We need to always pass /nodeReuse to ensure the value for /nodeReuse from msbuild.rsp\n             // (next to msbuild.exe) is ignored.\n             string commandLineArgs = $\"/nologo /nodemode:1 /nodeReuse:{ComponentHost.BuildParameters.EnableNodeReuse.ToString().ToLower()} /low:{ComponentHost.BuildParameters.LowPriority.ToString().ToLower()}\";\n \n             // Make it here.\n-            CommunicationsUtilities.Trace(\"Starting to acquire a new or existing node to establish node ID {0}...\", nodeId);\n+            CommunicationsUtilities.Trace(\"Starting to acquire a new or existing {1} node(s) to establish nodes starting from ID {0}...\", nextNodeId, numberOfNodesToCreate);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we have a context != null check here?",
              "createdAt": "2022-04-13T23:50:26Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs",
              "diffHunk": "@@ -73,44 +74,56 @@ internal static Handshake GetHandshake(bool enableNodeReuse, bool enableLowPrior\n         }\n \n         /// <summary>\n-        /// Instantiates a new MSBuild process acting as a child node.\n+        /// Instantiates a new MSBuild processes acting as a child nodes or connect to existing ones.\n         /// </summary>\n-        public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)\n+        public IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory factory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));\n \n-            if (_nodeContexts.Count >= ComponentHost.BuildParameters.MaxNodeCount)\n+            // This can run concurrently. To be properly detect internal bug when we create more nodes than allowed\n+            //   we add into _nodeContexts premise of future node and verify that it will not cross limits.\n+            if (_nodeContexts.Count + numberOfNodesToCreate > ComponentHost.BuildParameters.MaxNodeCount)\n             {\n-                ErrorUtilities.ThrowInternalError(\"All allowable nodes already created ({0}).\", _nodeContexts.Count);\n-                return false;\n+                ErrorUtilities.ThrowInternalError(\"Exceeded max node count of '{0}', current count is '{1}' \", ComponentHost.BuildParameters.MaxNodeCount, _nodeContexts.Count);\n+                return new List<NodeInfo>();\n             }\n \n+            ConcurrentBag<NodeInfo> nodes = new();\n+\n             // Start the new process.  We pass in a node mode with a node number of 1, to indicate that we\n             // want to start up just a standard MSBuild out-of-proc node.\n             // Note: We need to always pass /nodeReuse to ensure the value for /nodeReuse from msbuild.rsp\n             // (next to msbuild.exe) is ignored.\n             string commandLineArgs = $\"/nologo /nodemode:1 /nodeReuse:{ComponentHost.BuildParameters.EnableNodeReuse.ToString().ToLower()} /low:{ComponentHost.BuildParameters.LowPriority.ToString().ToLower()}\";\n \n             // Make it here.\n-            CommunicationsUtilities.Trace(\"Starting to acquire a new or existing node to establish node ID {0}...\", nodeId);\n+            CommunicationsUtilities.Trace(\"Starting to acquire a new or existing {1} node(s) to establish nodes starting from ID {0}...\", nextNodeId, numberOfNodesToCreate);\n \n             Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));\n-            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandshake, NodeContextTerminated);\n \n-            if (context != null)\n+            IList<NodeContext> nodeContexts = GetNodes(null, commandLineArgs, nextNodeId, factory, hostHandshake, NodeContextCreated, NodeContextTerminated, numberOfNodesToCreate);\n+\n+            if (nodeContexts.Count > 0)\n             {\n-                _nodeContexts[nodeId] = context;\n+                return nodeContexts\n+                    .Select(nc => new NodeInfo(nc.NodeId, ProviderType))\n+                    .ToList();\n+            }\n+\n+            throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotConnectToMSBuildExe\", ComponentHost.BuildParameters.NodeExeLocation));\n+\n+            void NodeContextCreated(NodeContext context)\n+            {\n+                NodeInfo nodeInfo = new NodeInfo(context.NodeId, ProviderType);\n+\n+                _nodeContexts[context.NodeId] = context;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "After we fix some info code like ThrowInternalError and anotate it I would like to revisit those classes and turn them into nullable enable. \r\nFor now with limited scope of invoking `NodeContextCreatedDelegate`, just one place, I believe null check here would not make code any better. Maybe in future with those !! operators which hinder readability less. ",
              "createdAt": "2022-04-14T18:48:42Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs",
              "diffHunk": "@@ -73,44 +74,56 @@ internal static Handshake GetHandshake(bool enableNodeReuse, bool enableLowPrior\n         }\n \n         /// <summary>\n-        /// Instantiates a new MSBuild process acting as a child node.\n+        /// Instantiates a new MSBuild processes acting as a child nodes or connect to existing ones.\n         /// </summary>\n-        public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)\n+        public IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory factory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate)\n         {\n             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));\n \n-            if (_nodeContexts.Count >= ComponentHost.BuildParameters.MaxNodeCount)\n+            // This can run concurrently. To be properly detect internal bug when we create more nodes than allowed\n+            //   we add into _nodeContexts premise of future node and verify that it will not cross limits.\n+            if (_nodeContexts.Count + numberOfNodesToCreate > ComponentHost.BuildParameters.MaxNodeCount)\n             {\n-                ErrorUtilities.ThrowInternalError(\"All allowable nodes already created ({0}).\", _nodeContexts.Count);\n-                return false;\n+                ErrorUtilities.ThrowInternalError(\"Exceeded max node count of '{0}', current count is '{1}' \", ComponentHost.BuildParameters.MaxNodeCount, _nodeContexts.Count);\n+                return new List<NodeInfo>();\n             }\n \n+            ConcurrentBag<NodeInfo> nodes = new();\n+\n             // Start the new process.  We pass in a node mode with a node number of 1, to indicate that we\n             // want to start up just a standard MSBuild out-of-proc node.\n             // Note: We need to always pass /nodeReuse to ensure the value for /nodeReuse from msbuild.rsp\n             // (next to msbuild.exe) is ignored.\n             string commandLineArgs = $\"/nologo /nodemode:1 /nodeReuse:{ComponentHost.BuildParameters.EnableNodeReuse.ToString().ToLower()} /low:{ComponentHost.BuildParameters.LowPriority.ToString().ToLower()}\";\n \n             // Make it here.\n-            CommunicationsUtilities.Trace(\"Starting to acquire a new or existing node to establish node ID {0}...\", nodeId);\n+            CommunicationsUtilities.Trace(\"Starting to acquire a new or existing {1} node(s) to establish nodes starting from ID {0}...\", nextNodeId, numberOfNodesToCreate);\n \n             Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));\n-            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandshake, NodeContextTerminated);\n \n-            if (context != null)\n+            IList<NodeContext> nodeContexts = GetNodes(null, commandLineArgs, nextNodeId, factory, hostHandshake, NodeContextCreated, NodeContextTerminated, numberOfNodesToCreate);\n+\n+            if (nodeContexts.Count > 0)\n             {\n-                _nodeContexts[nodeId] = context;\n+                return nodeContexts\n+                    .Select(nc => new NodeInfo(nc.NodeId, ProviderType))\n+                    .ToList();\n+            }\n+\n+            throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotConnectToMSBuildExe\", ComponentHost.BuildParameters.NodeExeLocation));\n+\n+            void NodeContextCreated(NodeContext context)\n+            {\n+                NodeInfo nodeInfo = new NodeInfo(context.NodeId, ProviderType);\n+\n+                _nodeContexts[context.NodeId] = context;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe worth a comment here that TaskHosts are created as needed for tasks, hence they're created individually, and we'll never request multiple?",
              "createdAt": "2022-04-13T23:53:51Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs",
              "diffHunk": "@@ -522,30 +522,35 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor\n             CommunicationsUtilities.Trace(\"For a host context of {0}, spawning executable from {1}.\", hostContext.ToString(), msbuildLocation ?? \"MSBuild.exe\");\n \n             // Make it here.\n-            NodeContext context = GetNode\n-                                    (\n-                                        msbuildLocation,\n-                                        commandLineArgs,\n-                                        (int)hostContext,\n-                                        this,\n-                                        new Handshake(hostContext),\n-                                        NodeContextTerminated\n-                                    );\n-\n-            if (context != null)\n-            {\n-                _nodeContexts[hostContext] = context;\n+            int nodeId = (int)hostContext;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Commented...",
              "createdAt": "2022-04-14T19:20:43Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs",
              "diffHunk": "@@ -522,30 +522,35 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor\n             CommunicationsUtilities.Trace(\"For a host context of {0}, spawning executable from {1}.\", hostContext.ToString(), msbuildLocation ?? \"MSBuild.exe\");\n \n             // Make it here.\n-            NodeContext context = GetNode\n-                                    (\n-                                        msbuildLocation,\n-                                        commandLineArgs,\n-                                        (int)hostContext,\n-                                        this,\n-                                        new Handshake(hostContext),\n-                                        NodeContextTerminated\n-                                    );\n-\n-            if (context != null)\n-            {\n-                _nodeContexts[hostContext] = context;\n+            int nodeId = (int)hostContext;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nThis should probably also be indented one.",
              "createdAt": "2022-04-13T23:55:52Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -600,50 +605,56 @@ internal static void Trace(int nodeId, string format, params object[] args)\n         {\n             if (s_trace)\n             {\n-                if (s_debugDumpPath == null)\n+                lock (s_traceLock)\n                 {\n-                    s_debugDumpPath =\n+                    if (s_debugDumpPath == null)\n+                    {\n+                        s_debugDumpPath =\n #if CLR2COMPATIBILITY\n                         Environment.GetEnvironmentVariable(\"MSBUILDDEBUGPATH\");",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit:\r\nIf I counted right, this is used once as a queue and once as a list. Since you're sorting it as a list anyway, return a list and make it into a queue in the case you need a queue? Otherwise you're turning a list into a queue into a list for no reason.",
              "createdAt": "2022-04-14T00:06:39Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -323,9 +382,9 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n         /// <param name=\"msbuildLocation\"></param>\n         /// <returns>\n         /// Item 1 is the name of the process being searched for.\n-        /// Item 2 is the list of processes themselves.\n+        /// Item 2 is the ConcurrentQueue of ordered processes themselves.\n         /// </returns>\n-        private (string expectedProcessName, List<Process> nodeProcesses) GetPossibleRunningNodes(string msbuildLocation = null)\n+        private (string expectedProcessName, ConcurrentQueue<Process> nodeProcesses) GetPossibleRunningNodes(string msbuildLocation = null)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Good point. Changed.",
              "createdAt": "2022-04-14T19:14:46Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -323,9 +382,9 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n         /// <param name=\"msbuildLocation\"></param>\n         /// <returns>\n         /// Item 1 is the name of the process being searched for.\n-        /// Item 2 is the list of processes themselves.\n+        /// Item 2 is the ConcurrentQueue of ordered processes themselves.\n         /// </returns>\n-        private (string expectedProcessName, List<Process> nodeProcesses) GetPossibleRunningNodes(string msbuildLocation = null)\n+        private (string expectedProcessName, ConcurrentQueue<Process> nodeProcesses) GetPossibleRunningNodes(string msbuildLocation = null)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    CommunicationsUtilities.Trace(\"Trying to connect to existing {0} process to establish node {1}...\", expectedProcessName, nodeId);\r\n```\r\n\r\nThough this seems a bit verbose. Previously, it announced that it was trying to connect to a process once for all processes. This means it's announcing it for all the wrong processes in addition to the reasonable guesses that fail and the right guesses. That's a lot.",
              "createdAt": "2022-04-14T00:09:47Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;\n #if FEATURE_NODE_REUSE\n             // Try to connect to idle nodes if node reuse is enabled.\n             if (_componentHost.BuildParameters.EnableNodeReuse)\n             {\n-                (string expectedProcessName, List<Process> processes) runningNodesTuple = GetPossibleRunningNodes(msbuildLocation);\n+                (expectedProcessName, possibleRunningNodes) = GetPossibleRunningNodes(msbuildLocation);\n+            }\n+#endif\n+            ConcurrentQueue<NodeContext> nodeContexts = new();\n+            ConcurrentQueue<Exception> exceptions = new();\n+            Parallel.For(nextNodeId, nextNodeId + numberOfNodesToCreate, (nodeId) =>\n+            {\n+                try\n+                {\n+                    if (!TryReuseAnyFromPossibleRunningNodes(nodeId) && !StartNewNode(nodeId))\n+                    {\n+                        // We were unable to reuse or launch a node.\n+                        CommunicationsUtilities.Trace(\"FAILED TO CONNECT TO A CHILD NODE\");\n+                    }\n+                }\n+                catch (Exception ex)\n+                {\n+                    // It will be rethrown as aggregate exception\n+                    exceptions.Enqueue(ex);\n+                }\n+            });\n+            if (!exceptions.IsEmpty)\n+            {\n+                ErrorUtilities.ThrowInternalError(\"Cannot acquire required number of nodes.\", new AggregateException(exceptions.ToArray()));\n+            }\n \n-                CommunicationsUtilities.Trace(\"Attempting to connect to each existing {1} process in turn to establish node {0}...\", nodeId, runningNodesTuple.expectedProcessName);\n-                foreach (Process nodeProcess in runningNodesTuple.processes)\n+            return nodeContexts.ToList();\n+\n+            bool TryReuseAnyFromPossibleRunningNodes(int nodeId)\n+            {\n+                while (possibleRunningNodes != null && possibleRunningNodes.TryDequeue(out var nodeToReuse))\n                 {\n-                    if (nodeProcess.Id == Process.GetCurrentProcess().Id)\n+                    CommunicationsUtilities.Trace(\"Try to connect to each existing {0} process candidate to establish node {1}...\", expectedProcessName, nodeId);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This is good catch. The verbosity is not an issue here as it will be just one log per process candidate.\r\nI have changed it to include more information;  specifically process id and its arguments.\r\n",
              "createdAt": "2022-04-14T19:05:05Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;\n #if FEATURE_NODE_REUSE\n             // Try to connect to idle nodes if node reuse is enabled.\n             if (_componentHost.BuildParameters.EnableNodeReuse)\n             {\n-                (string expectedProcessName, List<Process> processes) runningNodesTuple = GetPossibleRunningNodes(msbuildLocation);\n+                (expectedProcessName, possibleRunningNodes) = GetPossibleRunningNodes(msbuildLocation);\n+            }\n+#endif\n+            ConcurrentQueue<NodeContext> nodeContexts = new();\n+            ConcurrentQueue<Exception> exceptions = new();\n+            Parallel.For(nextNodeId, nextNodeId + numberOfNodesToCreate, (nodeId) =>\n+            {\n+                try\n+                {\n+                    if (!TryReuseAnyFromPossibleRunningNodes(nodeId) && !StartNewNode(nodeId))\n+                    {\n+                        // We were unable to reuse or launch a node.\n+                        CommunicationsUtilities.Trace(\"FAILED TO CONNECT TO A CHILD NODE\");\n+                    }\n+                }\n+                catch (Exception ex)\n+                {\n+                    // It will be rethrown as aggregate exception\n+                    exceptions.Enqueue(ex);\n+                }\n+            });\n+            if (!exceptions.IsEmpty)\n+            {\n+                ErrorUtilities.ThrowInternalError(\"Cannot acquire required number of nodes.\", new AggregateException(exceptions.ToArray()));\n+            }\n \n-                CommunicationsUtilities.Trace(\"Attempting to connect to each existing {1} process in turn to establish node {0}...\", nodeId, runningNodesTuple.expectedProcessName);\n-                foreach (Process nodeProcess in runningNodesTuple.processes)\n+            return nodeContexts.ToList();\n+\n+            bool TryReuseAnyFromPossibleRunningNodes(int nodeId)\n+            {\n+                while (possibleRunningNodes != null && possibleRunningNodes.TryDequeue(out var nodeToReuse))\n                 {\n-                    if (nodeProcess.Id == Process.GetCurrentProcess().Id)\n+                    CommunicationsUtilities.Trace(\"Try to connect to each existing {0} process candidate to establish node {1}...\", expectedProcessName, nodeId);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I was more worried about claiming that you're trying to connect to processes explicitly excluded when you're really not, as that might be a bit confusing. Not too big a deal to me, though, since it'd presumably be mostly just us looking at this.",
              "createdAt": "2022-04-14T21:30:45Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;\n #if FEATURE_NODE_REUSE\n             // Try to connect to idle nodes if node reuse is enabled.\n             if (_componentHost.BuildParameters.EnableNodeReuse)\n             {\n-                (string expectedProcessName, List<Process> processes) runningNodesTuple = GetPossibleRunningNodes(msbuildLocation);\n+                (expectedProcessName, possibleRunningNodes) = GetPossibleRunningNodes(msbuildLocation);\n+            }\n+#endif\n+            ConcurrentQueue<NodeContext> nodeContexts = new();\n+            ConcurrentQueue<Exception> exceptions = new();\n+            Parallel.For(nextNodeId, nextNodeId + numberOfNodesToCreate, (nodeId) =>\n+            {\n+                try\n+                {\n+                    if (!TryReuseAnyFromPossibleRunningNodes(nodeId) && !StartNewNode(nodeId))\n+                    {\n+                        // We were unable to reuse or launch a node.\n+                        CommunicationsUtilities.Trace(\"FAILED TO CONNECT TO A CHILD NODE\");\n+                    }\n+                }\n+                catch (Exception ex)\n+                {\n+                    // It will be rethrown as aggregate exception\n+                    exceptions.Enqueue(ex);\n+                }\n+            });\n+            if (!exceptions.IsEmpty)\n+            {\n+                ErrorUtilities.ThrowInternalError(\"Cannot acquire required number of nodes.\", new AggregateException(exceptions.ToArray()));\n+            }\n \n-                CommunicationsUtilities.Trace(\"Attempting to connect to each existing {1} process in turn to establish node {0}...\", nodeId, runningNodesTuple.expectedProcessName);\n-                foreach (Process nodeProcess in runningNodesTuple.processes)\n+            return nodeContexts.ToList();\n+\n+            bool TryReuseAnyFromPossibleRunningNodes(int nodeId)\n+            {\n+                while (possibleRunningNodes != null && possibleRunningNodes.TryDequeue(out var nodeToReuse))\n                 {\n-                    if (nodeProcess.Id == Process.GetCurrentProcess().Id)\n+                    CommunicationsUtilities.Trace(\"Try to connect to each existing {0} process candidate to establish node {1}...\", expectedProcessName, nodeId);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It is valid point, on the other hand listing all candidates (even those already rejected) might have some debug value.",
              "createdAt": "2022-04-14T22:15:44Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;\n #if FEATURE_NODE_REUSE\n             // Try to connect to idle nodes if node reuse is enabled.\n             if (_componentHost.BuildParameters.EnableNodeReuse)\n             {\n-                (string expectedProcessName, List<Process> processes) runningNodesTuple = GetPossibleRunningNodes(msbuildLocation);\n+                (expectedProcessName, possibleRunningNodes) = GetPossibleRunningNodes(msbuildLocation);\n+            }\n+#endif\n+            ConcurrentQueue<NodeContext> nodeContexts = new();\n+            ConcurrentQueue<Exception> exceptions = new();\n+            Parallel.For(nextNodeId, nextNodeId + numberOfNodesToCreate, (nodeId) =>\n+            {\n+                try\n+                {\n+                    if (!TryReuseAnyFromPossibleRunningNodes(nodeId) && !StartNewNode(nodeId))\n+                    {\n+                        // We were unable to reuse or launch a node.\n+                        CommunicationsUtilities.Trace(\"FAILED TO CONNECT TO A CHILD NODE\");\n+                    }\n+                }\n+                catch (Exception ex)\n+                {\n+                    // It will be rethrown as aggregate exception\n+                    exceptions.Enqueue(ex);\n+                }\n+            });\n+            if (!exceptions.IsEmpty)\n+            {\n+                ErrorUtilities.ThrowInternalError(\"Cannot acquire required number of nodes.\", new AggregateException(exceptions.ToArray()));\n+            }\n \n-                CommunicationsUtilities.Trace(\"Attempting to connect to each existing {1} process in turn to establish node {0}...\", nodeId, runningNodesTuple.expectedProcessName);\n-                foreach (Process nodeProcess in runningNodesTuple.processes)\n+            return nodeContexts.ToList();\n+\n+            bool TryReuseAnyFromPossibleRunningNodes(int nodeId)\n+            {\n+                while (possibleRunningNodes != null && possibleRunningNodes.TryDequeue(out var nodeToReuse))\n                 {\n-                    if (nodeProcess.Id == Process.GetCurrentProcess().Id)\n+                    CommunicationsUtilities.Trace(\"Try to connect to each existing {0} process candidate to establish node {1}...\", expectedProcessName, nodeId);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there any reason you're using ConcurrentQueue as opposed to some other concurrent data structure? It has tighter constraints that ConcurrentBag, so I'd imagine that's faster? (Haven't tested that.)",
              "createdAt": "2022-04-14T00:18:35Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I thought about it, I liked Q better as it preserver order of creation which could help with troubleshooting. Since there is no `Concurrent ordered collection` I am using `ConcurrentQueue` whenever I need ordered concurrent collection.\r\nIn this context when we are spending 100ms spawning process the difference between queue and bag would be insignificant. I have not measured it yet but I expect it will be < 1ns.\r\n",
              "createdAt": "2022-04-14T18:55:36Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I'm thinking about the limit as number of processors approaches infinity. It should get progressively harder to use the queue concurrently, which isn't true for a bag. No computer actually has infinite processors of course, but people doing C++ seem to have a lot. Might be reasonable?",
              "createdAt": "2022-04-14T21:34:17Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "When in doubt I call DotNetBenchmark for a help. Surprisingly, ConcurrentQueue is faster that ConcurrentBag.\r\n![image](https://user-images.githubusercontent.com/25249058/163484185-8873f21a-94c3-4b93-8e9f-1b60f2f0b165.png)\r\nResult of my benchmark is consitent with this article: https://minidump.net/performance-best-practices-in-c-b85a47bdd93a",
              "createdAt": "2022-04-14T22:11:13Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Also please note that for 1000 items (1000 processes which match our process name) it is ~1ns while connecting to ONE node is 20ms which  is 0.005% of it :-)",
              "createdAt": "2022-04-14T22:14:22Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "What code did you use for your benchmark? I was partially surprised because I'd run my own benchmark and got very different results:\r\n| Method | NumCases |         Mean |      Error |       StdDev |       Median |     Gen 0 |     Gen 1 |     Gen 2 |   Allocated |\r\n|------- |--------- |-------------:|-----------:|-------------:|-------------:|----------:|----------:|----------:|------------:|\r\n|    Bag |      100 |     17.26 us |   0.336 us |     0.588 us |     17.14 us |    0.7629 |    0.3662 |         - |     4.67 KB |\r\n|  Queue |      100 |     13.44 us |   0.150 us |     0.133 us |     13.43 us |    0.8545 |         - |         - |     5.23 KB |\r\n|    Bag |    10000 |    262.59 us |   8.581 us |    24.758 us |    253.76 us |   31.7383 |   15.6250 |    2.9297 |   155.39 KB |\r\n|  Queue |    10000 |    692.55 us |  13.848 us |    39.510 us |    679.86 us |   23.4375 |    5.8594 |         - |   134.14 KB |\r\n|    Bag |  1000000 | 12,165.84 us | 335.746 us |   989.955 us | 12,124.86 us | 1359.3750 | 1281.2500 | 1046.8750 | 16686.98 KB |\r\n|  Queue |  1000000 | 40,737.60 us | 808.214 us | 1,857.007 us | 40,433.64 us |  666.6667 |  666.6667 |  666.6667 |   8215.2 KB |\r\n\r\nThe article mentioned that ConcurrentBag is optimized for the process that uses something (normally) being the same as the one that added it to the bag. My code essentially looked like this:\r\n```C#\r\nConcurrentContainer<int> container = new();\r\nParallel.For(0, NumCases, i =>\r\n{\r\n    container.Add(i);\r\n});\r\nforeach (int i in container);\r\n```",
              "createdAt": "2022-04-14T22:54:47Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Most noteworthy, I think, is that for larger numbers of threads adding, the Bag starts to be much faster than the queue, but its allocations also get to be much larger.",
              "createdAt": "2022-04-14T22:56:01Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "(To be clear, I think it's reasonable/fine to use a queue; I'm just curious why your numbers would be so unexpected.)",
              "createdAt": "2022-04-14T22:57:03Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "But this is not how we use it in this code. Your benchmark have concurrent producers and one thread consumer. Our usage is one thread producer - get processes -  and multi thread competing consumers.\r\nTo feed your curiosity :-) please try to measure it with something like this:\r\n```\r\nConcurrentContainer<int> container = new();\r\nfor (int i = 0; i < NumCases; i++)\r\n   container.Add(i);\r\nParallel.For(0, NumCases, _ =>\r\n{\r\n    container.TryTake(out _);\r\n});\r\n```",
              "createdAt": "2022-04-14T23:43:01Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I added one little tweak to your version: rather than initializing a concurrent collection then adding to it, I initialized a normal List, added to it, then used the concurrent constructor taking a list.\r\n\r\n| Method | NumCases |         Mean |        Error |       StdDev |     Gen 0 |     Gen 1 |     Gen 2 |   Allocated |\r\n|------- |--------- |-------------:|-------------:|-------------:|----------:|----------:|----------:|------------:|\r\n|    Bag |      100 |     23.07 us |     0.455 us |     0.447 us |    0.8545 |    0.4272 |         - |     5.29 KB |\r\n|  Queue |      100 |     13.97 us |     0.278 us |     0.285 us |    0.8240 |         - |         - |     5.02 KB |\r\n|    Bag |    10000 |  1,467.20 us |    41.087 us |   119.854 us |   42.9688 |   21.4844 |    3.9063 |   266.05 KB |\r\n|  Queue |    10000 |    966.75 us |    26.234 us |    77.350 us |   41.0156 |   41.0156 |   41.0156 |   260.71 KB |\r\n|    Bag |  1000000 | 86,002.80 us | 1,717.738 us | 4,403.219 us | 1800.0000 | 1800.0000 | 1800.0000 |  16397.6 KB |\r\n|  Queue |  1000000 | 81,010.31 us | 2,224.135 us | 6,200.000 us |  625.0000 |  625.0000 |  625.0000 | 16398.53 KB |\r\n\r\nWhat I think is most interesting here is that Queue trounces Bag for small input sizes, but they approach the same for larger inputs. I'd wager that if I went for even NumCases == 10,000,000, Bag would be strictly more performant than Queue. That said, if someone has millions of MSBuild processes running on one computer all at once, I think we have a more fundamental problem...",
              "createdAt": "2022-04-15T16:13:56Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,162 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n\r\n```suggestion\r\n            List<NodeInfo> nodes = new(numberOfNodesToCreate);\r\n```\r\n\r\n?",
              "createdAt": "2022-04-18T14:26:58Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -92,32 +86,31 @@ private NodeManager()\n         /// </summary>\n         /// <param name=\"configuration\">The configuration to use for the remote node.</param>\n         /// <param name=\"nodeAffinity\">The <see cref=\"NodeAffinity\"/> to use.</param>\n+        /// <param name=\"numberOfNodesToCreate\">Number of nodes to be reused ot created.</param>\n         /// <returns>A NodeInfo describing the node created, or null if none could be created.</returns>\n-        public NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAffinity)\n+        public IList<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity nodeAffinity, int numberOfNodesToCreate)\n         {\n             // We will prefer to make nodes on the \"closest\" providers first; in-proc, then\n             // out-of-proc, then remote.\n             // When we support distributed build, we will also consider the remote provider.\n-            int nodeId = InvalidNodeId;\n-            if ((nodeAffinity == NodeAffinity.Any || nodeAffinity == NodeAffinity.InProc) && !_componentHost.BuildParameters.DisableInProcNode)\n+            List<NodeInfo> nodes = new();",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    // If it fails let it return what we have created so far so caller can somehow acquire missing nodes.\r\n```",
              "createdAt": "2022-04-18T14:33:05Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs",
              "diffHunk": "@@ -184,13 +185,34 @@ public void ShutdownAllNodes()\n             ShutdownConnectedNodes(false /* no node reuse */);\n         }\n \n+        public IList<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory factory, Func<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate)\n+        {\n+            var nodes = new List<NodeInfo>(numberOfNodesToCreate);\n+\n+            for (int i = 0; i < numberOfNodesToCreate; i++)\n+            {\n+                int nodeId = nextNodeId + i;\n+\n+                NodeInfo nodeInfo = new(nodeId, ProviderType);\n+                if (!CreateNode(nodeId, factory, configurationFactory(nodeInfo)))\n+                {\n+                    // If it fails let it return what we have crated so far to so caller can somehow acquire missing nodes.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this introduce a possible race between a call to ShutdownConnectedNodes and a call to create new nodes? Though it doesn't look like adding to `_nodeContexts` was locked before when adding so I guess that's not new.",
              "createdAt": "2022-04-18T14:40:18Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs",
              "diffHunk": "@@ -132,12 +144,7 @@ public void SendData(int nodeId, INodePacket packet)\n         public void ShutdownConnectedNodes(bool enableReuse)\n         {\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n-            List<NodeContext> contextsToShutDown;\n-\n-            lock (_nodeContexts)\n-            {\n-                contextsToShutDown = new List<NodeContext>(_nodeContexts.Values);\n-            }\n+            var contextsToShutDown = new List<NodeContext>(_nodeContexts.Values);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It is hard to find all possible race conditions here along with their probablility and consequences. I have found at least one race conditions: `ShutdownConnectedNodes` is in call stack of CTRL+C console cancellation so it can indeed happen anytime.\r\n\r\nHowever, these changes did not make it any worse. Actually, it is slightly better as  `_nodeContexts` is `ConcurentDictionary` now so it is guaranteed to be in consistent state when race condition happen, as oppose to former code when we could have had read Values while it was in middle of adding/mutating.\r\n\r\nI recommend to NOT invest more into this race condition.",
              "createdAt": "2022-04-18T18:16:24Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs",
              "diffHunk": "@@ -132,12 +144,7 @@ public void SendData(int nodeId, INodePacket packet)\n         public void ShutdownConnectedNodes(bool enableReuse)\n         {\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n-            List<NodeContext> contextsToShutDown;\n-\n-            lock (_nodeContexts)\n-            {\n-                contextsToShutDown = new List<NodeContext>(_nodeContexts.Values);\n-            }\n+            var contextsToShutDown = new List<NodeContext>(_nodeContexts.Values);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we assert that this returns `true`?",
              "createdAt": "2022-04-18T14:47:35Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,169 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;\n #if FEATURE_NODE_REUSE\n             // Try to connect to idle nodes if node reuse is enabled.\n             if (_componentHost.BuildParameters.EnableNodeReuse)\n             {\n-                (string expectedProcessName, List<Process> processes) runningNodesTuple = GetPossibleRunningNodes(msbuildLocation);\n+                IList<Process> possibleRunningNodesList;\n+                (expectedProcessName, possibleRunningNodesList) = GetPossibleRunningNodes(msbuildLocation);\n+                possibleRunningNodes = new ConcurrentQueue<Process>(possibleRunningNodesList);\n \n-                CommunicationsUtilities.Trace(\"Attempting to connect to each existing {1} process in turn to establish node {0}...\", nodeId, runningNodesTuple.expectedProcessName);\n-                foreach (Process nodeProcess in runningNodesTuple.processes)\n+                if (possibleRunningNodesList.Count > 0)\n+                {\n+                    CommunicationsUtilities.Trace(\"Attempting to connect to {1} existing processes '{0}'...\", expectedProcessName, possibleRunningNodesList.Count);\n+                }\n+            }\n+#endif\n+            ConcurrentQueue<NodeContext> nodeContexts = new();\n+            ConcurrentQueue<Exception> exceptions = new();\n+            Parallel.For(nextNodeId, nextNodeId + numberOfNodesToCreate, (nodeId) =>\n+            {\n+                try\n                 {\n-                    if (nodeProcess.Id == Process.GetCurrentProcess().Id)\n+                    if (!TryReuseAnyFromPossibleRunningNodes(nodeId) && !StartNewNode(nodeId))\n+                    {\n+                        // We were unable to reuse or launch a node.\n+                        CommunicationsUtilities.Trace(\"FAILED TO CONNECT TO A CHILD NODE\");\n+                    }\n+                }\n+                catch (Exception ex)\n+                {\n+                    // It will be rethrown as aggregate exception\n+                    exceptions.Enqueue(ex);\n+                }\n+            });\n+            if (!exceptions.IsEmpty)\n+            {\n+                ErrorUtilities.ThrowInternalError(\"Cannot acquire required number of nodes.\", new AggregateException(exceptions.ToArray()));\n+            }\n+\n+            return nodeContexts.ToList();\n+\n+            bool TryReuseAnyFromPossibleRunningNodes(int nodeId)\n+            {\n+                while (possibleRunningNodes != null && possibleRunningNodes.TryDequeue(out var nodeToReuse))\n+                {\n+                    CommunicationsUtilities.Trace(\"Trying to connect to existing process {2} with id {1} to establish node {0}...\", nodeId, nodeToReuse.Id, nodeToReuse.ProcessName);\n+                    if (nodeToReuse.Id == Process.GetCurrentProcess().Id)\n                     {\n                         continue;\n                     }\n \n                     // Get the full context of this inspection so that we can always skip this process when we have the same taskhost context\n-                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, nodeProcess.Id);\n-                    if (_processesToIgnore.Contains(nodeLookupKey))\n+                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, nodeToReuse.Id);\n+                    if (_processesToIgnore.ContainsKey(nodeLookupKey))\n                     {\n                         continue;\n                     }\n \n                     // We don't need to check this again\n-                    _processesToIgnore.Add(nodeLookupKey);\n+                    _processesToIgnore.TryAdd(nodeLookupKey, default);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Do you mean `Debug.Assert` or `VerifyThrow`? \r\nThis should never happen if there is no bug in our code as that `ConcurerentQueue` guarantee only one thread will handle particular process which makes `nodeLookupKey` unique and we test key absence ay line 278. Since we use underlying `ConcurrentDictionary` as `ConcurrentHashSet` the `TryAdd` actually has same meaning as `ISet.Add`.\r\nI believe original decision to use `HashSet` for `_processesToIgnore` was not to assure uniqueness but for algorithmically fast lookup.",
              "createdAt": "2022-04-18T18:28:17Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -206,115 +218,169 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in\n                 }\n             }\n \n+            // Get all process of possible running node processes for reuse and put them into ConcurrentQueue.\n+            // Processes from this queue will be concurrently consumed by TryReusePossibleRunningNodes while\n+            //    trying to connect to them and reuse them. When queue is empty, no process to reuse left\n+            //    new node process will be started.\n+            string expectedProcessName = null;\n+            ConcurrentQueue<Process> possibleRunningNodes = null;\n #if FEATURE_NODE_REUSE\n             // Try to connect to idle nodes if node reuse is enabled.\n             if (_componentHost.BuildParameters.EnableNodeReuse)\n             {\n-                (string expectedProcessName, List<Process> processes) runningNodesTuple = GetPossibleRunningNodes(msbuildLocation);\n+                IList<Process> possibleRunningNodesList;\n+                (expectedProcessName, possibleRunningNodesList) = GetPossibleRunningNodes(msbuildLocation);\n+                possibleRunningNodes = new ConcurrentQueue<Process>(possibleRunningNodesList);\n \n-                CommunicationsUtilities.Trace(\"Attempting to connect to each existing {1} process in turn to establish node {0}...\", nodeId, runningNodesTuple.expectedProcessName);\n-                foreach (Process nodeProcess in runningNodesTuple.processes)\n+                if (possibleRunningNodesList.Count > 0)\n+                {\n+                    CommunicationsUtilities.Trace(\"Attempting to connect to {1} existing processes '{0}'...\", expectedProcessName, possibleRunningNodesList.Count);\n+                }\n+            }\n+#endif\n+            ConcurrentQueue<NodeContext> nodeContexts = new();\n+            ConcurrentQueue<Exception> exceptions = new();\n+            Parallel.For(nextNodeId, nextNodeId + numberOfNodesToCreate, (nodeId) =>\n+            {\n+                try\n                 {\n-                    if (nodeProcess.Id == Process.GetCurrentProcess().Id)\n+                    if (!TryReuseAnyFromPossibleRunningNodes(nodeId) && !StartNewNode(nodeId))\n+                    {\n+                        // We were unable to reuse or launch a node.\n+                        CommunicationsUtilities.Trace(\"FAILED TO CONNECT TO A CHILD NODE\");\n+                    }\n+                }\n+                catch (Exception ex)\n+                {\n+                    // It will be rethrown as aggregate exception\n+                    exceptions.Enqueue(ex);\n+                }\n+            });\n+            if (!exceptions.IsEmpty)\n+            {\n+                ErrorUtilities.ThrowInternalError(\"Cannot acquire required number of nodes.\", new AggregateException(exceptions.ToArray()));\n+            }\n+\n+            return nodeContexts.ToList();\n+\n+            bool TryReuseAnyFromPossibleRunningNodes(int nodeId)\n+            {\n+                while (possibleRunningNodes != null && possibleRunningNodes.TryDequeue(out var nodeToReuse))\n+                {\n+                    CommunicationsUtilities.Trace(\"Trying to connect to existing process {2} with id {1} to establish node {0}...\", nodeId, nodeToReuse.Id, nodeToReuse.ProcessName);\n+                    if (nodeToReuse.Id == Process.GetCurrentProcess().Id)\n                     {\n                         continue;\n                     }\n \n                     // Get the full context of this inspection so that we can always skip this process when we have the same taskhost context\n-                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, nodeProcess.Id);\n-                    if (_processesToIgnore.Contains(nodeLookupKey))\n+                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, nodeToReuse.Id);\n+                    if (_processesToIgnore.ContainsKey(nodeLookupKey))\n                     {\n                         continue;\n                     }\n \n                     // We don't need to check this again\n-                    _processesToIgnore.Add(nodeLookupKey);\n+                    _processesToIgnore.TryAdd(nodeLookupKey, default);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n```",
              "createdAt": "2022-04-20T21:23:50Z",
              "path": "src/Build/BackEnd/Components/Communications/INodeProvider.cs",
              "diffHunk": "@@ -1,7 +1,8 @@\n \ufeff// Copyright (c) Microsoft. All rights reserved.\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n-#nullable disable\n+using System;\n+using System.Collections.Generic;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nusing System.Linq;\r\n\r\n#nullable disable\r\n```",
              "createdAt": "2022-04-20T21:24:23Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -5,11 +5,10 @@\n using System.Collections.Generic;\n using Microsoft.Build.Shared;\n using Microsoft.Build.Execution;\n+using System.Threading;\n using System.Diagnostics;\n using System.Linq;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n```",
              "createdAt": "2022-04-20T21:24:50Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs",
              "diffHunk": "@@ -1,9 +1,11 @@\n \ufeff// Copyright (c) Microsoft. All rights reserved.\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n+using System;\n+using System.Collections.Concurrent;\n using System.Collections.Generic;\n using System.Diagnostics;\n-\n+using System.Linq;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n```",
              "createdAt": "2022-04-20T21:25:11Z",
              "path": "src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs",
              "diffHunk": "@@ -2,6 +2,7 @@\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n using System;\n+using System.Collections.Generic;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "IEnumerable.Empty<Process>() to avoid extra allocation.",
              "createdAt": "2022-04-21T00:52:22Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -352,7 +349,7 @@ NodeConfiguration AcquiredNodeConfigurationFactory(NodeInfo nodeInfo)\n \n         public IEnumerable<Process> GetProcesses()\n         {\n-            return _outOfProcNodeProvider.GetProcesses();\n+            return _outOfProcNodeProvider?.GetProcesses() ?? new List<Process>(0);",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "It is dead path of code. _outOfProcNodeProvider is supposed to be always set in all codepaths calling this method. However, because of `nullable` we need to eliminate warning by `?`. I would actually recommend ` return _outOfProcNodeProvider?.GetProcesses()!`",
              "createdAt": "2022-04-21T07:13:03Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -352,7 +349,7 @@ NodeConfiguration AcquiredNodeConfigurationFactory(NodeInfo nodeInfo)\n \n         public IEnumerable<Process> GetProcesses()\n         {\n-            return _outOfProcNodeProvider.GetProcesses();\n+            return _outOfProcNodeProvider?.GetProcesses() ?? new List<Process>(0);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            return _outOfProcNodeProvider?.GetProcesses() ?? IEnumerable.Empty();\r\n```",
              "createdAt": "2022-04-21T03:08:24Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -307,52 +299,57 @@ private void RemoveNodeFromMapping(int nodeId)\n         /// </summary>\n         /// <param name=\"nodeProvider\">The provider used to create the node.</param>\n         /// <param name=\"nodeConfiguration\">The <see cref=\"NodeConfiguration\"/> to use.</param>\n-        /// <returns>The id of the node created.</returns>\n-        private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration)\n+        /// <param name=\"numberOfNodesToCreate\">Number of nodes to be reused ot created.</param>\n+        /// <returns>List of created nodes.</returns>\n+        private IList<NodeInfo> AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration, int numberOfNodesToCreate)\n         {\n             // If no provider was passed in, we obviously can't create a node.\n             if (nodeProvider == null)\n             {\n                 ErrorUtilities.ThrowInternalError(\"No node provider provided.\");\n-                return InvalidNodeId;\n+                return new List<NodeInfo>();\n             }\n \n             // Are there any free slots on this provider?\n             if (nodeProvider.AvailableNodes == 0)\n             {\n-                return InvalidNodeId;\n+                return new List<NodeInfo>();\n             }\n \n             // Assign a global ID to the node we are about to create.\n-            int nodeId;\n+            int fromNodeId;\n             if (nodeProvider is NodeProviderInProc)\n             {\n-                nodeId = _inprocNodeId;\n+                fromNodeId = _inprocNodeId;\n             }\n             else\n             {\n-                nodeId = _nextNodeId;\n-                _nextNodeId++;\n+                // Reserve node numbers for all needed nodes.\n+                fromNodeId = Interlocked.Add(ref _nextNodeId, numberOfNodesToCreate) - numberOfNodesToCreate;\n             }\n \n-            NodeConfiguration configToSend = nodeConfiguration.Clone();\n-            configToSend.NodeId = nodeId;\n \n             // Create the node and add it to our mapping.\n-            bool createdNode = nodeProvider.CreateNode(nodeId, this, configToSend);\n+            IList<NodeInfo> nodes = nodeProvider.CreateNodes(fromNodeId, this, AcquiredNodeConfigurationFactory, numberOfNodesToCreate);\n \n-            if (!createdNode)\n+            foreach (NodeInfo node in nodes)\n             {\n-                return InvalidNodeId;\n+                _nodeIdToProvider.Add(node.NodeId, nodeProvider);\n             }\n \n-            _nodeIdToProvider.Add(nodeId, nodeProvider);\n-            return nodeId;\n+            return nodes;\n+\n+            NodeConfiguration AcquiredNodeConfigurationFactory(NodeInfo nodeInfo)\n+            {\n+                var config = nodeConfiguration.Clone();\n+                config.NodeId = nodeInfo.NodeId;\n+                return config;\n+            }\n         }\n \n         public IEnumerable<Process> GetProcesses()\n         {\n-            return _outOfProcNodeProvider.GetProcesses();\n+            return _outOfProcNodeProvider?.GetProcesses() ?? new List<Process>(0);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            return _outOfProcNodeProvider?.GetProcesses()!;\r\n```",
              "createdAt": "2022-04-21T07:14:08Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeManager.cs",
              "diffHunk": "@@ -307,52 +299,57 @@ private void RemoveNodeFromMapping(int nodeId)\n         /// </summary>\n         /// <param name=\"nodeProvider\">The provider used to create the node.</param>\n         /// <param name=\"nodeConfiguration\">The <see cref=\"NodeConfiguration\"/> to use.</param>\n-        /// <returns>The id of the node created.</returns>\n-        private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration)\n+        /// <param name=\"numberOfNodesToCreate\">Number of nodes to be reused ot created.</param>\n+        /// <returns>List of created nodes.</returns>\n+        private IList<NodeInfo> AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration, int numberOfNodesToCreate)\n         {\n             // If no provider was passed in, we obviously can't create a node.\n             if (nodeProvider == null)\n             {\n                 ErrorUtilities.ThrowInternalError(\"No node provider provided.\");\n-                return InvalidNodeId;\n+                return new List<NodeInfo>();\n             }\n \n             // Are there any free slots on this provider?\n             if (nodeProvider.AvailableNodes == 0)\n             {\n-                return InvalidNodeId;\n+                return new List<NodeInfo>();\n             }\n \n             // Assign a global ID to the node we are about to create.\n-            int nodeId;\n+            int fromNodeId;\n             if (nodeProvider is NodeProviderInProc)\n             {\n-                nodeId = _inprocNodeId;\n+                fromNodeId = _inprocNodeId;\n             }\n             else\n             {\n-                nodeId = _nextNodeId;\n-                _nextNodeId++;\n+                // Reserve node numbers for all needed nodes.\n+                fromNodeId = Interlocked.Add(ref _nextNodeId, numberOfNodesToCreate) - numberOfNodesToCreate;\n             }\n \n-            NodeConfiguration configToSend = nodeConfiguration.Clone();\n-            configToSend.NodeId = nodeId;\n \n             // Create the node and add it to our mapping.\n-            bool createdNode = nodeProvider.CreateNode(nodeId, this, configToSend);\n+            IList<NodeInfo> nodes = nodeProvider.CreateNodes(fromNodeId, this, AcquiredNodeConfigurationFactory, numberOfNodesToCreate);\n \n-            if (!createdNode)\n+            foreach (NodeInfo node in nodes)\n             {\n-                return InvalidNodeId;\n+                _nodeIdToProvider.Add(node.NodeId, nodeProvider);\n             }\n \n-            _nodeIdToProvider.Add(nodeId, nodeProvider);\n-            return nodeId;\n+            return nodes;\n+\n+            NodeConfiguration AcquiredNodeConfigurationFactory(NodeInfo nodeInfo)\n+            {\n+                var config = nodeConfiguration.Clone();\n+                config.NodeId = nodeInfo.NodeId;\n+                return config;\n+            }\n         }\n \n         public IEnumerable<Process> GetProcesses()\n         {\n-            return _outOfProcNodeProvider.GetProcesses();\n+            return _outOfProcNodeProvider?.GetProcesses() ?? IEnumerable.Empty();",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      }
    ]
  }
}