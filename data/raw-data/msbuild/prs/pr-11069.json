{
  "number": 11069,
  "title": "expander optimization",
  "body": "# changes:\r\n 1. The AddArgumentFromSlices is an optimization that bypasses the need for argumentBuilder which has noticeable overhead.\r\n I use indices to directly calculate the argument instead.\r\n\r\n 2. The lines 2126 - 2142\r\n  The `expressionCapture.Captures?.Any ` iteration was visible in the profiler.\r\n  I pulled both branches into one loop since it looked slightly better. Performance improvement is speculative at best, can be \r\n  removed if we decide that it is too risky or something.\r\n\r\n3. Finally the `src/StringTools/WeakStringCache.Concurrent.cs`\r\n   the .Count call on the ConcurrentDictionary is locking everything which is not great since we do it quite often. my change aims to introduce separate count for that to limit the number of locks we take and to unblock the dictionary.\r\n\r\n\r\nAll together when profiling on my machine, after killing the outliers (MSBuild sometimes has a random-ish spikes in build time that I decided to skip) my aggregated output was ~this:\r\n\r\n1. 23 cold runs for our current Main branch, with `-maxcpucount:10 -tl:true` and average time of 62.103s\r\n2. 13 cold runs for this branch with same arguments, average time was 61.31s\r\nThough these are speculative at best, I've yet to find a reasonable and stable enough way of checking the impact.\r\n\r\nWhile using VS profiler for running my changes on a single-process basis, the improvement looked to be somewhere in the vicinity of 0.2-03%\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
  "state": "CLOSED",
  "createdAt": "2024-12-02T15:44:16Z",
  "updatedAt": "2025-01-03T10:45:38Z",
  "closedAt": "2025-01-03T10:45:37Z",
  "mergedAt": null,
  "additions": 148,
  "deletions": 62,
  "changedFiles": 2,
  "headRefName": "refactor_expander_optimization_GetArguments",
  "isDraft": false,
  "author": {
    "login": "SimaTian"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "f6b9b295977e147d2d4a120efc72d32b96405dc7",
          "message": "wip",
          "committedDate": "2024-12-01T19:43:26Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "e0ebda7c16f19671501077b60da3492696e9997b",
          "message": "multidictionary count to a separate variable, expander iteration one pass in ExpandExpressionCapture",
          "committedDate": "2024-12-01T19:43:26Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "13e8d3b9092c754139fb89390bee4ca05670b394",
          "message": "small revert",
          "committedDate": "2024-12-02T15:43:41Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "a55ad5eaba808940654bfa2d8f8a4bba44c2c0d4",
          "message": "fixing indexing errors",
          "committedDate": "2024-12-03T09:33:36Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "6e359e098a8d05b2014e88c683aa5a56d1587529",
          "message": "code cleanup",
          "committedDate": "2024-12-03T14:27:07Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "7d173bba35898f0826b5aa4a53309d39af13e2ab",
          "message": "annotation added back",
          "committedDate": "2024-12-03T14:28:21Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "62cf7e436171ba166cf8e466695fc1810a59a0b1",
          "message": "removal of unused variables",
          "committedDate": "2024-12-03T15:11:17Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "05c339ca2eb9d858394ab63ef651468bd55544cf",
          "message": "addressing review comments",
          "committedDate": "2024-12-04T08:22:58Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "088a4c0c5f92a03124a4725f3e6bfd40be55a024",
          "message": "Merge branch 'main' into refactor_expander_optimization_GetArguments",
          "committedDate": "2024-12-04T08:26:32Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "b159473f9c7a6873cd5d57778dc89d8c356565d9",
          "message": "Merge branch 'main' into refactor_expander_optimization_GetArguments",
          "committedDate": "2024-12-04T10:17:38Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "c818cb3ac7ca19915a0c29fbf8c2e1daab7dcbad",
          "message": "Merge branch 'main' into refactor_expander_optimization_GetArguments",
          "committedDate": "2024-12-10T09:43:20Z",
          "author": {
            "name": "Tomas Bartonek",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "2c5687529f7f5d7c3f0c279cda37642a6a1ac799",
          "message": "review",
          "committedDate": "2024-12-12T11:14:23Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "b52409721e46218728da0a49709174bd4946d939",
          "message": "fix",
          "committedDate": "2024-12-12T12:35:40Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      },
      {
        "commit": {
          "oid": "5acf8254fbceb2ff850c44710113476c0cc8e1c9",
          "message": "Merge branch 'main' into refactor_expander_optimization_GetArguments",
          "committedDate": "2024-12-16T12:28:17Z",
          "author": {
            "name": "SimaTian",
            "email": "tom.bartonek@volny.cz"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Thank you for tackling performance, I just have a few comments before getting to the specifics of the code.\r\n\r\n1. There are a lot of commented out code that doesn't seem that will be used in the future, please clean it up.\r\n2. For the PR description, it is very confusing. Please add the reason that these changes need to be made, and separate what you changed and the performance impact into two separate sections.",
        "createdAt": "2024-12-03T13:15:25Z",
        "author": {
          "login": "maridematte"
        }
      },
      {
        "body": "First of all, thank you for looking at my experimental changes. Much appreciated.\r\n\r\n> Thank you for tackling performance, I just have a few comments before getting to the specifics of the code.\r\n> \r\n> 1. There are a lot of commented out code that doesn't seem that will be used in the future, please clean it up.\r\n> 2. For the PR description, it is very confusing. Please add the reason that these changes need to be made, and separate what you changed and the performance impact into two separate sections.\r\n\r\n 1. I originally intended to keep the old code around for comparison purposes. That being said I forget that Git will make it visible anyways so I will remedy that soon-ish.\r\n 2. I will try.",
        "createdAt": "2024-12-03T14:20:03Z",
        "author": {
          "login": "SimaTian"
        }
      },
      {
        "body": "Thank you for the review. I wasn't expecting approval anytime soon. This is mostly to open the discussion about this area in particular.\r\nBefore we go ahead with an eventual merge(after resolving all concerns and/or discarding things we deem invalid), I would prefer to have some way to quantify the results other than \"it looks good in my local profiler\" or \"while running on my machine, it looked to be faster after averaging X vs Y runs.\"\r\n\r\nRegarding the test coverage:\r\nWe have 348 expander tests covering this area in general, see Expander_tests.cs\r\nIf I were to call out one test in particular that made my life somewhat uncomfortable, it would be `Medley` - a bunch of random error checks and edge cases.\r\nEvery test there does some expansion somewhere.\r\nFurthermore, I was able to build the Orchard even while some tests were failing - I don't think I can do much better test wise, unless we want to spend a lot more time on this.",
        "createdAt": "2024-12-04T08:10:34Z",
        "author": {
          "login": "SimaTian"
        }
      },
      {
        "body": "All sounds perfect!\r\n\r\nCan you run an exp insertion, request perf runs (DDRITs and Speedometer) a post results here?",
        "createdAt": "2024-12-10T09:33:10Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "@SimaTian , I am slightly concerned about code readability factor.\r\nIt's great that applying these changes brings  perf improvements , but it's quite difficult to understand a new logic in the amended parts.\r\n\r\n",
        "createdAt": "2024-12-10T14:03:24Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      },
      {
        "body": "I agree with @YuliiaKovalova. The code readability is not great here, it took me sometime to understand what is going on, and this concerns me if we need to debug it. My current opinion is that the performance improvement on this one is not worth the code readability trade-off.",
        "createdAt": "2025-01-02T10:29:26Z",
        "author": {
          "login": "maridematte"
        }
      },
      {
        "body": "I will split out the two smaller non-problematic improvements to a separate PR and kill this one.",
        "createdAt": "2025-01-03T10:45:37Z",
        "author": {
          "login": "SimaTian"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This feels can get out of sync after the `Scavenge` call (as judging by name, the goal is to remove items, while we only increment the count)",
              "createdAt": "2024-12-04T07:10:38Z",
              "path": "src/StringTools/WeakStringCache.Concurrent.cs",
              "diffHunk": "@@ -14,6 +14,7 @@ namespace Microsoft.NET.StringTools\n     internal sealed partial class WeakStringCache : IDisposable\n     {\n         private readonly ConcurrentDictionary<int, StringWeakHandle> _stringsByHashCode;\n+        private int _count;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "The scavenge call is resetting this counter after it's done:\r\n```\r\n_scavengeThreshold = _stringsByHashCode.Count * 2;\r\n_count = _stringsByHashCode.Count;\r\n```\r\nThere might be a slight inaccuracy, however I would argue that it's fine due to the fact that we're only using it here and only as a threshold to occasionaly reduce the size of the collection.",
              "createdAt": "2024-12-04T07:59:49Z",
              "path": "src/StringTools/WeakStringCache.Concurrent.cs",
              "diffHunk": "@@ -14,6 +14,7 @@ namespace Microsoft.NET.StringTools\n     internal sealed partial class WeakStringCache : IDisposable\n     {\n         private readonly ConcurrentDictionary<int, StringWeakHandle> _stringsByHashCode;\n+        private int _count;",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "I have for some reason missed that part :-O\r\nLooks good like this!",
              "createdAt": "2024-12-10T09:31:20Z",
              "path": "src/StringTools/WeakStringCache.Concurrent.cs",
              "diffHunk": "@@ -14,6 +14,7 @@ namespace Microsoft.NET.StringTools\n     internal sealed partial class WeakStringCache : IDisposable\n     {\n         private readonly ConcurrentDictionary<int, StringWeakHandle> _stringsByHashCode;\n+        private int _count;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can this be named more expressively?",
              "createdAt": "2024-12-04T07:12:29Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -830,18 +875,14 @@ private static string[] ExtractFunctionArguments(IElementLocation elementLocatio\n \n             List<string> arguments = new List<string>();\n \n-            using SpanBasedStringBuilder argumentBuilder = Strings.GetSpanBasedStringBuilder();\n-            int? argumentStartIndex = null;\n+            int abStart = -1;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What does this mean exactly? :)",
              "createdAt": "2024-12-04T07:13:54Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,95 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)\n+                {\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // Bit of extra logic to avoid trimming whitespace-only string one time too many.",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "When the string is whitespace only, this would first trim from the start and trim everything, then trim one more character from the back due to the way indices are set up here. (If I trimmed naively)\r\nThis is a bit of extra logic to prevent that.\r\nDon't ask me how I found out.\r\n",
              "createdAt": "2024-12-04T08:04:04Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,95 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)\n+                {\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // Bit of extra logic to avoid trimming whitespace-only string one time too many.",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This deserves comment (e.g. 'skiping the initial and trialing enclosing chars')",
              "createdAt": "2024-12-04T07:15:06Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,95 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)\n+                {\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // Bit of extra logic to avoid trimming whitespace-only string one time too many.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < --lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '\"' && arg[lastSliceIdx - 1] == '\"'))\n+            {\n+                ++firstSliceIdx;\n+                --lastSliceIdx;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "No problem, will do.\r\nThis function is nearly exact match of the previous version, just rewritten to use indices - so I mostly just copied comments over from that one. Probably should've thought about it a bit more.",
              "createdAt": "2024-12-04T08:01:36Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,95 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)\n+                {\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // Bit of extra logic to avoid trimming whitespace-only string one time too many.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < --lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '\"' && arg[lastSliceIdx - 1] == '\"'))\n+            {\n+                ++firstSliceIdx;\n+                --lastSliceIdx;",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "please elaborate on \"why this shouldn't happen\"",
              "createdAt": "2024-12-10T10:25:16Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "There should always be at least one slice. If something goes here then something is wrong. That being said, my argument at the time was that zero indices in the list meant argument is empty.\r\nMaybe I should've been more explicit and throw instead or remove the check alltogether since I don't think it can happen.\r\nIt was mostly me covering my bases when I started to fiddle around with indices.",
              "createdAt": "2024-12-10T14:30:15Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "Changed the comment to better reflect this fact.",
              "createdAt": "2024-12-11T10:19:08Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "it looks like `(firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx)` can be moved to the separate method with descriptive name and reused in the while loop here and on the line 794",
              "createdAt": "2024-12-10T10:27:49Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "This checks checks against lastSliceIndx and also checks to prevent duplicate whitespace removal (the second part after the ||)\r\nIt was similar-ish before, then I run into the \"all whitespace\" edge case and crashed. \r\nthat is what the `firstSlice == lastSlice && firstSliceIdx < lastSliceIdx` is for.\r\nSo the function would have to be something like\r\n`IsEdgeWhitespace(arg, firstSlice, lastSlice, idxToCheck)` and then some extra logic for this case.\r\nIs that more readable? I would like to say no, but that could be just my laziness/lack of feeling for cases such as this. ",
              "createdAt": "2024-12-10T14:50:24Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "why did you remove the static fields for these repetitive chars?",
              "createdAt": "2024-12-10T10:29:25Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSlice--;\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            // If the argument is in quotes, we want to remove those\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "The comparison didn't use them (I'm not 100% sure why, but I kept it that way). Since I'm working with indices, I didn't need them for .Trim() calls anymore so they became unused and the ./build.cmd started complaining.",
              "createdAt": "2024-12-10T13:55:31Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSlice--;\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            // If the argument is in quotes, we want to remove those\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "can it be just `return string.Equals(capture.FunctionName, \"AnyHaveMetadataValue\", StringComparison.OrdinalIgnoreCase)`?",
              "createdAt": "2024-12-10T10:36:30Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -2012,6 +2061,23 @@ internal static bool ExpandExpressionCapture<S>(\n                 // If there are no items of the given type, then bail out early\n                 if (itemsOfType.Count == 0)\n                 {\n+                    if (expressionCapture.Captures?.Any(capture =>\n+                        {\n+                            if (string.Equals(capture.FunctionName, \"Count\", StringComparison.OrdinalIgnoreCase))\n+                            {\n+                                return true;\n+                            }\n+                            if (string.Equals(capture.FunctionName, \"AnyHaveMetadataValue\", StringComparison.OrdinalIgnoreCase))",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The `_count` variable should be decremented when an entry is removed in the `Scavenge` method.",
              "createdAt": "2024-12-10T10:43:18Z",
              "path": "src/StringTools/WeakStringCache.Concurrent.cs",
              "diffHunk": "@@ -14,6 +14,7 @@ namespace Microsoft.NET.StringTools\n     internal sealed partial class WeakStringCache : IDisposable\n     {\n         private readonly ConcurrentDictionary<int, StringWeakHandle> _stringsByHashCode;\n+        private int _count;",
              "author": {
                "login": "copilot-pull-request-reviewer"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "could you please comment on these iterations so it's clear what  is handled here?",
              "createdAt": "2024-12-10T10:46:00Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSlice--;\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            // If the argument is in quotes, we want to remove those\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '\"' && arg[lastSliceIdx - 1] == '\"'))\n+            {\n+                ++firstSliceIdx;\n+                --lastSliceIdx;\n+                removedQuotes = true;\n+\n+                // Check yet again if we're still in the correct slice boundaries, this could've changed if we've trimmed.\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)\n                 {\n-                    arguments.Add(argValue);\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < --lastSlice)\n+                {\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n             }\n+\n+            string argValue = \"\";\n+\n+            while (firstSlice < lastSlice)",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I am a bit confused why would this improve perf, i guess there are usually few arguments. In general repeated concatenations are perf antipattern. Couldn't the StringTools.SpanBasedStringBuilder be optimized instead?",
              "createdAt": "2024-12-10T10:48:21Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSlice--;\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            // If the argument is in quotes, we want to remove those\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '\"' && arg[lastSliceIdx - 1] == '\"'))\n+            {\n+                ++firstSliceIdx;\n+                --lastSliceIdx;\n+                removedQuotes = true;\n+\n+                // Check yet again if we're still in the correct slice boundaries, this could've changed if we've trimmed.\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)\n                 {\n-                    arguments.Add(argValue);\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < --lastSlice)\n+                {\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n             }\n+\n+            string argValue = \"\";\n+\n+            while (firstSlice < lastSlice)\n+            {\n+                argValue += arg.Substring(firstSliceIdx, slices[firstSlice].Item2 - firstSliceIdx);",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "From what I saw/googled, the concat should be faster / similar speedwise up to 3-4 concatenations, after that the stringbuilder is faster.\r\nMost of resolved variables have 1 or 2 slices to concatenate(beyond the initial empty string) so I opted for the simplicity.\r\n\r\nThere is an argument to be made to have a split there based on number of slices and use a stringbuilder for 3+.\r\nAs for optimizing SpanBasedStringBuilder - that is not our code but something from Microsoft.NET.StringTools.\r\nI think that the main difference is that for most cases, the span based string builder is an overkill.",
              "createdAt": "2024-12-10T14:06:52Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSlice--;\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            // If the argument is in quotes, we want to remove those\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '\"' && arg[lastSliceIdx - 1] == '\"'))\n+            {\n+                ++firstSliceIdx;\n+                --lastSliceIdx;\n+                removedQuotes = true;\n+\n+                // Check yet again if we're still in the correct slice boundaries, this could've changed if we've trimmed.\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)\n                 {\n-                    arguments.Add(argValue);\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < --lastSlice)\n+                {\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n             }\n+\n+            string argValue = \"\";\n+\n+            while (firstSlice < lastSlice)\n+            {\n+                argValue += arg.Substring(firstSliceIdx, slices[firstSlice].Item2 - firstSliceIdx);",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "As for the perf improvement, the first two lines of the previous version function were doing this:\r\n```\r\n  argumentBuilder.Trim();\r\n  string argValue = argumentBuilder.ToString();\r\n``` \r\nand then doing everything with String, throwing away any and all advantage the spanbased stringbuilder might've had.\r\nSo there is an option to kill most of my changes and replace the string with SpanBasedChar - it could achieve similar if not identical results. The main cost would be probably further profiling since it's rather large replacement once again.",
              "createdAt": "2024-12-10T14:17:07Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSlice--;\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            // If the argument is in quotes, we want to remove those\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '\"' && arg[lastSliceIdx - 1] == '\"'))\n+            {\n+                ++firstSliceIdx;\n+                --lastSliceIdx;\n+                removedQuotes = true;\n+\n+                // Check yet again if we're still in the correct slice boundaries, this could've changed if we've trimmed.\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)\n                 {\n-                    arguments.Add(argValue);\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < --lastSlice)\n+                {\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n             }\n+\n+            string argValue = \"\";\n+\n+            while (firstSlice < lastSlice)\n+            {\n+                argValue += arg.Substring(firstSliceIdx, slices[firstSlice].Item2 - firstSliceIdx);",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "Bit more googling and having a static StringBuilder and reusing the instance should have the best from the both worlds - reasonable performance for small concatenation counts while avoiding the danger of allocation.",
              "createdAt": "2024-12-11T10:22:47Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSlice--;\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            // If the argument is in quotes, we want to remove those\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '\"' && arg[lastSliceIdx - 1] == '\"'))\n+            {\n+                ++firstSliceIdx;\n+                --lastSliceIdx;\n+                removedQuotes = true;\n+\n+                // Check yet again if we're still in the correct slice boundaries, this could've changed if we've trimmed.\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)\n                 {\n-                    arguments.Add(argValue);\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < --lastSlice)\n+                {\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n             }\n+\n+            string argValue = \"\";\n+\n+            while (firstSlice < lastSlice)\n+            {\n+                argValue += arg.Substring(firstSliceIdx, slices[firstSlice].Item2 - firstSliceIdx);",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: decrementing in conditions is unreadable",
              "createdAt": "2024-12-10T11:10:08Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSlice--;\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            // If the argument is in quotes, we want to remove those\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '\"' && arg[lastSliceIdx - 1] == '\"'))\n+            {\n+                ++firstSliceIdx;\n+                --lastSliceIdx;\n+                removedQuotes = true;\n+\n+                // Check yet again if we're still in the correct slice boundaries, this could've changed if we've trimmed.\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)\n                 {\n-                    arguments.Add(argValue);\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < --lastSlice)",
              "author": {
                "login": "JanProvaznik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: when thinking about it I understood what you mean that this is an equivalent behavior that but this comment is confusing, either remove or rephrase please",
              "createdAt": "2024-12-10T11:53:12Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -878,32 +923,36 @@ void FlushCurrentArgumentToArgumentBuilder(int argumentEndIndex)\n                         ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedQuote\"));\n                     }\n \n-                    FlushCurrentArgumentToArgumentBuilder(argumentEndIndex: quoteStart);\n-                    argumentBuilder.Append(argumentsString, quoteStart, (n - quoteStart) + 1);\n+                    FlushToSlices(quoteStart);\n+                    slices.Add(Tuple.Create(quoteStart, n + 1));\n                 }\n                 else if (argumentsString[n] == ',')\n                 {\n-                    FlushCurrentArgumentToArgumentBuilder(argumentEndIndex: n);\n+                    FlushToSlices(n);\n \n                     // We have reached the end of the current argument, go ahead and add it\n                     // to our list\n-                    AddArgument(arguments, argumentBuilder);\n+                    AddArgumentFromSlices(arguments, slices, argumentsString);\n \n                     // Clear out the argument builder ready for the next argument\n-                    argumentBuilder.Clear();\n+                    slices.Clear();\n                 }\n                 else\n                 {\n-                    argumentStartIndex ??= n;\n+                    // argumentStartIndex ??= n;",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "fair point, I've removed most of these, this one slipped through.",
              "createdAt": "2024-12-10T14:10:27Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -878,32 +923,36 @@ void FlushCurrentArgumentToArgumentBuilder(int argumentEndIndex)\n                         ProjectErrorUtilities.ThrowInvalidProject(elementLocation, \"InvalidFunctionPropertyExpression\", expressionFunction, AssemblyResources.GetString(\"InvalidFunctionPropertyExpressionDetailMismatchedQuote\"));\n                     }\n \n-                    FlushCurrentArgumentToArgumentBuilder(argumentEndIndex: quoteStart);\n-                    argumentBuilder.Append(argumentsString, quoteStart, (n - quoteStart) + 1);\n+                    FlushToSlices(quoteStart);\n+                    slices.Add(Tuple.Create(quoteStart, n + 1));\n                 }\n                 else if (argumentsString[n] == ',')\n                 {\n-                    FlushCurrentArgumentToArgumentBuilder(argumentEndIndex: n);\n+                    FlushToSlices(n);\n \n                     // We have reached the end of the current argument, go ahead and add it\n                     // to our list\n-                    AddArgument(arguments, argumentBuilder);\n+                    AddArgumentFromSlices(arguments, slices, argumentsString);\n \n                     // Clear out the argument builder ready for the next argument\n-                    argumentBuilder.Clear();\n+                    slices.Clear();\n                 }\n                 else\n                 {\n-                    argumentStartIndex ??= n;\n+                    // argumentStartIndex ??= n;",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "could we create struct for this? so it's a bit more readable slice.Start/End instead of slice.Item1/Item2.\r\nafaik that should have no perf difference",
              "createdAt": "2024-12-10T11:57:51Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -830,18 +879,14 @@ private static string[] ExtractFunctionArguments(IElementLocation elementLocatio\n \n             List<string> arguments = new List<string>();\n \n-            using SpanBasedStringBuilder argumentBuilder = Strings.GetSpanBasedStringBuilder();\n-            int? argumentStartIndex = null;\n+            int argumentStartIndex = -1;\n+            List<Tuple<int, int>> slices = new List<Tuple<int, int>>();",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Sound reasonable.\r\nMaybe we could go the ReadOnlySpan<char> route in the future and simplify this even more.",
              "createdAt": "2024-12-10T14:09:32Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -830,18 +879,14 @@ private static string[] ExtractFunctionArguments(IElementLocation elementLocatio\n \n             List<string> arguments = new List<string>();\n \n-            using SpanBasedStringBuilder argumentBuilder = Strings.GetSpanBasedStringBuilder();\n-            int? argumentStartIndex = null;\n+            int argumentStartIndex = -1;\n+            List<Tuple<int, int>> slices = new List<Tuple<int, int>>();",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: incrementing in conditions is unreadable",
              "createdAt": "2024-12-10T11:59:20Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSlice--;\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            // If the argument is in quotes, we want to remove those\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '\"' && arg[lastSliceIdx - 1] == '\"'))\n+            {\n+                ++firstSliceIdx;\n+                --lastSliceIdx;\n+                removedQuotes = true;\n+\n+                // Check yet again if we're still in the correct slice boundaries, this could've changed if we've trimmed.\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)",
              "author": {
                "login": "JanProvaznik"
              }
            },
            {
              "body": "Fair point. I think I removed it in another place but this one slipped through the crack.",
              "createdAt": "2024-12-10T13:56:11Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -775,47 +772,99 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in\n         }\n \n         /// <summary>\n-        /// Add the argument in the StringBuilder to the arguments list, handling nulls\n+        /// Add the argument represented by the slices to the arguments list, handling nulls\n         /// appropriately.\n         /// </summary>\n-        private static void AddArgument(List<string> arguments, SpanBasedStringBuilder argumentBuilder)\n+        private static void AddArgumentFromSlices(List<string> arguments, List<Tuple<int, int>> slices, string arg)\n         {\n-            // we reached the end of an argument, add the builder's final result\n-            // to our arguments.\n-            argumentBuilder.Trim();\n-            string argValue = argumentBuilder.ToString();\n+            // This shouldn't happen\n+            int firstSlice = 0;\n+            int lastSlice = slices.Count - 1;\n+            if (lastSlice == -1)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+            // from end\n+            int lastSliceIdx = slices[slices.Count - 1].Item2;\n+            // from start\n+            int firstSliceIdx = slices[0].Item1;\n \n-            // We support passing of null through the argument constant value null\n-            if (String.Equals(\"null\", argValue, StringComparison.OrdinalIgnoreCase))\n+            // Trim from the start\n+            while (firstSlice <= lastSlice && Char.IsWhiteSpace(arg, firstSliceIdx))\n             {\n-                arguments.Add(null);\n+                firstSliceIdx++;\n+                if (firstSliceIdx > slices[firstSlice].Item2 && firstSlice < lastSlice)\n+                {\n+                    firstSlice++;\n+                    firstSliceIdx = slices[firstSlice].Item1;\n+                }\n             }\n-            else\n+\n+            // Trim from the end.\n+            // There is some extra logic here to avoid edge case where we would trim a whitespace only character with\n+            // one slice from the start, and then once more from the end, resulting in invalid indices.\n+            while (((firstSlice < lastSlice) || (firstSlice == lastSlice && firstSliceIdx < lastSliceIdx)) && Char.IsWhiteSpace(arg, lastSliceIdx - 1))\n             {\n-                if (argValue.Length > 0)\n+                lastSliceIdx--;\n+                if (slices[lastSlice].Item1 > lastSliceIdx && firstSlice < lastSlice)\n                 {\n-                    if (argValue[0] == '\\'' && argValue[argValue.Length - 1] == '\\'')\n-                    {\n-                        arguments.Add(argValue.Trim(s_singleQuoteChar));\n-                    }\n-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')\n-                    {\n-                        arguments.Add(argValue.Trim(s_backtickChar));\n-                    }\n-                    else if (argValue[0] == '\"' && argValue[argValue.Length - 1] == '\"')\n-                    {\n-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));\n-                    }\n-                    else\n-                    {\n-                        arguments.Add(argValue);\n-                    }\n+                    lastSlice--;\n+                    lastSliceIdx = slices[lastSlice].Item2;\n                 }\n-                else\n+            }\n+\n+            if (firstSliceIdx == lastSliceIdx)\n+            {\n+                arguments.Add(\"\");\n+                return;\n+            }\n+\n+            bool removedQuotes = false;\n+\n+            // If the argument is in quotes, we want to remove those\n+            if ((arg[firstSliceIdx] == '\\'' && arg[lastSliceIdx - 1] == '\\'') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '`' && arg[lastSliceIdx - 1] == '`') ||\n+                (arg[firstSliceIdx] == '\"' && arg[lastSliceIdx - 1] == '\"'))\n+            {\n+                ++firstSliceIdx;\n+                --lastSliceIdx;\n+                removedQuotes = true;\n+\n+                // Check yet again if we're still in the correct slice boundaries, this could've changed if we've trimmed.\n+                if (firstSliceIdx > slices[firstSlice].Item2 && ++firstSlice < lastSlice)",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it this?\r\n\r\n```suggestion\r\n                    if (expressionCapture.Captures?.Any(capture =>\r\n                        !string.Equals(capture.FunctionName, \"Count\", StringComparison.OrdinalIgnoreCase) ||\r\n                        !string.Equals(capture.FunctionName, \"AnyHaveMetadataValue\", StringComparison.OrdinalIgnoreCase)\r\n                        )\r\n```",
              "createdAt": "2024-12-10T12:33:07Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -2012,6 +2061,23 @@ internal static bool ExpandExpressionCapture<S>(\n                 // If there are no items of the given type, then bail out early\n                 if (itemsOfType.Count == 0)\n                 {\n+                    if (expressionCapture.Captures?.Any(capture =>\n+                        {\n+                            if (string.Equals(capture.FunctionName, \"Count\", StringComparison.OrdinalIgnoreCase))\n+                            {\n+                                return true;\n+                            }\n+                            if (string.Equals(capture.FunctionName, \"AnyHaveMetadataValue\", StringComparison.OrdinalIgnoreCase))\n+                            {\n+                                return true;\n+                            }\n+                            return false;\n+                        }) != true)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "My brain is kind of fried at the moment, so I pasted this into .netfiddle:\r\n```\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\t\t\t\t\t\r\npublic class Program\r\n{\r\n\tpublic static void Main()\r\n\t{\r\n\t\t var x = new List<string>();\r\n\t\t x.Add(\"Count\");\r\n\t\t if (x.Any(capture =>\r\n                        {\r\n                            if (string.Equals(capture, \"Count\", StringComparison.OrdinalIgnoreCase))\r\n                            {\r\n                                return true;\r\n                            }\r\n                            if (string.Equals(capture, \"AnyHaveMetadataValue\", StringComparison.OrdinalIgnoreCase))\r\n                            {\r\n                                return true;\r\n                            }\r\n                            return false;\r\n                        }) != true)\r\n\t\t {\r\n\t\t \tConsole.WriteLine(\"hit1\");\r\n\t\t }\r\n\t    if (x.Any(capture =>\r\n\t\t\t\t\t\t\t\t\t\t\t\t !string.Equals(capture, \"Count\", StringComparison.OrdinalIgnoreCase) ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t !string.Equals(capture, \"AnyHaveMetadataValue\", StringComparison.OrdinalIgnoreCase)))\r\n\t\t\t{\r\n\t\t\tConsole.WriteLine(\"hit2\");\r\n\t\t\t}\r\n\t}\r\n}\r\n```\r\nThese aren't equivalent - empty collection hits only the first case, collection with \"Count\" hits only the second one.\r\nI'll look at it closer when refactoring, some simplification along these lines is definitely possible, but I found myself repeatedly getting lost in the logic so in the end I simplified at the cost of verbosity.",
              "createdAt": "2024-12-10T15:10:37Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -2012,6 +2061,23 @@ internal static bool ExpandExpressionCapture<S>(\n                 // If there are no items of the given type, then bail out early\n                 if (itemsOfType.Count == 0)\n                 {\n+                    if (expressionCapture.Captures?.Any(capture =>\n+                        {\n+                            if (string.Equals(capture.FunctionName, \"Count\", StringComparison.OrdinalIgnoreCase))\n+                            {\n+                                return true;\n+                            }\n+                            if (string.Equals(capture.FunctionName, \"AnyHaveMetadataValue\", StringComparison.OrdinalIgnoreCase))\n+                            {\n+                                return true;\n+                            }\n+                            return false;\n+                        }) != true)",
              "author": {
                "login": "SimaTian"
              }
            },
            {
              "body": "Yuliia suggested a similar change with a similar simplification. In the end I went with that one.",
              "createdAt": "2024-12-12T10:05:08Z",
              "path": "src/Build/Evaluation/Expander.cs",
              "diffHunk": "@@ -2012,6 +2061,23 @@ internal static bool ExpandExpressionCapture<S>(\n                 // If there are no items of the given type, then bail out early\n                 if (itemsOfType.Count == 0)\n                 {\n+                    if (expressionCapture.Captures?.Any(capture =>\n+                        {\n+                            if (string.Equals(capture.FunctionName, \"Count\", StringComparison.OrdinalIgnoreCase))\n+                            {\n+                                return true;\n+                            }\n+                            if (string.Equals(capture.FunctionName, \"AnyHaveMetadataValue\", StringComparison.OrdinalIgnoreCase))\n+                            {\n+                                return true;\n+                            }\n+                            return false;\n+                        }) != true)",
              "author": {
                "login": "SimaTian"
              }
            }
          ]
        }
      }
    ]
  }
}