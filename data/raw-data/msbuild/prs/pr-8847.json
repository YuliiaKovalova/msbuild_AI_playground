{
  "number": 8847,
  "title": "Avoid OfTypeIterators when enumerating project xml children",
  "body": "### Summary\r\n\r\nPerformance improvement with noticeable impact when using static graph in large repos.\r\n\r\n### Customer Impact\r\n\r\n~10% reduction in static graph construction time in a specific large repo.\r\n\r\n### Regression?\r\n\r\nNo.\r\n\r\n### Testing\r\n\r\nAutomated tests, manual runs on reporting repo showing noticeable improvement.\r\n\r\n### Risk\r\n\r\nLow.\r\n\r\n### Details\r\n\r\nAvoid OfTypeIterators when enumerating project xml children\r\n\r\nIn a recent profile of a graph construction, it was observed that a large amount of boxing was happening for `ProjectElementSiblingEnumerable`. This change simplifies how xml children are enumerated by adding an internal `ChildrenEnumerable` property which directly exposes the `ProjectElementSiblingEnumerable` which should avoid boxing, at least in some code paths (the public API makes it hard to avoid everywhere...).\r\n\r\nAdditionally, a very common usage of enumerating children was to do `Children.OfType<T>` and wrap it in a `ReadOnlyCollection<T>`, so I introduced a `GetChildrenOfType` (and `GetChildrenReversedOfType`) method which exposes an `ICollection<T>` which does the same thing but without the boxing of `ProjectElementSiblingEnumerable` and without the `OfType` class. It's just 1 collection allocation.\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/6445614/8b0c2a5f-19d3-4818-9f72-1452fb155c2e)\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/6445614/7058c65d-ca60-4dda-8f5b-6100104cd8e7)\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/6445614/18a99a8a-31b2-4bd3-99e8-e29abfba509e)\r\n",
  "state": "MERGED",
  "createdAt": "2023-06-06T23:18:49Z",
  "updatedAt": "2023-07-12T21:26:20Z",
  "closedAt": "2023-07-12T21:26:20Z",
  "mergedAt": "2023-07-12T21:26:20Z",
  "additions": 278,
  "deletions": 113,
  "changedFiles": 27,
  "headRefName": "perf-xml-child-enumeration",
  "isDraft": false,
  "author": {
    "login": "dfederm"
  },
  "milestone": {
    "title": "VS 17.7"
  },
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Servicing-consider"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "4f2a020879c7a7f1f7c2f95beb4952b97412dcac",
          "message": "Avoid boxing when enumerating project xml children\n\nIn a recent profile of a graph construction, it was observed that a\nlarge amount of boxing was happening for\nProjectElementSiblingEnumerable. This change simplifies how xml children\nare enumerated by adding an internal ChildrenEnumerable property which\ndirectly exposes the ProjectElementSiblingEnumerable which should avoid\nboxing, at least in some code paths (the public API makes it hard to\navoid everywhere...).\n\nAdditionally, a very common usage of enumerating children was to do\nChildren.OfType<T> and wrap it in a ReadOnlyCollection<T>, so I\nintroduced a GetChildrenOfType (and GetChildrenReversedOfType) method\nwhich exposes an ICollection<T> which does the same thing but without\nthe boxing of ProjectElementSiblingEnumerable and without the OfType\nclass. It's just 1 collection allocation.",
          "committedDate": "2023-07-12T18:48:57Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "From the thread which initiated this:\r\n\r\nInitial:\r\n> Static graph loaded in 156.466 seconds: 913 nodes, 12842 edges\r\n\r\nAnd after applying the changes:\r\n> I did a quick run with David PR + origin/main and the graph startup improved by 10-15s.  GC times is still high.\r\n\r\nSo still work to do, but this incrementally helps.",
        "createdAt": "2023-06-13T16:42:13Z",
        "author": {
          "login": "dfederm"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Maybe I'm wrong here, but I guess all of the changes that cast `GetChildrenOfType` to `ICollection` do nothing here, because you cast you collection to `ICollection` and so the consumer of this code iterating through `ICollection` interface won't call a special `GetEnumerator` method that returns your struct, but rather will call a method on the interface that still would box the iterator.",
              "createdAt": "2023-06-06T23:32:35Z",
              "path": "src/Build/Construction/ProjectTargetElement.cs",
              "diffHunk": "@@ -58,22 +58,22 @@ private ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootEleme\n         /// <summary>\n         /// Get an enumerator over any child item groups\n         /// </summary>\n-        public ICollection<ProjectItemGroupElement> ItemGroups => new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());\n+        public ICollection<ProjectItemGroupElement> ItemGroups => GetChildrenOfType<ProjectItemGroupElement>();",
              "author": {
                "login": "SergeyTeplyakov"
              }
            },
            {
              "body": "Bah, I think you're right. This would only save on the OfTypeIterators. Maybe still substantial enough to be worth it, but it's less compelling now. Might need to actually compare and gather data.",
              "createdAt": "2023-06-06T23:39:49Z",
              "path": "src/Build/Construction/ProjectTargetElement.cs",
              "diffHunk": "@@ -58,22 +58,22 @@ private ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootEleme\n         /// <summary>\n         /// Get an enumerator over any child item groups\n         /// </summary>\n-        public ICollection<ProjectItemGroupElement> ItemGroups => new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());\n+        public ICollection<ProjectItemGroupElement> ItemGroups => GetChildrenOfType<ProjectItemGroupElement>();",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "For public consumers of these types, you can fix this with a [bit of a hack](https://devdiv.visualstudio.com/DevDiv/_git/CPS?path=/src/Microsoft.VisualStudio.ProjectSystem/Utilities/IEnumerableExtensions.cs) which we use around the tree in situations where we can't change the public API.\r\n\r\nBasically if you make the underlying ICollection<T> a known public type, external consumers (like CPS, AnyCode, etc) can cast to and sniff for said type and avoid the boxing by calling the direct enumerator.",
              "createdAt": "2023-06-07T07:39:16Z",
              "path": "src/Build/Construction/ProjectTargetElement.cs",
              "diffHunk": "@@ -58,22 +58,22 @@ private ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootEleme\n         /// <summary>\n         /// Get an enumerator over any child item groups\n         /// </summary>\n-        public ICollection<ProjectItemGroupElement> ItemGroups => new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());\n+        public ICollection<ProjectItemGroupElement> ItemGroups => GetChildrenOfType<ProjectItemGroupElement>();",
              "author": {
                "login": "davkean"
              }
            },
            {
              "body": "Gotcha. I'm not sure we can make it a known public type very easily though since the existing impl is lazy. It's effectively a linked list \"view\" on the underlying Xml object model, and while the enumerator may box, it's not knowable whether allocating the full collection would be beneficial or not.\r\n\r\nConsider a naive consumer who just enumerates. With these changes, it would allocate the collection (just a wrapper) and box the enumerator. If we returned a well-known collection (let's say List<T>), we'd have to enumerate the full collection and populate the whole collection, which takes more memory due to the underlying storage (array).",
              "createdAt": "2023-06-07T20:31:36Z",
              "path": "src/Build/Construction/ProjectTargetElement.cs",
              "diffHunk": "@@ -58,22 +58,22 @@ private ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootEleme\n         /// <summary>\n         /// Get an enumerator over any child item groups\n         /// </summary>\n-        public ICollection<ProjectItemGroupElement> ItemGroups => new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());\n+        public ICollection<ProjectItemGroupElement> ItemGroups => GetChildrenOfType<ProjectItemGroupElement>();",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I guess the only benefits you're getting is here. But I'm curious if you can avoid the collection allocation here as well by having a property 'ChildrenEnumerator' that will return your struct enumerator?",
              "createdAt": "2023-06-06T23:33:27Z",
              "path": "src/Build/Definition/Toolset.cs",
              "diffHunk": "@@ -1062,7 +1062,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer\n                             preserveFormatting: false);\n                     }\n \n-                    foreach (ProjectElement elementXml in projectRootElement.Children)\n+                    foreach (ProjectElement elementXml in projectRootElement.ChildrenInternal)",
              "author": {
                "login": "SergeyTeplyakov"
              }
            },
            {
              "body": "Renamed `ChildrenInternal` -> `ChildrenEnumerable` for clarity",
              "createdAt": "2023-06-06T23:51:04Z",
              "path": "src/Build/Definition/Toolset.cs",
              "diffHunk": "@@ -1062,7 +1062,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer\n                             preserveFormatting: false);\n                     }\n \n-                    foreach (ProjectElement elementXml in projectRootElement.Children)\n+                    foreach (ProjectElement elementXml in projectRootElement.ChildrenInternal)",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "lol, due to the hidden copy that C# performs. :)",
              "createdAt": "2023-06-07T07:33:20Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -721,44 +755,180 @@ private static bool TrySearchRightSiblings(ProjectElement initialElement, Predic\n             return referenceSibling != null;\n         }\n \n+        internal sealed class ProjectElementSiblingSubTypeCollection<T> : ICollection<T>, ICollection\n+            where T : ProjectElement\n+        {\n+            private readonly ProjectElement _initial;\n+            private readonly bool _forwards;\n+            private List<T> _realizedElements;\n+\n+            internal ProjectElementSiblingSubTypeCollection(ProjectElement initial, bool forwards = true)\n+            {\n+                _initial = initial;\n+                _forwards = forwards;\n+            }\n+\n+            public int Count => RealizedElements.Count;\n+\n+            public bool IsReadOnly => true;\n+\n+            bool ICollection.IsSynchronized => false;\n+\n+            object ICollection.SyncRoot => this;\n+\n+            private List<T> RealizedElements\n+            {\n+                get\n+                {\n+                    if (_realizedElements == null)\n+                    {\n+                        // Note! Don't use the List ctor which takes an IEnumerable as it casts to an ICollection and calls Count,\n+                        // which leads to a StackOverflow exception in this implementation (see Count above)\n+                        List<T> list = new();\n+                        foreach (T element in this)\n+                        {\n+                            list.Add(element);\n+                        }\n+\n+                        _realizedElements = list;\n+                    }\n+\n+                    return _realizedElements;\n+                }\n+            }\n+\n+            public void Add(T item) => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public void Clear() => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public bool Contains(T item) => RealizedElements.Contains(item);\n+\n+            public void CopyTo(T[] array, int arrayIndex)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                if (_realizedElements != null)\n+                {\n+                    _realizedElements.CopyTo(array, arrayIndex);\n+                }\n+                else\n+                {\n+                    int i = arrayIndex;\n+                    foreach (T entry in this)\n+                    {\n+                        array[i] = entry;\n+                        i++;\n+                    }\n+                }\n+            }\n+\n+            public bool Remove(T item)\n+            {\n+                ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+                return false;\n+            }\n+\n+            public IEnumerator<T> GetEnumerator() => new Enumerator(_initial, _forwards);\n+\n+            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n+\n+            void ICollection.CopyTo(Array array, int index)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                int i = index;\n+                foreach (T entry in this)\n+                {\n+                    array.SetValue(entry, i);\n+                    i++;\n+                }\n+            }\n+\n+            public struct Enumerator : IEnumerator<T>\n+            {\n+                // Note! Should not be readonly or we run into infinite loop issues with mutable structs",
              "author": {
                "login": "davkean"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't know if MSBuild has the ability to [ban APIs](https://github.com/DotNetAnalyzers/BannedApiAnalyzer) but I would consider banning usage of Children inside of MSBuild itself to avoid accidentally opt'ing into the boxing again. Can't obsolete because that would affect external consumers.",
              "createdAt": "2023-06-07T07:43:01Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -64,32 +65,41 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer\n         /// </summary>\n         public IEnumerable<ProjectElement> AllChildren => GetChildrenRecursively();\n \n+        internal IEnumerable<T> GetAllChildrenOfType<T>()\n+            where T : ProjectElement\n+            => GetChildrenRecursivelyOfType<T>();\n+\n         /// <summary>\n         /// Get enumerable over all the children\n         /// </summary>\n         public ICollection<ProjectElement> Children\n         {\n             [DebuggerStepThrough]\n-            get\n-            {\n-                return new Collections.ReadOnlyCollection<ProjectElement>(\n-                        new ProjectElementSiblingEnumerable(FirstChild));\n-            }\n+            get => new Collections.ReadOnlyCollection<ProjectElement>(new ProjectElementSiblingEnumerable(FirstChild));\n         }\n \n+        /// <summary>\n+        /// Use this instead of <see cref=\"Children\"/> to avoid boxing.\n+        /// </summary>\n+        internal ProjectElementSiblingEnumerable ChildrenEnumerable => new ProjectElementSiblingEnumerable(FirstChild);",
              "author": {
                "login": "davkean"
              }
            },
            {
              "body": "Hmm, interesting idea. It seems to work except I'm unsure how to handle this for UTs since it's a internal member and not all UTs have visibility. I _could_ InternalsVisibleTo, but not sure if that's desirable here or not (MSBuild team feel free to express an opinion)\r\n\r\nNote to self in case it's decided to do this:\r\n```\r\nP:Microsoft.Build.Construction.ProjectElementContainer.Children;Use ChildrenEnumerable instead to avoid boxing\r\n```",
              "createdAt": "2023-06-07T20:41:51Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -64,32 +65,41 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer\n         /// </summary>\n         public IEnumerable<ProjectElement> AllChildren => GetChildrenRecursively();\n \n+        internal IEnumerable<T> GetAllChildrenOfType<T>()\n+            where T : ProjectElement\n+            => GetChildrenRecursivelyOfType<T>();\n+\n         /// <summary>\n         /// Get enumerable over all the children\n         /// </summary>\n         public ICollection<ProjectElement> Children\n         {\n             [DebuggerStepThrough]\n-            get\n-            {\n-                return new Collections.ReadOnlyCollection<ProjectElement>(\n-                        new ProjectElementSiblingEnumerable(FirstChild));\n-            }\n+            get => new Collections.ReadOnlyCollection<ProjectElement>(new ProjectElementSiblingEnumerable(FirstChild));\n         }\n \n+        /// <summary>\n+        /// Use this instead of <see cref=\"Children\"/> to avoid boxing.\n+        /// </summary>\n+        internal ProjectElementSiblingEnumerable ChildrenEnumerable => new ProjectElementSiblingEnumerable(FirstChild);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "We can skip the ban enforcement in UTs. I'll push a commit with that shortly.",
              "createdAt": "2023-06-28T16:23:21Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -64,32 +65,41 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer\n         /// </summary>\n         public IEnumerable<ProjectElement> AllChildren => GetChildrenRecursively();\n \n+        internal IEnumerable<T> GetAllChildrenOfType<T>()\n+            where T : ProjectElement\n+            => GetChildrenRecursivelyOfType<T>();\n+\n         /// <summary>\n         /// Get enumerable over all the children\n         /// </summary>\n         public ICollection<ProjectElement> Children\n         {\n             [DebuggerStepThrough]\n-            get\n-            {\n-                return new Collections.ReadOnlyCollection<ProjectElement>(\n-                        new ProjectElementSiblingEnumerable(FirstChild));\n-            }\n+            get => new Collections.ReadOnlyCollection<ProjectElement>(new ProjectElementSiblingEnumerable(FirstChild));\n         }\n \n+        /// <summary>\n+        /// Use this instead of <see cref=\"Children\"/> to avoid boxing.\n+        /// </summary>\n+        internal ProjectElementSiblingEnumerable ChildrenEnumerable => new ProjectElementSiblingEnumerable(FirstChild);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Because these call through an yield enumerator, these allocatate either way. I think you are aware of this, but wanted to call it out.",
              "createdAt": "2023-06-07T07:46:52Z",
              "path": "src/Build/Construction/ProjectRootElement.cs",
              "diffHunk": "@@ -287,81 +287,81 @@ public override string Condition\n         /// <remarks>\n         /// The name is inconsistent to make it more understandable, per API review.\n         /// </remarks>\n-        public ICollection<ProjectChooseElement> ChooseElements => new ReadOnlyCollection<ProjectChooseElement>(Children.OfType<ProjectChooseElement>());\n+        public ICollection<ProjectChooseElement> ChooseElements => GetChildrenOfType<ProjectChooseElement>();\n \n         /// <summary>\n         /// Get a read-only collection of the child item definition groups, if any\n         /// </summary>\n-        public ICollection<ProjectItemDefinitionGroupElement> ItemDefinitionGroups => new ReadOnlyCollection<ProjectItemDefinitionGroupElement>(Children.OfType<ProjectItemDefinitionGroupElement>());\n+        public ICollection<ProjectItemDefinitionGroupElement> ItemDefinitionGroups => GetChildrenOfType<ProjectItemDefinitionGroupElement>();\n \n         /// <summary>\n         /// Get a read-only collection of the child item definitions, if any, in all item definition groups anywhere in the project file.\n         /// </summary>\n-        public ICollection<ProjectItemDefinitionElement> ItemDefinitions => new ReadOnlyCollection<ProjectItemDefinitionElement>(AllChildren.OfType<ProjectItemDefinitionElement>());\n+        public ICollection<ProjectItemDefinitionElement> ItemDefinitions => new ReadOnlyCollection<ProjectItemDefinitionElement>(GetAllChildrenOfType<ProjectItemDefinitionElement>());",
              "author": {
                "login": "davkean"
              }
            },
            {
              "body": "Yep, but it should allocate less (no OfTypeIterator). I'm unsure whether I should create yet another struct enumerable for this, but maybe not since these only seem to be exposed publicly and not used by MSBuild itself.",
              "createdAt": "2023-06-07T20:45:18Z",
              "path": "src/Build/Construction/ProjectRootElement.cs",
              "diffHunk": "@@ -287,81 +287,81 @@ public override string Condition\n         /// <remarks>\n         /// The name is inconsistent to make it more understandable, per API review.\n         /// </remarks>\n-        public ICollection<ProjectChooseElement> ChooseElements => new ReadOnlyCollection<ProjectChooseElement>(Children.OfType<ProjectChooseElement>());\n+        public ICollection<ProjectChooseElement> ChooseElements => GetChildrenOfType<ProjectChooseElement>();\n \n         /// <summary>\n         /// Get a read-only collection of the child item definition groups, if any\n         /// </summary>\n-        public ICollection<ProjectItemDefinitionGroupElement> ItemDefinitionGroups => new ReadOnlyCollection<ProjectItemDefinitionGroupElement>(Children.OfType<ProjectItemDefinitionGroupElement>());\n+        public ICollection<ProjectItemDefinitionGroupElement> ItemDefinitionGroups => GetChildrenOfType<ProjectItemDefinitionGroupElement>();\n \n         /// <summary>\n         /// Get a read-only collection of the child item definitions, if any, in all item definition groups anywhere in the project file.\n         /// </summary>\n-        public ICollection<ProjectItemDefinitionElement> ItemDefinitions => new ReadOnlyCollection<ProjectItemDefinitionElement>(AllChildren.OfType<ProjectItemDefinitionElement>());\n+        public ICollection<ProjectItemDefinitionElement> ItemDefinitions => new ReadOnlyCollection<ProjectItemDefinitionElement>(GetAllChildrenOfType<ProjectItemDefinitionElement>());",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This can be `readonly ref`.",
              "createdAt": "2023-06-07T07:51:08Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -721,44 +755,180 @@ private static bool TrySearchRightSiblings(ProjectElement initialElement, Predic\n             return referenceSibling != null;\n         }\n \n+        internal sealed class ProjectElementSiblingSubTypeCollection<T> : ICollection<T>, ICollection\n+            where T : ProjectElement\n+        {\n+            private readonly ProjectElement _initial;\n+            private readonly bool _forwards;\n+            private List<T> _realizedElements;\n+\n+            internal ProjectElementSiblingSubTypeCollection(ProjectElement initial, bool forwards = true)\n+            {\n+                _initial = initial;\n+                _forwards = forwards;\n+            }\n+\n+            public int Count => RealizedElements.Count;\n+\n+            public bool IsReadOnly => true;\n+\n+            bool ICollection.IsSynchronized => false;\n+\n+            object ICollection.SyncRoot => this;\n+\n+            private List<T> RealizedElements\n+            {\n+                get\n+                {\n+                    if (_realizedElements == null)\n+                    {\n+                        // Note! Don't use the List ctor which takes an IEnumerable as it casts to an ICollection and calls Count,\n+                        // which leads to a StackOverflow exception in this implementation (see Count above)\n+                        List<T> list = new();\n+                        foreach (T element in this)\n+                        {\n+                            list.Add(element);\n+                        }\n+\n+                        _realizedElements = list;\n+                    }\n+\n+                    return _realizedElements;\n+                }\n+            }\n+\n+            public void Add(T item) => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public void Clear() => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public bool Contains(T item) => RealizedElements.Contains(item);\n+\n+            public void CopyTo(T[] array, int arrayIndex)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                if (_realizedElements != null)\n+                {\n+                    _realizedElements.CopyTo(array, arrayIndex);\n+                }\n+                else\n+                {\n+                    int i = arrayIndex;\n+                    foreach (T entry in this)\n+                    {\n+                        array[i] = entry;\n+                        i++;\n+                    }\n+                }\n+            }\n+\n+            public bool Remove(T item)\n+            {\n+                ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+                return false;\n+            }\n+\n+            public IEnumerator<T> GetEnumerator() => new Enumerator(_initial, _forwards);\n+\n+            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n+\n+            void ICollection.CopyTo(Array array, int index)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                int i = index;\n+                foreach (T entry in this)\n+                {\n+                    array.SetValue(entry, i);\n+                    i++;\n+                }\n+            }\n+\n+            public struct Enumerator : IEnumerator<T>",
              "author": {
                "login": "davkean"
              }
            },
            {
              "body": "Can't be `readonly` since it's mutable (`_current`). Unless there's some magic I'm unaware of that can be done.",
              "createdAt": "2023-06-07T20:46:43Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -721,44 +755,180 @@ private static bool TrySearchRightSiblings(ProjectElement initialElement, Predic\n             return referenceSibling != null;\n         }\n \n+        internal sealed class ProjectElementSiblingSubTypeCollection<T> : ICollection<T>, ICollection\n+            where T : ProjectElement\n+        {\n+            private readonly ProjectElement _initial;\n+            private readonly bool _forwards;\n+            private List<T> _realizedElements;\n+\n+            internal ProjectElementSiblingSubTypeCollection(ProjectElement initial, bool forwards = true)\n+            {\n+                _initial = initial;\n+                _forwards = forwards;\n+            }\n+\n+            public int Count => RealizedElements.Count;\n+\n+            public bool IsReadOnly => true;\n+\n+            bool ICollection.IsSynchronized => false;\n+\n+            object ICollection.SyncRoot => this;\n+\n+            private List<T> RealizedElements\n+            {\n+                get\n+                {\n+                    if (_realizedElements == null)\n+                    {\n+                        // Note! Don't use the List ctor which takes an IEnumerable as it casts to an ICollection and calls Count,\n+                        // which leads to a StackOverflow exception in this implementation (see Count above)\n+                        List<T> list = new();\n+                        foreach (T element in this)\n+                        {\n+                            list.Add(element);\n+                        }\n+\n+                        _realizedElements = list;\n+                    }\n+\n+                    return _realizedElements;\n+                }\n+            }\n+\n+            public void Add(T item) => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public void Clear() => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public bool Contains(T item) => RealizedElements.Contains(item);\n+\n+            public void CopyTo(T[] array, int arrayIndex)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                if (_realizedElements != null)\n+                {\n+                    _realizedElements.CopyTo(array, arrayIndex);\n+                }\n+                else\n+                {\n+                    int i = arrayIndex;\n+                    foreach (T entry in this)\n+                    {\n+                        array[i] = entry;\n+                        i++;\n+                    }\n+                }\n+            }\n+\n+            public bool Remove(T item)\n+            {\n+                ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+                return false;\n+            }\n+\n+            public IEnumerator<T> GetEnumerator() => new Enumerator(_initial, _forwards);\n+\n+            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n+\n+            void ICollection.CopyTo(Array array, int index)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                int i = index;\n+                foreach (T entry in this)\n+                {\n+                    array.SetValue(entry, i);\n+                    i++;\n+                }\n+            }\n+\n+            public struct Enumerator : IEnumerator<T>",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Also can't be a `ref struct` because `ref struct` cannot implement interfaces",
              "createdAt": "2023-06-07T20:47:34Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -721,44 +755,180 @@ private static bool TrySearchRightSiblings(ProjectElement initialElement, Predic\n             return referenceSibling != null;\n         }\n \n+        internal sealed class ProjectElementSiblingSubTypeCollection<T> : ICollection<T>, ICollection\n+            where T : ProjectElement\n+        {\n+            private readonly ProjectElement _initial;\n+            private readonly bool _forwards;\n+            private List<T> _realizedElements;\n+\n+            internal ProjectElementSiblingSubTypeCollection(ProjectElement initial, bool forwards = true)\n+            {\n+                _initial = initial;\n+                _forwards = forwards;\n+            }\n+\n+            public int Count => RealizedElements.Count;\n+\n+            public bool IsReadOnly => true;\n+\n+            bool ICollection.IsSynchronized => false;\n+\n+            object ICollection.SyncRoot => this;\n+\n+            private List<T> RealizedElements\n+            {\n+                get\n+                {\n+                    if (_realizedElements == null)\n+                    {\n+                        // Note! Don't use the List ctor which takes an IEnumerable as it casts to an ICollection and calls Count,\n+                        // which leads to a StackOverflow exception in this implementation (see Count above)\n+                        List<T> list = new();\n+                        foreach (T element in this)\n+                        {\n+                            list.Add(element);\n+                        }\n+\n+                        _realizedElements = list;\n+                    }\n+\n+                    return _realizedElements;\n+                }\n+            }\n+\n+            public void Add(T item) => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public void Clear() => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public bool Contains(T item) => RealizedElements.Contains(item);\n+\n+            public void CopyTo(T[] array, int arrayIndex)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                if (_realizedElements != null)\n+                {\n+                    _realizedElements.CopyTo(array, arrayIndex);\n+                }\n+                else\n+                {\n+                    int i = arrayIndex;\n+                    foreach (T entry in this)\n+                    {\n+                        array[i] = entry;\n+                        i++;\n+                    }\n+                }\n+            }\n+\n+            public bool Remove(T item)\n+            {\n+                ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+                return false;\n+            }\n+\n+            public IEnumerator<T> GetEnumerator() => new Enumerator(_initial, _forwards);\n+\n+            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n+\n+            void ICollection.CopyTo(Array array, int index)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                int i = index;\n+                foreach (T entry in this)\n+                {\n+                    array.SetValue(entry, i);\n+                    i++;\n+                }\n+            }\n+\n+            public struct Enumerator : IEnumerator<T>",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Indeed. For future reference, C# sniffs IEnumerable<T>/IEnumerable<T> by shape so interfaces aren't needed.",
              "createdAt": "2023-06-08T07:40:58Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -721,44 +755,180 @@ private static bool TrySearchRightSiblings(ProjectElement initialElement, Predic\n             return referenceSibling != null;\n         }\n \n+        internal sealed class ProjectElementSiblingSubTypeCollection<T> : ICollection<T>, ICollection\n+            where T : ProjectElement\n+        {\n+            private readonly ProjectElement _initial;\n+            private readonly bool _forwards;\n+            private List<T> _realizedElements;\n+\n+            internal ProjectElementSiblingSubTypeCollection(ProjectElement initial, bool forwards = true)\n+            {\n+                _initial = initial;\n+                _forwards = forwards;\n+            }\n+\n+            public int Count => RealizedElements.Count;\n+\n+            public bool IsReadOnly => true;\n+\n+            bool ICollection.IsSynchronized => false;\n+\n+            object ICollection.SyncRoot => this;\n+\n+            private List<T> RealizedElements\n+            {\n+                get\n+                {\n+                    if (_realizedElements == null)\n+                    {\n+                        // Note! Don't use the List ctor which takes an IEnumerable as it casts to an ICollection and calls Count,\n+                        // which leads to a StackOverflow exception in this implementation (see Count above)\n+                        List<T> list = new();\n+                        foreach (T element in this)\n+                        {\n+                            list.Add(element);\n+                        }\n+\n+                        _realizedElements = list;\n+                    }\n+\n+                    return _realizedElements;\n+                }\n+            }\n+\n+            public void Add(T item) => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public void Clear() => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public bool Contains(T item) => RealizedElements.Contains(item);\n+\n+            public void CopyTo(T[] array, int arrayIndex)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                if (_realizedElements != null)\n+                {\n+                    _realizedElements.CopyTo(array, arrayIndex);\n+                }\n+                else\n+                {\n+                    int i = arrayIndex;\n+                    foreach (T entry in this)\n+                    {\n+                        array[i] = entry;\n+                        i++;\n+                    }\n+                }\n+            }\n+\n+            public bool Remove(T item)\n+            {\n+                ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+                return false;\n+            }\n+\n+            public IEnumerator<T> GetEnumerator() => new Enumerator(_initial, _forwards);\n+\n+            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n+\n+            void ICollection.CopyTo(Array array, int index)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                int i = index;\n+                foreach (T entry in this)\n+                {\n+                    array.SetValue(entry, i);\n+                    i++;\n+                }\n+            }\n+\n+            public struct Enumerator : IEnumerator<T>",
              "author": {
                "login": "davkean"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If the enumerator from this generator appears in traces, it could be replaced with a non-allocating struct enumerator.",
              "createdAt": "2023-06-07T13:39:33Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -687,6 +697,30 @@ private IEnumerable<ProjectElement> GetChildrenRecursively()\n             }\n         }\n \n+        private IEnumerable<T> GetChildrenRecursivelyOfType<T>()",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "These only seem to be exposed publicly and not used by MSBuild itself, so I'll defer this one. Maybe if VS uses these heavily and it shows up in traces.",
              "createdAt": "2023-06-07T20:49:00Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -687,6 +697,30 @@ private IEnumerable<ProjectElement> GetChildrenRecursively()\n             }\n         }\n \n+        private IEnumerable<T> GetChildrenRecursivelyOfType<T>()",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This can be readonly",
              "createdAt": "2023-06-08T07:43:33Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -721,44 +755,180 @@ private static bool TrySearchRightSiblings(ProjectElement initialElement, Predic\n             return referenceSibling != null;\n         }\n \n+        internal sealed class ProjectElementSiblingSubTypeCollection<T> : ICollection<T>, ICollection\n+            where T : ProjectElement\n+        {\n+            private readonly ProjectElement _initial;\n+            private readonly bool _forwards;\n+            private List<T> _realizedElements;\n+\n+            internal ProjectElementSiblingSubTypeCollection(ProjectElement initial, bool forwards = true)\n+            {\n+                _initial = initial;\n+                _forwards = forwards;\n+            }\n+\n+            public int Count => RealizedElements.Count;\n+\n+            public bool IsReadOnly => true;\n+\n+            bool ICollection.IsSynchronized => false;\n+\n+            object ICollection.SyncRoot => this;\n+\n+            private List<T> RealizedElements\n+            {\n+                get\n+                {\n+                    if (_realizedElements == null)\n+                    {\n+                        // Note! Don't use the List ctor which takes an IEnumerable as it casts to an ICollection and calls Count,\n+                        // which leads to a StackOverflow exception in this implementation (see Count above)\n+                        List<T> list = new();\n+                        foreach (T element in this)\n+                        {\n+                            list.Add(element);\n+                        }\n+\n+                        _realizedElements = list;\n+                    }\n+\n+                    return _realizedElements;\n+                }\n+            }\n+\n+            public void Add(T item) => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public void Clear() => ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+\n+            public bool Contains(T item) => RealizedElements.Contains(item);\n+\n+            public void CopyTo(T[] array, int arrayIndex)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                if (_realizedElements != null)\n+                {\n+                    _realizedElements.CopyTo(array, arrayIndex);\n+                }\n+                else\n+                {\n+                    int i = arrayIndex;\n+                    foreach (T entry in this)\n+                    {\n+                        array[i] = entry;\n+                        i++;\n+                    }\n+                }\n+            }\n+\n+            public bool Remove(T item)\n+            {\n+                ErrorUtilities.ThrowInvalidOperation(\"OM_NotSupportedReadOnlyCollection\");\n+                return false;\n+            }\n+\n+            public IEnumerator<T> GetEnumerator() => new Enumerator(_initial, _forwards);\n+\n+            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n+\n+            void ICollection.CopyTo(Array array, int index)\n+            {\n+                ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));\n+\n+                int i = index;\n+                foreach (T entry in this)\n+                {\n+                    array.SetValue(entry, i);\n+                    i++;\n+                }\n+            }\n+\n+            public struct Enumerator : IEnumerator<T>\n+            {\n+                // Note! Should not be readonly or we run into infinite loop issues with mutable structs\n+                private ProjectElementSiblingEnumerable.Enumerator _innerEnumerator;\n+                private T _current;\n+\n+                internal Enumerator(ProjectElement initial, bool forwards = true)\n+                {\n+                    _innerEnumerator = new ProjectElementSiblingEnumerable.Enumerator(initial, forwards);\n+                }\n+\n+                public T Current\n+                {\n+                    get\n+                    {\n+                        if (_current != null)\n+                        {\n+                            return _current;\n+                        }\n+\n+                        throw new InvalidOperationException();\n+                    }\n+                }\n+\n+                object IEnumerator.Current => Current;\n+\n+                public readonly void Dispose()\n+                {\n+                }\n+\n+                public bool MoveNext()\n+                {\n+                    while (_innerEnumerator.MoveNext())\n+                    {\n+                        ProjectElement innerCurrent = _innerEnumerator.Current;\n+                        if (innerCurrent is T innerCurrentOfType)\n+                        {\n+                            _current = innerCurrentOfType;\n+                            return true;\n+                        }\n+                    }\n+\n+                    return false;\n+                }\n+\n+                public void Reset()\n+                {\n+                    _innerEnumerator.Reset();\n+                    _current = null;\n+                }\n+            }\n+        }\n+\n         /// <summary>\n         /// Enumerable over a series of sibling ProjectElement objects\n         /// </summary>\n-        private struct ProjectElementSiblingEnumerable : IEnumerable<ProjectElement>\n+        internal struct ProjectElementSiblingEnumerable : IEnumerable<ProjectElement>",
              "author": {
                "login": "davkean"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "for \"recursive children\" I like \"descendants\"",
              "createdAt": "2023-06-09T17:02:08Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -64,32 +65,41 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer\n         /// </summary>\n         public IEnumerable<ProjectElement> AllChildren => GetChildrenRecursively();\n \n+        internal IEnumerable<T> GetAllChildrenOfType<T>()\n+            where T : ProjectElement\n+            => GetChildrenRecursivelyOfType<T>();",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How common would it be that there are no children? In such cases it would be possible to return a singleton empty immutable collection here.",
              "createdAt": "2023-06-12T20:20:29Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -64,32 +65,41 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer\n         /// </summary>\n         public IEnumerable<ProjectElement> AllChildren => GetChildrenRecursively();\n \n+        internal IEnumerable<T> GetAllChildrenOfType<T>()\n+            where T : ProjectElement\n+            => GetChildrenRecursivelyOfType<T>();\n+\n         /// <summary>\n         /// Get enumerable over all the children\n         /// </summary>\n         public ICollection<ProjectElement> Children\n         {\n             [DebuggerStepThrough]\n-            get\n-            {\n-                return new Collections.ReadOnlyCollection<ProjectElement>(\n-                        new ProjectElementSiblingEnumerable(FirstChild));\n-            }\n+            get => new Collections.ReadOnlyCollection<ProjectElement>(new ProjectElementSiblingEnumerable(FirstChild));",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        public IEnumerable<ProjectElement> Descendants => GetDescendants();\r\n```",
              "createdAt": "2023-06-13T12:56:09Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -63,19 +64,23 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer\n         /// Get an enumerator over all children, gotten recursively.\n         /// Walks the children in a depth-first manner.\n         /// </summary>\n-        public IEnumerable<ProjectElement> AllChildren => GetChildrenRecursively();\n+        public IEnumerable<ProjectElement> AllChildren => GetDescendants();",
              "author": {
                "login": "drewnoakes"
              }
            },
            {
              "body": "This is part of the public API, so we can't rename this one.",
              "createdAt": "2023-06-13T13:03:22Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -63,19 +64,23 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer\n         /// Get an enumerator over all children, gotten recursively.\n         /// Walks the children in a depth-first manner.\n         /// </summary>\n-        public IEnumerable<ProjectElement> AllChildren => GetChildrenRecursively();\n+        public IEnumerable<ProjectElement> AllChildren => GetDescendants();",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Maybe the word \"children\" could be replaced with \"descendants\" in the doc comment.",
              "createdAt": "2023-06-13T20:44:13Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -63,19 +64,23 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer\n         /// Get an enumerator over all children, gotten recursively.\n         /// Walks the children in a depth-first manner.\n         /// </summary>\n-        public IEnumerable<ProjectElement> AllChildren => GetChildrenRecursively();\n+        public IEnumerable<ProjectElement> AllChildren => GetDescendants();",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: named args prove that the author, compiler and reader of the code all agree.\r\n\r\n```suggestion\r\n                : new ProjectElementSiblingSubTypeCollection<T>(LastChild, forwards: false);\r\n```\r\n\r\nI read the old code as saying `reverse: false`, which is the inverse.",
              "createdAt": "2023-06-13T13:04:07Z",
              "path": "src/Build/Construction/ProjectElementContainer.cs",
              "diffHunk": "@@ -62,34 +64,53 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer\n         /// Get an enumerator over all children, gotten recursively.\n         /// Walks the children in a depth-first manner.\n         /// </summary>\n-        public IEnumerable<ProjectElement> AllChildren => GetChildrenRecursively();\n+        public IEnumerable<ProjectElement> AllChildren => GetDescendants();\n+\n+        internal IEnumerable<T> GetAllChildrenOfType<T>()\n+            where T : ProjectElement\n+            => FirstChild == null\n+                ? Array.Empty<T>()\n+                : GetDescendantsOfType<T>();\n \n         /// <summary>\n         /// Get enumerable over all the children\n         /// </summary>\n         public ICollection<ProjectElement> Children\n         {\n             [DebuggerStepThrough]\n-            get\n-            {\n-                return new Collections.ReadOnlyCollection<ProjectElement>(\n-                        new ProjectElementSiblingEnumerable(FirstChild));\n-            }\n+            get => FirstChild == null\n+                ? Array.Empty<ProjectElement>()\n+                : new Collections.ReadOnlyCollection<ProjectElement>(new ProjectElementSiblingEnumerable(FirstChild));\n         }\n \n+        /// <summary>\n+        /// Use this instead of <see cref=\"Children\"/> to avoid boxing.\n+        /// </summary>\n+        internal ProjectElementSiblingEnumerable ChildrenEnumerable => new ProjectElementSiblingEnumerable(FirstChild);\n+\n+        internal ProjectElementSiblingSubTypeCollection<T> GetChildrenOfType<T>()\n+            where T : ProjectElement\n+            => FirstChild == null\n+                ? ProjectElementSiblingSubTypeCollection<T>.Empty\n+                : new ProjectElementSiblingSubTypeCollection<T>(FirstChild);\n+\n         /// <summary>\n         /// Get enumerable over all the children, starting from the last\n         /// </summary>\n         public ICollection<ProjectElement> ChildrenReversed\n         {\n             [DebuggerStepThrough]\n-            get\n-            {\n-                return new Collections.ReadOnlyCollection<ProjectElement>(\n-                        new ProjectElementSiblingEnumerable(LastChild, false /* reverse */));\n-            }\n+            get => LastChild == null\n+                ? Array.Empty<ProjectElement>()\n+                : new Collections.ReadOnlyCollection<ProjectElement>(new ProjectElementSiblingEnumerable(LastChild, false /* reverse */));\n         }\n \n+        internal ProjectElementSiblingSubTypeCollection<T> GetChildrenReversedOfType<T>()\n+            where T : ProjectElement\n+            => LastChild == null\n+                ? ProjectElementSiblingSubTypeCollection<T>.Empty\n+                : new ProjectElementSiblingSubTypeCollection<T>(LastChild, false /* reverse */);",
              "author": {
                "login": "drewnoakes"
              }
            }
          ]
        }
      }
    ]
  }
}