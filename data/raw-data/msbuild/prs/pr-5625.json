{
  "number": 5625,
  "title": "Fix cpu core count detection",
  "body": "Attempt to fix #435\r\n\r\n- I'm not sure whether similar code should be needed for Unix support.\r\n- I don't have a machine with > 32 cores to actually test this.\r\n\r\nPotentially relevant:\r\n- https://github.com/dotnet/corefx/pull/25630",
  "state": "MERGED",
  "createdAt": "2020-08-07T17:35:34Z",
  "updatedAt": "2022-09-05T17:36:32Z",
  "closedAt": "2020-09-18T16:39:39Z",
  "mergedAt": "2020-09-18T16:39:39Z",
  "additions": 92,
  "deletions": 0,
  "changedFiles": 2,
  "headRefName": "core-count-detection",
  "isDraft": false,
  "author": {
    "login": "mfkl"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "changewave16.8"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "66c9d1b6875c8956642f33593448c8f5cab27995",
          "message": "Use GetLogicalProcessorInformationEx to detect correct physical CPU count",
          "committedDate": "2020-08-07T17:16:25Z",
          "author": {
            "name": "Martin Finkel",
            "email": "finkel2804@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e5847f6af17ae003d980c7088c07ced4865bc6b4",
          "message": "review: add missing space",
          "committedDate": "2020-08-08T12:52:24Z",
          "author": {
            "name": "Martin Finkel",
            "email": "finkel2804@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8dda027ef621db497fd70290a70d17d0fbac8f3b",
          "message": "reuse previous corefx code\n\nhttps://github.com/dotnet/corefx/blob/8229cb7e33a40b990cdef2fd83a7a021636a89aa/src/Common/src/Interop/Windows/kernel32/Interop.GetLogicalProcessorInformationEx.cs",
          "committedDate": "2020-08-08T12:55:15Z",
          "author": {
            "name": "Martin Finkel",
            "email": "finkel2804@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ff27678592a2c24a735ca6321c6b0dcad31e2110",
          "message": "review feedback",
          "committedDate": "2020-08-11T16:56:23Z",
          "author": {
            "name": "Martin Finkel",
            "email": "finkel2804@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cace7664e7fb040cb2b258f67a276005505be744",
          "message": "Use Environment.Is64BitProcess to detect 32bit process",
          "committedDate": "2020-08-14T13:46:34Z",
          "author": {
            "name": "Martin Finkel",
            "email": "finkel2804@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "70d41ae6e695ad78acc73543dde8093285ae93b2",
          "message": "Add original source permalink",
          "committedDate": "2020-08-14T13:46:47Z",
          "author": {
            "name": "Martin Finkel",
            "email": "finkel2804@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2f6bfed66ba7e5bb63c902efd95d5e0fb86bdde3",
          "message": "split into 2 lines",
          "committedDate": "2020-08-14T13:49:20Z",
          "author": {
            "name": "Martin Finkel",
            "email": "finkel2804@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4223cc2e0c875c527afaf5f67a255c2995c4ebb1",
          "message": "add checks",
          "committedDate": "2020-08-16T10:15:26Z",
          "author": {
            "name": "Martin Finkel",
            "email": "finkel2804@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "deb5671abaf4753d7a7e368aae23c652ca46803a",
          "message": "Revert \"add checks\"\n\nThis reverts commit 4223cc2e0c875c527afaf5f67a255c2995c4ebb1.",
          "committedDate": "2020-08-18T15:32:33Z",
          "author": {
            "name": "Martin Finkel",
            "email": "finkel2804@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4be5f1ddd9835af558faa7ce64891008ee1c784e",
          "message": "review feedback",
          "committedDate": "2020-08-18T15:49:28Z",
          "author": {
            "name": "Martin Finkel",
            "email": "finkel2804@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7eaa217ebb6eaa05679a5643343ed8acc23d1a60",
          "message": "review feedback - preprocessor directive\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2020-08-19T11:27:33Z",
          "author": {
            "name": "mfkl",
            "email": "me@martinfinkel.com"
          }
        }
      },
      {
        "commit": {
          "oid": "919beefcc4c57f2aaae90faf1155489a27026ed7",
          "message": "review feedback - clarify comment\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2020-08-19T11:28:08Z",
          "author": {
            "name": "mfkl",
            "email": "me@martinfinkel.com"
          }
        }
      },
      {
        "commit": {
          "oid": "538737bb47a298fc0316fde6c1be6258fe8ae6e9",
          "message": "Scan processor objects, not groups\n\nWorks around win32 limitation--a group will report only up to 32 processors on a 32-bit process.",
          "committedDate": "2020-09-04T22:28:42Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0d42e7bb95e12700f53c7bdc80da004548a94dd7",
          "message": "Get proc-count the hard way on Windows, period",
          "committedDate": "2020-09-08T15:38:49Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "30eef725ed999668983382a08fa99b06aa908e9c",
          "message": "Rename to Logical core count (since we do the multiplication)",
          "committedDate": "2020-09-08T15:39:12Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f0bb807487d2ebdeef74d6208474a832b0d9cc60",
          "message": "Always use fancy method on .NET Core",
          "committedDate": "2020-09-14T16:25:06Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "> I imagine we do care about linux, but I don't know whether the same API works.\r\n\r\nDon't think so as `GetLogicalProcessorInformationEx` is a win32 API. There are several options for Linux/macOS, unsure which one you'd prefer.\r\n\r\nAlso, shouldn't this cpu checking code be located in https://github.com/dotnet/runtime/blob/96f178d32b7ba62485917ac46ef1edcfd3c2d10d/src/coreclr/src/classlibnative/bcltype/system.cpp#L327 instead?",
        "createdAt": "2020-08-08T13:07:24Z",
        "author": {
          "login": "mfkl"
        }
      },
      {
        "body": "Closing to reopen and trigger a CI build. See https://github.com/dotnet/msbuild/issues/5646",
        "createdAt": "2020-08-10T20:34:55Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "> I think this looks good to me. I'm trying to pull some strings internally to borrow a machine big enough to test it on (looks like Azure will charge me merely $50,000/month for a big enough VM!).\r\n\r\n@rainersigwald I reached out to some people within the dotnet foundation to see if there might be funds for something like this.  I'll let you know if I hear anything.",
        "createdAt": "2020-08-24T21:24:41Z",
        "author": {
          "login": "stackedsax"
        }
      },
      {
        "body": "@rainersigwald I emailed AMD and they have offered to test on their 64-core ThreadRipper 3990X processor.",
        "createdAt": "2020-08-25T22:47:14Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "Current status:\r\n\r\nI got access to a [Standard_F72s_v2](https://docs.microsoft.com/en-us/azure/virtual-machines/fsv2-series?toc=/azure/virtual-machines/linux/toc.json&bc=/azure/virtual-machines/linux/breadcrumb/toc.json) VM, installed a private Visual Studio with this fix and tested it out.\r\n\r\nIt almost works! In 64-bit everything looks great. In 32-bit, the new code correctly identifies 2 processor groups (2 NUMA nodes), but Windows lies to us _again_ and claims only 32 cores in each, when really there are 36--so we're artificially limited to 64 MSBuild nodes.\r\n\r\nThis is in [the docs](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformationex#remarks):\r\n\r\n> In addition, the sum of all per-group ActiveProcessorCount and MaximumProcessorCount values reported in PROCESSOR_GROUP_INFO structures may exclude some active logical processors.\r\n\r\nI'll start a thread up with some Windows folks internally to see if this is the best we can do.",
        "createdAt": "2020-09-03T22:31:41Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Latest push seems to work, at least until [AMD blows things up](https://www.tweaktown.com/news/67801/amds-next-gen-zen-3-rumor-4-threads-per-core-enables-64c-256t-chips/index.html).",
        "createdAt": "2020-09-04T22:29:57Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "However, depending on how https://github.com/dotnet/runtime/issues/41902 is resolved, we may need to do this on .NET Core/Windows too.",
        "createdAt": "2020-09-04T22:30:39Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@rainersigwald \"AMD's Milan CPUs for the third generation of Epyc products are unlikely to support quadruple smt.\"\r\nhttps://www.techpowerup.com/forums/threads/amd-zen-3-milan-cpus-not-getting-4-threads-per-core.259833/\r\n\r\nI imagine in the future it might happen, but lucky not so soon.",
        "createdAt": "2020-09-04T22:46:21Z",
        "author": {
          "login": "elachlan"
        }
      },
      {
        "body": "Thank you @mfkl! This should be available starting in 16.8 preview 4.",
        "createdAt": "2020-09-18T16:41:24Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Thank you for picking it up and finishing this :-)",
        "createdAt": "2020-09-18T17:30:58Z",
        "author": {
          "login": "mfkl"
        }
      },
      {
        "body": "By the way, GitHub somehow mangled the squash/merge commit--I did not intentionally erase you from the commit history. Sorry about that!",
        "createdAt": "2020-09-18T18:06:23Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "No worries.",
        "createdAt": "2020-09-18T18:41:27Z",
        "author": {
          "login": "mfkl"
        }
      },
      {
        "body": "@rainersigwald  @mfkl \r\n\r\nThis PR for the MSBuild cpu core count detection has an issue with debugging processor groups. I've created a new issue here and included some extra information for debugging without physical hardware: https://github.com/dotnet/msbuild/issues/7943",
        "createdAt": "2022-09-05T17:36:32Z",
        "author": {
          "login": "dmex"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Any reason not to make this part of the original definition? If it fails, you don't have to free it.",
              "createdAt": "2020-08-07T20:19:06Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +480,42 @@ public SystemInformationData()\n             }\n         }\n \n+        public static int GetPhysicalCoreCount()\n+        {\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+\t\t\t// Determine the required buffer size to store the processor information\n+\t\t\tuint ReturnLength = 0;\n+\t\t\tif(!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref ReturnLength) && Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+\t\t\t{\n+                IntPtr ptr = IntPtr.Zero;\n+\t\t\t\ttry\n+\t\t\t\t{\n+                    ptr = Marshal.AllocHGlobal((int)ReturnLength);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I usually put `Marshal.AllocHGlobal` inside try/catch statements to catch potential OOM exceptions. Calling free with `IntPtr.Zero` is safe. Can change it, if you prefer.",
              "createdAt": "2020-08-08T11:47:42Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +480,42 @@ public SystemInformationData()\n             }\n         }\n \n+        public static int GetPhysicalCoreCount()\n+        {\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+\t\t\t// Determine the required buffer size to store the processor information\n+\t\t\tuint ReturnLength = 0;\n+\t\t\tif(!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref ReturnLength) && Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+\t\t\t{\n+                IntPtr ptr = IntPtr.Zero;\n+\t\t\t\ttry\n+\t\t\t\t{\n+                    ptr = Marshal.AllocHGlobal((int)ReturnLength);",
              "author": {
                "login": "mfkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nCan you add this to the for statement?\r\n\r\nAlso, is this right? Maybe I'm misunderstanding, but it looks like you're increasing it by whatever 32-bit integer happens to be four bytes along? Is that the size of the current struct?",
              "createdAt": "2020-08-07T20:19:32Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +480,42 @@ public SystemInformationData()\n             }\n         }\n \n+        public static int GetPhysicalCoreCount()\n+        {\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+\t\t\t// Determine the required buffer size to store the processor information\n+\t\t\tuint ReturnLength = 0;\n+\t\t\tif(!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref ReturnLength) && Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+\t\t\t{\n+                IntPtr ptr = IntPtr.Zero;\n+\t\t\t\ttry\n+\t\t\t\t{\n+                    ptr = Marshal.AllocHGlobal((int)ReturnLength);\n+\t\t\t\t\tif (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, ptr, ref ReturnLength))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tint count = 0;\n+\t\t\t\t\t\tfor(int pos = 0; pos < ReturnLength; )\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tLOGICAL_PROCESSOR_RELATIONSHIP Type = (LOGICAL_PROCESSOR_RELATIONSHIP)Marshal.ReadInt16(ptr, pos);\n+\t\t\t\t\t\t\tif(Type == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tcount++;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpos += Marshal.ReadInt32(ptr, pos + 4);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "See new version.",
              "createdAt": "2020-08-08T12:58:18Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +480,42 @@ public SystemInformationData()\n             }\n         }\n \n+        public static int GetPhysicalCoreCount()\n+        {\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+\t\t\t// Determine the required buffer size to store the processor information\n+\t\t\tuint ReturnLength = 0;\n+\t\t\tif(!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref ReturnLength) && Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+\t\t\t{\n+                IntPtr ptr = IntPtr.Zero;\n+\t\t\t\ttry\n+\t\t\t\t{\n+                    ptr = Marshal.AllocHGlobal((int)ReturnLength);\n+\t\t\t\t\tif (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, ptr, ref ReturnLength))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tint count = 0;\n+\t\t\t\t\t\tfor(int pos = 0; pos < ReturnLength; )\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tLOGICAL_PROCESSOR_RELATIONSHIP Type = (LOGICAL_PROCESSOR_RELATIONSHIP)Marshal.ReadInt16(ptr, pos);\n+\t\t\t\t\t\t\tif(Type == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tcount++;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpos += Marshal.ReadInt32(ptr, pos + 4);",
              "author": {
                "login": "mfkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-system_logical_processor_information seems to say this is just a byte, not an int16.",
              "createdAt": "2020-08-07T20:34:21Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +480,42 @@ public SystemInformationData()\n             }\n         }\n \n+        public static int GetPhysicalCoreCount()\n+        {\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+\t\t\t// Determine the required buffer size to store the processor information\n+\t\t\tuint ReturnLength = 0;\n+\t\t\tif(!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref ReturnLength) && Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+\t\t\t{\n+                IntPtr ptr = IntPtr.Zero;\n+\t\t\t\ttry\n+\t\t\t\t{\n+                    ptr = Marshal.AllocHGlobal((int)ReturnLength);\n+\t\t\t\t\tif (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, ptr, ref ReturnLength))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tint count = 0;\n+\t\t\t\t\t\tfor(int pos = 0; pos < ReturnLength; )\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tLOGICAL_PROCESSOR_RELATIONSHIP Type = (LOGICAL_PROCESSOR_RELATIONSHIP)Marshal.ReadInt16(ptr, pos);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes",
              "createdAt": "2020-08-08T12:58:07Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +480,42 @@ public SystemInformationData()\n             }\n         }\n \n+        public static int GetPhysicalCoreCount()\n+        {\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+\t\t\t// Determine the required buffer size to store the processor information\n+\t\t\tuint ReturnLength = 0;\n+\t\t\tif(!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref ReturnLength) && Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+\t\t\t{\n+                IntPtr ptr = IntPtr.Zero;\n+\t\t\t\ttry\n+\t\t\t\t{\n+                    ptr = Marshal.AllocHGlobal((int)ReturnLength);\n+\t\t\t\t\tif (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, ptr, ref ReturnLength))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tint count = 0;\n+\t\t\t\t\t\tfor(int pos = 0; pos < ReturnLength; )\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tLOGICAL_PROCESSOR_RELATIONSHIP Type = (LOGICAL_PROCESSOR_RELATIONSHIP)Marshal.ReadInt16(ptr, pos);",
              "author": {
                "login": "mfkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Looking at the [documentation](https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-system_logical_processor_information):\r\nThe specified logical processors share a single processor core. The ProcessorCore member contains additional information.\r\n\r\nI switched this to run whenever numberOfCpus exceeded 1 and printed out the number of cpus it calculated. It printed 6. I have 6 dual cores. I think we can get a more accurate count if we use the ProcessorCore to get processors/core as well.",
              "createdAt": "2020-08-07T20:55:22Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +480,42 @@ public SystemInformationData()\n             }\n         }\n \n+        public static int GetPhysicalCoreCount()\n+        {\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+\t\t\t// Determine the required buffer size to store the processor information\n+\t\t\tuint ReturnLength = 0;\n+\t\t\tif(!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref ReturnLength) && Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+\t\t\t{\n+                IntPtr ptr = IntPtr.Zero;\n+\t\t\t\ttry\n+\t\t\t\t{\n+                    ptr = Marshal.AllocHGlobal((int)ReturnLength);\n+\t\t\t\t\tif (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, ptr, ref ReturnLength))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tint count = 0;\n+\t\t\t\t\t\tfor(int pos = 0; pos < ReturnLength; )\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tLOGICAL_PROCESSOR_RELATIONSHIP Type = (LOGICAL_PROCESSOR_RELATIONSHIP)Marshal.ReadInt16(ptr, pos);\n+\t\t\t\t\t\t\tif(Type == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tcount++;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Ok, reused previous corefx code, count should be more accurate now.",
              "createdAt": "2020-08-08T12:57:57Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +480,42 @@ public SystemInformationData()\n             }\n         }\n \n+        public static int GetPhysicalCoreCount()\n+        {\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+\t\t\t// Determine the required buffer size to store the processor information\n+\t\t\tuint ReturnLength = 0;\n+\t\t\tif(!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref ReturnLength) && Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+\t\t\t{\n+                IntPtr ptr = IntPtr.Zero;\n+\t\t\t\ttry\n+\t\t\t\t{\n+                    ptr = Marshal.AllocHGlobal((int)ReturnLength);\n+\t\t\t\t\tif (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, ptr, ref ReturnLength))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tint count = 0;\n+\t\t\t\t\t\tfor(int pos = 0; pos < ReturnLength; )\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tLOGICAL_PROCESSOR_RELATIONSHIP Type = (LOGICAL_PROCESSOR_RELATIONSHIP)Marshal.ReadInt16(ptr, pos);\n+\t\t\t\t\t\t\tif(Type == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tcount++;",
              "author": {
                "login": "mfkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "tiny nit:\r\nspace between `if` and `(` (also below)",
              "createdAt": "2020-08-07T20:59:31Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if(numberOfCpus == 32 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "done",
              "createdAt": "2020-08-08T12:57:31Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if(numberOfCpus == 32 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "mfkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This is defined as\r\n```C++\r\nWORD                 MaximumGroupCount;\r\n```\r\nin the unmanaged world so should be an `ushort` here.",
              "createdAt": "2020-08-10T05:16:53Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -137,6 +137,39 @@ private enum eDesiredAccess : int\n             PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xFFF\n         }\n \n+        internal enum LOGICAL_PROCESSOR_RELATIONSHIP\n+\t\t{\n+\t\t\tRelationProcessorCore,\n+\t\t\tRelationNumaNode,\n+\t\t\tRelationCache,\n+\t\t\tRelationProcessorPackage,\n+\t\t\tRelationGroup,\n+\t\t\tRelationAll = 0xffff\n+\t\t}\n+\n+        internal struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX\n+        {\n+            public LOGICAL_PROCESSOR_RELATIONSHIP Relationship;\n+            public uint Size;\n+            public GROUP_RELATIONSHIP Group;\n+        }\n+\n+        internal unsafe struct GROUP_RELATIONSHIP\n+        {\n+            private byte MaximumGroupCount;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Bad indentation.",
              "createdAt": "2020-08-10T05:25:47Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -137,6 +137,39 @@ private enum eDesiredAccess : int\n             PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xFFF\n         }\n \n+        internal enum LOGICAL_PROCESSOR_RELATIONSHIP\n+\t\t{",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you please add a comment with a short `<summary>`?",
              "createdAt": "2020-08-10T05:26:55Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +503,47 @@ public SystemInformationData()\n             }\n         }\n \n+        public unsafe static int GetPhysicalCoreCount()",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Add a check that this dereference is not overrunning the containing `buffer`, just in case.",
              "createdAt": "2020-08-10T05:31:11Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +503,47 @@ public SystemInformationData()\n             }\n         }\n \n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr, endPtr = bufferPtr + len;\n+                        while (ptr < endPtr)\n+                        {\n+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;\n+                            if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup)\n+                            {\n+                                PROCESSOR_GROUP_INFO* groupInfo = &current->Group.GroupInfo;\n+                                int groupCount = current->Group.ActiveGroupCount;\n+                                for (int i = 0; i < groupCount; i++)\n+                                {\n+                                    processorCount += (groupInfo + i)->ActiveProcessorCount;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I'm not quite sure about the kind of check you have in mind here?\r\n```\r\nbyte* ptr = bufferPtr, endPtr = bufferPtr + len;\r\nwhile (ptr < endPtr)\r\n```\r\nThis seems correct from what I can tell.\r\nWhat check would you add to `processorCount += (groupInfo + i)->ActiveProcessorCount;`?",
              "createdAt": "2020-08-11T16:19:16Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +503,47 @@ public SystemInformationData()\n             }\n         }\n \n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr, endPtr = bufferPtr + len;\n+                        while (ptr < endPtr)\n+                        {\n+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;\n+                            if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup)\n+                            {\n+                                PROCESSOR_GROUP_INFO* groupInfo = &current->Group.GroupInfo;\n+                                int groupCount = current->Group.ActiveGroupCount;\n+                                for (int i = 0; i < groupCount; i++)\n+                                {\n+                                    processorCount += (groupInfo + i)->ActiveProcessorCount;",
              "author": {
                "login": "mfkl"
              }
            },
            {
              "body": "If `groupCount` is a bogus number, `(groupInfo + i)` could be pointing outside of the `bufferPtr` <-> `endPtr` block. I believe it's a good security practice to not trust the data and check that all memory accesses are within the bounds when using unsafe C# code.\r\n\r\nStrictly speaking, this should also include `current->Relationship` and `current->Group.ActiveGroupCount` because `ptr` being less than `endPtr` is not sufficient for these reads to be from within the buffer.",
              "createdAt": "2020-08-11T21:14:06Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +503,47 @@ public SystemInformationData()\n             }\n         }\n \n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr, endPtr = bufferPtr + len;\n+                        while (ptr < endPtr)\n+                        {\n+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;\n+                            if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup)\n+                            {\n+                                PROCESSOR_GROUP_INFO* groupInfo = &current->Group.GroupInfo;\n+                                int groupCount = current->Group.ActiveGroupCount;\n+                                for (int i = 0; i < groupCount; i++)\n+                                {\n+                                    processorCount += (groupInfo + i)->ActiveProcessorCount;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Since this code was directly taken from dotnet/runtime unmodified, and has been pushed to production, I'm inclined to believe it works and does not need additional checks. I'll add the checks since you prefer though.",
              "createdAt": "2020-08-14T13:57:09Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +503,47 @@ public SystemInformationData()\n             }\n         }\n \n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr, endPtr = bufferPtr + len;\n+                        while (ptr < endPtr)\n+                        {\n+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;\n+                            if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup)\n+                            {\n+                                PROCESSOR_GROUP_INFO* groupInfo = &current->Group.GroupInfo;\n+                                int groupCount = current->Group.ActiveGroupCount;\n+                                for (int i = 0; i < groupCount; i++)\n+                                {\n+                                    processorCount += (groupInfo + i)->ActiveProcessorCount;",
              "author": {
                "login": "mfkl"
              }
            },
            {
              "body": "Added some checks https://github.com/dotnet/msbuild/pull/5625/commits/4223cc2e0c875c527afaf5f67a255c2995c4ebb1, please feel free to let me know if that's not what you had in mind.",
              "createdAt": "2020-08-16T10:16:32Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +503,47 @@ public SystemInformationData()\n             }\n         }\n \n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr, endPtr = bufferPtr + len;\n+                        while (ptr < endPtr)\n+                        {\n+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;\n+                            if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup)\n+                            {\n+                                PROCESSOR_GROUP_INFO* groupInfo = &current->Group.GroupInfo;\n+                                int groupCount = current->Group.ActiveGroupCount;\n+                                for (int i = 0; i < groupCount; i++)\n+                                {\n+                                    processorCount += (groupInfo + i)->ActiveProcessorCount;",
              "author": {
                "login": "mfkl"
              }
            },
            {
              "body": "These checks will now just ignore invalid data which is, to our understanding, logically impossible. Should they not be asserting or throwing?",
              "createdAt": "2022-05-11T10:03:53Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +503,47 @@ public SystemInformationData()\n             }\n         }\n \n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr, endPtr = bufferPtr + len;\n+                        while (ptr < endPtr)\n+                        {\n+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;\n+                            if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup)\n+                            {\n+                                PROCESSOR_GROUP_INFO* groupInfo = &current->Group.GroupInfo;\n+                                int groupCount = current->Group.ActiveGroupCount;\n+                                for (int i = 0; i < groupCount; i++)\n+                                {\n+                                    processorCount += (groupInfo + i)->ActiveProcessorCount;",
              "author": {
                "login": "GSPP"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think it would be better if either:\r\n- This code ran always, i.e. remove the `numberOfCpus == 32` condition. It would help test the new code on more machines. Unless calling the Win32 API has a measurable perf impact.\r\n- Or this code ran only if the process is actually 32-bit. Users may choose to run 64-bit msbuild.exe and my understanding is that this fix is not needed there.",
              "createdAt": "2020-08-10T05:38:06Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (numberOfCpus == 32 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "There was a build error related to the MaximumGroupCount:\r\n`error CS0169: The field 'NativeMethodsShared.GROUP_RELATIONSHIP.MaximumGroupCount' is never used`\r\n\r\nand ActiveGroupCount:\r\n`error CS0649: Field 'NativeMethodsShared.GROUP_RELATIONSHIP.ActiveGroupCount' is never assigned to, and will always have its default value 0\r\n`\r\n\r\nand SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.Size:\r\n`error CS0649: Field 'NativeMethodsShared.SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.Size' is never assigned to, and will always have its default value 0\r\n`\r\n\r\nand SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.Relationship:\r\n`error CS0649: Field 'NativeMethodsShared.SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.Relationship' is never assigned to, and will always have its default value\r\n`",
              "createdAt": "2020-08-11T05:51:44Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -137,6 +137,39 @@ private enum eDesiredAccess : int\n             PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xFFF\n         }\n \n+        internal enum LOGICAL_PROCESSOR_RELATIONSHIP\n+\t\t{\n+\t\t\tRelationProcessorCore,\n+\t\t\tRelationNumaNode,\n+\t\t\tRelationCache,\n+\t\t\tRelationProcessorPackage,\n+\t\t\tRelationGroup,\n+\t\t\tRelationAll = 0xffff\n+\t\t}\n+\n+        internal struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX\n+        {\n+            public LOGICAL_PROCESSOR_RELATIONSHIP Relationship;\n+            public uint Size;\n+            public GROUP_RELATIONSHIP Group;\n+        }\n+\n+        internal unsafe struct GROUP_RELATIONSHIP\n+        {\n+            private byte MaximumGroupCount;",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a more intuitive way to get that it's 32-bit? If not, this is fine. I was only confused until I read the comment.",
              "createdAt": "2020-08-11T20:43:24Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (IntPtr.Size == 4 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "If there isn't another way, can we comment with a link to https://docs.microsoft.com/en-us/dotnet/api/system.intptr.size?view=netcore-3.1, or the excerpt from that page\r\n`The size of a pointer or handle in this process, measured in bytes. The value of this property is 4 in a 32-bit process, and 8 in a 64-bit process. You can define the process type by setting the /platform switch when you compile your code with the C# and Visual Basic compilers.`",
              "createdAt": "2020-08-11T21:10:23Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (IntPtr.Size == 4 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "To be clear, I understood immediately after reading the comment. Although I'd count this as somewhat subtle but definitely simple and functional.",
              "createdAt": "2020-08-11T21:49:54Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (IntPtr.Size == 4 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Maybe extract it to a readonly static property is32bit? Or use an enum?",
              "createdAt": "2020-08-11T21:51:32Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (IntPtr.Size == 4 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "Good point! You reminded me of https://github.com/dotnet/msbuild/blob/master/src/Shared/EnvironmentUtilities.cs#L11\r\n\r\nWe should follow this model.",
              "createdAt": "2020-08-11T22:05:40Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (IntPtr.Size == 4 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Just use this but test for the negation?",
              "createdAt": "2020-08-11T22:36:06Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (IntPtr.Size == 4 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "Also it looks like there is a static bool in environment.\r\nhttps://github.com/dotnet/runtime/blob/ea2b09beea535abf960651c59359e40f99f2fecf/src/libraries/System.Private.CoreLib/src/System/Environment.cs#L138\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/api/system.environment.is64bitprocess?view=netcore-3.1",
              "createdAt": "2020-08-11T22:36:35Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (IntPtr.Size == 4 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "elachlan"
              }
            },
            {
              "body": "Either way works, but I'd make a new `Is32Bit` version. We probably don't have to worry about 16-bit machines, and we don't currently have to worry about 128-bit machines, but just in case this code lasts a while...",
              "createdAt": "2020-08-11T22:38:57Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (IntPtr.Size == 4 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`EnvironmentUtilities` is internal to this assembly thus cannot be referenced without adding an InternalsVisibleTo which I don't think we want to do. Used `!Environment.Is64BitProcess` instead.",
              "createdAt": "2020-08-14T13:50:30Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (IntPtr.Size == 4 && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "mfkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nsplit onto two lines\r\n\r\nI also kinda liked your for loop better, but this is fine.",
              "createdAt": "2020-08-11T20:44:41Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +501,52 @@ public SystemInformationData()\n             }\n         }\n \n+        /// <summary>\n+        /// Get the exact physical core count on Windows\n+        /// Useful for getting the exact core count in 32 bits processes,\n+        /// as Environment.ProcessorCount has a 32-core limit in that case. \n+        /// </summary>\n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr, endPtr = bufferPtr + len;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": ">  split onto two lines\r\n\r\ndone",
              "createdAt": "2020-08-14T13:50:57Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +501,52 @@ public SystemInformationData()\n             }\n         }\n \n+        /// <summary>\n+        /// Get the exact physical core count on Windows\n+        /// Useful for getting the exact core count in 32 bits processes,\n+        /// as Environment.ProcessorCount has a 32-core limit in that case. \n+        /// </summary>\n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr, endPtr = bufferPtr + len;",
              "author": {
                "login": "mfkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Question for myself. I noticed this struct has more members: https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-system_logical_processor_information_ex.\r\n\r\nCan you simply not define all members and it will populate only what you have defined without raising some sort of error?",
              "createdAt": "2020-08-11T21:56:55Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -136,6 +136,37 @@ private enum eDesiredAccess : int\n             PROCESS_QUERY_INFORMATION = 0x0400,\n             PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xFFF\n         }\n+#pragma warning disable 0649, 0169\n+        internal enum LOGICAL_PROCESSOR_RELATIONSHIP\n+        {\n+            RelationProcessorCore,\n+            RelationNumaNode,\n+            RelationCache,\n+            RelationProcessorPackage,\n+            RelationGroup,\n+            RelationAll = 0xffff\n+        }\n+        internal struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "> Can you simply not define all members and it will populate only what you have defined without raising some sort of error?\r\n\r\nFair question. I think it depends on what you need to marshal. In case of union, this way of doing things seems to be fine and the original writer had a comment about it: https://github.com/dotnet/runtime/blob/3ab9c0b79300a5b3d954421aa4da15a9c2ca1271/src/libraries/Common/src/Interop/Windows/kernel32/Interop.GetLogicalProcessorInformationEx.cs#L27",
              "createdAt": "2020-08-14T13:54:35Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -136,6 +136,37 @@ private enum eDesiredAccess : int\n             PROCESS_QUERY_INFORMATION = 0x0400,\n             PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xFFF\n         }\n+#pragma warning disable 0649, 0169\n+        internal enum LOGICAL_PROCESSOR_RELATIONSHIP\n+        {\n+            RelationProcessorCore,\n+            RelationNumaNode,\n+            RelationCache,\n+            RelationProcessorPackage,\n+            RelationGroup,\n+            RelationAll = 0xffff\n+        }\n+        internal struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX",
              "author": {
                "login": "mfkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Ideally this should be copy pasted code from a trustworthy repo (dotnet runtime, corefx, etc) and we just copy paste it and add a comment citing the source. If that's the case, can you please cite the source? (github file line permalink)\r\n\r\nWell, ideally ideally it should be in a shared library of some sorts, but let's not get too ideal :)",
              "createdAt": "2020-08-13T22:51:31Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +501,52 @@ public SystemInformationData()\n             }\n         }\n \n+        /// <summary>\n+        /// Get the exact physical core count on Windows\n+        /// Useful for getting the exact core count in 32 bits processes,\n+        /// as Environment.ProcessorCount has a 32-core limit in that case. \n+        /// </summary>\n+        public unsafe static int GetPhysicalCoreCount()",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Done https://github.com/dotnet/msbuild/pull/5625/commits/70d41ae6e695ad78acc73543dde8093285ae93b2",
              "createdAt": "2020-08-14T13:55:25Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +501,52 @@ public SystemInformationData()\n             }\n         }\n \n+        /// <summary>\n+        /// Get the exact physical core count on Windows\n+        /// Useful for getting the exact core count in 32 bits processes,\n+        /// as Environment.ProcessorCount has a 32-core limit in that case. \n+        /// </summary>\n+        public unsafe static int GetPhysicalCoreCount()",
              "author": {
                "login": "mfkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I may have misunderstood, but I thought @ladipro was thinking something more like this?\r\n\r\n```suggestion\r\n                                    for (int i = 0; i < groupCount && groupInfo + i < endPtr; i++)\r\n```",
              "createdAt": "2020-08-16T17:29:17Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +501,61 @@ public SystemInformationData()\n             }\n         }\n \n+        /// <summary>\n+        /// Get the exact physical core count on Windows\n+        /// Useful for getting the exact core count in 32 bits processes,\n+        /// as Environment.ProcessorCount has a 32-core limit in that case. \n+        /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210\n+        /// </summary>\n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr;\n+                        byte* endPtr = bufferPtr + len;\n+                        while (ptr < endPtr)\n+                        {\n+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;\n+                            if (current != null && current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup)\n+                            {\n+                                PROCESSOR_GROUP_INFO* groupInfo = &current->Group.GroupInfo;\n+                                if (groupInfo != null)\n+                                {\n+                                    int groupCount = current->Group.ActiveGroupCount;\n+                                    for (int i = 0; i < groupCount; i++)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thanks, yes, I was thinking something like this, not the `null` checks added in 4223cc2e0c875c527afaf5f67a255c2995c4ebb1. It would have to be:\r\n\r\n```C#\r\nfor (int i = 0; i < groupCount && groupInfo + i + 1 <= endPtr; i++)\r\n```\r\n\r\ni.e. the entire structure pointed to by `(groupInfo + i)` fits in the buffer.\r\n\r\nI mentioned this to @danmosemsft offline and he doesn't consider this kind of hardening necessary when calling a trusted API. @mfkl, feel free to revert the 4223cc2e0c875c527afaf5f67a255c2995c4ebb1. Apologies for randomizing you.",
              "createdAt": "2020-08-18T06:30:46Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +501,61 @@ public SystemInformationData()\n             }\n         }\n \n+        /// <summary>\n+        /// Get the exact physical core count on Windows\n+        /// Useful for getting the exact core count in 32 bits processes,\n+        /// as Environment.ProcessorCount has a 32-core limit in that case. \n+        /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210\n+        /// </summary>\n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr;\n+                        byte* endPtr = bufferPtr + len;\n+                        while (ptr < endPtr)\n+                        {\n+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;\n+                            if (current != null && current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup)\n+                            {\n+                                PROCESSOR_GROUP_INFO* groupInfo = &current->Group.GroupInfo;\n+                                if (groupInfo != null)\n+                                {\n+                                    int groupCount = current->Group.ActiveGroupCount;\n+                                    for (int i = 0; i < groupCount; i++)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Yeah, clearly we don't do it in the code this came from in dotnet/runtime and I think it would be simply \"testing the OS has no bugs\". But if there's a security context, don't take my word for it - we should ask others.",
              "createdAt": "2020-08-18T15:44:49Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +501,61 @@ public SystemInformationData()\n             }\n         }\n \n+        /// <summary>\n+        /// Get the exact physical core count on Windows\n+        /// Useful for getting the exact core count in 32 bits processes,\n+        /// as Environment.ProcessorCount has a 32-core limit in that case. \n+        /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210\n+        /// </summary>\n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr;\n+                        byte* endPtr = bufferPtr + len;\n+                        while (ptr < endPtr)\n+                        {\n+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;\n+                            if (current != null && current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup)\n+                            {\n+                                PROCESSOR_GROUP_INFO* groupInfo = &current->Group.GroupInfo;\n+                                if (groupInfo != null)\n+                                {\n+                                    int groupCount = current->Group.ActiveGroupCount;\n+                                    for (int i = 0; i < groupCount; i++)",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "All good, reverted.",
              "createdAt": "2020-08-18T15:50:01Z",
              "path": "src/Shared/NativeMethodsShared.cs",
              "diffHunk": "@@ -470,6 +501,61 @@ public SystemInformationData()\n             }\n         }\n \n+        /// <summary>\n+        /// Get the exact physical core count on Windows\n+        /// Useful for getting the exact core count in 32 bits processes,\n+        /// as Environment.ProcessorCount has a 32-core limit in that case. \n+        /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210\n+        /// </summary>\n+        public unsafe static int GetPhysicalCoreCount()\n+        {\n+            uint len = 0;\n+            const int ERROR_INSUFFICIENT_BUFFER = 122;\n+\n+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, IntPtr.Zero, ref len) &&\n+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)\n+            {\n+                // Allocate that much space\n+                var buffer = new byte[len];\n+                fixed (byte* bufferPtr = buffer)\n+                {\n+                    // Call GetLogicalProcessorInformationEx with the allocated buffer\n+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup, (IntPtr)bufferPtr, ref len))\n+                    {\n+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how\n+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.\n+                        int processorCount = 0;\n+                        byte* ptr = bufferPtr;\n+                        byte* endPtr = bufferPtr + len;\n+                        while (ptr < endPtr)\n+                        {\n+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;\n+                            if (current != null && current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup)\n+                            {\n+                                PROCESSOR_GROUP_INFO* groupInfo = &current->Group.GroupInfo;\n+                                if (groupInfo != null)\n+                                {\n+                                    int groupCount = current->Group.ActiveGroupCount;\n+                                    for (int i = 0; i < groupCount; i++)",
              "author": {
                "login": "mfkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "64-bit Windows had a 64-core limit, too. I think this should be called when we're running on .NET Framework regardless of bitness (on .NET Core/.NET 5, we can rely on `Environment.ProcessorCount` to do the trick for us, right?).",
              "createdAt": "2020-08-17T19:23:06Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (!Environment.Is64BitProcess && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Ok",
              "createdAt": "2020-08-18T15:49:45Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (!Environment.Is64BitProcess && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "mfkl"
              }
            },
            {
              "body": "> 64-bit Windows had a 64-core limit, too. I think this should be called when we're running on .NET Framework regardless of bitness (on .NET Core/.NET 5, we can rely on `Environment.ProcessorCount` to do the trick for us, right?).\r\n\r\n.NET 5 `Environment.ProcessorCount` calls the native GetProcessorCount function. So I think its all good. \r\nhttps://github.com/dotnet/runtime/blob/ea2b09beea535abf960651c59359e40f99f2fecf/src/libraries/System.Private.CoreLib/src/System/Environment.cs#L13\r\n\r\nhttps://github.com/dotnet/runtime/blob/60eff3f3766631bd4e7ee256ca17619fec90e9e6/src/coreclr/src/System.Private.CoreLib/src/System/Environment.CoreCLR.cs#L83-L84\r\n\r\nhttps://github.com/dotnet/runtime/blob/96f178d32b7ba62485917ac46ef1edcfd3c2d10d/src/coreclr/src/classlibnative/bcltype/system.cpp#L327-L364\r\n\r\n",
              "createdAt": "2020-08-19T00:09:54Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,12 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+                                if (!Environment.Is64BitProcess && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit",
              "author": {
                "login": "elachlan"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n#if NETFRAMEWORK && !MONO\r\n```\r\n\r\nI think this is slightly clearer and preserves the intent: do this only on full .NET Framework.",
              "createdAt": "2020-08-18T18:31:07Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,12 +1725,16 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n-                                if (!Environment.Is64BitProcess && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit\n+#if !RUNTIME_TYPE_NETCORE",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                                // .NET framework calls Windows APIs that have a core count limit (32/64 depending on process bitness), \r\n```",
              "createdAt": "2020-08-18T18:31:28Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,12 +1725,16 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n-                                if (!Environment.Is64BitProcess && NativeMethodsShared.IsWindows) // 32-bit process, 32-bit Windows had a 32-core limit\n+#if !RUNTIME_TYPE_NETCORE\n+                                // .NET framework has a core count limit (32/64 depending on process bitness), ",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Were we not thinking of expanding this for cases like, say, if you have 2 * 24 CPUs?",
              "createdAt": "2020-09-14T16:10:27Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,18 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+#if !MONO\n+                                // .NET framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).\n+                                // .NET Core on Windows returns a core count limited to the current NUMA node\n+                                //     https://github.com/dotnet/runtime/issues/41902\n+                                // So if we get a high core count on Windows, double-check it.\n+                                if (numberOfCpus >= 32 && NativeMethodsShared.IsWindows)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Ah, indeed we were. Back to the drawing board.",
              "createdAt": "2020-09-14T16:12:12Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,18 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+#if !MONO\n+                                // .NET framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).\n+                                // .NET Core on Windows returns a core count limited to the current NUMA node\n+                                //     https://github.com/dotnet/runtime/issues/41902\n+                                // So if we get a high core count on Windows, double-check it.\n+                                if (numberOfCpus >= 32 && NativeMethodsShared.IsWindows)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Ok, latest push looks good again.",
              "createdAt": "2020-09-14T16:45:25Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1725,6 +1725,18 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman\n                                 String.Equals(switchName, \"maxcpucount\", StringComparison.OrdinalIgnoreCase))\n                             {\n                                 int numberOfCpus = Environment.ProcessorCount;\n+#if !MONO\n+                                // .NET framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).\n+                                // .NET Core on Windows returns a core count limited to the current NUMA node\n+                                //     https://github.com/dotnet/runtime/issues/41902\n+                                // So if we get a high core count on Windows, double-check it.\n+                                if (numberOfCpus >= 32 && NativeMethodsShared.IsWindows)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}