{
  "number": 10134,
  "title": "Add prefer native arm64 flag",
  "body": "Fixes #10060\r\n\r\n### Context\r\nRelated changes in SDK: https://github.com/dotnet/sdk/pull/40895\r\n\r\n### Changes Made\r\nAdded new target and task to handle the cases when PreferNativeArm64 is specified.\r\n+ added a task to display localized messages specified in .target files\r\n\r\n### Testing\r\nUnit tests + e2e that check that modified manifest is embedded in the final dll.",
  "state": "MERGED",
  "createdAt": "2024-05-15T10:53:09Z",
  "updatedAt": "2024-05-29T06:23:53Z",
  "closedAt": "2024-05-29T06:23:52Z",
  "mergedAt": "2024-05-29T06:23:52Z",
  "additions": 1537,
  "deletions": 4,
  "changedFiles": 38,
  "headRefName": "dev/ykovalova/add_PreferNativeArm64",
  "isDraft": false,
  "author": {
    "login": "YuliiaKovalova"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "774972509c656404e3c3cee0b0b51e83ee5c9620",
          "message": "add basic implementation for preferArm64",
          "committedDate": "2024-05-14T20:03:34Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ee137fff2984fc0a66c6fdc34aa26c42da953c61",
          "message": "cleanup",
          "committedDate": "2024-05-15T09:28:26Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a0c1b7e9054c6af8c0378fc05827a07f12ea1592",
          "message": "Merge remote-tracking branch 'origin/main' into dev/ykovalova/add_PreferNativeArm64",
          "committedDate": "2024-05-15T09:31:48Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7219dab044ea5e9e9a9689cf982abdbd83ffed02",
          "message": "fix targets file",
          "committedDate": "2024-05-15T10:52:08Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "44ce08e55b50b0565141df3055b9253dc2bc51f2",
          "message": "cleanup test file",
          "committedDate": "2024-05-15T10:58:28Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4394d262dbd9d88589441f4262c8d08b48cf27cd",
          "message": "remove extra code",
          "committedDate": "2024-05-15T12:11:38Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c74b8912d3a4668387ef16d7cf10bff9b38c3622",
          "message": "fix review comments + extend tests",
          "committedDate": "2024-05-15T17:17:11Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b9a9d4226a24ced4103de28c4e905124f94e869f",
          "message": "fix review comments",
          "committedDate": "2024-05-16T13:42:46Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eb1986c94670cd0993010a886a523e4a76e1ff2f",
          "message": "remove extra ;",
          "committedDate": "2024-05-16T13:54:53Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b05655ff79cf7e7b3c73efb247cb1f84816ef770",
          "message": "fix the missed condition",
          "committedDate": "2024-05-16T15:49:51Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f52e0396da46683c4bc56d8ede499d86fd92c138",
          "message": "fix review comments",
          "committedDate": "2024-05-16T16:14:19Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "459f25d384dc2ffdd35a18f319519b6d375b3ea8",
          "message": "remove checking build results due to MSB3644 on build machines",
          "committedDate": "2024-05-17T06:37:30Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d81b6808064b1f96d9865e7b060886f1f9b8aaf5",
          "message": "fix review comments",
          "committedDate": "2024-05-23T14:48:41Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "170409ae1001daab2711695303a92cbe7f59a409",
          "message": "handle the case when prefix doesn't exist in manifest",
          "committedDate": "2024-05-23T16:36:55Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a79ee9078e5253b6a7a518f0cff54d4272cce8c4",
          "message": "remove extra changes",
          "committedDate": "2024-05-23T16:55:19Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "874884d1c66abc1cafa6bba40d8d5ff027a7a19a",
          "message": "fix review comments - renaming and handling in the task",
          "committedDate": "2024-05-23T17:45:33Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f645ef822b13f7fe317e27e5350f1437df51a197",
          "message": "change severity for SpecifiedSeverityDoesNotExist log",
          "committedDate": "2024-05-23T19:57:55Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "98cae2341e40d9ab666e25de3166b8ad30945dde",
          "message": "handle ClickOnceManifest and Prefer32bit cases",
          "committedDate": "2024-05-24T09:56:33Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "79dff86b18613cfe3510b719ac28e8a8c3e7f96c",
          "message": "fix quoting",
          "committedDate": "2024-05-24T10:05:02Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bdb3aba0f9726143d6cb2fb21b0f3d96175655a0",
          "message": "fix review comments - simplify conditions and typos",
          "committedDate": "2024-05-24T12:25:41Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0f35c1a8ff87218b8c7b7a684de37b8b0b404a12",
          "message": "change condition  '$(PreferNativeArm64)' == '' ->  '$(PreferNativeArm64)' != 'true'",
          "committedDate": "2024-05-24T14:41:35Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8c3e739e1363eb89c91847369a7ba2b362ce3ddb",
          "message": "handle the case for clickonce manifests",
          "committedDate": "2024-05-27T10:01:56Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "edee4522f918a07be7f04f3938b23f1529f2982a",
          "message": "make _SupportedArchitectures a global property",
          "committedDate": "2024-05-27T10:49:44Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "528d9307ddb06981919d4d213ab6c4686f349763",
          "message": "fix spacing",
          "committedDate": "2024-05-27T13:02:53Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b50a57f35501ceb252dccafc48dba6a0d5f33a90",
          "message": "Extend logged messages",
          "committedDate": "2024-05-28T15:54:48Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1ec6c3750ac98daca299411101206c2f73e0c755",
          "message": "add path to manifest to AddToWin32Manifest.ManifestCanNotBeOpened",
          "committedDate": "2024-05-28T15:59:26Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "be21253d85f7766356880d376e26aaa69c34c4cd",
          "message": "use LogErrorWithCodeFromResources to log file path",
          "committedDate": "2024-05-28T16:10:47Z",
          "author": {
            "name": "Yuliia Kovalova",
            "email": "ykovalova@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I have found a couple of issues when testing this PR in VS end to end.\r\n\r\n1. The application manifest template in VS contains this XML:\r\n\r\n```xml\r\n  <application xmlns=\"urn:schemas-microsoft-com:asm.v3\">\r\n    <windowsSettings>\r\n      <dpiAware xmlns=\"http://schemas.microsoft.com/SMI/2005/WindowsSettings\">true</dpiAware>\r\n      <longPathAware xmlns=\"http://schemas.microsoft.com/SMI/2016/WindowsSettings\">true</longPathAware>\r\n    </windowsSettings>\r\n  </application>\r\n```\r\n\r\nThe `PopulateSupportedArchitectures` task is failing on it with:\r\n\r\n```\r\n      The \"PopulateSupportedArchitectures\" task failed unexpectedly.\r\n      This is an unhandled exception from a task -- PLEASE OPEN A BUG AGAINST THE TASK OWNER.\r\n      System.Xml.XmlException: The prefix '' cannot be redefined from 'urn:schemas-microsoft-com:asm.v3' to 'http://schemas.microsoft.com/SMI/2024/WindowsSe\r\n      ttings' within the same start element tag.\r\n         at System.Xml.XmlWellFormedWriter.PushNamespaceExplicit(String prefix, String ns)\r\n         at System.Xml.XmlWellFormedWriter.WriteEndAttribute()\r\n         at System.Xml.XmlElement.WriteStartElement(XmlWriter w)\r\n         at System.Xml.XmlElement.WriteElementTo(XmlWriter writer, XmlElement e)\r\n         at System.Xml.XmlDocument.Save(XmlWriter w)\r\n         at Microsoft.Build.Tasks.PopulateSupportedArchitectures.SaveManifest(XmlDocument document, String manifestName) in C:\\src\\msbuild\\src\\Tasks\\Populat\r\n      eSupportedArchitectures.cs:line 154\r\n         at Microsoft.Build.Tasks.PopulateSupportedArchitectures.Execute() in C:\\src\\msbuild\\src\\Tasks\\PopulateSupportedArchitectures.cs:line 125\r\n         at Microsoft.Build.BackEnd.TaskExecutionHost.Execute() in C:\\src\\msbuild\\src\\Build\\BackEnd\\TaskExecutionHost\\TaskExecutionHost.cs:line 587\r\n         at Microsoft.Build.BackEnd.TaskBuilder.<ExecuteInstantiatedTask>d__26.MoveNext() in C:\\src\\msbuild\\src\\Build\\BackEnd\\Components\\RequestBuilder\\Task\r\n      Builder.cs:line 807\r\n```\r\n\r\n2. Adding `<PreferNativeArm64>true</PreferNativeArm64>` to an otherwise default .NET Framework console app makes it fail with `MSB9902` because `Prefer32Bit` is enabled by default. I wonder if setting `PreferNativeArm64` shouldn't disable the `Prefer32Bit` auto opt-in. I.e. developers would get `MSB9902` only if they set `Prefer32Bit` explicitly in their project file.",
        "createdAt": "2024-05-23T14:17:13Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "> I have found a couple of issues when testing this PR in VS end to end.\r\n> \r\n> 1. The application manifest template in VS contains this XML:\r\n> \r\n> ```\r\n>   <application xmlns=\"urn:schemas-microsoft-com:asm.v3\">\r\n>     <windowsSettings>\r\n>       <dpiAware xmlns=\"http://schemas.microsoft.com/SMI/2005/WindowsSettings\">true</dpiAware>\r\n>       <longPathAware xmlns=\"http://schemas.microsoft.com/SMI/2016/WindowsSettings\">true</longPathAware>\r\n>     </windowsSettings>\r\n>   </application>\r\n> ```\r\n> \r\n> The `PopulateSupportedArchitectures` task is failing on it with:\r\n> \r\n> ```\r\n>       The \"PopulateSupportedArchitectures\" task failed unexpectedly.\r\n>       This is an unhandled exception from a task -- PLEASE OPEN A BUG AGAINST THE TASK OWNER.\r\n>       System.Xml.XmlException: The prefix '' cannot be redefined from 'urn:schemas-microsoft-com:asm.v3' to 'http://schemas.microsoft.com/SMI/2024/WindowsSe\r\n>       ttings' within the same start element tag.\r\n>          at System.Xml.XmlWellFormedWriter.PushNamespaceExplicit(String prefix, String ns)\r\n>          at System.Xml.XmlWellFormedWriter.WriteEndAttribute()\r\n>          at System.Xml.XmlElement.WriteStartElement(XmlWriter w)\r\n>          at System.Xml.XmlElement.WriteElementTo(XmlWriter writer, XmlElement e)\r\n>          at System.Xml.XmlDocument.Save(XmlWriter w)\r\n>          at Microsoft.Build.Tasks.PopulateSupportedArchitectures.SaveManifest(XmlDocument document, String manifestName) in C:\\src\\msbuild\\src\\Tasks\\Populat\r\n>       eSupportedArchitectures.cs:line 154\r\n>          at Microsoft.Build.Tasks.PopulateSupportedArchitectures.Execute() in C:\\src\\msbuild\\src\\Tasks\\PopulateSupportedArchitectures.cs:line 125\r\n>          at Microsoft.Build.BackEnd.TaskExecutionHost.Execute() in C:\\src\\msbuild\\src\\Build\\BackEnd\\TaskExecutionHost\\TaskExecutionHost.cs:line 587\r\n>          at Microsoft.Build.BackEnd.TaskBuilder.<ExecuteInstantiatedTask>d__26.MoveNext() in C:\\src\\msbuild\\src\\Build\\BackEnd\\Components\\RequestBuilder\\Task\r\n>       Builder.cs:line 807\r\n> ```\r\n> \r\n> 2. Adding `<PreferNativeArm64>true</PreferNativeArm64>` to an otherwise default .NET Framework console app makes it fail with `MSB9902` because `Prefer32Bit` is enabled by default. I wonder if setting `PreferNativeArm64` shouldn't disable the `Prefer32Bit` auto opt-in. I.e. developers would get `MSB9902` only if they set `Prefer32Bit` explicitly in their project file.\r\n\r\n\r\nFor the second point it would require special handling in VS by project systems - where on checking PreferNativeArm64 \r\n, Prefer32Bit has to be handled automatically. Can we solely decide it here?\r\n\r\nThe first one was fixed here: https://github.com/dotnet/msbuild/pull/10134/commits/170409ae1001daab2711695303a92cbe7f59a409",
        "createdAt": "2024-05-23T14:49:54Z",
        "author": {
          "login": "YuliiaKovalova"
        }
      },
      {
        "body": "> > 3\\. Adding `<PreferNativeArm64>true</PreferNativeArm64>` to an otherwise default .NET Framework console app makes it fail with `MSB9902` because `Prefer32Bit` is enabled by default. I wonder if setting `PreferNativeArm64` shouldn't disable the `Prefer32Bit` auto opt-in. I.e. developers would get `MSB9902` only if they set `Prefer32Bit` explicitly in their project file.\r\n> \r\n> For the second point it would require special handling in VS by project systems - where on checking PreferNativeArm64 , Prefer32Bit has to be handled automatically. Can we solely decide it here?\r\n\r\nI believe we do plan to implement some of this logic in Visual Studio project properties UI.\r\n- `Prefer native ARM64` should be automatically unchecked and disabled when platform target is not Any CPU.\r\n- Checking `Prefer native ARM64` when `Prefer 32-bit` is checked should uncheck `Prefer 32-bit`, and vice versa.\r\n\r\nSo things should work well in VS because VS adds `<Prefer32Bit>false</Prefer32Bit>` when the ARM64 checkbox is checked. My concern is with modifying the project outside of VS. Say that the user just adds `<PreferNativeArm64>true</PreferNativeArm64>` and then the project fails to build complaining about PreferNativeArm64 and Prefer32Bit both set. However, the user doesn't have Prefer32Bit in their project file, so they may find the error confusing.\r\n\r\nMy proposal is to update the condition here to test if `PreferNativeArm64` is set:\r\nhttps://github.com/dotnet/msbuild/blob/eade7200e9e8c3f7017c7eff60b7cf591b2e71ac/src/Tasks/Microsoft.NETFramework.CurrentVersion.props#L86",
        "createdAt": "2024-05-24T08:12:37Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This doesn't look relevant. Is the `Al` task being updated because it has a parameter named `Prefer32Bit` or are you planning to add support for native Arm64 to `Al` as well?",
              "createdAt": "2024-05-15T12:13:48Z",
              "path": "src/Tasks/Al.cs",
              "diffHunk": "@@ -199,6 +199,12 @@ public bool Prefer32Bit\n             get => GetBoolParameterWithDefault(nameof(Prefer32Bit), false);\n         }\n \n+        public bool PreferNativeArm64\n+        {\n+            set => Bag[nameof(PreferNativeArm64)] = value;\n+            get => GetBoolParameterWithDefault(nameof(PreferNativeArm64), false);\n+        }\n+",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I added it just due to Prefer32Bit presence. I will remove it",
              "createdAt": "2024-05-15T13:38:00Z",
              "path": "src/Tasks/Al.cs",
              "diffHunk": "@@ -199,6 +199,12 @@ public bool Prefer32Bit\n             get => GetBoolParameterWithDefault(nameof(Prefer32Bit), false);\n         }\n \n+        public bool PreferNativeArm64\n+        {\n+            set => Bag[nameof(PreferNativeArm64)] = value;\n+            get => GetBoolParameterWithDefault(nameof(PreferNativeArm64), false);\n+        }\n+",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Did you intend to add `_SetPreferNativeArm64Win32ManifestProperties` as a dependency, without removing the existing `_SetEmbeddedWin32ManifestProperties`?",
              "createdAt": "2024-05-15T12:21:57Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4107,7 +4121,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n   <Target\n       Name=\"SetWin32ManifestProperties\"\n       Condition=\"'$(Win32Manifest)'==''\"\n-      DependsOnTargets=\"ResolveComReferences;ResolveNativeReferences;_SetExternalWin32ManifestProperties;_SetEmbeddedWin32ManifestProperties\" />\n+      DependsOnTargets=\"ResolveComReferences;ResolveNativeReferences;_SetExternalWin32ManifestProperties;_SetPreferNativeArm64Win32ManifestProperties\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo \"Any CPU\", with a space.",
              "createdAt": "2024-05-15T12:22:27Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -854,6 +854,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <PlatformTargetAsMSBuildArchitecture>x86</PlatformTargetAsMSBuildArchitecture>\n     </PropertyGroup>\n \n+    <Error Condition=\" '$(Prefer32Bit)' == 'true' and '$(PreferNativeArm64)' == 'true' \"\n+           Code=\"MSB9901\"\n+           Text=\"Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please disable one of those.\"\n+            />\n+\n+    <Error Condition=\" '$(NoWin32Manifest)' == 'true' and '$(PreferNativeArm64)' == 'true' \"\n+           Code=\"MSB9902\"\n+           Text=\"NoWin32Manifest and PreferNativeArm64 options are mutually exclusive. Please disable one of those.\"\n+            />\n+\n+    <Warning Condition=\" '$(PreferNativeArm64)' == 'true' and '$(Platform)' != 'AnyCPU' \"\n+             Code=\"MSB9903\"\n+             Text=\"When PreferNativeArm64 is enabled, ensure that the Platform is set to Any CPU.\"",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This doesn't look right. Developers may set `Win32Manifest` in their project file (it is documented for example here: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/resources#win32manifest) and if they do so, this target will be skipped and everything in `DependsOnTargets` will be skipped as well. We need the new task to run if the developer set `Win32Manifest`.",
              "createdAt": "2024-05-15T12:27:26Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4107,7 +4121,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n   <Target\n       Name=\"SetWin32ManifestProperties\"\n       Condition=\"'$(Win32Manifest)'==''\"",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I have done it. Please take a look",
              "createdAt": "2024-05-16T13:43:22Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4107,7 +4121,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n   <Target\n       Name=\"SetWin32ManifestProperties\"\n       Condition=\"'$(Win32Manifest)'==''\"",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Can the `Platform`, `Prefer32Bit` and `NoWin32Manifest` checks be omitted because we already validated them with `Error`/`Warning` above?",
              "createdAt": "2024-05-15T12:31:06Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4130,6 +4144,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <Target\n+    Name=\"_SetPreferNativeArm64Win32ManifestProperties\"\n+    Condition=\" '$(PreferNativeArm64)'=='true' and '$(Platform)'=='AnyCPU' and '$(Prefer32Bit)'!='true' and '$(NoWin32Manifest)'!='true' \">",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there anything blocking this task from running on non-Windows? I'm not sure what exactly is officially supported, but building an ARM64 .NET Framework executable with the .NET SDK looks like a reasonable scenario.",
              "createdAt": "2024-05-15T12:49:53Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,200 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Yes, I think you should be able to build a Windows application on Linux.",
              "createdAt": "2024-05-15T15:12:06Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,200 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Similar to `Al.cs`, I don't think the prop should be added here.",
              "createdAt": "2024-05-15T12:50:56Z",
              "path": "src/Tasks/ResolveSDKReference.cs",
              "diffHunk": "@@ -237,6 +237,11 @@ public string TargetPlatformVersion\n         /// </summary>\n         public bool Prefer32Bit { get; set; }\n \n+        /// <summary>\n+        /// The preferNativeArm64 flag used during the build\n+        /// </summary>\n+        public bool PreferNativeArm64 { get; set; }\n+",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Is there really no gap in the MSB3001 - MSB3999 range?",
              "createdAt": "2024-05-15T12:58:03Z",
              "path": "src/Tasks/Resources/Strings.resx",
              "diffHunk": "@@ -3100,9 +3111,12 @@\n             MSB3971 - MSB3980   Task: GetReferenceAssemblyPaths overflow\n             MSB3981 - MSB3990   Task: GetCompatiblePlatform\n             MSB3991 - MSB3999   Task: CombineTargetFrameworkInfoProperties\n+            MSB9911 - MSB9920   Task: PopulateSupportedArchitectures",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "changed the range, please check if it's any better",
              "createdAt": "2024-05-15T17:18:04Z",
              "path": "src/Tasks/Resources/Strings.resx",
              "diffHunk": "@@ -3100,9 +3111,12 @@\n             MSB3971 - MSB3980   Task: GetReferenceAssemblyPaths overflow\n             MSB3981 - MSB3990   Task: GetCompatiblePlatform\n             MSB3991 - MSB3999   Task: CombineTargetFrameworkInfoProperties\n+            MSB9911 - MSB9920   Task: PopulateSupportedArchitectures",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Properties should precede methods.",
              "createdAt": "2024-05-15T13:07:03Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,200 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string SupportedArchitecturesValue = \"amd64 arm64\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputPath = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output path.\n+        /// </summary>\n+        [Required]\n+        public string OutputPath\n+        {\n+            get => _outputPath;\n+            set => _outputPath = value ?? throw new ArgumentNullException(nameof(OutputPath));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        public override bool Execute()\n+        {\n+            Debugger.Launch();\n+            if (!string.IsNullOrEmpty(PathToManifest))\n+            {\n+                XmlDocument document = LoadManifest(PathToManifest);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(string path)\n+        {\n+            XmlDocument document = new XmlDocument();\n+            using (FileStream fs = File.OpenRead(path))\n+            using (XmlReader xr = XmlReader.Create(fs, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document)\n+        {\n+            ManifestPath = Path.Combine(OutputPath, Path.GetFileName(PathToManifest));\n+\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitecturesValue, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private string PathToManifest => string.IsNullOrEmpty(ApplicationManifestPath) || !File.Exists(ApplicationManifestPath)\n+                ? ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Latest)\n+                : ApplicationManifestPath ?? string.Empty;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Nested types should precede methods.",
              "createdAt": "2024-05-15T13:07:38Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,200 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string SupportedArchitecturesValue = \"amd64 arm64\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputPath = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output path.\n+        /// </summary>\n+        [Required]\n+        public string OutputPath\n+        {\n+            get => _outputPath;\n+            set => _outputPath = value ?? throw new ArgumentNullException(nameof(OutputPath));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        public override bool Execute()\n+        {\n+            Debugger.Launch();\n+            if (!string.IsNullOrEmpty(PathToManifest))\n+            {\n+                XmlDocument document = LoadManifest(PathToManifest);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(string path)\n+        {\n+            XmlDocument document = new XmlDocument();\n+            using (FileStream fs = File.OpenRead(path))\n+            using (XmlReader xr = XmlReader.Create(fs, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document)\n+        {\n+            ManifestPath = Path.Combine(OutputPath, Path.GetFileName(PathToManifest));\n+\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitecturesValue, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private string PathToManifest => string.IsNullOrEmpty(ApplicationManifestPath) || !File.Exists(ApplicationManifestPath)\n+                ? ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Latest)\n+                : ApplicationManifestPath ?? string.Empty;\n+\n+        private void PopulateSupportedArchitecturesElement(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            XmlNode assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager)\n+                ?? throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"PopulateSupportedArchitectures.AssemblyNodeIsMissed\"));\n+\n+            XmlElement appNode = GetOrCreateXmlElement(document , xmlNamespaceManager, \"application\", asmv3Prefix, XmlNamespaces.asmv3);\n+            XmlElement winSettingsNode = GetOrCreateXmlElement(document, xmlNamespaceManager, windowsSettings, asmv3Prefix, XmlNamespaces.asmv3);\n+            if (string.IsNullOrEmpty(winSettingsNode.GetAttribute(XMakeAttributes.xmlns)))\n+            {\n+                winSettingsNode.SetAttribute(XMakeAttributes.xmlns, WindowsSettingsNamespace);\n+            }\n+\n+            XmlElement supportedArchitecturesNode = GetOrCreateXmlElement(document, xmlNamespaceManager, supportedArchitectures, namespaceURI: WindowsSettingsNamespace);\n+            supportedArchitecturesNode.InnerText = SupportedArchitecturesValue;\n+            winSettingsNode.AppendChild(supportedArchitecturesNode);\n+            appNode.AppendChild(winSettingsNode);\n+            assemblyNode.AppendChild(appNode);\n+        }\n+\n+        private XmlElement GetOrCreateXmlElement(XmlDocument document, XmlNamespaceManager xmlNamespaceManager, string localName, string prefix = \"\", string namespaceURI = \"\")\n+        {\n+            bool isPrefixed = !string.IsNullOrEmpty(prefix);\n+\n+            XmlNode? existingNode = isPrefixed\n+                ? document.SelectSingleNode($\"//{prefix}:{localName}\", xmlNamespaceManager)\n+                : document.SelectSingleNode($\"//{localName}\", xmlNamespaceManager);\n+\n+            if (existingNode is not null and XmlElement element)\n+            {\n+                return element;\n+            }\n+\n+            return isPrefixed\n+                ? document.CreateElement(prefix, localName, namespaceURI)\n+                : document.CreateElement(localName, namespaceURI);\n+        }\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Would you consider renaming to `OutputDirectory` to emphasize that, unlike `ManifestPath`, it is not supposed to contain file name?",
              "createdAt": "2024-05-15T13:16:52Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,200 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string SupportedArchitecturesValue = \"amd64 arm64\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputPath = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output path.\n+        /// </summary>\n+        [Required]\n+        public string OutputPath",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`ManifestPath` is not set in this case. Isn't it a problem since it's unconditionally assigned to a build property in `Microsoft.Common.CurrentVersion.targets`?",
              "createdAt": "2024-05-15T13:19:32Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,200 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string SupportedArchitecturesValue = \"amd64 arm64\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputPath = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output path.\n+        /// </summary>\n+        [Required]\n+        public string OutputPath\n+        {\n+            get => _outputPath;\n+            set => _outputPath = value ?? throw new ArgumentNullException(nameof(OutputPath));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        public override bool Execute()\n+        {\n+            Debugger.Launch();\n+            if (!string.IsNullOrEmpty(PathToManifest))\n+            {\n+                XmlDocument document = LoadManifest(PathToManifest);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "it's a good catch, thank you :)",
              "createdAt": "2024-05-15T15:55:54Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,200 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string SupportedArchitecturesValue = \"amd64 arm64\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputPath = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output path.\n+        /// </summary>\n+        [Required]\n+        public string OutputPath\n+        {\n+            get => _outputPath;\n+            set => _outputPath = value ?? throw new ArgumentNullException(nameof(OutputPath));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        public override bool Execute()\n+        {\n+            Debugger.Launch();\n+            if (!string.IsNullOrEmpty(PathToManifest))\n+            {\n+                XmlDocument document = LoadManifest(PathToManifest);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I think it would be nice to make this a task parameter. Especially since the task name is generic and does not hint at anything ARM64 related.",
              "createdAt": "2024-05-15T13:25:29Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,200 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string SupportedArchitecturesValue = \"amd64 arm64\";",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "There are many examples of doing it this way in the targets, but it's bad to have unlocalized errors/warnings like these. Can this validation go into a task to get localized?",
              "createdAt": "2024-05-15T15:11:20Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -854,6 +854,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <PlatformTargetAsMSBuildArchitecture>x86</PlatformTargetAsMSBuildArchitecture>\n     </PropertyGroup>\n \n+    <Error Condition=\" '$(Prefer32Bit)' == 'true' and '$(PreferNativeArm64)' == 'true' \"\n+           Code=\"MSB9901\"\n+           Text=\"Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please disable one of those.\"",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "The SDK made a repo-local task for emitting localized warnings or errors - I think that could be useful for this repo as well.",
              "createdAt": "2024-05-15T15:28:25Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -854,6 +854,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <PlatformTargetAsMSBuildArchitecture>x86</PlatformTargetAsMSBuildArchitecture>\n     </PropertyGroup>\n \n+    <Error Condition=\" '$(Prefer32Bit)' == 'true' and '$(PreferNativeArm64)' == 'true' \"\n+           Code=\"MSB9901\"\n+           Text=\"Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please disable one of those.\"",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why set this explicitly, instead of letting it be default/empty?",
              "createdAt": "2024-05-15T15:14:49Z",
              "path": "src/Tasks/Microsoft.NETFramework.CurrentVersion.props",
              "diffHunk": "@@ -85,6 +85,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   <PropertyGroup Condition=\"'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == '')\">\n     <Prefer32Bit Condition=\"'$(Prefer32Bit)' == ''\">true</Prefer32Bit>\n+    <PreferNativeArm64 Condition=\"'$(PreferNativeArm64)' == ''\">false</PreferNativeArm64>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I did it according to https://github.com/dotnet/msbuild/issues/10060#:~:text=to%20false.%20PreferNativeArm64-,is%20a%20false%2Dby%2Ddefault,-opt%2Din%20switch\r\n\r\nHave I misunderstood it? :)",
              "createdAt": "2024-05-15T17:13:20Z",
              "path": "src/Tasks/Microsoft.NETFramework.CurrentVersion.props",
              "diffHunk": "@@ -85,6 +85,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   <PropertyGroup Condition=\"'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == '')\">\n     <Prefer32Bit Condition=\"'$(Prefer32Bit)' == ''\">true</Prefer32Bit>\n+    <PreferNativeArm64 Condition=\"'$(PreferNativeArm64)' == ''\">false</PreferNativeArm64>",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "There are two ways to make something false-by-default in MSBuild:\r\n\r\n1. Set the property in a .targets file (late in eval, after the project body) to a default value of `false` if it's not set (like you're doing here)\r\n2. Treat \"unspecified\"/\"empty string\" expansions of that property as `false`.\r\n\r\nI tend to prefer the latter, but it's a judgement call; I was asking if you have a specific reason to prefer the former.",
              "createdAt": "2024-05-15T17:23:40Z",
              "path": "src/Tasks/Microsoft.NETFramework.CurrentVersion.props",
              "diffHunk": "@@ -85,6 +85,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   <PropertyGroup Condition=\"'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == '')\">\n     <Prefer32Bit Condition=\"'$(Prefer32Bit)' == ''\">true</Prefer32Bit>\n+    <PreferNativeArm64 Condition=\"'$(PreferNativeArm64)' == ''\">false</PreferNativeArm64>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Thank you for explanation, I will clean it up",
              "createdAt": "2024-05-16T10:47:55Z",
              "path": "src/Tasks/Microsoft.NETFramework.CurrentVersion.props",
              "diffHunk": "@@ -85,6 +85,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   <PropertyGroup Condition=\"'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == '')\">\n     <Prefer32Bit Condition=\"'$(Prefer32Bit)' == ''\">true</Prefer32Bit>\n+    <PreferNativeArm64 Condition=\"'$(PreferNativeArm64)' == ''\">false</PreferNativeArm64>",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I would prefer a clear, explicit error in the \"user specified a file but it doesn't exist\" case.",
              "createdAt": "2024-05-15T15:24:13Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,198 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string SupportedArchitecturesValue = \"amd64 arm64\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputPath = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output path.\n+        /// </summary>\n+        [Required]\n+        public string OutputPath\n+        {\n+            get => _outputPath;\n+            set => _outputPath = value ?? throw new ArgumentNullException(nameof(OutputPath));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        public override bool Execute()\n+        {\n+            if (!string.IsNullOrEmpty(PathToManifest))\n+            {\n+                XmlDocument document = LoadManifest(PathToManifest);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(string path)\n+        {\n+            XmlDocument document = new XmlDocument();\n+            using (FileStream fs = File.OpenRead(path))\n+            using (XmlReader xr = XmlReader.Create(fs, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document)\n+        {\n+            ManifestPath = Path.Combine(OutputPath, Path.GetFileName(PathToManifest));\n+\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitecturesValue, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private string PathToManifest => string.IsNullOrEmpty(ApplicationManifestPath) || !File.Exists(ApplicationManifestPath)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This couples the output of the build to the running .NET Framework (and would fail on Core, right?). Should we embed the default manifest into this task instead?",
              "createdAt": "2024-05-15T15:25:07Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,198 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string SupportedArchitecturesValue = \"amd64 arm64\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputPath = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output path.\n+        /// </summary>\n+        [Required]\n+        public string OutputPath\n+        {\n+            get => _outputPath;\n+            set => _outputPath = value ?? throw new ArgumentNullException(nameof(OutputPath));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        public override bool Execute()\n+        {\n+            if (!string.IsNullOrEmpty(PathToManifest))\n+            {\n+                XmlDocument document = LoadManifest(PathToManifest);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(string path)\n+        {\n+            XmlDocument document = new XmlDocument();\n+            using (FileStream fs = File.OpenRead(path))\n+            using (XmlReader xr = XmlReader.Create(fs, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document)\n+        {\n+            ManifestPath = Path.Combine(OutputPath, Path.GetFileName(PathToManifest));\n+\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitecturesValue, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private string PathToManifest => string.IsNullOrEmpty(ApplicationManifestPath) || !File.Exists(ApplicationManifestPath)\n+                ? ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Latest)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Added manifest to msbuild that will be a fallback mechanism if TargetDotNetFrameworkVersion.46 doesn't exists (taken from Roslyn)",
              "createdAt": "2024-05-16T13:48:09Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,198 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string SupportedArchitecturesValue = \"amd64 arm64\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputPath = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output path.\n+        /// </summary>\n+        [Required]\n+        public string OutputPath\n+        {\n+            get => _outputPath;\n+            set => _outputPath = value ?? throw new ArgumentNullException(nameof(OutputPath));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        public override bool Execute()\n+        {\n+            if (!string.IsNullOrEmpty(PathToManifest))\n+            {\n+                XmlDocument document = LoadManifest(PathToManifest);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(string path)\n+        {\n+            XmlDocument document = new XmlDocument();\n+            using (FileStream fs = File.OpenRead(path))\n+            using (XmlReader xr = XmlReader.Create(fs, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document)\n+        {\n+            ManifestPath = Path.Combine(OutputPath, Path.GetFileName(PathToManifest));\n+\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitecturesValue, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private string PathToManifest => string.IsNullOrEmpty(ApplicationManifestPath) || !File.Exists(ApplicationManifestPath)\n+                ? ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Latest)",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "https://github.com/dotnet/roslyn/blob/main/src/Compilers/Core/Portable/Compilation/Compilation.cs#L1920-L1924\r\n",
              "createdAt": "2024-05-17T06:39:02Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,198 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Runtime.Versioning;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    [SupportedOSPlatform(\"windows\")]\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string SupportedArchitecturesValue = \"amd64 arm64\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputPath = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output path.\n+        /// </summary>\n+        [Required]\n+        public string OutputPath\n+        {\n+            get => _outputPath;\n+            set => _outputPath = value ?? throw new ArgumentNullException(nameof(OutputPath));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        public override bool Execute()\n+        {\n+            if (!string.IsNullOrEmpty(PathToManifest))\n+            {\n+                XmlDocument document = LoadManifest(PathToManifest);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(string path)\n+        {\n+            XmlDocument document = new XmlDocument();\n+            using (FileStream fs = File.OpenRead(path))\n+            using (XmlReader xr = XmlReader.Create(fs, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document)\n+        {\n+            ManifestPath = Path.Combine(OutputPath, Path.GetFileName(PathToManifest));\n+\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitecturesValue, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private string PathToManifest => string.IsNullOrEmpty(ApplicationManifestPath) || !File.Exists(ApplicationManifestPath)\n+                ? ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Latest)",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems unnecessarily complex. Why not inline it as a `switch` statement into `Execute`?",
              "createdAt": "2024-05-16T15:28:10Z",
              "path": "src/Tasks/NETMessage.cs",
              "diffHunk": "@@ -0,0 +1,81 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.Deployment.Bootstrapper;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class NETMessage : TaskExtension\n+    {\n+        private readonly Dictionary<BuildMessageSeverity, Func<bool>> _severityToActionMap;\n+\n+        public NETMessage()\n+        {\n+            _severityToActionMap = new Dictionary<BuildMessageSeverity, Func<bool>>()\n+            {\n+                {\n+                    BuildMessageSeverity.Error, () =>\n+                    {\n+                        Log.LogErrorWithCodeFromResources(ResourceName, FormatArguments);\n+                        return false;\n+                    }\n+                },\n+                {\n+                    BuildMessageSeverity.Warning, () =>\n+                    {\n+                        Log.LogWarningWithCodeFromResources(ResourceName, FormatArguments);\n+                        return true;\n+                    }\n+                },\n+                {\n+                    BuildMessageSeverity.Info, () =>\n+                    {\n+                        MessageImportance importance = (MessageImportance)Enum.Parse(typeof(MessageImportance), MessageImportance, true);\n+                        Log.LogMessageFromResources(importance, ResourceName, FormatArguments);\n+                        return true;\n+                    }\n+                },\n+            };\n+        }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `_SupportedArchitectures` because it's \"internal\".",
              "createdAt": "2024-05-16T15:29:58Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4149,6 +4156,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ============================================================\n+                                        _SetPreferNativeArm64Win32ManifestProperties\n+\n+    Populates Manifest with SupportedArchitectures and produces Win32Manifest property to be used later in the build.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"_SetPreferNativeArm64Win32ManifestProperties\"\n+      Condition=\" '$(PreferNativeArm64)'=='true' \"\n+      DependsOnTargets=\"SetWin32ManifestProperties\">\n+\n+    <PropertyGroup>\n+      <SupportedArchitectures>amd64 arm64</SupportedArchitectures>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Mutating the user-supplied property looks non-standard / suspicious. I would probably leave it and use `_Win32Manifest` when invoking the compiler. @rainersigwald, what do you think?",
              "createdAt": "2024-05-16T15:35:06Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4149,6 +4156,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ============================================================\n+                                        _SetPreferNativeArm64Win32ManifestProperties\n+\n+    Populates Manifest with SupportedArchitectures and produces Win32Manifest property to be used later in the build.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"_SetPreferNativeArm64Win32ManifestProperties\"\n+      Condition=\" '$(PreferNativeArm64)'=='true' \"\n+      DependsOnTargets=\"SetWin32ManifestProperties\">\n+\n+    <PropertyGroup>\n+      <SupportedArchitectures>amd64 arm64</SupportedArchitectures>\n+    </PropertyGroup>\n+\n+    <PopulateSupportedArchitectures\n+        ApplicationManifestPath=\"$(Win32Manifest)\"\n+        OutputDirectory=\"$(IntermediateOutputPath)\"\n+        SupportedArchitectures=\"$(SupportedArchitectures)\">\n+\n+        <Output TaskParameter=\"ManifestPath\" PropertyName=\"_Win32Manifest\"/>\n+    </PopulateSupportedArchitectures>\n+\n+    <PropertyGroup>\n+      <Win32Manifest Condition=\"'$(_Win32Manifest)' != ''\">$(_Win32Manifest)</Win32Manifest>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I actually prefer this way, because it would Just Work\u2122\ufe0f if someone was  inspecting or modifying the property (maybe doing some augmentation like this themselves).\r\n\r\nIdeally everything would have a public target that allows hooking final modification times, and we'd inject before that (and maybe then copy to a private underscore variable at that point and use that going forward). But that's not done consistently.",
              "createdAt": "2024-05-23T16:45:09Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4149,6 +4156,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ============================================================\n+                                        _SetPreferNativeArm64Win32ManifestProperties\n+\n+    Populates Manifest with SupportedArchitectures and produces Win32Manifest property to be used later in the build.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"_SetPreferNativeArm64Win32ManifestProperties\"\n+      Condition=\" '$(PreferNativeArm64)'=='true' \"\n+      DependsOnTargets=\"SetWin32ManifestProperties\">\n+\n+    <PropertyGroup>\n+      <SupportedArchitectures>amd64 arm64</SupportedArchitectures>\n+    </PropertyGroup>\n+\n+    <PopulateSupportedArchitectures\n+        ApplicationManifestPath=\"$(Win32Manifest)\"\n+        OutputDirectory=\"$(IntermediateOutputPath)\"\n+        SupportedArchitectures=\"$(SupportedArchitectures)\">\n+\n+        <Output TaskParameter=\"ManifestPath\" PropertyName=\"_Win32Manifest\"/>\n+    </PopulateSupportedArchitectures>\n+\n+    <PropertyGroup>\n+      <Win32Manifest Condition=\"'$(_Win32Manifest)' != ''\">$(_Win32Manifest)</Win32Manifest>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Gotcha - actually maybe `Win32Manifest` should be considered internal, despite the missing underscore, and `ApplicationManifest` is what we expect the user to set in their project files.\r\n\r\nLooking at this target then, I wonder how this feature interacts with ClickOnce:\r\nhttps://github.com/dotnet/msbuild/blob/eade7200e9e8c3f7017c7eff60b7cf591b2e71ac/src/Tasks/Microsoft.Common.CurrentVersion.targets#L4133-L4135\r\n\r\nRight now it looks like `PreferNativeArm64` has no effect on ClickOnce projects. Ideally I think it should do something or error out.",
              "createdAt": "2024-05-24T07:53:31Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4149,6 +4156,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ============================================================\n+                                        _SetPreferNativeArm64Win32ManifestProperties\n+\n+    Populates Manifest with SupportedArchitectures and produces Win32Manifest property to be used later in the build.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"_SetPreferNativeArm64Win32ManifestProperties\"\n+      Condition=\" '$(PreferNativeArm64)'=='true' \"\n+      DependsOnTargets=\"SetWin32ManifestProperties\">\n+\n+    <PropertyGroup>\n+      <SupportedArchitectures>amd64 arm64</SupportedArchitectures>\n+    </PropertyGroup>\n+\n+    <PopulateSupportedArchitectures\n+        ApplicationManifestPath=\"$(Win32Manifest)\"\n+        OutputDirectory=\"$(IntermediateOutputPath)\"\n+        SupportedArchitectures=\"$(SupportedArchitectures)\">\n+\n+        <Output TaskParameter=\"ManifestPath\" PropertyName=\"_Win32Manifest\"/>\n+    </PopulateSupportedArchitectures>\n+\n+    <PropertyGroup>\n+      <Win32Manifest Condition=\"'$(_Win32Manifest)' != ''\">$(_Win32Manifest)</Win32Manifest>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "handled in scope of https://github.com/dotnet/msbuild/pull/10134/commits/98cae2341e40d9ab666e25de3166b8ad30945dde",
              "createdAt": "2024-05-24T10:45:28Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4149,6 +4156,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ============================================================\n+                                        _SetPreferNativeArm64Win32ManifestProperties\n+\n+    Populates Manifest with SupportedArchitectures and produces Win32Manifest property to be used later in the build.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"_SetPreferNativeArm64Win32ManifestProperties\"\n+      Condition=\" '$(PreferNativeArm64)'=='true' \"\n+      DependsOnTargets=\"SetWin32ManifestProperties\">\n+\n+    <PropertyGroup>\n+      <SupportedArchitectures>amd64 arm64</SupportedArchitectures>\n+    </PropertyGroup>\n+\n+    <PopulateSupportedArchitectures\n+        ApplicationManifestPath=\"$(Win32Manifest)\"\n+        OutputDirectory=\"$(IntermediateOutputPath)\"\n+        SupportedArchitectures=\"$(SupportedArchitectures)\">\n+\n+        <Output TaskParameter=\"ManifestPath\" PropertyName=\"_Win32Manifest\"/>\n+    </PopulateSupportedArchitectures>\n+\n+    <PropertyGroup>\n+      <Win32Manifest Condition=\"'$(_Win32Manifest)' != ''\">$(_Win32Manifest)</Win32Manifest>",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "Apologies, after some more testing I'm not convinced this is correct. If the app has both an embedded manifest and an external .exe.manifest (the former added by `PreferNativeArm64`, the latter added by ClickOnce targets), Windows will ignore the external one and the app will likely not run correctly.\r\n\r\nWhat we need to do to support this scenario is hook into the targets that add/modify the external manifest to add our content there.",
              "createdAt": "2024-05-24T15:00:36Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4149,6 +4156,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ============================================================\n+                                        _SetPreferNativeArm64Win32ManifestProperties\n+\n+    Populates Manifest with SupportedArchitectures and produces Win32Manifest property to be used later in the build.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"_SetPreferNativeArm64Win32ManifestProperties\"\n+      Condition=\" '$(PreferNativeArm64)'=='true' \"\n+      DependsOnTargets=\"SetWin32ManifestProperties\">\n+\n+    <PropertyGroup>\n+      <SupportedArchitectures>amd64 arm64</SupportedArchitectures>\n+    </PropertyGroup>\n+\n+    <PopulateSupportedArchitectures\n+        ApplicationManifestPath=\"$(Win32Manifest)\"\n+        OutputDirectory=\"$(IntermediateOutputPath)\"\n+        SupportedArchitectures=\"$(SupportedArchitectures)\">\n+\n+        <Output TaskParameter=\"ManifestPath\" PropertyName=\"_Win32Manifest\"/>\n+    </PopulateSupportedArchitectures>\n+\n+    <PropertyGroup>\n+      <Win32Manifest Condition=\"'$(_Win32Manifest)' != ''\">$(_Win32Manifest)</Win32Manifest>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "The repro is:\r\n1. Create a new Framework Winforms project in VS.\r\n2. Go to Build -> Publish and choose a local path to publish to.\r\n3. Inspect the bin directory of the project - `<app-name>.exe.manifest` is the external Win32 manifest.",
              "createdAt": "2024-05-24T15:08:51Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4149,6 +4156,37 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n \n   </Target>\n \n+  <!--\n+    ============================================================\n+                                        _SetPreferNativeArm64Win32ManifestProperties\n+\n+    Populates Manifest with SupportedArchitectures and produces Win32Manifest property to be used later in the build.\n+    ============================================================\n+    -->\n+\n+  <Target\n+      Name=\"_SetPreferNativeArm64Win32ManifestProperties\"\n+      Condition=\" '$(PreferNativeArm64)'=='true' \"\n+      DependsOnTargets=\"SetWin32ManifestProperties\">\n+\n+    <PropertyGroup>\n+      <SupportedArchitectures>amd64 arm64</SupportedArchitectures>\n+    </PropertyGroup>\n+\n+    <PopulateSupportedArchitectures\n+        ApplicationManifestPath=\"$(Win32Manifest)\"\n+        OutputDirectory=\"$(IntermediateOutputPath)\"\n+        SupportedArchitectures=\"$(SupportedArchitectures)\">\n+\n+        <Output TaskParameter=\"ManifestPath\" PropertyName=\"_Win32Manifest\"/>\n+    </PopulateSupportedArchitectures>\n+\n+    <PropertyGroup>\n+      <Win32Manifest Condition=\"'$(_Win32Manifest)' != ''\">$(_Win32Manifest)</Win32Manifest>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Isn't `if (!(A || (A && B)))` equivalent to `if (!(A))` ?\r\n\r\n```suggestion\r\n            if (!string.IsNullOrEmpty(pathToManifest))\r\n```",
              "createdAt": "2024-05-16T15:47:34Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,227 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private string? GetPathToManifest()\n+        {\n+            if (!string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                if (!File.Exists(ApplicationManifestPath))\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\", ApplicationManifestPath);\n+                    return null;\n+                }\n+\n+                return ApplicationManifestPath;\n+            }\n+\n+            // The logic for getting default manifest is similar to the one from Roslyn:\n+            // If Roslyn logic returns null, we fall back to reading embedded manifest.\n+            return ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);\n+        }\n+\n+        public override bool Execute()\n+        {\n+            string? pathToManifest = GetPathToManifest();\n+\n+            // Only if ApplicationManifest was not specified, we can try to load the embedded manifest.\n+            if (!(string.IsNullOrEmpty(pathToManifest) || (string.IsNullOrEmpty(pathToManifest) && string.IsNullOrEmpty(ApplicationManifestPath))))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "suggestion: Maybe this method can return `Stream` instead of the `(bool, string)` tuple. It would keep the logic to decide where to read the manifest from in one place.",
              "createdAt": "2024-05-16T15:56:03Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,227 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private (bool canProcceed, string? path) GetPathToManifest()",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think this should be \"element\" rather than \"node\". The [documentation](https://learn.microsoft.com/en-us/windows/win32/sbscs/application-manifests#assembly) uses this word as well.\r\n\r\nAlso, for the second sentence, the user may have specified the manifest using the `Win32Manifest` property in which case the reference to `ApplicationManifest` would be confusing.\r\n\r\nI would probably simplify to:\r\n\r\n```suggestion\r\n    <value>The assembly element is missing from the application manifest.</value>\r\n```",
              "createdAt": "2024-05-23T12:30:56Z",
              "path": "src/Tasks/Resources/Strings.resx",
              "diffHunk": "@@ -3013,6 +3013,40 @@\n     <value>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</value>\n     <comment>{StrBegin=\"MSB3992: \"}</comment>\n   </data>\n+\n+  <!--\n+        MSB4300 - MSB4310   Task: PopulateSupportedArchitectures\n+  -->\n+  <data name=\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\">\n+    <value>MSB4300: The specified value: '{0}' for supportedArchitectures element is invalid. Either remove it from manifest or set as 'amd64 arm64'.</value>\n+    <comment>{StrBegin=\"MSB4300: \"}</comment>\n+  </data>\n+  <data name=\"PopulateSupportedArchitectures.AssemblyNodeIsMissed\">\n+    <value>The assembly node is missing from the manifest. Check your ApplicationManifest file.</value>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    <value>The application manifest file cannot be found: '{0}'. Please make sure it exists.</value>\r\n```",
              "createdAt": "2024-05-23T12:31:34Z",
              "path": "src/Tasks/Resources/Strings.resx",
              "diffHunk": "@@ -3013,6 +3013,40 @@\n     <value>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</value>\n     <comment>{StrBegin=\"MSB3992: \"}</comment>\n   </data>\n+\n+  <!--\n+        MSB4300 - MSB4310   Task: PopulateSupportedArchitectures\n+  -->\n+  <data name=\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\">\n+    <value>MSB4300: The specified value: '{0}' for supportedArchitectures element is invalid. Either remove it from manifest or set as 'amd64 arm64'.</value>\n+    <comment>{StrBegin=\"MSB4300: \"}</comment>\n+  </data>\n+  <data name=\"PopulateSupportedArchitectures.AssemblyNodeIsMissed\">\n+    <value>The assembly node is missing from the manifest. Check your ApplicationManifest file.</value>\n+  </data>\n+  <data name=\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\">\n+    <value>The file specified in ApplicationManifest can not be found: '{0}'. Please make sure it exists.</value>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I wonder if including the `Platform` value here wouldn't be helpful.",
              "createdAt": "2024-05-23T12:33:12Z",
              "path": "src/Tasks/Resources/Strings.resx",
              "diffHunk": "@@ -3013,6 +3013,40 @@\n     <value>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</value>\n     <comment>{StrBegin=\"MSB3992: \"}</comment>\n   </data>\n+\n+  <!--\n+        MSB4300 - MSB4310   Task: PopulateSupportedArchitectures\n+  -->\n+  <data name=\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\">\n+    <value>MSB4300: The specified value: '{0}' for supportedArchitectures element is invalid. Either remove it from manifest or set as 'amd64 arm64'.</value>\n+    <comment>{StrBegin=\"MSB4300: \"}</comment>\n+  </data>\n+  <data name=\"PopulateSupportedArchitectures.AssemblyNodeIsMissed\">\n+    <value>The assembly node is missing from the manifest. Check your ApplicationManifest file.</value>\n+  </data>\n+  <data name=\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\">\n+    <value>The file specified in ApplicationManifest can not be found: '{0}'. Please make sure it exists.</value>\n+  </data>\n+\n+  <!--\n+        MSB9901 - MSB9990   MSBuild common targets messages\n+  -->\n+  <data name=\"CommonTarget.SpecifiedSeverityDoesNotExist\">\n+    <value>The specified severity is not relevant: '{0}' for the message: '{1}'.</value>\n+  </data>\n+  <data name=\"CommonTarget.Prefer32BitAndPreferNativeArm64Enabled\">\n+    <value>MSB9902: Prefer32Bit and PreferNativeArm64 options are mutually exclusive. Please disable one of those.</value>\n+    <comment>{StrBegin=\"MSB9902: \"}</comment>\n+  </data>\n+  <data name=\"CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled\">\n+    <value>MSB9903: NoWin32Manifest and PreferNativeArm64 options are mutually exclusive. Please disable one of those.</value>\n+    <comment>{StrBegin=\"MSB9903: \"}</comment>\n+  </data>\n+  <data name=\"CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled\">\n+    <value>MSB9904: When PreferNativeArm64 is enabled, ensure that the Platform is set to AnyCPU.</value>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This commend does not seem to apply anymore.",
              "createdAt": "2024-05-23T12:39:09Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,224 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private Stream? GetManifestStream()\n+        {\n+            if (!string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                if (!File.Exists(ApplicationManifestPath))\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\", ApplicationManifestPath);\n+                    return null;\n+                }\n+\n+                return File.OpenRead(ApplicationManifestPath);\n+            }\n+\n+            string? defaultManifestPath = ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);\n+\n+            // The logic for getting default manifest is similar to the one from Roslyn:\n+            // If Roslyn logic returns null, we fall back to reading embedded manifest.\n+            return defaultManifestPath is null\n+                    ? typeof(PopulateSupportedArchitectures).Assembly.GetManifestResourceStream($\"Microsoft.Build.Tasks.Resources.{DefaultManifestName}\")\n+                    : File.OpenRead(defaultManifestPath);\n+        }\n+\n+        public override bool Execute()\n+        {\n+            using Stream? stream = GetManifestStream();\n+\n+            // Only if ApplicationManifest was not specified, we can try to load the embedded manifest.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't this be moved to `ValidateManifest`? Currently if `ValidateManifest` doesn't find the assembly element, it will return failure and we wouldn't even execute this line.",
              "createdAt": "2024-05-23T12:46:37Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,224 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private Stream? GetManifestStream()\n+        {\n+            if (!string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                if (!File.Exists(ApplicationManifestPath))\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\", ApplicationManifestPath);\n+                    return null;\n+                }\n+\n+                return File.OpenRead(ApplicationManifestPath);\n+            }\n+\n+            string? defaultManifestPath = ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);\n+\n+            // The logic for getting default manifest is similar to the one from Roslyn:\n+            // If Roslyn logic returns null, we fall back to reading embedded manifest.\n+            return defaultManifestPath is null\n+                    ? typeof(PopulateSupportedArchitectures).Assembly.GetManifestResourceStream($\"Microsoft.Build.Tasks.Resources.{DefaultManifestName}\")\n+                    : File.OpenRead(defaultManifestPath);\n+        }\n+\n+        public override bool Execute()\n+        {\n+            using Stream? stream = GetManifestStream();\n+\n+            // Only if ApplicationManifest was not specified, we can try to load the embedded manifest.\n+            if (stream is not null)\n+            {\n+                XmlDocument document = LoadManifest(stream);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document, Path.GetFileName(ApplicationManifestPath) ?? DefaultManifestName);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(Stream stream)\n+        {\n+            XmlDocument document = new XmlDocument();\n+\n+            using (XmlReader xr = XmlReader.Create(stream, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document, string manifestName)\n+        {\n+            ManifestPath = Path.Combine(OutputDirectory, manifestName);\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitectures, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private void PopulateSupportedArchitecturesElement(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            XmlNode assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager)\n+                ?? throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"PopulateSupportedArchitectures.AssemblyNodeIsMissed\"));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Extra space after `document`.",
              "createdAt": "2024-05-23T12:46:57Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,224 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private Stream? GetManifestStream()\n+        {\n+            if (!string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                if (!File.Exists(ApplicationManifestPath))\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\", ApplicationManifestPath);\n+                    return null;\n+                }\n+\n+                return File.OpenRead(ApplicationManifestPath);\n+            }\n+\n+            string? defaultManifestPath = ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);\n+\n+            // The logic for getting default manifest is similar to the one from Roslyn:\n+            // If Roslyn logic returns null, we fall back to reading embedded manifest.\n+            return defaultManifestPath is null\n+                    ? typeof(PopulateSupportedArchitectures).Assembly.GetManifestResourceStream($\"Microsoft.Build.Tasks.Resources.{DefaultManifestName}\")\n+                    : File.OpenRead(defaultManifestPath);\n+        }\n+\n+        public override bool Execute()\n+        {\n+            using Stream? stream = GetManifestStream();\n+\n+            // Only if ApplicationManifest was not specified, we can try to load the embedded manifest.\n+            if (stream is not null)\n+            {\n+                XmlDocument document = LoadManifest(stream);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document, Path.GetFileName(ApplicationManifestPath) ?? DefaultManifestName);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(Stream stream)\n+        {\n+            XmlDocument document = new XmlDocument();\n+\n+            using (XmlReader xr = XmlReader.Create(stream, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document, string manifestName)\n+        {\n+            ManifestPath = Path.Combine(OutputDirectory, manifestName);\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitectures, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private void PopulateSupportedArchitecturesElement(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            XmlNode assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager)\n+                ?? throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"PopulateSupportedArchitectures.AssemblyNodeIsMissed\"));\n+\n+            XmlElement appNode = GetOrCreateXmlElement(document , xmlNamespaceManager, \"application\", asmv3Prefix, XmlNamespaces.asmv3);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Also, shouldn't `\"application\"` also be added as a named constant?",
              "createdAt": "2024-05-23T12:48:06Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,224 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private Stream? GetManifestStream()\n+        {\n+            if (!string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                if (!File.Exists(ApplicationManifestPath))\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\", ApplicationManifestPath);\n+                    return null;\n+                }\n+\n+                return File.OpenRead(ApplicationManifestPath);\n+            }\n+\n+            string? defaultManifestPath = ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);\n+\n+            // The logic for getting default manifest is similar to the one from Roslyn:\n+            // If Roslyn logic returns null, we fall back to reading embedded manifest.\n+            return defaultManifestPath is null\n+                    ? typeof(PopulateSupportedArchitectures).Assembly.GetManifestResourceStream($\"Microsoft.Build.Tasks.Resources.{DefaultManifestName}\")\n+                    : File.OpenRead(defaultManifestPath);\n+        }\n+\n+        public override bool Execute()\n+        {\n+            using Stream? stream = GetManifestStream();\n+\n+            // Only if ApplicationManifest was not specified, we can try to load the embedded manifest.\n+            if (stream is not null)\n+            {\n+                XmlDocument document = LoadManifest(stream);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document, Path.GetFileName(ApplicationManifestPath) ?? DefaultManifestName);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(Stream stream)\n+        {\n+            XmlDocument document = new XmlDocument();\n+\n+            using (XmlReader xr = XmlReader.Create(stream, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document, string manifestName)\n+        {\n+            ManifestPath = Path.Combine(OutputDirectory, manifestName);\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitectures, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private void PopulateSupportedArchitecturesElement(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            XmlNode assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager)\n+                ?? throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"PopulateSupportedArchitectures.AssemblyNodeIsMissed\"));\n+\n+            XmlElement appNode = GetOrCreateXmlElement(document , xmlNamespaceManager, \"application\", asmv3Prefix, XmlNamespaces.asmv3);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Calling `AppendChild` on nodes that were already in the document results in moving them to be the last child. I think it would be better if the logic here did not make such edit and preserved the input XML as much as it can.",
              "createdAt": "2024-05-23T12:54:06Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,224 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private Stream? GetManifestStream()\n+        {\n+            if (!string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                if (!File.Exists(ApplicationManifestPath))\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\", ApplicationManifestPath);\n+                    return null;\n+                }\n+\n+                return File.OpenRead(ApplicationManifestPath);\n+            }\n+\n+            string? defaultManifestPath = ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);\n+\n+            // The logic for getting default manifest is similar to the one from Roslyn:\n+            // If Roslyn logic returns null, we fall back to reading embedded manifest.\n+            return defaultManifestPath is null\n+                    ? typeof(PopulateSupportedArchitectures).Assembly.GetManifestResourceStream($\"Microsoft.Build.Tasks.Resources.{DefaultManifestName}\")\n+                    : File.OpenRead(defaultManifestPath);\n+        }\n+\n+        public override bool Execute()\n+        {\n+            using Stream? stream = GetManifestStream();\n+\n+            // Only if ApplicationManifest was not specified, we can try to load the embedded manifest.\n+            if (stream is not null)\n+            {\n+                XmlDocument document = LoadManifest(stream);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document, Path.GetFileName(ApplicationManifestPath) ?? DefaultManifestName);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(Stream stream)\n+        {\n+            XmlDocument document = new XmlDocument();\n+\n+            using (XmlReader xr = XmlReader.Create(stream, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document, string manifestName)\n+        {\n+            ManifestPath = Path.Combine(OutputDirectory, manifestName);\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitectures, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private void PopulateSupportedArchitecturesElement(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            XmlNode assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager)\n+                ?? throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"PopulateSupportedArchitectures.AssemblyNodeIsMissed\"));\n+\n+            XmlElement appNode = GetOrCreateXmlElement(document , xmlNamespaceManager, \"application\", asmv3Prefix, XmlNamespaces.asmv3);\n+            XmlElement winSettingsNode = GetOrCreateXmlElement(document, xmlNamespaceManager, windowsSettings, asmv3Prefix, XmlNamespaces.asmv3);\n+            if (string.IsNullOrEmpty(winSettingsNode.GetAttribute(XMakeAttributes.xmlns)))\n+            {\n+                winSettingsNode.SetAttribute(XMakeAttributes.xmlns, WindowsSettingsNamespace);\n+            }\n+\n+            XmlElement supportedArchitecturesNode = GetOrCreateXmlElement(document, xmlNamespaceManager, supportedArchitectures, namespaceURI: WindowsSettingsNamespace);\n+            supportedArchitecturesNode.InnerText = SupportedArchitectures;\n+            winSettingsNode.AppendChild(supportedArchitecturesNode);\n+            appNode.AppendChild(winSettingsNode);\n+            assemblyNode.AppendChild(appNode);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "fixed and added a test for checking the saved xml structure",
              "createdAt": "2024-05-23T14:50:46Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,224 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private Stream? GetManifestStream()\n+        {\n+            if (!string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                if (!File.Exists(ApplicationManifestPath))\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\", ApplicationManifestPath);\n+                    return null;\n+                }\n+\n+                return File.OpenRead(ApplicationManifestPath);\n+            }\n+\n+            string? defaultManifestPath = ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);\n+\n+            // The logic for getting default manifest is similar to the one from Roslyn:\n+            // If Roslyn logic returns null, we fall back to reading embedded manifest.\n+            return defaultManifestPath is null\n+                    ? typeof(PopulateSupportedArchitectures).Assembly.GetManifestResourceStream($\"Microsoft.Build.Tasks.Resources.{DefaultManifestName}\")\n+                    : File.OpenRead(defaultManifestPath);\n+        }\n+\n+        public override bool Execute()\n+        {\n+            using Stream? stream = GetManifestStream();\n+\n+            // Only if ApplicationManifest was not specified, we can try to load the embedded manifest.\n+            if (stream is not null)\n+            {\n+                XmlDocument document = LoadManifest(stream);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document, Path.GetFileName(ApplicationManifestPath) ?? DefaultManifestName);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(Stream stream)\n+        {\n+            XmlDocument document = new XmlDocument();\n+\n+            using (XmlReader xr = XmlReader.Create(stream, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document, string manifestName)\n+        {\n+            ManifestPath = Path.Combine(OutputDirectory, manifestName);\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitectures, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private void PopulateSupportedArchitecturesElement(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            XmlNode assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager)\n+                ?? throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"PopulateSupportedArchitectures.AssemblyNodeIsMissed\"));\n+\n+            XmlElement appNode = GetOrCreateXmlElement(document , xmlNamespaceManager, \"application\", asmv3Prefix, XmlNamespaces.asmv3);\n+            XmlElement winSettingsNode = GetOrCreateXmlElement(document, xmlNamespaceManager, windowsSettings, asmv3Prefix, XmlNamespaces.asmv3);\n+            if (string.IsNullOrEmpty(winSettingsNode.GetAttribute(XMakeAttributes.xmlns)))\n+            {\n+                winSettingsNode.SetAttribute(XMakeAttributes.xmlns, WindowsSettingsNamespace);\n+            }\n+\n+            XmlElement supportedArchitecturesNode = GetOrCreateXmlElement(document, xmlNamespaceManager, supportedArchitectures, namespaceURI: WindowsSettingsNamespace);\n+            supportedArchitecturesNode.InnerText = SupportedArchitectures;\n+            winSettingsNode.AppendChild(supportedArchitecturesNode);\n+            appNode.AppendChild(winSettingsNode);\n+            assemblyNode.AppendChild(appNode);",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n            if (existingNode is XmlElement element)\r\n```",
              "createdAt": "2024-05-23T12:57:26Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,224 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private Stream? GetManifestStream()\n+        {\n+            if (!string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                if (!File.Exists(ApplicationManifestPath))\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\", ApplicationManifestPath);\n+                    return null;\n+                }\n+\n+                return File.OpenRead(ApplicationManifestPath);\n+            }\n+\n+            string? defaultManifestPath = ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);\n+\n+            // The logic for getting default manifest is similar to the one from Roslyn:\n+            // If Roslyn logic returns null, we fall back to reading embedded manifest.\n+            return defaultManifestPath is null\n+                    ? typeof(PopulateSupportedArchitectures).Assembly.GetManifestResourceStream($\"Microsoft.Build.Tasks.Resources.{DefaultManifestName}\")\n+                    : File.OpenRead(defaultManifestPath);\n+        }\n+\n+        public override bool Execute()\n+        {\n+            using Stream? stream = GetManifestStream();\n+\n+            // Only if ApplicationManifest was not specified, we can try to load the embedded manifest.\n+            if (stream is not null)\n+            {\n+                XmlDocument document = LoadManifest(stream);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document, Path.GetFileName(ApplicationManifestPath) ?? DefaultManifestName);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(Stream stream)\n+        {\n+            XmlDocument document = new XmlDocument();\n+\n+            using (XmlReader xr = XmlReader.Create(stream, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document, string manifestName)\n+        {\n+            ManifestPath = Path.Combine(OutputDirectory, manifestName);\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode? assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager);\n+            if (assemblyNode != null)\n+            {\n+                XmlNode? supportedArchitecturesNode = assemblyNode.SelectSingleNode($\"//*[local-name()='{supportedArchitectures}']\", xmlNamespaceManager);\n+                if (supportedArchitecturesNode != null)\n+                {\n+                    if (!string.Equals(supportedArchitecturesNode.InnerText.Trim(), SupportedArchitectures, StringComparison.OrdinalIgnoreCase))\n+                    {\n+                        Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.InvalidValueInSupportedArchitectures\", supportedArchitecturesNode.InnerText);\n+\n+                        return ManifestValidationResult.Failure;\n+                    }\n+\n+                    return ManifestValidationResult.SupportedArchitecturesExists;\n+                }\n+\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            return ManifestValidationResult.Failure;\n+        }\n+\n+        private void PopulateSupportedArchitecturesElement(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            XmlNode assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager)\n+                ?? throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"PopulateSupportedArchitectures.AssemblyNodeIsMissed\"));\n+\n+            XmlElement appNode = GetOrCreateXmlElement(document , xmlNamespaceManager, \"application\", asmv3Prefix, XmlNamespaces.asmv3);\n+            XmlElement winSettingsNode = GetOrCreateXmlElement(document, xmlNamespaceManager, windowsSettings, asmv3Prefix, XmlNamespaces.asmv3);\n+            if (string.IsNullOrEmpty(winSettingsNode.GetAttribute(XMakeAttributes.xmlns)))\n+            {\n+                winSettingsNode.SetAttribute(XMakeAttributes.xmlns, WindowsSettingsNamespace);\n+            }\n+\n+            XmlElement supportedArchitecturesNode = GetOrCreateXmlElement(document, xmlNamespaceManager, supportedArchitectures, namespaceURI: WindowsSettingsNamespace);\n+            supportedArchitecturesNode.InnerText = SupportedArchitectures;\n+            winSettingsNode.AppendChild(supportedArchitecturesNode);\n+            appNode.AppendChild(winSettingsNode);\n+            assemblyNode.AppendChild(appNode);\n+        }\n+\n+        private XmlElement GetOrCreateXmlElement(XmlDocument document, XmlNamespaceManager xmlNamespaceManager, string localName, string prefix = \"\", string namespaceURI = \"\")\n+        {\n+            bool isPrefixed = !string.IsNullOrEmpty(prefix);\n+\n+            XmlNode? existingNode = isPrefixed\n+                ? document.SelectSingleNode($\"//{prefix}:{localName}\", xmlNamespaceManager)\n+                : document.SelectSingleNode($\"//{localName}\", xmlNamespaceManager);\n+\n+            if (existingNode is not null and XmlElement element)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you please comment the new class, mentioning that the task is intended to be called from internal targets only? Also, I'm wondering if there's a more descriptive name, or if `NetMessage` wouldn't be better aligned with naming conventions.",
              "createdAt": "2024-05-23T13:08:49Z",
              "path": "src/Tasks/NETMessage.cs",
              "diffHunk": "@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.Deployment.Bootstrapper;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class NETMessage : TaskExtension",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "How does \"MSBuildMessage\" sound to you?",
              "createdAt": "2024-05-23T14:22:52Z",
              "path": "src/Tasks/NETMessage.cs",
              "diffHunk": "@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.Deployment.Bootstrapper;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class NETMessage : TaskExtension",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "MSBuildMessage sounds good to me. Or maybe `MSBuildInternalMessage` to further scare people off of using it?",
              "createdAt": "2024-05-23T16:48:49Z",
              "path": "src/Tasks/NETMessage.cs",
              "diffHunk": "@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.Deployment.Bootstrapper;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    public sealed class NETMessage : TaskExtension",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I think it's better to declare the enum here (or just do if/switch on the string) than reference it from what looks like unrelated code.",
              "createdAt": "2024-05-23T13:18:36Z",
              "path": "src/Tasks/NETMessage.cs",
              "diffHunk": "@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Tasks.Deployment.Bootstrapper;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Wasn't this supposed to be\r\n```suggestion\r\n                    IntPtr hResource = FindResource(hModule, lpName, lpType);\r\n```\r\n?",
              "createdAt": "2024-05-23T13:27:08Z",
              "path": "src/Tasks.UnitTests/PopulateSupportedArchitectures_Tests.cs",
              "diffHunk": "@@ -0,0 +1,179 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Xml;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class PopulateSupportedArchitectures_Tests\n+    {\n+        private static string TestAssetsRootPath { get; } = Path.Combine(\n+            Path.GetDirectoryName(typeof(PopulateSupportedArchitectures_Tests).Assembly.Location) ?? AppContext.BaseDirectory,\n+            \"TestResources\",\n+            \"Manifests\");\n+\n+        private readonly ITestOutputHelper _testOutput;\n+\n+        public PopulateSupportedArchitectures_Tests(ITestOutputHelper testOutput) => _testOutput = testOutput;\n+\n+        [Theory]\n+        [InlineData(\"testManifestWithInvalidSupportedArchs.manifest\", false)]\n+        [InlineData(\"testManifestWithApplicationDefined.manifest\", true)]\n+        [InlineData(null, true)]\n+        public void ManifestPopulationCheck(string manifestName, bool expectedResult)\n+        {\n+            PopulateSupportedArchitectures task = new PopulateSupportedArchitectures()\n+            {\n+                BuildEngine = new MockEngine(_testOutput)\n+            };\n+\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                var tempOutput = env.CreateFolder().Path;\n+                task.OutputDirectory = tempOutput;\n+                task.SupportedArchitectures = \"amd64 arm64\";\n+                if (!string.IsNullOrEmpty(manifestName))\n+                {\n+                    task.ApplicationManifestPath = Path.Combine(TestAssetsRootPath, manifestName);\n+                }\n+\n+                var result = task.Execute();\n+\n+                result.ShouldBe(expectedResult);\n+\n+                if (result)\n+                {\n+                    string generatedManifest = task.ManifestPath;\n+                    string expectedManifest = Path.Combine(TestAssetsRootPath, $\"{manifestName ?? \"default.win32manifest\"}_expected\");\n+\n+                    XmlDocument expectedDoc = new XmlDocument();\n+                    XmlDocument actualDoc = new XmlDocument();\n+\n+                    expectedDoc.Load(generatedManifest);\n+                    actualDoc.Load(expectedManifest);\n+\n+                    expectedDoc.OuterXml.ShouldBe(actualDoc.OuterXml);\n+                    expectedDoc.InnerXml.ShouldBe(actualDoc.InnerXml);\n+                }\n+            }\n+        }\n+\n+        [WindowsOnlyTheory]\n+        [InlineData(null, true)]\n+        [InlineData(\"buildIn.manifest\", true)]\n+        [InlineData(\"testManifestWithValidSupportedArchs.manifest\", true)]\n+        public void E2EScenarioTests(string manifestName, bool expectedResult)\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                var outputPath = env.CreateFolder().Path;\n+                string projectContent = @$\"\n+                <Project DefaultTargets=\"\"Build\"\">\n+                    <Import Project=\"\"$(MSBuildBinPath)\\Microsoft.Common.props\"\" />\n+\n+                    <PropertyGroup>\n+                        <Platform>AnyCPU</Platform>\n+                        <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>\n+                        <OutputType>Library</OutputType>\n+                        <PreferNativeArm64>true</PreferNativeArm64>\n+                        <Prefer32Bit>false</Prefer32Bit>\n+                        {(!string.IsNullOrEmpty(manifestName) ? $\"<ApplicationManifest>{manifestName}</ApplicationManifest>\" : \"\")}\n+                        <IntermediateOutputPath>{outputPath}</IntermediateOutputPath>\n+                    </PropertyGroup>\n+\n+                    <Target Name=\"\"Build\"\"/>\n+                    <Import Project=\"\"$(MSBuildBinPath)\\Microsoft.CSharp.targets\"\" />\n+\n+                </Project>\n+                \";\n+\n+                var projectFolder = env.CreateFolder();\n+                var projectFile = env.CreateFile(projectFolder, \"test.csproj\", projectContent).Path;\n+\n+                // copy application manifest\n+                if (!string.IsNullOrEmpty(manifestName))\n+                {\n+                    File.Copy(Path.Combine(TestAssetsRootPath, manifestName), Path.Combine(projectFolder.Path, manifestName));\n+                }\n+\n+                Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFile, touchProject: false);\n+\n+                bool result = project.Build(new MockLogger(_testOutput));\n+                result.ShouldBe(expectedResult);\n+\n+                // #2 - represents the name for native resource (Win 32 resource), #24 - the type (Manifest) \n+                byte[]? actualManifestBytes = AssemblyNativeResourceManager.GetResourceFromExecutable(Path.Combine(outputPath, \"test.dll\"), \"#2\", \"#24\");\n+\n+                // check manifest content\n+                if (actualManifestBytes != null)\n+                {\n+                    string expectedManifest = Path.Combine(TestAssetsRootPath, $\"{manifestName ?? \"default.win32manifest\"}_expected\");\n+\n+                    XmlDocument expectedDoc = new XmlDocument();\n+                    XmlDocument actualDoc = new XmlDocument();\n+\n+                    expectedDoc.Load(expectedManifest);\n+                    using (MemoryStream stream = new MemoryStream(actualManifestBytes))\n+                    {\n+                        actualDoc.Load(stream);\n+                    }\n+\n+                    expectedDoc.OuterXml.ShouldBe(actualDoc.OuterXml);\n+                    expectedDoc.InnerXml.ShouldBe(actualDoc.InnerXml);\n+                }\n+            }\n+        }\n+\n+        internal sealed class AssemblyNativeResourceManager\n+        {\n+            public enum LoadLibraryFlags : uint { LOAD_LIBRARY_AS_DATAFILE = 2 };\n+\n+            [DllImport(\"Kernel32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n+            public static extern IntPtr LoadLibrary(string lpFileName, IntPtr hReservedNull, LoadLibraryFlags dwFlags);\n+\n+            [DllImport(\"kernel32.dll\", SetLastError = true)]\n+            public static extern IntPtr FindResource(IntPtr hModule, string lpName, string lpType);\n+\n+            [DllImport(\"kernel32.dll\", SetLastError = true)]\n+            public static extern IntPtr LoadResource(IntPtr hModule, IntPtr hResInfo);\n+\n+            [DllImport(\"kernel32.dll\", SetLastError = true)]\n+            public static extern IntPtr LockResource(IntPtr hResData);\n+\n+            [DllImport(\"kernel32.dll\", SetLastError = true)]\n+            public static extern uint SizeofResource(IntPtr hModule, IntPtr hResInfo);\n+\n+            public static byte[]? GetResourceFromExecutable(string assembly, string lpName, string lpType)\n+            {\n+                IntPtr hModule = LoadLibrary(assembly, IntPtr.Zero, LoadLibraryFlags.LOAD_LIBRARY_AS_DATAFILE);\n+                if (hModule != IntPtr.Zero)\n+                {\n+                    IntPtr hResource = FindResource(hModule, \"#2\", \"#24\");",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `LoadLibrary` should be complemented with a call to `FreeLibrary` before the method returns.",
              "createdAt": "2024-05-23T13:30:06Z",
              "path": "src/Tasks.UnitTests/PopulateSupportedArchitectures_Tests.cs",
              "diffHunk": "@@ -0,0 +1,179 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Xml;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class PopulateSupportedArchitectures_Tests\n+    {\n+        private static string TestAssetsRootPath { get; } = Path.Combine(\n+            Path.GetDirectoryName(typeof(PopulateSupportedArchitectures_Tests).Assembly.Location) ?? AppContext.BaseDirectory,\n+            \"TestResources\",\n+            \"Manifests\");\n+\n+        private readonly ITestOutputHelper _testOutput;\n+\n+        public PopulateSupportedArchitectures_Tests(ITestOutputHelper testOutput) => _testOutput = testOutput;\n+\n+        [Theory]\n+        [InlineData(\"testManifestWithInvalidSupportedArchs.manifest\", false)]\n+        [InlineData(\"testManifestWithApplicationDefined.manifest\", true)]\n+        [InlineData(null, true)]\n+        public void ManifestPopulationCheck(string manifestName, bool expectedResult)\n+        {\n+            PopulateSupportedArchitectures task = new PopulateSupportedArchitectures()\n+            {\n+                BuildEngine = new MockEngine(_testOutput)\n+            };\n+\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                var tempOutput = env.CreateFolder().Path;\n+                task.OutputDirectory = tempOutput;\n+                task.SupportedArchitectures = \"amd64 arm64\";\n+                if (!string.IsNullOrEmpty(manifestName))\n+                {\n+                    task.ApplicationManifestPath = Path.Combine(TestAssetsRootPath, manifestName);\n+                }\n+\n+                var result = task.Execute();\n+\n+                result.ShouldBe(expectedResult);\n+\n+                if (result)\n+                {\n+                    string generatedManifest = task.ManifestPath;\n+                    string expectedManifest = Path.Combine(TestAssetsRootPath, $\"{manifestName ?? \"default.win32manifest\"}_expected\");\n+\n+                    XmlDocument expectedDoc = new XmlDocument();\n+                    XmlDocument actualDoc = new XmlDocument();\n+\n+                    expectedDoc.Load(generatedManifest);\n+                    actualDoc.Load(expectedManifest);\n+\n+                    expectedDoc.OuterXml.ShouldBe(actualDoc.OuterXml);\n+                    expectedDoc.InnerXml.ShouldBe(actualDoc.InnerXml);\n+                }\n+            }\n+        }\n+\n+        [WindowsOnlyTheory]\n+        [InlineData(null, true)]\n+        [InlineData(\"buildIn.manifest\", true)]\n+        [InlineData(\"testManifestWithValidSupportedArchs.manifest\", true)]\n+        public void E2EScenarioTests(string manifestName, bool expectedResult)\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                var outputPath = env.CreateFolder().Path;\n+                string projectContent = @$\"\n+                <Project DefaultTargets=\"\"Build\"\">\n+                    <Import Project=\"\"$(MSBuildBinPath)\\Microsoft.Common.props\"\" />\n+\n+                    <PropertyGroup>\n+                        <Platform>AnyCPU</Platform>\n+                        <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>\n+                        <OutputType>Library</OutputType>\n+                        <PreferNativeArm64>true</PreferNativeArm64>\n+                        <Prefer32Bit>false</Prefer32Bit>\n+                        {(!string.IsNullOrEmpty(manifestName) ? $\"<ApplicationManifest>{manifestName}</ApplicationManifest>\" : \"\")}\n+                        <IntermediateOutputPath>{outputPath}</IntermediateOutputPath>\n+                    </PropertyGroup>\n+\n+                    <Target Name=\"\"Build\"\"/>\n+                    <Import Project=\"\"$(MSBuildBinPath)\\Microsoft.CSharp.targets\"\" />\n+\n+                </Project>\n+                \";\n+\n+                var projectFolder = env.CreateFolder();\n+                var projectFile = env.CreateFile(projectFolder, \"test.csproj\", projectContent).Path;\n+\n+                // copy application manifest\n+                if (!string.IsNullOrEmpty(manifestName))\n+                {\n+                    File.Copy(Path.Combine(TestAssetsRootPath, manifestName), Path.Combine(projectFolder.Path, manifestName));\n+                }\n+\n+                Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFile, touchProject: false);\n+\n+                bool result = project.Build(new MockLogger(_testOutput));\n+                result.ShouldBe(expectedResult);\n+\n+                // #2 - represents the name for native resource (Win 32 resource), #24 - the type (Manifest) \n+                byte[]? actualManifestBytes = AssemblyNativeResourceManager.GetResourceFromExecutable(Path.Combine(outputPath, \"test.dll\"), \"#2\", \"#24\");\n+\n+                // check manifest content\n+                if (actualManifestBytes != null)\n+                {\n+                    string expectedManifest = Path.Combine(TestAssetsRootPath, $\"{manifestName ?? \"default.win32manifest\"}_expected\");\n+\n+                    XmlDocument expectedDoc = new XmlDocument();\n+                    XmlDocument actualDoc = new XmlDocument();\n+\n+                    expectedDoc.Load(expectedManifest);\n+                    using (MemoryStream stream = new MemoryStream(actualManifestBytes))\n+                    {\n+                        actualDoc.Load(stream);\n+                    }\n+\n+                    expectedDoc.OuterXml.ShouldBe(actualDoc.OuterXml);\n+                    expectedDoc.InnerXml.ShouldBe(actualDoc.InnerXml);\n+                }\n+            }\n+        }\n+\n+        internal sealed class AssemblyNativeResourceManager\n+        {\n+            public enum LoadLibraryFlags : uint { LOAD_LIBRARY_AS_DATAFILE = 2 };\n+\n+            [DllImport(\"Kernel32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n+            public static extern IntPtr LoadLibrary(string lpFileName, IntPtr hReservedNull, LoadLibraryFlags dwFlags);\n+\n+            [DllImport(\"kernel32.dll\", SetLastError = true)]\n+            public static extern IntPtr FindResource(IntPtr hModule, string lpName, string lpType);\n+\n+            [DllImport(\"kernel32.dll\", SetLastError = true)]\n+            public static extern IntPtr LoadResource(IntPtr hModule, IntPtr hResInfo);\n+\n+            [DllImport(\"kernel32.dll\", SetLastError = true)]\n+            public static extern IntPtr LockResource(IntPtr hResData);\n+\n+            [DllImport(\"kernel32.dll\", SetLastError = true)]\n+            public static extern uint SizeofResource(IntPtr hModule, IntPtr hResInfo);\n+\n+            public static byte[]? GetResourceFromExecutable(string assembly, string lpName, string lpType)\n+            {\n+                IntPtr hModule = LoadLibrary(assembly, IntPtr.Zero, LoadLibraryFlags.LOAD_LIBRARY_AS_DATAFILE);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "In an `Execute()` method, always return `!Log.HasLoggedError` instead of literal `true` or `false` to avoid the \"succeeded with errors\" case.",
              "createdAt": "2024-05-23T15:51:23Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string application = \"application\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private Stream? GetManifestStream()\n+        {\n+            if (!string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                if (!File.Exists(ApplicationManifestPath))\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\", ApplicationManifestPath);\n+                    return null;\n+                }\n+\n+                return File.OpenRead(ApplicationManifestPath);\n+            }\n+\n+            string? defaultManifestPath = ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);\n+\n+            // The logic for getting default manifest is similar to the one from Roslyn:\n+            // If Roslyn logic returns null, we fall back to reading embedded manifest.\n+            return defaultManifestPath is null\n+                    ? typeof(PopulateSupportedArchitectures).Assembly.GetManifestResourceStream($\"Microsoft.Build.Tasks.Resources.{DefaultManifestName}\")\n+                    : File.OpenRead(defaultManifestPath);\n+        }\n+\n+        public override bool Execute()\n+        {\n+            using Stream? stream = GetManifestStream();\n+\n+            if (stream is not null)\n+            {\n+                XmlDocument document = LoadManifest(stream);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document, Path.GetFileName(ApplicationManifestPath) ?? DefaultManifestName);\n+                        return true;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Based on the `DependsOnTargets`:\r\n```suggestion\r\n      SetWin32ManifestProperties;\r\n      _SetPreferNativeArm64Win32ManifestProperties;\r\n```",
              "createdAt": "2024-05-23T15:55:47Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -3599,6 +3605,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     <CompileDependsOn>\n       ResolveReferences;\n       ResolveKeySource;\n+      _SetPreferNativeArm64Win32ManifestProperties;\n       SetWin32ManifestProperties;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If you pass `NoWin32Manifest` and `Prefer32Bit` into the `PopulateSupportedArchitectures` task you could avoid creating this new NETMessage/MSBuildMessage task, right? But realistically we should have a task to do the loc for all the errors in this target and elsewhere, so maybe now is a fine time to do it.",
              "createdAt": "2024-05-23T16:47:52Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -854,6 +854,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <PlatformTargetAsMSBuildArchitecture>x86</PlatformTargetAsMSBuildArchitecture>\n     </PropertyGroup>\n \n+    <NETMessage Condition=\" '$(Prefer32Bit)' == 'true' and '$(PreferNativeArm64)' == 'true' \" ResourceName=\"CommonTarget.Prefer32BitAndPreferNativeArm64Enabled\" Severity=\"Error\"/>\n+\n+    <NETMessage Condition=\" '$(NoWin32Manifest)' == 'true' and '$(PreferNativeArm64)' == 'true' \" ResourceName=\"CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled\" Severity=\"Error\"/>\n+\n+    <NETMessage Condition=\" '$(PreferNativeArm64)' == 'true' and '$(Platform)' != 'AnyCPU' \" ResourceName=\"CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled\" Severity=\"Warning\" FormatArguments=\"$(Platform)\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I checked the way it was done it sdk and it was quite easy to introduce it too :)",
              "createdAt": "2024-05-23T17:16:38Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -854,6 +854,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <PlatformTargetAsMSBuildArchitecture>x86</PlatformTargetAsMSBuildArchitecture>\n     </PropertyGroup>\n \n+    <NETMessage Condition=\" '$(Prefer32Bit)' == 'true' and '$(PreferNativeArm64)' == 'true' \" ResourceName=\"CommonTarget.Prefer32BitAndPreferNativeArm64Enabled\" Severity=\"Error\"/>\n+\n+    <NETMessage Condition=\" '$(NoWin32Manifest)' == 'true' and '$(PreferNativeArm64)' == 'true' \" ResourceName=\"CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled\" Severity=\"Error\"/>\n+\n+    <NETMessage Condition=\" '$(PreferNativeArm64)' == 'true' and '$(Platform)' != 'AnyCPU' \" ResourceName=\"CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled\" Severity=\"Warning\" FormatArguments=\"$(Platform)\" />",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "The ticket for refactoring messages: https://github.com/dotnet/msbuild/issues/10171\r\ncc: @baronfel ",
              "createdAt": "2024-05-24T10:51:49Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -854,6 +854,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <PlatformTargetAsMSBuildArchitecture>x86</PlatformTargetAsMSBuildArchitecture>\n     </PropertyGroup>\n \n+    <NETMessage Condition=\" '$(Prefer32Bit)' == 'true' and '$(PreferNativeArm64)' == 'true' \" ResourceName=\"CommonTarget.Prefer32BitAndPreferNativeArm64Enabled\" Severity=\"Error\"/>\n+\n+    <NETMessage Condition=\" '$(NoWin32Manifest)' == 'true' and '$(PreferNativeArm64)' == 'true' \" ResourceName=\"CommonTarget.NoWin32ManifestAndPreferNativeArm64Enabled\" Severity=\"Error\"/>\n+\n+    <NETMessage Condition=\" '$(PreferNativeArm64)' == 'true' and '$(Platform)' != 'AnyCPU' \" ResourceName=\"CommonTarget.PlatformIsAnyCPUAndPreferNativeArm64Enabled\" Severity=\"Warning\" FormatArguments=\"$(Platform)\" />",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Shouldn't this be an error?",
              "createdAt": "2024-05-23T16:50:04Z",
              "path": "src/Tasks/NETMessage.cs",
              "diffHunk": "@@ -0,0 +1,84 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that produces localized messages based on the specified resource name.\n+    /// This task is intended to be called from internal targets only.\n+    /// </summary>\n+    public sealed class NETMessage : TaskExtension\n+    {\n+        private enum BuildMessageSeverity\n+        {\n+            /// <summary>\n+            /// Indicates that the message corresponds to build information.\n+            /// </summary>\n+            Info,\n+\n+            /// <summary>\n+            /// Indicates that the message corresponds to a build warning.\n+            /// </summary>\n+            Warning,\n+\n+            /// <summary>\n+            /// Indicates that the message corresponds to a build error.\n+            /// </summary>\n+            Error,\n+        }\n+\n+        /// <summary>\n+        /// The name of the resource in Strings.resx that contains the desired error message.\n+        /// </summary>\n+        [Required]\n+        public string ResourceName { get; set; } = string.Empty;\n+\n+        /// <summary>\n+        /// Resource arguments to be used in the format string.\n+        /// </summary>\n+        public string[] FormatArguments { get; set; } = [];\n+\n+        /// <summary>\n+        /// <see cref=\"BuildMessageSeverity\"/>.\n+        /// </summary>\n+        [Required]\n+        public string Severity { set; get; } = string.Empty;\n+\n+        /// <summary>\n+        /// Configurable message importance.\n+        /// </summary>\n+        public string MessageImportance { get; set; } = \"Normal\";\n+\n+        public override bool Execute()\n+        {\n+            if (Enum.TryParse(Severity, ignoreCase: true, out BuildMessageSeverity severity))\n+            {\n+                switch (severity)\n+                {\n+                    case BuildMessageSeverity.Error:\n+                        Log.LogErrorWithCodeFromResources(ResourceName, FormatArguments);\n+                        return false;\n+\n+                    case BuildMessageSeverity.Warning:\n+                        Log.LogWarningWithCodeFromResources(ResourceName, FormatArguments);\n+                        return true;\n+\n+                    case BuildMessageSeverity.Info:\n+                        MessageImportance importance = (MessageImportance)Enum.Parse(typeof(MessageImportance), MessageImportance, true);\n+                        Log.LogMessageFromResources(importance, ResourceName, FormatArguments);\n+                        return true;\n+\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            Log.LogMessageFromResources(\"CommonTarget.SpecifiedSeverityDoesNotExist\", Severity);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I wasn't sure if the absence of the error message should cause the error=fail the build. \r\nI am open to discussion ",
              "createdAt": "2024-05-23T17:17:27Z",
              "path": "src/Tasks/NETMessage.cs",
              "diffHunk": "@@ -0,0 +1,84 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that produces localized messages based on the specified resource name.\n+    /// This task is intended to be called from internal targets only.\n+    /// </summary>\n+    public sealed class NETMessage : TaskExtension\n+    {\n+        private enum BuildMessageSeverity\n+        {\n+            /// <summary>\n+            /// Indicates that the message corresponds to build information.\n+            /// </summary>\n+            Info,\n+\n+            /// <summary>\n+            /// Indicates that the message corresponds to a build warning.\n+            /// </summary>\n+            Warning,\n+\n+            /// <summary>\n+            /// Indicates that the message corresponds to a build error.\n+            /// </summary>\n+            Error,\n+        }\n+\n+        /// <summary>\n+        /// The name of the resource in Strings.resx that contains the desired error message.\n+        /// </summary>\n+        [Required]\n+        public string ResourceName { get; set; } = string.Empty;\n+\n+        /// <summary>\n+        /// Resource arguments to be used in the format string.\n+        /// </summary>\n+        public string[] FormatArguments { get; set; } = [];\n+\n+        /// <summary>\n+        /// <see cref=\"BuildMessageSeverity\"/>.\n+        /// </summary>\n+        [Required]\n+        public string Severity { set; get; } = string.Empty;\n+\n+        /// <summary>\n+        /// Configurable message importance.\n+        /// </summary>\n+        public string MessageImportance { get; set; } = \"Normal\";\n+\n+        public override bool Execute()\n+        {\n+            if (Enum.TryParse(Severity, ignoreCase: true, out BuildMessageSeverity severity))\n+            {\n+                switch (severity)\n+                {\n+                    case BuildMessageSeverity.Error:\n+                        Log.LogErrorWithCodeFromResources(ResourceName, FormatArguments);\n+                        return false;\n+\n+                    case BuildMessageSeverity.Warning:\n+                        Log.LogWarningWithCodeFromResources(ResourceName, FormatArguments);\n+                        return true;\n+\n+                    case BuildMessageSeverity.Info:\n+                        MessageImportance importance = (MessageImportance)Enum.Parse(typeof(MessageImportance), MessageImportance, true);\n+                        Log.LogMessageFromResources(importance, ResourceName, FormatArguments);\n+                        return true;\n+\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            Log.LogMessageFromResources(\"CommonTarget.SpecifiedSeverityDoesNotExist\", Severity);",
              "author": {
                "login": "YuliiaKovalova"
              }
            },
            {
              "body": "It is an error in our targets, right? I think it should just be fatal.",
              "createdAt": "2024-05-23T18:26:54Z",
              "path": "src/Tasks/NETMessage.cs",
              "diffHunk": "@@ -0,0 +1,84 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that produces localized messages based on the specified resource name.\n+    /// This task is intended to be called from internal targets only.\n+    /// </summary>\n+    public sealed class NETMessage : TaskExtension\n+    {\n+        private enum BuildMessageSeverity\n+        {\n+            /// <summary>\n+            /// Indicates that the message corresponds to build information.\n+            /// </summary>\n+            Info,\n+\n+            /// <summary>\n+            /// Indicates that the message corresponds to a build warning.\n+            /// </summary>\n+            Warning,\n+\n+            /// <summary>\n+            /// Indicates that the message corresponds to a build error.\n+            /// </summary>\n+            Error,\n+        }\n+\n+        /// <summary>\n+        /// The name of the resource in Strings.resx that contains the desired error message.\n+        /// </summary>\n+        [Required]\n+        public string ResourceName { get; set; } = string.Empty;\n+\n+        /// <summary>\n+        /// Resource arguments to be used in the format string.\n+        /// </summary>\n+        public string[] FormatArguments { get; set; } = [];\n+\n+        /// <summary>\n+        /// <see cref=\"BuildMessageSeverity\"/>.\n+        /// </summary>\n+        [Required]\n+        public string Severity { set; get; } = string.Empty;\n+\n+        /// <summary>\n+        /// Configurable message importance.\n+        /// </summary>\n+        public string MessageImportance { get; set; } = \"Normal\";\n+\n+        public override bool Execute()\n+        {\n+            if (Enum.TryParse(Severity, ignoreCase: true, out BuildMessageSeverity severity))\n+            {\n+                switch (severity)\n+                {\n+                    case BuildMessageSeverity.Error:\n+                        Log.LogErrorWithCodeFromResources(ResourceName, FormatArguments);\n+                        return false;\n+\n+                    case BuildMessageSeverity.Warning:\n+                        Log.LogWarningWithCodeFromResources(ResourceName, FormatArguments);\n+                        return true;\n+\n+                    case BuildMessageSeverity.Info:\n+                        MessageImportance importance = (MessageImportance)Enum.Parse(typeof(MessageImportance), MessageImportance, true);\n+                        Log.LogMessageFromResources(importance, ResourceName, FormatArguments);\n+                        return true;\n+\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            Log.LogMessageFromResources(\"CommonTarget.SpecifiedSeverityDoesNotExist\", Severity);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd name this after the underlying type for consistency.\r\n```suggestion\r\n            Message,\r\n```",
              "createdAt": "2024-05-23T16:51:39Z",
              "path": "src/Tasks/NETMessage.cs",
              "diffHunk": "@@ -0,0 +1,84 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that produces localized messages based on the specified resource name.\n+    /// This task is intended to be called from internal targets only.\n+    /// </summary>\n+    public sealed class NETMessage : TaskExtension\n+    {\n+        private enum BuildMessageSeverity\n+        {\n+            /// <summary>\n+            /// Indicates that the message corresponds to build information.\n+            /// </summary>\n+            Info,",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Same \"return `!Log.HasLoggedError` comment as the other task.",
              "createdAt": "2024-05-23T16:52:39Z",
              "path": "src/Tasks/NETMessage.cs",
              "diffHunk": "@@ -0,0 +1,84 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Represents a task that produces localized messages based on the specified resource name.\n+    /// This task is intended to be called from internal targets only.\n+    /// </summary>\n+    public sealed class NETMessage : TaskExtension\n+    {\n+        private enum BuildMessageSeverity\n+        {\n+            /// <summary>\n+            /// Indicates that the message corresponds to build information.\n+            /// </summary>\n+            Info,\n+\n+            /// <summary>\n+            /// Indicates that the message corresponds to a build warning.\n+            /// </summary>\n+            Warning,\n+\n+            /// <summary>\n+            /// Indicates that the message corresponds to a build error.\n+            /// </summary>\n+            Error,\n+        }\n+\n+        /// <summary>\n+        /// The name of the resource in Strings.resx that contains the desired error message.\n+        /// </summary>\n+        [Required]\n+        public string ResourceName { get; set; } = string.Empty;\n+\n+        /// <summary>\n+        /// Resource arguments to be used in the format string.\n+        /// </summary>\n+        public string[] FormatArguments { get; set; } = [];\n+\n+        /// <summary>\n+        /// <see cref=\"BuildMessageSeverity\"/>.\n+        /// </summary>\n+        [Required]\n+        public string Severity { set; get; } = string.Empty;\n+\n+        /// <summary>\n+        /// Configurable message importance.\n+        /// </summary>\n+        public string MessageImportance { get; set; } = \"Normal\";\n+\n+        public override bool Execute()\n+        {\n+            if (Enum.TryParse(Severity, ignoreCase: true, out BuildMessageSeverity severity))\n+            {\n+                switch (severity)\n+                {\n+                    case BuildMessageSeverity.Error:\n+                        Log.LogErrorWithCodeFromResources(ResourceName, FormatArguments);\n+                        return false;\n+\n+                    case BuildMessageSeverity.Warning:\n+                        Log.LogWarningWithCodeFromResources(ResourceName, FormatArguments);\n+                        return true;\n+\n+                    case BuildMessageSeverity.Info:\n+                        MessageImportance importance = (MessageImportance)Enum.Parse(typeof(MessageImportance), MessageImportance, true);\n+                        Log.LogMessageFromResources(importance, ResourceName, FormatArguments);\n+                        return true;\n+\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            Log.LogMessageFromResources(\"CommonTarget.SpecifiedSeverityDoesNotExist\", Severity);\n+\n+            return true;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm worried this file will get CRLF corrected and confuse things. Can you make sure it doesn't in `.gitconfig` and confirm everything's working by building a project on Linux, then running the output binary on windows arm and making sure it works?",
              "createdAt": "2024-05-23T16:54:23Z",
              "path": "src/Tasks/Resources/default.win32manifest",
              "diffHunk": "@@ -0,0 +1,12 @@\n+\ufeff<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n+\n+<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">\n+  <assemblyIdentity version=\"1.0.0.0\" name=\"MyApplication.app\"/>\n+  <trustInfo xmlns=\"urn:schemas-microsoft-com:asm.v2\">\n+    <security>\n+      <requestedPrivileges xmlns=\"urn:schemas-microsoft-com:asm.v3\">\n+        <requestedExecutionLevel level=\"asInvoker\" uiAccess=\"false\"/>\n+      </requestedPrivileges>\n+    </security>\n+  </trustInfo>\n+</assembly>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I have done it - everything works as expected.",
              "createdAt": "2024-05-27T11:52:50Z",
              "path": "src/Tasks/Resources/default.win32manifest",
              "diffHunk": "@@ -0,0 +1,12 @@\n+\ufeff<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n+\n+<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">\n+  <assemblyIdentity version=\"1.0.0.0\" name=\"MyApplication.app\"/>\n+  <trustInfo xmlns=\"urn:schemas-microsoft-com:asm.v2\">\n+    <security>\n+      <requestedPrivileges xmlns=\"urn:schemas-microsoft-com:asm.v3\">\n+        <requestedExecutionLevel level=\"asInvoker\" uiAccess=\"false\"/>\n+      </requestedPrivileges>\n+    </security>\n+  </trustInfo>\n+</assembly>",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think I'd prefer a name that is both more and less specific: explicitly specify what kind of manifest, but leave open the possibility of doing other stuff with it.\r\n\r\n```suggestion\r\n    public sealed class AddToWin32Manifest : TaskExtension\r\n```",
              "createdAt": "2024-05-23T16:56:12Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Never return `false` from a task without explicitly logging a clear error. I'd prefer to invert the logic: if the stream _is_ null, log an error and return early.",
              "createdAt": "2024-05-23T16:58:15Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string application = \"application\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private Stream? GetManifestStream()\n+        {\n+            if (!string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                if (!File.Exists(ApplicationManifestPath))\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\", ApplicationManifestPath);\n+                    return null;\n+                }\n+\n+                return File.OpenRead(ApplicationManifestPath);\n+            }\n+\n+            string? defaultManifestPath = ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);\n+\n+            // The logic for getting default manifest is similar to the one from Roslyn:\n+            // If Roslyn logic returns null, we fall back to reading embedded manifest.\n+            return defaultManifestPath is null\n+                    ? typeof(PopulateSupportedArchitectures).Assembly.GetManifestResourceStream($\"Microsoft.Build.Tasks.Resources.{DefaultManifestName}\")\n+                    : File.OpenRead(defaultManifestPath);\n+        }\n+\n+        public override bool Execute()\n+        {\n+            using Stream? stream = GetManifestStream();\n+\n+            if (stream is not null)\n+            {\n+                XmlDocument document = LoadManifest(stream);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document, Path.GetFileName(ApplicationManifestPath) ?? DefaultManifestName);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't see a catch that handles this and produces a clear error. What is the error experience if you pass in a bogus manifest?",
              "createdAt": "2024-05-23T16:58:59Z",
              "path": "src/Tasks/PopulateSupportedArchitectures.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Text;\n+using System.Xml;\n+\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Tasks\n+{\n+    /// <summary>\n+    /// Generates an application manifest or adds an entry to the existing one when PreferNativeArm64 property is true.\n+    /// </summary>\n+    public sealed class PopulateSupportedArchitectures : TaskExtension\n+    {\n+        private const string supportedArchitectures = \"supportedArchitectures\";\n+        private const string windowsSettings = \"windowsSettings\";\n+        private const string application = \"application\";\n+        private const string asmv3Prefix = \"asmv3\";\n+        private const string DefaultManifestName = \"default.win32manifest\";\n+        private const string WindowsSettingsNamespace = \"http://schemas.microsoft.com/SMI/2024/WindowsSettings\";\n+\n+        private string _outputDirectory = string.Empty;\n+        private string _supportedArchitectures = string.Empty;\n+        private string _generatedManifestFullPath = string.Empty;\n+\n+        /// <summary>\n+        /// Represents the result of validating an application manifest.\n+        /// </summary>\n+        private enum ManifestValidationResult\n+        {\n+            /// <summary>\n+            /// The manifest validation was successful.\n+            /// </summary>\n+            Success = 1,\n+\n+            /// <summary>\n+            /// The manifest validation failed.\n+            /// </summary>\n+            Failure,\n+\n+            /// <summary>\n+            /// The supported architectures exist in the manifest with the expected value.\n+            /// </summary>\n+            SupportedArchitecturesExists,\n+        }\n+\n+        /// <summary>\n+        /// Path to the existing application manifest.\n+        /// </summary>\n+        public string? ApplicationManifestPath { get; set; }\n+\n+        /// <summary>\n+        /// Intermediate output directory.\n+        /// </summary>\n+        [Required]\n+        public string OutputDirectory\n+        {\n+            get => _outputDirectory;\n+            set => _outputDirectory = value ?? throw new ArgumentNullException(nameof(OutputDirectory));\n+        }\n+\n+        /// <summary>\n+        /// Value for supportedArchitectures node.\n+        /// </summary>\n+        [Required]\n+        public string SupportedArchitectures\n+        {\n+            get => _supportedArchitectures;\n+            set => _supportedArchitectures = value ?? throw new ArgumentNullException(nameof(SupportedArchitectures));\n+        }\n+\n+        /// <summary>\n+        /// Returns path to the generated manifest.\n+        /// </summary>\n+        [Output]\n+        public string ManifestPath\n+        {\n+            get => _generatedManifestFullPath;\n+            private set => _generatedManifestFullPath = value;\n+        }\n+\n+        private Stream? GetManifestStream()\n+        {\n+            if (!string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                if (!File.Exists(ApplicationManifestPath))\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"PopulateSupportedArchitectures.SpecifiedApplicationManifestCanNotBeFound\", ApplicationManifestPath);\n+                    return null;\n+                }\n+\n+                return File.OpenRead(ApplicationManifestPath);\n+            }\n+\n+            string? defaultManifestPath = ToolLocationHelper.GetPathToDotNetFrameworkFile(DefaultManifestName, TargetDotNetFrameworkVersion.Version46);\n+\n+            // The logic for getting default manifest is similar to the one from Roslyn:\n+            // If Roslyn logic returns null, we fall back to reading embedded manifest.\n+            return defaultManifestPath is null\n+                    ? typeof(PopulateSupportedArchitectures).Assembly.GetManifestResourceStream($\"Microsoft.Build.Tasks.Resources.{DefaultManifestName}\")\n+                    : File.OpenRead(defaultManifestPath);\n+        }\n+\n+        public override bool Execute()\n+        {\n+            using Stream? stream = GetManifestStream();\n+\n+            if (stream is not null)\n+            {\n+                XmlDocument document = LoadManifest(stream);\n+                XmlNamespaceManager xmlNamespaceManager = XmlNamespaces.GetNamespaceManager(document.NameTable);\n+\n+                ManifestValidationResult validationResult = ValidateManifest(document, xmlNamespaceManager);\n+\n+                switch (validationResult)\n+                {\n+                    case ManifestValidationResult.Success:\n+                        PopulateSupportedArchitecturesElement(document, xmlNamespaceManager);\n+                        SaveManifest(document, Path.GetFileName(ApplicationManifestPath) ?? DefaultManifestName);\n+                        return true;\n+                    case ManifestValidationResult.SupportedArchitecturesExists:\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private XmlDocument LoadManifest(Stream stream)\n+        {\n+            XmlDocument document = new XmlDocument();\n+\n+            using (XmlReader xr = XmlReader.Create(stream, new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true }))\n+            {\n+                document.Load(xr);\n+            }\n+\n+            return document;\n+        }\n+\n+        private void SaveManifest(XmlDocument document, string manifestName)\n+        {\n+            ManifestPath = Path.Combine(OutputDirectory, manifestName);\n+            using (XmlWriter xmlWriter = XmlWriter.Create(ManifestPath, new XmlWriterSettings { Indent = true, Encoding = Encoding.UTF8 }))\n+            {\n+                document.Save(xmlWriter);\n+            }\n+        }\n+\n+        private ManifestValidationResult ValidateManifest(XmlDocument document, XmlNamespaceManager xmlNamespaceManager)\n+        {\n+            if (string.IsNullOrEmpty(ApplicationManifestPath))\n+            {\n+                return ManifestValidationResult.Success;\n+            }\n+\n+            XmlNode assemblyNode = document.SelectSingleNode(XPaths.assemblyElement, xmlNamespaceManager)\n+                ?? throw new InvalidOperationException(ResourceUtilities.GetResourceString(\"PopulateSupportedArchitectures.AssemblyNodeIsMissed\"));",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we need e2e tests here? What do they add over the task-level stuff?",
              "createdAt": "2024-05-23T17:04:09Z",
              "path": "src/Tasks.UnitTests/PopulateSupportedArchitectures_Tests.cs",
              "diffHunk": "@@ -0,0 +1,190 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Runtime.Versioning;\n+using System.Xml;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class PopulateSupportedArchitectures_Tests\n+    {\n+        private static string TestAssetsRootPath { get; } = Path.Combine(\n+            Path.GetDirectoryName(typeof(PopulateSupportedArchitectures_Tests).Assembly.Location) ?? AppContext.BaseDirectory,\n+            \"TestResources\",\n+            \"Manifests\");\n+\n+        private readonly ITestOutputHelper _testOutput;\n+\n+        public PopulateSupportedArchitectures_Tests(ITestOutputHelper testOutput) => _testOutput = testOutput;\n+\n+        [Theory]\n+        [InlineData(\"testManifestWithInvalidSupportedArchs.manifest\", false)]\n+        [InlineData(\"testManifestWithApplicationDefined.manifest\", true)]\n+        [InlineData(\"testManifestSavesTheCurrentNodesPositions.manifest\", true)]\n+        [InlineData(null, true)]\n+        public void ManifestPopulationCheck(string manifestName, bool expectedResult)\n+        {\n+            PopulateSupportedArchitectures task = new PopulateSupportedArchitectures()\n+            {\n+                BuildEngine = new MockEngine(_testOutput)\n+            };\n+\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                var tempOutput = env.CreateFolder().Path;\n+                task.OutputDirectory = tempOutput;\n+                task.SupportedArchitectures = \"amd64 arm64\";\n+                if (!string.IsNullOrEmpty(manifestName))\n+                {\n+                    task.ApplicationManifestPath = Path.Combine(TestAssetsRootPath, manifestName);\n+                }\n+\n+                var result = task.Execute();\n+\n+                result.ShouldBe(expectedResult);\n+\n+                if (result)\n+                {\n+                    string generatedManifest = task.ManifestPath;\n+                    string expectedManifest = Path.Combine(TestAssetsRootPath, $\"{manifestName ?? \"default.win32manifest\"}_expected\");\n+\n+                    XmlDocument expectedDoc = new XmlDocument();\n+                    XmlDocument actualDoc = new XmlDocument();\n+\n+                    expectedDoc.Load(expectedManifest);\n+                    actualDoc.Load(generatedManifest);\n+\n+                    expectedDoc.OuterXml.ShouldBe(actualDoc.OuterXml);\n+                    expectedDoc.InnerXml.ShouldBe(actualDoc.InnerXml);\n+                }\n+            }\n+        }\n+\n+        [SupportedOSPlatform(\"windows\")]\n+        [WindowsOnlyTheory]\n+        [InlineData(null, true)]\n+        [InlineData(\"buildIn.manifest\", true)]\n+        [InlineData(\"testManifestWithValidSupportedArchs.manifest\", true)]\n+        public void E2EScenarioTests(string manifestName, bool expectedResult)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I meant to cover just a full flow scenario - from the  target's standpoint: if it is invoked, passed params, if task can be invoked, etc.\r\n",
              "createdAt": "2024-05-23T17:10:30Z",
              "path": "src/Tasks.UnitTests/PopulateSupportedArchitectures_Tests.cs",
              "diffHunk": "@@ -0,0 +1,190 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Runtime.Versioning;\n+using System.Xml;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.UnitTests;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class PopulateSupportedArchitectures_Tests\n+    {\n+        private static string TestAssetsRootPath { get; } = Path.Combine(\n+            Path.GetDirectoryName(typeof(PopulateSupportedArchitectures_Tests).Assembly.Location) ?? AppContext.BaseDirectory,\n+            \"TestResources\",\n+            \"Manifests\");\n+\n+        private readonly ITestOutputHelper _testOutput;\n+\n+        public PopulateSupportedArchitectures_Tests(ITestOutputHelper testOutput) => _testOutput = testOutput;\n+\n+        [Theory]\n+        [InlineData(\"testManifestWithInvalidSupportedArchs.manifest\", false)]\n+        [InlineData(\"testManifestWithApplicationDefined.manifest\", true)]\n+        [InlineData(\"testManifestSavesTheCurrentNodesPositions.manifest\", true)]\n+        [InlineData(null, true)]\n+        public void ManifestPopulationCheck(string manifestName, bool expectedResult)\n+        {\n+            PopulateSupportedArchitectures task = new PopulateSupportedArchitectures()\n+            {\n+                BuildEngine = new MockEngine(_testOutput)\n+            };\n+\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                var tempOutput = env.CreateFolder().Path;\n+                task.OutputDirectory = tempOutput;\n+                task.SupportedArchitectures = \"amd64 arm64\";\n+                if (!string.IsNullOrEmpty(manifestName))\n+                {\n+                    task.ApplicationManifestPath = Path.Combine(TestAssetsRootPath, manifestName);\n+                }\n+\n+                var result = task.Execute();\n+\n+                result.ShouldBe(expectedResult);\n+\n+                if (result)\n+                {\n+                    string generatedManifest = task.ManifestPath;\n+                    string expectedManifest = Path.Combine(TestAssetsRootPath, $\"{manifestName ?? \"default.win32manifest\"}_expected\");\n+\n+                    XmlDocument expectedDoc = new XmlDocument();\n+                    XmlDocument actualDoc = new XmlDocument();\n+\n+                    expectedDoc.Load(expectedManifest);\n+                    actualDoc.Load(generatedManifest);\n+\n+                    expectedDoc.OuterXml.ShouldBe(actualDoc.OuterXml);\n+                    expectedDoc.InnerXml.ShouldBe(actualDoc.InnerXml);\n+                }\n+            }\n+        }\n+\n+        [SupportedOSPlatform(\"windows\")]\n+        [WindowsOnlyTheory]\n+        [InlineData(null, true)]\n+        [InlineData(\"buildIn.manifest\", true)]\n+        [InlineData(\"testManifestWithValidSupportedArchs.manifest\", true)]\n+        public void E2EScenarioTests(string manifestName, bool expectedResult)",
              "author": {
                "login": "YuliiaKovalova"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo \"Openned\"",
              "createdAt": "2024-05-24T10:38:54Z",
              "path": "src/Tasks/Resources/Strings.resx",
              "diffHunk": "@@ -3013,6 +3013,46 @@\n     <value>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</value>\n     <comment>{StrBegin=\"MSB3992: \"}</comment>\n   </data>\n+\n+  <!--\n+        MSB4300 - MSB4310   Task: AddToWin32Manifest\n+  -->\n+  <data name=\"AddToWin32Manifest.InvalidValueInSupportedArchitectures\">\n+    <value>MSB4300: The specified value: '{0}' for supportedArchitectures element is invalid. Either remove it from manifest or set as 'amd64 arm64'.</value>\n+    <comment>{StrBegin=\"MSB4300: \"}</comment>\n+  </data>\n+  <data name=\"AddToWin32Manifest.AssemblyNodeIsMissed\">\n+    <value>The assembly element is missing from the application manifest.</value>\n+  </data>\n+  <data name=\"AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound\">\n+    <value>The application manifest file cannot be found: '{0}'. Please make sure it exists.</value>\n+  </data>\n+  <data name=\"AddToWin32Manifest.ManifestCanNotBeOpenned\">",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Typos: \"Openned\" and \"openning\"",
              "createdAt": "2024-05-24T10:40:23Z",
              "path": "src/Tasks/Resources/Strings.resx",
              "diffHunk": "@@ -3013,6 +3013,46 @@\n     <value>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</value>\n     <comment>{StrBegin=\"MSB3992: \"}</comment>\n   </data>\n+\n+  <!--\n+        MSB4300 - MSB4310   Task: AddToWin32Manifest\n+  -->\n+  <data name=\"AddToWin32Manifest.InvalidValueInSupportedArchitectures\">\n+    <value>MSB4300: The specified value: '{0}' for supportedArchitectures element is invalid. Either remove it from manifest or set as 'amd64 arm64'.</value>\n+    <comment>{StrBegin=\"MSB4300: \"}</comment>\n+  </data>\n+  <data name=\"AddToWin32Manifest.AssemblyNodeIsMissed\">\n+    <value>The assembly element is missing from the application manifest.</value>\n+  </data>\n+  <data name=\"AddToWin32Manifest.SpecifiedApplicationManifestCanNotBeFound\">\n+    <value>The application manifest file cannot be found: '{0}'. Please make sure it exists.</value>\n+  </data>\n+  <data name=\"AddToWin32Manifest.ManifestCanNotBeOpenned\">\n+    <value>The manifest file either does not exist or can not be read. Please make sure it exists and has relevant content.</value>\n+  </data>\n+  <data name=\"AddToWin32Manifest.ManifestCanNotBeOpennedWithException\">\n+    <value>The manifest file openning has failed with exception: '{0}'. Please make sure it exists and has relevant content.</value>\n+  </data>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`'$(PreferNativeArm64)' == ''` implies `'$(PreferNativeArm64)' != 'true'` so I believe the condition can be simplified.",
              "createdAt": "2024-05-24T11:15:53Z",
              "path": "src/Tasks/Microsoft.NETFramework.CurrentVersion.props",
              "diffHunk": "@@ -83,7 +83,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     <TargetedRuntimeVersion Condition=\"'$(TargetedRuntimeVersion)' == ''\">v$(MSBuildRuntimeVersion)</TargetedRuntimeVersion>\n   </PropertyGroup>\n \n-  <PropertyGroup Condition=\"'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == '')\">\n+  <PropertyGroup Condition=\"'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == '') and ('$(PreferNativeArm64)' == '' or '$(PreferNativeArm64)' != 'true')\">",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: The added lines don't seem to be indented the same way as existing content.",
              "createdAt": "2024-05-24T11:17:05Z",
              "path": "src/Tasks/Microsoft.Common.tasks",
              "diffHunk": "@@ -62,6 +62,8 @@\n   <UsingTask TaskName=\"Microsoft.Build.Tasks.Message\"                               AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n   <UsingTask TaskName=\"Microsoft.Build.Tasks.Move\"                                  AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n   <UsingTask TaskName=\"Microsoft.Build.Tasks.MSBuild\"                               AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n+  <UsingTask TaskName=\"Microsoft.Build.Tasks.MSBuildInternalMessage\"                            AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n+  <UsingTask TaskName=\"Microsoft.Build.Tasks.AddToWin32Manifest\"        AssemblyName=\"Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Same as in the .props file, the condition can be simplified.",
              "createdAt": "2024-05-24T11:18:20Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -4139,12 +4146,44 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <Win32Manifest>$(ApplicationManifest)</Win32Manifest>\n     </PropertyGroup>\n \n-    <GetFrameworkPath Condition=\"'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true'\">\n+    <!-- If PreferNativeArm64 is enabled, it searches for the same default.win32manifest  -->\n+    <GetFrameworkPath Condition=\"'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and ('$(PreferNativeArm64)' == '' or '$(PreferNativeArm64)' != 'true')\">",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}