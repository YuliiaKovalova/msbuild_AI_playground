{
  "number": 9111,
  "title": "Don't use TranslateDotNet in TaskParameter",
  "body": "Fixes #8923 \r\n\r\n### Context\r\n\r\nMoving `TaskParameter` instances between processes uses `TranslateDotNet` for serializing/deserializing value types and value type arrays. This functionality is implemented on top of `BinaryFormatter` and as such problematic from compliance perspective.\r\n\r\n### Changes Made\r\n\r\nReworked `TaskParameter` so now it operates on the following types:\r\n\r\n- `PrimitiveType` and `PrimitiveTypeArray`, which are converted with `Convert.ChangeType(o, typeof(T))` to/from string or serialized natively if the type is supported by `ITranslator`. These types additionally use `System.TypeCode` of the specific type as a discriminator.\r\n- `ValueType` and `ValueTypeArray`, which are converted only to string because they can only be used in task outputs. The requirement for these to implement `IConvertible` is not new. Without the changes in this PR a serializable but non-`IConvertible` task output parameter can be moved from the task host process but fails later because the same `Convert.ChangeType` conversion is attempted by the engine.\r\n- `ITaskItem, ITaskItemArray, Invalid, Null` - no change, same behavior as before.\r\n\r\n### Testing\r\n\r\nExisting unit tests (extended, enhanced, and refactored).\r\n\r\n### Notes\r\n\r\n- The new code is under a change wave check so it can be disabled if needed.\r\n- If the user disables the 17.8 change wave, they will have to make sure that MSBuild can call `BinaryFormatter`. This is an unfortunate limitation but it seems to be done elsewhere already (`TranslateException` for example) so I'm assuming it's been thought though.",
  "state": "MERGED",
  "createdAt": "2023-08-08T12:41:22Z",
  "updatedAt": "2023-08-14T07:43:41Z",
  "closedAt": "2023-08-14T07:43:37Z",
  "mergedAt": "2023-08-14T07:43:37Z",
  "additions": 1437,
  "deletions": 287,
  "changedFiles": 6,
  "headRefName": "task-parameter-bf",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "07c6a3c2fb58adb94d4516242bd0d53643b9b828",
          "message": "Add TaskParameterType.BoolArray, TaskParameterType.IntArray",
          "committedDate": "2023-08-08T09:10:04Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c71235c23a72177c8f69039acd972d1644919de8",
          "message": "Extend and enhance VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost",
          "committedDate": "2023-08-08T11:29:02Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e30f7783cc49cf8acc06b0577fee0890fe9de680",
          "message": "Don't use TranslateDotNet under ChangeWave check",
          "committedDate": "2023-08-08T12:15:27Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a87b369048522878d5d787965752cbbc5d2b13f2",
          "message": "Run VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost with and without the changes",
          "committedDate": "2023-08-08T13:09:04Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7ba77b903ef362427e489331067f81c70d5028ec",
          "message": "Don't serialize type names",
          "committedDate": "2023-08-10T07:39:52Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "623716b6bfd9b4598e07fe21e376d6b18518f31a",
          "message": "Use Convert.ChangeType instead of Convert.ToString for consistency",
          "committedDate": "2023-08-10T07:40:33Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5c710a321679dd2c2f79de09b700e95100779932",
          "message": "Revert \"Use Convert.ChangeType instead of Convert.ToString for consistency\"\n\nThis reverts commit 623716b6bfd9b4598e07fe21e376d6b18518f31a.",
          "committedDate": "2023-08-10T09:41:11Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1f92ec8bbd1b9c8c62fb250ceccde633c8cbc920",
          "message": "Revert \"Don't serialize type names\"\n\nThis reverts commit 7ba77b903ef362427e489331067f81c70d5028ec.",
          "committedDate": "2023-08-10T09:41:22Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c93fce59be347c3acf5893af83911dc3a241366a",
          "message": "Extend TaskBuilderTestTask with all built-in IConvertible types",
          "committedDate": "2023-08-10T12:15:41Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eaf7622edb5ca58f41e5d92ea09824cfd13468ef",
          "message": "Work around a BinaryFormatter bug",
          "committedDate": "2023-08-11T07:27:22Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb584e0ceeeb80875b7d9458a31e79847f4c57af",
          "message": "Extend VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost",
          "committedDate": "2023-08-11T07:28:47Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c76f53727b51cf0813a93625affa4442785fe1fa",
          "message": "Rework TaskParameter serialization",
          "committedDate": "2023-08-11T07:32:12Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b65b29e1bbf1a1d19fafd24a716f12180f055e99",
          "message": "Cover all types with TaskParameter_Tests",
          "committedDate": "2023-08-11T08:16:07Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d7ee72f52e4dadf2443d35304600b4b936b10b07",
          "message": "Use ITranslator for supported primitive types",
          "committedDate": "2023-08-11T10:01:05Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f1fc80b965c636194de4c0a2bd97274af36af050",
          "message": "Update src/Shared/TaskParameter.cs",
          "committedDate": "2023-08-11T10:52:11Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "ladi.prosek@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2b344291b218747366c642745f853a7b44468222",
          "message": "Update comment",
          "committedDate": "2023-08-14T07:07:47Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "(May be easier to review by commit.)",
        "createdAt": "2023-08-08T13:18:12Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "@rokonec @JanKrivanek I ended up reworking the PR, please take another look when you get a chance.\r\n\r\nHere is the key revelation that led to the current approach:\r\n\r\n`IConvertible` provides methods to convert the implementing type to primitives, most importantly to string. It does not include the other direction (I had assumed it was a convention with a string-taking constructor, for example), i.e. `Convert.ChangeType(o, typeof(T))` fails for custom types. It works only for \"built-in\" convertibles, of which there is a limited set. They are enumerated in the `System.TypeCode` enum.\r\n\r\nAs a consequence, custom `IConvertible` implementations are allowed to be used only as task outputs, as the engine can convert from the output value to the internal string representation. The set of allowed task inputs types is therefore limited to built-in convertibles and there is no need to communicate the parameter type as part of the payload or infer it from the signature of the corresponding .NET property.\r\n\r\n`TaskParameter` now distinguishes:\r\n1. `PrimitiveType` and `PrimitiveTypeArray` types, which are converted with `Convert.ChangeType(o, typeof(T))` to/from string or serialized natively if the type is supported by `ITranslator`.\r\n2. `ValueType` and `ValueTypeArray` types, which are converted only _to_ string because they can only be task outputs.\r\n3. `ITaskItem`, `ITaskItemArray`, `Invalid`, `Null` - same as before.\r\n\r\n`PrimitiveType` and `PrimitiveTypeArray` additionally serializes the `TypeCode` of the specific type. I did this to avoid exploding `TaskParameterType` enum with many more types.\r\n\r\nSince this functionality is somewhat obscure, I did my best to cover it with tests, doing some refactoring along the way. For example, `TaskParameter_Tests` could be easily parameterized using `[Theory]` instead of many `[Fact]`s with duplicated code.\r\n\r\nThe `ValueType` and `ValueTypeArray` conversion code is still under a change wave check. At this point I am more confident that the new logic is correct so I'll defer to your opinion whether it's needed or not.",
        "createdAt": "2023-08-11T10:33:03Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "> (May be easier to review by commit.)\r\n\r\nNo longer the case \u2639\ufe0f ",
        "createdAt": "2023-08-11T10:34:27Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Why? It would force people to mark their new custom value type by [Serializable] although they don't need it.\r\nI believe we could allow it.\r\nIs there same check when \"normal non task-host task\" argument is converted when task is factored? If not, then value arguments will work and fails only when task needs to be task-hosted.",
              "createdAt": "2023-08-08T16:25:39Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +583,100 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string typeName = null;\n+            string valueString = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Type type = _wrappedParameter.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!type.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{type} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                typeName = type.AssemblyQualifiedName;\n+                valueString = Convert.ToString(_wrappedParameter, CultureInfo.InvariantCulture);\n+            }\n+\n+            translator.Translate(ref typeName);\n+            translator.Translate(ref valueString);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                Type type = Type.GetType(typeName);\n+                _wrappedParameter = Convert.ChangeType(valueString, type, CultureInfo.InvariantCulture);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type array instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The array is assumed to be non-null.\n+        /// </remarks>\n+        private void TranslateValueTypeArray(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Array array = (Array)_wrappedParameter;\n+                Type arrayType = array.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!arrayType.GetTypeInfo().IsSerializable)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Since our long-term plan should be to kill this functionality, types are still required to be serializable so that we are as strict as the current logic, i.e. we don't want to open it up to more types. You're right that this limitation currently exists only for tasks hosted in the task host and while it feels artificial for the new code, I slightly prefer having this.",
              "createdAt": "2023-08-08T21:02:50Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +583,100 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string typeName = null;\n+            string valueString = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Type type = _wrappedParameter.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!type.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{type} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                typeName = type.AssemblyQualifiedName;\n+                valueString = Convert.ToString(_wrappedParameter, CultureInfo.InvariantCulture);\n+            }\n+\n+            translator.Translate(ref typeName);\n+            translator.Translate(ref valueString);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                Type type = Type.GetType(typeName);\n+                _wrappedParameter = Convert.ChangeType(valueString, type, CultureInfo.InvariantCulture);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type array instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The array is assumed to be non-null.\n+        /// </remarks>\n+        private void TranslateValueTypeArray(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Array array = (Array)_wrappedParameter;\n+                Type arrayType = array.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!arrayType.GetTypeInfo().IsSerializable)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I have updated the PR and we no longer have to discontinue this functionality. Consequently I have removed the restriction. Thank you!",
              "createdAt": "2023-08-11T10:03:45Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +583,100 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string typeName = null;\n+            string valueString = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Type type = _wrappedParameter.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!type.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{type} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                typeName = type.AssemblyQualifiedName;\n+                valueString = Convert.ToString(_wrappedParameter, CultureInfo.InvariantCulture);\n+            }\n+\n+            translator.Translate(ref typeName);\n+            translator.Translate(ref valueString);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                Type type = Type.GetType(typeName);\n+                _wrappedParameter = Convert.ChangeType(valueString, type, CultureInfo.InvariantCulture);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type array instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The array is assumed to be non-null.\n+        /// </remarks>\n+        private void TranslateValueTypeArray(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Array array = (Array)_wrappedParameter;\n+                Type arrayType = array.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!arrayType.GetTypeInfo().IsSerializable)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I have not looked into it, but is `Convert.ToString` always same as `Convert.ChangeType(valueString, typeof(string))` which is used in other parts of code?",
              "createdAt": "2023-08-08T16:27:00Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +583,100 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string typeName = null;\n+            string valueString = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Type type = _wrappedParameter.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!type.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{type} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                typeName = type.AssemblyQualifiedName;\n+                valueString = Convert.ToString(_wrappedParameter, CultureInfo.InvariantCulture);\n+            }\n+\n+            translator.Translate(ref typeName);\n+            translator.Translate(ref valueString);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                Type type = Type.GetType(typeName);\n+                _wrappedParameter = Convert.ChangeType(valueString, type, CultureInfo.InvariantCulture);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type array instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The array is assumed to be non-null.\n+        /// </remarks>\n+        private void TranslateValueTypeArray(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Array array = (Array)_wrappedParameter;\n+                Type arrayType = array.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!arrayType.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{arrayType} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                string typeName = arrayType.GetElementType().AssemblyQualifiedName;\n+                int length = array.Length;\n+\n+                translator.Translate(ref typeName);\n+                translator.Translate(ref length);\n+\n+                for (int i = 0; i < length; i++)\n+                {\n+                    string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "It is the same for types implementing `IConvertible` and we shouldn't get here for any other type. I'll switch to `Convert.ChangeType` for consistency, thank you for pointing it out.",
              "createdAt": "2023-08-08T21:05:14Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +583,100 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string typeName = null;\n+            string valueString = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Type type = _wrappedParameter.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!type.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{type} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                typeName = type.AssemblyQualifiedName;\n+                valueString = Convert.ToString(_wrappedParameter, CultureInfo.InvariantCulture);\n+            }\n+\n+            translator.Translate(ref typeName);\n+            translator.Translate(ref valueString);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                Type type = Type.GetType(typeName);\n+                _wrappedParameter = Convert.ChangeType(valueString, type, CultureInfo.InvariantCulture);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type array instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The array is assumed to be non-null.\n+        /// </remarks>\n+        private void TranslateValueTypeArray(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Array array = (Array)_wrappedParameter;\n+                Type arrayType = array.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!arrayType.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{arrayType} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                string typeName = arrayType.GetElementType().AssemblyQualifiedName;\n+                int length = array.Length;\n+\n+                translator.Translate(ref typeName);\n+                translator.Translate(ref length);\n+\n+                for (int i = 0; i < length; i++)\n+                {\n+                    string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Done.",
              "createdAt": "2023-08-11T10:04:01Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +583,100 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string typeName = null;\n+            string valueString = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Type type = _wrappedParameter.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!type.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{type} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                typeName = type.AssemblyQualifiedName;\n+                valueString = Convert.ToString(_wrappedParameter, CultureInfo.InvariantCulture);\n+            }\n+\n+            translator.Translate(ref typeName);\n+            translator.Translate(ref valueString);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                Type type = Type.GetType(typeName);\n+                _wrappedParameter = Convert.ChangeType(valueString, type, CultureInfo.InvariantCulture);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type array instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The array is assumed to be non-null.\n+        /// </remarks>\n+        private void TranslateValueTypeArray(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Array array = (Array)_wrappedParameter;\n+                Type arrayType = array.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!arrayType.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{arrayType} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                string typeName = arrayType.GetElementType().AssemblyQualifiedName;\n+                int length = array.Length;\n+\n+                translator.Translate(ref typeName);\n+                translator.Translate(ref length);\n+\n+                for (int i = 0; i < length; i++)\n+                {\n+                    string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "That looks little bit unsafe. \r\nCan we infer type from given property of destination type? We know what we deserialiaze into so we don't need typename on the wire, rigth?",
              "createdAt": "2023-08-08T16:30:57Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +583,100 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string typeName = null;\n+            string valueString = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Type type = _wrappedParameter.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!type.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{type} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                typeName = type.AssemblyQualifiedName;\n+                valueString = Convert.ToString(_wrappedParameter, CultureInfo.InvariantCulture);\n+            }\n+\n+            translator.Translate(ref typeName);\n+            translator.Translate(ref valueString);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                Type type = Type.GetType(typeName);\n+                _wrappedParameter = Convert.ChangeType(valueString, type, CultureInfo.InvariantCulture);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type array instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The array is assumed to be non-null.\n+        /// </remarks>\n+        private void TranslateValueTypeArray(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Array array = (Array)_wrappedParameter;\n+                Type arrayType = array.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!arrayType.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{arrayType} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                string typeName = arrayType.GetElementType().AssemblyQualifiedName;\n+                int length = array.Length;\n+\n+                translator.Translate(ref typeName);\n+                translator.Translate(ref length);\n+\n+                for (int i = 0; i < length; i++)\n+                {\n+                    string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                    translator.Translate(ref valueString);\n+                }\n+            }\n+            else\n+            {\n+                string typeName = null;\n+                int length = 0;\n+\n+                translator.Translate(ref typeName);\n+                translator.Translate(ref length);\n+\n+                Type elementType = Type.GetType(typeName);\n+                Array array = Array.CreateInstance(elementType, length);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Should be doable, maybe at the cost of extra reflection calls on the receiving side. I'm not sure if the added complexity is worth it, though. \"Type name on the wire\" is inherent to the task host scenario. We're instructing another process to load a task type, by design. I would argue that this exercise is just about compliance, not security. Nothing is changing security-wise; if you can intercept our IPC calls and modify the data, you can do nasty things with or without this code.",
              "createdAt": "2023-08-08T21:20:50Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +583,100 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string typeName = null;\n+            string valueString = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Type type = _wrappedParameter.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!type.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{type} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                typeName = type.AssemblyQualifiedName;\n+                valueString = Convert.ToString(_wrappedParameter, CultureInfo.InvariantCulture);\n+            }\n+\n+            translator.Translate(ref typeName);\n+            translator.Translate(ref valueString);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                Type type = Type.GetType(typeName);\n+                _wrappedParameter = Convert.ChangeType(valueString, type, CultureInfo.InvariantCulture);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type array instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The array is assumed to be non-null.\n+        /// </remarks>\n+        private void TranslateValueTypeArray(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Array array = (Array)_wrappedParameter;\n+                Type arrayType = array.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!arrayType.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{arrayType} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                string typeName = arrayType.GetElementType().AssemblyQualifiedName;\n+                int length = array.Length;\n+\n+                translator.Translate(ref typeName);\n+                translator.Translate(ref length);\n+\n+                for (int i = 0; i < length; i++)\n+                {\n+                    string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                    translator.Translate(ref valueString);\n+                }\n+            }\n+            else\n+            {\n+                string typeName = null;\n+                int length = 0;\n+\n+                translator.Translate(ref typeName);\n+                translator.Translate(ref length);\n+\n+                Type elementType = Type.GetType(typeName);\n+                Array array = Array.CreateInstance(elementType, length);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Agreeing with both of you.\r\nImplementation cost seems to be low; performance cost hits only the TaskHost scenario (where, I believe, we already do not care about perf) - I'd just go for it and defer the thoughts of the real value",
              "createdAt": "2023-08-09T09:01:46Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +583,100 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string typeName = null;\n+            string valueString = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Type type = _wrappedParameter.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!type.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{type} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                typeName = type.AssemblyQualifiedName;\n+                valueString = Convert.ToString(_wrappedParameter, CultureInfo.InvariantCulture);\n+            }\n+\n+            translator.Translate(ref typeName);\n+            translator.Translate(ref valueString);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                Type type = Type.GetType(typeName);\n+                _wrappedParameter = Convert.ChangeType(valueString, type, CultureInfo.InvariantCulture);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type array instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The array is assumed to be non-null.\n+        /// </remarks>\n+        private void TranslateValueTypeArray(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Array array = (Array)_wrappedParameter;\n+                Type arrayType = array.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!arrayType.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{arrayType} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                string typeName = arrayType.GetElementType().AssemblyQualifiedName;\n+                int length = array.Length;\n+\n+                translator.Translate(ref typeName);\n+                translator.Translate(ref length);\n+\n+                for (int i = 0; i < length; i++)\n+                {\n+                    string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                    translator.Translate(ref valueString);\n+                }\n+            }\n+            else\n+            {\n+                string typeName = null;\n+                int length = 0;\n+\n+                translator.Translate(ref typeName);\n+                translator.Translate(ref length);\n+\n+                Type elementType = Type.GetType(typeName);\n+                Array array = Array.CreateInstance(elementType, length);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I ended up reworking the PR completely after getting better understanding of what's currently supported. We don't put type names on the wire now, nor do we have to fish for the expected type elsewhere. I'll summarize in a top-level comment.",
              "createdAt": "2023-08-11T10:07:27Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +583,100 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string typeName = null;\n+            string valueString = null;\n+\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Type type = _wrappedParameter.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!type.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{type} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                typeName = type.AssemblyQualifiedName;\n+                valueString = Convert.ToString(_wrappedParameter, CultureInfo.InvariantCulture);\n+            }\n+\n+            translator.Translate(ref typeName);\n+            translator.Translate(ref valueString);\n+\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                Type type = Type.GetType(typeName);\n+                _wrappedParameter = Convert.ChangeType(valueString, type, CultureInfo.InvariantCulture);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type array instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The array is assumed to be non-null.\n+        /// </remarks>\n+        private void TranslateValueTypeArray(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                Array array = (Array)_wrappedParameter;\n+                Type arrayType = array.GetType();\n+\n+                // Don't allow non-serializable types to be translated to keep the same limitation as the previous\n+                // BinaryFormatter-based implementation.\n+#pragma warning disable SYSLIB0050\n+                if (!arrayType.GetTypeInfo().IsSerializable)\n+#pragma warning restore SYSLIB0050\n+                {\n+                    throw new NotSupportedException($\"{arrayType} cannot be used as a task parameter type because it is not serializable.\");\n+                }\n+\n+                string typeName = arrayType.GetElementType().AssemblyQualifiedName;\n+                int length = array.Length;\n+\n+                translator.Translate(ref typeName);\n+                translator.Translate(ref length);\n+\n+                for (int i = 0; i < length; i++)\n+                {\n+                    string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                    translator.Translate(ref valueString);\n+                }\n+            }\n+            else\n+            {\n+                string typeName = null;\n+                int length = 0;\n+\n+                translator.Translate(ref typeName);\n+                translator.Translate(ref length);\n+\n+                Type elementType = Type.GetType(typeName);\n+                Array array = Array.CreateInstance(elementType, length);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please consider support for double, doublearray, datetime, timespan. for which we also have native translator methods.",
              "createdAt": "2023-08-08T16:36:06Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -145,6 +155,16 @@ public TaskParameter(object wrappedParameter)\n \n                     _wrappedParameter = taskItemArrayParameter;\n                 }\n+                else if (wrappedParameterType == typeof(bool[]))\n+                {\n+                    _parameterType = TaskParameterType.BoolArray;\n+                    _wrappedParameter = wrappedParameter;\n+                }\n+                else if (wrappedParameterType == typeof(int[]))\n+                {\n+                    _parameterType = TaskParameterType.IntArray;\n+                    _wrappedParameter = wrappedParameter;\n+                }",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I have opted for not extending `ITranslator` with additional types. There are many of them and the chances that they are actually used are slim. The perf difference is negligible.",
              "createdAt": "2023-08-11T10:12:40Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -145,6 +155,16 @@ public TaskParameter(object wrappedParameter)\n \n                     _wrappedParameter = taskItemArrayParameter;\n                 }\n+                else if (wrappedParameterType == typeof(bool[]))\n+                {\n+                    _parameterType = TaskParameterType.BoolArray;\n+                    _wrappedParameter = wrappedParameter;\n+                }\n+                else if (wrappedParameterType == typeof(int[]))\n+                {\n+                    _parameterType = TaskParameterType.IntArray;\n+                    _wrappedParameter = wrappedParameter;\n+                }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we use the `_parameterTypeCode` directly here?\r\n",
              "createdAt": "2023-08-11T10:39:45Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +513,222 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes a primitive type value wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveType(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;\n+                    translator.Translate(ref boolParam);\n+                    _wrappedParameter = boolParam;\n+                    break;\n+\n+                case TypeCode.Byte:\n+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;\n+                    translator.Translate(ref byteParam);\n+                    _wrappedParameter = byteParam;\n+                    break;\n+\n+                case TypeCode.Int16:\n+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;\n+                    translator.Translate(ref shortParam);\n+                    _wrappedParameter = shortParam;\n+                    break;\n+\n+                case TypeCode.UInt16:\n+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;\n+                    translator.Translate(ref ushortParam);\n+                    _wrappedParameter = ushortParam;\n+                    break;\n+\n+                case TypeCode.Int64:\n+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;\n+                    translator.Translate(ref longParam);\n+                    _wrappedParameter = longParam;\n+                    break;\n+\n+                case TypeCode.Double:\n+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;\n+                    translator.Translate(ref doubleParam);\n+                    _wrappedParameter = doubleParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string stringParam = (string)_wrappedParameter;\n+                    translator.Translate(ref stringParam);\n+                    _wrappedParameter = stringParam;\n+                    break;\n+\n+                case TypeCode.DateTime:\n+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;\n+                    translator.Translate(ref dateTimeParam);\n+                    _wrappedParameter = dateTimeParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    string stringValue = null;\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);\n+                    }\n+\n+                    translator.Translate(ref stringValue);\n+\n+                    if (translator.Mode == TranslationDirection.ReadFromStream)\n+                    {\n+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveTypeArray(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool[] boolArrayParam = (bool[])_wrappedParameter;\n+                    translator.Translate(ref boolArrayParam);\n+                    _wrappedParameter = boolArrayParam;\n+                    break;\n+\n+                case TypeCode.Int32:\n+                    int[] intArrayParam = (int[])_wrappedParameter;\n+                    translator.Translate(ref intArrayParam);\n+                    _wrappedParameter = intArrayParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string[] stringArrayParam = (string[])_wrappedParameter;\n+                    translator.Translate(ref stringArrayParam);\n+                    _wrappedParameter = stringArrayParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        Array array = (Array)_wrappedParameter;\n+                        int length = array.Length;\n+\n+                        translator.Translate(ref length);\n+\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                            translator.Translate(ref valueString);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        Type elementType = _parameterTypeCode switch\n+                        {\n+                            TypeCode.Char => typeof(char),\n+                            TypeCode.SByte => typeof(sbyte),\n+                            TypeCode.Byte => typeof(byte),\n+                            TypeCode.Int16 => typeof(short),\n+                            TypeCode.UInt16 => typeof(ushort),\n+                            TypeCode.UInt32 => typeof(uint),\n+                            TypeCode.Int64 => typeof(long),\n+                            TypeCode.UInt64 => typeof(ulong),\n+                            TypeCode.Single => typeof(float),\n+                            TypeCode.Double => typeof(double),\n+                            TypeCode.Decimal => typeof(decimal),\n+                            TypeCode.DateTime => typeof(DateTime),\n+                            _ => throw new NotImplementedException(),\n+                        };\n+\n+                        int length = 0;\n+                        translator.Translate(ref length);\n+\n+                        Array array = Array.CreateInstance(elementType, length);\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = null;\n+                            translator.Translate(ref valueString);\n+                            array.SetValue(Convert.ChangeType(valueString, elementType, CultureInfo.InvariantCulture), i);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "If you mean:\r\n\r\n```suggestion\r\n                            array.SetValue(Convert.ChangeType(valueString, _parameterTypeCode, CultureInfo.InvariantCulture), i);\r\n```\r\n\r\nthen it is equivalent. But it's an extra verification that the `TypeCode` -> `Type` switch above is correct, so let's do it.",
              "createdAt": "2023-08-11T10:52:02Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +513,222 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes a primitive type value wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveType(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;\n+                    translator.Translate(ref boolParam);\n+                    _wrappedParameter = boolParam;\n+                    break;\n+\n+                case TypeCode.Byte:\n+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;\n+                    translator.Translate(ref byteParam);\n+                    _wrappedParameter = byteParam;\n+                    break;\n+\n+                case TypeCode.Int16:\n+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;\n+                    translator.Translate(ref shortParam);\n+                    _wrappedParameter = shortParam;\n+                    break;\n+\n+                case TypeCode.UInt16:\n+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;\n+                    translator.Translate(ref ushortParam);\n+                    _wrappedParameter = ushortParam;\n+                    break;\n+\n+                case TypeCode.Int64:\n+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;\n+                    translator.Translate(ref longParam);\n+                    _wrappedParameter = longParam;\n+                    break;\n+\n+                case TypeCode.Double:\n+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;\n+                    translator.Translate(ref doubleParam);\n+                    _wrappedParameter = doubleParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string stringParam = (string)_wrappedParameter;\n+                    translator.Translate(ref stringParam);\n+                    _wrappedParameter = stringParam;\n+                    break;\n+\n+                case TypeCode.DateTime:\n+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;\n+                    translator.Translate(ref dateTimeParam);\n+                    _wrappedParameter = dateTimeParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    string stringValue = null;\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);\n+                    }\n+\n+                    translator.Translate(ref stringValue);\n+\n+                    if (translator.Mode == TranslationDirection.ReadFromStream)\n+                    {\n+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveTypeArray(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool[] boolArrayParam = (bool[])_wrappedParameter;\n+                    translator.Translate(ref boolArrayParam);\n+                    _wrappedParameter = boolArrayParam;\n+                    break;\n+\n+                case TypeCode.Int32:\n+                    int[] intArrayParam = (int[])_wrappedParameter;\n+                    translator.Translate(ref intArrayParam);\n+                    _wrappedParameter = intArrayParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string[] stringArrayParam = (string[])_wrappedParameter;\n+                    translator.Translate(ref stringArrayParam);\n+                    _wrappedParameter = stringArrayParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        Array array = (Array)_wrappedParameter;\n+                        int length = array.Length;\n+\n+                        translator.Translate(ref length);\n+\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                            translator.Translate(ref valueString);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        Type elementType = _parameterTypeCode switch\n+                        {\n+                            TypeCode.Char => typeof(char),\n+                            TypeCode.SByte => typeof(sbyte),\n+                            TypeCode.Byte => typeof(byte),\n+                            TypeCode.Int16 => typeof(short),\n+                            TypeCode.UInt16 => typeof(ushort),\n+                            TypeCode.UInt32 => typeof(uint),\n+                            TypeCode.Int64 => typeof(long),\n+                            TypeCode.UInt64 => typeof(ulong),\n+                            TypeCode.Single => typeof(float),\n+                            TypeCode.Double => typeof(double),\n+                            TypeCode.Decimal => typeof(decimal),\n+                            TypeCode.DateTime => typeof(DateTime),\n+                            _ => throw new NotImplementedException(),\n+                        };\n+\n+                        int length = 0;\n+                        translator.Translate(ref length);\n+\n+                        Array array = Array.CreateInstance(elementType, length);\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = null;\n+                            translator.Translate(ref valueString);\n+                            array.SetValue(Convert.ChangeType(valueString, elementType, CultureInfo.InvariantCulture), i);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I mean - do we even need the switch? `_parameterTypeCode` cannot already have the value of Object or DBNull (we can possibly explicitly throw just on those unexpected values (Empty as well))",
              "createdAt": "2023-08-11T10:56:10Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +513,222 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes a primitive type value wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveType(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;\n+                    translator.Translate(ref boolParam);\n+                    _wrappedParameter = boolParam;\n+                    break;\n+\n+                case TypeCode.Byte:\n+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;\n+                    translator.Translate(ref byteParam);\n+                    _wrappedParameter = byteParam;\n+                    break;\n+\n+                case TypeCode.Int16:\n+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;\n+                    translator.Translate(ref shortParam);\n+                    _wrappedParameter = shortParam;\n+                    break;\n+\n+                case TypeCode.UInt16:\n+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;\n+                    translator.Translate(ref ushortParam);\n+                    _wrappedParameter = ushortParam;\n+                    break;\n+\n+                case TypeCode.Int64:\n+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;\n+                    translator.Translate(ref longParam);\n+                    _wrappedParameter = longParam;\n+                    break;\n+\n+                case TypeCode.Double:\n+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;\n+                    translator.Translate(ref doubleParam);\n+                    _wrappedParameter = doubleParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string stringParam = (string)_wrappedParameter;\n+                    translator.Translate(ref stringParam);\n+                    _wrappedParameter = stringParam;\n+                    break;\n+\n+                case TypeCode.DateTime:\n+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;\n+                    translator.Translate(ref dateTimeParam);\n+                    _wrappedParameter = dateTimeParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    string stringValue = null;\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);\n+                    }\n+\n+                    translator.Translate(ref stringValue);\n+\n+                    if (translator.Mode == TranslationDirection.ReadFromStream)\n+                    {\n+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveTypeArray(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool[] boolArrayParam = (bool[])_wrappedParameter;\n+                    translator.Translate(ref boolArrayParam);\n+                    _wrappedParameter = boolArrayParam;\n+                    break;\n+\n+                case TypeCode.Int32:\n+                    int[] intArrayParam = (int[])_wrappedParameter;\n+                    translator.Translate(ref intArrayParam);\n+                    _wrappedParameter = intArrayParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string[] stringArrayParam = (string[])_wrappedParameter;\n+                    translator.Translate(ref stringArrayParam);\n+                    _wrappedParameter = stringArrayParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        Array array = (Array)_wrappedParameter;\n+                        int length = array.Length;\n+\n+                        translator.Translate(ref length);\n+\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                            translator.Translate(ref valueString);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        Type elementType = _parameterTypeCode switch\n+                        {\n+                            TypeCode.Char => typeof(char),\n+                            TypeCode.SByte => typeof(sbyte),\n+                            TypeCode.Byte => typeof(byte),\n+                            TypeCode.Int16 => typeof(short),\n+                            TypeCode.UInt16 => typeof(ushort),\n+                            TypeCode.UInt32 => typeof(uint),\n+                            TypeCode.Int64 => typeof(long),\n+                            TypeCode.UInt64 => typeof(ulong),\n+                            TypeCode.Single => typeof(float),\n+                            TypeCode.Double => typeof(double),\n+                            TypeCode.Decimal => typeof(decimal),\n+                            TypeCode.DateTime => typeof(DateTime),\n+                            _ => throw new NotImplementedException(),\n+                        };\n+\n+                        int length = 0;\n+                        translator.Translate(ref length);\n+\n+                        Array array = Array.CreateInstance(elementType, length);\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = null;\n+                            translator.Translate(ref valueString);\n+                            array.SetValue(Convert.ChangeType(valueString, elementType, CultureInfo.InvariantCulture), i);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I see. It's because there is no call equivalent to\r\n\r\n`Array array = Array.CreateInstance(elementType, length);`\r\n\r\nthat takes `TypeCode` instead of `Type`. (To my best knowledge.)",
              "createdAt": "2023-08-11T10:58:37Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +513,222 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes a primitive type value wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveType(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;\n+                    translator.Translate(ref boolParam);\n+                    _wrappedParameter = boolParam;\n+                    break;\n+\n+                case TypeCode.Byte:\n+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;\n+                    translator.Translate(ref byteParam);\n+                    _wrappedParameter = byteParam;\n+                    break;\n+\n+                case TypeCode.Int16:\n+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;\n+                    translator.Translate(ref shortParam);\n+                    _wrappedParameter = shortParam;\n+                    break;\n+\n+                case TypeCode.UInt16:\n+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;\n+                    translator.Translate(ref ushortParam);\n+                    _wrappedParameter = ushortParam;\n+                    break;\n+\n+                case TypeCode.Int64:\n+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;\n+                    translator.Translate(ref longParam);\n+                    _wrappedParameter = longParam;\n+                    break;\n+\n+                case TypeCode.Double:\n+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;\n+                    translator.Translate(ref doubleParam);\n+                    _wrappedParameter = doubleParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string stringParam = (string)_wrappedParameter;\n+                    translator.Translate(ref stringParam);\n+                    _wrappedParameter = stringParam;\n+                    break;\n+\n+                case TypeCode.DateTime:\n+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;\n+                    translator.Translate(ref dateTimeParam);\n+                    _wrappedParameter = dateTimeParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    string stringValue = null;\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);\n+                    }\n+\n+                    translator.Translate(ref stringValue);\n+\n+                    if (translator.Mode == TranslationDirection.ReadFromStream)\n+                    {\n+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveTypeArray(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool[] boolArrayParam = (bool[])_wrappedParameter;\n+                    translator.Translate(ref boolArrayParam);\n+                    _wrappedParameter = boolArrayParam;\n+                    break;\n+\n+                case TypeCode.Int32:\n+                    int[] intArrayParam = (int[])_wrappedParameter;\n+                    translator.Translate(ref intArrayParam);\n+                    _wrappedParameter = intArrayParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string[] stringArrayParam = (string[])_wrappedParameter;\n+                    translator.Translate(ref stringArrayParam);\n+                    _wrappedParameter = stringArrayParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        Array array = (Array)_wrappedParameter;\n+                        int length = array.Length;\n+\n+                        translator.Translate(ref length);\n+\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                            translator.Translate(ref valueString);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        Type elementType = _parameterTypeCode switch\n+                        {\n+                            TypeCode.Char => typeof(char),\n+                            TypeCode.SByte => typeof(sbyte),\n+                            TypeCode.Byte => typeof(byte),\n+                            TypeCode.Int16 => typeof(short),\n+                            TypeCode.UInt16 => typeof(ushort),\n+                            TypeCode.UInt32 => typeof(uint),\n+                            TypeCode.Int64 => typeof(long),\n+                            TypeCode.UInt64 => typeof(ulong),\n+                            TypeCode.Single => typeof(float),\n+                            TypeCode.Double => typeof(double),\n+                            TypeCode.Decimal => typeof(decimal),\n+                            TypeCode.DateTime => typeof(DateTime),\n+                            _ => throw new NotImplementedException(),\n+                        };\n+\n+                        int length = 0;\n+                        translator.Translate(ref length);\n+\n+                        Array array = Array.CreateInstance(elementType, length);\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = null;\n+                            translator.Translate(ref valueString);\n+                            array.SetValue(Convert.ChangeType(valueString, elementType, CultureInfo.InvariantCulture), i);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Aaah - I see\r\nThen it all makes sense",
              "createdAt": "2023-08-11T11:15:27Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +513,222 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes a primitive type value wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveType(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;\n+                    translator.Translate(ref boolParam);\n+                    _wrappedParameter = boolParam;\n+                    break;\n+\n+                case TypeCode.Byte:\n+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;\n+                    translator.Translate(ref byteParam);\n+                    _wrappedParameter = byteParam;\n+                    break;\n+\n+                case TypeCode.Int16:\n+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;\n+                    translator.Translate(ref shortParam);\n+                    _wrappedParameter = shortParam;\n+                    break;\n+\n+                case TypeCode.UInt16:\n+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;\n+                    translator.Translate(ref ushortParam);\n+                    _wrappedParameter = ushortParam;\n+                    break;\n+\n+                case TypeCode.Int64:\n+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;\n+                    translator.Translate(ref longParam);\n+                    _wrappedParameter = longParam;\n+                    break;\n+\n+                case TypeCode.Double:\n+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;\n+                    translator.Translate(ref doubleParam);\n+                    _wrappedParameter = doubleParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string stringParam = (string)_wrappedParameter;\n+                    translator.Translate(ref stringParam);\n+                    _wrappedParameter = stringParam;\n+                    break;\n+\n+                case TypeCode.DateTime:\n+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;\n+                    translator.Translate(ref dateTimeParam);\n+                    _wrappedParameter = dateTimeParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    string stringValue = null;\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);\n+                    }\n+\n+                    translator.Translate(ref stringValue);\n+\n+                    if (translator.Mode == TranslationDirection.ReadFromStream)\n+                    {\n+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveTypeArray(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool[] boolArrayParam = (bool[])_wrappedParameter;\n+                    translator.Translate(ref boolArrayParam);\n+                    _wrappedParameter = boolArrayParam;\n+                    break;\n+\n+                case TypeCode.Int32:\n+                    int[] intArrayParam = (int[])_wrappedParameter;\n+                    translator.Translate(ref intArrayParam);\n+                    _wrappedParameter = intArrayParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string[] stringArrayParam = (string[])_wrappedParameter;\n+                    translator.Translate(ref stringArrayParam);\n+                    _wrappedParameter = stringArrayParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        Array array = (Array)_wrappedParameter;\n+                        int length = array.Length;\n+\n+                        translator.Translate(ref length);\n+\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                            translator.Translate(ref valueString);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        Type elementType = _parameterTypeCode switch\n+                        {\n+                            TypeCode.Char => typeof(char),\n+                            TypeCode.SByte => typeof(sbyte),\n+                            TypeCode.Byte => typeof(byte),\n+                            TypeCode.Int16 => typeof(short),\n+                            TypeCode.UInt16 => typeof(ushort),\n+                            TypeCode.UInt32 => typeof(uint),\n+                            TypeCode.Int64 => typeof(long),\n+                            TypeCode.UInt64 => typeof(ulong),\n+                            TypeCode.Single => typeof(float),\n+                            TypeCode.Double => typeof(double),\n+                            TypeCode.Decimal => typeof(decimal),\n+                            TypeCode.DateTime => typeof(DateTime),\n+                            _ => throw new NotImplementedException(),\n+                        };\n+\n+                        int length = 0;\n+                        translator.Translate(ref length);\n+\n+                        Array array = Array.CreateInstance(elementType, length);\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = null;\n+                            translator.Translate(ref valueString);\n+                            array.SetValue(Convert.ChangeType(valueString, elementType, CultureInfo.InvariantCulture), i);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would we want to be more friendly to other primite type arrays - we could probably extract the the value translation from `TranslatePrimitiveType` and call it here in a loop. But it's probably not worth the efforts.",
              "createdAt": "2023-08-11T10:42:42Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +513,222 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes a primitive type value wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveType(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;\n+                    translator.Translate(ref boolParam);\n+                    _wrappedParameter = boolParam;\n+                    break;\n+\n+                case TypeCode.Byte:\n+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;\n+                    translator.Translate(ref byteParam);\n+                    _wrappedParameter = byteParam;\n+                    break;\n+\n+                case TypeCode.Int16:\n+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;\n+                    translator.Translate(ref shortParam);\n+                    _wrappedParameter = shortParam;\n+                    break;\n+\n+                case TypeCode.UInt16:\n+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;\n+                    translator.Translate(ref ushortParam);\n+                    _wrappedParameter = ushortParam;\n+                    break;\n+\n+                case TypeCode.Int64:\n+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;\n+                    translator.Translate(ref longParam);\n+                    _wrappedParameter = longParam;\n+                    break;\n+\n+                case TypeCode.Double:\n+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;\n+                    translator.Translate(ref doubleParam);\n+                    _wrappedParameter = doubleParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string stringParam = (string)_wrappedParameter;\n+                    translator.Translate(ref stringParam);\n+                    _wrappedParameter = stringParam;\n+                    break;\n+\n+                case TypeCode.DateTime:\n+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;\n+                    translator.Translate(ref dateTimeParam);\n+                    _wrappedParameter = dateTimeParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    string stringValue = null;\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);\n+                    }\n+\n+                    translator.Translate(ref stringValue);\n+\n+                    if (translator.Mode == TranslationDirection.ReadFromStream)\n+                    {\n+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveTypeArray(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool[] boolArrayParam = (bool[])_wrappedParameter;\n+                    translator.Translate(ref boolArrayParam);\n+                    _wrappedParameter = boolArrayParam;\n+                    break;\n+\n+                case TypeCode.Int32:\n+                    int[] intArrayParam = (int[])_wrappedParameter;\n+                    translator.Translate(ref intArrayParam);\n+                    _wrappedParameter = intArrayParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string[] stringArrayParam = (string[])_wrappedParameter;\n+                    translator.Translate(ref stringArrayParam);\n+                    _wrappedParameter = stringArrayParam;\n+                    break;\n+\n+                default:",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "> But it's probably not worth the efforts.\r\n\r\n+1 on not worth the efforts. Typing a task output as something like `long[]`, running the task in the task host, and trying to squeeze every bit of perf out of it? I say **no**! \ud83d\ude04 ",
              "createdAt": "2023-08-11T10:54:55Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +513,222 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes a primitive type value wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveType(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;\n+                    translator.Translate(ref boolParam);\n+                    _wrappedParameter = boolParam;\n+                    break;\n+\n+                case TypeCode.Byte:\n+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;\n+                    translator.Translate(ref byteParam);\n+                    _wrappedParameter = byteParam;\n+                    break;\n+\n+                case TypeCode.Int16:\n+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;\n+                    translator.Translate(ref shortParam);\n+                    _wrappedParameter = shortParam;\n+                    break;\n+\n+                case TypeCode.UInt16:\n+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;\n+                    translator.Translate(ref ushortParam);\n+                    _wrappedParameter = ushortParam;\n+                    break;\n+\n+                case TypeCode.Int64:\n+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;\n+                    translator.Translate(ref longParam);\n+                    _wrappedParameter = longParam;\n+                    break;\n+\n+                case TypeCode.Double:\n+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;\n+                    translator.Translate(ref doubleParam);\n+                    _wrappedParameter = doubleParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string stringParam = (string)_wrappedParameter;\n+                    translator.Translate(ref stringParam);\n+                    _wrappedParameter = stringParam;\n+                    break;\n+\n+                case TypeCode.DateTime:\n+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;\n+                    translator.Translate(ref dateTimeParam);\n+                    _wrappedParameter = dateTimeParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    string stringValue = null;\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);\n+                    }\n+\n+                    translator.Translate(ref stringValue);\n+\n+                    if (translator.Mode == TranslationDirection.ReadFromStream)\n+                    {\n+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveTypeArray(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool[] boolArrayParam = (bool[])_wrappedParameter;\n+                    translator.Translate(ref boolArrayParam);\n+                    _wrappedParameter = boolArrayParam;\n+                    break;\n+\n+                case TypeCode.Int32:\n+                    int[] intArrayParam = (int[])_wrappedParameter;\n+                    translator.Translate(ref intArrayParam);\n+                    _wrappedParameter = intArrayParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string[] stringArrayParam = (string[])_wrappedParameter;\n+                    translator.Translate(ref stringArrayParam);\n+                    _wrappedParameter = stringArrayParam;\n+                    break;\n+\n+                default:",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Perfect that custom type is tested as well!",
              "createdAt": "2023-08-11T10:46:49Z",
              "path": "src/Shared/UnitTests/TaskParameter_Tests.cs",
              "diffHunk": "@@ -39,96 +40,124 @@ public void NullParameter()\n             Assert.Equal(TaskParameterType.Null, t2.ParameterType);\n         }\n \n-        /// <summary>\n-        /// Verifies that construction and serialization with a string parameter is OK.\n-        /// </summary>\n-        [Fact]\n-        public void StringParameter()\n+        [Theory]\n+        [InlineData(typeof(bool), (int)TypeCode.Boolean, \"True\")]\n+        [InlineData(typeof(byte), (int)TypeCode.Byte, \"127\")]\n+        [InlineData(typeof(sbyte), (int)TypeCode.SByte, \"-127\")]\n+        [InlineData(typeof(double), (int)TypeCode.Double, \"3.14\")]\n+        [InlineData(typeof(float), (int)TypeCode.Single, \"3.14\")]\n+        [InlineData(typeof(short), (int)TypeCode.Int16, \"-20000\")]\n+        [InlineData(typeof(ushort), (int)TypeCode.UInt16, \"30000\")]\n+        [InlineData(typeof(int), (int)TypeCode.Int32, \"-1\")]\n+        [InlineData(typeof(uint), (int)TypeCode.UInt32, \"1\")]\n+        [InlineData(typeof(long), (int)TypeCode.Int64, \"-1000000000000\")]\n+        [InlineData(typeof(ulong), (int)TypeCode.UInt64, \"1000000000000\")]\n+        [InlineData(typeof(decimal), (int)TypeCode.Decimal, \"29.99\")]\n+        [InlineData(typeof(char), (int)TypeCode.Char, \"q\")]\n+        [InlineData(typeof(string), (int)TypeCode.String, \"foo\")]\n+        [InlineData(typeof(DateTime), (int)TypeCode.DateTime, \"1/1/2000 12:12:12\")]\n+        public void PrimitiveParameter(Type type, int expectedTypeCodeAsInt, string testValueAsString)\n         {\n-            TaskParameter t = new TaskParameter(\"foo\");\n+            TypeCode expectedTypeCode = (TypeCode)expectedTypeCodeAsInt;\n+\n+            object value = Convert.ChangeType(testValueAsString, type, CultureInfo.InvariantCulture);\n+            TaskParameter t = new TaskParameter(value);\n \n-            Assert.Equal(\"foo\", t.WrappedParameter);\n-            Assert.Equal(TaskParameterType.String, t.ParameterType);\n+            Assert.Equal(value, t.WrappedParameter);\n+            Assert.Equal(TaskParameterType.PrimitiveType, t.ParameterType);\n+            Assert.Equal(expectedTypeCode, t.ParameterTypeCode);\n \n             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());\n             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());\n \n-            Assert.Equal(\"foo\", t2.WrappedParameter);\n-            Assert.Equal(TaskParameterType.String, t2.ParameterType);\n+            Assert.Equal(value, t2.WrappedParameter);\n+            Assert.Equal(TaskParameterType.PrimitiveType, t2.ParameterType);\n+            Assert.Equal(expectedTypeCode, t2.ParameterTypeCode);\n         }\n \n-        /// <summary>\n-        /// Verifies that construction and serialization with a string array parameter is OK.\n-        /// </summary>\n-        [Fact]\n-        public void StringArrayParameter()\n+        [Theory]\n+        [InlineData(typeof(bool), (int)TypeCode.Boolean, \"True;False;True\")]\n+        [InlineData(typeof(byte), (int)TypeCode.Byte, \"127;100;0\")]\n+        [InlineData(typeof(sbyte), (int)TypeCode.SByte, \"-127;-126;12\")]\n+        [InlineData(typeof(double), (int)TypeCode.Double, \"3.14;3.15\")]\n+        [InlineData(typeof(float), (int)TypeCode.Single, \"3.14;3.15\")]\n+        [InlineData(typeof(short), (int)TypeCode.Int16, \"-20000;0;-1\")]\n+        [InlineData(typeof(ushort), (int)TypeCode.UInt16, \"30000;20000;10\")]\n+        [InlineData(typeof(int), (int)TypeCode.Int32, \"-1;-2\")]\n+        [InlineData(typeof(uint), (int)TypeCode.UInt32, \"1;5;6\")]\n+        [InlineData(typeof(long), (int)TypeCode.Int64, \"-1000000000000;0\")]\n+        [InlineData(typeof(ulong), (int)TypeCode.UInt64, \"1000000000000;0\")]\n+        [InlineData(typeof(decimal), (int)TypeCode.Decimal, \"29.99;0.88\")]\n+        [InlineData(typeof(char), (int)TypeCode.Char, \"q;r;c\")]\n+        [InlineData(typeof(string), (int)TypeCode.String, \"foo;bar\")]\n+        [InlineData(typeof(DateTime), (int)TypeCode.DateTime, \"1/1/2000 12:12:12;2/2/2000 13:13:13\")]\n+        public void PrimitiveArrayParameter(Type type, int expectedTypeCodeAsInt, string testValueAsString)\n         {\n-            TaskParameter t = new TaskParameter(new string[] { \"foo\", \"bar\" });\n+            TypeCode expectedTypeCode = (TypeCode)expectedTypeCodeAsInt;\n \n-            Assert.Equal(TaskParameterType.StringArray, t.ParameterType);\n+            string[] values = testValueAsString.Split(';');\n+            Array array = Array.CreateInstance(type, values.Length);\n+            for (int i = 0; i < values.Length; i++)\n+            {\n+                object value = Convert.ChangeType(values[i], type, CultureInfo.InvariantCulture);\n+                array.SetValue(value, i);\n+            }\n \n-            string[] wrappedParameter = t.WrappedParameter as string[];\n-            Assert.NotNull(wrappedParameter);\n-            Assert.Equal(2, wrappedParameter.Length);\n-            Assert.Equal(\"foo\", wrappedParameter[0]);\n-            Assert.Equal(\"bar\", wrappedParameter[1]);\n+            TaskParameter t = new TaskParameter(array);\n+\n+            Assert.Equal(array, t.WrappedParameter);\n+            Assert.Equal(TaskParameterType.PrimitiveTypeArray, t.ParameterType);\n+            Assert.Equal(expectedTypeCode, t.ParameterTypeCode);\n \n             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());\n             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());\n \n-            Assert.Equal(TaskParameterType.StringArray, t2.ParameterType);\n-\n-            string[] wrappedParameter2 = t2.WrappedParameter as string[];\n-            Assert.NotNull(wrappedParameter2);\n-            Assert.Equal(2, wrappedParameter2.Length);\n-            Assert.Equal(\"foo\", wrappedParameter2[0]);\n-            Assert.Equal(\"bar\", wrappedParameter2[1]);\n+            Assert.Equal(array, t2.WrappedParameter);\n+            Assert.Equal(TaskParameterType.PrimitiveTypeArray, t2.ParameterType);\n+            Assert.Equal(expectedTypeCode, t2.ParameterTypeCode);\n         }\n \n-        /// <summary>\n-        /// Verifies that construction and serialization with a value type (integer) parameter is OK.\n-        /// </summary>\n         [Fact]\n-        public void IntParameter()\n+        public void ValueTypeParameter()\n         {\n-            TaskParameter t = new TaskParameter(1);\n+            TaskBuilderTestTask.CustomStruct value = new TaskBuilderTestTask.CustomStruct(3.14);\n+            TaskParameter t = new TaskParameter(value);\n \n-            Assert.Equal(1, t.WrappedParameter);\n-            Assert.Equal(TaskParameterType.Int, t.ParameterType);\n+            Assert.Equal(value, t.WrappedParameter);\n+            Assert.Equal(TaskParameterType.ValueType, t.ParameterType);\n \n             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());\n             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());\n \n-            Assert.Equal(1, t2.WrappedParameter);\n-            Assert.Equal(TaskParameterType.Int, t2.ParameterType);\n+            // Custom IConvertible structs are deserialized into strings.\n+            Assert.Equal(value.ToString(CultureInfo.InvariantCulture), t2.WrappedParameter);\n+            Assert.Equal(TaskParameterType.ValueType, t2.ParameterType);\n         }\n \n-        /// <summary>\n-        /// Verifies that construction and serialization with a parameter that is an array of value types (ints) is OK.\n-        /// </summary>\n         [Fact]\n-        public void IntArrayParameter()\n+        public void ValueTypeArrayParameter()\n         {\n-            TaskParameter t = new TaskParameter(new int[] { 2, 15 });\n-\n+            TaskBuilderTestTask.CustomStruct[] value = new TaskBuilderTestTask.CustomStruct[]",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "https://github.com/dotnet/runtime/issues/90387",
              "createdAt": "2023-08-11T11:25:11Z",
              "path": "src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs",
              "diffHunk": "@@ -17,228 +17,973 @@ namespace Microsoft.Build.UnitTests.BackEnd\n     /// </summary>\n     public class TaskBuilderTestTask : IGeneratedTask\n     {\n+        /// <summary>\n+        /// A custom <see cref=\"IConvertible\"/> value type.\n+        /// </summary>\n+        /// <remarks>\n+        /// Types like this one can be used only as Output parameter types because they can be converted to string\n+        /// but not from string.\n+        /// </remarks>\n+        [Serializable]\n+        public struct CustomStruct : IConvertible\n+        {\n+            private readonly object _value;\n+\n+            /// <summary>\n+            /// Using <see cref=\"IConvertible\"/> as the type of the <see cref=\"_value\"/> field triggers a BinaryFormatter bug.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: In what case it will legally happen? I mean there is code to Translate all known supported value types. Since there is no `ITranslatable.ToObject` it is not possible to introduce new value type with ITranslatable  roundtrip string de/ser. I this somehow happens (i dont know how thats possible), it will crash on TaskHostNode anyway, so this code is either unreachable or it will cause crash. Please consider `fail-fast` kind of exception here or up in stack.",
              "createdAt": "2023-08-13T20:36:07Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +513,222 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes a primitive type value wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveType(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;\n+                    translator.Translate(ref boolParam);\n+                    _wrappedParameter = boolParam;\n+                    break;\n+\n+                case TypeCode.Byte:\n+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;\n+                    translator.Translate(ref byteParam);\n+                    _wrappedParameter = byteParam;\n+                    break;\n+\n+                case TypeCode.Int16:\n+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;\n+                    translator.Translate(ref shortParam);\n+                    _wrappedParameter = shortParam;\n+                    break;\n+\n+                case TypeCode.UInt16:\n+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;\n+                    translator.Translate(ref ushortParam);\n+                    _wrappedParameter = ushortParam;\n+                    break;\n+\n+                case TypeCode.Int64:\n+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;\n+                    translator.Translate(ref longParam);\n+                    _wrappedParameter = longParam;\n+                    break;\n+\n+                case TypeCode.Double:\n+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;\n+                    translator.Translate(ref doubleParam);\n+                    _wrappedParameter = doubleParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string stringParam = (string)_wrappedParameter;\n+                    translator.Translate(ref stringParam);\n+                    _wrappedParameter = stringParam;\n+                    break;\n+\n+                case TypeCode.DateTime:\n+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;\n+                    translator.Translate(ref dateTimeParam);\n+                    _wrappedParameter = dateTimeParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    string stringValue = null;\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);\n+                    }\n+\n+                    translator.Translate(ref stringValue);\n+\n+                    if (translator.Mode == TranslationDirection.ReadFromStream)\n+                    {\n+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveTypeArray(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool[] boolArrayParam = (bool[])_wrappedParameter;\n+                    translator.Translate(ref boolArrayParam);\n+                    _wrappedParameter = boolArrayParam;\n+                    break;\n+\n+                case TypeCode.Int32:\n+                    int[] intArrayParam = (int[])_wrappedParameter;\n+                    translator.Translate(ref intArrayParam);\n+                    _wrappedParameter = intArrayParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string[] stringArrayParam = (string[])_wrappedParameter;\n+                    translator.Translate(ref stringArrayParam);\n+                    _wrappedParameter = stringArrayParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        Array array = (Array)_wrappedParameter;\n+                        int length = array.Length;\n+\n+                        translator.Translate(ref length);\n+\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                            translator.Translate(ref valueString);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        Type elementType = _parameterTypeCode switch\n+                        {\n+                            TypeCode.Char => typeof(char),\n+                            TypeCode.SByte => typeof(sbyte),\n+                            TypeCode.Byte => typeof(byte),\n+                            TypeCode.Int16 => typeof(short),\n+                            TypeCode.UInt16 => typeof(ushort),\n+                            TypeCode.UInt32 => typeof(uint),\n+                            TypeCode.Int64 => typeof(long),\n+                            TypeCode.UInt64 => typeof(ulong),\n+                            TypeCode.Single => typeof(float),\n+                            TypeCode.Double => typeof(double),\n+                            TypeCode.Decimal => typeof(decimal),\n+                            TypeCode.DateTime => typeof(DateTime),\n+                            _ => throw new NotImplementedException(),\n+                        };\n+\n+                        int length = 0;\n+                        translator.Translate(ref length);\n+\n+                        Array array = Array.CreateInstance(elementType, length);\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = null;\n+                            translator.Translate(ref valueString);\n+                            array.SetValue(Convert.ChangeType(valueString, _parameterTypeCode, CultureInfo.InvariantCulture), i);\n+                        }\n+                        _wrappedParameter = array;\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string valueString = null;\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                valueString = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "This code runs for custom value types used as _output_ parameters. They are serialized in task host and then deserialized to strings in a worker process. Unclear if supporting these types was by design, but not breaking them is relatively cheap so I think I'd prefer to keep this.",
              "createdAt": "2023-08-14T06:43:16Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +513,222 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes a primitive type value wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveType(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;\n+                    translator.Translate(ref boolParam);\n+                    _wrappedParameter = boolParam;\n+                    break;\n+\n+                case TypeCode.Byte:\n+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;\n+                    translator.Translate(ref byteParam);\n+                    _wrappedParameter = byteParam;\n+                    break;\n+\n+                case TypeCode.Int16:\n+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;\n+                    translator.Translate(ref shortParam);\n+                    _wrappedParameter = shortParam;\n+                    break;\n+\n+                case TypeCode.UInt16:\n+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;\n+                    translator.Translate(ref ushortParam);\n+                    _wrappedParameter = ushortParam;\n+                    break;\n+\n+                case TypeCode.Int64:\n+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;\n+                    translator.Translate(ref longParam);\n+                    _wrappedParameter = longParam;\n+                    break;\n+\n+                case TypeCode.Double:\n+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;\n+                    translator.Translate(ref doubleParam);\n+                    _wrappedParameter = doubleParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string stringParam = (string)_wrappedParameter;\n+                    translator.Translate(ref stringParam);\n+                    _wrappedParameter = stringParam;\n+                    break;\n+\n+                case TypeCode.DateTime:\n+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;\n+                    translator.Translate(ref dateTimeParam);\n+                    _wrappedParameter = dateTimeParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    string stringValue = null;\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);\n+                    }\n+\n+                    translator.Translate(ref stringValue);\n+\n+                    if (translator.Mode == TranslationDirection.ReadFromStream)\n+                    {\n+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveTypeArray(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool[] boolArrayParam = (bool[])_wrappedParameter;\n+                    translator.Translate(ref boolArrayParam);\n+                    _wrappedParameter = boolArrayParam;\n+                    break;\n+\n+                case TypeCode.Int32:\n+                    int[] intArrayParam = (int[])_wrappedParameter;\n+                    translator.Translate(ref intArrayParam);\n+                    _wrappedParameter = intArrayParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string[] stringArrayParam = (string[])_wrappedParameter;\n+                    translator.Translate(ref stringArrayParam);\n+                    _wrappedParameter = stringArrayParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        Array array = (Array)_wrappedParameter;\n+                        int length = array.Length;\n+\n+                        translator.Translate(ref length);\n+\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                            translator.Translate(ref valueString);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        Type elementType = _parameterTypeCode switch\n+                        {\n+                            TypeCode.Char => typeof(char),\n+                            TypeCode.SByte => typeof(sbyte),\n+                            TypeCode.Byte => typeof(byte),\n+                            TypeCode.Int16 => typeof(short),\n+                            TypeCode.UInt16 => typeof(ushort),\n+                            TypeCode.UInt32 => typeof(uint),\n+                            TypeCode.Int64 => typeof(long),\n+                            TypeCode.UInt64 => typeof(ulong),\n+                            TypeCode.Single => typeof(float),\n+                            TypeCode.Double => typeof(double),\n+                            TypeCode.Decimal => typeof(decimal),\n+                            TypeCode.DateTime => typeof(DateTime),\n+                            _ => throw new NotImplementedException(),\n+                        };\n+\n+                        int length = 0;\n+                        translator.Translate(ref length);\n+\n+                        Array array = Array.CreateInstance(elementType, length);\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = null;\n+                            translator.Translate(ref valueString);\n+                            array.SetValue(Convert.ChangeType(valueString, _parameterTypeCode, CultureInfo.InvariantCulture), i);\n+                        }\n+                        _wrappedParameter = array;\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string valueString = null;\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                valueString = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I have updated the comment a few lines down in this method - as discussed.",
              "createdAt": "2023-08-14T07:11:19Z",
              "path": "src/Shared/TaskParameter.cs",
              "diffHunk": "@@ -537,6 +513,222 @@ private bool TranslateNullable<T>(ITranslator translator, T value)\n             return haveRef;\n         }\n \n+        /// <summary>\n+        /// Serializes or deserializes a primitive type value wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveType(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;\n+                    translator.Translate(ref boolParam);\n+                    _wrappedParameter = boolParam;\n+                    break;\n+\n+                case TypeCode.Byte:\n+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;\n+                    translator.Translate(ref byteParam);\n+                    _wrappedParameter = byteParam;\n+                    break;\n+\n+                case TypeCode.Int16:\n+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;\n+                    translator.Translate(ref shortParam);\n+                    _wrappedParameter = shortParam;\n+                    break;\n+\n+                case TypeCode.UInt16:\n+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;\n+                    translator.Translate(ref ushortParam);\n+                    _wrappedParameter = ushortParam;\n+                    break;\n+\n+                case TypeCode.Int64:\n+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;\n+                    translator.Translate(ref longParam);\n+                    _wrappedParameter = longParam;\n+                    break;\n+\n+                case TypeCode.Double:\n+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;\n+                    translator.Translate(ref doubleParam);\n+                    _wrappedParameter = doubleParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string stringParam = (string)_wrappedParameter;\n+                    translator.Translate(ref stringParam);\n+                    _wrappedParameter = stringParam;\n+                    break;\n+\n+                case TypeCode.DateTime:\n+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;\n+                    translator.Translate(ref dateTimeParam);\n+                    _wrappedParameter = dateTimeParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    string stringValue = null;\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);\n+                    }\n+\n+                    translator.Translate(ref stringValue);\n+\n+                    if (translator.Mode == TranslationDirection.ReadFromStream)\n+                    {\n+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        private void TranslatePrimitiveTypeArray(ITranslator translator)\n+        {\n+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);\n+\n+            switch (_parameterTypeCode)\n+            {\n+                case TypeCode.Boolean:\n+                    bool[] boolArrayParam = (bool[])_wrappedParameter;\n+                    translator.Translate(ref boolArrayParam);\n+                    _wrappedParameter = boolArrayParam;\n+                    break;\n+\n+                case TypeCode.Int32:\n+                    int[] intArrayParam = (int[])_wrappedParameter;\n+                    translator.Translate(ref intArrayParam);\n+                    _wrappedParameter = intArrayParam;\n+                    break;\n+\n+                case TypeCode.String:\n+                    string[] stringArrayParam = (string[])_wrappedParameter;\n+                    translator.Translate(ref stringArrayParam);\n+                    _wrappedParameter = stringArrayParam;\n+                    break;\n+\n+                default:\n+                    // Fall back to converting to/from string for types that don't have ITranslator support.\n+                    if (translator.Mode == TranslationDirection.WriteToStream)\n+                    {\n+                        Array array = (Array)_wrappedParameter;\n+                        int length = array.Length;\n+\n+                        translator.Translate(ref length);\n+\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);\n+                            translator.Translate(ref valueString);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        Type elementType = _parameterTypeCode switch\n+                        {\n+                            TypeCode.Char => typeof(char),\n+                            TypeCode.SByte => typeof(sbyte),\n+                            TypeCode.Byte => typeof(byte),\n+                            TypeCode.Int16 => typeof(short),\n+                            TypeCode.UInt16 => typeof(ushort),\n+                            TypeCode.UInt32 => typeof(uint),\n+                            TypeCode.Int64 => typeof(long),\n+                            TypeCode.UInt64 => typeof(ulong),\n+                            TypeCode.Single => typeof(float),\n+                            TypeCode.Double => typeof(double),\n+                            TypeCode.Decimal => typeof(decimal),\n+                            TypeCode.DateTime => typeof(DateTime),\n+                            _ => throw new NotImplementedException(),\n+                        };\n+\n+                        int length = 0;\n+                        translator.Translate(ref length);\n+\n+                        Array array = Array.CreateInstance(elementType, length);\n+                        for (int i = 0; i < length; i++)\n+                        {\n+                            string valueString = null;\n+                            translator.Translate(ref valueString);\n+                            array.SetValue(Convert.ChangeType(valueString, _parameterTypeCode, CultureInfo.InvariantCulture), i);\n+                        }\n+                        _wrappedParameter = array;\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Serializes or deserializes the value type instance wrapped by this <see cref=\"TaskParameter\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        /// The value type is converted to/from string using the <see cref=\"Convert\"/> class. Note that we require\n+        /// task parameter types to be <see cref=\"IConvertible\"/> so this conversion is guaranteed to work for parameters\n+        /// that have made it this far.\n+        /// </remarks>\n+        private void TranslateValueType(ITranslator translator)\n+        {\n+            string valueString = null;\n+            if (translator.Mode == TranslationDirection.WriteToStream)\n+            {\n+                valueString = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}