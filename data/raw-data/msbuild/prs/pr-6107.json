{
  "number": 6107,
  "title": "Pre cache",
  "body": "Fixes #5247\r\n\r\n### Context\r\nPermits creating a cache that RAR can use if it can't find the normal on-disk cache.\r\n\r\n### Changes Made\r\n\r\n\r\n### Testing\r\nUnit tests\r\n\r\n### Notes\r\nNot yet manually tested; relies on #6094",
  "state": "MERGED",
  "createdAt": "2021-02-02T02:12:21Z",
  "updatedAt": "2021-03-15T17:12:12Z",
  "closedAt": "2021-03-15T17:12:12Z",
  "mergedAt": "2021-03-15T17:12:12Z",
  "additions": 304,
  "deletions": 8,
  "changedFiles": 19,
  "headRefName": "pre-cache",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "bae7d8e0d565e175b7f281f289333c2b9201e590",
          "message": "Create RAR pre-cache error message",
          "committedDate": "2021-02-25T18:09:06Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5949c208c849928e5d486d046b62f8ae76f4f4b4",
          "message": "Rebase and fix conflicts",
          "committedDate": "2021-02-25T18:10:58Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "539b7a8b2a495e4fc6096643f98a86dab7dcac51",
          "message": "Create tests",
          "committedDate": "2021-02-25T18:17:07Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0f463229cbe21fe85813dad0c2d8524c54f7995a",
          "message": "add easy means to specify paths",
          "committedDate": "2021-02-25T18:19:26Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e4a7fc65f70e50e2bcae536291c7d46e17f2797b",
          "message": "PR feedback",
          "committedDate": "2021-02-25T22:43:08Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a7101f427359457b22d39356bd377217394e2a15",
          "message": "Fix typo",
          "committedDate": "2021-02-25T23:00:05Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5d2ffed0808a3369911b9731013853015e308fc5",
          "message": "PR comments",
          "committedDate": "2021-03-04T00:38:41Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d2a96023f64f952b306c874665869ccc8067303b",
          "message": "Mark isDirty private",
          "committedDate": "2021-03-05T16:47:28Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9a8c40751d853e89d8366c08ff24f49e0c2ddff9",
          "message": "Merge branch 'master' into pre-cache",
          "committedDate": "2021-03-15T16:27:50Z",
          "author": {
            "name": "Forgind",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Few notes:\r\nThe latest commit claims that I just pulled in the latest version of @rokonec's branch. Actually, I did that then changed and saved the change to accept somewhat incorrect timestamps before I realized I hadn't committed the merge yet, so it's a little messy. Sorry \ud83d\ude1e\r\nAfter looking at it a little more, I don't think I can easily have a separate path to being \"checked\" for the precomputed cache and the normal cache except at the deserialization stage, since the precomputed cache, to put it more accurately, prefills the standard cache. Having a third cache just for the precomputed version would add more complexity to the change and make serializing caches more complicated.\r\nAlso, in PR Reviews, it was brought up that this might be bad for small projects if they get a lot more in their cache than they'd expected. That's true, but it occurred to me that you can always just make more than one cache based on what you think the relevant assemblies are, so if you're making projectType1, perhaps you bring in caches 1, 4, and 5, whereas for projectType2, you bring in caches 3, 5, and 6. That way, you can split the SDK up into user-relevant buckets. Note that that would increase complexity for whoever makes the caches, but I think that's unavoidable.",
        "createdAt": "2021-02-08T21:51:54Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you really want to modify `instanceLocalFileStateCache`? Is it possible that RAR will be yielding wrong results after the paths have been relativized?\r\n\r\nIf the answer is yes and this is safe, consider simply modifying `instanceLocalFileStateCache` instead of creating a new dictionary.\r\n\r\nOtherwise, consider the `ToDictionary()` extension method to do the mapping.",
              "createdAt": "2021-02-22T15:07:41Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -562,6 +626,69 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns></returns>\n+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile. Log message but do not error if not.\n+                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                            assembliesFound.Add(relativePath);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to filePath.\n+        /// </summary>\n+        /// <param name=\"stateFile\">Path to which to write the precomputed cache</param>\n+        /// <param name=\"log\">How to log</param>\n+        internal void SerializePrecomputedCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);\n+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)\n+            {\n+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key);\n+                newInstanceLocalFileStateCache[relativePath] = kvp.Value;\n+            }\n+            instanceLocalFileStateCache = newInstanceLocalFileStateCache;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Nope! You're right. I did this weird logic specifically so I could temporarily modify instanceLocalFileStateCache (to make it more accessible to SerializeCacheByTranslator) but then neglected to change it back. Fixed, thanks!",
              "createdAt": "2021-02-25T22:30:52Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -562,6 +626,69 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns></returns>\n+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile. Log message but do not error if not.\n+                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                            assembliesFound.Add(relativePath);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to filePath.\n+        /// </summary>\n+        /// <param name=\"stateFile\">Path to which to write the precomputed cache</param>\n+        /// <param name=\"log\">How to log</param>\n+        internal void SerializePrecomputedCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);\n+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)\n+            {\n+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key);\n+                newInstanceLocalFileStateCache[relativePath] = kvp.Value;\n+            }\n+            instanceLocalFileStateCache = newInstanceLocalFileStateCache;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Thank you. nit: Still wondering if calling `ToDictionary` wouldn't look slightly nicer. It's basically a concise way of expressing the mapping from one collection (in this case a dictionary) to a new dictionary.",
              "createdAt": "2021-03-03T21:57:17Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -562,6 +626,69 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns></returns>\n+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile. Log message but do not error if not.\n+                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                            assembliesFound.Add(relativePath);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to filePath.\n+        /// </summary>\n+        /// <param name=\"stateFile\">Path to which to write the precomputed cache</param>\n+        /// <param name=\"log\">How to log</param>\n+        internal void SerializePrecomputedCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);\n+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)\n+            {\n+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key);\n+                newInstanceLocalFileStateCache[relativePath] = kvp.Value;\n+            }\n+            instanceLocalFileStateCache = newInstanceLocalFileStateCache;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I had initially thought of this as more performant, but that doesn't really matter for a case like this, and you're right\u2014it does look a lot cleaner. Fixed, thanks!",
              "createdAt": "2021-03-04T00:40:02Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -562,6 +626,69 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns></returns>\n+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile. Log message but do not error if not.\n+                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                            assembliesFound.Add(relativePath);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to filePath.\n+        /// </summary>\n+        /// <param name=\"stateFile\">Path to which to write the precomputed cache</param>\n+        /// <param name=\"log\">How to log</param>\n+        internal void SerializePrecomputedCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);\n+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)\n+            {\n+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key);\n+                newInstanceLocalFileStateCache[relativePath] = kvp.Value;\n+            }\n+            instanceLocalFileStateCache = newInstanceLocalFileStateCache;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n            if (_cache == null && AssemblyInformationCachePaths != null)\r\n```\r\n?\r\n\r\nCalling `DeserializePrecomputedCachesByTranslator` if there are no precomputed caches looks a bit unexpected.",
              "createdAt": "2021-02-22T15:15:06Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1884,25 +1884,29 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n         /// <summary>\n         /// Reads the state file (if present) into the cache.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(FileExists fileExists)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n+            _cache = SystemState.DeserializeCacheByTranslator(_stateFile, Log);\n \n             // Construct the cache if necessary.\n             if (_cache == null)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: `string` (lower-case) for consistency.",
              "createdAt": "2021-02-22T15:18:42Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1884,25 +1884,29 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l\n         /// <summary>\n         /// Reads the state file (if present) into the cache.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(FileExists fileExists)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n+            _cache = SystemState.DeserializeCacheByTranslator(_stateFile, Log);\n \n             // Construct the cache if necessary.\n             if (_cache == null)\n             {\n-                _cache = new SystemState();\n+                _cache = SystemState.DeserializePrecomputedCachesByTranslator(AssemblyInformationCachePaths ?? Array.Empty<ITaskItem>(), Log, fileExists);\n             }\n         }\n \n         /// <summary>\n         /// Write out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile()\n         {\n-            if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n+            if (!String.IsNullOrEmpty(AssemblyInformationCacheOutputPath))",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How hard would it be to not rely on the current directory (as used in `Path.GetFullPath`) here? We'll soon need to find and fix all places like this to make RAR multithreaded so ideally we wouldn't be introducing more. cc @AR-May ",
              "createdAt": "2021-03-03T21:51:26Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -596,6 +606,74 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns></returns>\n+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile. Log message but do not error if not.\n+                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "This shouldn't actually be relying on the current directory because stateFile should be a full path, so it would effectively be:\r\nFind the path like (current directory) -> C:\\Users\\Forgind\\...\r\n\r\nI only included that to weed out things like folder1\\..\\folder1.",
              "createdAt": "2021-03-03T23:46:38Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -596,6 +606,74 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns></returns>\n+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile. Log message but do not error if not.\n+                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Missing return value comment.",
              "createdAt": "2021-03-03T21:51:49Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -596,6 +606,74 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns></returns>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Put this statement in a `finally` block to make sure it's executed even if `SerializeCacheByTranslator` throws?",
              "createdAt": "2021-03-03T21:54:04Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -596,6 +606,74 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns></returns>\n+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile. Log message but do not error if not.\n+                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                            assembliesFound.Add(relativePath);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to filePath.\n+        /// </summary>\n+        /// <param name=\"stateFile\">Path to which to write the precomputed cache</param>\n+        /// <param name=\"log\">How to log</param>\n+        internal void SerializePrecomputedCacheByTranslator(string stateFile, TaskLoggingHelper log)\n+        {\n+            // Save a copy of instanceLocalFileStateCache so we can restore it later. SerializeCacheByTranslator serializes\n+            // instanceLocalFileStateCache by default, so change that to the relativized form, then change it back.\n+            Dictionary<string, FileState> oldFileStateCache = instanceLocalFileStateCache;\n+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);\n+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)\n+            {\n+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key);\n+                newInstanceLocalFileStateCache[relativePath] = kvp.Value;\n+            }\n+            instanceLocalFileStateCache = newInstanceLocalFileStateCache;\n+\n+            if (FileUtilities.FileExistsNoThrow(stateFile))\n+            {\n+                log.LogWarningWithCodeFromResources(\"General.StateFileAlreadyPresent\", stateFile);\n+            }\n+            SerializeCacheByTranslator(stateFile, log);\n+\n+            instanceLocalFileStateCache = oldFileStateCache;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: What if `stateFiles` is not empty but `DeserializeCacheByTranslator` returns `null` so we end up with an empty `retVal`? Is it still considered dirty?",
              "createdAt": "2021-03-03T21:59:46Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -596,6 +606,74 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns></returns>\n+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.isDirty = stateFiles.Length > 0;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "isDirty shouldn't matter at this point in almost any case, since we'd presumably modify the cache before considering serializing it anyway unless there really is nothing of interest. I actually slightly prefer this version, since if there are invalid caches, we won't try repeatedly to read something invalid, instead reading something empty, which is less computationally expensive.",
              "createdAt": "2021-03-04T00:20:40Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -596,6 +606,74 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns></returns>\n+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.isDirty = stateFiles.Length > 0;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Still need `internal` access? Isn't it a left-over from when the cache was Json-serialized? Same for the other `private` -> `internal` changes.",
              "createdAt": "2021-03-03T22:01:46Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -71,7 +72,7 @@ internal sealed class SystemState : StateFileBase, ITranslatable\n         /// <summary>\n         /// True if the contents have changed.\n         /// </summary>\n-        private bool isDirty;\n+        internal bool isDirty;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Actually, this (and others) were for testing so I could make a cache and serialize it without modifying it or actually executing RAR.",
              "createdAt": "2021-03-03T23:47:46Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -71,7 +72,7 @@ internal sealed class SystemState : StateFileBase, ITranslatable\n         /// <summary>\n         /// True if the contents have changed.\n         /// </summary>\n-        private bool isDirty;\n+        internal bool isDirty;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Gotcha. This one can be private, though, as it has an internal read/write property, is that correct?",
              "createdAt": "2021-03-04T09:33:37Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -71,7 +72,7 @@ internal sealed class SystemState : StateFileBase, ITranslatable\n         /// <summary>\n         /// True if the contents have changed.\n         /// </summary>\n-        private bool isDirty;\n+        internal bool isDirty;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Yep! You're right. I added the write part of that property, so it seems I gave myself one way to access it, forgot, and gave myself a second way to access it. Fixed!",
              "createdAt": "2021-03-05T16:40:33Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -71,7 +72,7 @@ internal sealed class SystemState : StateFileBase, ITranslatable\n         /// <summary>\n         /// True if the contents have changed.\n         /// </summary>\n-        private bool isDirty;\n+        internal bool isDirty;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Worth logging a warning if this assembly has been seen before? Or is the expectation that there will be conflicts and the user needs to put the more important files first? If that's the case hopefully it's documented somewhere.",
              "createdAt": "2021-03-04T01:45:02Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -596,6 +606,73 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns>A cache representing key aspects of file states.</returns>\n+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile. Log message but do not error if not.\n+                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "There may be conflicts if, say, two precomputed caches are created (and used) that both include My.Assembly.dll.\r\n\r\nIt shouldn't be a problem, however, because there should only be one assembly at that relative path, so it should have identical data from each. The original version of this verified that via an mvid check; I since simplified it, so theoretically someone could put incorrect information into their cache and prevent correct information from being read in, but that's just an error with the first cache rather than anything about ordering, and it doesn't break the build or anything, just making your build slightly longer. Given the above, I'd prefer to leave it as-is.",
              "createdAt": "2021-03-05T16:45:40Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -596,6 +606,73 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n+        /// <summary>\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n+        /// </summary>\n+        /// <param name=\"stateFiles\">List of locations of caches on disk.</param>\n+        /// <param name=\"log\">How to log</param>\n+        /// <param name=\"fileExists\">Whether a file exists</param>\n+        /// <returns>A cache representing key aspects of file states.</returns>\n+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile. Log message but do not error if not.\n+                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}