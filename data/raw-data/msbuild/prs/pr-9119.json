{
  "number": 9119,
  "title": "Terminal logger enablement by /tlp:default and related telemetry",
  "body": "Fixes part of #9063\r\n\r\n### Context\r\nSee #9063 for requirements.\r\nThis PR address changes in msbuild only. SDK changes will be in different PR. This PRs are independent and could be merged in any order.\r\n\r\n### Changes Made\r\n- introduce /tlp:default={true|false|auto} to signalize what is SDK intent of default behavior. Such default will achieve requirements of overriding default by user intent (arguments, env vars, rsp files)\r\n- introduced `LoggingConfigurationTelemetry` containing info about logger settings\r\n\r\n### Testing\r\n- locally\r\n- existing and new unit tests\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2023-08-10T14:09:44Z",
  "updatedAt": "2023-08-16T15:29:23Z",
  "closedAt": "2023-08-16T15:29:23Z",
  "mergedAt": "2023-08-16T15:29:23Z",
  "additions": 878,
  "deletions": 52,
  "changedFiles": 26,
  "headRefName": "rokonec/9063-skd-tl-defaults",
  "isDraft": false,
  "author": {
    "login": "rokonec"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "a77f8d536942acb3760cd1aadf766711b8c6957e",
          "message": "Default terminal behavior by /tlp",
          "committedDate": "2023-08-10T13:59:08Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "638417dd9b9ef98bde14cb2c8c174b15e58cef52",
          "message": "macos unit test failure hunting",
          "committedDate": "2023-08-11T11:29:09Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "84aca1c555f21bfdda03f9f52fef031093685ad5",
          "message": "Hunting macos tests mk2",
          "committedDate": "2023-08-11T13:50:22Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1c39abbdcc4c0d291855d3d1f38294dcb39c84b8",
          "message": "Fix flaky unit tests",
          "committedDate": "2023-08-11T14:30:02Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "22d080eaad14a5cda919151e3a4068f21e1a0489",
          "message": "Refactor for readability.\nEnsure Ansi Color Codes are enabled even for /tl:true",
          "committedDate": "2023-08-11T15:59:46Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1de7e109b0a22b81d04b37f33481bde1808b90b2",
          "message": "Minor changes",
          "committedDate": "2023-08-11T16:07:17Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "54c74bf30ae2f161a453e66b5409dc5f2c64c3d2",
          "message": "Enable ansi colors only when forced to tl.",
          "committedDate": "2023-08-15T09:01:12Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aee4edaae55825dd7476a211a1ed996a3ff47c61",
          "message": "Typos",
          "committedDate": "2023-08-15T09:01:35Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5a6729c25ee89fe9d2eef643e123c15bdfd9573a",
          "message": "Rename method to signal side effects",
          "committedDate": "2023-08-15T09:04:23Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5ac0c15b4e84bfbc52b54c046c4dfe02b6adf3d",
          "message": "Renaming SDK CLI env var",
          "committedDate": "2023-08-15T21:59:39Z",
          "author": {
            "name": "Roman Konecny",
            "email": "rokonecn@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "consider implementing the disposable pattern as follows...\r\nhttps://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose",
              "createdAt": "2023-08-10T15:46:50Z",
              "path": "src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs",
              "diffHunk": "@@ -0,0 +1,231 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework.Telemetry;\n+using Microsoft.Build.UnitTests.Shared;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests;\n+\n+/// <summary>\n+/// End to end tests for the terminal logger configuration.\n+/// We need to execute msbuild process as tested code path is also in XMake.cs.\n+/// Also verifies that the telemetry is logged correctly.\n+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.\n+/// </summary>\n+public class TerminalLoggerConfiguration_Tests : IDisposable\n+{\n+    private readonly TestEnvironment _env;\n+\n+    private readonly string _cmd;\n+\n+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)\n+    {\n+        _env = TestEnvironment.Create(output);\n+\n+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);\n+        TransientTestFile projectFile = _env.CreateFile(logFolder, \"myProj.proj\", $\"\"\"\n+            <Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" DefaultTargets=\"Hello\">\n+                <Target Name=\"Hello\">\n+                  <Message Text=\"Hello, world!\" />\n+                </Target>\n+            </Project>\n+            \"\"\");\n+        _cmd = $\"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry\";\n+    }\n+\n+    /// <summary>\n+    /// TearDown\n+    /// </summary>\n+    public void Dispose()",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "It is class test fixture implementation. Coded by xUnit best practices: https://xunit.net/docs/shared-context",
              "createdAt": "2023-08-11T14:39:44Z",
              "path": "src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs",
              "diffHunk": "@@ -0,0 +1,231 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework.Telemetry;\n+using Microsoft.Build.UnitTests.Shared;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests;\n+\n+/// <summary>\n+/// End to end tests for the terminal logger configuration.\n+/// We need to execute msbuild process as tested code path is also in XMake.cs.\n+/// Also verifies that the telemetry is logged correctly.\n+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.\n+/// </summary>\n+public class TerminalLoggerConfiguration_Tests : IDisposable\n+{\n+    private readonly TestEnvironment _env;\n+\n+    private readonly string _cmd;\n+\n+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)\n+    {\n+        _env = TestEnvironment.Create(output);\n+\n+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);\n+        TransientTestFile projectFile = _env.CreateFile(logFolder, \"myProj.proj\", $\"\"\"\n+            <Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" DefaultTargets=\"Hello\">\n+                <Target Name=\"Hello\">\n+                  <Message Text=\"Hello, world!\" />\n+                </Target>\n+            </Project>\n+            \"\"\");\n+        _cmd = $\"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry\";\n+    }\n+\n+    /// <summary>\n+    /// TearDown\n+    /// </summary>\n+    public void Dispose()",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: consider a reusable construction utility for `LoggingConfigurationTelemetry` instances.",
              "createdAt": "2023-08-10T15:49:40Z",
              "path": "src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs",
              "diffHunk": "@@ -0,0 +1,231 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework.Telemetry;\n+using Microsoft.Build.UnitTests.Shared;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests;\n+\n+/// <summary>\n+/// End to end tests for the terminal logger configuration.\n+/// We need to execute msbuild process as tested code path is also in XMake.cs.\n+/// Also verifies that the telemetry is logged correctly.\n+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.\n+/// </summary>\n+public class TerminalLoggerConfiguration_Tests : IDisposable\n+{\n+    private readonly TestEnvironment _env;\n+\n+    private readonly string _cmd;\n+\n+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)\n+    {\n+        _env = TestEnvironment.Create(output);\n+\n+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);\n+        TransientTestFile projectFile = _env.CreateFile(logFolder, \"myProj.proj\", $\"\"\"\n+            <Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" DefaultTargets=\"Hello\">\n+                <Target Name=\"Hello\">\n+                  <Message Text=\"Hello, world!\" />\n+                </Target>\n+            </Project>\n+            \"\"\");\n+        _cmd = $\"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry\";\n+    }\n+\n+    /// <summary>\n+    /// TearDown\n+    /// </summary>\n+    public void Dispose()\n+    {\n+        _env.Dispose();\n+    }\n+\n+    [Theory]\n+    [InlineData(\"on\")]\n+    [InlineData(\"true\")]\n+    public void TerminalLoggerOn(string tlValue)\n+    {\n+        string output = RunnerUtilities.ExecMSBuild($\"{_cmd} -tl:{tlValue}\", out bool success);\n+        success.ShouldBeTrue();\n+\n+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry\n+        {\n+            TerminalLogger = true,\n+            TerminalLoggerDefault = bool.FalseString,\n+            TerminalLoggerDefaultSource = \"msbuild\",\n+            TerminalLoggerUserIntent = tlValue,\n+            TerminalLoggerUserIntentSource = \"arg\",\n+            ConsoleLogger = false,\n+            FileLogger = false,\n+        };\n+\n+        expectedTelemetry.UpdateEventProperties();\n+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)\n+        {\n+            output.ShouldContain($\"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}\");\n+        }\n+\n+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.\n+        ShouldBeTerminalLog(output);\n+    }\n+\n+    [Theory]\n+    [InlineData(\"\")]\n+    [InlineData(\"auto\")]\n+    public void TerminalLoggerWithTlAutoIsOff(string tlValue)\n+    {\n+        string output = RunnerUtilities.ExecMSBuild($\"{_cmd} -tl:{tlValue}\", out bool success);\n+        success.ShouldBeTrue();\n+\n+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry\n+        {",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Although it looks like instances are very similar, I prefer to inline what are expected values.",
              "createdAt": "2023-08-11T14:42:17Z",
              "path": "src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs",
              "diffHunk": "@@ -0,0 +1,231 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework.Telemetry;\n+using Microsoft.Build.UnitTests.Shared;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests;\n+\n+/// <summary>\n+/// End to end tests for the terminal logger configuration.\n+/// We need to execute msbuild process as tested code path is also in XMake.cs.\n+/// Also verifies that the telemetry is logged correctly.\n+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.\n+/// </summary>\n+public class TerminalLoggerConfiguration_Tests : IDisposable\n+{\n+    private readonly TestEnvironment _env;\n+\n+    private readonly string _cmd;\n+\n+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)\n+    {\n+        _env = TestEnvironment.Create(output);\n+\n+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);\n+        TransientTestFile projectFile = _env.CreateFile(logFolder, \"myProj.proj\", $\"\"\"\n+            <Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" DefaultTargets=\"Hello\">\n+                <Target Name=\"Hello\">\n+                  <Message Text=\"Hello, world!\" />\n+                </Target>\n+            </Project>\n+            \"\"\");\n+        _cmd = $\"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry\";\n+    }\n+\n+    /// <summary>\n+    /// TearDown\n+    /// </summary>\n+    public void Dispose()\n+    {\n+        _env.Dispose();\n+    }\n+\n+    [Theory]\n+    [InlineData(\"on\")]\n+    [InlineData(\"true\")]\n+    public void TerminalLoggerOn(string tlValue)\n+    {\n+        string output = RunnerUtilities.ExecMSBuild($\"{_cmd} -tl:{tlValue}\", out bool success);\n+        success.ShouldBeTrue();\n+\n+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry\n+        {\n+            TerminalLogger = true,\n+            TerminalLoggerDefault = bool.FalseString,\n+            TerminalLoggerDefaultSource = \"msbuild\",\n+            TerminalLoggerUserIntent = tlValue,\n+            TerminalLoggerUserIntentSource = \"arg\",\n+            ConsoleLogger = false,\n+            FileLogger = false,\n+        };\n+\n+        expectedTelemetry.UpdateEventProperties();\n+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)\n+        {\n+            output.ShouldContain($\"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}\");\n+        }\n+\n+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.\n+        ShouldBeTerminalLog(output);\n+    }\n+\n+    [Theory]\n+    [InlineData(\"\")]\n+    [InlineData(\"auto\")]\n+    public void TerminalLoggerWithTlAutoIsOff(string tlValue)\n+    {\n+        string output = RunnerUtilities.ExecMSBuild($\"{_cmd} -tl:{tlValue}\", out bool success);\n+        success.ShouldBeTrue();\n+\n+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry\n+        {",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: is there an opportunity to build a prototype method for the behavior repeated in most test cases here?\r\n- setting ENV vars\r\n- calling RunnerUtilities.ExecMSBuild & trapping its' output",
              "createdAt": "2023-08-10T15:52:05Z",
              "path": "src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs",
              "diffHunk": "@@ -0,0 +1,231 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework.Telemetry;\n+using Microsoft.Build.UnitTests.Shared;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests;\n+\n+/// <summary>\n+/// End to end tests for the terminal logger configuration.\n+/// We need to execute msbuild process as tested code path is also in XMake.cs.\n+/// Also verifies that the telemetry is logged correctly.\n+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.\n+/// </summary>\n+public class TerminalLoggerConfiguration_Tests : IDisposable\n+{\n+    private readonly TestEnvironment _env;\n+\n+    private readonly string _cmd;\n+\n+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)\n+    {\n+        _env = TestEnvironment.Create(output);\n+\n+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);\n+        TransientTestFile projectFile = _env.CreateFile(logFolder, \"myProj.proj\", $\"\"\"\n+            <Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" DefaultTargets=\"Hello\">\n+                <Target Name=\"Hello\">\n+                  <Message Text=\"Hello, world!\" />\n+                </Target>\n+            </Project>\n+            \"\"\");\n+        _cmd = $\"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry\";\n+    }\n+\n+    /// <summary>\n+    /// TearDown\n+    /// </summary>\n+    public void Dispose()\n+    {\n+        _env.Dispose();\n+    }\n+\n+    [Theory]\n+    [InlineData(\"on\")]\n+    [InlineData(\"true\")]\n+    public void TerminalLoggerOn(string tlValue)\n+    {\n+        string output = RunnerUtilities.ExecMSBuild($\"{_cmd} -tl:{tlValue}\", out bool success);\n+        success.ShouldBeTrue();\n+\n+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry\n+        {\n+            TerminalLogger = true,\n+            TerminalLoggerDefault = bool.FalseString,\n+            TerminalLoggerDefaultSource = \"msbuild\",\n+            TerminalLoggerUserIntent = tlValue,\n+            TerminalLoggerUserIntentSource = \"arg\",\n+            ConsoleLogger = false,\n+            FileLogger = false,\n+        };\n+\n+        expectedTelemetry.UpdateEventProperties();\n+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)\n+        {\n+            output.ShouldContain($\"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}\");\n+        }\n+\n+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.\n+        ShouldBeTerminalLog(output);\n+    }\n+\n+    [Theory]\n+    [InlineData(\"\")]\n+    [InlineData(\"auto\")]\n+    public void TerminalLoggerWithTlAutoIsOff(string tlValue)\n+    {\n+        string output = RunnerUtilities.ExecMSBuild($\"{_cmd} -tl:{tlValue}\", out bool success);\n+        success.ShouldBeTrue();\n+\n+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry\n+        {\n+            TerminalLogger = false,\n+            TerminalLoggerDefault = bool.FalseString,\n+            TerminalLoggerDefaultSource = \"msbuild\",\n+            TerminalLoggerUserIntent = tlValue,\n+            TerminalLoggerUserIntentSource = \"arg\",\n+            ConsoleLogger = true,\n+            ConsoleLoggerType = \"parallel\",\n+            ConsoleLoggerVerbosity = \"normal\",\n+            FileLogger = false,\n+        };\n+\n+        expectedTelemetry.UpdateEventProperties();\n+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)\n+        {\n+            output.ShouldContain($\"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}\");\n+        }\n+\n+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.\n+        ShouldNotBeTerminalLog(output);\n+    }\n+\n+\n+    [Fact]\n+    public void TerminalLoggerDefaultByEnv()\n+    {\n+        _env.SetEnvironmentVariable(\"DOTNET_CLI_BUILD_TERMINAL_LOGGER\", bool.TrueString);\n+        string output = RunnerUtilities.ExecMSBuild($\"{_cmd} -tlp:default={bool.TrueString}\", out bool success);\n+        success.ShouldBeTrue();\n+\n+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry\n+        {\n+            TerminalLogger = true,\n+            TerminalLoggerDefault = bool.TrueString,\n+            TerminalLoggerDefaultSource = \"DOTNET_CLI_BUILD_TERMINAL_LOGGER\",\n+            TerminalLoggerUserIntent = null,\n+            TerminalLoggerUserIntentSource = null,\n+            ConsoleLogger = false,\n+            FileLogger = false,\n+        };\n+\n+        expectedTelemetry.UpdateEventProperties();\n+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)\n+        {\n+            output.ShouldContain($\"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}\");\n+        }\n+\n+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.\n+        ShouldBeTerminalLog(output);\n+    }\n+\n+    [Theory]\n+    [InlineData(\"MSBUILDLIVELOGGER\")]\n+    [InlineData(\"MSBUILDTERMINALLOGGER\")]\n+    public void TerminalLoggerOnByEnv(string envVarSource)\n+    {\n+        _env.SetEnvironmentVariable(envVarSource, bool.TrueString);",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "I believe it would not make thing any better. We would have to add at least two arguments into ExecMSBuild so we will end up with:\r\n```\r\nRunnerUtilities.ExecMSBuild(\r\n   _env,\r\n   \"ENVVAR1\",\r\n   envVar1Value,\r\n   msbuildcmd,\r\n   out success);\r\n```\r\nas oppose to curent\r\n```\r\n_env.SetEnvironmentVariable(envVarSource, bool.TrueString);\r\nRunnerUtilities.ExecMSBuild(msbuildcmd, out success);\r\n```\r\n\r\n",
              "createdAt": "2023-08-11T14:48:33Z",
              "path": "src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs",
              "diffHunk": "@@ -0,0 +1,231 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework.Telemetry;\n+using Microsoft.Build.UnitTests.Shared;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests;\n+\n+/// <summary>\n+/// End to end tests for the terminal logger configuration.\n+/// We need to execute msbuild process as tested code path is also in XMake.cs.\n+/// Also verifies that the telemetry is logged correctly.\n+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.\n+/// </summary>\n+public class TerminalLoggerConfiguration_Tests : IDisposable\n+{\n+    private readonly TestEnvironment _env;\n+\n+    private readonly string _cmd;\n+\n+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)\n+    {\n+        _env = TestEnvironment.Create(output);\n+\n+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);\n+        TransientTestFile projectFile = _env.CreateFile(logFolder, \"myProj.proj\", $\"\"\"\n+            <Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" DefaultTargets=\"Hello\">\n+                <Target Name=\"Hello\">\n+                  <Message Text=\"Hello, world!\" />\n+                </Target>\n+            </Project>\n+            \"\"\");\n+        _cmd = $\"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry\";\n+    }\n+\n+    /// <summary>\n+    /// TearDown\n+    /// </summary>\n+    public void Dispose()\n+    {\n+        _env.Dispose();\n+    }\n+\n+    [Theory]\n+    [InlineData(\"on\")]\n+    [InlineData(\"true\")]\n+    public void TerminalLoggerOn(string tlValue)\n+    {\n+        string output = RunnerUtilities.ExecMSBuild($\"{_cmd} -tl:{tlValue}\", out bool success);\n+        success.ShouldBeTrue();\n+\n+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry\n+        {\n+            TerminalLogger = true,\n+            TerminalLoggerDefault = bool.FalseString,\n+            TerminalLoggerDefaultSource = \"msbuild\",\n+            TerminalLoggerUserIntent = tlValue,\n+            TerminalLoggerUserIntentSource = \"arg\",\n+            ConsoleLogger = false,\n+            FileLogger = false,\n+        };\n+\n+        expectedTelemetry.UpdateEventProperties();\n+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)\n+        {\n+            output.ShouldContain($\"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}\");\n+        }\n+\n+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.\n+        ShouldBeTerminalLog(output);\n+    }\n+\n+    [Theory]\n+    [InlineData(\"\")]\n+    [InlineData(\"auto\")]\n+    public void TerminalLoggerWithTlAutoIsOff(string tlValue)\n+    {\n+        string output = RunnerUtilities.ExecMSBuild($\"{_cmd} -tl:{tlValue}\", out bool success);\n+        success.ShouldBeTrue();\n+\n+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry\n+        {\n+            TerminalLogger = false,\n+            TerminalLoggerDefault = bool.FalseString,\n+            TerminalLoggerDefaultSource = \"msbuild\",\n+            TerminalLoggerUserIntent = tlValue,\n+            TerminalLoggerUserIntentSource = \"arg\",\n+            ConsoleLogger = true,\n+            ConsoleLoggerType = \"parallel\",\n+            ConsoleLoggerVerbosity = \"normal\",\n+            FileLogger = false,\n+        };\n+\n+        expectedTelemetry.UpdateEventProperties();\n+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)\n+        {\n+            output.ShouldContain($\"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}\");\n+        }\n+\n+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.\n+        ShouldNotBeTerminalLog(output);\n+    }\n+\n+\n+    [Fact]\n+    public void TerminalLoggerDefaultByEnv()\n+    {\n+        _env.SetEnvironmentVariable(\"DOTNET_CLI_BUILD_TERMINAL_LOGGER\", bool.TrueString);\n+        string output = RunnerUtilities.ExecMSBuild($\"{_cmd} -tlp:default={bool.TrueString}\", out bool success);\n+        success.ShouldBeTrue();\n+\n+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry\n+        {\n+            TerminalLogger = true,\n+            TerminalLoggerDefault = bool.TrueString,\n+            TerminalLoggerDefaultSource = \"DOTNET_CLI_BUILD_TERMINAL_LOGGER\",\n+            TerminalLoggerUserIntent = null,\n+            TerminalLoggerUserIntentSource = null,\n+            ConsoleLogger = false,\n+            FileLogger = false,\n+        };\n+\n+        expectedTelemetry.UpdateEventProperties();\n+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)\n+        {\n+            output.ShouldContain($\"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}\");\n+        }\n+\n+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.\n+        ShouldBeTerminalLog(output);\n+    }\n+\n+    [Theory]\n+    [InlineData(\"MSBUILDLIVELOGGER\")]\n+    [InlineData(\"MSBUILDTERMINALLOGGER\")]\n+    public void TerminalLoggerOnByEnv(string envVarSource)\n+    {\n+        _env.SetEnvironmentVariable(envVarSource, bool.TrueString);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: consider a constant for \"msbuild.binlog\";",
              "createdAt": "2023-08-10T15:53:33Z",
              "path": "src/Build/Logging/BinaryLogger/BinaryLogger.cs",
              "diffHunk": "@@ -356,6 +359,7 @@ private void ProcessParameters()\n             {\n                 FilePath = \"msbuild.binlog\";\n             }\n+            KnownTelemetry.LoggingConfigurationTelemetry.BinaryLoggerUsedDefaultName = FilePath == \"msbuild.binlog\";",
              "author": {
                "login": "donJoseLuis"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: any need to protect FileLoggersCount from concurrency concerns?",
              "createdAt": "2023-08-10T15:56:11Z",
              "path": "src/Build/Logging/FileLogger.cs",
              "diffHunk": "@@ -87,6 +88,9 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)\n             // Finally, ask the base console logger class to initialize. It may\n             // want to make decisions based on our verbosity, so we do this last.\n             base.Initialize(eventSource, nodeCount);\n+            KnownTelemetry.LoggingConfigurationTelemetry.FileLoggersCount++;",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Nope. Initialization of loggers is done in single thread during application bootstraping.",
              "createdAt": "2023-08-11T14:49:36Z",
              "path": "src/Build/Logging/FileLogger.cs",
              "diffHunk": "@@ -87,6 +88,9 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)\n             // Finally, ask the base console logger class to initialize. It may\n             // want to make decisions based on our verbosity, so we do this last.\n             base.Initialize(eventSource, nodeCount);\n+            KnownTelemetry.LoggingConfigurationTelemetry.FileLoggersCount++;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "line 2532 used `string.IsNullOrWhiteSpace()` consider homogeneity unless there are specific reasons to use both.",
              "createdAt": "2023-08-10T16:01:58Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2514,10 +2515,46 @@ private static bool GatherAutoResponseFileSwitchesFromFullPath(string autoRespon\n             return invokeBuild;\n         }\n \n-        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches)\n+        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)\n         {\n             string terminalloggerArg;\n \n+            string[] terminalLoggerParameters = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.TerminalLoggerParameters];\n+            aggregatedParameters = terminalLoggerParameters?.Length > 0 ?\n+                AggregateParameters(string.Empty, terminalLoggerParameters) :\n+                string.Empty;\n+\n+            // Find default configuration so it is part of telemetry even when default is not used.\n+            // Default can be stored in /tlp:default=true|false|on|off|auto\n+            string defaultValue = null;\n+            foreach (string parameter in aggregatedParameters.Split(MSBuildConstants.SemicolonChar))\n+            {\n+                if (string.IsNullOrWhiteSpace(parameter))\n+                {\n+                    continue;\n+                }\n+\n+                string[] parameterAndValue = parameter.Split(MSBuildConstants.EqualsChar);\n+                if (parameterAndValue[0].Equals(\"DEFAULT\", StringComparison.InvariantCultureIgnoreCase) && parameterAndValue.Length > 1)\n+                {\n+                    defaultValue = parameterAndValue[1];\n+                }\n+            }\n+\n+            if (defaultValue == null)\n+            {\n+                defaultValue = bool.FalseString;\n+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefault = bool.FalseString;\n+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefaultSource = \"msbuild\";\n+            }\n+            else\n+            {\n+                // Lets check DOTNET CLI env var\n+                string dotnetCliEnvVar = Environment.GetEnvironmentVariable(\"DOTNET_CLI_BUILD_TERMINAL_LOGGER\");\n+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefault = defaultValue;\n+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefaultSource = string.IsNullOrEmpty(dotnetCliEnvVar) ? \"sdk\" : \"DOTNET_CLI_BUILD_TERMINAL_LOGGER\";",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Fixed",
              "createdAt": "2023-08-11T15:54:52Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2514,10 +2515,46 @@ private static bool GatherAutoResponseFileSwitchesFromFullPath(string autoRespon\n             return invokeBuild;\n         }\n \n-        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches)\n+        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)\n         {\n             string terminalloggerArg;\n \n+            string[] terminalLoggerParameters = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.TerminalLoggerParameters];\n+            aggregatedParameters = terminalLoggerParameters?.Length > 0 ?\n+                AggregateParameters(string.Empty, terminalLoggerParameters) :\n+                string.Empty;\n+\n+            // Find default configuration so it is part of telemetry even when default is not used.\n+            // Default can be stored in /tlp:default=true|false|on|off|auto\n+            string defaultValue = null;\n+            foreach (string parameter in aggregatedParameters.Split(MSBuildConstants.SemicolonChar))\n+            {\n+                if (string.IsNullOrWhiteSpace(parameter))\n+                {\n+                    continue;\n+                }\n+\n+                string[] parameterAndValue = parameter.Split(MSBuildConstants.EqualsChar);\n+                if (parameterAndValue[0].Equals(\"DEFAULT\", StringComparison.InvariantCultureIgnoreCase) && parameterAndValue.Length > 1)\n+                {\n+                    defaultValue = parameterAndValue[1];\n+                }\n+            }\n+\n+            if (defaultValue == null)\n+            {\n+                defaultValue = bool.FalseString;\n+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefault = bool.FalseString;\n+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefaultSource = \"msbuild\";\n+            }\n+            else\n+            {\n+                // Lets check DOTNET CLI env var\n+                string dotnetCliEnvVar = Environment.GetEnvironmentVariable(\"DOTNET_CLI_BUILD_TERMINAL_LOGGER\");\n+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefault = defaultValue;\n+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefaultSource = string.IsNullOrEmpty(dotnetCliEnvVar) ? \"sdk\" : \"DOTNET_CLI_BUILD_TERMINAL_LOGGER\";",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "minor: lot of things happening inside this lock. Please ensure everything locked is a must.",
              "createdAt": "2023-08-10T16:04:54Z",
              "path": "src/Shared/UnitTests/MockLogger.cs",
              "diffHunk": "@@ -383,6 +398,27 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)\n             }\n         }\n \n+        internal void TelemetryEventHandler(object sender, BuildEventArgs eventArgs)\n+        {\n+            lock (_lockObj)\n+            {\n+                if (eventArgs is TelemetryEventArgs telemetryEventArgs)",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Everything in lock scope is a must. We can move lock inside if, but due to fact that if will always be true, from runtime perspective it would not make difference.",
              "createdAt": "2023-08-11T14:53:21Z",
              "path": "src/Shared/UnitTests/MockLogger.cs",
              "diffHunk": "@@ -383,6 +398,27 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)\n             }\n         }\n \n+        internal void TelemetryEventHandler(object sender, BuildEventArgs eventArgs)\n+        {\n+            lock (_lockObj)\n+            {\n+                if (eventArgs is TelemetryEventArgs telemetryEventArgs)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I belieive it would be easier to use and understand if the types would be defined as enums.\r\nConverting to string is not a perf concern here",
              "createdAt": "2023-08-11T06:53:06Z",
              "path": "src/Framework/Telemetry/LoggingConfigurationTelemetry.cs",
              "diffHunk": "@@ -0,0 +1,150 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.Framework.Telemetry;\n+\n+internal class LoggingConfigurationTelemetry : TelemetryBase\n+{\n+    public override string EventName => \"loggingConfiguration\";\n+\n+    /// <summary>\n+    /// True if terminal logger was used.\n+    /// </summary>\n+    public bool TerminalLogger { get; set; }\n+\n+    /// <summary>\n+    /// What was user intent:\n+    ///   on | true -> user intent to enable logging\n+    ///   off | false -> user intent to disable logging\n+    ///   auto -> user intent to use logging if terminal allows it\n+    ///   null -> no user intent, using default\n+    /// </summary>\n+    public string? TerminalLoggerUserIntent { get; set; }\n+\n+    /// <summary>\n+    /// How was user intent signalized:\n+    ///   arg -> from command line argument or rsp file\n+    ///   MSBUILDTERMINALLOGGER -> from environment variable\n+    ///   MSBUILDLIVELOGGER -> from environment variable\n+    ///   null -> no user intent\n+    /// </summary>\n+    public string? TerminalLoggerUserIntentSource { get; set; }\n+\n+    /// <summary>\n+    /// The default behavior of terminal logger if user intent is not specified:\n+    ///   on | true -> enable logging\n+    ///   off | false -> disable logging\n+    ///   auto -> use logging if terminal allows it\n+    ///   null -> unspecified\n+    /// </summary>\n+    public string? TerminalLoggerDefault { get; set; }\n+\n+    /// <summary>\n+    /// How was default behavior signalized:\n+    ///   sdk -> from SDK\n+    ///   DOTNET_CLI_BUILD_TERMINAL_LOGGER -> from environment variable\n+    ///   msbuild -> MSBuild hardcoded default\n+    ///   null -> unspecified\n+    /// </summary>\n+    public string? TerminalLoggerDefaultSource { get; set; }",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I thought about it, but when telemetry is concerned, I like freedom of strings, so value could not follow enum names naming practice, telemetry issues can do simple temporary changes or extend enums. Also for enums I like the decision of number vs string of enums to be on place where valus is assigned. It is opinionated though",
              "createdAt": "2023-08-11T16:05:40Z",
              "path": "src/Framework/Telemetry/LoggingConfigurationTelemetry.cs",
              "diffHunk": "@@ -0,0 +1,150 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.Framework.Telemetry;\n+\n+internal class LoggingConfigurationTelemetry : TelemetryBase\n+{\n+    public override string EventName => \"loggingConfiguration\";\n+\n+    /// <summary>\n+    /// True if terminal logger was used.\n+    /// </summary>\n+    public bool TerminalLogger { get; set; }\n+\n+    /// <summary>\n+    /// What was user intent:\n+    ///   on | true -> user intent to enable logging\n+    ///   off | false -> user intent to disable logging\n+    ///   auto -> user intent to use logging if terminal allows it\n+    ///   null -> no user intent, using default\n+    /// </summary>\n+    public string? TerminalLoggerUserIntent { get; set; }\n+\n+    /// <summary>\n+    /// How was user intent signalized:\n+    ///   arg -> from command line argument or rsp file\n+    ///   MSBUILDTERMINALLOGGER -> from environment variable\n+    ///   MSBUILDLIVELOGGER -> from environment variable\n+    ///   null -> no user intent\n+    /// </summary>\n+    public string? TerminalLoggerUserIntentSource { get; set; }\n+\n+    /// <summary>\n+    /// The default behavior of terminal logger if user intent is not specified:\n+    ///   on | true -> enable logging\n+    ///   off | false -> disable logging\n+    ///   auto -> use logging if terminal allows it\n+    ///   null -> unspecified\n+    /// </summary>\n+    public string? TerminalLoggerDefault { get; set; }\n+\n+    /// <summary>\n+    /// How was default behavior signalized:\n+    ///   sdk -> from SDK\n+    ///   DOTNET_CLI_BUILD_TERMINAL_LOGGER -> from environment variable\n+    ///   msbuild -> MSBuild hardcoded default\n+    ///   null -> unspecified\n+    /// </summary>\n+    public string? TerminalLoggerDefaultSource { get; set; }",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Setter is not needed.",
              "createdAt": "2023-08-11T07:04:39Z",
              "path": "src/Framework/Telemetry/KnownTelemetry.cs",
              "diffHunk": "@@ -15,4 +15,9 @@ internal static class KnownTelemetry\n     /// Null means there are no prior collected build telemetry data, new clean instance shall be created for particular build.\n     /// </summary>\n     public static BuildTelemetry? PartialBuildTelemetry { get; set; }\n+\n+    /// <summary>\n+    /// Describes how logging was configured.\n+    /// </summary>\n+    public static LoggingConfigurationTelemetry LoggingConfigurationTelemetry { get; set; } = new LoggingConfigurationTelemetry();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Fixed",
              "createdAt": "2023-08-11T16:06:13Z",
              "path": "src/Framework/Telemetry/KnownTelemetry.cs",
              "diffHunk": "@@ -15,4 +15,9 @@ internal static class KnownTelemetry\n     /// Null means there are no prior collected build telemetry data, new clean instance shall be created for particular build.\n     /// </summary>\n     public static BuildTelemetry? PartialBuildTelemetry { get; set; }\n+\n+    /// <summary>\n+    /// Describes how logging was configured.\n+    /// </summary>\n+    public static LoggingConfigurationTelemetry LoggingConfigurationTelemetry { get; set; } = new LoggingConfigurationTelemetry();",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`LoggingConfigurationTelemetry` not needed after this point",
              "createdAt": "2023-08-11T07:11:34Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -566,6 +566,10 @@ public void BeginBuild(BuildParameters parameters)\n                 // Log deferred messages and response files\n                 LogDeferredMessages(loggingService, _deferredBuildMessages);\n \n+                // Log known deferred telemetry\n+                KnownTelemetry.LoggingConfigurationTelemetry.UpdateEventProperties();\n+                loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.LoggingConfigurationTelemetry.EventName, KnownTelemetry.LoggingConfigurationTelemetry.Properties);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Since we don't have setter we can keep it. It is also safer for unexpected null ref bugs.",
              "createdAt": "2023-08-11T16:06:59Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -566,6 +566,10 @@ public void BeginBuild(BuildParameters parameters)\n                 // Log deferred messages and response files\n                 LogDeferredMessages(loggingService, _deferredBuildMessages);\n \n+                // Log known deferred telemetry\n+                KnownTelemetry.LoggingConfigurationTelemetry.UpdateEventProperties();\n+                loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.LoggingConfigurationTelemetry.EventName, KnownTelemetry.LoggingConfigurationTelemetry.Properties);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "The nullref can be avoided by declaring it as nullable and calling it via Null Conditional Operator.\r\nBut it's unsignificant detail - I'm ok with current state",
              "createdAt": "2023-08-14T07:45:33Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -566,6 +566,10 @@ public void BeginBuild(BuildParameters parameters)\n                 // Log deferred messages and response files\n                 LogDeferredMessages(loggingService, _deferredBuildMessages);\n \n+                // Log known deferred telemetry\n+                KnownTelemetry.LoggingConfigurationTelemetry.UpdateEventProperties();\n+                loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.LoggingConfigurationTelemetry.EventName, KnownTelemetry.LoggingConfigurationTelemetry.Properties);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Implementation needs to be adjusted - it currently has no effect: https://github.com/dotnet/msbuild/blob/main/src/MSBuild/TerminalLogger/TerminalLogger.cs#L195",
              "createdAt": "2023-08-11T07:22:10Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3565,16 +3629,19 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<IL\n             }\n         }\n \n-        private static void ProcessTerminalLogger(\n-            bool noConsoleLogger,\n+        private static void ProcessTerminalLogger(bool noConsoleLogger,\n+            string aggregatedLoggerParameters,\n             List<DistributedLoggerRecord> distributedLoggerRecords,\n             int cpuCount,\n             List<ILogger> loggers)\n         {\n             if (!noConsoleLogger)\n             {\n                 // A central logger will be created for both single proc and multiproc.\n-                TerminalLogger logger = new TerminalLogger();\n+                TerminalLogger logger = new TerminalLogger()\n+                {\n+                    Parameters = aggregatedLoggerParameters",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Is it actually needed for production at all?\r\n\r\nIf we want it as part of telemetry - add it there and test it.\r\nIf it's used only to instruct flushing telemetry during unit testing - then it'd be better to remove all the added 'aggregatedParameters' plumbing code and just faciliate the testing needs less invasively (e.g. using TelemetryMockLogger extending the MockLogger, that allways spits the telemetry or instructing MockLogger with env var)",
              "createdAt": "2023-08-11T07:34:42Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3565,16 +3629,19 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<IL\n             }\n         }\n \n-        private static void ProcessTerminalLogger(\n-            bool noConsoleLogger,\n+        private static void ProcessTerminalLogger(bool noConsoleLogger,\n+            string aggregatedLoggerParameters,\n             List<DistributedLoggerRecord> distributedLoggerRecords,\n             int cpuCount,\n             List<ILogger> loggers)\n         {\n             if (!noConsoleLogger)\n             {\n                 // A central logger will be created for both single proc and multiproc.\n-                TerminalLogger logger = new TerminalLogger();\n+                TerminalLogger logger = new TerminalLogger()\n+                {\n+                    Parameters = aggregatedLoggerParameters",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Discussed offline - this is for future use (comment will be added)",
              "createdAt": "2023-08-11T09:04:15Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3565,16 +3629,19 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<IL\n             }\n         }\n \n-        private static void ProcessTerminalLogger(\n-            bool noConsoleLogger,\n+        private static void ProcessTerminalLogger(bool noConsoleLogger,\n+            string aggregatedLoggerParameters,\n             List<DistributedLoggerRecord> distributedLoggerRecords,\n             int cpuCount,\n             List<ILogger> loggers)\n         {\n             if (!noConsoleLogger)\n             {\n                 // A central logger will be created for both single proc and multiproc.\n-                TerminalLogger logger = new TerminalLogger();\n+                TerminalLogger logger = new TerminalLogger()\n+                {\n+                    Parameters = aggregatedLoggerParameters",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "As noted in other comment - this can be done via env var or set in extending type - so that we do not need to change production cod to facilitate this",
              "createdAt": "2023-08-11T07:36:15Z",
              "path": "src/Shared/UnitTests/MockLogger.cs",
              "diffHunk": "@@ -190,13 +191,23 @@ public string Parameters\n         public void Initialize(IEventSource eventSource)\n         {\n             eventSource.AnyEventRaised += LoggerEventHandler;\n+            if (eventSource is IEventSource2 eventSource2)\n+            {\n+                eventSource2.TelemetryLogged += TelemetryEventHandler;\n+            }\n \n             if (_profileEvaluation)\n             {\n                 var eventSource3 = eventSource as IEventSource3;\n                 eventSource3.ShouldNotBeNull();\n                 eventSource3.IncludeEvaluationProfiles();\n             }\n+\n+            // Apply parameters\n+            if (Parameters?.IndexOf(\"reporttelemetry\", StringComparison.OrdinalIgnoreCase) >= 0)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Discussed offline - not valid",
              "createdAt": "2023-08-11T09:03:13Z",
              "path": "src/Shared/UnitTests/MockLogger.cs",
              "diffHunk": "@@ -190,13 +191,23 @@ public string Parameters\n         public void Initialize(IEventSource eventSource)\n         {\n             eventSource.AnyEventRaised += LoggerEventHandler;\n+            if (eventSource is IEventSource2 eventSource2)\n+            {\n+                eventSource2.TelemetryLogged += TelemetryEventHandler;\n+            }\n \n             if (_profileEvaluation)\n             {\n                 var eventSource3 = eventSource as IEventSource3;\n                 eventSource3.ShouldNotBeNull();\n                 eventSource3.IncludeEvaluationProfiles();\n             }\n+\n+            // Apply parameters\n+            if (Parameters?.IndexOf(\"reporttelemetry\", StringComparison.OrdinalIgnoreCase) >= 0)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This method has side effect - it calls `SetConcoleMode` (if that's needed) and sets a static variable with previous mode (so that it can be restored).\r\n\r\nSo make sure this method is called if `terminalloggerArg` indicate usage of terminal logger. Plus rename the method to make it explicit it does something extra.",
              "createdAt": "2023-08-11T07:58:15Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2541,32 +2581,55 @@ private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches comma\n                 {\n                     s_globalMessagesToLogInBuildLoggers.Add(\n                         new BuildManager.DeferredBuildMessage($\"The environment variable MSBUILDTERMINALLOGGER was set to {terminalloggerArg}.\", MessageImportance.Low));\n+\n+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalloggerArg;\n+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = \"MSBUILDTERMINALLOGGER\";\n                 }\n                 else if (!string.IsNullOrEmpty(liveLoggerArg))\n                 {\n                     terminalloggerArg = liveLoggerArg;\n                     s_globalMessagesToLogInBuildLoggers.Add(\n                         new BuildManager.DeferredBuildMessage($\"The environment variable MSBUILDLIVELOGGER was set to {liveLoggerArg}.\", MessageImportance.Low));\n+\n+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalloggerArg;\n+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = \"MSBUILDLIVELOGGER\";\n                 }\n                 else\n                 {\n-                    return false;\n+                    // Not from the command line, rps, or environment, so we apply default now.\n+                    terminalloggerArg = defaultValue;\n                 }\n             }\n \n-            // We now have a string. It can be \"true\" or \"false\" which means just that:\n-            if (bool.TryParse(terminalloggerArg, out bool result))\n+            // We now have a string`. It can be \"true\" or \"false\" which means just that:\n+            if (terminalloggerArg.Equals(\"on\", StringComparison.InvariantCultureIgnoreCase))\n             {\n-                return result;\n+                terminalloggerArg = bool.TrueString;\n+            }\n+            else if (terminalloggerArg.Equals(\"off\", StringComparison.InvariantCultureIgnoreCase))\n+            {\n+                terminalloggerArg = bool.FalseString;\n             }\n \n-            // or it can be \"auto\", meaning \"enable if we can\"\n-            if (!terminalloggerArg.Equals(\"auto\", StringComparison.OrdinalIgnoreCase))\n+            bool useTerminalLogger;\n+            if (bool.TryParse(terminalloggerArg, out bool result))\n             {\n-                CommandLineSwitchException.Throw(\"InvalidTerminalLoggerValue\", terminalloggerArg);\n+                useTerminalLogger = result;\n             }\n+            else\n+            {\n+                // or it can be \"auto\", meaning \"enable if we can\"\n+                if (!terminalloggerArg.Equals(\"auto\", StringComparison.OrdinalIgnoreCase))\n+                {\n+                    CommandLineSwitchException.Throw(\"InvalidTerminalLoggerValue\", terminalloggerArg);\n+                }\n+\n+                useTerminalLogger = DoesEnvironmentSupportTerminalLogger();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Fixed",
              "createdAt": "2023-08-11T15:54:43Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2541,32 +2581,55 @@ private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches comma\n                 {\n                     s_globalMessagesToLogInBuildLoggers.Add(\n                         new BuildManager.DeferredBuildMessage($\"The environment variable MSBUILDTERMINALLOGGER was set to {terminalloggerArg}.\", MessageImportance.Low));\n+\n+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalloggerArg;\n+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = \"MSBUILDTERMINALLOGGER\";\n                 }\n                 else if (!string.IsNullOrEmpty(liveLoggerArg))\n                 {\n                     terminalloggerArg = liveLoggerArg;\n                     s_globalMessagesToLogInBuildLoggers.Add(\n                         new BuildManager.DeferredBuildMessage($\"The environment variable MSBUILDLIVELOGGER was set to {liveLoggerArg}.\", MessageImportance.Low));\n+\n+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalloggerArg;\n+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = \"MSBUILDLIVELOGGER\";\n                 }\n                 else\n                 {\n-                    return false;\n+                    // Not from the command line, rps, or environment, so we apply default now.\n+                    terminalloggerArg = defaultValue;\n                 }\n             }\n \n-            // We now have a string. It can be \"true\" or \"false\" which means just that:\n-            if (bool.TryParse(terminalloggerArg, out bool result))\n+            // We now have a string`. It can be \"true\" or \"false\" which means just that:\n+            if (terminalloggerArg.Equals(\"on\", StringComparison.InvariantCultureIgnoreCase))\n             {\n-                return result;\n+                terminalloggerArg = bool.TrueString;\n+            }\n+            else if (terminalloggerArg.Equals(\"off\", StringComparison.InvariantCultureIgnoreCase))\n+            {\n+                terminalloggerArg = bool.FalseString;\n             }\n \n-            // or it can be \"auto\", meaning \"enable if we can\"\n-            if (!terminalloggerArg.Equals(\"auto\", StringComparison.OrdinalIgnoreCase))\n+            bool useTerminalLogger;\n+            if (bool.TryParse(terminalloggerArg, out bool result))\n             {\n-                CommandLineSwitchException.Throw(\"InvalidTerminalLoggerValue\", terminalloggerArg);\n+                useTerminalLogger = result;\n             }\n+            else\n+            {\n+                // or it can be \"auto\", meaning \"enable if we can\"\n+                if (!terminalloggerArg.Equals(\"auto\", StringComparison.OrdinalIgnoreCase))\n+                {\n+                    CommandLineSwitchException.Throw(\"InvalidTerminalLoggerValue\", terminalloggerArg);\n+                }\n+\n+                useTerminalLogger = DoesEnvironmentSupportTerminalLogger();",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    /// How was user intent signaled:\r\n```\r\n\r\n(for all of these)",
              "createdAt": "2023-08-14T19:13:35Z",
              "path": "src/Framework/Telemetry/LoggingConfigurationTelemetry.cs",
              "diffHunk": "@@ -0,0 +1,150 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.Framework.Telemetry;\n+\n+internal class LoggingConfigurationTelemetry : TelemetryBase\n+{\n+    public override string EventName => \"loggingConfiguration\";\n+\n+    /// <summary>\n+    /// True if terminal logger was used.\n+    /// </summary>\n+    public bool TerminalLogger { get; set; }\n+\n+    /// <summary>\n+    /// What was user intent:\n+    ///   on | true -> user intent to enable logging\n+    ///   off | false -> user intent to disable logging\n+    ///   auto -> user intent to use logging if terminal allows it\n+    ///   null -> no user intent, using default\n+    /// </summary>\n+    public string? TerminalLoggerUserIntent { get; set; }\n+\n+    /// <summary>\n+    /// How was user intent signalized:",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Question: I can see defaulting to \"auto\", and I can see defaulting to \"off\" (after we ship, if you like old-n-busted better). But is there a case to default to \"on\"? It feels like that's dangerous since it'll junk up logs in a bunch of situations.\r\n\r\n(In retrospect it doesn't make sense for the current env vars to support `true` either . . .)",
              "createdAt": "2023-08-14T19:28:43Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2514,87 +2515,195 @@ private static bool GatherAutoResponseFileSwitchesFromFullPath(string autoRespon\n             return invokeBuild;\n         }\n \n-        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches)\n+        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)\n         {\n-            string terminalloggerArg;\n+            aggregatedParameters = AggregateParameters(commandLineSwitches);\n+            string defaultValue = FindDefaultValue(aggregatedParameters);\n \n-            // Command line wins, so check it first\n-            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.TerminalLogger))\n+            string terminalLoggerArg = null;\n+            if (!TryFromCommandLine(commandLineSwitches) && !TryFromEnvironmentVariables())\n             {\n+                ApplyDefault();\n+            }\n+\n+            terminalLoggerArg = NormalizeIntoBooleanValues();\n+\n+            bool useTerminalLogger = false;\n+            if (!TrueOrFalse())\n+            {\n+                ItMustBeAuto();\n+            }\n+\n+            return KnownTelemetry.LoggingConfigurationTelemetry.TerminalLogger = useTerminalLogger;\n+\n+            static bool DoesEnvironmentSupportTerminalLogger()\n+            {\n+                (var acceptAnsiColorCodes, var outputIsScreen, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();\n+\n+                if (!outputIsScreen)\n+                {\n+                    s_globalMessagesToLogInBuildLoggers.Add(\n+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString(\"TerminalLoggerNotUsedRedirected\"), MessageImportance.Low));\n+                    return false;\n+                }\n+\n+                // TerminalLogger is not used if the terminal does not support ANSI/VT100 escape sequences.\n+                if (!acceptAnsiColorCodes)\n+                {\n+                    s_globalMessagesToLogInBuildLoggers.Add(\n+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString(\"TerminalLoggerNotUsedNotSupported\"), MessageImportance.Low));\n+                    return false;\n+                }\n+\n+                if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)\n+                {\n+                    s_globalMessagesToLogInBuildLoggers.Add(\n+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString(\"TerminalLoggerNotUsedDisabled\"), MessageImportance.Low));\n+                    return false;\n+                }\n+\n+                return true;\n+            }\n+\n+            string FindDefaultValue(string s)\n+            {\n+                // Find default configuration so it is part of telemetry even when default is not used.\n+                // Default can be stored in /tlp:default=true|false|on|off|auto",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This is good point. When I though about it I personally prefer to give customer freedom to decide, playing with undocumented /tlp is \"for experts only\" and they should know better than enable it on CI.\r\nOne possible usage is: `msbuild /tl:true > t.log; cat t.log`.  When you `cat t.log` it will replay log on terminal with all escape chars and such. One can also investigate `raw` form of output. I used it few time to investigate and troubleshoot, but outside of this niche use cases, it might be risky. \r\nI consider `/tl:true` more risky than `/tlp:default=true` in this context as people can do that by mistake as `true` could be instinctive 'nobody-has-time-for-read-manual' kind of value they choose.\r\nMaybe we can shall `true | on` by `force`. \r\n@rainersigwald @baronfel what do you think about ^?",
              "createdAt": "2023-08-15T08:48:54Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2514,87 +2515,195 @@ private static bool GatherAutoResponseFileSwitchesFromFullPath(string autoRespon\n             return invokeBuild;\n         }\n \n-        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches)\n+        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)\n         {\n-            string terminalloggerArg;\n+            aggregatedParameters = AggregateParameters(commandLineSwitches);\n+            string defaultValue = FindDefaultValue(aggregatedParameters);\n \n-            // Command line wins, so check it first\n-            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.TerminalLogger))\n+            string terminalLoggerArg = null;\n+            if (!TryFromCommandLine(commandLineSwitches) && !TryFromEnvironmentVariables())\n             {\n+                ApplyDefault();\n+            }\n+\n+            terminalLoggerArg = NormalizeIntoBooleanValues();\n+\n+            bool useTerminalLogger = false;\n+            if (!TrueOrFalse())\n+            {\n+                ItMustBeAuto();\n+            }\n+\n+            return KnownTelemetry.LoggingConfigurationTelemetry.TerminalLogger = useTerminalLogger;\n+\n+            static bool DoesEnvironmentSupportTerminalLogger()\n+            {\n+                (var acceptAnsiColorCodes, var outputIsScreen, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();\n+\n+                if (!outputIsScreen)\n+                {\n+                    s_globalMessagesToLogInBuildLoggers.Add(\n+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString(\"TerminalLoggerNotUsedRedirected\"), MessageImportance.Low));\n+                    return false;\n+                }\n+\n+                // TerminalLogger is not used if the terminal does not support ANSI/VT100 escape sequences.\n+                if (!acceptAnsiColorCodes)\n+                {\n+                    s_globalMessagesToLogInBuildLoggers.Add(\n+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString(\"TerminalLoggerNotUsedNotSupported\"), MessageImportance.Low));\n+                    return false;\n+                }\n+\n+                if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)\n+                {\n+                    s_globalMessagesToLogInBuildLoggers.Add(\n+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString(\"TerminalLoggerNotUsedDisabled\"), MessageImportance.Low));\n+                    return false;\n+                }\n+\n+                return true;\n+            }\n+\n+            string FindDefaultValue(string s)\n+            {\n+                // Find default configuration so it is part of telemetry even when default is not used.\n+                // Default can be stored in /tlp:default=true|false|on|off|auto",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "there's not really a use case for `on/true` here, but IMO it's more consistent to describe this parameter in terms of the valid values for the MSBUILDTERMINALLOGGER environment variable, since it's answering the question \"what default for `this_other_value` should I use if non is explicitly provided\". So I don't think that any change needs to be made here.",
              "createdAt": "2023-08-16T15:24:16Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2514,87 +2515,195 @@ private static bool GatherAutoResponseFileSwitchesFromFullPath(string autoRespon\n             return invokeBuild;\n         }\n \n-        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches)\n+        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)\n         {\n-            string terminalloggerArg;\n+            aggregatedParameters = AggregateParameters(commandLineSwitches);\n+            string defaultValue = FindDefaultValue(aggregatedParameters);\n \n-            // Command line wins, so check it first\n-            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.TerminalLogger))\n+            string terminalLoggerArg = null;\n+            if (!TryFromCommandLine(commandLineSwitches) && !TryFromEnvironmentVariables())\n             {\n+                ApplyDefault();\n+            }\n+\n+            terminalLoggerArg = NormalizeIntoBooleanValues();\n+\n+            bool useTerminalLogger = false;\n+            if (!TrueOrFalse())\n+            {\n+                ItMustBeAuto();\n+            }\n+\n+            return KnownTelemetry.LoggingConfigurationTelemetry.TerminalLogger = useTerminalLogger;\n+\n+            static bool DoesEnvironmentSupportTerminalLogger()\n+            {\n+                (var acceptAnsiColorCodes, var outputIsScreen, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();\n+\n+                if (!outputIsScreen)\n+                {\n+                    s_globalMessagesToLogInBuildLoggers.Add(\n+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString(\"TerminalLoggerNotUsedRedirected\"), MessageImportance.Low));\n+                    return false;\n+                }\n+\n+                // TerminalLogger is not used if the terminal does not support ANSI/VT100 escape sequences.\n+                if (!acceptAnsiColorCodes)\n+                {\n+                    s_globalMessagesToLogInBuildLoggers.Add(\n+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString(\"TerminalLoggerNotUsedNotSupported\"), MessageImportance.Low));\n+                    return false;\n+                }\n+\n+                if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)\n+                {\n+                    s_globalMessagesToLogInBuildLoggers.Add(\n+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString(\"TerminalLoggerNotUsedDisabled\"), MessageImportance.Low));\n+                    return false;\n+                }\n+\n+                return true;\n+            }\n+\n+            string FindDefaultValue(string s)\n+            {\n+                // Find default configuration so it is part of telemetry even when default is not used.\n+                // Default can be stored in /tlp:default=true|false|on|off|auto",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "So are we going to guide people to use on/off/auto, but support true/false for backward compat? I find this a bit confusing :)",
              "createdAt": "2023-08-14T19:55:27Z",
              "path": "src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework.Telemetry;\n+using Microsoft.Build.UnitTests.Shared;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests;\n+\n+/// <summary>\n+/// End to end tests for the terminal logger configuration.\n+/// We need to execute msbuild process as tested code path is also in XMake.cs.\n+/// Also verifies that the telemetry is logged correctly.\n+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.\n+/// </summary>\n+public class TerminalLoggerConfiguration_Tests : IDisposable\n+{\n+    private readonly TestEnvironment _env;\n+\n+    private readonly string _cmd;\n+    private readonly ITestOutputHelper _output;\n+\n+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)\n+    {\n+        _env = TestEnvironment.Create(output);\n+        _output = output;\n+\n+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);\n+        TransientTestFile projectFile = _env.CreateFile(logFolder, \"myProj.proj\", $\"\"\"\n+            <Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" DefaultTargets=\"Hello\">\n+                <Target Name=\"Hello\">\n+                  <Message Text=\"Hello, world!\" />\n+                </Target>\n+            </Project>\n+            \"\"\");\n+        _cmd = $\"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry\";\n+    }\n+\n+    /// <summary>\n+    /// TearDown\n+    /// </summary>\n+    public void Dispose()\n+    {\n+        _env.Dispose();\n+    }\n+\n+    [Theory]\n+    [InlineData(\"on\")]\n+    [InlineData(\"true\")]",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I included it for convenience only. We mostly support only True | False like for example /nr:false altough from linguistic point of view sentence `node reduce is off` looks better to me than `node reduce is false`.\r\nNot that it matter as much as people learned not to be too creating with CLI commands and simply to respect CLI help and docs.\r\n@baronfel @rainersigwald changing this is very simply though. Please make the decision.",
              "createdAt": "2023-08-15T08:59:40Z",
              "path": "src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework.Telemetry;\n+using Microsoft.Build.UnitTests.Shared;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests;\n+\n+/// <summary>\n+/// End to end tests for the terminal logger configuration.\n+/// We need to execute msbuild process as tested code path is also in XMake.cs.\n+/// Also verifies that the telemetry is logged correctly.\n+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.\n+/// </summary>\n+public class TerminalLoggerConfiguration_Tests : IDisposable\n+{\n+    private readonly TestEnvironment _env;\n+\n+    private readonly string _cmd;\n+    private readonly ITestOutputHelper _output;\n+\n+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)\n+    {\n+        _env = TestEnvironment.Create(output);\n+        _output = output;\n+\n+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);\n+        TransientTestFile projectFile = _env.CreateFile(logFolder, \"myProj.proj\", $\"\"\"\n+            <Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" DefaultTargets=\"Hello\">\n+                <Target Name=\"Hello\">\n+                  <Message Text=\"Hello, world!\" />\n+                </Target>\n+            </Project>\n+            \"\"\");\n+        _cmd = $\"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry\";\n+    }\n+\n+    /// <summary>\n+    /// TearDown\n+    /// </summary>\n+    public void Dispose()\n+    {\n+        _env.Dispose();\n+    }\n+\n+    [Theory]\n+    [InlineData(\"on\")]\n+    [InlineData(\"true\")]",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "off/on is something that I asked for because I already make this mistake often and I helped design the dang feature. I expect users will want to use boolean-ish properties here.",
              "createdAt": "2023-08-16T15:25:21Z",
              "path": "src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs",
              "diffHunk": "@@ -0,0 +1,233 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+using System;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework.Telemetry;\n+using Microsoft.Build.UnitTests.Shared;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+namespace Microsoft.Build.UnitTests;\n+\n+/// <summary>\n+/// End to end tests for the terminal logger configuration.\n+/// We need to execute msbuild process as tested code path is also in XMake.cs.\n+/// Also verifies that the telemetry is logged correctly.\n+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.\n+/// </summary>\n+public class TerminalLoggerConfiguration_Tests : IDisposable\n+{\n+    private readonly TestEnvironment _env;\n+\n+    private readonly string _cmd;\n+    private readonly ITestOutputHelper _output;\n+\n+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)\n+    {\n+        _env = TestEnvironment.Create(output);\n+        _output = output;\n+\n+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);\n+        TransientTestFile projectFile = _env.CreateFile(logFolder, \"myProj.proj\", $\"\"\"\n+            <Project ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" DefaultTargets=\"Hello\">\n+                <Target Name=\"Hello\">\n+                  <Message Text=\"Hello, world!\" />\n+                </Target>\n+            </Project>\n+            \"\"\");\n+        _cmd = $\"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry\";\n+    }\n+\n+    /// <summary>\n+    /// TearDown\n+    /// </summary>\n+    public void Dispose()\n+    {\n+        _env.Dispose();\n+    }\n+\n+    [Theory]\n+    [InlineData(\"on\")]\n+    [InlineData(\"true\")]",
              "author": {
                "login": "baronfel"
              }
            }
          ]
        }
      }
    ]
  }
}