{
  "number": 9374,
  "title": "Allow optional reuse of existing immutable collections when constructing a ProjectInstance.",
  "body": "ProjectInstance is a snapshot of the Project values that duplicates the project data in \"Instance\" objects (e.g. ProjectPropertyInstance). In the special case of the ProjectInstance constructed from the CPS Evaluation Cache data, this duplication is unnecessary, as the original data is guaranteed to be immutable. This PR introduces the ProjectInstance.FromImmutableProjectSource method, which CPS will use when it wants ProjectInstance to reuse its immutable structures.\r\n\r\nOne complicating factor was a concern about taking a dependency on any particular version of MSBuild, as CPS ships in C# Dev Kit and in that context it must play nice with the installed version.",
  "state": "MERGED",
  "createdAt": "2023-10-31T19:09:58Z",
  "updatedAt": "2024-01-04T19:54:27Z",
  "closedAt": "2024-01-04T19:54:27Z",
  "mergedAt": "2024-01-04T19:54:26Z",
  "additions": 1264,
  "deletions": 192,
  "changedFiles": 33,
  "headRefName": "dev/sgreen/useImmutableCacheData",
  "isDraft": false,
  "author": {
    "login": "sgreenmsft"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "needs-attention"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "d2991da827c817d437d1dbf4fea93a4e23afac14",
          "message": "Modifications to allow use of existing immutable collections when constructing a ProjectInstance.",
          "committedDate": "2023-10-31T19:06:48Z",
          "author": {
            "name": "SGreen",
            "email": "sgreen@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e499c19f157944ec940947b80175150dfefd901c",
          "message": "Merge branch 'main' into dev/sgreen/useImmutableCacheData",
          "committedDate": "2023-10-31T19:07:28Z",
          "author": {
            "name": "SGreen",
            "email": "sgreen@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d8c67178947e83a0d601b732d693b8e7a8adc922",
          "message": "Updates as per PR feedback.",
          "committedDate": "2023-12-08T23:48:12Z",
          "author": {
            "name": "SGreen",
            "email": "sgreen@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b46cff2e846e5ff0547de630c3ed91e7d19ab89d",
          "message": "Merge branch 'main' into dev/sgreen/useImmutableCacheData",
          "committedDate": "2024-01-04T19:20:11Z",
          "author": {
            "name": "SGreen",
            "email": "sgreen@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@ladipro @rokonec - Thanks for the feedback! I've made changes as per your suggestions. When convenient, could you take another look? Thanks!",
        "createdAt": "2024-01-02T22:18:44Z",
        "author": {
          "login": "sgreenmsft"
        }
      },
      {
        "body": "> Looks correct. However, it is hard for me to understand its full context as I don't known how exactly it will be usable for CPS.\r\n> \r\n> However, it is lot of changes, as there is no unit teste coverage for those, how did you verified it?\r\n\r\n@rokonec - CPS tests and manual verification of impacted scenarios. If there are additional steps I can take to verify please let me know. :)",
        "createdAt": "2024-01-02T22:20:56Z",
        "author": {
          "login": "sgreenmsft"
        }
      },
      {
        "body": "@sgreenmsft - can you please resolve comments that were reflected or doesn't apply anymore? That will make the second look easier. Plus please resolve the conflicts with main.\r\n\r\n@rokonec - can you please have a second look if your concerns were addressed?",
        "createdAt": "2024-01-03T14:02:03Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Seems to be OK.",
        "createdAt": "2024-01-04T13:48:54Z",
        "author": {
          "login": "rokonec"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: Although my personal preference is not to comment internal types which obvious signature, this class does it for other member, and maybe we can include comment here for consistency sake.",
              "createdAt": "2023-11-03T10:50:19Z",
              "path": "src/Build/Collections/IItemDictionary.cs",
              "diffHunk": "@@ -0,0 +1,130 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Collections\n+{\n+    internal interface IItemDictionary<T> : IEnumerable<T>, IItemProvider<T>\n+        where T : class, IKeyed, IItem\n+    {\n+        /// <summary>\n+        /// Number of items in total, for debugging purposes.\n+        /// </summary>\n+        int Count { get; }\n+\n+        /// <summary>\n+        /// Get the item types that have at least one item in this collection.\n+        /// </summary>\n+        /// <remarks>\n+        /// KeyCollection&lt;K&gt; is already a read only collection, so no protection\n+        /// is necessary.\n+        /// </remarks>\n+        ICollection<string> ItemTypes { get; }\n+\n+        /// <summary>\n+        /// Returns the item list for a particular item type,\n+        /// creating and adding a new item list if necessary.\n+        /// Does not throw if there are no items of this type.\n+        /// This is a read-only list.\n+        /// If the result is not empty it is a live list.\n+        /// Use AddItem or RemoveItem to modify items in this project.\n+        /// Using the return value from this in a multithreaded situation is unsafe.\n+        /// </summary>\n+        ICollection<T> this[string itemType] { get; }\n+\n+        /// <summary>\n+        /// Empty the collection.\n+        /// </summary>\n+        void Clear();\n+\n+        /// <summary>\n+        /// Returns an enumerable which copies the underlying data on read.\n+        /// </summary>\n+        IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector);\n+\n+        /// <summary>\n+        /// Enumerates item lists per each item type under the lock.\n+        /// </summary>\n+        /// <param name=\"itemTypeCallback\">\n+        /// A delegate that accepts the item type string and a list of items of that type.\n+        /// Will be called for each item type in the list.\n+        /// </param>\n+        void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback);\n+\n+        /// <summary>\n+        /// Whether the provided item is in this table or not.\n+        /// </summary>\n+        bool Contains(T projectItem);\n+\n+        /// <summary>\n+        /// Add a new item to the collection, at the\n+        /// end of the list of other items with its key.\n+        /// </summary>\n+        void Add(T projectItem);\n+\n+        void AddRange(IEnumerable<T> projectItems);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: Is this needed? IDictionary<T> implements those.",
              "createdAt": "2023-11-06T14:19:22Z",
              "path": "src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs",
              "diffHunk": "@@ -0,0 +1,75 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System.Collections.Generic;\n+using System.Runtime.Serialization;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Collections\n+{\n+    internal interface IRetrievableEntryHashSet<T> :\n+        ICollection<T>,\n+        ISerializable,\n+        IDeserializationCallback,\n+        ICollection<KeyValuePair<string, T>>,\n+        IEnumerable<KeyValuePair<string, T>>,",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It might be an issue in context of our usage patterns, but according to code https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,199 it is supposed to compare value as well.",
              "createdAt": "2023-11-06T14:33:36Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,278 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    /// <summary>\n+    /// A specialized collection used when element data originates in an immutable Project.\n+    /// </summary>\n+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>\n+        where T : class, IKeyed\n+    {\n+        private readonly IDictionary<string, TCached> _projectElements;\n+        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;\n+        private readonly ValuesCollection _values;\n+\n+        public ImmutableElementCollectionConverter(\n+            IDictionary<string, TCached> projectElements,\n+            IDictionary<(string, int, int), TCached> constrainedProjectElements)\n+        {\n+            _projectElements = projectElements;\n+            _constrainedProjectElements = constrainedProjectElements;\n+            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);\n+        }\n+\n+        public T this[string key]\n+        {\n+            get => Get(key);\n+            set => throw new NotSupportedException();\n+        }\n+\n+        public int Count => _values.Count;\n+\n+        public bool IsReadOnly => true;\n+\n+        public ICollection<string> Keys => _projectElements.Keys;\n+\n+        public ICollection<T> Values => _values;\n+\n+        public void Add(T item) => throw new NotSupportedException();\n+\n+        public void Add(string key, T value) => throw new NotSupportedException();\n+\n+        public void Add(KeyValuePair<string, T> item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public bool Contains(T item) => _projectElements.ContainsKey(item.Key);\n+\n+        public bool Contains(KeyValuePair<string, T> item) => _projectElements.ContainsKey(item.Key);",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "RetrievableEntryHashSet's implementation of Contains(KeyValuePair<string, T>) does not check for item equivalence. It only checks whether an item with the same key exists in the collection. As ImmutableElementCollectionConverter seeks to match the behavior of RetrievableEntryHashSet, I think this implementation is correct. I'll add a comment noting that only checking the Key matches the behavior of RetrievableEntryHashSet.",
              "createdAt": "2023-11-28T19:27:44Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,278 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    /// <summary>\n+    /// A specialized collection used when element data originates in an immutable Project.\n+    /// </summary>\n+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>\n+        where T : class, IKeyed\n+    {\n+        private readonly IDictionary<string, TCached> _projectElements;\n+        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;\n+        private readonly ValuesCollection _values;\n+\n+        public ImmutableElementCollectionConverter(\n+            IDictionary<string, TCached> projectElements,\n+            IDictionary<(string, int, int), TCached> constrainedProjectElements)\n+        {\n+            _projectElements = projectElements;\n+            _constrainedProjectElements = constrainedProjectElements;\n+            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);\n+        }\n+\n+        public T this[string key]\n+        {\n+            get => Get(key);\n+            set => throw new NotSupportedException();\n+        }\n+\n+        public int Count => _values.Count;\n+\n+        public bool IsReadOnly => true;\n+\n+        public ICollection<string> Keys => _projectElements.Keys;\n+\n+        public ICollection<T> Values => _values;\n+\n+        public void Add(T item) => throw new NotSupportedException();\n+\n+        public void Add(string key, T value) => throw new NotSupportedException();\n+\n+        public void Add(KeyValuePair<string, T> item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public bool Contains(T item) => _projectElements.ContainsKey(item.Key);\n+\n+        public bool Contains(KeyValuePair<string, T> item) => _projectElements.ContainsKey(item.Key);",
              "author": {
                "login": "sgreenmsft"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we rather throw here? Most CopyTo, such as Array and List<T>, does throw if target array is not big enough.",
              "createdAt": "2023-11-06T14:57:07Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,278 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    /// <summary>\n+    /// A specialized collection used when element data originates in an immutable Project.\n+    /// </summary>\n+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>\n+        where T : class, IKeyed\n+    {\n+        private readonly IDictionary<string, TCached> _projectElements;\n+        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;\n+        private readonly ValuesCollection _values;\n+\n+        public ImmutableElementCollectionConverter(\n+            IDictionary<string, TCached> projectElements,\n+            IDictionary<(string, int, int), TCached> constrainedProjectElements)\n+        {\n+            _projectElements = projectElements;\n+            _constrainedProjectElements = constrainedProjectElements;\n+            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);\n+        }\n+\n+        public T this[string key]\n+        {\n+            get => Get(key);\n+            set => throw new NotSupportedException();\n+        }\n+\n+        public int Count => _values.Count;\n+\n+        public bool IsReadOnly => true;\n+\n+        public ICollection<string> Keys => _projectElements.Keys;\n+\n+        public ICollection<T> Values => _values;\n+\n+        public void Add(T item) => throw new NotSupportedException();\n+\n+        public void Add(string key, T value) => throw new NotSupportedException();\n+\n+        public void Add(KeyValuePair<string, T> item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public bool Contains(T item) => _projectElements.ContainsKey(item.Key);\n+\n+        public bool Contains(KeyValuePair<string, T> item) => _projectElements.ContainsKey(item.Key);\n+\n+        public bool ContainsKey(string key) => _projectElements.ContainsKey(key);\n+\n+        public void CopyTo(T[] array) => _values.CopyTo(array, arrayIndex: 0);\n+\n+        public void CopyTo(T[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);\n+\n+        public void CopyTo(T[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);\n+\n+        public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);\n+\n+        public T Get(string key) => _values.Get(key);\n+\n+        public T Get(string key, int index, int length) => _values.Get(key, index, length);\n+\n+        public IEnumerator<T> GetEnumerator() => _values.GetEnumerator();\n+\n+        public void GetObjectData(SerializationInfo info, StreamingContext context) => throw new NotSupportedException();\n+\n+        public void OnDeserialization(object sender) => throw new NotSupportedException();\n+\n+        public bool Remove(T item) => throw new NotSupportedException();\n+\n+        public bool Remove(string key) => throw new NotSupportedException();\n+\n+        public bool Remove(KeyValuePair<string, T> item) => throw new NotSupportedException();\n+\n+        public void TrimExcess()\n+        {\n+        }\n+\n+        public bool TryGetValue(string key, out T value) => _values.TryGetValue(key, out value);\n+\n+        public void UnionWith(IEnumerable<T> other) => throw new NotSupportedException();\n+\n+        IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator() => _values.GetKvpEnumerator();\n+\n+        IEnumerator IEnumerable.GetEnumerator() => _values.GetEnumerator();\n+\n+        /// <summary>\n+        /// Wraps the Project's values.\n+        /// </summary>\n+        private class ValuesCollection : ICollection<T>\n+        {\n+            private readonly IDictionary<string, TCached> _projectElements;\n+            private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;\n+\n+            public ValuesCollection(\n+                IDictionary<string, TCached> projectElements,\n+                IDictionary<(string, int, int), TCached> constrainedProjectElements)\n+            {\n+                _projectElements = projectElements;\n+                _constrainedProjectElements = constrainedProjectElements;\n+            }\n+\n+            public int Count => _projectElements.Count;\n+\n+            public bool IsReadOnly => true;\n+\n+            public void Add(T item) => throw new NotSupportedException();\n+\n+            public void Clear() => throw new NotSupportedException();\n+\n+            public bool Contains(T item)\n+            {\n+                if (item == null)\n+                {\n+                    throw new ArgumentNullException(nameof(item));\n+                }\n+\n+                return _projectElements.ContainsKey(item.Key);\n+            }\n+\n+            public void CopyTo(T[] array, int arrayIndex)\n+            {\n+                if (array == null)\n+                {\n+                    throw new ArgumentNullException(nameof(array));\n+                }\n+\n+                if (arrayIndex < 0)\n+                {\n+                    throw new ArgumentOutOfRangeException(nameof(arrayIndex));\n+                }\n+\n+                int count = Math.Min(Count, array.Length - arrayIndex);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "OutOfRangeException when count > (array.Lenght - arrayIndex)\r\nI think we shall fast-fail throw same as other BCL CopyTo do when dest array is not big enough.",
              "createdAt": "2023-11-06T15:04:07Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,278 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    /// <summary>\n+    /// A specialized collection used when element data originates in an immutable Project.\n+    /// </summary>\n+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>\n+        where T : class, IKeyed\n+    {\n+        private readonly IDictionary<string, TCached> _projectElements;\n+        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;\n+        private readonly ValuesCollection _values;\n+\n+        public ImmutableElementCollectionConverter(\n+            IDictionary<string, TCached> projectElements,\n+            IDictionary<(string, int, int), TCached> constrainedProjectElements)\n+        {\n+            _projectElements = projectElements;\n+            _constrainedProjectElements = constrainedProjectElements;\n+            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);\n+        }\n+\n+        public T this[string key]\n+        {\n+            get => Get(key);\n+            set => throw new NotSupportedException();\n+        }\n+\n+        public int Count => _values.Count;\n+\n+        public bool IsReadOnly => true;\n+\n+        public ICollection<string> Keys => _projectElements.Keys;\n+\n+        public ICollection<T> Values => _values;\n+\n+        public void Add(T item) => throw new NotSupportedException();\n+\n+        public void Add(string key, T value) => throw new NotSupportedException();\n+\n+        public void Add(KeyValuePair<string, T> item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public bool Contains(T item) => _projectElements.ContainsKey(item.Key);\n+\n+        public bool Contains(KeyValuePair<string, T> item) => _projectElements.ContainsKey(item.Key);\n+\n+        public bool ContainsKey(string key) => _projectElements.ContainsKey(key);\n+\n+        public void CopyTo(T[] array) => _values.CopyTo(array, arrayIndex: 0);\n+\n+        public void CopyTo(T[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);\n+\n+        public void CopyTo(T[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);\n+\n+        public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);\n+\n+        public T Get(string key) => _values.Get(key);\n+\n+        public T Get(string key, int index, int length) => _values.Get(key, index, length);\n+\n+        public IEnumerator<T> GetEnumerator() => _values.GetEnumerator();\n+\n+        public void GetObjectData(SerializationInfo info, StreamingContext context) => throw new NotSupportedException();\n+\n+        public void OnDeserialization(object sender) => throw new NotSupportedException();\n+\n+        public bool Remove(T item) => throw new NotSupportedException();\n+\n+        public bool Remove(string key) => throw new NotSupportedException();\n+\n+        public bool Remove(KeyValuePair<string, T> item) => throw new NotSupportedException();\n+\n+        public void TrimExcess()\n+        {\n+        }\n+\n+        public bool TryGetValue(string key, out T value) => _values.TryGetValue(key, out value);\n+\n+        public void UnionWith(IEnumerable<T> other) => throw new NotSupportedException();\n+\n+        IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator() => _values.GetKvpEnumerator();\n+\n+        IEnumerator IEnumerable.GetEnumerator() => _values.GetEnumerator();\n+\n+        /// <summary>\n+        /// Wraps the Project's values.\n+        /// </summary>\n+        private class ValuesCollection : ICollection<T>\n+        {\n+            private readonly IDictionary<string, TCached> _projectElements;\n+            private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;\n+\n+            public ValuesCollection(\n+                IDictionary<string, TCached> projectElements,\n+                IDictionary<(string, int, int), TCached> constrainedProjectElements)\n+            {\n+                _projectElements = projectElements;\n+                _constrainedProjectElements = constrainedProjectElements;\n+            }\n+\n+            public int Count => _projectElements.Count;\n+\n+            public bool IsReadOnly => true;\n+\n+            public void Add(T item) => throw new NotSupportedException();\n+\n+            public void Clear() => throw new NotSupportedException();\n+\n+            public bool Contains(T item)\n+            {\n+                if (item == null)\n+                {\n+                    throw new ArgumentNullException(nameof(item));\n+                }\n+\n+                return _projectElements.ContainsKey(item.Key);\n+            }\n+\n+            public void CopyTo(T[] array, int arrayIndex)\n+            {\n+                if (array == null)\n+                {\n+                    throw new ArgumentNullException(nameof(array));\n+                }\n+\n+                if (arrayIndex < 0)\n+                {\n+                    throw new ArgumentOutOfRangeException(nameof(arrayIndex));\n+                }\n+\n+                int count = Math.Min(Count, array.Length - arrayIndex);\n+\n+                CopyTo(array, arrayIndex, count);\n+            }\n+\n+            public void CopyTo(T[] array, int arrayIndex, int count)\n+            {\n+                if (array == null)\n+                {\n+                    throw new ArgumentNullException(nameof(array));\n+                }\n+\n+                if (arrayIndex < 0)\n+                {\n+                    throw new ArgumentOutOfRangeException(nameof(arrayIndex));\n+                }\n+\n+                if (count < 0)\n+                {\n+                    throw new ArgumentOutOfRangeException(nameof(count));\n+                }\n+\n+                int index = arrayIndex;\n+                int endIndex = arrayIndex + count;\n+                foreach (var item in _projectElements.Values)\n+                {\n+                    array[index] = GetElementInstance(item);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we rather throw here? Most CopyTo, such as Array and List, does throw if target array is not big enough.",
              "createdAt": "2023-11-06T15:04:40Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,278 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    /// <summary>\n+    /// A specialized collection used when element data originates in an immutable Project.\n+    /// </summary>\n+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>\n+        where T : class, IKeyed\n+    {\n+        private readonly IDictionary<string, TCached> _projectElements;\n+        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;\n+        private readonly ValuesCollection _values;\n+\n+        public ImmutableElementCollectionConverter(\n+            IDictionary<string, TCached> projectElements,\n+            IDictionary<(string, int, int), TCached> constrainedProjectElements)\n+        {\n+            _projectElements = projectElements;\n+            _constrainedProjectElements = constrainedProjectElements;\n+            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);\n+        }\n+\n+        public T this[string key]\n+        {\n+            get => Get(key);\n+            set => throw new NotSupportedException();\n+        }\n+\n+        public int Count => _values.Count;\n+\n+        public bool IsReadOnly => true;\n+\n+        public ICollection<string> Keys => _projectElements.Keys;\n+\n+        public ICollection<T> Values => _values;\n+\n+        public void Add(T item) => throw new NotSupportedException();\n+\n+        public void Add(string key, T value) => throw new NotSupportedException();\n+\n+        public void Add(KeyValuePair<string, T> item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public bool Contains(T item) => _projectElements.ContainsKey(item.Key);\n+\n+        public bool Contains(KeyValuePair<string, T> item) => _projectElements.ContainsKey(item.Key);\n+\n+        public bool ContainsKey(string key) => _projectElements.ContainsKey(key);\n+\n+        public void CopyTo(T[] array) => _values.CopyTo(array, arrayIndex: 0);\n+\n+        public void CopyTo(T[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);\n+\n+        public void CopyTo(T[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);\n+\n+        public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);\n+\n+        public T Get(string key) => _values.Get(key);\n+\n+        public T Get(string key, int index, int length) => _values.Get(key, index, length);\n+\n+        public IEnumerator<T> GetEnumerator() => _values.GetEnumerator();\n+\n+        public void GetObjectData(SerializationInfo info, StreamingContext context) => throw new NotSupportedException();\n+\n+        public void OnDeserialization(object sender) => throw new NotSupportedException();\n+\n+        public bool Remove(T item) => throw new NotSupportedException();\n+\n+        public bool Remove(string key) => throw new NotSupportedException();\n+\n+        public bool Remove(KeyValuePair<string, T> item) => throw new NotSupportedException();\n+\n+        public void TrimExcess()\n+        {\n+        }\n+\n+        public bool TryGetValue(string key, out T value) => _values.TryGetValue(key, out value);\n+\n+        public void UnionWith(IEnumerable<T> other) => throw new NotSupportedException();\n+\n+        IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator() => _values.GetKvpEnumerator();\n+\n+        IEnumerator IEnumerable.GetEnumerator() => _values.GetEnumerator();\n+\n+        /// <summary>\n+        /// Wraps the Project's values.\n+        /// </summary>\n+        private class ValuesCollection : ICollection<T>\n+        {\n+            private readonly IDictionary<string, TCached> _projectElements;\n+            private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;\n+\n+            public ValuesCollection(\n+                IDictionary<string, TCached> projectElements,\n+                IDictionary<(string, int, int), TCached> constrainedProjectElements)\n+            {\n+                _projectElements = projectElements;\n+                _constrainedProjectElements = constrainedProjectElements;\n+            }\n+\n+            public int Count => _projectElements.Count;\n+\n+            public bool IsReadOnly => true;\n+\n+            public void Add(T item) => throw new NotSupportedException();\n+\n+            public void Clear() => throw new NotSupportedException();\n+\n+            public bool Contains(T item)\n+            {\n+                if (item == null)\n+                {\n+                    throw new ArgumentNullException(nameof(item));\n+                }\n+\n+                return _projectElements.ContainsKey(item.Key);\n+            }\n+\n+            public void CopyTo(T[] array, int arrayIndex)\n+            {\n+                if (array == null)\n+                {\n+                    throw new ArgumentNullException(nameof(array));\n+                }\n+\n+                if (arrayIndex < 0)\n+                {\n+                    throw new ArgumentOutOfRangeException(nameof(arrayIndex));\n+                }\n+\n+                int count = Math.Min(Count, array.Length - arrayIndex);\n+\n+                CopyTo(array, arrayIndex, count);\n+            }\n+\n+            public void CopyTo(T[] array, int arrayIndex, int count)\n+            {\n+                if (array == null)\n+                {\n+                    throw new ArgumentNullException(nameof(array));\n+                }\n+\n+                if (arrayIndex < 0)\n+                {\n+                    throw new ArgumentOutOfRangeException(nameof(arrayIndex));\n+                }\n+\n+                if (count < 0)\n+                {\n+                    throw new ArgumentOutOfRangeException(nameof(count));\n+                }\n+\n+                int index = arrayIndex;\n+                int endIndex = arrayIndex + count;\n+                foreach (var item in _projectElements.Values)\n+                {\n+                    array[index] = GetElementInstance(item);\n+                    ++index;\n+                    if (index >= endIndex)\n+                    {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex)\n+            {\n+                if (array == null)\n+                {\n+                    throw new ArgumentNullException(nameof(array));\n+                }\n+\n+                if (arrayIndex < 0)\n+                {\n+                    throw new ArgumentOutOfRangeException(nameof(arrayIndex));\n+                }\n+\n+                int count = Math.Min(_projectElements.Count, array.Length - arrayIndex);",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please consider if this CopyTo shall rather throw when destination array is not big enough. This is would be more consistent with other CopyTo implementations.",
              "createdAt": "2023-11-08T15:03:17Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs",
              "diffHunk": "@@ -0,0 +1,232 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    /// <summary>\n+    /// A specialized collection used when item data originates in an immutable Project.\n+    /// </summary>\n+    internal class ImmutableItemDictionary<TCached, T> : IItemDictionary<T>\n+        where T : class, IKeyed, IItem\n+    {\n+        private readonly IDictionary<string, ICollection<TCached>> _itemsByType;\n+        private readonly ICollection<T> _allItems;\n+\n+        public ImmutableItemDictionary(IDictionary<string, ICollection<TCached>> itemsByType, ICollection<TCached> allItems)\n+        {\n+            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));\n+\n+            if (allItems == null)\n+            {\n+                throw new ArgumentNullException(nameof(allItems));\n+            }\n+\n+            var convertedItems = new HashSet<T>(allItems.Count);\n+            foreach (var item in allItems)\n+            {\n+                T? instance = GetInstance(item);\n+                if (instance != null)\n+                {\n+                    convertedItems.Add(instance);\n+                }\n+            }\n+            _allItems = new ReadOnlyCollection<T>(convertedItems);\n+        }\n+\n+        /// <inheritdoc />\n+        public ICollection<T> this[string itemType]\n+        {\n+            get\n+            {\n+                if (!_itemsByType.TryGetValue(itemType, out ICollection<TCached>? list))\n+                {\n+                    return Array.Empty<T>();\n+                }\n+\n+                return new ListConverter(itemType, _allItems, list);\n+            }\n+        }\n+\n+        /// <inheritdoc />\n+        public int Count => _allItems.Count;\n+\n+        /// <inheritdoc />\n+        public ICollection<string> ItemTypes => _itemsByType.Keys;\n+\n+        /// <inheritdoc />\n+        public void Add(T projectItem) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void AddEmptyMarker(string itemType) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void AddRange(IEnumerable<T> projectItems) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void Clear() => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public bool Contains(T projectItem) => _allItems.Contains(projectItem);\n+\n+        /// <inheritdoc />\n+        public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)\n+        {\n+            foreach (var kvp in _itemsByType)\n+            {\n+                if (kvp.Value == null || kvp.Value.Count == 0)\n+                {\n+                    // skip empty markers\n+                    continue;\n+                }\n+\n+                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, _allItems, kvp.Value));\n+            }\n+        }\n+\n+        /// <inheritdoc />\n+        public IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector)\n+        {\n+            foreach (var item in _allItems)\n+            {\n+                yield return selector(item);\n+            }\n+        }\n+\n+        /// <inheritdoc />\n+        public IEnumerator<T> GetEnumerator() => _allItems.GetEnumerator();\n+\n+        /// <inheritdoc />\n+        IEnumerator IEnumerable.GetEnumerator() => _allItems.GetEnumerator();\n+\n+        /// <inheritdoc />\n+        public ICollection<T> GetItems(string itemType)\n+        {\n+            if (_itemsByType.TryGetValue(itemType, out ICollection<TCached>? items))\n+            {\n+                return new ListConverter(itemType, _allItems, items);\n+            }\n+\n+            return Array.Empty<T>();\n+        }\n+\n+        /// <inheritdoc />\n+        public bool HasEmptyMarker(string itemType) => _itemsByType.Values.Any(list => list.Count == 0);\n+\n+        /// <inheritdoc />\n+        public void ImportItems(IEnumerable<T> other) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void ImportItemsOfType(string itemType, IEnumerable<T> items) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public bool Remove(T projectItem) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void RemoveItems(IEnumerable<T> other) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void Replace(T existingItem, T newItem) => throw new NotSupportedException();\n+\n+        private static T? GetInstance(TCached item)\n+        {\n+            if (item is IImmutableInstanceProvider<T> instanceProvider)\n+            {\n+                return instanceProvider.ImmutableInstance;\n+            }\n+\n+            return null;\n+        }\n+\n+        private class ListConverter : ICollection<T>\n+        {\n+            private readonly string _itemType;\n+            private readonly ICollection<T> _allItems;\n+            private readonly ICollection<TCached> _list;\n+\n+            public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCached> list)\n+            {\n+                _itemType = itemType;\n+                _allItems = allItems;\n+                _list = list;\n+            }\n+\n+            public int Count => _list.Count;\n+\n+            public bool IsReadOnly => true;\n+\n+            public void Add(T item) => throw new NotSupportedException();\n+\n+            public void Clear() => throw new NotSupportedException();\n+\n+            public bool Remove(T item) => throw new NotSupportedException();\n+\n+            public bool Contains(T item)\n+            {\n+                return MSBuildNameIgnoreCaseComparer.Default.Equals(item.Key, _itemType) &&\n+                       _allItems.Contains(item);\n+            }\n+\n+            public void CopyTo(T[] array, int arrayIndex)\n+            {\n+                if (array == null)\n+                {\n+                    throw new ArgumentNullException(nameof(array));\n+                }\n+\n+                if (arrayIndex < 0 || arrayIndex >= array.Length)\n+                {\n+                    throw new ArgumentOutOfRangeException(nameof(arrayIndex));\n+                }\n+\n+                int currentIndex = arrayIndex;\n+                foreach (var item in _list)\n+                {\n+                    T? instance = GetInstance(item);\n+                    if (instance != null)\n+                    {\n+                        array[currentIndex] = instance;\n+                        ++currentIndex;\n+                        if (currentIndex == array.Length)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: this casting seems to be redundant",
              "createdAt": "2023-11-20T11:41:26Z",
              "path": "src/Build/Instance/ProjectInstance.cs",
              "diffHunk": "@@ -388,6 +390,83 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)\n             _isImmutable = immutable;\n         }\n \n+        /// <summary>\n+        /// Creates a ProjectInstance from an immutable <see cref=\"Project\"/>.\n+        /// The resulting <see cref=\"ProjectInstance\"/> object wraps the <see cref=\"Project\"/>\n+        /// object. Unlike the ProjectInstance(Project project, ProjectInstanceSettings settings)\n+        /// constructor, the properties and items are not cloned.\n+        /// </summary>\n+        /// <param name=\"linkedProject\">The immutable <see cref=\"Project\"/>.</param>\n+        /// <param name=\"fastItemLookupNeeded\">Whether the fast item lookup cache is required.</param>\n+        private ProjectInstance(Project linkedProject, bool fastItemLookupNeeded)\n+        {\n+            ErrorUtilities.VerifyThrowInternalNull(linkedProject, nameof(linkedProject));\n+\n+            var projectPath = linkedProject.FullPath;\n+            _directory = Path.GetDirectoryName(projectPath);\n+            _projectFileLocation = ElementLocation.Create(projectPath);\n+            _hostServices = linkedProject.ProjectCollection.HostServices;\n+            _isImmutable = true;\n+\n+            EvaluationId = linkedProject.EvaluationCounter;\n+\n+            // ProjectProperties\n+            InitializeImmutableProjectPropertyInstances(linkedProject.Properties);\n+            var projectPropertiesConverter = GetImmutableElementCollectionConverter<ProjectProperty, ProjectPropertyInstance>(linkedProject.Properties);\n+            _properties = new PropertyDictionary<ProjectPropertyInstance>(projectPropertiesConverter);\n+\n+            // ProjectItemDefinitions\n+            InitializeImmutableProjectItemDefinitionInstances(linkedProject.ItemDefinitions);\n+            _itemDefinitions = GetImmutableElementCollectionConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(linkedProject.ItemDefinitions);\n+\n+            // ProjectItems\n+            InitializeImmutableProjectItemInstances(linkedProject.Items);\n+            var itemsByType = linkedProject.Items as IDictionary<string, ICollection<ProjectItem>>;\n+            var allItems = linkedProject.Items as ICollection<ProjectItem>;",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This may be worth pulling into a private helper to be called from `Add` and `AddRange`.",
              "createdAt": "2023-11-21T09:31:58Z",
              "path": "src/Build/Collections/ItemDictionary.cs",
              "diffHunk": "@@ -241,15 +241,33 @@ internal void Add(T projectItem)\n             }\n         }\n \n+        public void AddRange(IEnumerable<T> projectItems)\n+        {\n+            lock (_itemLists)\n+            {\n+                foreach (var projectItem in projectItems)\n+                {\n+                    if (!_itemLists.TryGetValue(projectItem.Key, out LinkedList<T> list))\n+                    {\n+                        list = new LinkedList<T>();\n+                        _itemLists[projectItem.Key] = list;\n+                    }\n+\n+                    LinkedListNode<T> node = list.AddLast(projectItem);\n+                    _nodes.Add(projectItem, node);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `sealed`",
              "createdAt": "2023-11-21T09:45:58Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,278 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    /// <summary>\n+    /// A specialized collection used when element data originates in an immutable Project.\n+    /// </summary>\n+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>\n+        where T : class, IKeyed\n+    {\n+        private readonly IDictionary<string, TCached> _projectElements;\n+        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;\n+        private readonly ValuesCollection _values;\n+\n+        public ImmutableElementCollectionConverter(\n+            IDictionary<string, TCached> projectElements,\n+            IDictionary<(string, int, int), TCached> constrainedProjectElements)\n+        {\n+            _projectElements = projectElements;\n+            _constrainedProjectElements = constrainedProjectElements;\n+            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);\n+        }\n+\n+        public T this[string key]\n+        {\n+            get => Get(key);\n+            set => throw new NotSupportedException();\n+        }\n+\n+        public int Count => _values.Count;\n+\n+        public bool IsReadOnly => true;\n+\n+        public ICollection<string> Keys => _projectElements.Keys;\n+\n+        public ICollection<T> Values => _values;\n+\n+        public void Add(T item) => throw new NotSupportedException();\n+\n+        public void Add(string key, T value) => throw new NotSupportedException();\n+\n+        public void Add(KeyValuePair<string, T> item) => throw new NotSupportedException();\n+\n+        public void Clear() => throw new NotSupportedException();\n+\n+        public bool Contains(T item) => _projectElements.ContainsKey(item.Key);\n+\n+        public bool Contains(KeyValuePair<string, T> item) => _projectElements.ContainsKey(item.Key);\n+\n+        public bool ContainsKey(string key) => _projectElements.ContainsKey(key);\n+\n+        public void CopyTo(T[] array) => _values.CopyTo(array, arrayIndex: 0);\n+\n+        public void CopyTo(T[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);\n+\n+        public void CopyTo(T[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);\n+\n+        public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);\n+\n+        public T Get(string key) => _values.Get(key);\n+\n+        public T Get(string key, int index, int length) => _values.Get(key, index, length);\n+\n+        public IEnumerator<T> GetEnumerator() => _values.GetEnumerator();\n+\n+        public void GetObjectData(SerializationInfo info, StreamingContext context) => throw new NotSupportedException();\n+\n+        public void OnDeserialization(object sender) => throw new NotSupportedException();\n+\n+        public bool Remove(T item) => throw new NotSupportedException();\n+\n+        public bool Remove(string key) => throw new NotSupportedException();\n+\n+        public bool Remove(KeyValuePair<string, T> item) => throw new NotSupportedException();\n+\n+        public void TrimExcess()\n+        {\n+        }\n+\n+        public bool TryGetValue(string key, out T value) => _values.TryGetValue(key, out value);\n+\n+        public void UnionWith(IEnumerable<T> other) => throw new NotSupportedException();\n+\n+        IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator() => _values.GetKvpEnumerator();\n+\n+        IEnumerator IEnumerable.GetEnumerator() => _values.GetEnumerator();\n+\n+        /// <summary>\n+        /// Wraps the Project's values.\n+        /// </summary>\n+        private class ValuesCollection : ICollection<T>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `sealed`",
              "createdAt": "2023-11-21T09:46:26Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs",
              "diffHunk": "@@ -0,0 +1,278 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n+using System.Runtime.Serialization;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    /// <summary>\n+    /// A specialized collection used when element data originates in an immutable Project.\n+    /// </summary>\n+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `sealed`",
              "createdAt": "2023-11-21T09:46:50Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs",
              "diffHunk": "@@ -0,0 +1,232 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    /// <summary>\n+    /// A specialized collection used when item data originates in an immutable Project.\n+    /// </summary>\n+    internal class ImmutableItemDictionary<TCached, T> : IItemDictionary<T>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `sealed`",
              "createdAt": "2023-11-21T09:47:42Z",
              "path": "src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs",
              "diffHunk": "@@ -0,0 +1,232 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Execution;\n+\n+namespace Microsoft.Build.Instance\n+{\n+    /// <summary>\n+    /// A specialized collection used when item data originates in an immutable Project.\n+    /// </summary>\n+    internal class ImmutableItemDictionary<TCached, T> : IItemDictionary<T>\n+        where T : class, IKeyed, IItem\n+    {\n+        private readonly IDictionary<string, ICollection<TCached>> _itemsByType;\n+        private readonly ICollection<T> _allItems;\n+\n+        public ImmutableItemDictionary(IDictionary<string, ICollection<TCached>> itemsByType, ICollection<TCached> allItems)\n+        {\n+            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));\n+\n+            if (allItems == null)\n+            {\n+                throw new ArgumentNullException(nameof(allItems));\n+            }\n+\n+            var convertedItems = new HashSet<T>(allItems.Count);\n+            foreach (var item in allItems)\n+            {\n+                T? instance = GetInstance(item);\n+                if (instance != null)\n+                {\n+                    convertedItems.Add(instance);\n+                }\n+            }\n+            _allItems = new ReadOnlyCollection<T>(convertedItems);\n+        }\n+\n+        /// <inheritdoc />\n+        public ICollection<T> this[string itemType]\n+        {\n+            get\n+            {\n+                if (!_itemsByType.TryGetValue(itemType, out ICollection<TCached>? list))\n+                {\n+                    return Array.Empty<T>();\n+                }\n+\n+                return new ListConverter(itemType, _allItems, list);\n+            }\n+        }\n+\n+        /// <inheritdoc />\n+        public int Count => _allItems.Count;\n+\n+        /// <inheritdoc />\n+        public ICollection<string> ItemTypes => _itemsByType.Keys;\n+\n+        /// <inheritdoc />\n+        public void Add(T projectItem) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void AddEmptyMarker(string itemType) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void AddRange(IEnumerable<T> projectItems) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void Clear() => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public bool Contains(T projectItem) => _allItems.Contains(projectItem);\n+\n+        /// <inheritdoc />\n+        public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)\n+        {\n+            foreach (var kvp in _itemsByType)\n+            {\n+                if (kvp.Value == null || kvp.Value.Count == 0)\n+                {\n+                    // skip empty markers\n+                    continue;\n+                }\n+\n+                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, _allItems, kvp.Value));\n+            }\n+        }\n+\n+        /// <inheritdoc />\n+        public IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector)\n+        {\n+            foreach (var item in _allItems)\n+            {\n+                yield return selector(item);\n+            }\n+        }\n+\n+        /// <inheritdoc />\n+        public IEnumerator<T> GetEnumerator() => _allItems.GetEnumerator();\n+\n+        /// <inheritdoc />\n+        IEnumerator IEnumerable.GetEnumerator() => _allItems.GetEnumerator();\n+\n+        /// <inheritdoc />\n+        public ICollection<T> GetItems(string itemType)\n+        {\n+            if (_itemsByType.TryGetValue(itemType, out ICollection<TCached>? items))\n+            {\n+                return new ListConverter(itemType, _allItems, items);\n+            }\n+\n+            return Array.Empty<T>();\n+        }\n+\n+        /// <inheritdoc />\n+        public bool HasEmptyMarker(string itemType) => _itemsByType.Values.Any(list => list.Count == 0);\n+\n+        /// <inheritdoc />\n+        public void ImportItems(IEnumerable<T> other) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void ImportItemsOfType(string itemType, IEnumerable<T> items) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public bool Remove(T projectItem) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void RemoveItems(IEnumerable<T> other) => throw new NotSupportedException();\n+\n+        /// <inheritdoc />\n+        public void Replace(T existingItem, T newItem) => throw new NotSupportedException();\n+\n+        private static T? GetInstance(TCached item)\n+        {\n+            if (item is IImmutableInstanceProvider<T> instanceProvider)\n+            {\n+                return instanceProvider.ImmutableInstance;\n+            }\n+\n+            return null;\n+        }\n+\n+        private class ListConverter : ICollection<T>",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      }
    ]
  }
}