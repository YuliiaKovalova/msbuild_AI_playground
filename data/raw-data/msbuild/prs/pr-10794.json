{
  "number": 10794,
  "title": ".SLNX format support",
  "body": "Fixes #10266\r\n\r\n### Context\r\nWe currently use our own parser SolutionFile.Parse() to parse .sln files in order to build them.\r\nIn this PR I intergrate the new package Microsoft.VisualStudio.SolutionPersistence to parse the new format .slnx files.\r\n\r\nKey differences in the SolutionFile from the package's SolutionModel:\r\n\r\n1. ProjectsInOrder and ProjectsByGuid no loner include solution folders because they are saved separately (in the package SolutionModel.SolutionProjects and SolutionModel.SolutionFolders)\r\n2. SolutionConfigurations are not available in the SolutionModel, instead there are BuildTypes and Platforms. Since SolutionConfigurations are used in SolutionGenerator a lot, I needed SolutionConfigurations represented accurately. Combination of SoutionModel's BuildTypes and Platforms might be redundant, so I collect Solution configurations from each project's configurations.\r\n\r\n### Changes Made\r\n\r\n\r\n### Testing\r\n1. Added tests in SolutionFile_Tests that cover .slnx cases\r\n2. Added SolutionFile_NewParser_Tests with only one test for parse website properties as it was not possible to do that in SolutionFile_Tests because AspNetConfigurations is internal.\r\n3. Tested manually as well.\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2024-10-10T18:06:04Z",
  "updatedAt": "2024-12-11T11:22:58Z",
  "closedAt": "2024-10-17T06:12:02Z",
  "mergedAt": "2024-10-17T06:12:02Z",
  "additions": 932,
  "deletions": 191,
  "changedFiles": 14,
  "headRefName": "slnx-support-first",
  "isDraft": false,
  "author": {
    "login": "surayya-MS"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "3d1897d01f866859663b27166f378612677da74f",
          "message": "include SolutionPersistence package",
          "committedDate": "2024-10-10T17:44:59Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "86f4847d83c2c486d1139845455e514d05299010",
          "message": "add slnx in XMake.ProcessProjectSwitch",
          "committedDate": "2024-10-10T17:44:59Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8a60719fbd240228022c962e12ddc9d8d87aa55e",
          "message": "support for .slnx format",
          "committedDate": "2024-10-10T17:44:59Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e734a1bd46afb0ea10623a0d6ada12b79b7dc316",
          "message": "small fix",
          "committedDate": "2024-10-10T18:05:09Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "32bc09f06c580cd521fa8df93b879a5c5915e0b6",
          "message": "update package",
          "committedDate": "2024-10-10T18:09:58Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9fd5e8cdeb366bfd45a967b688f5bb6d22f44c24",
          "message": "fix comment",
          "committedDate": "2024-10-11T12:49:30Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "221fb65b09784fa5fca88afda58d730d427ee2ef",
          "message": "Apply suggestions from code review\r\n\r\ncommit suggestions\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>\nCo-authored-by: Jan Krivanek <krivanek.j@hotmail.com>",
          "committedDate": "2024-10-11T13:27:33Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "114938397+surayya-MS@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "62ed51578b236b41c764e92ed480bcb93cc57631",
          "message": "fix error message",
          "committedDate": "2024-10-11T13:28:15Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9c2002fd00e52744de87fa51998ac2d99c3d36fa",
          "message": "move package version",
          "committedDate": "2024-10-11T13:28:25Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c30f7c01fe54ef006698394b1db51ca76afe1275",
          "message": "apply suggestions",
          "committedDate": "2024-10-11T13:30:17Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "94130b93e5ae82332b17243fa6cb9a050f9ff17e",
          "message": "remove comment",
          "committedDate": "2024-10-11T13:52:27Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "09a5a7b6b036605abee3e4226ea25653d5cb0f2a",
          "message": "small fix",
          "committedDate": "2024-10-11T13:57:28Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "63be4f4700b20ae5c8c82d94537e1b3f75fbd581",
          "message": "small change in xmake tests",
          "committedDate": "2024-10-11T14:49:03Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "73b84435047ad8b5b66ad5ebc484dc01a1be426d",
          "message": "apply same suggestion to the other xmake tests",
          "committedDate": "2024-10-11T14:51:57Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1bd2a25da9a9526a757562fa3ce260d0a6f38419",
          "message": "refactor ParseSolutionHelper",
          "committedDate": "2024-10-11T15:18:02Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cf14602c2758be0487794e4add4554ab8c4df382",
          "message": "Bump to first nuget.org package version",
          "committedDate": "2024-10-14T22:05:17Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "415125b8acbdafcf0373a258db07dae7636bdcd5",
          "message": "fix tests for unix",
          "committedDate": "2024-10-15T12:17:24Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ccc12e1d3992a4ea0b84371ba4aa47142bc08a36",
          "message": "small fix",
          "committedDate": "2024-10-15T12:40:03Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "128bd947d4fde7f5a19403958728920ebadd1687",
          "message": "Merge branch 'main' into slnx-support-first",
          "committedDate": "2024-10-15T12:45:46Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "07d3c3563d1544f2d9e7457a7541db3c4c3c20b6",
          "message": "rename test method",
          "committedDate": "2024-10-15T12:53:16Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8a67d7a35356756fcb79cf84f6845897683119ab",
          "message": "fix unix tests",
          "committedDate": "2024-10-15T14:55:09Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7594edfc5d4074cf3100552389e2becd8b3057fe",
          "message": "fix",
          "committedDate": "2024-10-15T15:30:11Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "674e2572dc4a28b2599c519b6c5b25f17f67fbed",
          "message": "fix",
          "committedDate": "2024-10-15T15:54:32Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b3ea2750a74a522bc448dbf4f69a6956887b2d57",
          "message": "add Microsoft.VisualStudio.SolutionPersistence to SourceBuildPrebuiltBaseline.xml",
          "committedDate": "2024-10-16T13:48:53Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "57169dba90e96d1d85ff49e896c7a5ba0e6c7769",
          "message": "add more details to docs comments",
          "committedDate": "2024-10-16T15:25:37Z",
          "author": {
            "name": "Surayya Huseyn Zada",
            "email": "shuseynzada@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "can replace existing .sln serializer with https://github.com/microsoft/vs-solutionpersistence/tree/main/src/Microsoft.VisualStudio.SolutionPersistence/Serializer/SlnV12",
        "createdAt": "2024-10-10T19:07:52Z",
        "author": {
          "login": "kasperk81"
        }
      },
      {
        "body": "@kasperk81 we're going to use that deserializer in a follow-up PR. We're trying to make this PR the \"minimum risk for potential backport to 9.0.1xx SDK\" change, so keeping the existing sln behavior.",
        "createdAt": "2024-10-10T19:09:56Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@surayya-MS should `fix tests for unix` handling be done in the product or does it produce expected style understood by consumer code?",
        "createdAt": "2024-10-15T12:20:58Z",
        "author": {
          "login": "kasperk81"
        }
      },
      {
        "body": "> @surayya-MS should `fix tests for unix` handling be done in the product or does it produce expected style understood by consumer code?\r\n\r\nIt's just `/` or `\\` difference.",
        "createdAt": "2024-10-15T12:41:56Z",
        "author": {
          "login": "surayya-MS"
        }
      },
      {
        "body": "Opened https://github.com/dotnet/source-build-externals/pull/392 for source build error (should be the same version as the package)",
        "createdAt": "2024-10-15T12:43:01Z",
        "author": {
          "login": "kasperk81"
        }
      },
      {
        "body": "follow-up PR to replace existing .sln parser with `Microsoft.VisualStudio.SolutionPersistence` https://github.com/dotnet/msbuild/pull/10836",
        "createdAt": "2024-10-25T16:19:25Z",
        "author": {
          "login": "surayya-MS"
        }
      },
      {
        "body": "This PR also fixes Bug #9587",
        "createdAt": "2024-11-08T14:20:24Z",
        "author": {
          "login": "jrdodds"
        }
      },
      {
        "body": "what dotnet version will this be in ?\r\n9.0.100 ?\r\n\r\n",
        "createdAt": "2024-12-11T11:16:11Z",
        "author": {
          "login": "softlion"
        }
      },
      {
        "body": "9.0.200 see https://github.com/dotnet/sdk/issues/40913",
        "createdAt": "2024-12-11T11:22:51Z",
        "author": {
          "login": "kasperk81"
        }
      },
      {
        "body": "> what dotnet version will this be in ? 9.0.100 ?\r\n\r\n`9.0.100` is already out; SLNX support is slated for `9.0.200`.",
        "createdAt": "2024-12-11T11:22:57Z",
        "author": {
          "login": "chucker"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This would match SLNF solution filter files too. Even if that's the intent (the comment above indicates otherwise), it might also inadvertently match any future file extensions that might start with SLN and end with another letter other than X and F. I think explicit matching would be better even if SLNF are included.",
              "createdAt": "2024-10-10T18:27:17Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3552,8 +3552,8 @@ internal static string ProcessProjectSwitch(\n                     }\n                 }\n \n-                // Get all files in the current directory that have a sln extension\n-                string[] potentialSolutionFiles = getFiles(projectDirectory ?? \".\", \"*.sln\");\n+                // Get all files in the current directory that have a sln or slnx extension\n+                string[] potentialSolutionFiles = getFiles(projectDirectory ?? \".\", \"*.sln?\");",
              "author": {
                "login": "ssg"
              }
            },
            {
              "body": "It is the intent: this is \"get all the potential solution filenames\", then in the `foreach` below the code filters the list to only what this code cares about (\"is solution\" and \"is solution filter\").",
              "createdAt": "2024-10-10T18:41:23Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3552,8 +3552,8 @@ internal static string ProcessProjectSwitch(\n                     }\n                 }\n \n-                // Get all files in the current directory that have a sln extension\n-                string[] potentialSolutionFiles = getFiles(projectDirectory ?? \".\", \"*.sln\");\n+                // Get all files in the current directory that have a sln or slnx extension\n+                string[] potentialSolutionFiles = getFiles(projectDirectory ?? \".\", \"*.sln?\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "@rainersigwald Then I propose the comment to reflect that. :) ",
              "createdAt": "2024-10-10T18:48:54Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3552,8 +3552,8 @@ internal static string ProcessProjectSwitch(\n                     }\n                 }\n \n-                // Get all files in the current directory that have a sln extension\n-                string[] potentialSolutionFiles = getFiles(projectDirectory ?? \".\", \"*.sln\");\n+                // Get all files in the current directory that have a sln or slnx extension\n+                string[] potentialSolutionFiles = getFiles(projectDirectory ?? \".\", \"*.sln?\");",
              "author": {
                "login": "ssg"
              }
            },
            {
              "body": "thanks! ",
              "createdAt": "2024-10-11T13:58:27Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3552,8 +3552,8 @@ internal static string ProcessProjectSwitch(\n                     }\n                 }\n \n-                // Get all files in the current directory that have a sln extension\n-                string[] potentialSolutionFiles = getFiles(projectDirectory ?? \".\", \"*.sln\");\n+                // Get all files in the current directory that have a sln or slnx extension\n+                string[] potentialSolutionFiles = getFiles(projectDirectory ?? \".\", \"*.sln?\");",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), \"ParseSolutionFile() got a null or empty solution file.\");\r\n```",
              "createdAt": "2024-10-10T19:02:42Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,233 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (AggregateException aggregateException)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            string.Join(\" \", aggregateException.InnerExceptions.Select(inner => inner.Message)));\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }\n+            }\n+            else if (serializer == null)\n+            {\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                    new BuildEventFileInfo(FullPath),\n+                    $\"InvalidProjectFile\",\n+                    $\"No solution serializer was found for {FullPath}\");\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Maps <see cref=\"SolutionModel\"/> to <see cref=\"SolutionFile\" />.\n+        /// </summary>\n+        /// <param name=\"solutionModel\"></param>\n+        private void ReadSolutionModel(SolutionModel solutionModel)\n+        {\n+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), \"ParseSolutionFile() got a null solution file!\");",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Is this an internal error or one that an API user could hit? If internal use `ErrorUtilities.VerifyThrowInternalLength()`.",
              "createdAt": "2024-10-10T20:03:05Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,233 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (AggregateException aggregateException)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            string.Join(\" \", aggregateException.InnerExceptions.Select(inner => inner.Message)));\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }\n+            }\n+            else if (serializer == null)\n+            {\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                    new BuildEventFileInfo(FullPath),\n+                    $\"InvalidProjectFile\",\n+                    $\"No solution serializer was found for {FullPath}\");\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Maps <see cref=\"SolutionModel\"/> to <see cref=\"SolutionFile\" />.\n+        /// </summary>\n+        /// <param name=\"solutionModel\"></param>\n+        private void ReadSolutionModel(SolutionModel solutionModel)\n+        {\n+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), \"ParseSolutionFile() got a null solution file!\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "an API user can hit this by providing empty string to Solution.Parse(solutionFile)",
              "createdAt": "2024-10-11T13:18:12Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,233 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (AggregateException aggregateException)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            string.Join(\" \", aggregateException.InnerExceptions.Select(inner => inner.Message)));\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }\n+            }\n+            else if (serializer == null)\n+            {\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                    new BuildEventFileInfo(FullPath),\n+                    $\"InvalidProjectFile\",\n+                    $\"No solution serializer was found for {FullPath}\");\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Maps <see cref=\"SolutionModel\"/> to <see cref=\"SolutionFile\" />.\n+        /// </summary>\n+        /// <param name=\"solutionModel\"></param>\n+        private void ReadSolutionModel(SolutionModel solutionModel)\n+        {\n+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), \"ParseSolutionFile() got a null solution file!\");",
              "author": {
                "login": "surayya-MS"
              }
            },
            {
              "body": "It feels like it should be an `ArgumentException` right away in `SolutionFile.Parse()`. Looks like we were doing that kinda badly before since it was internal and didn't fix it when we went public.",
              "createdAt": "2024-10-11T13:38:22Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,233 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (AggregateException aggregateException)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            string.Join(\" \", aggregateException.InnerExceptions.Select(inner => inner.Message)));\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }\n+            }\n+            else if (serializer == null)\n+            {\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                    new BuildEventFileInfo(FullPath),\n+                    $\"InvalidProjectFile\",\n+                    $\"No solution serializer was found for {FullPath}\");\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Maps <see cref=\"SolutionModel\"/> to <see cref=\"SolutionFile\" />.\n+        /// </summary>\n+        /// <param name=\"solutionModel\"></param>\n+        private void ReadSolutionModel(SolutionModel solutionModel)\n+        {\n+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), \"ParseSolutionFile() got a null solution file!\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "i'll make this change in the follow-up pr, when the .sln is parsed by the new parser.",
              "createdAt": "2024-10-11T14:45:28Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,233 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (AggregateException aggregateException)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            string.Join(\" \", aggregateException.InnerExceptions.Select(inner => inner.Message)));\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }\n+            }\n+            else if (serializer == null)\n+            {\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                    new BuildEventFileInfo(FullPath),\n+                    $\"InvalidProjectFile\",\n+                    $\"No solution serializer was found for {FullPath}\");\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Maps <see cref=\"SolutionModel\"/> to <see cref=\"SolutionFile\" />.\n+        /// </summary>\n+        /// <param name=\"solutionModel\"></param>\n+        private void ReadSolutionModel(SolutionModel solutionModel)\n+        {\n+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), \"ParseSolutionFile() got a null solution file!\");",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we need to self-service push to dotnet-public feed? https://dev.azure.com/dnceng/internal/_wiki/wikis/DNCEng%20Services%20Wiki/882/Updating-the-dotnet-public-feed",
              "createdAt": "2024-10-10T19:07:15Z",
              "path": "eng/Versions.props",
              "diffHunk": "@@ -76,4 +76,8 @@\n       <FileVersion>$(VersionPrefix).$(FileVersion.Split('.')[3])</FileVersion>\n     </PropertyGroup>\n   </Target>\n+   <!-- SolutionPersistence -->\n+  <PropertyGroup>\n+\t  <MicrosoftVisualStudioSolutionPersistenceVersion>1.0.4</MicrosoftVisualStudioSolutionPersistenceVersion>",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "It's not on nuget.org yet so we'll have to either wait for that (@richardstanton?) or get a more manual push going.",
              "createdAt": "2024-10-10T19:25:27Z",
              "path": "eng/Versions.props",
              "diffHunk": "@@ -76,4 +76,8 @@\n       <FileVersion>$(VersionPrefix).$(FileVersion.Split('.')[3])</FileVersion>\n     </PropertyGroup>\n   </Target>\n+   <!-- SolutionPersistence -->\n+  <PropertyGroup>\n+\t  <MicrosoftVisualStudioSolutionPersistenceVersion>1.0.4</MicrosoftVisualStudioSolutionPersistenceVersion>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "https://github.com/microsoft/vs-solutionpersistence/blob/main/README.md has a badge linked to nuget.org, but currently it's returning 404. `dotnet nuget push` missing somewhere :)",
              "createdAt": "2024-10-11T14:52:26Z",
              "path": "eng/Versions.props",
              "diffHunk": "@@ -76,4 +76,8 @@\n       <FileVersion>$(VersionPrefix).$(FileVersion.Split('.')[3])</FileVersion>\n     </PropertyGroup>\n   </Target>\n+   <!-- SolutionPersistence -->\n+  <PropertyGroup>\n+\t  <MicrosoftVisualStudioSolutionPersistenceVersion>1.0.4</MicrosoftVisualStudioSolutionPersistenceVersion>",
              "author": {
                "login": "kasperk81"
              }
            },
            {
              "body": "@mmitche could we build and push this package to the dotnet9 feed with the suffix 1.0.0-rc? Once the official non-preview version is available on NuGet from Microsoft, we can then push that version to both the dotnet9 and dotnet10 feeds. This approach will help unblock a list of tasks to be delivered for .NET 9 after this merge: https://github.com/dotnet/sdk/issues/40913#issuecomment-2405750845.",
              "createdAt": "2024-10-14T08:17:02Z",
              "path": "eng/Versions.props",
              "diffHunk": "@@ -76,4 +76,8 @@\n       <FileVersion>$(VersionPrefix).$(FileVersion.Split('.')[3])</FileVersion>\n     </PropertyGroup>\n   </Target>\n+   <!-- SolutionPersistence -->\n+  <PropertyGroup>\n+\t  <MicrosoftVisualStudioSolutionPersistenceVersion>1.0.4</MicrosoftVisualStudioSolutionPersistenceVersion>",
              "author": {
                "login": "kasperk81"
              }
            },
            {
              "body": "@kasperk81 No, let's not do that. We'll bug the owners internally today.",
              "createdAt": "2024-10-14T14:29:16Z",
              "path": "eng/Versions.props",
              "diffHunk": "@@ -76,4 +76,8 @@\n       <FileVersion>$(VersionPrefix).$(FileVersion.Split('.')[3])</FileVersion>\n     </PropertyGroup>\n   </Target>\n+   <!-- SolutionPersistence -->\n+  <PropertyGroup>\n+\t  <MicrosoftVisualStudioSolutionPersistenceVersion>1.0.4</MicrosoftVisualStudioSolutionPersistenceVersion>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Move this `PackageVersion` to https://github.com/dotnet/msbuild/blob/main/eng/dependabot/Packages.props",
              "createdAt": "2024-10-10T19:24:06Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -39,6 +40,10 @@\n     <PackageReference Include=\"Microsoft.BuildXL.Processes\" Condition=\"'$(FeatureReportFileAccesses)' == 'true'\" PrivateAssets=\"all\" />\n   </ItemGroup>\n \n+  <ItemGroup>\n+    <PackageVersion Include=\"Microsoft.VisualStudio.SolutionPersistence\" Version=\"$(MicrosoftVisualStudioSolutionPersistenceVersion)\" />",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: scope the throw assertion to the exact line that's expected to throw.\r\n```suggestion\r\n            string[] projects = { \"test.proj\", \"Different.slnx\" };\r\n            string[] extensionsToIgnore = null;\r\n\r\n            Should.Throw<InitializationException>(() =>\r\n            {\r\n                IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);\r\n                MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles);\r\n            });\r\n```",
              "createdAt": "2024-10-10T19:31:14Z",
              "path": "src/MSBuild.UnitTests/XMake_Tests.cs",
              "diffHunk": "@@ -1796,6 +1814,20 @@ public void TestProcessProjectSwitchSlnProjDifferentNames()\n             });\n         }\n         /// <summary>\n+        /// Test the case where there is a .slnx and a project in the same directory but they have different names\n+        /// </summary>\n+        [Fact]\n+        public void TestProcessProjectSwitchSlnxProjDifferentNames()\n+        {\n+            Should.Throw<InitializationException>(() =>\n+            {\n+                string[] projects = { \"test.proj\", \"Different.slnx\" };\n+                string[] extensionsToIgnore = null;\n+                IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);\n+                MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles);\n+            });",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "The existing bad style you followed was because of a long-ago conversion from an assertion library that didn't support the granularity, and I didn't bother fixing everything . . . but for new code I'd like to be more precise.",
              "createdAt": "2024-10-10T19:33:59Z",
              "path": "src/MSBuild.UnitTests/XMake_Tests.cs",
              "diffHunk": "@@ -1796,6 +1814,20 @@ public void TestProcessProjectSwitchSlnProjDifferentNames()\n             });\n         }\n         /// <summary>\n+        /// Test the case where there is a .slnx and a project in the same directory but they have different names\n+        /// </summary>\n+        [Fact]\n+        public void TestProcessProjectSwitchSlnxProjDifferentNames()\n+        {\n+            Should.Throw<InitializationException>(() =>\n+            {\n+                string[] projects = { \"test.proj\", \"Different.slnx\" };\n+                string[] extensionsToIgnore = null;\n+                IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);\n+                MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles);\n+            });",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "or more succinctly `string[] projects = [\"test.proj\", \"Different.slnx\"];` ;)",
              "createdAt": "2024-10-10T21:36:33Z",
              "path": "src/MSBuild.UnitTests/XMake_Tests.cs",
              "diffHunk": "@@ -1796,6 +1814,20 @@ public void TestProcessProjectSwitchSlnProjDifferentNames()\n             });\n         }\n         /// <summary>\n+        /// Test the case where there is a .slnx and a project in the same directory but they have different names\n+        /// </summary>\n+        [Fact]\n+        public void TestProcessProjectSwitchSlnxProjDifferentNames()\n+        {\n+            Should.Throw<InitializationException>(() =>\n+            {\n+                string[] projects = { \"test.proj\", \"Different.slnx\" };\n+                string[] extensionsToIgnore = null;\n+                IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);\n+                MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles);\n+            });",
              "author": {
                "login": "kasperk81"
              }
            },
            {
              "body": "applied the suggestion to other tests",
              "createdAt": "2024-10-11T14:52:28Z",
              "path": "src/MSBuild.UnitTests/XMake_Tests.cs",
              "diffHunk": "@@ -1796,6 +1814,20 @@ public void TestProcessProjectSwitchSlnProjDifferentNames()\n             });\n         }\n         /// <summary>\n+        /// Test the case where there is a .slnx and a project in the same directory but they have different names\n+        /// </summary>\n+        [Fact]\n+        public void TestProcessProjectSwitchSlnxProjDifferentNames()\n+        {\n+            Should.Throw<InitializationException>(() =>\n+            {\n+                string[] projects = { \"test.proj\", \"Different.slnx\" };\n+                string[] extensionsToIgnore = null;\n+                IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);\n+                MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles);\n+            });",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "extreme nit: in a test helper I'd handle the nullability like\r\n```suggestion\r\n            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(slnPath).ShouldNotBeNull();\r\n            SolutionModel solutionModel = serializer.OpenAsync(slnPath, CancellationToken.None).Result;\r\n```",
              "createdAt": "2024-10-10T19:55:05Z",
              "path": "src/Build.UnitTests/Construction/SolutionFilter_Tests.cs",
              "diffHunk": "@@ -276,6 +282,15 @@ public void ParseSolutionFilter()\n             }\n         }\n \n+        private static string ConvertToSlnx(string slnPath)\n+        {\n+            string slnxPath = slnPath + \"x\";\n+            ISolutionSerializer? serializer = SolutionSerializers.GetSerializerByMoniker(slnPath);\n+            SolutionModel solutionModel = serializer!.OpenAsync(slnPath, CancellationToken.None).Result;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Ideally we'd handle this kind of cleanup with our `TestEnvironment`, handling this with something like an `ExpectFile` that will automatically clean up on dispose. But no need to refactor now.",
              "createdAt": "2024-10-10T20:00:03Z",
              "path": "src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs",
              "diffHunk": "@@ -1053,22 +1215,37 @@ public void ParseSolutionWithComments()\n \n         /// <summary>\n         /// Helper method to create a SolutionFile object, and call it to parse the SLN file\n-        /// represented by the string contents passed in.\n+        /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.\n         /// </summary>\n-        private static SolutionFile ParseSolutionHelper(string solutionFileContents)\n+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)\n         {\n             solutionFileContents = solutionFileContents.Replace('\\'', '\"');\n             string solutionPath = FileUtilities.GetTemporaryFileName(\".sln\");\n-\n+            string slnxPath = solutionPath + \"x\";\n             try\n             {\n                 File.WriteAllText(solutionPath, solutionFileContents);\n-                SolutionFile sp = SolutionFile.Parse(solutionPath);\n-                return sp;\n+                if (convertToSlnx)\n+                {\n+                    ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(solutionPath);\n+                    SolutionModel solutionModel = serializer.OpenAsync(solutionPath, CancellationToken.None).Result;\n+                    SolutionSerializers.SlnXml.SaveAsync(slnxPath, solutionModel, CancellationToken.None).Wait();\n+\n+                    SolutionFile slnx = SolutionFile.Parse(slnxPath);\n+                    return slnx;\n+                }\n+\n+                SolutionFile sln = SolutionFile.Parse(solutionPath);\n+                return sln;\n             }\n             finally\n             {\n                 File.Delete(solutionPath);\n+\n+                if (convertToSlnx)\n+                {\n+                    File.Delete(slnxPath);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "done",
              "createdAt": "2024-10-11T15:18:16Z",
              "path": "src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs",
              "diffHunk": "@@ -1053,22 +1215,37 @@ public void ParseSolutionWithComments()\n \n         /// <summary>\n         /// Helper method to create a SolutionFile object, and call it to parse the SLN file\n-        /// represented by the string contents passed in.\n+        /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.\n         /// </summary>\n-        private static SolutionFile ParseSolutionHelper(string solutionFileContents)\n+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)\n         {\n             solutionFileContents = solutionFileContents.Replace('\\'', '\"');\n             string solutionPath = FileUtilities.GetTemporaryFileName(\".sln\");\n-\n+            string slnxPath = solutionPath + \"x\";\n             try\n             {\n                 File.WriteAllText(solutionPath, solutionFileContents);\n-                SolutionFile sp = SolutionFile.Parse(solutionPath);\n-                return sp;\n+                if (convertToSlnx)\n+                {\n+                    ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(solutionPath);\n+                    SolutionModel solutionModel = serializer.OpenAsync(solutionPath, CancellationToken.None).Result;\n+                    SolutionSerializers.SlnXml.SaveAsync(slnxPath, solutionModel, CancellationToken.None).Wait();\n+\n+                    SolutionFile slnx = SolutionFile.Parse(slnxPath);\n+                    return slnx;\n+                }\n+\n+                SolutionFile sln = SolutionFile.Parse(solutionPath);\n+                return sln;\n             }\n             finally\n             {\n                 File.Delete(solutionPath);\n+\n+                if (convertToSlnx)\n+                {\n+                    File.Delete(slnxPath);",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think I understand why this is per-project, rather than derivable from `buildTypes` and `platforms`. Is it because the full matrix may not exist, so doing this here ensures that only relevant combos are present?",
              "createdAt": "2024-10-10T20:20:23Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,233 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (AggregateException aggregateException)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            string.Join(\" \", aggregateException.InnerExceptions.Select(inner => inner.Message)));\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }\n+            }\n+            else if (serializer == null)\n+            {\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                    new BuildEventFileInfo(FullPath),\n+                    $\"InvalidProjectFile\",\n+                    $\"No solution serializer was found for {FullPath}\");\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Maps <see cref=\"SolutionModel\"/> to <see cref=\"SolutionFile\" />.\n+        /// </summary>\n+        /// <param name=\"solutionModel\"></param>\n+        private void ReadSolutionModel(SolutionModel solutionModel)\n+        {\n+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), \"ParseSolutionFile() got a null solution file!\");\n+            ErrorUtilities.VerifyThrowInternalRooted(_solutionFile);\n+\n+            _projectsByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);\n+            _solutionFoldersByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);\n+            _projectsInOrder = new List<ProjectInSolution>();\n+            ContainsWebProjects = false;\n+            Version = 0;\n+            _currentLineNumber = 0;\n+            _solutionConfigurationsByFullName = new Dictionary<string, SolutionConfigurationInSolution>();\n+            _defaultConfigurationName = null;\n+            _defaultPlatformName = null;\n+\n+            _currentVisualStudioVersion = solutionModel.VisualStudioProperties.Version;\n+\n+            ReadProjects(solutionModel);\n+\n+            // We need to save the solution folders in order to cache the unique project names and check for duplicates.\n+            ReadSolutionFolders(solutionModel);\n+\n+            if (_solutionFilter != null)\n+            {\n+                ValidateProjectsInSolutionFilter();\n+            }\n+\n+            CacheUniqueProjectNamesAndCheckForDuplicates();\n+        }\n+\n+        private void ReadProjects(SolutionModel solutionModel)\n+        {\n+            foreach (SolutionProjectModel projectModel in solutionModel.SolutionProjects)\n+            {\n+                var proj = new ProjectInSolution(this)\n+                {\n+                    ProjectName = GetProjectName(projectModel),\n+                    RelativePath = projectModel.FilePath,\n+                    ProjectGuid = ToProjectGuidFormat(projectModel.Id),\n+                };\n+\n+                // If the project name is empty the new parser throws an error.\n+\n+                // Validate project relative path\n+                ValidateProjectRelativePath(proj);\n+\n+                SetProjectType(proj, ToProjectGuidFormat(projectModel.TypeId));\n+\n+                SetProjectDependencies(proj, projectModel);\n+\n+                SetWebsiteProperties(proj, projectModel);\n+\n+                // Note: This is corresponds to GlobalSection(NestedProjects) section in sln files.\n+                if (projectModel.Parent != null)\n+                {\n+                    proj.ParentProjectGuid = ToProjectGuidFormat(projectModel.Parent.Id);\n+                }\n+\n+                SetProjectConfigurations(proj, projectModel, solutionModel.BuildTypes, solutionModel.Platforms);\n+\n+                // Add the project to the collection\n+                AddProjectToSolution(proj);\n+\n+                // If the project is an etp project then parse the etp project file\n+                // to get the projects contained in it.\n+                if (IsEtpProjectFile(proj.RelativePath))\n+                {\n+                    ParseEtpProject(proj);\n+                }\n+            }\n+        }\n+\n+        private string GetProjectName(SolutionProjectModel projectModel)\n+            => !string.IsNullOrEmpty(projectModel.DisplayName) ? projectModel.DisplayName : projectModel.ActualDisplayName;\n+\n+        /// <summary>\n+        /// Returns a string from Guid in the format \"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\".\n+        /// </summary>\n+        private static string ToProjectGuidFormat(Guid id) => id.ToString(\"B\").ToUpper();\n+\n+        private void SetProjectDependencies(ProjectInSolution proj, SolutionProjectModel projectModel)\n+        {\n+            if (projectModel.Dependencies == null)\n+            {\n+                return;\n+            }\n+\n+            foreach (var dependency in projectModel.Dependencies)\n+            {\n+                proj.AddDependency(ToProjectGuidFormat(dependency.Id));\n+            }\n+        }\n+\n+        private void SetWebsiteProperties(ProjectInSolution proj, SolutionProjectModel projectModel)\n+        {\n+            SolutionPropertyBag websiteProperties = projectModel?.Properties.FirstOrDefault(p => p.Id == \"WebsiteProperties\");\n+\n+            if (websiteProperties is null)\n+            {\n+                return;\n+            }\n+\n+            foreach (var property in websiteProperties)\n+            {\n+                ParseAspNetCompilerProperty(proj, property.Key, property.Value);\n+            }\n         }\n \n+        private void SetProjectConfigurations(\n+            ProjectInSolution proj,\n+            SolutionProjectModel projectModel,\n+            IReadOnlyList<string> buildTypes,\n+            IReadOnlyList<string> platforms)\n+        {\n+            foreach (string solutionBuildType in buildTypes)\n+            {\n+                foreach (string solutionPlatform in platforms)\n+                {\n+                    // isBuild represents Build.0. The \"Build.0\" entry tells us whether to build the project configuration in the given solution configuration\n+                    // _ argument represents Deploy.0 which we do not use in the old parser\n+                    (string projectBuildType, string projectPlatform, bool isBuild, bool _) = projectModel.GetProjectConfiguration(solutionBuildType, solutionPlatform);\n+\n+                    if (projectBuildType == null || projectPlatform == null)\n+                    {\n+                        continue;\n+                    }\n+\n+                    var projectConfiguration = new ProjectConfigurationInSolution(\n+                                projectBuildType,\n+                                projectPlatform,\n+                                isBuild);\n+\n+                    string configurationName = SolutionConfigurationInSolution.ComputeFullName(solutionBuildType, solutionPlatform);\n+\n+                    proj.SetProjectConfiguration(configurationName, projectConfiguration);\n+\n+                    // There are no solution configurations in the new parser. Instead we collect them from each project's configurations.\n+                    AddSolutionConfiguration(solutionBuildType, solutionPlatform);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "that's exactly right. example :\r\n```\r\nGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n    Debug|ARM = Debug|ARM\r\n    Debug|Any CPU = Debug|Any CPU\r\n    Debug|Win32 = Debug|Win32\r\n    Release|Any CPU = Release|Any CPU\r\n    Release|Win32 = Release|Win32\r\nEndGlobalSection\r\n```\r\n`BuildTypes = Debug, Release`, `PlatformTypes = ARM, Any CPU, Win32`\r\nIf we make SolutionConfigurations = all combinations of BuildTypes and PlatformTypes, then there is \"Release|ARM\" which is not a solution config in the file\r\n\r\n",
              "createdAt": "2024-10-11T13:49:50Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,233 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (AggregateException aggregateException)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            string.Join(\" \", aggregateException.InnerExceptions.Select(inner => inner.Message)));\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }\n+            }\n+            else if (serializer == null)\n+            {\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                    new BuildEventFileInfo(FullPath),\n+                    $\"InvalidProjectFile\",\n+                    $\"No solution serializer was found for {FullPath}\");\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Maps <see cref=\"SolutionModel\"/> to <see cref=\"SolutionFile\" />.\n+        /// </summary>\n+        /// <param name=\"solutionModel\"></param>\n+        private void ReadSolutionModel(SolutionModel solutionModel)\n+        {\n+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), \"ParseSolutionFile() got a null solution file!\");\n+            ErrorUtilities.VerifyThrowInternalRooted(_solutionFile);\n+\n+            _projectsByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);\n+            _solutionFoldersByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);\n+            _projectsInOrder = new List<ProjectInSolution>();\n+            ContainsWebProjects = false;\n+            Version = 0;\n+            _currentLineNumber = 0;\n+            _solutionConfigurationsByFullName = new Dictionary<string, SolutionConfigurationInSolution>();\n+            _defaultConfigurationName = null;\n+            _defaultPlatformName = null;\n+\n+            _currentVisualStudioVersion = solutionModel.VisualStudioProperties.Version;\n+\n+            ReadProjects(solutionModel);\n+\n+            // We need to save the solution folders in order to cache the unique project names and check for duplicates.\n+            ReadSolutionFolders(solutionModel);\n+\n+            if (_solutionFilter != null)\n+            {\n+                ValidateProjectsInSolutionFilter();\n+            }\n+\n+            CacheUniqueProjectNamesAndCheckForDuplicates();\n+        }\n+\n+        private void ReadProjects(SolutionModel solutionModel)\n+        {\n+            foreach (SolutionProjectModel projectModel in solutionModel.SolutionProjects)\n+            {\n+                var proj = new ProjectInSolution(this)\n+                {\n+                    ProjectName = GetProjectName(projectModel),\n+                    RelativePath = projectModel.FilePath,\n+                    ProjectGuid = ToProjectGuidFormat(projectModel.Id),\n+                };\n+\n+                // If the project name is empty the new parser throws an error.\n+\n+                // Validate project relative path\n+                ValidateProjectRelativePath(proj);\n+\n+                SetProjectType(proj, ToProjectGuidFormat(projectModel.TypeId));\n+\n+                SetProjectDependencies(proj, projectModel);\n+\n+                SetWebsiteProperties(proj, projectModel);\n+\n+                // Note: This is corresponds to GlobalSection(NestedProjects) section in sln files.\n+                if (projectModel.Parent != null)\n+                {\n+                    proj.ParentProjectGuid = ToProjectGuidFormat(projectModel.Parent.Id);\n+                }\n+\n+                SetProjectConfigurations(proj, projectModel, solutionModel.BuildTypes, solutionModel.Platforms);\n+\n+                // Add the project to the collection\n+                AddProjectToSolution(proj);\n+\n+                // If the project is an etp project then parse the etp project file\n+                // to get the projects contained in it.\n+                if (IsEtpProjectFile(proj.RelativePath))\n+                {\n+                    ParseEtpProject(proj);\n+                }\n+            }\n+        }\n+\n+        private string GetProjectName(SolutionProjectModel projectModel)\n+            => !string.IsNullOrEmpty(projectModel.DisplayName) ? projectModel.DisplayName : projectModel.ActualDisplayName;\n+\n+        /// <summary>\n+        /// Returns a string from Guid in the format \"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\".\n+        /// </summary>\n+        private static string ToProjectGuidFormat(Guid id) => id.ToString(\"B\").ToUpper();\n+\n+        private void SetProjectDependencies(ProjectInSolution proj, SolutionProjectModel projectModel)\n+        {\n+            if (projectModel.Dependencies == null)\n+            {\n+                return;\n+            }\n+\n+            foreach (var dependency in projectModel.Dependencies)\n+            {\n+                proj.AddDependency(ToProjectGuidFormat(dependency.Id));\n+            }\n+        }\n+\n+        private void SetWebsiteProperties(ProjectInSolution proj, SolutionProjectModel projectModel)\n+        {\n+            SolutionPropertyBag websiteProperties = projectModel?.Properties.FirstOrDefault(p => p.Id == \"WebsiteProperties\");\n+\n+            if (websiteProperties is null)\n+            {\n+                return;\n+            }\n+\n+            foreach (var property in websiteProperties)\n+            {\n+                ParseAspNetCompilerProperty(proj, property.Key, property.Value);\n+            }\n         }\n \n+        private void SetProjectConfigurations(\n+            ProjectInSolution proj,\n+            SolutionProjectModel projectModel,\n+            IReadOnlyList<string> buildTypes,\n+            IReadOnlyList<string> platforms)\n+        {\n+            foreach (string solutionBuildType in buildTypes)\n+            {\n+                foreach (string solutionPlatform in platforms)\n+                {\n+                    // isBuild represents Build.0. The \"Build.0\" entry tells us whether to build the project configuration in the given solution configuration\n+                    // _ argument represents Deploy.0 which we do not use in the old parser\n+                    (string projectBuildType, string projectPlatform, bool isBuild, bool _) = projectModel.GetProjectConfiguration(solutionBuildType, solutionPlatform);\n+\n+                    if (projectBuildType == null || projectPlatform == null)\n+                    {\n+                        continue;\n+                    }\n+\n+                    var projectConfiguration = new ProjectConfigurationInSolution(\n+                                projectBuildType,\n+                                projectPlatform,\n+                                isBuild);\n+\n+                    string configurationName = SolutionConfigurationInSolution.ComputeFullName(solutionBuildType, solutionPlatform);\n+\n+                    proj.SetProjectConfiguration(configurationName, projectConfiguration);\n+\n+                    // There are no solution configurations in the new parser. Instead we collect them from each project's configurations.\n+                    AddSolutionConfiguration(solutionBuildType, solutionPlatform);",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: doc _why_ not just what. In this case I think that's:\r\n\r\n```suggestion\r\n        /// Returns a string from Guid in the format that the old MSBuild solution parser returned.\r\n```",
              "createdAt": "2024-10-10T20:21:52Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,233 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (AggregateException aggregateException)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            string.Join(\" \", aggregateException.InnerExceptions.Select(inner => inner.Message)));\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }\n+            }\n+            else if (serializer == null)\n+            {\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                    new BuildEventFileInfo(FullPath),\n+                    $\"InvalidProjectFile\",\n+                    $\"No solution serializer was found for {FullPath}\");\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Maps <see cref=\"SolutionModel\"/> to <see cref=\"SolutionFile\" />.\n+        /// </summary>\n+        /// <param name=\"solutionModel\"></param>\n+        private void ReadSolutionModel(SolutionModel solutionModel)\n+        {\n+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), \"ParseSolutionFile() got a null solution file!\");\n+            ErrorUtilities.VerifyThrowInternalRooted(_solutionFile);\n+\n+            _projectsByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);\n+            _solutionFoldersByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);\n+            _projectsInOrder = new List<ProjectInSolution>();\n+            ContainsWebProjects = false;\n+            Version = 0;\n+            _currentLineNumber = 0;\n+            _solutionConfigurationsByFullName = new Dictionary<string, SolutionConfigurationInSolution>();\n+            _defaultConfigurationName = null;\n+            _defaultPlatformName = null;\n+\n+            _currentVisualStudioVersion = solutionModel.VisualStudioProperties.Version;\n+\n+            ReadProjects(solutionModel);\n+\n+            // We need to save the solution folders in order to cache the unique project names and check for duplicates.\n+            ReadSolutionFolders(solutionModel);\n+\n+            if (_solutionFilter != null)\n+            {\n+                ValidateProjectsInSolutionFilter();\n+            }\n+\n+            CacheUniqueProjectNamesAndCheckForDuplicates();\n+        }\n+\n+        private void ReadProjects(SolutionModel solutionModel)\n+        {\n+            foreach (SolutionProjectModel projectModel in solutionModel.SolutionProjects)\n+            {\n+                var proj = new ProjectInSolution(this)\n+                {\n+                    ProjectName = GetProjectName(projectModel),\n+                    RelativePath = projectModel.FilePath,\n+                    ProjectGuid = ToProjectGuidFormat(projectModel.Id),\n+                };\n+\n+                // If the project name is empty the new parser throws an error.\n+\n+                // Validate project relative path\n+                ValidateProjectRelativePath(proj);\n+\n+                SetProjectType(proj, ToProjectGuidFormat(projectModel.TypeId));\n+\n+                SetProjectDependencies(proj, projectModel);\n+\n+                SetWebsiteProperties(proj, projectModel);\n+\n+                // Note: This is corresponds to GlobalSection(NestedProjects) section in sln files.\n+                if (projectModel.Parent != null)\n+                {\n+                    proj.ParentProjectGuid = ToProjectGuidFormat(projectModel.Parent.Id);\n+                }\n+\n+                SetProjectConfigurations(proj, projectModel, solutionModel.BuildTypes, solutionModel.Platforms);\n+\n+                // Add the project to the collection\n+                AddProjectToSolution(proj);\n+\n+                // If the project is an etp project then parse the etp project file\n+                // to get the projects contained in it.\n+                if (IsEtpProjectFile(proj.RelativePath))\n+                {\n+                    ParseEtpProject(proj);\n+                }\n+            }\n+        }\n+\n+        private string GetProjectName(SolutionProjectModel projectModel)\n+            => !string.IsNullOrEmpty(projectModel.DisplayName) ? projectModel.DisplayName : projectModel.ActualDisplayName;\n+\n+        /// <summary>\n+        /// Returns a string from Guid in the format \"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\".",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Consider a new localized string \"UnrecognizedSolutionFormat\" or similar. Though actually that makes the backport hard so maybe don't consider it too hard.",
              "createdAt": "2024-10-10T20:24:22Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,233 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (AggregateException aggregateException)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            string.Join(\" \", aggregateException.InnerExceptions.Select(inner => inner.Message)));\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }\n+            }\n+            else if (serializer == null)\n+            {\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                    new BuildEventFileInfo(FullPath),\n+                    $\"InvalidProjectFile\",\n+                    $\"No solution serializer was found for {FullPath}\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "i'll do this in the follow-up PR then",
              "createdAt": "2024-10-11T13:53:43Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,233 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (AggregateException aggregateException)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            string.Join(\" \", aggregateException.InnerExceptions.Select(inner => inner.Message)));\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }\n+            }\n+            else if (serializer == null)\n+            {\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                    new BuildEventFileInfo(FullPath),\n+                    $\"InvalidProjectFile\",\n+                    $\"No solution serializer was found for {FullPath}\");",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Important to actually do this?",
              "createdAt": "2024-10-10T20:28:09Z",
              "path": "src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs",
              "diffHunk": "@@ -0,0 +1,166 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Shared;\n+using Microsoft.VisualStudio.SolutionPersistence;\n+using Microsoft.VisualStudio.SolutionPersistence.Model;\n+using Microsoft.VisualStudio.SolutionPersistence.Serializer;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.UnitTests.Construction\n+{\n+    public class SolutionFile_NewParser_Tests\n+    {\n+        public ITestOutputHelper TestOutputHelper { get; }\n+\n+        public SolutionFile_NewParser_Tests(ITestOutputHelper testOutputHelper)\n+        {\n+            TestOutputHelper = testOutputHelper;\n+        }\n+\n+        /// <summary>\n+        /// Tests to see that all the data/properties are correctly parsed out of a Venus\n+        /// project in a .SLN. This can be checked only here because of AspNetConfigurations protection level.\n+        /// </summary>\n+        [Theory]\n+        [InlineData(false)]\n+        [InlineData(true)]\n+        public void ProjectWithWebsiteProperties(bool convertToSlnx)\n+        {\n+            string solutionFileContents =\n+                \"\"\"\n+                Microsoft Visual Studio Solution File, Format Version 9.00\n+                # Visual Studio 2005\n+                Project(`{E24C65DC-7377-472B-9ABA-BC803B73C61A}`) = `C:\\WebSites\\WebApplication3\\`, `C:\\WebSites\\WebApplication3\\`, `{464FD0B9-E335-4677-BE1E-6B2F982F4D86}`\n+                    ProjectSection(WebsiteProperties) = preProject\n+                        ProjectReferences = `{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSCla;ssLibra;ry1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;`\n+                        Frontpage = false\n+                            Debug.AspNetCompiler.VirtualPath = `/publishfirst`\n+                            Debug.AspNetCompiler.PhysicalPath = `..\\rajeev\\temp\\websites\\myfirstwebsite\\`\n+                            Debug.AspNetCompiler.TargetPath = `..\\rajeev\\temp\\publishfirst\\`\n+                            Debug.AspNetCompiler.ForceOverwrite = `true`\n+                            Debug.AspNetCompiler.Updateable = `false`\n+                            Debug.AspNetCompiler.Debug = `true`\n+                            Debug.AspNetCompiler.KeyFile = `debugkeyfile.snk`\n+                            Debug.AspNetCompiler.KeyContainer = `12345.container`\n+                            Debug.AspNetCompiler.DelaySign = `true`\n+                            Debug.AspNetCompiler.AllowPartiallyTrustedCallers = `false`\n+                            Debug.AspNetCompiler.FixedNames = `debugfixednames`\n+                            Release.AspNetCompiler.VirtualPath = `/publishfirst_release`\n+                            Release.AspNetCompiler.PhysicalPath = `..\\rajeev\\temp\\websites\\myfirstwebsite_release\\`\n+                            Release.AspNetCompiler.TargetPath = `..\\rajeev\\temp\\publishfirst_release\\`\n+                            Release.AspNetCompiler.ForceOverwrite = `true`\n+                            Release.AspNetCompiler.Updateable = `true`\n+                            Release.AspNetCompiler.Debug = `false`\n+                        VWDPort = 63496\n+                    EndProjectSection\n+                EndProject\n+                Global\n+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution\n+                        Debug|.NET = Debug|.NET\n+                    EndGlobalSection\n+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution\n+                        {464FD0B9-E335-4677-BE1E-6B2F982F4D86}.Debug|.NET.ActiveCfg = Debug|.NET\n+                        {464FD0B9-E335-4677-BE1E-6B2F982F4D86}.Debug|.NET.Build.0 = Debug|.NET\n+                    EndGlobalSection\n+                    GlobalSection(SolutionProperties) = preSolution\n+                        HideSolutionNode = FALSE\n+                    EndGlobalSection\n+                EndGlobal\n+                \"\"\";\n+\n+            SolutionFile solution = ParseSolutionHelper(solutionFileContents.Replace('`', '\"'), convertToSlnx);\n+\n+            solution.ProjectsInOrder.ShouldHaveSingleItem();\n+\n+            solution.ProjectsInOrder[0].ProjectType.ShouldBe(SolutionProjectType.WebProject);\n+            solution.ProjectsInOrder[0].ProjectName.ShouldBe(@\"C:\\WebSites\\WebApplication3\\\");\n+            // TODO: try set Relative path with a port http://localhost:8080/WebSites/WebApplication3/",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "no, i'll remove it",
              "createdAt": "2024-10-11T13:51:06Z",
              "path": "src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs",
              "diffHunk": "@@ -0,0 +1,166 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.Construction;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Shared;\n+using Microsoft.VisualStudio.SolutionPersistence;\n+using Microsoft.VisualStudio.SolutionPersistence.Model;\n+using Microsoft.VisualStudio.SolutionPersistence.Serializer;\n+using Shouldly;\n+using Xunit;\n+using Xunit.Abstractions;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.UnitTests.Construction\n+{\n+    public class SolutionFile_NewParser_Tests\n+    {\n+        public ITestOutputHelper TestOutputHelper { get; }\n+\n+        public SolutionFile_NewParser_Tests(ITestOutputHelper testOutputHelper)\n+        {\n+            TestOutputHelper = testOutputHelper;\n+        }\n+\n+        /// <summary>\n+        /// Tests to see that all the data/properties are correctly parsed out of a Venus\n+        /// project in a .SLN. This can be checked only here because of AspNetConfigurations protection level.\n+        /// </summary>\n+        [Theory]\n+        [InlineData(false)]\n+        [InlineData(true)]\n+        public void ProjectWithWebsiteProperties(bool convertToSlnx)\n+        {\n+            string solutionFileContents =\n+                \"\"\"\n+                Microsoft Visual Studio Solution File, Format Version 9.00\n+                # Visual Studio 2005\n+                Project(`{E24C65DC-7377-472B-9ABA-BC803B73C61A}`) = `C:\\WebSites\\WebApplication3\\`, `C:\\WebSites\\WebApplication3\\`, `{464FD0B9-E335-4677-BE1E-6B2F982F4D86}`\n+                    ProjectSection(WebsiteProperties) = preProject\n+                        ProjectReferences = `{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSCla;ssLibra;ry1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;`\n+                        Frontpage = false\n+                            Debug.AspNetCompiler.VirtualPath = `/publishfirst`\n+                            Debug.AspNetCompiler.PhysicalPath = `..\\rajeev\\temp\\websites\\myfirstwebsite\\`\n+                            Debug.AspNetCompiler.TargetPath = `..\\rajeev\\temp\\publishfirst\\`\n+                            Debug.AspNetCompiler.ForceOverwrite = `true`\n+                            Debug.AspNetCompiler.Updateable = `false`\n+                            Debug.AspNetCompiler.Debug = `true`\n+                            Debug.AspNetCompiler.KeyFile = `debugkeyfile.snk`\n+                            Debug.AspNetCompiler.KeyContainer = `12345.container`\n+                            Debug.AspNetCompiler.DelaySign = `true`\n+                            Debug.AspNetCompiler.AllowPartiallyTrustedCallers = `false`\n+                            Debug.AspNetCompiler.FixedNames = `debugfixednames`\n+                            Release.AspNetCompiler.VirtualPath = `/publishfirst_release`\n+                            Release.AspNetCompiler.PhysicalPath = `..\\rajeev\\temp\\websites\\myfirstwebsite_release\\`\n+                            Release.AspNetCompiler.TargetPath = `..\\rajeev\\temp\\publishfirst_release\\`\n+                            Release.AspNetCompiler.ForceOverwrite = `true`\n+                            Release.AspNetCompiler.Updateable = `true`\n+                            Release.AspNetCompiler.Debug = `false`\n+                        VWDPort = 63496\n+                    EndProjectSection\n+                EndProject\n+                Global\n+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution\n+                        Debug|.NET = Debug|.NET\n+                    EndGlobalSection\n+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution\n+                        {464FD0B9-E335-4677-BE1E-6B2F982F4D86}.Debug|.NET.ActiveCfg = Debug|.NET\n+                        {464FD0B9-E335-4677-BE1E-6B2F982F4D86}.Debug|.NET.Build.0 = Debug|.NET\n+                    EndGlobalSection\n+                    GlobalSection(SolutionProperties) = preSolution\n+                        HideSolutionNode = FALSE\n+                    EndGlobalSection\n+                EndGlobal\n+                \"\"\";\n+\n+            SolutionFile solution = ParseSolutionHelper(solutionFileContents.Replace('`', '\"'), convertToSlnx);\n+\n+            solution.ProjectsInOrder.ShouldHaveSingleItem();\n+\n+            solution.ProjectsInOrder[0].ProjectType.ShouldBe(SolutionProjectType.WebProject);\n+            solution.ProjectsInOrder[0].ProjectName.ShouldBe(@\"C:\\WebSites\\WebApplication3\\\");\n+            // TODO: try set Relative path with a port http://localhost:8080/WebSites/WebApplication3/",
              "author": {
                "login": "surayya-MS"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why not catch both (pattern matching) and use `ex.ToString()` in both cases? It'll unwrap the `AggregateException` appropriately ",
              "createdAt": "2024-10-11T10:58:43Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,233 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (AggregateException aggregateException)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            string.Join(\" \", aggregateException.InnerExceptions.Select(inner => inner.Message)));\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: Seems to be missing the word \"included\"",
              "createdAt": "2024-10-11T12:55:16Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -180,16 +191,24 @@ internal int VisualStudioVersion\n         /// </summary>\n         internal bool ContainsWebDeploymentProjects { get; private set; }\n \n+        internal bool UseNewParser => ShouldUseNewParser(_solutionFile);\n+\n+        internal static bool ShouldUseNewParser(string solutionFile) => FileUtilities.IsSolutionXFilename(solutionFile);\n+\n         /// <summary>\n         /// All projects in this solution, in the order they appeared in the solution file\n         /// </summary>\n+        /// <remarks>Solution folders are no longer for the new parser.</remarks>",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could we add why we are mapping these two types.",
              "createdAt": "2024-10-16T13:58:33Z",
              "path": "src/Build/Construction/Solution/SolutionFile.cs",
              "diffHunk": "@@ -257,11 +276,226 @@ internal bool ProjectShouldBuild(string projectFile)\n         /// </summary>\n         public static SolutionFile Parse(string solutionFile)\n         {\n-            var parser = new SolutionFile { FullPath = solutionFile };\n-            parser.ParseSolutionFile();\n-            return parser;\n+            var solution = new SolutionFile { FullPath = solutionFile };\n+\n+            if (solution.UseNewParser)\n+            {\n+                solution.ParseUsingNewParser();\n+            }\n+            else\n+            {\n+                // Parse the solution file using the old parser\n+                solution.ParseSolutionFile();\n+            }\n+\n+            return solution;\n+        }\n+\n+        /// <summary>\n+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.\n+        /// </summary>\n+        internal void ParseUsingNewParser()\n+        {\n+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);\n+\n+            if (serializer != null)\n+            {\n+                try\n+                {\n+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;\n+                    ReadSolutionModel(solutionModel);\n+                }\n+                catch (Exception ex)\n+                {\n+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                            new BuildEventFileInfo(FullPath),\n+                            $\"InvalidProjectFile\",\n+                            ex.ToString());\n+                }\n+            }\n+            else if (serializer == null)\n+            {\n+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(\n+                    new BuildEventFileInfo(FullPath),\n+                    $\"InvalidProjectFile\",\n+                    $\"No solution serializer was found for {FullPath}\");\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Maps <see cref=\"SolutionModel\"/> to <see cref=\"SolutionFile\" />.",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      }
    ]
  }
}