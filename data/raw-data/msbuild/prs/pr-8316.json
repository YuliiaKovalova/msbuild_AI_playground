{
  "number": 8316,
  "title": "Log assembly loads during task run",
  "body": "Fixes #6303\r\nRelated: https://github.com/KirillOsenkov/MSBuildStructuredLog/pull/653\r\n\r\n### Context\r\n\r\n* Assembly loading logging for:\r\n  * Task runs  - including loads in separate app domain for `AppDomainIsolatedTask`\r\n  * Except for tasks runs in `OutOfProcessRaskHostNode` - as neither `LoggingService` nor `LoggingContext` are available there - **not sure if not supporting those is a problem**.\r\n  * Sdk resolving (explicitly skipping resolvers defined in `Microsoft.Build` assembly)\r\n  * Loggers initialization (explicitly skipping resolvers defined in `Microsoft.Build` assembly orwithin `Microsoft.Build.Logging` namespace) - **Note** - loggers initialiation reordered - Binlog is the first one - as assembly load events are emited at the time of each logger initialization, currently `LoggerService` dispatches events immediately after construction, so as a result order of logger definitions matter (only the earlier initialized gets messages about latter ones initialization assembly loads). Alternative would be to change the `LoggerService` contract to start dispatching on explicit request (easy to implement and preserving current MSBuild behavior - however might be potentially breaking for API users?) or to cache those events and log them later (doable, but convoluted - probably not worth the efforts now)\r\n  * Evaluation\r\n\r\n### Samples\r\n* task run:\r\n\r\n  ```\r\n  Assembly loaded during TaskRun: System.Diagnostics.Debug, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a (location: C:\\Windows\\Microsoft.Net\\assembly\\GAC_MSIL\\System.Diagnostics.Debug\\v4.0_4.0.0.0__b03f5f7f11d50a3a\\System.Diagnostics.Debug.dll, MVID: bc6b825d-5f99-464e-a06d-e3ae4b860a34, AppDomain: [Default])\r\n  ```\r\n* evaluation:\r\n  ```\r\n  Assembly loaded during Evaluation: System.Collections.Immutable, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a (location: C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\7.0.2\\System.Collections.Immutable.dll, MVID: 5a4c54a3-2092-428e-89cc-a391fd9d398a, AppDomain: [Default])\r\n  ```\r\n* logger initialization:\r\n\r\n  ```\r\n  Assembly loaded during LoggerInitialization (MyLoggers.BasicFileLogger): System.Reflection.Metadata, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a (location: C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\7.0.2\\System.Reflection.Metadata.dll, MVID: c602a8ce-3890-40fc-aa9b-fa3c23f81aab, AppDomain: [Default])\r\n  ```\r\n* custom sdk resolver (no sample - similar to logger initialization)\r\n\r\n### Perf impact\r\n\r\nNo observable impact.\r\n\r\n * `MSBUILDLOGALLASSEMBLYLOADS` is used to turn on loggin of all assembly loads\r\n * build command: `msbuild.exe <proj> /nodeReuse:false /bl`\r\n\r\n| Scenario | Mean Duration |\r\n| --- | --- |\r\n| Orchard - MSBuild main | 00:00:59.25 |\r\n| Orchard - curr branch | 00:00:58.30 |\r\n| Orchard - curr branch, all loads  | 00:00:58.30 |\r\n|  |  |\r\n| Console - MSBuild main | 00:00:01.08 |\r\n| Console - curr branch | 00:00:01.09 |\r\n| Console - curr branch, all loads  | 00:00:01.10 |\r\n",
  "state": "MERGED",
  "createdAt": "2023-01-18T15:55:57Z",
  "updatedAt": "2023-02-28T12:16:26Z",
  "closedAt": "2023-02-24T11:09:29Z",
  "mergedAt": "2023-02-24T11:09:29Z",
  "additions": 650,
  "deletions": 19,
  "changedFiles": 39,
  "headRefName": "proto/assembly-loads",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "da7aa788970d75f00066d75e163776b1abaa575c",
          "message": "Log assembly loads during task run",
          "committedDate": "2023-01-17T13:35:25Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "635a83d8e21c56e86be3cc6c5f1ce0f06ef1451e",
          "message": "Remove functionality from MSBuildTaskHost, Add test",
          "committedDate": "2023-01-18T15:47:51Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b9b289a9a1fbf05dd279891e17db6d7db5c8039f",
          "message": "AssemblyLoadBuildEventArgs can serialize self",
          "committedDate": "2023-01-19T17:38:22Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b32cdde44a3493f6505d32fce75a815f2caee96a",
          "message": "Fix optional string reading",
          "committedDate": "2023-01-20T09:12:24Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5d73494318a3064981554dc8990f1ba9b8ae2e4c",
          "message": "Add serialization tests",
          "committedDate": "2023-01-24T10:15:23Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "32926be63521fbe45dd4f1dee833776e78c4f759",
          "message": "Revert resx cahnges",
          "committedDate": "2023-01-24T18:12:10Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0076032db3dcc9103e41200df878af6e74a90126",
          "message": "Add support for multiple app domains",
          "committedDate": "2023-01-24T19:26:02Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "00297c846396659b36ced04463dd17041f0e412d",
          "message": "Add support for sdkResolvers, Loggers",
          "committedDate": "2023-01-25T09:54:31Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7a8549226d3e6503ba41d69b177df61e43f3b4ed",
          "message": "Cleanup test",
          "committedDate": "2023-01-25T09:58:50Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cf67298e92771109799b656b49eec11c0dea201e",
          "message": "Temporarily disable logger assembly loads logging",
          "committedDate": "2023-01-25T14:43:36Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "402d91586d07c59841b4d3adc04fe7763cbd57bc",
          "message": "Fix build",
          "committedDate": "2023-01-25T15:12:34Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bfc7e424b69f1219bdcc6b3a1c8e81fc90445f35",
          "message": "Reintroduce assembly loads logging for loggers init",
          "committedDate": "2023-01-25T16:33:17Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "95332291b2c08ab90fc068cc37a9fb5f25abb06c",
          "message": "Reorder test loggers - to assure binlogger consumes all events",
          "committedDate": "2023-01-25T18:05:27Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f63bccc2c4e9fde22e9c27f77688dbc6f9bd1dc1",
          "message": "Merge remote-tracking branch 'upstream/main' into proto/assembly-loads",
          "committedDate": "2023-02-03T16:23:56Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0ac0a0c9a250258ed2626aba8ee3a3b46f3a3f04",
          "message": "Fix formatting",
          "committedDate": "2023-02-03T16:30:38Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a9f6aa05d877419c5789b7313ca6c8ce099c0e30",
          "message": "Log node reuse",
          "committedDate": "2023-02-03T17:15:50Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d08a0b4abaa1bff6732694fd282e27752657b19a",
          "message": "Implement PR suggestions",
          "committedDate": "2023-02-06T17:56:29Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "83bcb3c155884b451cfc3256a93bfa176963dc26",
          "message": "Fix logging contract",
          "committedDate": "2023-02-07T15:24:55Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cb75a7b3d22cbb5d4002f7a0af759137adbe62ce",
          "message": "Buildfix",
          "committedDate": "2023-02-07T16:26:55Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d5a04ec71549f85a9ae6681f7c0d5a4f287d83ae",
          "message": "Improve assembly loads logging filtering",
          "committedDate": "2023-02-09T20:11:37Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f6c696399c13667bc7742a8e94c0cfc3c79e46aa",
          "message": "Improve - review comments, improved filtering for builtin tasks",
          "committedDate": "2023-02-12T17:05:41Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9a859ed6e03b66819948cf589c95f7cdf9f15619",
          "message": "Remove superfluous check",
          "committedDate": "2023-02-14T09:26:21Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a461afcc85d4b0f3d182136ef490be146f1076dc",
          "message": "Add changewave doc info",
          "committedDate": "2023-02-14T15:54:26Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "/azp run",
        "createdAt": "2023-01-19T18:47:25Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "<samp>\nAzure Pipelines successfully started running 1 pipeline(s).<br>\r\n\n</samp>",
        "createdAt": "2023-01-19T18:47:36Z",
        "author": {
          "login": "azure-pipelines"
        }
      },
      {
        "body": "Don't forget to increment the file format version:\r\nhttps://source.dot.net/#Microsoft.Build/Logging/BinaryLogger/BinaryLogger.cs,7791c3b6dbbeedbf,references\r\n\r\nI'd say don't worry about the out of proc task node - it's a black box to us anyway, let's consider it a \"tool\" that we don't control.\r\n\r\nMake sure AppDomain stuff works on Core (Core doesn't have AppDomains) or gracefully degrades.\r\n\r\nI'm torn on whether we should include the built-in assembly loads. On one hand, we want to know where our own stuff is loaded from. On the other hand, we can already infer since we know the path to MSBuild.exe, and maybe not worth having the same redundant messages at the beginning of every binlog.\r\n\r\nI'd say let's record a couple of medium-sized real-world binlogs when the PR is ready, add viewer support, look at the logs in the viewer and then tweak to achieve the desired behavior.\r\n\r\nAlso remember that we should submit the binlog viewer support for the new file format version first, test it with the test binlogs, I will publish the new viewer version, then we merge this PR. So that by the time early adopters start recording these binlogs the viewer already supports them.\r\n\r\nSee a sample PR by @edvilme that incremented the binlog version:\r\nhttps://github.com/dotnet/msbuild/pull/8146\r\n\r\nand the corresponding viewer PR:\r\nhttps://github.com/KirillOsenkov/MSBuildStructuredLog/pull/644",
        "createdAt": "2023-01-25T18:17:07Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Forgot to say, the general direction looks good to me!",
        "createdAt": "2023-01-25T18:17:56Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Thank you for great suggestions!\r\nI've tried to adress those (in https://github.com/dotnet/msbuild/pull/8316/commits/d08a0b4abaa1bff6732694fd282e27752657b19a), namely:\r\n\r\n* Not observing loads triggered by builtin types (loggers, sdk resolvers)\r\n* Putting the tracking and logging behinde ChangeWave\r\n* Not storing/transfering/logging AppDomain details for default app domain (Core and Framework)\r\n* Grace handle concurrent calls for multiple app domains\r\n* Logging the type initiating the assembly loads (if known)\r\n* Incrementing binloger version (I'm yet to create PR into the binlog viewer)",
        "createdAt": "2023-02-06T18:12:31Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Coresponding Binlog viewer PR: https://github.com/KirillOsenkov/MSBuildStructuredLog/pull/653\r\n@KirillOsenkov FYI",
        "createdAt": "2023-02-07T15:30:38Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "I'm wondering if we could simplify this. When do we expect to load assemblies? This PR seems to just say that _when_ we load assemblies, we should log it but does that with broad strokes. Could we have something that targets the places where we load an assembly and log that an assembly was loaded at those places? So for tasks, for instance, you could put things [here](https://github.com/dotnet/msbuild/blob/446f42e6d1478acb44faec787f90f57f38c08b73/src/Shared/TypeLoader.cs#L161) and [here](https://github.com/dotnet/msbuild/blob/446f42e6d1478acb44faec787f90f57f38c08b73/src/Shared/TypeLoader.cs#L189).",
        "createdAt": "2023-02-08T01:01:39Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "@Forgind the .NET assembly loader(s) load assemblies just-in-time to provide definitions for methods that can be called in a method as it is JITted before its first run. Because of that, we cannot control when assemblies will be loaded beyond the plugin entrypoints we explicitly control.\r\n\r\nI originally was thinking of logging only the resolved paths of plugin entrypoints, but this approach is more comprehensive and enables debugging collisions between transitive dependencies of plugins, so it seems superior to me.",
        "createdAt": "2023-02-08T14:18:24Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "This change is mostly about runtime induced (implicit) loading.\r\nThe explicit type loading is actualy not loaded.\r\n\r\nFor this reason (closer explained by @rainersigwald) we unfortunately need to mount observing for the entire execution time of the component in question.\r\nFor tasks and for evaluation this is fortunately possible to perform in properly constrained code section (and execution time).\r\n\r\nFor loggers and sdkresolvers, the typeloader should actually be the additional point in code hooked (I choosed not to hook, as for those two components we hopefully should know where we are loading from and this way I do not need to complicately distinguish which type loading is of interest and which to fileter out).\r\n\r\nAdditionaly for the loggers the code obvserves only the initialization section - in hopes all the assemblies will be touched there. But I can imagine esoteric loggers that will use additional assemblies only during handling of specific events or even shutdown - this is intentionally not supported (as it opens a can of worm of distniguishing what caused assembly load at specific point of time - e.g. when custom task is logging to custom logger).\r\n\r\n**tl;dr;:** please let me know if you think the assembly loads caused by loading the actual types implementing the custom loggers or sdkresolvers should be logged as well (*in addition* to the current hooked usages of the components.)\r\n",
        "createdAt": "2023-02-08T15:35:08Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "> **tl;dr;:** please let me know if you think the assembly loads caused by loading the actual types implementing the custom loggers or sdkresolvers should be logged as well (_in addition_ to the current hooked usages of the components.)\r\n\r\nI think this is important. One way things can go wrong is a build that has references to two versions of a build task with the same identity. If they're loaded in separate worker nodes they can both work, but when loaded in the same process the first one \"wins\" the load and might cause behavior differences.",
        "createdAt": "2023-02-08T15:58:21Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> I think this is important. One way things can go wrong is a build that has references to two versions of a build task with the same identity. If they're loaded in separate worker nodes they can both work, but when loaded in the same process the first one \"wins\" the load and might cause behavior differences.\r\n\r\nThe task case is hooked withing [`InitializeAndExecuteTask`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L657) - which is eventually calling into the `TypeLoader` - so the assembly information should be properly loged in this case. I'll verify with explicit custom task.\r\n\r\nThe `TypeLoader` loading is not hooked for logger and sdk resolver (the logging service is not yet available there) - though this can definitely be solved somehow (deffered log message?) if it feels as importnat usecase.\r\n\r\n\r\nOne another question that pops-up during testing this: can we somehow distinguish builtin tasks? (while possibly special case keep handling some that are used as surrogate for custom tasks - like `RoslynCodeTaskFactory`) Is there anything that can be used to filter those out?\r\n\r\n<img width=\"437\" alt=\"image\" src=\"https://user-images.githubusercontent.com/3809076/217617304-b8876221-c148-4810-91bb-48db485150cf.png\">\r\n \r\n",
        "createdAt": "2023-02-08T18:22:49Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Can we just check which assembly it's from? If it's in a fixed list, then it's us. I think we have a \"fixed\" list somewhere in MSBuildLocator",
        "createdAt": "2023-02-08T22:07:52Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "For tasks I think it's literally just `Microsoft.Build.Tasks.Core.dll`. Loggers we have in `Microsoft.Build.dll` though.",
        "createdAt": "2023-02-08T22:20:38Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I'm slowly peeling the onion here :-)\r\nSome of the requests I can filter out by the initiating type being defined in the same assembly as is the executing one (`Microsoft.Build.dl`), others by being defined within namespace or an assembly starting with `Microsoft.Build`. \r\nThis is still not perfect - considerable amount of tasks are defined in SDK - so I'm experimenting with excluding them via string prefix (`Microsoft.NET.Build`) or probably better, by trying to type relate them to the loaded sdks.\r\nLastly some requests for monitoring we want to likely accept even if comming from internal types (e.g. the `RoslynCodeTaskFactory`).\r\n\r\nCurrently I'm waist down in the code and experimentation - trying to have it ready for PR review meeting",
        "createdAt": "2023-02-09T17:11:12Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "I've published the viewer version that supports this, would be nice to test that it's able to open binlogs produced with this change.",
        "createdAt": "2023-02-25T02:45:38Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@KirillOsenkov I confirm I can open my test logs (new console, orchard, etc.) with the latest official version :thumbsup:\r\n\r\n~~I have an issue with some logs from previous version - I'm on it now.~~\r\nAll my old (without the assembly load logging feature) and new (with the assembly load logging feature) binlogs can be opened and reviewed without issues with the newest official version ([`2.1.784`](https://github.com/KirillOsenkov/MSBuildStructuredLog/releases/tag/v2.1.784)) of binlog viewer. Issue I was seeing was only for binlog produced by the in-progress version of msbuild. Appology for confusion here\r\n\r\nBtw. a dumb question - Were there any thoughts to make the auto-update experience more friendly or understandable? I observed that the first open attempt led to error due to an old version, without simple info about update option/process. The Help->About menu presented a clear message about a new version and need to restart the app. Can this be perceived as confusing?",
        "createdAt": "2023-02-27T12:57:56Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "Yeah we can certainly improve this. One of these days!",
        "createdAt": "2023-02-27T17:21:38Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "> Yeah we can certainly improve this. One of these days!\r\n\r\nSince I complained :-) - let me try to propose a fix ...\r\n",
        "createdAt": "2023-02-28T12:16:26Z",
        "author": {
          "login": "JanKrivanek"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This is autogenerated - I'm wondering how invalid xml got here :thinking:",
              "createdAt": "2023-01-18T15:57:44Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -1942,9 +1942,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n     </comment>\n   </data>\n   <data name=\"ProjectCacheHitWithOutputs\" xml:space=\"preserve\">\n-    <value>{0} -> Cache Hit</value>",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Builtin are probably defined in assemblies that are anyway already loaded, so we might not care...\r\nAny thoughts here are appreciated.\r\n\r\nSame applies for SdkResolvers\r\n",
              "createdAt": "2023-01-25T09:56:46Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -1594,6 +1595,8 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)\n         {\n             try\n             {\n+                // TODO: can we distinguish builtin and custom loggers here?",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Feels like we _could_ have an explicit check for the known types, but there are enough of them that I don't know how helpful it would be.",
              "createdAt": "2023-01-26T23:11:24Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -1594,6 +1595,8 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)\n         {\n             try\n             {\n+                // TODO: can we distinguish builtin and custom loggers here?",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The only built-in one is `DefaultSdkResolver` so an explicit check for that should suffice.",
              "createdAt": "2023-01-26T23:09:30Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1847,6 +1849,8 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin\n                 // Combine SDK path with the \"project\" relative path\n                 try\n                 {\n+                    // TODO: can we distinguish builtin and custom sdkresolvers here?\n+                    using var _ = AssemblyLoadsTracker.StartTracking(_evaluationLoggingContext, AssemblyLoadingContext.SdkResolution);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you put this behind a 17.6 changewave opt-out, so if we discover some functional problem we can easily disable it?",
              "createdAt": "2023-01-26T23:12:52Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -0,0 +1,102 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Concurrent;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd.Components.RequestBuilder\n+{\n+    internal class AssemblyLoadsTracker : MarshalByRefObject, IDisposable\n+    {\n+        private static readonly ConcurrentDictionary<AppDomain, AssemblyLoadsTracker> s_instances = new();\n+        private readonly LoggingContext? _loggingContext;\n+        private readonly LoggingService? _loggingService;\n+        private readonly AssemblyLoadingContext _context;\n+        private readonly AppDomain _appDomain;\n+\n+        private AssemblyLoadsTracker(\n+            LoggingContext? loggingContext,\n+            LoggingService? loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain appDomain)\n+        {\n+            _loggingContext = loggingContext;\n+            _loggingService = loggingService;\n+            _context = context;\n+            _appDomain = appDomain;\n+        }\n+\n+        public static IDisposable StartTracking(\n+            LoggingContext loggingContext,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            return StartTracking(loggingContext, null, context, appDomain);\n+        }\n+\n+        public static IDisposable StartTracking(\n+            LoggingService loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            return StartTracking(null, loggingService, context, appDomain);\n+        }\n+\n+        public static void StopTracking(AppDomain appDomain)\n+        {\n+            if (s_instances.TryRemove(appDomain, out AssemblyLoadsTracker? tracker))\n+            {\n+                tracker.StopTracking();\n+            }\n+        }\n+\n+        public void Dispose()\n+        {\n+            StopTracking();\n+        }\n+\n+        private static IDisposable StartTracking(\n+            LoggingContext? loggingContext,\n+            LoggingService? loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we not log this in the text log, too? It's generally less helpful than binlogs but still has some place, and is (sadly) still popular.",
              "createdAt": "2023-01-26T23:16:13Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1101,6 +1101,11 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)\n         {\n             if (showOnlyErrors || showOnlyWarnings) return;\n \n+            if (e.BuildEventContext == null && e is AssemblyLoadBuildEventArgs)\n+            {\n+                return;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "**tl;dr;:** I believe it's out of scope currently.\r\n\r\nIt logs with exception of assembly loading for custom loggers. Those do not have any `BuildContext` that `ParallelConsoleLogger` relies upon quite a lot. It would take some refactoring of `ParallelConsoleLogger`, which is definitely doable but feels beyond scope of this change. \r\nIf it would be missed - it can definitely be added later on.\r\nThoughts?",
              "createdAt": "2023-02-06T13:23:14Z",
              "path": "src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs",
              "diffHunk": "@@ -1101,6 +1101,11 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)\n         {\n             if (showOnlyErrors || showOnlyWarnings) return;\n \n+            if (e.BuildEventContext == null && e is AssemblyLoadBuildEventArgs)\n+            {\n+                return;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is a great representation for the task case, where the event context information is sufficient to understand what task did the load. In the other cases, it might be nice to have an association to \"what plugin did the loading?\". Only way I can see out of that is a string.",
              "createdAt": "2023-01-26T23:19:07Z",
              "path": "src/Framework/AssemblyLoadBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,80 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+#nullable disable\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public class AssemblyLoadBuildEventArgs : BuildMessageEventArgs\n+    {\n+        public AssemblyLoadBuildEventArgs()\n+        { }\n+\n+        public AssemblyLoadBuildEventArgs(\n+            AssemblyLoadingContext loadingContext,\n+            string assemblyName,\n+            string assemblyPath,\n+            Guid mvid,\n+            int appDomainId,\n+            string appDomainFriendlyName,\n+            MessageImportance importance = MessageImportance.Low)\n+            : base(null, null, null, importance, DateTime.UtcNow, assemblyName, assemblyPath, mvid)\n+        {\n+            LoadingContext = loadingContext;\n+            AssemblyName = assemblyName;\n+            AssemblyPath = assemblyPath;\n+            MVID = mvid;\n+            AppDomainId = appDomainId;\n+            AppDomainFriendlyName = appDomainFriendlyName;\n+        }\n+\n+        public AssemblyLoadingContext LoadingContext { get; private set; }",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Think it's worth anything to avoid storing and reporting these for the default app domain and/or on core where there are no app domains?\r\n\r\nWould indicating `AssemblyLoadContext` on core be helpful at all (I don't think so at the moment)?",
              "createdAt": "2023-01-26T23:20:36Z",
              "path": "src/Framework/AssemblyLoadBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,80 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+#nullable disable\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public class AssemblyLoadBuildEventArgs : BuildMessageEventArgs\n+    {\n+        public AssemblyLoadBuildEventArgs()\n+        { }\n+\n+        public AssemblyLoadBuildEventArgs(\n+            AssemblyLoadingContext loadingContext,\n+            string assemblyName,\n+            string assemblyPath,\n+            Guid mvid,\n+            int appDomainId,\n+            string appDomainFriendlyName,\n+            MessageImportance importance = MessageImportance.Low)\n+            : base(null, null, null, importance, DateTime.UtcNow, assemblyName, assemblyPath, mvid)\n+        {\n+            LoadingContext = loadingContext;\n+            AssemblyName = assemblyName;\n+            AssemblyPath = assemblyPath;\n+            MVID = mvid;\n+            AppDomainId = appDomainId;\n+            AppDomainFriendlyName = appDomainFriendlyName;\n+        }\n+\n+        public AssemblyLoadingContext LoadingContext { get; private set; }\n+        public string AssemblyName { get; private set; }\n+        public string AssemblyPath { get; private set; }\n+        public Guid MVID { get; private set; }\n+        public int AppDomainId { get; private set; }\n+        public string AppDomainFriendlyName { get; private set; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Fair enough - updating to store/transfer null (single bit) for cases where `IsDefaultAppDomain()` returns `true`.\r\nThis handles core and framework and is prepared for cases like running task on core, but reporting the result to framework scheduler (not currently possible - but might be in the future) or vice versa; while using single bit of wire format for the most common cases.",
              "createdAt": "2023-02-06T15:20:34Z",
              "path": "src/Framework/AssemblyLoadBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,80 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+#nullable disable\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public class AssemblyLoadBuildEventArgs : BuildMessageEventArgs\n+    {\n+        public AssemblyLoadBuildEventArgs()\n+        { }\n+\n+        public AssemblyLoadBuildEventArgs(\n+            AssemblyLoadingContext loadingContext,\n+            string assemblyName,\n+            string assemblyPath,\n+            Guid mvid,\n+            int appDomainId,\n+            string appDomainFriendlyName,\n+            MessageImportance importance = MessageImportance.Low)\n+            : base(null, null, null, importance, DateTime.UtcNow, assemblyName, assemblyPath, mvid)\n+        {\n+            LoadingContext = loadingContext;\n+            AssemblyName = assemblyName;\n+            AssemblyPath = assemblyPath;\n+            MVID = mvid;\n+            AppDomainId = appDomainId;\n+            AppDomainFriendlyName = appDomainFriendlyName;\n+        }\n+\n+        public AssemblyLoadingContext LoadingContext { get; private set; }\n+        public string AssemblyName { get; private set; }\n+        public string AssemblyPath { get; private set; }\n+        public Guid MVID { get; private set; }\n+        public int AppDomainId { get; private set; }\n+        public string AppDomainFriendlyName { get; private set; }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    internal sealed class AssemblyLoadsTracker : MarshalByRefObject, IDisposable\r\n```",
              "createdAt": "2023-01-30T20:10:10Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -0,0 +1,102 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Concurrent;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd.Components.RequestBuilder\n+{\n+    internal class AssemblyLoadsTracker : MarshalByRefObject, IDisposable",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this type run on both core and framework? Heavy use of `AppDomain` makse me think framework but not seeing `#if` to remove it from core builds.",
              "createdAt": "2023-01-30T20:10:24Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -0,0 +1,102 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Concurrent;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd.Components.RequestBuilder\n+{\n+    internal class AssemblyLoadsTracker : MarshalByRefObject, IDisposable\n+    {",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "It's core and framework tested.\r\nThat being said - the dictionary with app domains is really needed just on FW - so putting this behing `#ifdef`\r\nRest I believe needs to stay as is - but it might be my lack of knowledge - for tracking assembly loads I need `AppDomain` (even if it's just the default one on core) to subscribe - correct?",
              "createdAt": "2023-02-06T15:46:30Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -0,0 +1,102 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Concurrent;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd.Components.RequestBuilder\n+{\n+    internal class AssemblyLoadsTracker : MarshalByRefObject, IDisposable\n+    {",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The `AddOrUpdate` call seems suspicious here. In the case there is already an existing entry the value `tracker` is essentially lost. It will get a call to `StartTracking` but never `StopTracking`. I don't know the significance of that in the MSBuild system but it seems better to avoid if we can. \r\n\r\nIt feels like the code here should be doing one of the following: \r\n\r\n1. Not calling `StartTracking` then the`AssemblyLoadsTracker` instance is not in the list\r\n2. Having `s_instances` store a list vs. a single value\r\n",
              "createdAt": "2023-01-30T20:18:53Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -0,0 +1,102 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Concurrent;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd.Components.RequestBuilder\n+{\n+    internal class AssemblyLoadsTracker : MarshalByRefObject, IDisposable\n+    {\n+        private static readonly ConcurrentDictionary<AppDomain, AssemblyLoadsTracker> s_instances = new();\n+        private readonly LoggingContext? _loggingContext;\n+        private readonly LoggingService? _loggingService;\n+        private readonly AssemblyLoadingContext _context;\n+        private readonly AppDomain _appDomain;\n+\n+        private AssemblyLoadsTracker(\n+            LoggingContext? loggingContext,\n+            LoggingService? loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain appDomain)\n+        {\n+            _loggingContext = loggingContext;\n+            _loggingService = loggingService;\n+            _context = context;\n+            _appDomain = appDomain;\n+        }\n+\n+        public static IDisposable StartTracking(\n+            LoggingContext loggingContext,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            return StartTracking(loggingContext, null, context, appDomain);\n+        }\n+\n+        public static IDisposable StartTracking(\n+            LoggingService loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            return StartTracking(null, loggingService, context, appDomain);\n+        }\n+\n+        public static void StopTracking(AppDomain appDomain)\n+        {\n+            if (s_instances.TryRemove(appDomain, out AssemblyLoadsTracker? tracker))\n+            {\n+                tracker.StopTracking();\n+            }\n+        }\n+\n+        public void Dispose()\n+        {\n+            StopTracking();\n+        }\n+\n+        private static IDisposable StartTracking(\n+            LoggingContext? loggingContext,\n+            LoggingService? loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            var tracker = new AssemblyLoadsTracker(loggingContext, loggingService, context, appDomain ?? AppDomain.CurrentDomain);\n+            if (appDomain != null)\n+            {\n+                s_instances.AddOrUpdate(appDomain, tracker, (_, loadsTracker) => loadsTracker);",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Note: consider the case where the same `AppDomain` is registered twice (the crux of my comment above). This code actually produces a subtle race condition. There is a period of time inside the call to `StartTracking` that assembly loads are not monitored and that means we could end up missing an entry in the log. ",
              "createdAt": "2023-01-30T20:20:00Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -0,0 +1,102 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Concurrent;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd.Components.RequestBuilder\n+{\n+    internal class AssemblyLoadsTracker : MarshalByRefObject, IDisposable\n+    {\n+        private static readonly ConcurrentDictionary<AppDomain, AssemblyLoadsTracker> s_instances = new();\n+        private readonly LoggingContext? _loggingContext;\n+        private readonly LoggingService? _loggingService;\n+        private readonly AssemblyLoadingContext _context;\n+        private readonly AppDomain _appDomain;\n+\n+        private AssemblyLoadsTracker(\n+            LoggingContext? loggingContext,\n+            LoggingService? loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain appDomain)\n+        {\n+            _loggingContext = loggingContext;\n+            _loggingService = loggingService;\n+            _context = context;\n+            _appDomain = appDomain;\n+        }\n+\n+        public static IDisposable StartTracking(\n+            LoggingContext loggingContext,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            return StartTracking(loggingContext, null, context, appDomain);\n+        }\n+\n+        public static IDisposable StartTracking(\n+            LoggingService loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            return StartTracking(null, loggingService, context, appDomain);\n+        }\n+\n+        public static void StopTracking(AppDomain appDomain)\n+        {\n+            if (s_instances.TryRemove(appDomain, out AssemblyLoadsTracker? tracker))\n+            {\n+                tracker.StopTracking();\n+            }\n+        }\n+\n+        public void Dispose()\n+        {\n+            StopTracking();\n+        }\n+\n+        private static IDisposable StartTracking(\n+            LoggingContext? loggingContext,\n+            LoggingService? loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            var tracker = new AssemblyLoadsTracker(loggingContext, loggingService, context, appDomain ?? AppDomain.CurrentDomain);\n+            if (appDomain != null)\n+            {\n+                s_instances.AddOrUpdate(appDomain, tracker, (_, loadsTracker) => loadsTracker);\n+            }\n+            tracker.StartTracking();",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "This convo was marked as resolved but I can't see how. The race condition still exists. ",
              "createdAt": "2023-02-12T14:41:59Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -0,0 +1,102 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Concurrent;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd.Components.RequestBuilder\n+{\n+    internal class AssemblyLoadsTracker : MarshalByRefObject, IDisposable\n+    {\n+        private static readonly ConcurrentDictionary<AppDomain, AssemblyLoadsTracker> s_instances = new();\n+        private readonly LoggingContext? _loggingContext;\n+        private readonly LoggingService? _loggingService;\n+        private readonly AssemblyLoadingContext _context;\n+        private readonly AppDomain _appDomain;\n+\n+        private AssemblyLoadsTracker(\n+            LoggingContext? loggingContext,\n+            LoggingService? loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain appDomain)\n+        {\n+            _loggingContext = loggingContext;\n+            _loggingService = loggingService;\n+            _context = context;\n+            _appDomain = appDomain;\n+        }\n+\n+        public static IDisposable StartTracking(\n+            LoggingContext loggingContext,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            return StartTracking(loggingContext, null, context, appDomain);\n+        }\n+\n+        public static IDisposable StartTracking(\n+            LoggingService loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            return StartTracking(null, loggingService, context, appDomain);\n+        }\n+\n+        public static void StopTracking(AppDomain appDomain)\n+        {\n+            if (s_instances.TryRemove(appDomain, out AssemblyLoadsTracker? tracker))\n+            {\n+                tracker.StopTracking();\n+            }\n+        }\n+\n+        public void Dispose()\n+        {\n+            StopTracking();\n+        }\n+\n+        private static IDisposable StartTracking(\n+            LoggingContext? loggingContext,\n+            LoggingService? loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            var tracker = new AssemblyLoadsTracker(loggingContext, loggingService, context, appDomain ?? AppDomain.CurrentDomain);\n+            if (appDomain != null)\n+            {\n+                s_instances.AddOrUpdate(appDomain, tracker, (_, loadsTracker) => loadsTracker);\n+            }\n+            tracker.StartTracking();",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "Thanks for reiterating this one!\r\nSince the `StartTracking` instance method was private and was invoked only after construction - there was no chance for double subscription case - so the `unsubscribe-subscribe` was superfluous and I removed it. \r\nBut it's a good point for future cases as well",
              "createdAt": "2023-02-12T17:18:44Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -0,0 +1,102 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Concurrent;\n+using Microsoft.Build.BackEnd.Logging;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.BackEnd.Components.RequestBuilder\n+{\n+    internal class AssemblyLoadsTracker : MarshalByRefObject, IDisposable\n+    {\n+        private static readonly ConcurrentDictionary<AppDomain, AssemblyLoadsTracker> s_instances = new();\n+        private readonly LoggingContext? _loggingContext;\n+        private readonly LoggingService? _loggingService;\n+        private readonly AssemblyLoadingContext _context;\n+        private readonly AppDomain _appDomain;\n+\n+        private AssemblyLoadsTracker(\n+            LoggingContext? loggingContext,\n+            LoggingService? loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain appDomain)\n+        {\n+            _loggingContext = loggingContext;\n+            _loggingService = loggingService;\n+            _context = context;\n+            _appDomain = appDomain;\n+        }\n+\n+        public static IDisposable StartTracking(\n+            LoggingContext loggingContext,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            return StartTracking(loggingContext, null, context, appDomain);\n+        }\n+\n+        public static IDisposable StartTracking(\n+            LoggingService loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            return StartTracking(null, loggingService, context, appDomain);\n+        }\n+\n+        public static void StopTracking(AppDomain appDomain)\n+        {\n+            if (s_instances.TryRemove(appDomain, out AssemblyLoadsTracker? tracker))\n+            {\n+                tracker.StopTracking();\n+            }\n+        }\n+\n+        public void Dispose()\n+        {\n+            StopTracking();\n+        }\n+\n+        private static IDisposable StartTracking(\n+            LoggingContext? loggingContext,\n+            LoggingService? loggingService,\n+            AssemblyLoadingContext context,\n+            AppDomain? appDomain = null)\n+        {\n+            var tracker = new AssemblyLoadsTracker(loggingContext, loggingService, context, appDomain ?? AppDomain.CurrentDomain);\n+            if (appDomain != null)\n+            {\n+                s_instances.AddOrUpdate(appDomain, tracker, (_, loadsTracker) => loadsTracker);\n+            }\n+            tracker.StartTracking();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why not be specific about `AppDomain.CurrentDomain` here to make it explicit it's part of the tracking?",
              "createdAt": "2023-01-30T20:20:58Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -662,6 +663,7 @@ private void ExecuteIntrinsicTask(ItemBucket bucket)\n         /// </summary>\n         private async Task<WorkUnitResult> InitializeAndExecuteTask(TaskLoggingContext taskLoggingContext, ItemBucket bucket, IDictionary<string, string> taskIdentityParameters, TaskHost taskHost, TaskExecutionMode howToExecuteTask)\n         {\n+            using var assemblyLoadsTracker = AssemblyLoadsTracker.StartTracking(taskLoggingContext, AssemblyLoadingContext.TaskRun);",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "I have adjusted the code not to store and transfer AppDomain name and id for default app domain (so never on Core and only for explict app domains on Framework).\r\nSo I'd probably still prefer to keep the majority use case simpler (being able to specify the `AppDomain` explicitly but not being forced to).\r\nThoughts?",
              "createdAt": "2023-02-06T17:36:54Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs",
              "diffHunk": "@@ -662,6 +663,7 @@ private void ExecuteIntrinsicTask(ItemBucket bucket)\n         /// </summary>\n         private async Task<WorkUnitResult> InitializeAndExecuteTask(TaskLoggingContext taskLoggingContext, ItemBucket bucket, IDictionary<string, string> taskIdentityParameters, TaskHost taskHost, TaskExecutionMode howToExecuteTask)\n         {\n+            using var assemblyLoadsTracker = AssemblyLoadsTracker.StartTracking(taskLoggingContext, AssemblyLoadingContext.TaskRun);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Given this is a public type, is there a reason you all don't default to `sealed`?",
              "createdAt": "2023-01-30T20:23:07Z",
              "path": "src/Framework/AssemblyLoadBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,80 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+#nullable disable\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public class AssemblyLoadBuildEventArgs : BuildMessageEventArgs",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "We haven't had this rule but we should.",
              "createdAt": "2023-01-30T20:37:58Z",
              "path": "src/Framework/AssemblyLoadBuildEventArgs.cs",
              "diffHunk": "@@ -0,0 +1,80 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+#nullable disable\n+\n+using System;\n+using System.IO;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Framework\n+{\n+    public class AssemblyLoadBuildEventArgs : BuildMessageEventArgs",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "File scoped namespaces FTW \ud83d\ude80 ",
              "createdAt": "2023-01-30T20:23:33Z",
              "path": "src/Framework/AssemblyLoadingContext.cs",
              "diffHunk": "@@ -0,0 +1,12 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Framework;",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I reordered loggers initialization to have binlog on top - to ensure it receives all the events from initialiation of custom loggers.\r\n\r\n@rainersigwald - is there any hidden risk associated to reordering the creation and initialiation of the loggers",
              "createdAt": "2023-02-07T15:33:59Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3210,8 +3210,12 @@ private static string ProcessToolsVersionSwitch(string[] parameters)\n                 originalVerbosity = ProcessVerbositySwitch(verbositySwitchParameters[verbositySwitchParameters.Length - 1]);\n                 verbosity = originalVerbosity;\n             }\n+            var loggers = new List<ILogger>();\n+\n+            var outVerbosity = verbosity;\n+            ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Nothing springs to mind.",
              "createdAt": "2023-02-08T14:16:46Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -3210,8 +3210,12 @@ private static string ProcessToolsVersionSwitch(string[] parameters)\n                 originalVerbosity = ProcessVerbositySwitch(verbositySwitchParameters[verbositySwitchParameters.Length - 1]);\n                 verbosity = originalVerbosity;\n             }\n+            var loggers = new List<ILogger>();\n+\n+            var outVerbosity = verbosity;\n+            ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think we should consider the Roslyn tasks built in. One of the biggest issues we have to investigate is why Roslyn tasks don't laod the way we expect precisely because they're not built in. ",
              "createdAt": "2023-02-12T14:37:02Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -107,19 +83,47 @@ public void Dispose()\n             StopTracking();\n         }\n \n+        private static bool IsBuiltinType(string? typeName)\n+        {\n+            if (string.IsNullOrEmpty(typeName))\n+            {\n+                return false;\n+            }\n+\n+            return typeName!.StartsWith(\"Microsoft.Build\", StringComparison.OrdinalIgnoreCase) ||\n+                   typeName.StartsWith(\"Microsoft.NET.Build\", StringComparison.OrdinalIgnoreCase) ||\n+                   typeName.StartsWith(\"Microsoft.CodeAnalysis.BuildTasks\", StringComparison.OrdinalIgnoreCase);",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "Makes sense - removed from filter.\r\nJust to supplement the info - in case of need it's possible to force all tracking via defining `MSBUILDLOGALLASSEMBLYLOADS` env var.",
              "createdAt": "2023-02-12T17:08:26Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -107,19 +83,47 @@ public void Dispose()\n             StopTracking();\n         }\n \n+        private static bool IsBuiltinType(string? typeName)\n+        {\n+            if (string.IsNullOrEmpty(typeName))\n+            {\n+                return false;\n+            }\n+\n+            return typeName!.StartsWith(\"Microsoft.Build\", StringComparison.OrdinalIgnoreCase) ||\n+                   typeName.StartsWith(\"Microsoft.NET.Build\", StringComparison.OrdinalIgnoreCase) ||\n+                   typeName.StartsWith(\"Microsoft.CodeAnalysis.BuildTasks\", StringComparison.OrdinalIgnoreCase);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We should be using `StringComparison.Ordinal` here. Type names are case sensitive and known at compile time. ",
              "createdAt": "2023-02-12T14:37:57Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -107,19 +83,47 @@ public void Dispose()\n             StopTracking();\n         }\n \n+        private static bool IsBuiltinType(string? typeName)\n+        {\n+            if (string.IsNullOrEmpty(typeName))\n+            {\n+                return false;\n+            }\n+\n+            return typeName!.StartsWith(\"Microsoft.Build\", StringComparison.OrdinalIgnoreCase) ||",
              "author": {
                "login": "jaredpar"
              }
            },
            {
              "body": "This code can execute on top of the assembly filename as well (it's mounted prior actual loading of the task, when only the task name and some information about it's hosting assembly are known).\r\nBut since we are having consistent casing for our assembly files - it's good idea to be more strict here.",
              "createdAt": "2023-02-12T17:12:45Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs",
              "diffHunk": "@@ -107,19 +83,47 @@ public void Dispose()\n             StopTracking();\n         }\n \n+        private static bool IsBuiltinType(string? typeName)\n+        {\n+            if (string.IsNullOrEmpty(typeName))\n+            {\n+                return false;\n+            }\n+\n+            return typeName!.StartsWith(\"Microsoft.Build\", StringComparison.OrdinalIgnoreCase) ||",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it possible for this type of nesting to be more than one level deep? Often for this type of problem there is an extension method defined called `Unwrap` that recursively calls itself to handle arbitrary nesting scenarios.",
              "createdAt": "2023-02-12T14:39:50Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -1589,8 +1591,17 @@ private void RouteBuildEvent(BuildEventArgs eventArg)\n         /// <exception cref=\"Exception\">Any exception which is a ExceptionHandling.IsCriticalException will not be wrapped</exception>\n         private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)\n         {\n+            ILogger UnwrapLoggerType(ILogger log)\n+            {\n+                return (log is ProjectCollection.ReusableLogger reusableLogger)\n+                    ? reusableLogger.OriginalLogger",
              "author": {
                "login": "jaredpar"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Aren't SDK resolvers in different assemblies? We have our built-in one, but NuGet owns theirs, C++ owns theirs, etc.",
              "createdAt": "2023-02-14T00:43:51Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1840,9 +1843,16 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin\n                     }\n                 }\n \n+                IDisposable assemblyLoadTracker = null;\n                 // Combine SDK path with the \"project\" relative path\n                 try\n                 {\n+                    // Is the sdk resolver a custom type?",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That's a good point - I believe that if it's not built-in, than the default tracking has a sense, as it might not be obvious from where it was loaded. (similarly to this comment about roslyn tasks: https://github.com/dotnet/msbuild/pull/8316#discussion_r1103814426). \r\nWhat do you think?\r\n\r\nBtw. this code was accidentaly performin the filtering twice - I removed the superfluous call wrapping the `StartTracking`, as unified (and bit more comprehensive) filtering is performed within `StartTracking`.\r\nIt filters as well based on the typename - https://github.com/dotnet/msbuild/pull/8316/files/f6c696399c13667bc7742a8e94c0cfc3c79e46aa#diff-7f217b4ccb76592a2ab78dd7f8332509dfa2e2216d8a6032f956cbdf48df8d03R86-R96",
              "createdAt": "2023-02-14T09:11:01Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1840,9 +1843,16 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin\n                     }\n                 }\n \n+                IDisposable assemblyLoadTracker = null;\n                 // Combine SDK path with the \"project\" relative path\n                 try\n                 {\n+                    // Is the sdk resolver a custom type?",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I\u2019d rather err on the side of logging known assemblies than filtering something out too aggressively.",
              "createdAt": "2023-02-14T16:41:27Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1840,9 +1843,16 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin\n                     }\n                 }\n \n+                IDisposable assemblyLoadTracker = null;\n                 // Combine SDK path with the \"project\" relative path\n                 try\n                 {\n+                    // Is the sdk resolver a custom type?",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "There is a  opt-in trait (via `MSBUILDLOGALLASSEMBLYLOADS` env var) to stop any filtering.\r\nSo if for any reason any component of interest would not be hooked (e.g. due to being placed to 'Microsoft.Build' namespace), it can allways be opted-in.",
              "createdAt": "2023-02-15T09:11:31Z",
              "path": "src/Build/Evaluation/Evaluator.cs",
              "diffHunk": "@@ -1840,9 +1843,16 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin\n                     }\n                 }\n \n+                IDisposable assemblyLoadTracker = null;\n                 // Combine SDK path with the \"project\" relative path\n                 try\n                 {\n+                    // Is the sdk resolver a custom type?",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you still need _tasksAndAppDomains[taskInstance] = taskAppDomain; in this condition?",
              "createdAt": "2023-02-14T00:44:31Z",
              "path": "src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs",
              "diffHunk": "@@ -393,10 +400,14 @@ public void CleanupTask(ITask task)\n #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter\n \n #if FEATURE_APPDOMAIN\n-                if (taskAppDomain != null)\n+                if (taskAppDomain != null && taskInstance != null)\n                 {\n                     _tasksAndAppDomains[taskInstance] = taskAppDomain;\n                 }\n+                else if (taskAppDomain != null)\n+                {\n+                    AssemblyLoadsTracker.StopTracking(taskAppDomain);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "No - it's just a cleanup if the `taskInstance` is `null` and `taskAppDomain` is not (in such a case we do not want to track as task was not created).\r\nThe condition is altered as there was a hidden bug in the original code (indexing with `null` key `taskInstance`)",
              "createdAt": "2023-02-14T09:17:25Z",
              "path": "src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs",
              "diffHunk": "@@ -393,10 +400,14 @@ public void CleanupTask(ITask task)\n #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter\n \n #if FEATURE_APPDOMAIN\n-                if (taskAppDomain != null)\n+                if (taskAppDomain != null && taskInstance != null)\n                 {\n                     _tasksAndAppDomains[taskInstance] = taskAppDomain;\n                 }\n+                else if (taskAppDomain != null)\n+                {\n+                    AssemblyLoadsTracker.StopTracking(taskAppDomain);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Have you tested if this works properly for a build that traverses multiple nodes? When introducing a new event args type, we typically have to implement (de)serialization in (Write/Read)Event(To/From)Stream. It's possible you can squeeze by because this is a message, but I'd want to make sure that's properly tested.",
              "createdAt": "2023-02-14T00:49:52Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -139,7 +139,12 @@ internal enum LoggingEventType : int\n         /// <summary>\n         /// Event is a ResponseFileUsedEventArgs\n         /// </summary>\n-        ResponseFileUsedEvent = 20\n+        ResponseFileUsedEvent = 20,\n+\n+        /// <summary>\n+        /// Event is an AssemblyLoadBuildEventArgs\n+        /// </summary>\n+        AssemblyLoadEvent = 21,",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Good question. **tl;dr;:** yes the serialization logic is explicitly tested (https://github.com/dotnet/msbuild/pull/8316/files/f6c696399c13667bc7742a8e94c0cfc3c79e46aa#diff-08f18531025068e9ea785f0151729deab91afb28542319e9dfd3789d9fbe4fa9R224), plus it was tested on larger build with multiple nodes as well\r\n\r\nThis is confusing part of code :-)\r\nThe `LogMessagePacketBase` first tries to resolve (de)serialization instance methods via reflection (e.g.: https://github.com/dotnet/msbuild/blob/main/src/Shared/LogMessagePacketBase.cs#L322), only then resorts to the methods you mentioned.\r\nMSBuild code unfortunately combines both approaches - so it's easy to get lost. In this case I kept serializaion logic within the event type (as I believe that ideally type should be responsible for (de)serializing self; externalizing the logic elsewhere is prone to errors during future changes of that type).",
              "createdAt": "2023-02-14T09:25:56Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -139,7 +139,12 @@ internal enum LoggingEventType : int\n         /// <summary>\n         /// Event is a ResponseFileUsedEventArgs\n         /// </summary>\n-        ResponseFileUsedEvent = 20\n+        ResponseFileUsedEvent = 20,\n+\n+        /// <summary>\n+        /// Event is an AssemblyLoadBuildEventArgs\n+        /// </summary>\n+        AssemblyLoadEvent = 21,",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I normally think of reflection as a bit slow but sometimes required if we don't know anything about a build event. I'm wondering if there's some opportunity to optimize this a bit if we have some WriteToStream base method in the base type and have it take a BinaryWriter (and maybe a bool) and have it return a bool to indicate that we do or don't support self-serialization? I'm imagining that if it says yes, it would just call the method afterwards. Alternatively, it could just be a query to WriteToStream() and return true/false but not do any work. What do you think?",
              "createdAt": "2023-02-14T18:54:42Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -139,7 +139,12 @@ internal enum LoggingEventType : int\n         /// <summary>\n         /// Event is a ResponseFileUsedEventArgs\n         /// </summary>\n-        ResponseFileUsedEvent = 20\n+        ResponseFileUsedEvent = 20,\n+\n+        /// <summary>\n+        /// Event is an AssemblyLoadBuildEventArgs\n+        /// </summary>\n+        AssemblyLoadEvent = 21,",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I totally agree the code would benefit from unifying (de)serialization techniques for cross-nodes communication - currently there are 3 different approaches: \r\n[MSBUILDLOGALLASSEMBLYLOADS ](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Nodes-Orchestration.md#messages-deserialization)\r\n\r\n`ITranslatable` contract sounds as the best choice here - so ideally `BuildEventArgs` would implement and use that.\r\n\r\nThough - that is totally out of scope of current change :-) Do you think any change to contract is needed in scope of this change? Do you want to crerate item for code/contracts refactoring?\r\n\r\nI wouldn't worry about perf impact - reflection is definitely more costly then explicit contract implementation - though the cost is paid once per node, so I prefered to stick with current contracts",
              "createdAt": "2023-02-15T09:25:23Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -139,7 +139,12 @@ internal enum LoggingEventType : int\n         /// <summary>\n         /// Event is a ResponseFileUsedEventArgs\n         /// </summary>\n-        ResponseFileUsedEvent = 20\n+        ResponseFileUsedEvent = 20,\n+\n+        /// <summary>\n+        /// Event is an AssemblyLoadBuildEventArgs\n+        /// </summary>\n+        AssemblyLoadEvent = 21,",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "It's once per node? I would've thought once per method per node. In any event, I can agree it's out of scope, and I can't think of anything else that is both clearly better and in scope. You can make the item or not\u2014as you said, I don't think it'd be a high priority for us, so it might end up sitting for a while then getting closed as low priority. I think this otherwise looks good to me \ud83d\ude42",
              "createdAt": "2023-02-16T04:30:38Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -139,7 +139,12 @@ internal enum LoggingEventType : int\n         /// <summary>\n         /// Event is a ResponseFileUsedEventArgs\n         /// </summary>\n-        ResponseFileUsedEvent = 20\n+        ResponseFileUsedEvent = 20,\n+\n+        /// <summary>\n+        /// Event is an AssemblyLoadBuildEventArgs\n+        /// </summary>\n+        AssemblyLoadEvent = 21,",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}