{
  "number": 7489,
  "title": "[WIP-FEATURE] MSBuild server node",
  "body": "Fixes #7372\r\n\r\n### Context\r\nMSBuild server is a new node that accepts build request from client. This approach avoids spawning a new MSBuild process for every build from CLI tools like .NET SDK.\r\n\r\n### Changes Made\r\nThis PR implements a new node capable to accept and validate pipe connection, receive and invoke build commands, send console messages to client and inform about build result.\r\n\r\n### Testing\r\nTests will be added.\r\n\r\n### Notes\r\nThis is only draft as some areas need more care:\r\n- [x] Intelligent console messages flushing - based on buffer size AND elapsed time since last flush\r\n- [x] Console messages colorization - we want to use ANSI escape codes for colorization. Right now it's possible to pass `-consoleLoggerParameters:ForceConsoleColor` parameter from client, but we have to find a better way.\r\n- [x] Unit tests\r\n\r\nSome aspects will be implemented in different PR:\r\n1. Configurable timeout (nice to have)\r\n2. Support for build cancellation\r\n3. Non-interactive console checking - we don't want to emit ASNI escape codes when the stream is redirected",
  "state": "MERGED",
  "createdAt": "2022-03-25T10:26:17Z",
  "updatedAt": "2022-04-21T12:25:19Z",
  "closedAt": "2022-04-21T12:24:18Z",
  "mergedAt": "2022-04-21T12:24:18Z",
  "additions": 926,
  "deletions": 12,
  "changedFiles": 20,
  "headRefName": "dev/mipavlik/msbuild-server-node",
  "isDraft": false,
  "author": {
    "login": "MichalPavlik"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "afb6e914b5cc3fc2751d45f72ef092105be321c8",
          "message": "Initial commit",
          "committedDate": "2022-03-18T08:28:24Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9ccca49a6a2038e15f8992cbbd202bc309534cc6",
          "message": "Fixed problem with handshake",
          "committedDate": "2022-03-22T12:03:00Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "50aafb93000369746130a3cca5c1d3b8d8fa9c89",
          "message": "Refactoring and removing colors from console write packet",
          "committedDate": "2022-03-25T10:12:15Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "44fa2c8cc5e4f5b2ae8e6b64e3326dcbcd22b0b3",
          "message": "Moving server handshake to shared file so it can be used by client",
          "committedDate": "2022-03-28T08:40:16Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a3290467597d2e4ee991ab73d37d676fb41488a1",
          "message": "Resolving comments",
          "committedDate": "2022-03-28T14:16:41Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8f17d63ad140f2b27d382187443528915eaf0345",
          "message": "Resolving comments",
          "committedDate": "2022-03-28T14:35:03Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f01d0ad1dd7eae74a30f9320af2a9a9cc4543ad1",
          "message": "Force ANSI espace codes for console logger and disable lowering priority when the build is initiated by server.",
          "committedDate": "2022-04-04T14:35:42Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "55f28e1bd8d35b3a569d8b14c8acfc32c420e346",
          "message": "Improved flushing logic of console writer",
          "committedDate": "2022-04-07T12:15:32Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "015952e2f989b66e98b6a977e25f63e943006f78",
          "message": "Improved server related packets serialization/deserialization",
          "committedDate": "2022-04-07T13:30:06Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "069ce84bbb66d2dc71ed59a0f010f6ae64fd886b",
          "message": "Resolving comments",
          "committedDate": "2022-04-12T12:23:14Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "af559adaa95cb0e37cf0dd060fb023bbc635f92a",
          "message": "Resolving comments",
          "committedDate": "2022-04-13T08:36:19Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3995cfbb280cf5e334d95843afd3c46ffbc426b8",
          "message": "Resolving comments",
          "committedDate": "2022-04-20T09:32:57Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e12b50b4c0c6a2f230a6978063d08dc5e77288b2",
          "message": "Resolving comments (removed low prio and node reuse part in hash computation)",
          "committedDate": "2022-04-20T12:18:16Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cb4dea3bbfd85b1c1359f36583177317f4e72eed",
          "message": "Resolving comments",
          "committedDate": "2022-04-21T08:25:59Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cce64ba998fa95aca02e36a91d405606e2d92fa2",
          "message": "Resolving conflicts",
          "committedDate": "2022-04-21T10:54:14Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "82caefd41e4ee12727eadca9f6df15759ae8a686",
          "message": "Fixed error caused by changed API. Extracted ServerNamedMutex.",
          "committedDate": "2022-04-21T11:24:45Z",
          "author": {
            "name": "Michal Pavlik",
            "email": "mipavlik@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I didn't review the code but it's of course critical that the CLI-MSBuild pipe is tested to ensure it's secured in the same way as the MSBuild-MSBUild pipes are: the user at both ends must be the same user and (on Windows) elevation level.\n\nIn .NET Core there's API to do this: while MSBuild builds against .NET Framework it has to continue to do it manually.",
        "createdAt": "2022-03-25T15:51:13Z",
        "author": {
          "login": "danmoseley"
        }
      },
      {
        "body": "Hello @danmoseley, client-server communication uses same IPC infrastructure with user and elevation checking as the current nodes. It's implemented in base class and we didn't change it.",
        "createdAt": "2022-03-28T08:46:44Z",
        "author": {
          "login": "MichalPavlik"
        }
      },
      {
        "body": "If this is no longer a WIP, can you remove the [WIP-FEATURE] in the title?\r\n\r\nLooks like the test failures are from an overload of GetHandshakeOptions not being found.",
        "createdAt": "2022-04-21T11:17:11Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "@Forgind, we marked it as WIP as we will merge the code to the feature branch with the client implementation. It will make the work more efficient and we will continue with changes.",
        "createdAt": "2022-04-21T11:28:01Z",
        "author": {
          "login": "MichalPavlik"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Better make it a class because the struct will be boxed on the way out of `GetHandshake` anyway.",
              "createdAt": "2022-03-25T12:47:39Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -70,7 +70,24 @@ internal enum HandshakeOptions\n         NET = 64,\n     }\n \n-    internal readonly struct Handshake\n+    internal interface IHandshake\n+    {\n+        int[] RetrieveHandshakeComponents();\n+\n+        /// <summary>\n+        /// Get string key representing all handshake values. It does not need to be human readable.\n+        /// </summary>\n+        string GetKey();\n+\n+        /// <summary>\n+        /// Some handshakes uses very 1st byte to encode version of handshake in it,\n+        /// so if it does not match it can reject it early based on very first byte.\n+        /// Null means that no such encoding is used\n+        /// </summary>\n+        byte? ExpectedVersionInFirstByte { get; }\n+    }\n+\n+    internal readonly struct Handshake : IHandshake",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Typo `Buil`.",
              "createdAt": "2022-03-25T12:51:18Z",
              "path": "src/Shared/INodePacket.cs",
              "diffHunk": "@@ -189,6 +189,24 @@ internal enum NodePacketType : byte\n         /// Message sent back to a node informing it about the resource that were granted by the scheduler.\n         /// </summary>\n         ResourceResponse,\n+\n+        /// <summary>\n+        /// Command in form of MSBuild command line for server node - MSBuild Server.\n+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n+        /// </summary>\n+        ServerNodeBuilCommand = 0xF0,",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If I'm reading the sources correctly, the only place where handshake needs to be accessed in a generic way is `NodeEndpointOutOfProcBase.GetHandshake`. This has exactly one caller in `PacketPumpProc` and only one method is called on the handshake: `RetrieveHandshakeComponents`.\r\n\r\nSo overall it looks like this interface may be an overkill and we could instead have something like `RetrieveHandshakeComponents` (suggestion: name it `GetHandshakeData`?) directly on `NodeEndpointOutOfProcBase`.",
              "createdAt": "2022-03-25T14:06:29Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -70,7 +70,24 @@ internal enum HandshakeOptions\n         NET = 64,\n     }\n \n-    internal readonly struct Handshake\n+    internal interface IHandshake",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Some of this code looks copied from the original `Handshake`. Do you think it would be worth deduping? By introducing a base class or a helper method maybe.",
              "createdAt": "2022-03-25T14:09:11Z",
              "path": "src/Build/BackEnd/Components/Communications/ServerNodeHandshake.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeffusing System;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.Security.Cryptography;\n+using System.Text;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal class ServerNodeHandshake : IHandshake\n+    {\n+        readonly int _options;\n+        readonly int _salt;\n+        readonly int _fileVersionMajor;\n+        readonly int _fileVersionMinor;\n+        readonly int _fileVersionBuild;\n+        readonly int _fileVersionRevision;\n+\n+        internal ServerNodeHandshake(HandshakeOptions nodeType, string msBuildLocation)\n+        {\n+            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.\n+            // This indicates in the first byte that we are a modern build.\n+            _options = (int)nodeType | (CommunicationsUtilities.handshakeVersion << 24);\n+            string? handshakeSalt = Environment.GetEnvironmentVariable(\"MSBUILDNODEHANDSHAKESALT\");\n+            var msBuildFile = new FileInfo(msBuildLocation);\n+            var msBuildDirectory = msBuildFile.DirectoryName;\n+            _salt = ComputeHandshakeHash(handshakeSalt + msBuildDirectory);\n+            Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(msBuildLocation).FileVersion ?? string.Empty);\n+            _fileVersionMajor = fileVersion.Major;\n+            _fileVersionMinor = fileVersion.Minor;\n+            _fileVersionBuild = fileVersion.Build;\n+            _fileVersionRevision = fileVersion.Revision;",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Can you explain why we need a new handshake at all? The point of the original handshake is that both sides need to come up with the same thing. I don't like the idea of adding a new thing here without good justification.",
              "createdAt": "2022-03-25T19:25:38Z",
              "path": "src/Build/BackEnd/Components/Communications/ServerNodeHandshake.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeffusing System;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.Security.Cryptography;\n+using System.Text;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal class ServerNodeHandshake : IHandshake\n+    {\n+        readonly int _options;\n+        readonly int _salt;\n+        readonly int _fileVersionMajor;\n+        readonly int _fileVersionMinor;\n+        readonly int _fileVersionBuild;\n+        readonly int _fileVersionRevision;\n+\n+        internal ServerNodeHandshake(HandshakeOptions nodeType, string msBuildLocation)\n+        {\n+            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.\n+            // This indicates in the first byte that we are a modern build.\n+            _options = (int)nodeType | (CommunicationsUtilities.handshakeVersion << 24);\n+            string? handshakeSalt = Environment.GetEnvironmentVariable(\"MSBUILDNODEHANDSHAKESALT\");\n+            var msBuildFile = new FileInfo(msBuildLocation);\n+            var msBuildDirectory = msBuildFile.DirectoryName;\n+            _salt = ComputeHandshakeHash(handshakeSalt + msBuildDirectory);\n+            Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(msBuildLocation).FileVersion ?? string.Empty);\n+            _fileVersionMajor = fileVersion.Major;\n+            _fileVersionMinor = fileVersion.Minor;\n+            _fileVersionBuild = fileVersion.Build;\n+            _fileVersionRevision = fileVersion.Revision;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I had same question. Handshake from prototype was a little bit different, but I had to align it with current codebase, so it looks almost same now. The main difference is that server doesn't need session ID. We can remove duplicates by (for example) inheritance - if it's OK to change the original handshake from value type to reference type.\r\n\r\ncc: @rokonec ",
              "createdAt": "2022-03-28T08:58:17Z",
              "path": "src/Build/BackEnd/Components/Communications/ServerNodeHandshake.cs",
              "diffHunk": "@@ -0,0 +1,88 @@\n+\ufeffusing System;\n+using System.Diagnostics;\n+using System.Globalization;\n+using System.IO;\n+using System.Security.Cryptography;\n+using System.Text;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal class ServerNodeHandshake : IHandshake\n+    {\n+        readonly int _options;\n+        readonly int _salt;\n+        readonly int _fileVersionMajor;\n+        readonly int _fileVersionMinor;\n+        readonly int _fileVersionBuild;\n+        readonly int _fileVersionRevision;\n+\n+        internal ServerNodeHandshake(HandshakeOptions nodeType, string msBuildLocation)\n+        {\n+            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.\n+            // This indicates in the first byte that we are a modern build.\n+            _options = (int)nodeType | (CommunicationsUtilities.handshakeVersion << 24);\n+            string? handshakeSalt = Environment.GetEnvironmentVariable(\"MSBUILDNODEHANDSHAKESALT\");\n+            var msBuildFile = new FileInfo(msBuildLocation);\n+            var msBuildDirectory = msBuildFile.DirectoryName;\n+            _salt = ComputeHandshakeHash(handshakeSalt + msBuildDirectory);\n+            Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(msBuildLocation).FileVersion ?? string.Empty);\n+            _fileVersionMajor = fileVersion.Major;\n+            _fileVersionMinor = fileVersion.Minor;\n+            _fileVersionBuild = fileVersion.Build;\n+            _fileVersionRevision = fileVersion.Revision;",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why compute a hash (costs some CPU, has some minor risk of collisions) when we could use the stringified handshake in its full form, just fixed up to not contain path-invalid characters?",
              "createdAt": "2022-03-25T14:14:32Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Pipe name has limited length, so there would be a risk that we will exceed the limit. Hash computation is required only once during node initialization, so I guess there is not a critical perf hit.\r\nIt would be nice to have human readable name and save some cycles and code complexity, but same approach was used by Roslyn team.",
              "createdAt": "2022-03-28T08:50:45Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Yes pipe name size limit is the main reason. It is worth to mention that hashing ideas was adopted, as many other stuff in msbuild server prototype, from roslyn server `vbcscompiler`.",
              "createdAt": "2022-04-07T13:39:47Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Aren't these `Dispose` calls redundant when `outWriter` and `errWriter` are declared with `using` declaration above?",
              "createdAt": "2022-03-25T14:18:45Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuilCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+\n+            using var outWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 1));\n+            });\n+            using var errWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 2));\n+            });\n+\n+            Console.SetOut(outWriter);\n+            Console.SetError(errWriter);\n+\n+            var (exitCode, exitType) = _buildFunction(command.CommandLine);\n+\n+            Console.SetOut(oldOut);\n+            Console.SetError(oldErr);\n+            outWriter.Dispose();\n+            errWriter.Dispose();",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "That's right. I didn't notice when I was moving the code.",
              "createdAt": "2022-03-28T14:02:04Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuilCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+\n+            using var outWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 1));\n+            });\n+            using var errWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 2));\n+            });\n+\n+            Console.SetOut(outWriter);\n+            Console.SetError(errWriter);\n+\n+            var (exitCode, exitType) = _buildFunction(command.CommandLine);\n+\n+            Console.SetOut(oldOut);\n+            Console.SetError(oldErr);\n+            outWriter.Dispose();\n+            errWriter.Dispose();",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `sealed` (applies to most classes introduced in the PR).",
              "createdAt": "2022-03-25T14:19:53Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuilCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+\n+            using var outWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 1));\n+            });\n+            using var errWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 2));\n+            });\n+\n+            Console.SetOut(outWriter);\n+            Console.SetError(errWriter);\n+\n+            var (exitCode, exitType) = _buildFunction(command.CommandLine);\n+\n+            Console.SetOut(oldOut);\n+            Console.SetError(oldErr);\n+            outWriter.Dispose();\n+            errWriter.Dispose();\n+\n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeResponse(exitCode, exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        // TODO: unit tests\n+        internal class RedirectConsoleWriter : StringWriter",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Should catch only the specific exception type(s) expected here (`WaitHandleCannotBeOpenedException` and `UnauthorizedAccessException`)?",
              "createdAt": "2022-03-25T15:01:11Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuilCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+\n+            using var outWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 1));\n+            });\n+            using var errWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 2));\n+            });\n+\n+            Console.SetOut(outWriter);\n+            Console.SetError(errWriter);\n+\n+            var (exitCode, exitType) = _buildFunction(command.CommandLine);\n+\n+            Console.SetOut(oldOut);\n+            Console.SetError(oldErr);\n+            outWriter.Dispose();\n+            errWriter.Dispose();\n+\n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeResponse(exitCode, exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        // TODO: unit tests\n+        internal class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly string _newLineString;\n+\n+            private readonly Action<string> _writeCallback;\n+\n+            public RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _newLineString = new String(CoreNewLine);\n+                _writeCallback = writeCallback;\n+            }\n+\n+            private void MaybeFlushCaptured(bool force)\n+            {\n+                if (force || GetStringBuilder().Length > 200)\n+                {\n+                    Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+\n+            public override void Write(char value)\n+            {\n+                base.Write(value);\n+                MaybeFlushCaptured(false);\n+            }\n+\n+            public override void Write(char[] buffer, int index, int count)\n+            {\n+                base.Write(buffer, index, count);\n+                MaybeFlushCaptured(buffer.SequenceEqual(CoreNewLine));\n+            }\n+\n+            public override void Write(string? value)\n+            {\n+                if (value is null)\n+                {\n+                    return;\n+                }\n+\n+                base.Write(value);\n+                MaybeFlushCaptured(value.Contains(_newLineString));\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Handles the NodeBuildComplete packet.\n+        /// </summary>\n+        private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)\n+        {\n+            _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;\n+            _shutdownEvent.Set();\n+        }\n+\n+        internal sealed class ServerNamedMutex : IDisposable\n+        {\n+            public readonly Mutex _serverMutex;\n+\n+            public bool IsDisposed { get; private set; }\n+\n+            public bool IsLocked { get; private set; }\n+\n+            public ServerNamedMutex(string mutexName, out bool createdNew)\n+            {\n+                _serverMutex = new Mutex(\n+                    initiallyOwned: true,\n+                    name: mutexName,\n+                    createdNew: out createdNew);\n+\n+                if (createdNew)\n+                {\n+                    IsLocked = true;\n+                }\n+            }\n+\n+            internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+            {\n+                // TODO: verify it is not needed anymore\n+                // if (PlatformInformation.IsRunningOnMono)\n+                // {\n+                //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);\n+                // }\n+                // else\n+\n+                return new ServerNamedMutex(name, out createdNew);\n+            }\n+\n+            public static bool WasOpen(string mutexName)\n+            {\n+                try\n+                {\n+                    // we can't use TryOpenExisting as it is not supported in net3.5\n+                    using var m = Mutex.OpenExisting(mutexName);\n+                    return true;\n+                }\n+                catch",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I moved this type from shared code and it will not be compiled while targeting net35, so I will use `TryOpenExisting`.",
              "createdAt": "2022-03-28T14:24:50Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuilCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+\n+            using var outWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 1));\n+            });\n+            using var errWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 2));\n+            });\n+\n+            Console.SetOut(outWriter);\n+            Console.SetError(errWriter);\n+\n+            var (exitCode, exitType) = _buildFunction(command.CommandLine);\n+\n+            Console.SetOut(oldOut);\n+            Console.SetError(oldErr);\n+            outWriter.Dispose();\n+            errWriter.Dispose();\n+\n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeResponse(exitCode, exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        // TODO: unit tests\n+        internal class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly string _newLineString;\n+\n+            private readonly Action<string> _writeCallback;\n+\n+            public RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _newLineString = new String(CoreNewLine);\n+                _writeCallback = writeCallback;\n+            }\n+\n+            private void MaybeFlushCaptured(bool force)\n+            {\n+                if (force || GetStringBuilder().Length > 200)\n+                {\n+                    Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+\n+            public override void Write(char value)\n+            {\n+                base.Write(value);\n+                MaybeFlushCaptured(false);\n+            }\n+\n+            public override void Write(char[] buffer, int index, int count)\n+            {\n+                base.Write(buffer, index, count);\n+                MaybeFlushCaptured(buffer.SequenceEqual(CoreNewLine));\n+            }\n+\n+            public override void Write(string? value)\n+            {\n+                if (value is null)\n+                {\n+                    return;\n+                }\n+\n+                base.Write(value);\n+                MaybeFlushCaptured(value.Contains(_newLineString));\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Handles the NodeBuildComplete packet.\n+        /// </summary>\n+        private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)\n+        {\n+            _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;\n+            _shutdownEvent.Set();\n+        }\n+\n+        internal sealed class ServerNamedMutex : IDisposable\n+        {\n+            public readonly Mutex _serverMutex;\n+\n+            public bool IsDisposed { get; private set; }\n+\n+            public bool IsLocked { get; private set; }\n+\n+            public ServerNamedMutex(string mutexName, out bool createdNew)\n+            {\n+                _serverMutex = new Mutex(\n+                    initiallyOwned: true,\n+                    name: mutexName,\n+                    createdNew: out createdNew);\n+\n+                if (createdNew)\n+                {\n+                    IsLocked = true;\n+                }\n+            }\n+\n+            internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)\n+            {\n+                // TODO: verify it is not needed anymore\n+                // if (PlatformInformation.IsRunningOnMono)\n+                // {\n+                //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);\n+                // }\n+                // else\n+\n+                return new ServerNamedMutex(name, out createdNew);\n+            }\n+\n+            public static bool WasOpen(string mutexName)\n+            {\n+                try\n+                {\n+                    // we can't use TryOpenExisting as it is not supported in net3.5\n+                    using var m = Mutex.OpenExisting(mutexName);\n+                    return true;\n+                }\n+                catch",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Would it be more appropriate to call it `ServerNodeResult` or `ServerNodeBuildResult`? \"Response\" tends to be used as the counterpart to \"Request\" here.",
              "createdAt": "2022-03-25T15:20:12Z",
              "path": "src/Shared/INodePacket.cs",
              "diffHunk": "@@ -189,6 +189,24 @@ internal enum NodePacketType : byte\n         /// Message sent back to a node informing it about the resource that were granted by the scheduler.\n         /// </summary>\n         ResourceResponse,\n+\n+        /// <summary>\n+        /// Command in form of MSBuild command line for server node - MSBuild Server.\n+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n+        /// </summary>\n+        ServerNodeBuilCommand = 0xF0,\n+\n+        /// <summary>\n+        /// Response from server node command\n+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n+        /// </summary>\n+        ServerNodeResponse = 0xF1,",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Make sense",
              "createdAt": "2022-03-28T14:21:41Z",
              "path": "src/Shared/INodePacket.cs",
              "diffHunk": "@@ -189,6 +189,24 @@ internal enum NodePacketType : byte\n         /// Message sent back to a node informing it about the resource that were granted by the scheduler.\n         /// </summary>\n         ResourceResponse,\n+\n+        /// <summary>\n+        /// Command in form of MSBuild command line for server node - MSBuild Server.\n+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n+        /// </summary>\n+        ServerNodeBuilCommand = 0xF0,\n+\n+        /// <summary>\n+        /// Response from server node command\n+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n+        /// </summary>\n+        ServerNodeResponse = 0xF1,",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "super-nit: Use `IsNullOrEmpty` to skip empty strings as well?",
              "createdAt": "2022-03-25T15:27:29Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuilCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+\n+            using var outWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 1));\n+            });\n+            using var errWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 2));\n+            });\n+\n+            Console.SetOut(outWriter);\n+            Console.SetError(errWriter);\n+\n+            var (exitCode, exitType) = _buildFunction(command.CommandLine);\n+\n+            Console.SetOut(oldOut);\n+            Console.SetError(oldErr);\n+            outWriter.Dispose();\n+            errWriter.Dispose();\n+\n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeResponse(exitCode, exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        // TODO: unit tests\n+        internal class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly string _newLineString;\n+\n+            private readonly Action<string> _writeCallback;\n+\n+            public RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _newLineString = new String(CoreNewLine);\n+                _writeCallback = writeCallback;\n+            }\n+\n+            private void MaybeFlushCaptured(bool force)\n+            {\n+                if (force || GetStringBuilder().Length > 200)\n+                {\n+                    Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+\n+            public override void Write(char value)\n+            {\n+                base.Write(value);\n+                MaybeFlushCaptured(false);\n+            }\n+\n+            public override void Write(char[] buffer, int index, int count)\n+            {\n+                base.Write(buffer, index, count);\n+                MaybeFlushCaptured(buffer.SequenceEqual(CoreNewLine));\n+            }\n+\n+            public override void Write(string? value)\n+            {\n+                if (value is null)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I guess we will not have a lot of empty strings (if any). But we can measure :)",
              "createdAt": "2022-03-28T14:37:41Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuilCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+\n+            using var outWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 1));\n+            });\n+            using var errWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 2));\n+            });\n+\n+            Console.SetOut(outWriter);\n+            Console.SetError(errWriter);\n+\n+            var (exitCode, exitType) = _buildFunction(command.CommandLine);\n+\n+            Console.SetOut(oldOut);\n+            Console.SetError(oldErr);\n+            outWriter.Dispose();\n+            errWriter.Dispose();\n+\n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeResponse(exitCode, exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        // TODO: unit tests\n+        internal class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly string _newLineString;\n+\n+            private readonly Action<string> _writeCallback;\n+\n+            public RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _newLineString = new String(CoreNewLine);\n+                _writeCallback = writeCallback;\n+            }\n+\n+            private void MaybeFlushCaptured(bool force)\n+            {\n+                if (force || GetStringBuilder().Length > 200)\n+                {\n+                    Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+\n+            public override void Write(char value)\n+            {\n+                base.Write(value);\n+                MaybeFlushCaptured(false);\n+            }\n+\n+            public override void Write(char[] buffer, int index, int count)\n+            {\n+                base.Write(buffer, index, count);\n+                MaybeFlushCaptured(buffer.SequenceEqual(CoreNewLine));\n+            }\n+\n+            public override void Write(string? value)\n+            {\n+                if (value is null)",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Custom `Write` overrides were removed.",
              "createdAt": "2022-04-07T12:19:33Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuilCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+\n+            using var outWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 1));\n+            });\n+            using var errWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 2));\n+            });\n+\n+            Console.SetOut(outWriter);\n+            Console.SetError(errWriter);\n+\n+            var (exitCode, exitType) = _buildFunction(command.CommandLine);\n+\n+            Console.SetOut(oldOut);\n+            Console.SetError(oldErr);\n+            outWriter.Dispose();\n+            errWriter.Dispose();\n+\n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeResponse(exitCode, exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        // TODO: unit tests\n+        internal class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly string _newLineString;\n+\n+            private readonly Action<string> _writeCallback;\n+\n+            public RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _newLineString = new String(CoreNewLine);\n+                _writeCallback = writeCallback;\n+            }\n+\n+            private void MaybeFlushCaptured(bool force)\n+            {\n+                if (force || GetStringBuilder().Length > 200)\n+                {\n+                    Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+\n+            public override void Write(char value)\n+            {\n+                base.Write(value);\n+                MaybeFlushCaptured(false);\n+            }\n+\n+            public override void Write(char[] buffer, int index, int count)\n+            {\n+                base.Write(buffer, index, count);\n+                MaybeFlushCaptured(buffer.SequenceEqual(CoreNewLine));\n+            }\n+\n+            public override void Write(string? value)\n+            {\n+                if (value is null)",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it intentional that this behaves differently than `Write(string?)`. Is the idea flushing the buffer if it *contains* the new-line sequence or if it is the new-line sequence?",
              "createdAt": "2022-03-25T15:31:55Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuilCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+\n+            using var outWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 1));\n+            });\n+            using var errWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 2));\n+            });\n+\n+            Console.SetOut(outWriter);\n+            Console.SetError(errWriter);\n+\n+            var (exitCode, exitType) = _buildFunction(command.CommandLine);\n+\n+            Console.SetOut(oldOut);\n+            Console.SetError(oldErr);\n+            outWriter.Dispose();\n+            errWriter.Dispose();\n+\n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeResponse(exitCode, exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        // TODO: unit tests\n+        internal class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly string _newLineString;\n+\n+            private readonly Action<string> _writeCallback;\n+\n+            public RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _newLineString = new String(CoreNewLine);\n+                _writeCallback = writeCallback;\n+            }\n+\n+            private void MaybeFlushCaptured(bool force)\n+            {\n+                if (force || GetStringBuilder().Length > 200)\n+                {\n+                    Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+\n+            public override void Write(char value)\n+            {\n+                base.Write(value);\n+                MaybeFlushCaptured(false);\n+            }\n+\n+            public override void Write(char[] buffer, int index, int count)\n+            {\n+                base.Write(buffer, index, count);\n+                MaybeFlushCaptured(buffer.SequenceEqual(CoreNewLine));",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "As I mentioned in notes, the flushing logic will be modified. I only removed console color handling, because we will use ANSI codes.",
              "createdAt": "2022-03-28T14:31:30Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuilCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+\n+            using var outWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 1));\n+            });\n+            using var errWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 2));\n+            });\n+\n+            Console.SetOut(outWriter);\n+            Console.SetError(errWriter);\n+\n+            var (exitCode, exitType) = _buildFunction(command.CommandLine);\n+\n+            Console.SetOut(oldOut);\n+            Console.SetError(oldErr);\n+            outWriter.Dispose();\n+            errWriter.Dispose();\n+\n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeResponse(exitCode, exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        // TODO: unit tests\n+        internal class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly string _newLineString;\n+\n+            private readonly Action<string> _writeCallback;\n+\n+            public RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _newLineString = new String(CoreNewLine);\n+                _writeCallback = writeCallback;\n+            }\n+\n+            private void MaybeFlushCaptured(bool force)\n+            {\n+                if (force || GetStringBuilder().Length > 200)\n+                {\n+                    Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+\n+            public override void Write(char value)\n+            {\n+                base.Write(value);\n+                MaybeFlushCaptured(false);\n+            }\n+\n+            public override void Write(char[] buffer, int index, int count)\n+            {\n+                base.Write(buffer, index, count);\n+                MaybeFlushCaptured(buffer.SequenceEqual(CoreNewLine));",
              "author": {
                "login": "MichalPavlik"
              }
            },
            {
              "body": "Custom `Write` overrides were removed.",
              "createdAt": "2022-04-07T12:19:56Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,516 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuilCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuilCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+\n+            using var outWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 1));\n+            });\n+            using var errWriter = new RedirectConsoleWriter(text =>\n+            {\n+                SendPacket(new ServerNodeConsoleWrite(text, 2));\n+            });\n+\n+            Console.SetOut(outWriter);\n+            Console.SetError(errWriter);\n+\n+            var (exitCode, exitType) = _buildFunction(command.CommandLine);\n+\n+            Console.SetOut(oldOut);\n+            Console.SetError(oldErr);\n+            outWriter.Dispose();\n+            errWriter.Dispose();\n+\n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeResponse(exitCode, exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        // TODO: unit tests\n+        internal class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly string _newLineString;\n+\n+            private readonly Action<string> _writeCallback;\n+\n+            public RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _newLineString = new String(CoreNewLine);\n+                _writeCallback = writeCallback;\n+            }\n+\n+            private void MaybeFlushCaptured(bool force)\n+            {\n+                if (force || GetStringBuilder().Length > 200)\n+                {\n+                    Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+\n+            public override void Write(char value)\n+            {\n+                base.Write(value);\n+                MaybeFlushCaptured(false);\n+            }\n+\n+            public override void Write(char[] buffer, int index, int count)\n+            {\n+                base.Write(buffer, index, count);\n+                MaybeFlushCaptured(buffer.SequenceEqual(CoreNewLine));",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Why this packet type is named differently than the corresponding class? Is that deliberate?",
              "createdAt": "2022-03-30T08:10:42Z",
              "path": "src/Shared/INodePacket.cs",
              "diffHunk": "@@ -189,6 +189,24 @@ internal enum NodePacketType : byte\n         /// Message sent back to a node informing it about the resource that were granted by the scheduler.\n         /// </summary>\n         ResourceResponse,\n+\n+        /// <summary>\n+        /// Command in form of MSBuild command line for server node - MSBuild Server.\n+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n+        /// </summary>\n+        ServerNodeBuildCommand = 0xF0,\n+\n+        /// <summary>\n+        /// Response from server node command\n+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n+        /// </summary>\n+        ServerNodeBuildResult = 0xF1,\n+\n+        /// <summary>\n+        /// Info about server console activity. \n+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n+        /// </summary>\n+        ServerNodeConsole = 0xF2,",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Why this packet type is named differently than the corresponding class? Is that deliberate?",
              "createdAt": "2022-03-30T08:10:42Z",
              "path": "src/Shared/INodePacket.cs",
              "diffHunk": "@@ -189,6 +189,24 @@ internal enum NodePacketType : byte\n         /// Message sent back to a node informing it about the resource that were granted by the scheduler.\n         /// </summary>\n         ResourceResponse,\n+\n+        /// <summary>\n+        /// Command in form of MSBuild command line for server node - MSBuild Server.\n+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n+        /// </summary>\n+        ServerNodeBuildCommand = 0xF0,\n+\n+        /// <summary>\n+        /// Response from server node command\n+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n+        /// </summary>\n+        ServerNodeBuildResult = 0xF1,\n+\n+        /// <summary>\n+        /// Info about server console activity. \n+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n+        /// </summary>\n+        ServerNodeConsole = 0xF2,",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: It is my understanding that `enableReuse` concerns other nodes than this one. In fact, it tells us if we wish to reuse other regular long-living MSBuild nodes or to create new ones.",
              "createdAt": "2022-03-30T08:19:45Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,506 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I agree, non reusable msbuild server node does not make sense. Please clean this file from `enableReuse`. It should always reuse.",
              "createdAt": "2022-04-07T13:36:17Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,506 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: It is my understanding that `enableReuse` concerns other nodes that this one. In fact, it tells us if we wish to reuse other regular long-living MSBuild nodes or to create new ones.",
              "createdAt": "2022-03-30T08:19:45Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,506 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I do not believe that `nodeReuse` should be part of the handshake between client and server. It is needed to be a part of handshake between regular MSBuild nodes and MSBuild server / the starting MSBuild node, but is there any reason for it to be here?",
              "createdAt": "2022-03-30T08:23:37Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,506 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I removed it. The hash will always have a default value for node reuse.",
              "createdAt": "2022-04-20T12:23:11Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,506 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I do not believe that `nodeReuse` should be part of the handshake between client and server. It is needed to be a part of handshake between regular MSBuild nodes and MSBuild server / the starting MSBuild node, but is there any reason for it to be here?",
              "createdAt": "2022-03-30T08:23:37Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,506 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I removed it. The hash will always have a default value for node reuse.",
              "createdAt": "2022-04-20T12:23:24Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,506 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `lowpriority` -> `lowPriority` ?",
              "createdAt": "2022-03-30T10:33:30Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2614,6 +2614,48 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)\n                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();\n                     shutdownReason = node.Run(out nodeException);\n                 }\n+                else if (nodeModeNumber == 8)\n+                {\n+                    // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False\n+                    bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);\n+                    string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];\n+                    bool lowpriority = lowPriorityInput.Length > 0 && lowPriorityInput[0].Equals(\"true\");",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Concerning `lowpriority` here. Is that good that if we start two builds with different priorities it should start two different server processes that would accept requests according to priority too? Could we instead not put priority in the handshake and switch the priority of the process according to the value we get, so we have one server process for both high priority and low priority?  ",
              "createdAt": "2022-03-30T10:45:08Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2614,6 +2614,48 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)\n                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();\n                     shutdownReason = node.Run(out nodeException);\n                 }\n+                else if (nodeModeNumber == 8)\n+                {\n+                    // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False\n+                    bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);\n+                    string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];\n+                    bool lowpriority = lowPriorityInput.Length > 0 && lowPriorityInput[0].Equals(\"true\");\n+\n+                    // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly\n+                    // we have to pass down xmake build invocation to avoid circular dependency\n+                    Func<string, (int exitCode, string exitType)> buildFunction = (commandLine) =>\n+                    {\n+                        int exitCode;\n+                        ExitType exitType;\n+\n+                        if (!s_initialized)\n+                        {\n+                            exitType = ExitType.InitializationError;\n+                        }\n+                        else\n+                        {\n+                            exitType = Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                                    commandLine\n+#else\n+                                    QuotingUtilities.SplitUnquoted(commandLine).ToArray()\n+#endif\n+                                );\n+                            exitCode = exitType == ExitType.Success ? 0 : 1;\n+                        }\n+                        exitCode = exitType == ExitType.Success ? 0 : 1;\n+\n+                        return (exitCode, exitType.ToString());\n+                    };\n+\n+                    // commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters]\n+\n+                    OutOfProcServerNode node = new(buildFunction);\n+\n+                    shutdownReason = node.Run(nodeReuse, lowpriority, out nodeException);",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "This would require more work than just changing the priority of the server process. Not only would it have to propagate to worker/taskhost nodes, but other child processes that inherited the priority from its MSBuild parent would have to be tweaked as well (*\"that\"* because we don't know if those processes inherited their priority from MSBuild or if they set it explicitly).\r\n\r\nSo probably doable, albeit with subtle issues, but probably not worth it.",
              "createdAt": "2022-03-30T12:02:13Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2614,6 +2614,48 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)\n                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();\n                     shutdownReason = node.Run(out nodeException);\n                 }\n+                else if (nodeModeNumber == 8)\n+                {\n+                    // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False\n+                    bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);\n+                    string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];\n+                    bool lowpriority = lowPriorityInput.Length > 0 && lowPriorityInput[0].Equals(\"true\");\n+\n+                    // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly\n+                    // we have to pass down xmake build invocation to avoid circular dependency\n+                    Func<string, (int exitCode, string exitType)> buildFunction = (commandLine) =>\n+                    {\n+                        int exitCode;\n+                        ExitType exitType;\n+\n+                        if (!s_initialized)\n+                        {\n+                            exitType = ExitType.InitializationError;\n+                        }\n+                        else\n+                        {\n+                            exitType = Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                                    commandLine\n+#else\n+                                    QuotingUtilities.SplitUnquoted(commandLine).ToArray()\n+#endif\n+                                );\n+                            exitCode = exitType == ExitType.Success ? 0 : 1;\n+                        }\n+                        exitCode = exitType == ExitType.Success ? 0 : 1;\n+\n+                        return (exitCode, exitType.ToString());\n+                    };\n+\n+                    // commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters]\n+\n+                    OutOfProcServerNode node = new(buildFunction);\n+\n+                    shutdownReason = node.Run(nodeReuse, lowpriority, out nodeException);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I see, yes, if it is more subtle than changing the priority right away, then it might be not worth it.",
              "createdAt": "2022-03-30T12:34:27Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2614,6 +2614,48 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)\n                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();\n                     shutdownReason = node.Run(out nodeException);\n                 }\n+                else if (nodeModeNumber == 8)\n+                {\n+                    // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False\n+                    bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);\n+                    string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];\n+                    bool lowpriority = lowPriorityInput.Length > 0 && lowPriorityInput[0].Equals(\"true\");\n+\n+                    // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly\n+                    // we have to pass down xmake build invocation to avoid circular dependency\n+                    Func<string, (int exitCode, string exitType)> buildFunction = (commandLine) =>\n+                    {\n+                        int exitCode;\n+                        ExitType exitType;\n+\n+                        if (!s_initialized)\n+                        {\n+                            exitType = ExitType.InitializationError;\n+                        }\n+                        else\n+                        {\n+                            exitType = Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                                    commandLine\n+#else\n+                                    QuotingUtilities.SplitUnquoted(commandLine).ToArray()\n+#endif\n+                                );\n+                            exitCode = exitType == ExitType.Success ? 0 : 1;\n+                        }\n+                        exitCode = exitType == ExitType.Success ? 0 : 1;\n+\n+                        return (exitCode, exitType.ToString());\n+                    };\n+\n+                    // commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters]\n+\n+                    OutOfProcServerNode node = new(buildFunction);\n+\n+                    shutdownReason = node.Run(nodeReuse, lowpriority, out nodeException);",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Based on our discussion, I removed low prio and node reuse part of the hash.",
              "createdAt": "2022-04-20T12:19:13Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -2614,6 +2614,48 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)\n                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();\n                     shutdownReason = node.Run(out nodeException);\n                 }\n+                else if (nodeModeNumber == 8)\n+                {\n+                    // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False\n+                    bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);\n+                    string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];\n+                    bool lowpriority = lowPriorityInput.Length > 0 && lowPriorityInput[0].Equals(\"true\");\n+\n+                    // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly\n+                    // we have to pass down xmake build invocation to avoid circular dependency\n+                    Func<string, (int exitCode, string exitType)> buildFunction = (commandLine) =>\n+                    {\n+                        int exitCode;\n+                        ExitType exitType;\n+\n+                        if (!s_initialized)\n+                        {\n+                            exitType = ExitType.InitializationError;\n+                        }\n+                        else\n+                        {\n+                            exitType = Execute(\n+#if FEATURE_GET_COMMANDLINE\n+                                    commandLine\n+#else\n+                                    QuotingUtilities.SplitUnquoted(commandLine).ToArray()\n+#endif\n+                                );\n+                            exitCode = exitType == ExitType.Success ? 0 : 1;\n+                        }\n+                        exitCode = exitType == ExitType.Success ? 0 : 1;\n+\n+                        return (exitCode, exitType.ToString());\n+                    };\n+\n+                    // commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters]\n+\n+                    OutOfProcServerNode node = new(buildFunction);\n+\n+                    shutdownReason = node.Run(nodeReuse, lowpriority, out nodeException);",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Doc seems to be outdated.",
              "createdAt": "2022-04-07T13:30:43Z",
              "path": "src/Build/BackEnd/Components/Communications/ServerNodeEndpointOutOfProc.cs",
              "diffHunk": "@@ -0,0 +1,46 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// This is an implementation of INodeEndpoint for the out-of-proc nodes.  It acts only as a client.",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since we introducing new code, I vote for getting rid of regions in such simple class.",
              "createdAt": "2022-04-07T13:31:37Z",
              "path": "src/Build/BackEnd/Components/Communications/ServerNodeEndpointOutOfProc.cs",
              "diffHunk": "@@ -0,0 +1,46 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// This is an implementation of INodeEndpoint for the out-of-proc nodes.  It acts only as a client.\n+    /// </summary>\n+    internal sealed class ServerNodeEndpointOutOfProc : NodeEndpointOutOfProcBase\n+    {\n+        #region Private Data",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Yeah, I'm totally for removing them at least in simple types.",
              "createdAt": "2022-04-07T13:32:38Z",
              "path": "src/Build/BackEnd/Components/Communications/ServerNodeEndpointOutOfProc.cs",
              "diffHunk": "@@ -0,0 +1,46 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// This is an implementation of INodeEndpoint for the out-of-proc nodes.  It acts only as a client.\n+    /// </summary>\n+    internal sealed class ServerNodeEndpointOutOfProc : NodeEndpointOutOfProcBase\n+    {\n+        #region Private Data",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This race condition will be most probably handled by client. Please change this command to describe our decision about how will client handle it.",
              "createdAt": "2022-04-07T14:00:51Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,486 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "There would be mutex `\"Global\\server-launch-{_pipeName}\"` for starting server process in a client. This does not guarantee that some other client, if anybody writes it, would not introduce a race condition, so the fast quit from server process in this case is still needed.",
              "createdAt": "2022-04-13T14:50:20Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,486 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT:  please conmsider to introduce some enums for that hardcoded `1` and `2`",
              "createdAt": "2022-04-07T14:11:44Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,486 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuildCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+            (int exitCode, string exitType) buildResult;\n+\n+            // Dispose must be called before the server sends response packet\n+            using (var outWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 1))))",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "If you do, make enum internal please, so client could use.",
              "createdAt": "2022-04-11T07:34:37Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,486 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuildCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+            (int exitCode, string exitType) buildResult;\n+\n+            // Dispose must be called before the server sends response packet\n+            using (var outWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 1))))",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            // Dispose must be called before the server sends ServerNodeBuildResult packet\r\n```",
              "createdAt": "2022-04-07T14:13:03Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,486 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuildCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+            (int exitCode, string exitType) buildResult;\n+\n+            // Dispose must be called before the server sends response packet",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: consider own file",
              "createdAt": "2022-04-07T14:14:52Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,486 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuildCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+            (int exitCode, string exitType) buildResult;\n+\n+            // Dispose must be called before the server sends response packet\n+            using (var outWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 1))))\n+            using (var errWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 2))))\n+            {\n+                Console.SetOut(outWriter);\n+                Console.SetError(errWriter);\n+\n+                buildResult = _buildFunction(command.CommandLine);\n+\n+                Console.SetOut(oldOut);\n+                Console.SetError(oldErr);\n+            }\n+          \n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeBuildResult(buildResult.exitCode, buildResult.exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        internal sealed class RedirectConsoleWriter : StringWriter",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "This type is not used anywhere except the server node. I would keep it here.",
              "createdAt": "2022-04-12T12:12:02Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,486 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuildCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+            (int exitCode, string exitType) buildResult;\n+\n+            // Dispose must be called before the server sends response packet\n+            using (var outWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 1))))\n+            using (var errWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 2))))\n+            {\n+                Console.SetOut(outWriter);\n+                Console.SetError(errWriter);\n+\n+                buildResult = _buildFunction(command.CommandLine);\n+\n+                Console.SetOut(oldOut);\n+                Console.SetError(oldErr);\n+            }\n+          \n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeBuildResult(buildResult.exitCode, buildResult.exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        internal sealed class RedirectConsoleWriter : StringWriter",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think it is not used as msbuild server client never send NodeBuildComplete, or does it?",
              "createdAt": "2022-04-07T14:18:42Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,486 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuildCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+            (int exitCode, string exitType) buildResult;\n+\n+            // Dispose must be called before the server sends response packet\n+            using (var outWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 1))))\n+            using (var errWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 2))))\n+            {\n+                Console.SetOut(outWriter);\n+                Console.SetError(errWriter);\n+\n+                buildResult = _buildFunction(command.CommandLine);\n+\n+                Console.SetOut(oldOut);\n+                Console.SetError(oldErr);\n+            }\n+          \n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeBuildResult(buildResult.exitCode, buildResult.exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        internal sealed class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly Action<string> _writeCallback;\n+            private readonly Timer _timer;\n+            private readonly TextWriter _syncWriter;\n+\n+            private RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _writeCallback = writeCallback;\n+                _syncWriter = Synchronized(this);\n+                _timer = new Timer(TimerCallback, null, 0, 200);\n+            }\n+\n+            public static TextWriter Create(Action<string> writeCallback)\n+            {\n+                RedirectConsoleWriter writer = new(writeCallback);\n+                return writer._syncWriter;\n+            }\n+\n+            private void TimerCallback(object? state)\n+            {\n+                if (GetStringBuilder().Length > 0)\n+                {\n+                    _syncWriter.Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    _timer.Dispose();\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Handles the NodeBuildComplete packet.\n+        /// </summary>\n+        private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I suggest in future we have some other message for shutdown between server and client. We should not reuse `NodeBuildComplete` for that, I suppose. However, shutting down is out of scope for the first PR, as far as I know. ",
              "createdAt": "2022-04-13T14:40:42Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,486 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuildCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+            (int exitCode, string exitType) buildResult;\n+\n+            // Dispose must be called before the server sends response packet\n+            using (var outWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 1))))\n+            using (var errWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 2))))\n+            {\n+                Console.SetOut(outWriter);\n+                Console.SetError(errWriter);\n+\n+                buildResult = _buildFunction(command.CommandLine);\n+\n+                Console.SetOut(oldOut);\n+                Console.SetError(oldErr);\n+            }\n+          \n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeBuildResult(buildResult.exitCode, buildResult.exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        internal sealed class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly Action<string> _writeCallback;\n+            private readonly Timer _timer;\n+            private readonly TextWriter _syncWriter;\n+\n+            private RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _writeCallback = writeCallback;\n+                _syncWriter = Synchronized(this);\n+                _timer = new Timer(TimerCallback, null, 0, 200);\n+            }\n+\n+            public static TextWriter Create(Action<string> writeCallback)\n+            {\n+                RedirectConsoleWriter writer = new(writeCallback);\n+                return writer._syncWriter;\n+            }\n+\n+            private void TimerCallback(object? state)\n+            {\n+                if (GetStringBuilder().Length > 0)\n+                {\n+                    _syncWriter.Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    _timer.Dispose();\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Handles the NodeBuildComplete packet.\n+        /// </summary>\n+        private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I removed it.",
              "createdAt": "2022-04-20T09:32:49Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,486 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes no node reuse.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            return Run(false, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// Assumes low priority is disabled.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)\n+        {\n+            return Run(enableReuse, false, out shutdownException);\n+        }\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"enableReuse\">Whether this node is eligible for reuse later.</param>\n+        /// <param name=\"lowPriority\">Whether this node should be running with low priority.</param>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuildCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+                case NodePacketType.NodeBuildComplete:\n+                    HandleNodeBuildComplete((NodeBuildComplete)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+            (int exitCode, string exitType) buildResult;\n+\n+            // Dispose must be called before the server sends response packet\n+            using (var outWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 1))))\n+            using (var errWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, 2))))\n+            {\n+                Console.SetOut(outWriter);\n+                Console.SetError(errWriter);\n+\n+                buildResult = _buildFunction(command.CommandLine);\n+\n+                Console.SetOut(oldOut);\n+                Console.SetError(oldErr);\n+            }\n+          \n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeBuildResult(buildResult.exitCode, buildResult.exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        internal sealed class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly Action<string> _writeCallback;\n+            private readonly Timer _timer;\n+            private readonly TextWriter _syncWriter;\n+\n+            private RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _writeCallback = writeCallback;\n+                _syncWriter = Synchronized(this);\n+                _timer = new Timer(TimerCallback, null, 0, 200);\n+            }\n+\n+            public static TextWriter Create(Action<string> writeCallback)\n+            {\n+                RedirectConsoleWriter writer = new(writeCallback);\n+                return writer._syncWriter;\n+            }\n+\n+            private void TimerCallback(object? state)\n+            {\n+                if (GetStringBuilder().Length > 0)\n+                {\n+                    _syncWriter.Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    _timer.Dispose();\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Handles the NodeBuildComplete packet.\n+        /// </summary>\n+        private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please rewrite by commonly used `translator.Translate(ref something)`.",
              "createdAt": "2022-04-07T14:22:09Z",
              "path": "src/Build/BackEnd/Node/ServerNodeBuildCommand.cs",
              "diffHunk": "@@ -0,0 +1,109 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Globalization;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    /// <summary>\n+    /// Contains all of the information necessary for a entry node to run a command line.\n+    /// </summary>\n+    internal sealed class ServerNodeBuildCommand : INodePacket\n+    {\n+        public ServerNodeBuildCommand(string commandLine, string startupDirectory, Dictionary<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture)\n+        {\n+            CommandLine = commandLine;\n+            StartupDirectory = startupDirectory;\n+            BuildProcessEnvironment = buildProcessEnvironment;\n+            Culture = culture;\n+            UICulture = uiCulture;\n+        }\n+\n+        /// <summary>\n+        /// Private constructor for deserialization\n+        /// </summary>\n+        private ServerNodeBuildCommand()\n+        {\n+        }\n+\n+        #region INodePacket Members\n+\n+        /// <summary>\n+        /// Retrieves the packet type.\n+        /// </summary>\n+        public NodePacketType Type => NodePacketType.ServerNodeBuildCommand;\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// The startup directory\n+        /// </summary>\n+        public string CommandLine { get; private set; } = default!;\n+\n+        /// <summary>\n+        /// The startup directory\n+        /// </summary>\n+        public string StartupDirectory { get; private set; } = default!;\n+\n+        /// <summary>\n+        /// The process environment.\n+        /// </summary>\n+        public Dictionary<string, string> BuildProcessEnvironment { get; private set; } = default!;\n+\n+        /// <summary>\n+        /// The culture\n+        /// </summary>\n+        public CultureInfo Culture { get; private set; } = default!;\n+\n+        /// <summary>\n+        /// The UI culture.\n+        /// </summary>\n+        public CultureInfo UICulture { get; private set; } = default!;\n+\n+        #region INodePacketTranslatable Members\n+\n+        /// <summary>\n+        /// Translates the packet to/from binary form.\n+        /// </summary>\n+        /// <param name=\"translator\">The translator to use.</param>\n+        public void Translate(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.ReadFromStream)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please rewrite by commonly used `translator.Translate(ref something)`.",
              "createdAt": "2022-04-07T14:23:51Z",
              "path": "src/Build/BackEnd/Node/ServerNodeBuildResult.cs",
              "diffHunk": "@@ -0,0 +1,46 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+//\n+\n+using System;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class ServerNodeBuildResult : INodePacket\n+    {\n+        public ServerNodeBuildResult(int exitCode, string exitType)\n+        {\n+            ExitCode = exitCode;\n+            ExitType = exitType;\n+        }\n+\n+        #region INodePacket Members\n+\n+        /// <summary>\n+        /// Packet type.\n+        /// This has to be in sync with Microsoft.Build.BackEnd.NodePacketType.ServerNodeBuildCommand\n+        /// </summary>\n+        public NodePacketType Type => NodePacketType.ServerNodeBuildResult;\n+\n+        #endregion\n+\n+        public int ExitCode { get; }\n+\n+        public string ExitType { get; }\n+\n+        public void Translate(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Please rewrite by commonly used `translator.Translate(ref something)`.",
              "createdAt": "2022-04-07T14:26:02Z",
              "path": "src/Build/BackEnd/Node/ServerNodeConsoleWrite.cs",
              "diffHunk": "@@ -0,0 +1,47 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class ServerNodeConsoleWrite : INodePacket\n+    {\n+        public string Text { get; }\n+\n+        /// <summary>\n+        /// 1 = stdout, 2 = stderr\n+        /// </summary>\n+        public byte OutputType { get; }\n+\n+        public ServerNodeConsoleWrite(string text, byte outputType)\n+        {\n+            Text = text;\n+            OutputType = outputType;\n+        }\n+\n+        #region INodePacket Members\n+\n+        /// <summary>\n+        /// Packet type.\n+        /// </summary>\n+        public NodePacketType Type => NodePacketType.ServerNodeConsole;\n+\n+        #endregion\n+\n+        public void Translate(ITranslator translator)\n+        {\n+            if (translator.Mode == TranslationDirection.WriteToStream)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this needed?",
              "createdAt": "2022-04-07T14:26:54Z",
              "path": "src/Build/Logging/ConsoleLogger.cs",
              "diffHunk": "@@ -9,6 +9,7 @@\n using BaseConsoleLogger = Microsoft.Build.BackEnd.Logging.BaseConsoleLogger;\n using SerialConsoleLogger = Microsoft.Build.BackEnd.Logging.SerialConsoleLogger;\n using ParallelConsoleLogger = Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger;\n+using Microsoft.Build.Execution;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "No, it's relic from testing. I will remove it.",
              "createdAt": "2022-04-12T12:14:39Z",
              "path": "src/Build/Logging/ConsoleLogger.cs",
              "diffHunk": "@@ -9,6 +9,7 @@\n using BaseConsoleLogger = Microsoft.Build.BackEnd.Logging.BaseConsoleLogger;\n using SerialConsoleLogger = Microsoft.Build.BackEnd.Logging.SerialConsoleLogger;\n using ParallelConsoleLogger = Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger;\n+using Microsoft.Build.Execution;",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "NIT: the hosted suffix is confusing to me. Please consider to rename it to `s_isServerNode`",
              "createdAt": "2022-04-07T14:30:46Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1960,6 +1960,11 @@ private static bool IsEnvironmentVariable(string envVar)\n         /// </summary>\n         internal static bool usingSwitchesFromAutoResponseFile = false;\n \n+        /// <summary>\n+        /// Indicates that this process is working as a server.\n+        /// </summary>\n+        private static bool s_isServerNodeHosted;",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "I wasn't sure if the only node inside process will be the server node. But yes, I will change it.",
              "createdAt": "2022-04-12T12:16:52Z",
              "path": "src/MSBuild/XMake.cs",
              "diffHunk": "@@ -1960,6 +1960,11 @@ private static bool IsEnvironmentVariable(string envVar)\n         /// </summary>\n         internal static bool usingSwitchesFromAutoResponseFile = false;\n \n+        /// <summary>\n+        /// Indicates that this process is working as a server.\n+        /// </summary>\n+        private static bool s_isServerNodeHosted;",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since Handshake and IHandshake is internal, does this need to be public?",
              "createdAt": "2022-04-07T14:35:45Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -104,7 +123,7 @@ public override string ToString()\n             return String.Format(\"{0} {1} {2} {3} {4} {5} {6}\", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);\n         }\n \n-        internal int[] RetrieveHandshakeComponents()\n+        public int[] RetrieveHandshakeComponents()",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "The interface declares this method, so yes, it must be public.",
              "createdAt": "2022-04-12T12:21:55Z",
              "path": "src/Shared/CommunicationsUtilities.cs",
              "diffHunk": "@@ -104,7 +123,7 @@ public override string ToString()\n             return String.Format(\"{0} {1} {2} {3} {4} {5} {6}\", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);\n         }\n \n-        internal int[] RetrieveHandshakeComponents()\n+        public int[] RetrieveHandshakeComponents()",
              "author": {
                "login": "MichalPavlik"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could we get this class out of OutOfProcServerNode class? I do plan to reuse it in the server client too.",
              "createdAt": "2022-04-20T12:41:11Z",
              "path": "src/Build/BackEnd/Node/OutOfProcServerNode.cs",
              "diffHunk": "@@ -0,0 +1,448 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Internal;\n+\n+namespace Microsoft.Build.Execution\n+{\n+    /// <summary>\n+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server \n+    /// </summary>\n+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler\n+    {\n+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;\n+\n+        /// <summary>\n+        /// The endpoint used to talk to the host.\n+        /// </summary>\n+        private INodeEndpoint _nodeEndpoint = default!;\n+\n+        /// <summary>\n+        /// The packet factory.\n+        /// </summary>\n+        private readonly NodePacketFactory _packetFactory;\n+\n+        /// <summary>\n+        /// The queue of packets we have received but which have not yet been processed.\n+        /// </summary>\n+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;\n+\n+        /// <summary>\n+        /// The event which is set when we receive packets.\n+        /// </summary>\n+        private readonly AutoResetEvent _packetReceivedEvent;\n+\n+        /// <summary>\n+        /// The event which is set when we should shut down.\n+        /// </summary>\n+        private readonly ManualResetEvent _shutdownEvent;\n+\n+        /// <summary>\n+        /// The reason we are shutting down.\n+        /// </summary>\n+        private NodeEngineShutdownReason _shutdownReason;\n+\n+        /// <summary>\n+        /// The exception, if any, which caused shutdown.\n+        /// </summary>\n+        private Exception? _shutdownException = null;\n+\n+        /// <summary>\n+        /// Flag indicating if we should debug communications or not.\n+        /// </summary>\n+        private readonly bool _debugCommunications;\n+\n+        private string _serverBusyMutexName = default!;\n+\n+        public OutOfProcServerNode(Func<string, (int exitCode, string exitType)> buildFunction)\n+        {\n+            _buildFunction = buildFunction;\n+            new Dictionary<string, string>();\n+            _debugCommunications = (Environment.GetEnvironmentVariable(\"MSBUILDDEBUGCOMM\") == \"1\");\n+\n+            _receivedPackets = new ConcurrentQueue<INodePacket>();\n+            _packetReceivedEvent = new AutoResetEvent(false);\n+            _shutdownEvent = new ManualResetEvent(false);\n+            _packetFactory = new NodePacketFactory();\n+\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);\n+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);\n+        }\n+\n+        #region INode Members\n+\n+        /// <summary>\n+        /// Starts up the node and processes messages until the node is requested to shut down.\n+        /// </summary>\n+        /// <param name=\"shutdownException\">The exception which caused shutdown, if any.</param>\n+        /// <returns>The reason for shutting down.</returns>\n+        public NodeEngineShutdownReason Run(out Exception? shutdownException)\n+        {\n+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;\n+            var handshake = new ServerNodeHandshake(\n+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess),\n+                msBuildLocation);\n+\n+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(\"MSBuildServer-\" + handshake.ComputeHash());\n+\n+            string serverRunningMutexName = $@\"Global\\server-running-{pipeName}\";\n+            _serverBusyMutexName = $@\"Global\\server-busy-{pipeName}\";\n+\n+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning\n+            // and of two processes will become victim and fails, build will not be affected\n+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);\n+            if (!mutexCreatedNew)\n+            {\n+                shutdownException = new InvalidOperationException(\"MSBuild server is already running!\");\n+                return NodeEngineShutdownReason.Error;\n+            }\n+\n+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(pipeName, handshake);\n+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;\n+            _nodeEndpoint.Listen(this);\n+\n+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };\n+\n+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.\n+            while (true)\n+            {\n+                int index = WaitHandle.WaitAny(waitHandles);\n+                switch (index)\n+                {\n+                    case 0:\n+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);\n+                        return shutdownReason;\n+\n+                    case 1:\n+\n+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))\n+                        {\n+                            if (packet != null)\n+                            {\n+                                HandlePacket(packet);\n+                            }\n+                        }\n+\n+                        break;\n+                }\n+            }\n+\n+            // UNREACHABLE\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketFactory Members\n+\n+        /// <summary>\n+        /// Registers a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The packet type for which the handler should be registered.</param>\n+        /// <param name=\"factory\">The factory used to create packets.</param>\n+        /// <param name=\"handler\">The handler for the packets.</param>\n+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+        {\n+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);\n+        }\n+\n+        /// <summary>\n+        /// Unregisters a packet handler.\n+        /// </summary>\n+        /// <param name=\"packetType\">The type of packet for which the handler should be unregistered.</param>\n+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)\n+        {\n+            _packetFactory.UnregisterPacketHandler(packetType);\n+        }\n+\n+        /// <summary>\n+        /// Deserializes and routes a packer to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node from which the packet was received.</param>\n+        /// <param name=\"packetType\">The packet type.</param>\n+        /// <param name=\"translator\">The translator to use as a source for packet data.</param>\n+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)\n+        {\n+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);\n+        }\n+\n+        /// <summary>\n+        /// Routes a packet to the appropriate handler.\n+        /// </summary>\n+        /// <param name=\"nodeId\">The node id from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet to route.</param>\n+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)\n+        {\n+            _packetFactory.RoutePacket(nodeId, packet);\n+        }\n+\n+        #endregion\n+\n+        #region INodePacketHandler Members\n+\n+        /// <summary>\n+        /// Called when a packet has been received.\n+        /// </summary>\n+        /// <param name=\"node\">The node from which the packet was received.</param>\n+        /// <param name=\"packet\">The packet.</param>\n+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)\n+        {\n+            _receivedPackets.Enqueue(packet);\n+            _packetReceivedEvent.Set();\n+        }\n+\n+        #endregion\n+\n+        /// <summary>\n+        /// Perform necessary actions to shut down the node.\n+        /// </summary>\n+        // TODO: it is too complicated, for simple role of server node it needs to be simplified\n+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)\n+        {\n+            CommunicationsUtilities.Trace(\"Shutting down with reason: {0}, and exception: {1}.\", _shutdownReason, _shutdownException);\n+\n+            exception = _shutdownException;\n+\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;\n+            }\n+\n+            _nodeEndpoint.Disconnect();\n+\n+            CommunicationsUtilities.Trace(\"Shut down complete.\");\n+\n+            return _shutdownReason;\n+        }\n+\n+        /// <summary>\n+        /// Event handler for the node endpoint's LinkStatusChanged event.\n+        /// </summary>\n+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)\n+        {\n+            switch (status)\n+            {\n+                case LinkStatus.ConnectionFailed:\n+                case LinkStatus.Failed:\n+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;\n+                    _shutdownEvent.Set();\n+                    break;\n+\n+                case LinkStatus.Inactive:\n+                    break;\n+\n+                case LinkStatus.Active:\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Callback for logging packets to be sent.\n+        /// </summary>\n+        private void SendPacket(INodePacket packet)\n+        {\n+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)\n+            {\n+                _nodeEndpoint.SendData(packet);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Dispatches the packet to the correct handler.\n+        /// </summary>\n+        private void HandlePacket(INodePacket packet)\n+        {\n+            switch (packet.Type)\n+            {\n+                case NodePacketType.ServerNodeBuildCommand:\n+                    HandleServerNodeBuildCommand((ServerNodeBuildCommand)packet);\n+                    break;\n+            }\n+        }\n+\n+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)\n+        {\n+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);\n+            if (!holdsMutex)\n+            {\n+                // Client must have send request message to server even though serer is busy.\n+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.\n+                _shutdownException = new InvalidOperationException(\"Client requested build while server is busy processing previous client build request.\");\n+                _shutdownReason = NodeEngineShutdownReason.Error;\n+                _shutdownEvent.Set();\n+            }\n+\n+            // set build process context\n+            Directory.SetCurrentDirectory(command.StartupDirectory);\n+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);\n+            Thread.CurrentThread.CurrentCulture = command.Culture;\n+            Thread.CurrentThread.CurrentUICulture = command.UICulture;\n+\n+            // configure console output redirection\n+            var oldOut = Console.Out;\n+            var oldErr = Console.Error;\n+            (int exitCode, string exitType) buildResult;\n+\n+            // Dispose must be called before the server sends ServerNodeBuildResult packet\n+            using (var outWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, ConsoleOutput.Standard))))\n+            using (var errWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, ConsoleOutput.Error))))\n+            {\n+                Console.SetOut(outWriter);\n+                Console.SetError(errWriter);\n+\n+                buildResult = _buildFunction(command.CommandLine);\n+\n+                Console.SetOut(oldOut);\n+                Console.SetError(oldErr);\n+            }\n+          \n+            // On Windows, a process holds a handle to the current directory,\n+            // so reset it away from a user-requested folder that may get deleted.\n+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);\n+\n+            var response = new ServerNodeBuildResult(buildResult.exitCode, buildResult.exitType);\n+            SendPacket(response);\n+\n+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;\n+            _shutdownEvent.Set();\n+        }\n+\n+        internal sealed class RedirectConsoleWriter : StringWriter\n+        {\n+            private readonly Action<string> _writeCallback;\n+            private readonly Timer _timer;\n+            private readonly TextWriter _syncWriter;\n+\n+            private RedirectConsoleWriter(Action<string> writeCallback)\n+            {\n+                _writeCallback = writeCallback;\n+                _syncWriter = Synchronized(this);\n+                _timer = new Timer(TimerCallback, null, 0, 200);\n+            }\n+\n+            public static TextWriter Create(Action<string> writeCallback)\n+            {\n+                RedirectConsoleWriter writer = new(writeCallback);\n+                return writer._syncWriter;\n+            }\n+\n+            private void TimerCallback(object? state)\n+            {\n+                if (GetStringBuilder().Length > 0)\n+                {\n+                    _syncWriter.Flush();\n+                }\n+            }\n+\n+            protected override void Dispose(bool disposing)\n+            {\n+                if (disposing)\n+                {\n+                    _timer.Dispose();\n+                    Flush();\n+                }\n+\n+                base.Dispose(disposing);\n+            }\n+\n+            public override void Flush()\n+            {\n+                var sb = GetStringBuilder();\n+                var captured = sb.ToString();\n+                sb.Clear();\n+                _writeCallback(captured);\n+\n+                base.Flush();\n+            }\n+        }\n+\n+        internal sealed class ServerNamedMutex : IDisposable",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      }
    ]
  }
}