{
  "number": 6350,
  "title": "Remove BinaryFormatter from StateFileBase",
  "body": "This ends our reliance on BinaryFormatter within any StateFileBase. This comprises AssemblyReferenceCache, ResolveComReference, and ResGenDependencies. SystemState (part of ResolveAssemblyReference) also extends StateFileBase, but that was already converted. We may want to combine those two serialization efforts into a single location, but that's more of a refactor so lower priority.\r\n\r\nAlso added tests.",
  "state": "MERGED",
  "createdAt": "2021-04-15T17:58:21Z",
  "updatedAt": "2021-05-24T21:50:49Z",
  "closedAt": "2021-05-24T21:50:48Z",
  "mergedAt": "2021-05-24T21:50:48Z",
  "additions": 355,
  "deletions": 399,
  "changedFiles": 15,
  "headRefName": "next-bf-removal",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "8124add656e4bb38017302f1efbc1780c5c4f724",
          "message": "Serialize state files without BinaryFormatter",
          "committedDate": "2021-04-15T17:15:53Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "013f65dc2f3d865dcde9f6dada72e89367a6da93",
          "message": "Add tests",
          "committedDate": "2021-04-15T17:15:57Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "708b7d9bdb9879588be78933422beb91dc02a505",
          "message": "Remove extra [Serializable]",
          "committedDate": "2021-04-15T22:20:32Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fdc980ae91e2806a3cbb959e47892007f1eb14a8",
          "message": "Shift serialization to StateFileBase and extensions",
          "committedDate": "2021-04-16T21:34:53Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fc25eb772d31c9c92a389404623c4f528a34614c",
          "message": "Add copyright header and remove fileExists",
          "committedDate": "2021-04-16T22:09:52Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "76b99233d6a1ff8678af805d30f5b935eee95aa3",
          "message": "Partially implement suggestions",
          "committedDate": "2021-04-20T17:45:49Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "858a99b5a9a9d0e1dfdaf6305d64d7e10d14fa97",
          "message": "Remove Dependencies",
          "committedDate": "2021-04-20T20:32:17Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "69ad8b7629596eec593a793eba4f9eedc8d3fef4",
          "message": "Comments. Also centralize version",
          "committedDate": "2021-04-28T00:25:51Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Getting rid of this too?",
              "createdAt": "2021-04-15T21:11:18Z",
              "path": "src/Tasks/ResGenDependencies.cs",
              "diffHunk": "@@ -284,9 +286,13 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir\n         [Serializable]",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yep! Thanks.",
              "createdAt": "2021-04-15T22:19:14Z",
              "path": "src/Tasks/ResGenDependencies.cs",
              "diffHunk": "@@ -284,9 +286,13 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir\n         [Serializable]",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why are you putting these here instead of as a method in the relevant classes?",
              "createdAt": "2021-04-15T21:36:32Z",
              "path": "src/Tasks/TaskTranslatorHelpers.cs",
              "diffHunk": "@@ -34,5 +35,94 @@ public static void Translate(this ITranslator translator, ref FrameworkName fram\n                 frameworkName = new FrameworkName(identifier, version, profile);\n             }\n         }\n+\n+        public static void TranslateDictionary(this ITranslator translator, ref Dictionary<string, DateTime> dict, StringComparer comparer)\n+        {\n+            int count = 0;\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                dict = new Dictionary<string, DateTime>(comparer);\n+                translator.Translate(ref count);\n+                string key = string.Empty;\n+                DateTime val = DateTime.Now;\n+                for (int i = 0; i < count; i++)\n+                {\n+                    translator.Translate(ref key);\n+                    translator.Translate(ref val);\n+                    dict.Add(key, val);\n+                }\n+            }\n+            else\n+            {\n+                count = dict.Count;\n+                translator.Translate(ref count);\n+                foreach (KeyValuePair<string, DateTime> kvp in dict)\n+                {\n+                    string key = kvp.Key;\n+                    DateTime val = kvp.Value;\n+                    translator.Translate(ref key);\n+                    translator.Translate(ref val);\n+                }\n+            }\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref Dependencies dependencies, Type t)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "When we've added new Translators, we've generally done it in \"TranslatorHelpers\" (or similar) files. I was thinking about eventually combining these with @rokonec's change for the other kind of StateFileBase: https://github.com/dotnet/msbuild/pull/6094\r\n\r\nTaskTranslatorHelpers makes a little more sense to me than a shared TranslatorHelpers, though, because these are all task-specific.",
              "createdAt": "2021-04-15T22:18:56Z",
              "path": "src/Tasks/TaskTranslatorHelpers.cs",
              "diffHunk": "@@ -34,5 +35,94 @@ public static void Translate(this ITranslator translator, ref FrameworkName fram\n                 frameworkName = new FrameworkName(identifier, version, profile);\n             }\n         }\n+\n+        public static void TranslateDictionary(this ITranslator translator, ref Dictionary<string, DateTime> dict, StringComparer comparer)\n+        {\n+            int count = 0;\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                dict = new Dictionary<string, DateTime>(comparer);\n+                translator.Translate(ref count);\n+                string key = string.Empty;\n+                DateTime val = DateTime.Now;\n+                for (int i = 0; i < count; i++)\n+                {\n+                    translator.Translate(ref key);\n+                    translator.Translate(ref val);\n+                    dict.Add(key, val);\n+                }\n+            }\n+            else\n+            {\n+                count = dict.Count;\n+                translator.Translate(ref count);\n+                foreach (KeyValuePair<string, DateTime> kvp in dict)\n+                {\n+                    string key = kvp.Key;\n+                    DateTime val = kvp.Value;\n+                    translator.Translate(ref key);\n+                    translator.Translate(ref val);\n+                }\n+            }\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref Dependencies dependencies, Type t)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I believe that for for our own types we shall implement ITranslatable interface and use extensions only for close source clases, like Dictionary<X,Y> or Version. \r\nThis way the serialization code stays inside the class, which might limit future serialization code omission bugs.",
              "createdAt": "2021-04-16T14:10:05Z",
              "path": "src/Tasks/TaskTranslatorHelpers.cs",
              "diffHunk": "@@ -34,5 +35,94 @@ public static void Translate(this ITranslator translator, ref FrameworkName fram\n                 frameworkName = new FrameworkName(identifier, version, profile);\n             }\n         }\n+\n+        public static void TranslateDictionary(this ITranslator translator, ref Dictionary<string, DateTime> dict, StringComparer comparer)\n+        {\n+            int count = 0;\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                dict = new Dictionary<string, DateTime>(comparer);\n+                translator.Translate(ref count);\n+                string key = string.Empty;\n+                DateTime val = DateTime.Now;\n+                for (int i = 0; i < count; i++)\n+                {\n+                    translator.Translate(ref key);\n+                    translator.Translate(ref val);\n+                    dict.Add(key, val);\n+                }\n+            }\n+            else\n+            {\n+                count = dict.Count;\n+                translator.Translate(ref count);\n+                foreach (KeyValuePair<string, DateTime> kvp in dict)\n+                {\n+                    string key = kvp.Key;\n+                    DateTime val = kvp.Value;\n+                    translator.Translate(ref key);\n+                    translator.Translate(ref val);\n+                }\n+            }\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref Dependencies dependencies, Type t)",
              "author": {
                "login": "rokonec"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since _serializedVersion is never serialized, it will **always** have same value as CurrentSerializationVersion and it will never detect outdated cache.\r\nIn SystemState.DeserializeCacheByTranslator I have implemented some kind of file signature check along with basic versioning.",
              "createdAt": "2021-04-16T14:31:24Z",
              "path": "src/Tasks/StateFileBase.cs",
              "diffHunk": "@@ -75,43 +72,30 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp\n                 {\n                     using (FileStream s = new FileStream(stateFile, FileMode.Open))\n                     {\n-                        var formatter = new BinaryFormatter();\n-                        object deserializedObject = formatter.Deserialize(s);\n-                        retVal = deserializedObject as StateFileBase;\n+                        var translator = BinaryTranslator.GetReadTranslator(s, buffer: null);\n+                        translator.Translate(ref retVal, requiredReturnType);\n \n-                        // If the deserialized object is null then there would be no cast error but retVal would still be null\n-                        // only log the message if there would have been a cast error\n-                        if (retVal == null && deserializedObject != null)\n+                        // If retVal is still null or the version is wrong, log a message not a warning. This could be a valid cache with the wrong version preventing correct deserialization.\n+                        // For the latter case, internals may be unexpectedly null.\n+                        if (retVal == null || retVal._serializedVersion != CurrentSerializationVersion)",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "Good point, added.",
              "createdAt": "2021-04-16T16:12:30Z",
              "path": "src/Tasks/StateFileBase.cs",
              "diffHunk": "@@ -75,43 +72,30 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp\n                 {\n                     using (FileStream s = new FileStream(stateFile, FileMode.Open))\n                     {\n-                        var formatter = new BinaryFormatter();\n-                        object deserializedObject = formatter.Deserialize(s);\n-                        retVal = deserializedObject as StateFileBase;\n+                        var translator = BinaryTranslator.GetReadTranslator(s, buffer: null);\n+                        translator.Translate(ref retVal, requiredReturnType);\n \n-                        // If the deserialized object is null then there would be no cast error but retVal would still be null\n-                        // only log the message if there would have been a cast error\n-                        if (retVal == null && deserializedObject != null)\n+                        // If retVal is still null or the version is wrong, log a message not a warning. This could be a valid cache with the wrong version preventing correct deserialization.\n+                        // For the latter case, internals may be unexpectedly null.\n+                        if (retVal == null || retVal._serializedVersion != CurrentSerializationVersion)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "When called in dotnet core it will write nothing into file. If such file will be then deserialized in NETFRAMEWORK it will crash.\r\nHow do we protect against cache mangling between CLI and VS msbuild invocations?\r\nI have not looked at caller side to verify that for given types it is never called for non NETFRAMEWORK, but even if it is assured, it makes code somehow fragile.",
              "createdAt": "2021-04-16T14:38:37Z",
              "path": "src/Tasks/TaskTranslatorHelpers.cs",
              "diffHunk": "@@ -34,5 +35,94 @@ public static void Translate(this ITranslator translator, ref FrameworkName fram\n                 frameworkName = new FrameworkName(identifier, version, profile);\n             }\n         }\n+\n+        public static void TranslateDictionary(this ITranslator translator, ref Dictionary<string, DateTime> dict, StringComparer comparer)\n+        {\n+            int count = 0;\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                dict = new Dictionary<string, DateTime>(comparer);\n+                translator.Translate(ref count);\n+                string key = string.Empty;\n+                DateTime val = DateTime.Now;\n+                for (int i = 0; i < count; i++)\n+                {\n+                    translator.Translate(ref key);\n+                    translator.Translate(ref val);\n+                    dict.Add(key, val);\n+                }\n+            }\n+            else\n+            {\n+                count = dict.Count;\n+                translator.Translate(ref count);\n+                foreach (KeyValuePair<string, DateTime> kvp in dict)\n+                {\n+                    string key = kvp.Key;\n+                    DateTime val = kvp.Value;\n+                    translator.Translate(ref key);\n+                    translator.Translate(ref val);\n+                }\n+            }\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref Dependencies dependencies, Type t)\n+        {\n+            translator.TranslateDictionary(ref dependencies.dependencies, (ITranslator translator, ref DependencyFile dependency) => {\n+                if (t == typeof(ResGenDependencies.ResXFile))\n+                {\n+                    ResGenDependencies.ResXFile resx = dependency as ResGenDependencies.ResXFile;\n+                    resx ??= new();\n+                    translator.Translate(ref resx.linkedFiles);\n+                    dependency = resx;\n+                }\n+                else if (t == typeof(ResGenDependencies.PortableLibraryFile))\n+                {\n+                    ResGenDependencies.PortableLibraryFile lib = dependency as ResGenDependencies.PortableLibraryFile;\n+                    lib ??= new();\n+                    translator.Translate(ref lib.assemblySimpleName);\n+                    translator.Translate(ref lib.outputFiles);\n+                    translator.Translate(ref lib.neutralResourceLanguage);\n+                    dependency = lib;\n+                }\n+\n+                dependency ??= new();\n+                translator.Translate(ref dependency.filename);\n+                translator.Translate(ref dependency.lastModified);\n+                translator.Translate(ref dependency.exists);\n+            });\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref StateFileBase stateFile, Type t)\n+        {\n+            if (t == typeof(ResGenDependencies))\n+            {\n+                ResGenDependencies rgd = stateFile as ResGenDependencies;\n+                rgd ??= new();\n+                translator.Translate(ref rgd.resXFiles, typeof(ResGenDependencies.ResXFile));\n+                translator.Translate(ref rgd.portableLibraries, typeof(ResGenDependencies.PortableLibraryFile));\n+                translator.Translate(ref rgd.baseLinkedFileDirectory);\n+                stateFile = rgd;\n+            }\n+#if NETFRAMEWORK\n+            else if (t == typeof(ResolveComReferenceCache))",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "It should only be .NET Framework --> .NET Framework. Those caches are only compiled, even, if the TFI is .NETFramework:\r\nhttps://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Build.Tasks.csproj#L558\r\n\r\nIf, at some point, we were to add support for those on .NET Core, we'd have to start by moving that to a not-framework-specific itemgroup, which would make the tests I wrote (and didn't specify not-core on) fail.",
              "createdAt": "2021-04-16T16:10:51Z",
              "path": "src/Tasks/TaskTranslatorHelpers.cs",
              "diffHunk": "@@ -34,5 +35,94 @@ public static void Translate(this ITranslator translator, ref FrameworkName fram\n                 frameworkName = new FrameworkName(identifier, version, profile);\n             }\n         }\n+\n+        public static void TranslateDictionary(this ITranslator translator, ref Dictionary<string, DateTime> dict, StringComparer comparer)\n+        {\n+            int count = 0;\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                dict = new Dictionary<string, DateTime>(comparer);\n+                translator.Translate(ref count);\n+                string key = string.Empty;\n+                DateTime val = DateTime.Now;\n+                for (int i = 0; i < count; i++)\n+                {\n+                    translator.Translate(ref key);\n+                    translator.Translate(ref val);\n+                    dict.Add(key, val);\n+                }\n+            }\n+            else\n+            {\n+                count = dict.Count;\n+                translator.Translate(ref count);\n+                foreach (KeyValuePair<string, DateTime> kvp in dict)\n+                {\n+                    string key = kvp.Key;\n+                    DateTime val = kvp.Value;\n+                    translator.Translate(ref key);\n+                    translator.Translate(ref val);\n+                }\n+            }\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref Dependencies dependencies, Type t)\n+        {\n+            translator.TranslateDictionary(ref dependencies.dependencies, (ITranslator translator, ref DependencyFile dependency) => {\n+                if (t == typeof(ResGenDependencies.ResXFile))\n+                {\n+                    ResGenDependencies.ResXFile resx = dependency as ResGenDependencies.ResXFile;\n+                    resx ??= new();\n+                    translator.Translate(ref resx.linkedFiles);\n+                    dependency = resx;\n+                }\n+                else if (t == typeof(ResGenDependencies.PortableLibraryFile))\n+                {\n+                    ResGenDependencies.PortableLibraryFile lib = dependency as ResGenDependencies.PortableLibraryFile;\n+                    lib ??= new();\n+                    translator.Translate(ref lib.assemblySimpleName);\n+                    translator.Translate(ref lib.outputFiles);\n+                    translator.Translate(ref lib.neutralResourceLanguage);\n+                    dependency = lib;\n+                }\n+\n+                dependency ??= new();\n+                translator.Translate(ref dependency.filename);\n+                translator.Translate(ref dependency.lastModified);\n+                translator.Translate(ref dependency.exists);\n+            });\n+        }\n+\n+        public static void Translate(this ITranslator translator, ref StateFileBase stateFile, Type t)\n+        {\n+            if (t == typeof(ResGenDependencies))\n+            {\n+                ResGenDependencies rgd = stateFile as ResGenDependencies;\n+                rgd ??= new();\n+                translator.Translate(ref rgd.resXFiles, typeof(ResGenDependencies.ResXFile));\n+                translator.Translate(ref rgd.portableLibraries, typeof(ResGenDependencies.PortableLibraryFile));\n+                translator.Translate(ref rgd.baseLinkedFileDirectory);\n+                stateFile = rgd;\n+            }\n+#if NETFRAMEWORK\n+            else if (t == typeof(ResolveComReferenceCache))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "ultranit:\r\n\r\n```suggestion\r\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\r\n\r\n```",
              "createdAt": "2021-04-20T14:54:00Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs",
              "diffHunk": "@@ -1,6 +1,8 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would it be harmful to default this to min or max? Those are constants and would never require a clock read.\r\n\r\n```suggestion\r\n                DateTime val = DateTime.MinValue;\r\n```",
              "createdAt": "2021-04-20T15:07:08Z",
              "path": "src/Tasks/TaskTranslatorHelpers.cs",
              "diffHunk": "@@ -34,5 +35,35 @@ public static void Translate(this ITranslator translator, ref FrameworkName fram\n                 frameworkName = new FrameworkName(identifier, version, profile);\n             }\n         }\n+\n+        public static void TranslateDictionary(this ITranslator translator, ref Dictionary<string, DateTime> dict, StringComparer comparer)\n+        {\n+            int count = 0;\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                dict = new Dictionary<string, DateTime>(comparer);\n+                translator.Translate(ref count);\n+                string key = string.Empty;\n+                DateTime val = DateTime.Now;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Nope, just needed a value.",
              "createdAt": "2021-04-20T15:33:41Z",
              "path": "src/Tasks/TaskTranslatorHelpers.cs",
              "diffHunk": "@@ -34,5 +35,35 @@ public static void Translate(this ITranslator translator, ref FrameworkName fram\n                 frameworkName = new FrameworkName(identifier, version, profile);\n             }\n         }\n+\n+        public static void TranslateDictionary(this ITranslator translator, ref Dictionary<string, DateTime> dict, StringComparer comparer)\n+        {\n+            int count = 0;\n+            if (translator.Mode == TranslationDirection.ReadFromStream)\n+            {\n+                dict = new Dictionary<string, DateTime>(comparer);\n+                translator.Translate(ref count);\n+                string key = string.Empty;\n+                DateTime val = DateTime.Now;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is this overload not in `BinaryTranslator.cs` with the rest? It doesn't use a Tasks-specific type.",
              "createdAt": "2021-04-20T15:07:58Z",
              "path": "src/Tasks/TaskTranslatorHelpers.cs",
              "diffHunk": "@@ -34,5 +35,35 @@ public static void Translate(this ITranslator translator, ref FrameworkName fram\n                 frameworkName = new FrameworkName(identifier, version, profile);\n             }\n         }\n+\n+        public static void TranslateDictionary(this ITranslator translator, ref Dictionary<string, DateTime> dict, StringComparer comparer)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "To do this, I would have to add a method signature in ITranslator.cs and a separate implementation for read and write. Those implementations would be almost identical and easily merged. Looking at other examples in that class, most just reimplemented the same logic twice with a tiny tweak. I don't approve of wasting code like that and would propose moving all methods beyond the basics (int, string, etc.) to an extensions class where they can reuse code properly. I'm fine with moving this to Shared, though.",
              "createdAt": "2021-04-20T16:03:09Z",
              "path": "src/Tasks/TaskTranslatorHelpers.cs",
              "diffHunk": "@@ -34,5 +35,35 @@ public static void Translate(this ITranslator translator, ref FrameworkName fram\n                 frameworkName = new FrameworkName(identifier, version, profile);\n             }\n         }\n+\n+        public static void TranslateDictionary(this ITranslator translator, ref Dictionary<string, DateTime> dict, StringComparer comparer)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this correct for both serialization and deserialization directions?",
              "createdAt": "2021-04-20T15:14:11Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -329,6 +246,7 @@ public void Translate(ITranslator translator)\n                 ref instanceLocalFileStateCache,\n                 StringComparer.OrdinalIgnoreCase,\n                 (ITranslator t) => new FileState(t));\n+            IsDirty = false;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes. For serialization, the cache was just written to disk, so it is no longer dirty. For deserialization, this cache was just read from disk, so it is no longer dirty. Either way, the two versions match.",
              "createdAt": "2021-04-20T15:39:30Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -329,6 +246,7 @@ public void Translate(ITranslator translator)\n                 ref instanceLocalFileStateCache,\n                 StringComparer.OrdinalIgnoreCase,\n                 (ITranslator t) => new FileState(t));\n+            IsDirty = false;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Great! Can you comment that please?",
              "createdAt": "2021-04-20T15:42:31Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -329,6 +246,7 @@ public void Translate(ITranslator translator)\n                 ref instanceLocalFileStateCache,\n                 StringComparer.OrdinalIgnoreCase,\n                 (ITranslator t) => new FileState(t));\n+            IsDirty = false;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What's the motivation for this change?",
              "createdAt": "2021-04-20T15:15:04Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -89,11 +84,6 @@ internal sealed class SystemState : StateFileBase, ITranslatable\n         /// </summary>\n         private GetAssemblyMetadata getAssemblyMetadata;\n \n-        /// <summary>\n-        /// Cached delegate.\n-        /// </summary>\n-        private FileExists fileExists;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It isn't used, and I came across it. Small cleanup.",
              "createdAt": "2021-04-20T15:39:55Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -89,11 +84,6 @@ internal sealed class SystemState : StateFileBase, ITranslatable\n         /// </summary>\n         private GetAssemblyMetadata getAssemblyMetadata;\n \n-        /// <summary>\n-        /// Cached delegate.\n-        /// </summary>\n-        private FileExists fileExists;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why pass and check the type explicitly? Could you instead do a pattern match on the runtime type?",
              "createdAt": "2021-04-20T15:24:59Z",
              "path": "src/Tasks/Dependencies.cs",
              "diffHunk": "@@ -1,32 +1,65 @@\n \ufeff// Copyright (c) Microsoft. All rights reserved.\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n+using Microsoft.Build.BackEnd;\n using System;\n-using System.Collections;\n+using System.Collections.Generic;\n \n namespace Microsoft.Build.Tasks\n {\n     /// <summary>\n     /// Represents a cache of inputs to a compilation-style task.\n     /// </summary>\n-    /// <remarks>On-disk serialization format, don't change field names or types or use readonly.</remarks>\n-    [Serializable]\n     internal class Dependencies\n     {\n         /// <summary>\n-        /// Hashtable of other dependency files.\n+        /// Dictionary of other dependency files.\n         /// Key is filename and value is DependencyFile.\n         /// </summary>\n-        private Hashtable dependencies = new Hashtable();\n+        internal Dictionary<string, DependencyFile> dependencies = new();\n+\n+        internal Dependencies() { }\n+\n+        internal Dependencies(ITranslator translator, Type t)\n+        {\n+            Translate(translator, t);\n+        }\n+\n+        public void Translate(ITranslator translator, Type t)\n+        {\n+            translator.TranslateDictionary(ref dependencies, (ITranslator translator, ref DependencyFile dependency) =>\n+            {\n+                if (t == typeof(ResGenDependencies.ResXFile))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Great question\u2014that's actually how I first implemented it, and it took me a bit to figure out why it was failing. For serializing to disk, yes, that works. For deserializing, dependency comes in as null, so it can be cast to either a ResXFile or a PortableLibraryFile. Only one of those is valid, however, so I need to pick the right one. Explicitly passing the type (or some equivalent information) is the only way I can get the requisite information for deserializing the right type.",
              "createdAt": "2021-04-20T15:42:32Z",
              "path": "src/Tasks/Dependencies.cs",
              "diffHunk": "@@ -1,32 +1,65 @@\n \ufeff// Copyright (c) Microsoft. All rights reserved.\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n+using Microsoft.Build.BackEnd;\n using System;\n-using System.Collections;\n+using System.Collections.Generic;\n \n namespace Microsoft.Build.Tasks\n {\n     /// <summary>\n     /// Represents a cache of inputs to a compilation-style task.\n     /// </summary>\n-    /// <remarks>On-disk serialization format, don't change field names or types or use readonly.</remarks>\n-    [Serializable]\n     internal class Dependencies\n     {\n         /// <summary>\n-        /// Hashtable of other dependency files.\n+        /// Dictionary of other dependency files.\n         /// Key is filename and value is DependencyFile.\n         /// </summary>\n-        private Hashtable dependencies = new Hashtable();\n+        internal Dictionary<string, DependencyFile> dependencies = new();\n+\n+        internal Dependencies() { }\n+\n+        internal Dependencies(ITranslator translator, Type t)\n+        {\n+            Translate(translator, t);\n+        }\n+\n+        public void Translate(ITranslator translator, Type t)\n+        {\n+            translator.TranslateDictionary(ref dependencies, (ITranslator translator, ref DependencyFile dependency) =>\n+            {\n+                if (t == typeof(ResGenDependencies.ResXFile))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Can we make Dependencies implement ITranslatable and override it in derived classes?",
              "createdAt": "2021-04-20T16:15:11Z",
              "path": "src/Tasks/Dependencies.cs",
              "diffHunk": "@@ -1,32 +1,65 @@\n \ufeff// Copyright (c) Microsoft. All rights reserved.\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n+using Microsoft.Build.BackEnd;\n using System;\n-using System.Collections;\n+using System.Collections.Generic;\n \n namespace Microsoft.Build.Tasks\n {\n     /// <summary>\n     /// Represents a cache of inputs to a compilation-style task.\n     /// </summary>\n-    /// <remarks>On-disk serialization format, don't change field names or types or use readonly.</remarks>\n-    [Serializable]\n     internal class Dependencies\n     {\n         /// <summary>\n-        /// Hashtable of other dependency files.\n+        /// Dictionary of other dependency files.\n         /// Key is filename and value is DependencyFile.\n         /// </summary>\n-        private Hashtable dependencies = new Hashtable();\n+        internal Dictionary<string, DependencyFile> dependencies = new();\n+\n+        internal Dependencies() { }\n+\n+        internal Dependencies(ITranslator translator, Type t)\n+        {\n+            Translate(translator, t);\n+        }\n+\n+        public void Translate(ITranslator translator, Type t)\n+        {\n+            translator.TranslateDictionary(ref dependencies, (ITranslator translator, ref DependencyFile dependency) =>\n+            {\n+                if (t == typeof(ResGenDependencies.ResXFile))",
              "author": {
                "login": "rokonec"
              }
            },
            {
              "body": "If it was the first instinct for both of us it deserves a comment please",
              "createdAt": "2021-04-20T16:17:00Z",
              "path": "src/Tasks/Dependencies.cs",
              "diffHunk": "@@ -1,32 +1,65 @@\n \ufeff// Copyright (c) Microsoft. All rights reserved.\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n+using Microsoft.Build.BackEnd;\n using System;\n-using System.Collections;\n+using System.Collections.Generic;\n \n namespace Microsoft.Build.Tasks\n {\n     /// <summary>\n     /// Represents a cache of inputs to a compilation-style task.\n     /// </summary>\n-    /// <remarks>On-disk serialization format, don't change field names or types or use readonly.</remarks>\n-    [Serializable]\n     internal class Dependencies\n     {\n         /// <summary>\n-        /// Hashtable of other dependency files.\n+        /// Dictionary of other dependency files.\n         /// Key is filename and value is DependencyFile.\n         /// </summary>\n-        private Hashtable dependencies = new Hashtable();\n+        internal Dictionary<string, DependencyFile> dependencies = new();\n+\n+        internal Dependencies() { }\n+\n+        internal Dependencies(ITranslator translator, Type t)\n+        {\n+            Translate(translator, t);\n+        }\n+\n+        public void Translate(ITranslator translator, Type t)\n+        {\n+            translator.TranslateDictionary(ref dependencies, (ITranslator translator, ref DependencyFile dependency) =>\n+            {\n+                if (t == typeof(ResGenDependencies.ResXFile))",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "@rokonec The type is just Dictionary<string, DependencyFile> and it has to work for either Dictionary<string, ResXFile> or Dictionary<string, PortableLibraryFile>. The Dependencies class doesn't know which will be required, so the Translator can't either. To be honest, this whole class structure could have been dramatically simplified by just having ResGenDependencies have a Dictionary<string, ResXFile> and a Dictionary<string, PortableLibraryFile>. That would make this a lot cleaner but be a little outside the scope of this PR. That said, if you want me to do that, I'm happy deleting a lot of code \ud83d\ude09",
              "createdAt": "2021-04-20T16:40:03Z",
              "path": "src/Tasks/Dependencies.cs",
              "diffHunk": "@@ -1,32 +1,65 @@\n \ufeff// Copyright (c) Microsoft. All rights reserved.\n // Licensed under the MIT license. See LICENSE file in the project root for full license information.\n \n+using Microsoft.Build.BackEnd;\n using System;\n-using System.Collections;\n+using System.Collections.Generic;\n \n namespace Microsoft.Build.Tasks\n {\n     /// <summary>\n     /// Represents a cache of inputs to a compilation-style task.\n     /// </summary>\n-    /// <remarks>On-disk serialization format, don't change field names or types or use readonly.</remarks>\n-    [Serializable]\n     internal class Dependencies\n     {\n         /// <summary>\n-        /// Hashtable of other dependency files.\n+        /// Dictionary of other dependency files.\n         /// Key is filename and value is DependencyFile.\n         /// </summary>\n-        private Hashtable dependencies = new Hashtable();\n+        internal Dictionary<string, DependencyFile> dependencies = new();\n+\n+        internal Dependencies() { }\n+\n+        internal Dependencies(ITranslator translator, Type t)\n+        {\n+            Translate(translator, t);\n+        }\n+\n+        public void Translate(ITranslator translator, Type t)\n+        {\n+            translator.TranslateDictionary(ref dependencies, (ITranslator translator, ref DependencyFile dependency) =>\n+            {\n+                if (t == typeof(ResGenDependencies.ResXFile))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't feel like this is clearer than switching the cast to an `as`.",
              "createdAt": "2021-04-20T15:27:23Z",
              "path": "src/Tasks/ResGenDependencies.cs",
              "diffHunk": "@@ -90,11 +89,25 @@ internal bool UseSourcePath\n             }\n         }\n \n+        public ResGenDependencies() { }\n+\n+        public ResGenDependencies(ITranslator translator)\n+        {\n+            Translate(translator);\n+        }\n+\n+        public override void Translate(ITranslator translator)\n+        {\n+            resXFiles.Translate(translator, typeof(ResXFile));\n+            portableLibraries.Translate(translator, typeof(PortableLibraryFile));\n+            translator.Translate(ref baseLinkedFileDirectory);\n+            translator.Translate(ref _serializedVersion);\n+        }\n+\n         internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)\n         {\n             // First, try to retrieve the resx information from our hashtable.\n-            var retVal = (ResXFile)resXFiles.GetDependencyFile(resxFile);\n-            if (retVal == null)\n+            if (resXFiles.GetDependencyFile(resxFile) is not ResXFile retVal || retVal == null)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "That's probably better, thanks. This wasn't about clarity but correctness\u2014the cast was failing and throwing an exception because it wasn't a ResXFile. That shouldn't happen in practice, and it's now fixed (see previous comment), but did cause problems for a bit.",
              "createdAt": "2021-04-20T15:45:54Z",
              "path": "src/Tasks/ResGenDependencies.cs",
              "diffHunk": "@@ -90,11 +89,25 @@ internal bool UseSourcePath\n             }\n         }\n \n+        public ResGenDependencies() { }\n+\n+        public ResGenDependencies(ITranslator translator)\n+        {\n+            Translate(translator);\n+        }\n+\n+        public override void Translate(ITranslator translator)\n+        {\n+            resXFiles.Translate(translator, typeof(ResXFile));\n+            portableLibraries.Translate(translator, typeof(PortableLibraryFile));\n+            translator.Translate(ref baseLinkedFileDirectory);\n+            translator.Translate(ref _serializedVersion);\n+        }\n+\n         internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)\n         {\n             // First, try to retrieve the resx information from our hashtable.\n-            var retVal = (ResXFile)resXFiles.GetDependencyFile(resxFile);\n-            if (retVal == null)\n+            if (resXFiles.GetDependencyFile(resxFile) is not ResXFile retVal || retVal == null)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            /// Translates a dictionary of { string, DateTime }.\r\n```",
              "createdAt": "2021-04-27T15:10:29Z",
              "path": "src/Shared/BinaryTranslator.cs",
              "diffHunk": "@@ -1254,6 +1269,24 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali\n                 }\n             }\n \n+            /// <summary>\n+            /// Translates a dictionary of { string, T } for dictionaries with public parameterless constructors.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you use `_reader.ReadInt32()` here like other implementations?",
              "createdAt": "2021-04-27T15:11:12Z",
              "path": "src/Shared/BinaryTranslator.cs",
              "diffHunk": "@@ -660,12 +660,27 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali\n                 }\n             }\n \n-            /// <summary>\n-            /// Reads in the boolean which says if this object is null or not.\n-            /// </summary>\n-            /// <typeparam name=\"T\">The type of object to test.</typeparam>\n-            /// <returns>True if the object should be read, false otherwise.</returns>\n-            public bool TranslateNullable<T>(T value)\n+            public void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer)\n+            {\n+                int count = 0;\n+                dictionary = new(comparer);\n+                Translate(ref count);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "So is there now no equivalent to this test? What about the \"cache was written with v.last and is read with v.current\" scenario?",
              "createdAt": "2021-04-27T15:13:15Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs",
              "diffHunk": "@@ -42,178 +45,63 @@ public void RoundTripEmptyState()\n         {\n             SystemState systemState = new();\n \n-            systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);\n+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);\n \n-            var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);\n+            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));\n \n             deserialized.ShouldNotBeNull();\n         }\n \n-        [Fact]\n-        public void WrongFileSignature()\n-        {\n-            SystemState systemState = new();\n-\n-            for (int i = 0; i < TranslateContractSignature.Length; i++)\n-            {\n-                systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);\n-                using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))\n-                {\n-                    cacheStream.Seek(i, SeekOrigin.Begin);\n-                    cacheStream.WriteByte(0);\n-                    cacheStream.Close();\n-                }\n-\n-                var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);\n-\n-                deserialized.ShouldBeNull();\n-            }\n-        }\n-\n-        [Fact]\n-        public void WrongFileVersion()",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I can reinstate it. To be honest, in retrospect, I'm not sure why I deleted it in the first place.",
              "createdAt": "2021-04-28T00:25:18Z",
              "path": "src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs",
              "diffHunk": "@@ -42,178 +45,63 @@ public void RoundTripEmptyState()\n         {\n             SystemState systemState = new();\n \n-            systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);\n+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);\n \n-            var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);\n+            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));\n \n             deserialized.ShouldNotBeNull();\n         }\n \n-        [Fact]\n-        public void WrongFileSignature()\n-        {\n-            SystemState systemState = new();\n-\n-            for (int i = 0; i < TranslateContractSignature.Length; i++)\n-            {\n-                systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);\n-                using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))\n-                {\n-                    cacheStream.Seek(i, SeekOrigin.Begin);\n-                    cacheStream.WriteByte(0);\n-                    cacheStream.Close();\n-                }\n-\n-                var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);\n-\n-                deserialized.ShouldBeNull();\n-            }\n-        }\n-\n-        [Fact]\n-        public void WrongFileVersion()",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "as an aside, what happens if you build, change timezones, and build again? Do we potentially under build or do we handle that?",
              "createdAt": "2021-04-28T18:59:18Z",
              "path": "src/Shared/BinaryTranslator.cs",
              "diffHunk": "@@ -660,12 +660,31 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali\n                 }\n             }\n \n-            /// <summary>\n-            /// Reads in the boolean which says if this object is null or not.\n-            /// </summary>\n-            /// <typeparam name=\"T\">The type of object to test.</typeparam>\n-            /// <returns>True if the object should be read, false otherwise.</returns>\n-            public bool TranslateNullable<T>(T value)\n+            public void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer)\n+            {\n+                if (!TranslateNullable(dictionary))\n+                {\n+                    return;\n+                }\n+\n+                int count = _reader.ReadInt32();\n+                dictionary = new(count, comparer);\n+                string key = string.Empty;\n+                DateTime val = DateTime.MinValue;\n+                for (int i = 0; i < count; i++)\n+                {\n+                    Translate(ref key);\n+                    Translate(ref val);",
              "author": {
                "login": "danmoseley"
              }
            },
            {
              "body": "I believe we underbuild, but that's very unusual and perpendicular to this PR. (Does that sound right @rainersigwald?) This part is just about serializing and deserializing something.",
              "createdAt": "2021-04-28T21:27:07Z",
              "path": "src/Shared/BinaryTranslator.cs",
              "diffHunk": "@@ -660,12 +660,31 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali\n                 }\n             }\n \n-            /// <summary>\n-            /// Reads in the boolean which says if this object is null or not.\n-            /// </summary>\n-            /// <typeparam name=\"T\">The type of object to test.</typeparam>\n-            /// <returns>True if the object should be read, false otherwise.</returns>\n-            public bool TranslateNullable<T>(T value)\n+            public void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer)\n+            {\n+                if (!TranslateNullable(dictionary))\n+                {\n+                    return;\n+                }\n+\n+                int count = _reader.ReadInt32();\n+                dictionary = new(count, comparer);\n+                string key = string.Empty;\n+                DateTime val = DateTime.MinValue;\n+                for (int i = 0; i < count; i++)\n+                {\n+                    Translate(ref key);\n+                    Translate(ref val);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Never mind - I'm pretty sure the DateTimes are all UTC so time zones can generally be ignored. DateTime barely has a concept of time zone anyway.",
              "createdAt": "2021-04-28T22:32:42Z",
              "path": "src/Shared/BinaryTranslator.cs",
              "diffHunk": "@@ -660,12 +660,31 @@ public void TranslateDictionary<T>(ref Dictionary<string, T> dictionary, IEquali\n                 }\n             }\n \n-            /// <summary>\n-            /// Reads in the boolean which says if this object is null or not.\n-            /// </summary>\n-            /// <typeparam name=\"T\">The type of object to test.</typeparam>\n-            /// <returns>True if the object should be read, false otherwise.</returns>\n-            public bool TranslateNullable<T>(T value)\n+            public void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer)\n+            {\n+                if (!TranslateNullable(dictionary))\n+                {\n+                    return;\n+                }\n+\n+                int count = _reader.ReadInt32();\n+                dictionary = new(count, comparer);\n+                string key = string.Empty;\n+                DateTime val = DateTime.MinValue;\n+                for (int i = 0; i < count; i++)\n+                {\n+                    Translate(ref key);\n+                    Translate(ref val);",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      }
    ]
  }
}