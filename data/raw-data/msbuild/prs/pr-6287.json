{
  "number": 6287,
  "title": "Log properties and items on ProjectEvaluationFinished",
  "body": "Add an option to log global properties, properties and items on ProjectEvaluationFinishedEventArgs instead of ProjectStartedEventArgs. This option is currently only turned on by the BinaryLogger.\r\n\r\nThis has several advantages. Currently only the projects that are built by the central node log their properties and items (properties are translated across nodes only if a special flag is set, and items are never translated). This resulted in properties and items not being available for projects built on other nodes. Now we log them after every evaluation and translate across nodes if needed. Together with the fact that we now log EvaluationId for each ProjectStarted, we can now recover properties and items for all project started events. This is the main purpose of this PR - to not lose properties and items like we currently do. We will still not log for project results that are satisfied by cache, because we don't keep track of evaluation for these. Presumably it will have already been logged previously.\r\n\r\nIn addition, if more than one project are built from the same evaluation, we do not duplicate properties and items, only logging them once. This results in logging more information, but storing it more efficiently. Together with string and dictionary deduplication we see very significant savings in binlog size and some reduction in build time.\r\n\r\nThis change has several large parts:\r\n\r\n 1. add a way to enumerate evaluation properties and items directly at the end of Evaluate() for PropertyDictionary<ProjectPropertyInstance> and ItemDictionary<ProjectItemInstance>\r\n 2. manual translation logic for ProjectEvaluationStarted and ProjectEvaluationFinished (instead of relying on TranslateDotNet/BinaryFormatter)\r\n 3. reading and writing ProjectEvaluationFinished GlobalProperties, Properties and Items in BuildEventArgsReader/Writer (used by BinaryLogger)\r\n 4. adding IEventSource4 with IncludeEvaluationPropertiesAndItems, to propagate this setting across nodes and threading it through the LoggingService\r\n 5. update the ParallelConsoleLogger and SerialConsoleLogger to print the new data, if present\r\n 6. tests\r\n\r\nOne controversial design decision here is storing a reference to live evaluation data in ProjectEvaluationFinishedEventArgs. It does not make a snapshot of the data to avoid very significant allocations. It does take the lock on the PropertyDictionary<T>/ItemDictionary<T> when enumerating, because logging is asynchronous and the logging consumer (BinaryLogger) will enumerate the data potentially after the build has already started and the data is being mutated. I did see exceptions when enumerating without the lock. We had the same problem when the data was logged on ProjectStartedEventArgs though. In addition, there's a slight risk of logging not the exact data as it was at the end of evaluation, but the mutated data after some target has modified it. However given that the previous behavior was to not log anything for out-of-proc projects, and given the very significant allocation reduction, I think it's worth it.\r\n\r\nTo mitigate, we could capture a snapshot at the end of evaluation, so we don't hold a reference to live data. This won't need a lock to enumerate. Ideally we also rely on the immutable collections to avoid allocations, but I didn't see an easy way to do that currently. We can investigate this in a future change.\r\n\r\nFor items, it doesn't concatenate items of different types into a single large item stream, but keeps multiple lists, one per item type, to reflect the internal representation. Not flattening item types results in savings because we don't have to mention the item type for each item.\r\n\r\nThis change increments the BinaryLogger file format to 12, to serialize GlobalProperties, Properties and Items on ProjectEvaluationFinishedEventArgs. It also stores items more efficiently, without having to know the number of item types in advance and enumerate in a single pass. It writes the item type and all items of that type, and it writes 0 to signal there are no more item types. It also no longer writes the Message for args as it can be recovered upon reading.\r\n\r\nNew EnumerateProperties() and EnumerateItems() methods are added to Utilities, to consolidate the logic to enumerate the new data structures in a single location, used by packet translation logic, binary logger and the console loggers.\r\n\r\nPerf wise, I'm seeing no significant change on binlog size for small builds (it's a wash, because we log properties/items for all projects now, but they are no longer duplicated). For large projects I expect very significant savings though, as ProjectStarted is the most heavy-weight event in large binlogs.\r\nBuild performance with /bl on small-ish builds is improved 27 s -> 24 s for single-core and 18 s -> 17 s for parallel. No observable change without /bl.\r\n\r\nFixes\r\nhttps://github.com/dotnet/msbuild/issues/5316\r\nhttps://github.com/dotnet/msbuild/issues/3616",
  "state": "MERGED",
  "createdAt": "2021-03-20T20:50:19Z",
  "updatedAt": "2021-04-02T18:05:28Z",
  "closedAt": "2021-04-02T16:52:18Z",
  "mergedAt": "2021-04-02T16:52:18Z",
  "additions": 1420,
  "deletions": 222,
  "changedFiles": 40,
  "headRefName": "dev/kirillo/logEval",
  "isDraft": false,
  "author": {
    "login": "KirillOsenkov"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "79b4f41d4629168ed082a6c32e4eb3fbded56b90",
          "message": "Log properties and items on ProjectEvaluationFinished\n\nAdd an option to log global properties, properties and items on ProjectEvaluationFinishedEventArgs instead of ProjectStartedEventArgs. This option is currently only turned on by the BinaryLogger.\n\nThis has several advantages. Currently only the projects that are built by the central node log their properties and items (properties are translated across nodes only if a special flag is set, and items are never translated). This resulted in properties and items not being available for projects built on other nodes. Now we log them after every evaluation and translate across nodes if needed. Together with the fact that we now log EvaluationId for each ProjectStarted, we can now recover properties and items for all project started events. This is the main purpose of this PR - to not lose properties and items like we currently do. We will still not log for project results that are satisfied by cache, because we don't keep track of evaluation for these. Presumably it will have already been logged previously.\n\nIn addition, if more than one project are built from the same evaluation, we do not duplicate properties and items, only logging them once. This results in logging more information, but storing it more efficiently. Together with string and dictionary deduplication we see very significant savings in binlog size and some reduction in build time.\n\nThis change has several large parts:\n\n 1. add a way to enumerate evaluation properties and items directly at the end of Evaluate() for PropertyDictionary<ProjectPropertyInstance> and ItemDictionary<ProjectItemInstance>\n 2. manual translation logic for ProjectEvaluationStarted and ProjectEvaluationFinished (instead of relying on TranslateDotNet/BinaryFormatter)\n 3. reading and writing ProjectEvaluationFinished GlobalProperties, Properties and Items in BuildEventArgsReader/Writer (used by BinaryLogger)\n 4. adding IEventSource4 with IncludeEvaluationPropertiesAndItems, to propagate this setting across nodes and threading it through the LoggingService\n 5. update the ParallelConsoleLogger and SerialConsoleLogger to print the new data, if present\n 6. tests\n\nOne controversial design decision here is storing a reference to live evaluation data in ProjectEvaluationFinishedEventArgs. It does not make a snapshot of the data to avoid very significant allocations. It does take the lock on the PropertyDictionary<T>/ItemDictionary<T> when enumerating, because logging is asynchronous and the logging consumer (BinaryLogger) will enumerate the data potentially after the build has already started and the data is being mutated. I did see exceptions when enumerating without the lock. We had the same problem when the data was logged on ProjectStartedEventArgs though. In addition, there's a slight risk of logging not the exact data as it was at the end of evaluation, but the mutated data after some target has modified it. However given that the previous behavior was to not log anything for out-of-proc projects, and given the very significant allocation reduction, I think it's worth it.\n\nTo mitigate, we could capture a snapshot at the end of evaluation, so we don't hold a reference to live data. This won't need a lock to enumerate. Ideally we also rely on the immutable collections to avoid allocations, but I didn't see an easy way to do that currently. We can investigate this in a future change.\n\nFor items, it doesn't concatenate items of different types into a single large item stream, but keeps multiple lists, one per item type, to reflect the internal representation. Not flattening item types results in savings because we don't have to mention the item type for each item.\n\nThis change increments the BinaryLogger file format to 12, to serialize GlobalProperties, Properties and Items on ProjectEvaluationFinishedEventArgs. It also stores items more efficiently, without having to know the number of item types in advance and enumerate in a single pass. It writes the item type and all items of that type, and it writes 0 to signal there are no more item types. It also no longer writes the Message for args as it can be recovered upon reading.\n\nNew EnumerateProperties() and EnumerateItems() methods are added to Utilities, to consolidate the logic to enumerate the new data structures in a single location, used by packet translation logic, binary logger and the console loggers.\n\nPerf wise, I'm seeing no significant change on binlog size for small builds (it's a wash, because we log properties/items for all projects now, but they are no longer duplicated). For large projects I expect very significant savings though, as ProjectStarted is the most heavy-weight event in large binlogs.\nBuild performance with /bl on small-ish builds is improved 27 s -> 24 s for single-core and 18 s -> 17 s for parallel. No observable change without /bl.",
          "committedDate": "2021-03-20T20:44:29Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0a517ea1edc2b0a14925dce18d329065a6b759f7",
          "message": "Add Debug.Fail to catch unexpected cases",
          "committedDate": "2021-03-27T23:29:43Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ffb63ca84aa6f4ed09507a88f055b62dbbe4672d",
          "message": "Fix name.",
          "committedDate": "2021-03-27T23:31:00Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ad644b2014bd1a96f81bd5fcafcc0c88fb076026",
          "message": "Update src/Build/Collections/ItemDictionary.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-03-30T16:05:46Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "KirillOsenkov@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f953c0d0135edaa98b95791c6b73e55fe8a9c3e8",
          "message": "Update src/Build/Utilities/Utilities.cs\n\nCo-authored-by: Forgind <Forgind@users.noreply.github.com>",
          "committedDate": "2021-03-30T16:08:22Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "KirillOsenkov@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "87d1d511d7641c6b701f7dc6a37694fb2781a494",
          "message": "Revert \"Update src/Build/Collections/ItemDictionary.cs\"\n\nThis reverts commit ad644b2014bd1a96f81bd5fcafcc0c88fb076026.",
          "committedDate": "2021-03-30T16:14:21Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b7f5607ab22c2028e2998e86cfc1f22137a5a4f8",
          "message": "Use switch expression.",
          "committedDate": "2021-03-30T16:29:24Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "@mmitche it would be really good if you could take this one for a spin and get some stats on build perf and binlog size for a really large build.\r\n\r\nYou can use `msbuild -bl -c Release /p:CreateBootstrap=true` to produce an MSBuild layout and then use `C:\\MSBuild\\artifacts\\bin\\bootstrap\\net472\\MSBuild\\Current\\Bin\\MSBuild.exe` to build.",
        "createdAt": "2021-03-20T20:55:48Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I have updated the binlog viewer for the latest format and added some affordances to make it easier to look up properties and items now that they're logged at evaluation and not under the project:\r\n\r\n![image](https://user-images.githubusercontent.com/679326/112044293-e2703080-8b06-11eb-9d57-675be814ce1e.png)\r\n\r\n![image](https://user-images.githubusercontent.com/679326/112044008-886f6b00-8b06-11eb-89e5-84ca72305853.png)\r\n\r\n![image](https://user-images.githubusercontent.com/679326/112044043-91f8d300-8b06-11eb-9a4c-356a0acf7497.png)\r\n\r\n![image](https://user-images.githubusercontent.com/679326/112044124-aa68ed80-8b06-11eb-8634-ffcc73c74bd2.png)\r\n\r\n![image](https://user-images.githubusercontent.com/679326/112044262-d5534180-8b06-11eb-81a4-05b65330122f.png)\r\n",
        "createdAt": "2021-03-22T19:05:29Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Yes, the exceptions didn\u2019t happen every time but I saw them at least three times, which is often enough.\r\n\r\nTechnically you\u2019re right and we should keep track of the inaccuracies in binlog. I can add these to the wiki where I keep binlog stats. Keep in mind though that these pale in comparison to the status quo, which is most properties and items are simply not logged in multi-proc builds at all.",
        "createdAt": "2021-03-23T16:38:54Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "The properties / items logged in ProjectStarted events is not the evaluation state, but the current state of the mutated ProjectInstance. Several MSBuild tasks over the same ProjectInstance can mutate its state, and that state is what gets captured in ProjectStarted events, not the static evaluation state. Not showing this mutated state might make debugging harder. On the other hand it's probably good to log both though :) Or even better, do a diff and only log props/item that changed from evaluation, like added / deleted / changed.\r\n\r\n```xml\r\n<Project>\r\n    <Target Name=\"Build\">\r\n        <MSBuild Projects=\"B.proj\" Targets=\"AddFoo\" />\r\n        <MSBuild Projects=\"B.proj\" Targets=\"AddZar\" />\r\n    </Target>\r\n</Project>\r\n```\r\n\r\n```xml\r\n<!-- B.proj -->\r\n<Project>\r\n    <ItemGroup>\r\n        <CreatedInEvaluation Include=\"val\" />\r\n    </ItemGroup>\r\n\r\n    <Target Name=\"AddFoo\">\r\n        <ItemGroup>\r\n            <Foo_CreatedInATarget Include=\"bar\"/>\r\n        </ItemGroup>\r\n    </Target>\r\n\r\n    <Target Name=\"AddZar\">\r\n        <ItemGroup>\r\n            <Zar_CreatedInATarget Include=\"tar\"/>\r\n        </ItemGroup>\r\n    </Target>\r\n</Project>\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/2255729/112185199-3dfcf580-8bbd-11eb-8887-95a7dfc3df1b.png)\r\n\r\n",
        "createdAt": "2021-03-23T16:50:49Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "But as far as I can tell all post-evaluation mutations should be logged via TaskParameterEventArgs, right? So technically we could stitch together the latest state. Still, a great observation.",
        "createdAt": "2021-03-23T18:18:08Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I got some stats for building Roslyn.\r\n\r\nBinlog size:\r\n16.9: 122MB\r\nmain: 14.7MB\r\nPR 6287: 15.6MB\r\n\r\nAgainst expectations, the binlog size is increased slightly with this PR, but at least we log all properties and items for each project, not just a small part. You can tell whether it has properties and items by the presence of the target framework label:\r\n![image](https://user-images.githubusercontent.com/679326/112381723-25b5d500-8ca8-11eb-8f31-a3d94dab360f.png)\r\n\r\nThe build time seemed very close for this PR vs. main.",
        "createdAt": "2021-03-24T20:52:45Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "> But as far as I can tell all post-evaluation mutations should be logged via TaskParameterEventArgs, right? So technically we could stitch together the latest state. Still, a great observation.\r\n\r\nI would still leave both of them in (first evaluation state, and then the state at the beginning of each project build). Other loggers will not have the re-construction logic you mentioned above. If you write the reconstruction logic you can then change the binary logger to not include the eval state for project started events :). Regarding the concern of repeating mostly similar eval states, shouldn't the string dedup you previously added prevent that?",
        "createdAt": "2021-03-26T17:04:11Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "I considered leaving them on ProjectStarted as well, however here are some concerns:\r\n\r\n 1. it is kind of pointless because they will only be preserved for the central node, as we currently don't have logic that translates them across nodes. As you see in the screenshot above, currently we only log properties and items for a small chunk of projects (roughly 1/8 for my 8 core machine).\r\n 2. there are many many ProjectStarted events, as each project is being built multiple times for many targets. Logging all this new state, and translating it across nodes will drastically slow down the build and increase the binlog size (dedup logic will be disrupted by slight differences)\r\n 3. the behavior change in this PR is only when BinaryLogger is present: https://github.com/dotnet/msbuild/pull/6287/files#diff-0864a6f2e10a87d935fbf19d81370f534e67f33931642dec1f30023b108e2cdcR142 so other loggers will get the old behavior if /bl is not specified.\r\n\r\nWe certainly could look into tracking changes made to the eval properties and items and only log the deltas for each project, but that deserves to be a separate PR. I think you can do it intelligently so each project start receives the current immutable snapshot of the data and walks back to the initial snapshot from evaluation. We can also make the initial logging at evaluation finished inline, and not delayed, but for that we need true immutable data structures at the core. \r\n\r\nBasically I'm saying: there's certainly work to make it all better, this PR I believe vastly improves things without significant takebacks, so let's do it one step at a time ;)\r\n\r\nBut we can discuss more in person and hopefully we'll find a golden middle for this PR.",
        "createdAt": "2021-03-26T17:58:39Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I had to rollback a change to use Any() because LinkedList<T> doesn't have Any(). I had my reservations because Any() is a method call that does allocations etc. vs. Count == 0 is a simple check.",
        "createdAt": "2021-03-30T16:19:09Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "And yes, `protected internal` means protected OR internal (union). So everyone in the same assembly + all assemblies that this assembly has InternalsVisibleTo to + all derived types.\r\n\r\nC# recently introduced `private protected` to mean protected AND internal (intersection). Only types in the same assembly + IVT which derive from this one.",
        "createdAt": "2021-03-30T16:33:13Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "How do I trigger RPS for this? I have an exp branch here: https://github.com/dotnet/msbuild/tree/exp/kirillo/logEval",
        "createdAt": "2021-03-31T20:49:43Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Happened automatically\u2014[here's](https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequest/313663?_a=overview) your PR. Looks good!",
        "createdAt": "2021-03-31T21:23:38Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Zomg now all I want is the coveted Merge when branch open sticker",
        "createdAt": "2021-03-31T21:48:00Z",
        "author": {
          "login": "KirillOsenkov"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "What's the context behind this change?",
              "createdAt": "2021-03-23T15:58:07Z",
              "path": "ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs",
              "diffHunk": "@@ -38,7 +38,7 @@ public abstract partial class BuildEventArgs : System.EventArgs\n         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }\n         public string HelpKeyword { get { throw null; } }\n         public virtual string Message { get { throw null; } protected set { } }\n-        protected System.DateTime RawTimestamp { get { throw null; } set { } }",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I needed to be able to read and write the raw timestamp without reflection. protected wasn\u2019t enough because I needed access from LogMessagePacketBase and binlog writer, so I\u2019m adding protected internal. I was worried about exposing the field directly because who knows whether changing that field could break BinaryFormatter and I didn\u2019t call it Timestamp because having identifiers that differ by case only would break CLS compliance (not sure how much we care).",
              "createdAt": "2021-03-23T16:33:00Z",
              "path": "ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs",
              "diffHunk": "@@ -38,7 +38,7 @@ public abstract partial class BuildEventArgs : System.EventArgs\n         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }\n         public string HelpKeyword { get { throw null; } }\n         public virtual string Message { get { throw null; } protected set { } }\n-        protected System.DateTime RawTimestamp { get { throw null; } set { } }",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "This means it can be accessed freely within the assembly or by classes that extend it but not other classes? Is that right?",
              "createdAt": "2021-03-29T20:25:07Z",
              "path": "ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs",
              "diffHunk": "@@ -38,7 +38,7 @@ public abstract partial class BuildEventArgs : System.EventArgs\n         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }\n         public string HelpKeyword { get { throw null; } }\n         public virtual string Message { get { throw null; } protected set { } }\n-        protected System.DateTime RawTimestamp { get { throw null; } set { } }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "ReusableStringBuilder?",
              "createdAt": "2021-03-29T20:29:17Z",
              "path": "src/Build.UnitTests/BackEnd/TranslationHelpers.cs",
              "diffHunk": "@@ -104,5 +107,64 @@ internal static bool CompareExceptions(Exception left, Exception right)\n \n             return CompareExceptions(left.InnerException, right.InnerException);\n         }\n+\n+        internal static string GetPropertiesString(IEnumerable properties)\n+        {\n+            var dictionary = properties\n+                .OfType<DictionaryEntry>()\n+                .ToDictionary(\n+                    (Func<DictionaryEntry, string>)(d => d.Key.ToString()),\n+                    (Func<DictionaryEntry, string>)(d => d.Value.ToString()));\n+            return ToString(dictionary);\n+        }\n+\n+        internal static string GetMultiItemsString(IEnumerable items)\n+        {\n+            var list = items\n+                .OfType<DictionaryEntry>()\n+                .Select(i => i.Key.ToString() + GetTaskItemString(i.Value));\n+            var text = string.Join(\"\\n\", list);\n+            return text;\n+        }\n+\n+        internal static string GetItemsString(IEnumerable items)\n+        {\n+            var list = items\n+                .OfType<object>()\n+                .Select(i => GetTaskItemString(i));\n+            var text = string.Join(\"\\n\", list);\n+            return text;\n+        }\n+\n+        internal static string GetTaskItemString(object item)\n+        {\n+            var sb = new StringBuilder();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Tests, we don't care ;) I doubt there will be a difference on the test data of this size.",
              "createdAt": "2021-03-30T15:51:57Z",
              "path": "src/Build.UnitTests/BackEnd/TranslationHelpers.cs",
              "diffHunk": "@@ -104,5 +107,64 @@ internal static bool CompareExceptions(Exception left, Exception right)\n \n             return CompareExceptions(left.InnerException, right.InnerException);\n         }\n+\n+        internal static string GetPropertiesString(IEnumerable properties)\n+        {\n+            var dictionary = properties\n+                .OfType<DictionaryEntry>()\n+                .ToDictionary(\n+                    (Func<DictionaryEntry, string>)(d => d.Key.ToString()),\n+                    (Func<DictionaryEntry, string>)(d => d.Value.ToString()));\n+            return ToString(dictionary);\n+        }\n+\n+        internal static string GetMultiItemsString(IEnumerable items)\n+        {\n+            var list = items\n+                .OfType<DictionaryEntry>()\n+                .Select(i => i.Key.ToString() + GetTaskItemString(i.Value));\n+            var text = string.Join(\"\\n\", list);\n+            return text;\n+        }\n+\n+        internal static string GetItemsString(IEnumerable items)\n+        {\n+            var list = items\n+                .OfType<object>()\n+                .Select(i => GetTaskItemString(i));\n+            var text = string.Join(\"\\n\", list);\n+            return text;\n+        }\n+\n+        internal static string GetTaskItemString(object item)\n+        {\n+            var sb = new StringBuilder();",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "You're right; didn't notice.",
              "createdAt": "2021-03-30T16:02:22Z",
              "path": "src/Build.UnitTests/BackEnd/TranslationHelpers.cs",
              "diffHunk": "@@ -104,5 +107,64 @@ internal static bool CompareExceptions(Exception left, Exception right)\n \n             return CompareExceptions(left.InnerException, right.InnerException);\n         }\n+\n+        internal static string GetPropertiesString(IEnumerable properties)\n+        {\n+            var dictionary = properties\n+                .OfType<DictionaryEntry>()\n+                .ToDictionary(\n+                    (Func<DictionaryEntry, string>)(d => d.Key.ToString()),\n+                    (Func<DictionaryEntry, string>)(d => d.Value.ToString()));\n+            return ToString(dictionary);\n+        }\n+\n+        internal static string GetMultiItemsString(IEnumerable items)\n+        {\n+            var list = items\n+                .OfType<DictionaryEntry>()\n+                .Select(i => i.Key.ToString() + GetTaskItemString(i.Value));\n+            var text = string.Join(\"\\n\", list);\n+            return text;\n+        }\n+\n+        internal static string GetItemsString(IEnumerable items)\n+        {\n+            var list = items\n+                .OfType<object>()\n+                .Select(i => GetTaskItemString(i));\n+            var text = string.Join(\"\\n\", list);\n+            return text;\n+        }\n+\n+        internal static string GetTaskItemString(object item)\n+        {\n+            var sb = new StringBuilder();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I see several uses of OfType. I was wondering whether we could cut out some iterations like:\r\n```suggestion\r\n            get => _includeEvaluationPropertiesAndItems ??= _eventSinkDictionary.Values.Any(sink => sink is EventSourceSink esSink && esSink.IncludeEvaluationPropertiesAndItems);\r\n```\r\n\r\nand if that might make it faster. Doesn't seem like a particularly relevant performance problem, but I thought I'd mention it.",
              "createdAt": "2021-03-29T20:35:24Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -502,6 +508,16 @@ public bool IncludeTaskInputs\n             set => _includeTaskInputs = value;\n         }\n \n+        /// <summary>\n+        /// Should properties and items be logged on <see cref=\"ProjectEvaluationFinishedEventArgs\"/>\n+        /// instead of <see cref=\"ProjectStartedEventArgs\"/>?\n+        /// </summary>\n+        public bool IncludeEvaluationPropertiesAndItems\n+        {\n+            get => _includeEvaluationPropertiesAndItems ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationPropertiesAndItems);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "good idea in general, but this runs once per build on a list of like 2 items, and I just followed the existing pattern in that code (smart way to say \"copy pasted\")",
              "createdAt": "2021-03-30T16:02:55Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingService.cs",
              "diffHunk": "@@ -502,6 +508,16 @@ public bool IncludeTaskInputs\n             set => _includeTaskInputs = value;\n         }\n \n+        /// <summary>\n+        /// Should properties and items be logged on <see cref=\"ProjectEvaluationFinishedEventArgs\"/>\n+        /// instead of <see cref=\"ProjectStartedEventArgs\"/>?\n+        /// </summary>\n+        public bool IncludeEvaluationPropertiesAndItems\n+        {\n+            get => _includeEvaluationPropertiesAndItems ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationPropertiesAndItems);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm probably misunderstanding this, but it looks backwards. If we aren't including evaluation properties and items, we should pass properties as a parameter? Isn't that including it?",
              "createdAt": "2021-03-29T20:41:28Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -579,17 +594,24 @@ public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventConte\n \n                 ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectInstanceId), \"Cannot find the project configuration while injecting non-serialized data from out-of-proc node.\");\n                 var buildRequestConfiguration = _configCache.Value[projectInstanceId];\n-                ProjectStartedEventArgs buildEvent = new ProjectStartedEventArgs\n+\n+                IDictionary<string, string> globalProperties = null;\n+                if (!IncludeEvaluationPropertiesAndItems)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It is a bit confusing.\r\n\r\nif (!IncludeEvaluationPropertiesAndItems)\r\n    log stuff on ProjectStarted\r\nelse\r\n    log stuff on ProjectEvaluationFinished",
              "createdAt": "2021-03-30T16:04:39Z",
              "path": "src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs",
              "diffHunk": "@@ -579,17 +594,24 @@ public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventConte\n \n                 ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectInstanceId), \"Cannot find the project configuration while injecting non-serialized data from out-of-proc node.\");\n                 var buildRequestConfiguration = _configCache.Value[projectInstanceId];\n-                ProjectStartedEventArgs buildEvent = new ProjectStartedEventArgs\n+\n+                IDictionary<string, string> globalProperties = null;\n+                if (!IncludeEvaluationPropertiesAndItems)",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                    if (itemTypeBucket.Value?.Any())\r\n                    {\r\n                        itemTypeCallback(itemTypeBucket.Key, itemTypeBucket.Value);\r\n                    }\r\n```",
              "createdAt": "2021-03-29T21:28:59Z",
              "path": "src/Build/Collections/ItemDictionary.cs",
              "diffHunk": "@@ -167,6 +167,30 @@ IEnumerator IEnumerable.GetEnumerator()\n             return _itemLists.GetEnumerator();\n         }\n \n+        /// <summary>\n+        /// Enumerates item lists per each item type under the lock.\n+        /// </summary>\n+        /// <param name=\"itemTypeCallback\">\n+        /// A delegate that accepts the item type string and a list of items of that type.\n+        /// Will be called for each item type in the list.\n+        /// </param>\n+        internal void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)\n+        {\n+            lock (_itemLists)\n+            {\n+                foreach (var itemTypeBucket in _itemLists)\n+                {\n+                    if (itemTypeBucket.Value == null || itemTypeBucket.Value.Count == 0)\n+                    {\n+                        // skip empty markers\n+                        continue;\n+                    }\n+\n+                    itemTypeCallback(itemTypeBucket.Key, itemTypeBucket.Value);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: I prefer it this way\r\n```suggestion\r\n                Dictionary<string, string> dictionary = new(_properties.Count, MSBuildNameIgnoreCaseComparer.Default);\r\n```",
              "createdAt": "2021-03-29T21:31:57Z",
              "path": "src/Build/Collections/PropertyDictionary.cs",
              "diffHunk": "@@ -492,22 +492,33 @@ internal void RemoveProperties(IEnumerable<T> other)\n \n         /// <summary>\n         /// Helper to convert into a read-only dictionary of string, string.\n+        /// TODO: for performance, consider switching to returning IDictionary\n+        /// and returning ArrayDictionary if lookup of results is not needed.\n         /// </summary>\n         internal Dictionary<string, string> ToDictionary()\n         {\n-            Dictionary<string, string> dictionary;\n-\n             lock (_properties)\n             {\n-                dictionary = new Dictionary<string, string>(_properties.Count, MSBuildNameIgnoreCaseComparer.Default);\n+                var dictionary = new Dictionary<string, string>(_properties.Count, MSBuildNameIgnoreCaseComparer.Default);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there no case in which you would want to write 0 other than in indicating the end? I was thinking like if you have an item with Include=\"...\\0\\...\"",
              "createdAt": "2021-03-29T22:02:53Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -736,18 +755,71 @@ private void WriteProjectItems(IEnumerable items)\n                 return;\n             }\n \n-            var groups = items\n-                .OfType<DictionaryEntry>()\n-                .GroupBy(entry => entry.Key as string, entry => entry.Value as ITaskItem)\n-                .Where(group => !string.IsNullOrEmpty(group.Key))\n-                .ToArray();\n+            if (items is ItemDictionary<ProjectItemInstance> itemInstanceDictionary)\n+            {\n+                // If we have access to the live data from evaluation, it exposes a special method\n+                // to iterate the data structure under a lock and return results grouped by item type.\n+                // There's no need to allocate or call GroupBy this way.\n+                itemInstanceDictionary.EnumerateItemsPerType((itemType, itemList) =>\n+                {\n+                    WriteDeduplicatedString(itemType);\n+                    WriteTaskItemList(itemList);\n+                });\n \n-            Write(groups.Length);\n+                // signal the end\n+                Write(0);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "No, since strings are interned, the item text is not written here. Also we write how many strings we expect for each item type, and we read that many. So at this position in the stream only two things are possible: either the string that indicates the item type of the next group (non-zero) or 0 which indicates the end.",
              "createdAt": "2021-03-30T16:18:00Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs",
              "diffHunk": "@@ -736,18 +755,71 @@ private void WriteProjectItems(IEnumerable items)\n                 return;\n             }\n \n-            var groups = items\n-                .OfType<DictionaryEntry>()\n-                .GroupBy(entry => entry.Key as string, entry => entry.Value as ITaskItem)\n-                .Where(group => !string.IsNullOrEmpty(group.Key))\n-                .ToArray();\n+            if (items is ItemDictionary<ProjectItemInstance> itemInstanceDictionary)\n+            {\n+                // If we have access to the live data from evaluation, it exposes a special method\n+                // to iterate the data structure under a lock and return results grouped by item type.\n+                // There's no need to allocate or call GroupBy this way.\n+                itemInstanceDictionary.EnumerateItemsPerType((itemType, itemList) =>\n+                {\n+                    WriteDeduplicatedString(itemType);\n+                    WriteTaskItemList(itemList);\n+                });\n \n-            Write(groups.Length);\n+                // signal the end\n+                Write(0);",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why did you swap the nesting here?",
              "createdAt": "2021-03-29T22:10:42Z",
              "path": "src/Build/Logging/SerialConsoleLogger.cs",
              "diffHunk": "@@ -571,25 +571,36 @@ public override void CustomEventHandler(object sender, CustomBuildEventArgs e)\n \n         public override void StatusEventHandler(object sender, BuildStatusEventArgs e)\n         {\n-            if (showPerfSummary)\n+            if (e is ProjectEvaluationStartedEventArgs projectEvaluationStarted)\n             {\n-                ProjectEvaluationStartedEventArgs projectEvaluationStarted = e as ProjectEvaluationStartedEventArgs;\n-\n-                if (projectEvaluationStarted != null)\n+                if (showPerfSummary)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Because I only wanted to test for types once, and make showPerfSummary check secondary. showPerfSummary is no longer the only important thing in this method, so I wanted to downgrade that",
              "createdAt": "2021-03-30T16:06:41Z",
              "path": "src/Build/Logging/SerialConsoleLogger.cs",
              "diffHunk": "@@ -571,25 +571,36 @@ public override void CustomEventHandler(object sender, CustomBuildEventArgs e)\n \n         public override void StatusEventHandler(object sender, BuildStatusEventArgs e)\n         {\n-            if (showPerfSummary)\n+            if (e is ProjectEvaluationStartedEventArgs projectEvaluationStarted)\n             {\n-                ProjectEvaluationStartedEventArgs projectEvaluationStarted = e as ProjectEvaluationStartedEventArgs;\n-\n-                if (projectEvaluationStarted != null)\n+                if (showPerfSummary)",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n                    if (!String.IsNullOrEmpty(itemType))\r\n                    {\r\n                        callback(new DictionaryEntry(itemType, itemValue));\r\n                    }\r\n```",
              "createdAt": "2021-03-29T22:13:15Z",
              "path": "src/Build/Utilities/Utilities.cs",
              "diffHunk": "@@ -613,5 +615,118 @@ public static T[] ToArray<T>(this IEnumerator<T> enumerator)\n         {\n             return enumerator.ToEnumerable().ToArray();\n         }\n+\n+        public static void EnumerateProperties(IEnumerable properties, Action<KeyValuePair<string, string>> callback)\n+        {\n+            if (properties == null)\n+            {\n+                return;\n+            }\n+\n+            if (properties is PropertyDictionary<ProjectPropertyInstance> propertyInstanceDictionary)\n+            {\n+                propertyInstanceDictionary.Enumerate((key, value) =>\n+                {\n+                    callback(new KeyValuePair<string, string>(key, value));\n+                });\n+            }\n+            else if (properties is PropertyDictionary<ProjectProperty> propertyDictionary)\n+            {\n+                propertyDictionary.Enumerate((key, value) =>\n+                {\n+                    callback(new KeyValuePair<string, string>(key, value));\n+                });\n+            }\n+            else\n+            {\n+                foreach (var item in properties)\n+                {\n+                    if (item is IProperty property && !string.IsNullOrEmpty(property.Name))\n+                    {\n+                        callback(new KeyValuePair<string, string>(property.Name, property.EvaluatedValue ?? string.Empty));\n+                    }\n+                    else if (item is DictionaryEntry dictionaryEntry && dictionaryEntry.Key is string key && !string.IsNullOrEmpty(key))\n+                    {\n+                        callback(new KeyValuePair<string, string>(key, dictionaryEntry.Value as string ?? string.Empty));\n+                    }\n+                    else if (item is KeyValuePair<string, string> kvp)\n+                    {\n+                        callback(kvp);\n+                    }\n+                    else\n+                    {\n+                        if (item == null)\n+                        {\n+                            Debug.Fail($\"In {nameof(EnumerateProperties)}(): Unexpected: property is null\");\n+                        }\n+                        else\n+                        {\n+                            Debug.Fail($\"In {nameof(EnumerateProperties)}(): Unexpected property {item} of type {item?.GetType().ToString()}\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        public static void EnumerateItems(IEnumerable items, Action<DictionaryEntry> callback)\n+        {\n+            if (items is ItemDictionary<ProjectItemInstance> projectItemInstanceDictionary)\n+            {\n+                projectItemInstanceDictionary.EnumerateItemsPerType((itemType, itemList) =>\n+                {\n+                    foreach (var item in itemList)\n+                    {\n+                        callback(new DictionaryEntry(itemType, item));\n+                    }\n+                });\n+            }\n+            else if (items is ItemDictionary<ProjectItem> projectItemDictionary)\n+            {\n+                projectItemDictionary.EnumerateItemsPerType((itemType, itemList) =>\n+                {\n+                    foreach (var item in itemList)\n+                    {\n+                        callback(new DictionaryEntry(itemType, item));\n+                    }\n+                });\n+            }\n+            else\n+            {\n+                foreach (var item in items)\n+                {\n+                    string itemType = default;\n+                    object itemValue = null;\n+\n+                    if (item is IItem iitem)\n+                    {\n+                        itemType = iitem.Key;\n+                        itemValue = iitem;\n+                    }\n+                    else if (item is DictionaryEntry dictionaryEntry)\n+                    {\n+                        itemType = dictionaryEntry.Key as string;\n+                        itemValue = dictionaryEntry.Value;\n+                    }\n+                    else\n+                    {\n+                        if (item == null)\n+                        {\n+                            Debug.Fail($\"In {nameof(EnumerateItems)}(): Unexpected: {nameof(item)} is null\");\n+                        }\n+                        else\n+                        {\n+                            Debug.Fail($\"In {nameof(EnumerateItems)}(): Unexpected {nameof(item)} {item} of type {item?.GetType().ToString()}\");\n+                        }\n+                    }\n+\n+                    if (string.IsNullOrEmpty(itemType))\n+                    {\n+                        continue;\n+                    }\n+\n+                    callback(new DictionaryEntry(itemType, itemValue));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "In general, I prefer making an initial check and getting it out of the way, then proceed with the actual logic. This keeps the statements flatter and reduces nesting.\r\n\r\nHowever in this case you're right, for a single statement it's better your way.",
              "createdAt": "2021-03-30T16:08:18Z",
              "path": "src/Build/Utilities/Utilities.cs",
              "diffHunk": "@@ -613,5 +615,118 @@ public static T[] ToArray<T>(this IEnumerator<T> enumerator)\n         {\n             return enumerator.ToEnumerable().ToArray();\n         }\n+\n+        public static void EnumerateProperties(IEnumerable properties, Action<KeyValuePair<string, string>> callback)\n+        {\n+            if (properties == null)\n+            {\n+                return;\n+            }\n+\n+            if (properties is PropertyDictionary<ProjectPropertyInstance> propertyInstanceDictionary)\n+            {\n+                propertyInstanceDictionary.Enumerate((key, value) =>\n+                {\n+                    callback(new KeyValuePair<string, string>(key, value));\n+                });\n+            }\n+            else if (properties is PropertyDictionary<ProjectProperty> propertyDictionary)\n+            {\n+                propertyDictionary.Enumerate((key, value) =>\n+                {\n+                    callback(new KeyValuePair<string, string>(key, value));\n+                });\n+            }\n+            else\n+            {\n+                foreach (var item in properties)\n+                {\n+                    if (item is IProperty property && !string.IsNullOrEmpty(property.Name))\n+                    {\n+                        callback(new KeyValuePair<string, string>(property.Name, property.EvaluatedValue ?? string.Empty));\n+                    }\n+                    else if (item is DictionaryEntry dictionaryEntry && dictionaryEntry.Key is string key && !string.IsNullOrEmpty(key))\n+                    {\n+                        callback(new KeyValuePair<string, string>(key, dictionaryEntry.Value as string ?? string.Empty));\n+                    }\n+                    else if (item is KeyValuePair<string, string> kvp)\n+                    {\n+                        callback(kvp);\n+                    }\n+                    else\n+                    {\n+                        if (item == null)\n+                        {\n+                            Debug.Fail($\"In {nameof(EnumerateProperties)}(): Unexpected: property is null\");\n+                        }\n+                        else\n+                        {\n+                            Debug.Fail($\"In {nameof(EnumerateProperties)}(): Unexpected property {item} of type {item?.GetType().ToString()}\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        public static void EnumerateItems(IEnumerable items, Action<DictionaryEntry> callback)\n+        {\n+            if (items is ItemDictionary<ProjectItemInstance> projectItemInstanceDictionary)\n+            {\n+                projectItemInstanceDictionary.EnumerateItemsPerType((itemType, itemList) =>\n+                {\n+                    foreach (var item in itemList)\n+                    {\n+                        callback(new DictionaryEntry(itemType, item));\n+                    }\n+                });\n+            }\n+            else if (items is ItemDictionary<ProjectItem> projectItemDictionary)\n+            {\n+                projectItemDictionary.EnumerateItemsPerType((itemType, itemList) =>\n+                {\n+                    foreach (var item in itemList)\n+                    {\n+                        callback(new DictionaryEntry(itemType, item));\n+                    }\n+                });\n+            }\n+            else\n+            {\n+                foreach (var item in items)\n+                {\n+                    string itemType = default;\n+                    object itemValue = null;\n+\n+                    if (item is IItem iitem)\n+                    {\n+                        itemType = iitem.Key;\n+                        itemValue = iitem;\n+                    }\n+                    else if (item is DictionaryEntry dictionaryEntry)\n+                    {\n+                        itemType = dictionaryEntry.Key as string;\n+                        itemValue = dictionaryEntry.Value;\n+                    }\n+                    else\n+                    {\n+                        if (item == null)\n+                        {\n+                            Debug.Fail($\"In {nameof(EnumerateItems)}(): Unexpected: {nameof(item)} is null\");\n+                        }\n+                        else\n+                        {\n+                            Debug.Fail($\"In {nameof(EnumerateItems)}(): Unexpected {nameof(item)} {item} of type {item?.GetType().ToString()}\");\n+                        }\n+                    }\n+\n+                    if (string.IsNullOrEmpty(itemType))\n+                    {\n+                        continue;\n+                    }\n+\n+                    callback(new DictionaryEntry(itemType, itemValue));",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would you mind refactoring this slightly to be of the form:\r\n```C#\r\nreturn _eventType switch\r\n{\r\n    LoggingEventType.BuildErrorEvent => new BuildErrorEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),\r\n    LoggingEventType.BuildFinishedEvent => new BuildFinishedEventArgs(null, null, false),\r\n    ...\r\n}\r\n```\r\n?",
              "createdAt": "2021-03-29T22:17:44Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -493,6 +523,10 @@ private BuildEventArgs GetBuildEventArgFromId()\n #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5\n                 case LoggingEventType.TaskParameterEvent:\n                     return new TaskParameterEventArgs(0, null, null, true, default);\n+                case LoggingEventType.ProjectEvaluationStartedEvent:",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Sure",
              "createdAt": "2021-03-30T16:29:49Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -493,6 +523,10 @@ private BuildEventArgs GetBuildEventArgFromId()\n #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5\n                 case LoggingEventType.TaskParameterEvent:\n                     return new TaskParameterEventArgs(0, null, null, true, default);\n+                case LoggingEventType.ProjectEvaluationStartedEvent:",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think this can be turned into a switch statement because typeof isn't constant. I'd be happy to be wrong!",
              "createdAt": "2021-03-29T22:18:45Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -532,6 +566,16 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)\n             {\n                 return LoggingEventType.ProjectStartedEvent;\n             }\n+#if !TASKHOST\n+            else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yeah, CS0150: A constant value is expected.",
              "createdAt": "2021-03-30T16:12:05Z",
              "path": "src/Shared/LogMessagePacketBase.cs",
              "diffHunk": "@@ -532,6 +566,16 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)\n             {\n                 return LoggingEventType.ProjectStartedEvent;\n             }\n+#if !TASKHOST\n+            else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      }
    ]
  }
}