{
  "number": 5514,
  "title": "First stab at caching more RAR info",
  "body": "This gives RAR the ability to save off a modified state file and load it for later use.\r\n\r\n@rainersigwald, would you mind looking at this at some point to let me know if you think it's going in the direction you expected? This is certainly incomplete\u2014proposed future steps below.\r\n\r\nNote: As far as I can tell, the only file path stored and serialized (currently) is the key\u2014that is, FileStates didn't have any paths in them\u2014but the sample solutions I tried didn't have scatter files, so I was unsure about those. As far as I could tell, they're never used? That felt wrong, but it's internal, and there were very few references to it, and they seemed to be assigning to it with one exception that could be using it in a very indirect way.\r\n\r\nStill to do:\r\n - [x] Verify that the precomputed cache read in is real.\r\n - [x] Change logging such that it will log messages instead of errors or warnings if there are problems with deserializing the precomputed cache\r\n - [x] Comments at relevant points\r\n - [x] Switch serialization mode to another form (json?)\r\n - [x] Validation + performance tests\r\n - [ ] Have SDK opt in",
  "state": "CLOSED",
  "createdAt": "2020-07-14T23:11:04Z",
  "updatedAt": "2021-02-02T17:40:02Z",
  "closedAt": "2021-02-02T17:39:56Z",
  "mergedAt": null,
  "additions": 338,
  "deletions": 48,
  "changedFiles": 24,
  "headRefName": "rar-cache",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Performance",
    "Area: Task: Resolve Assembly References (RAR)"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "a79f3080ea40840edf1a6563447a8121fa45000f",
          "message": "First stab at caching more RAR info\n\nThis gives RAR the ability to save off a modified state file and load it for later use.\n\nStill to do:\n1) Verify that the precomputed cache read in is real.\n2) Change logging such that it will log messages instead of errors or warnings if there are problems with deserializing the precomputed cache\n3) Comments at relevant points\n4) Switch serialization mode to another form (json?)\n5) Validation + performance tests\n6) Have SDK opt in",
          "committedDate": "2020-07-14T23:03:06Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1d7355985217b3de3049d383a9d829173bb3d390",
          "message": "PR comments pt. 1",
          "committedDate": "2020-07-21T17:20:42Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "036c5a38dd759b46dc8cb52e9fa244f737a6acf1",
          "message": "Resolve first three bullet points",
          "committedDate": "2020-07-21T20:50:05Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8b3b613b728bb62f2b6ca1e97c267229f5f81078",
          "message": "Next steps",
          "committedDate": "2020-08-03T20:28:42Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6160d48cdf18dc7ad407588204fe1f475631f7d6",
          "message": "revert to BinaryFormatter",
          "committedDate": "2020-08-03T23:01:42Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9b95494d0351a91a2ed82f567c1d73cf751862e7",
          "message": "Serialize mvid",
          "committedDate": "2020-08-04T20:18:06Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "43195f4f368c443643f6a9757a7d025ed19e6a92",
          "message": "Design change",
          "committedDate": "2020-08-10T21:46:13Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "560806632da291d575d7251256a1f96cbb853d2b",
          "message": "PR comments\n\nI have not yet measured how long it takes to read a MVID vs. reading and parsing its references, nor have I made unit tests.",
          "committedDate": "2020-09-04T01:12:29Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ccb508da7ec32a57f3e49ee232ddca480fd73a95",
          "message": "Make DeserializeCache take a generic StateFileBase",
          "committedDate": "2020-09-08T21:13:52Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "354de87d4348988be672611b780f71fd4ac64d07",
          "message": "Use FileSystems.Default.FileExists",
          "committedDate": "2020-09-08T21:14:11Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fd76e0b73da602b5c1e0ba72cc652044d0bd02a0",
          "message": "Convert instanceLocalFileStateCache to a dictionary",
          "committedDate": "2020-09-08T21:18:39Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b1a7695f1291079bbebe6420e67815eea3754bdc",
          "message": "Fix generic",
          "committedDate": "2020-09-22T21:52:19Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d71f2a6552bfb85aaa7fd3695e0ca632d73f74af",
          "message": "Merge branch 'master' of https://github.com/dotnet/msbuild into rar-cache",
          "committedDate": "2020-09-22T21:53:14Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fbe102851c5dbda71ef6bf3663d61231a538ccd0",
          "message": "Build",
          "committedDate": "2020-09-22T22:28:09Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d790150b5b0d1a12a3f92894173540846a9e47b8",
          "message": "Fix bad changes",
          "committedDate": "2020-09-23T17:22:33Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a759006ef6b192171673a2bf9bc2253b25acc8a6",
          "message": "Added tests 1",
          "committedDate": "2020-10-02T22:41:39Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "767f1ccbddd9c72dba9c0ed8959a3c3c2073bac4",
          "message": "Finish tests\n\n...although they don't work yet",
          "committedDate": "2020-10-06T22:42:39Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "412c21b6339c2609f49f06ce7c8e5e6f1813940e",
          "message": "Create delegates to mock system calls",
          "committedDate": "2020-10-08T23:54:57Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2043c3f5bc02a1514db81c892e9a55d2f75f9598",
          "message": "PR feedback",
          "committedDate": "2020-11-12T02:19:27Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "853fd38f0c14b0fcfeb7e760d5d7e502fad31cb4",
          "message": "Avoid using overly new feature",
          "committedDate": "2020-11-12T15:57:42Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a2c0f4298c7eaa2af902e3a513e204d12fa58315",
          "message": "Merge https://github.com/dotnet/msbuild into rar-cache",
          "committedDate": "2020-11-12T16:18:21Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59aaab14e8a42ec0825b3f5941c1da774e7423a7",
          "message": "Remove MVID check",
          "committedDate": "2020-12-04T16:24:52Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0fdbdf975761b7c5fbf691414b261cbe56a9897c",
          "message": "Fix alignment; don't \"correct\" timestamp",
          "committedDate": "2020-12-07T15:51:58Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5f7732277c5c1a83fce5f5e659420824ded8c8a9",
          "message": "Simplify test",
          "committedDate": "2020-12-11T00:37:39Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f849a83bcf93f1d6fffe77fc8df285567e61d733",
          "message": "Delete extant precomputed cache",
          "committedDate": "2020-12-11T20:43:48Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Don't block on my approval. I am not very familiar with MSBuild. Although I will read this",
        "createdAt": "2020-08-11T17:39:37Z",
        "author": {
          "login": "wli3"
        }
      },
      {
        "body": "PR nit: \r\n\r\n- [ ] Verify that the precomputed cache read in is real.\r\n- [ ] Change logging such that it will log messages instead of errors or warnings if there are problems with deserializing the precomputed cache\r\n- [ ] Comments at relevant points\r\n- [ ] Switch serialization mode to another form (json?)\r\n- [ ] Validation + performance tests\r\n- [ ] Have SDK opt in\r\n\r\nCheckboxes! \ud83d\ude09",
        "createdAt": "2020-08-13T17:36:36Z",
        "author": {
          "login": "benvillalobos"
        }
      },
      {
        "body": "Looks like we are still in explore phase, trying out it will help the perf or not. But once we have are sure about this route, we should have unit test coverage.",
        "createdAt": "2020-08-23T17:45:18Z",
        "author": {
          "login": "wli3"
        }
      },
      {
        "body": "Did my first performance test, comparing building MSBuild.sln (with no caches) to building MSBuild.sln with only the precomputed caches. Here are the times for RAR:\r\nNo caches:\r\n![image](https://user-images.githubusercontent.com/12969783/93947159-e950ee80-fcef-11ea-825c-b39d8b51c535.png)\r\nOnly precomputed caches:\r\n![image](https://user-images.githubusercontent.com/12969783/93947187-f8d03780-fcef-11ea-969f-a26a4147d3f5.png)\r\n\r\nAlthough there's always a nontrivial chance that I did something wrong, and these results are invalid, they look promising!\r\n",
        "createdAt": "2020-09-22T23:24:08Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I build OrchardCore once with no caches of any kind and once with the perfect precomputed caches. Results (in ms):\r\nNoCaches:\r\nMean: 85838.3843\r\nMedian: 82582.754\r\nPrecomputedCaches:\r\nMean: 61150.18\r\nMedian: 58261.5\r\n\r\nLooking at the full data, I noticed more powerfully a trend hinted at by the data with building MSBuild: precomputed caches make it a little slower if RAR would be fast either way but much faster if it would actually have to calculate something. This make sense, since deserializing and validating the cache takes some time. More precisely, having no caches made RAR faster for the fastest forty (out of 159) RAR executions, ranging up to about 30 seconds. After that, however, the time it took increased much faster, so whereas the difference between the fastest RAR executions for the two was about 100ms, the difference between having precomputed caches and not having them was over a minute for the slowest execution.",
        "createdAt": "2020-11-23T21:38:45Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "We can't use `Assembly.LoadFrom` here--it's a real load and will lock the assembly in question. You'll need to use `System.Reflection.Metadata` to extract this information.",
              "createdAt": "2020-07-16T15:41:50Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -547,13 +552,58 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n-        /// <summary>\n-        /// Cached implementation of GetDirectories.\n-        /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = true;\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sfBase = (SystemState)DeserializeCache(stateFile, log, requiredReturnType);\n+                foreach (string s in sfBase.instanceLocalFileStateCache.Keys)\n+                {\n+                    if (!retVal.instanceLocalFileStateCache.ContainsKey(s))\n+                    {\n+                        FileState fileState = (FileState)sfBase.instanceLocalFileStateCache[s];\n+                        // Verify that the assembly is correct\n+                        if (File.Exists(s) && Assembly.LoadFile(s).ManifestModule.ModuleVersionId.Equals(fileState.ModuleVersionID))\n+                        {\n+                            // Correct file path and timestamp\n+                            string fullPath = Path.GetFullPath(Path.Combine(Directory.GetCurrentDirectory(), stateFile));\n+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)\n+        {\n+            foreach (string path in instanceLocalFileStateCache.Keys)\n+            {\n+                FileState fileState = (FileState)instanceLocalFileStateCache[path];\n+                fileState.ModuleVersionID = Assembly.LoadFrom(path).ManifestModule.ModuleVersionId;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Does `Assembly.ReflectionOnlyLoadFrom(path)` also work? It seems clearer to me.",
              "createdAt": "2020-07-16T21:02:08Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -547,13 +552,58 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n-        /// <summary>\n-        /// Cached implementation of GetDirectories.\n-        /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = true;\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sfBase = (SystemState)DeserializeCache(stateFile, log, requiredReturnType);\n+                foreach (string s in sfBase.instanceLocalFileStateCache.Keys)\n+                {\n+                    if (!retVal.instanceLocalFileStateCache.ContainsKey(s))\n+                    {\n+                        FileState fileState = (FileState)sfBase.instanceLocalFileStateCache[s];\n+                        // Verify that the assembly is correct\n+                        if (File.Exists(s) && Assembly.LoadFile(s).ManifestModule.ModuleVersionId.Equals(fileState.ModuleVersionID))\n+                        {\n+                            // Correct file path and timestamp\n+                            string fullPath = Path.GetFullPath(Path.Combine(Directory.GetCurrentDirectory(), stateFile));\n+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)\n+        {\n+            foreach (string path in instanceLocalFileStateCache.Keys)\n+            {\n+                FileState fileState = (FileState)instanceLocalFileStateCache[path];\n+                fileState.ModuleVersionID = Assembly.LoadFrom(path).ManifestModule.ModuleVersionId;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It does not. That also locks the assembly.",
              "createdAt": "2020-07-17T19:40:11Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -547,13 +552,58 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n-        /// <summary>\n-        /// Cached implementation of GetDirectories.\n-        /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = true;\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sfBase = (SystemState)DeserializeCache(stateFile, log, requiredReturnType);\n+                foreach (string s in sfBase.instanceLocalFileStateCache.Keys)\n+                {\n+                    if (!retVal.instanceLocalFileStateCache.ContainsKey(s))\n+                    {\n+                        FileState fileState = (FileState)sfBase.instanceLocalFileStateCache[s];\n+                        // Verify that the assembly is correct\n+                        if (File.Exists(s) && Assembly.LoadFile(s).ManifestModule.ModuleVersionId.Equals(fileState.ModuleVersionID))\n+                        {\n+                            // Correct file path and timestamp\n+                            string fullPath = Path.GetFullPath(Path.Combine(Directory.GetCurrentDirectory(), stateFile));\n+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)\n+        {\n+            foreach (string path in instanceLocalFileStateCache.Keys)\n+            {\n+                FileState fileState = (FileState)instanceLocalFileStateCache[path];\n+                fileState.ModuleVersionID = Assembly.LoadFrom(path).ManifestModule.ModuleVersionId;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "directory of stateFile, not current directory, right?",
              "createdAt": "2020-07-16T19:21:10Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -547,13 +552,58 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n-        /// <summary>\n-        /// Cached implementation of GetDirectories.\n-        /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = true;\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sfBase = (SystemState)DeserializeCache(stateFile, log, requiredReturnType);\n+                foreach (string s in sfBase.instanceLocalFileStateCache.Keys)\n+                {\n+                    if (!retVal.instanceLocalFileStateCache.ContainsKey(s))\n+                    {\n+                        FileState fileState = (FileState)sfBase.instanceLocalFileStateCache[s];\n+                        // Verify that the assembly is correct\n+                        if (File.Exists(s) && Assembly.LoadFile(s).ManifestModule.ModuleVersionId.Equals(fileState.ModuleVersionID))\n+                        {\n+                            // Correct file path and timestamp\n+                            string fullPath = Path.GetFullPath(Path.Combine(Directory.GetCurrentDirectory(), stateFile));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes\u2014directory of stateFile, and the relative path is s. (I should probably change that name, too.)",
              "createdAt": "2020-07-16T21:04:46Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -547,13 +552,58 @@ out fileState.frameworkName\n             frameworkName = fileState.frameworkName;\n         }\n \n-        /// <summary>\n-        /// Cached implementation of GetDirectories.\n-        /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = true;\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sfBase = (SystemState)DeserializeCache(stateFile, log, requiredReturnType);\n+                foreach (string s in sfBase.instanceLocalFileStateCache.Keys)\n+                {\n+                    if (!retVal.instanceLocalFileStateCache.ContainsKey(s))\n+                    {\n+                        FileState fileState = (FileState)sfBase.instanceLocalFileStateCache[s];\n+                        // Verify that the assembly is correct\n+                        if (File.Exists(s) && Assembly.LoadFile(s).ManifestModule.ModuleVersionId.Equals(fileState.ModuleVersionID))\n+                        {\n+                            // Correct file path and timestamp\n+                            string fullPath = Path.GetFullPath(Path.Combine(Directory.GetCurrentDirectory(), stateFile));",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why this change?",
              "createdAt": "2020-07-16T19:24:01Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1845,23 +1849,36 @@ private void LogConflict(Reference reference, string fusionName)\n         /// <summary>\n         /// Reads the state file (if present) into the cache.\n         /// </summary>\n-        private void ReadStateFile()\n+        private void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I know you said GetLastWriteTime was only provided for testing, but this is in case that ever changes. I wanted to update the `LastModified` field of each fileState to what it would be if it's queried later, and since it technically uses getLastWriteTime, I wanted to use the appropriate getLastWriteTime, which meant passing it through to DeserializePrecomputedCaches and using it to adjust LastModified rather than using the real timestamp.",
              "createdAt": "2020-07-16T21:08:52Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1845,23 +1849,36 @@ private void LogConflict(Reference reference, string fusionName)\n         /// <summary>\n         /// Reads the state file (if present) into the cache.\n         /// </summary>\n-        private void ReadStateFile()\n+        private void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I added installedAssemblyTableInfo because they were set together, and it seemed wrong to split them. That part wasn't actually needed, though.",
              "createdAt": "2020-07-16T21:09:57Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1845,23 +1849,36 @@ private void LogConflict(Reference reference, string fusionName)\n         /// <summary>\n         /// Reads the state file (if present) into the cache.\n         /// </summary>\n-        private void ReadStateFile()\n+        private void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't like this much better, would like to think on a name for these.\r\n\r\n```suggestion\r\n        public string OutputCache { get; set; }\r\n```",
              "createdAt": "2020-07-16T19:26:00Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -441,6 +441,10 @@ public string TargetedRuntimeVersion\n             set { _targetedRuntimeVersionRawValue = value; }\n         }\n \n+        public string PreComputedCacheOutputPath { get; set; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "How about CacheOutputPath, Relative(Path)CacheOutputPath, or OutputCachePath?",
              "createdAt": "2020-07-20T19:59:17Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -441,6 +441,10 @@ public string TargetedRuntimeVersion\n             set { _targetedRuntimeVersionRawValue = value; }\n         }\n \n+        public string PreComputedCacheOutputPath { get; set; }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        public string[] AssemblyInformationCache { get; set; }\r\n```\r\n\r\n?",
              "createdAt": "2020-07-16T19:26:25Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -441,6 +441,10 @@ public string TargetedRuntimeVersion\n             set { _targetedRuntimeVersionRawValue = value; }\n         }\n \n+        public string PreComputedCacheOutputPath { get; set; }\n+\n+        public string[] PreComputedCacheFileList { get; set; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "\"AssemblyInformation\" just sounds like \"related to RAR\" to me. It would probably be best to match this with the above name, so the equivalents of my latest suggestions would be (Secondary)CacheInputPath, Relative(Path)CacheInputPath, or InputCachePath. Do any of those sound reasonable to you?",
              "createdAt": "2020-07-20T20:03:12Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -441,6 +441,10 @@ public string TargetedRuntimeVersion\n             set { _targetedRuntimeVersionRawValue = value; }\n         }\n \n+        public string PreComputedCacheOutputPath { get; set; }\n+\n+        public string[] PreComputedCacheFileList { get; set; }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "These were made public as part of trying to switch to json. It seemed to be serializing/deserializing only public properties in my testing console even if it had access, but I think I'm still missing a piece.",
              "createdAt": "2020-08-11T18:04:12Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -192,22 +196,24 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)\n                     info.AddValue(\"fnId\", frameworkName.Identifier);\n                     info.AddValue(\"fmProf\", frameworkName.Profile);\n                 }\n+                info.AddValue(\"mvid\", ModuleVersionID);\n             }\n \n             /// <summary>\n             /// Gets the last modified date.\n             /// </summary>\n             /// <value></value>\n-            internal DateTime LastModified\n+            public DateTime LastModified",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `Array.Empty<string>()` instead of `new string[0]`.",
              "createdAt": "2020-08-26T13:46:31Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1843,25 +1855,33 @@ private void LogConflict(Reference reference, string fusionName)\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        private void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n         {\n             _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n \n-            // Construct the cache if necessary.\n             if (_cache == null)\n             {\n-                _cache = new SystemState();\n+                _cache = SystemState.DeserializePrecomputedCaches(CacheInputPaths ?? new string[0], Log, typeof(SystemState), getLastWriteTime, installedAssemblyTableInfo);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "`s/MSB3101/MSB3667/` ?\r\n\r\nAlso:\r\n- Is \"RAR\" an official acronym to be used in an error message?\r\n- `_CacheOutputPath` does not match the property name.\r\n- Should it be referred to as a \"parameter\" rather than \"field\"?",
              "createdAt": "2020-08-26T13:59:34Z",
              "path": "src/Tasks/Resources/Strings.resx",
              "diffHunk": "@@ -451,6 +451,10 @@\n     <value>MSB3101: Could not write state file \"{0}\". {1}</value>\n     <comment>{StrBegin=\"MSB3101: \"}</comment>\n   </data>\n+  <data name=\"General.StateFileAlreadyPresent\">\n+    <value>MSB3101: There is already a file at \"{0}\". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the \"_CacheOutputPath\" field of RAR.</value>",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Yea, make RAR explicit.\r\n\r\n---\r\nIn reply to: [477323537](https://github.com/dotnet/msbuild/pull/5514#discussion_r477323537) [](ancestors = 477323537)",
              "createdAt": "2020-11-12T01:59:32Z",
              "path": "src/Tasks/Resources/Strings.resx",
              "diffHunk": "@@ -451,6 +451,10 @@\n     <value>MSB3101: Could not write state file \"{0}\". {1}</value>\n     <comment>{StrBegin=\"MSB3101: \"}</comment>\n   </data>\n+  <data name=\"General.StateFileAlreadyPresent\">\n+    <value>MSB3101: There is already a file at \"{0}\". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the \"_CacheOutputPath\" field of RAR.</value>",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: This change shouldn't be needed as JSON serialization ignores fields.",
              "createdAt": "2020-08-26T14:11:04Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -115,7 +118,7 @@ private sealed class FileState : ISerializable\n             /// <summary>\n             /// The last modified time for this file.\n             /// </summary>\n-            private DateTime lastModified;\n+            internal DateTime lastModified;",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n            Hashtable newInstanceLocalFileStateCache = new Hashtable(instanceLocalFileStateCache.Count);\r\n```",
              "createdAt": "2020-08-26T14:22:28Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -548,12 +559,85 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sfBase = (SystemState)DeserializeCache(stateFile, log, requiredReturnType, false);\n+                foreach (string relativePath in sfBase.instanceLocalFileStateCache.Keys)\n+                {\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = (FileState)sfBase.instanceLocalFileStateCache[relativePath];\n+                        // Verify that the assembly is correct\n+                        Guid mvid;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile), relativePath));\n+                        if (File.Exists(fullPath))\n+                        {\n+                            using (var reader = new PEReader(File.OpenRead(fullPath)))\n+                            {\n+                                var metadataReader = reader.GetMetadataReader();\n+                                mvid = metadataReader.GetGuid(metadataReader.GetModuleDefinition().Mvid);\n+                            }\n+                            if (mvid.Equals(fileState.ModuleVersionID))\n+                            {\n+                                // Correct file path and timestamp\n+                                fileState.LastModified = retVal.getLastWriteTime(fullPath);\n+                                retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                                assembliesFound.Add(relativePath);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to stateFile.\n+        /// </summary>\n+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)\n+        {\n+            Hashtable newInstanceLocalFileStateCache = new Hashtable();",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Enumerate `instanceLocalFileStateCache` and not `instanceLocalFileStateCache.Keys` to avoid another hashtable lookup here.",
              "createdAt": "2020-08-26T14:23:24Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -548,12 +559,85 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sfBase = (SystemState)DeserializeCache(stateFile, log, requiredReturnType, false);\n+                foreach (string relativePath in sfBase.instanceLocalFileStateCache.Keys)\n+                {\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = (FileState)sfBase.instanceLocalFileStateCache[relativePath];\n+                        // Verify that the assembly is correct\n+                        Guid mvid;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile), relativePath));\n+                        if (File.Exists(fullPath))\n+                        {\n+                            using (var reader = new PEReader(File.OpenRead(fullPath)))\n+                            {\n+                                var metadataReader = reader.GetMetadataReader();\n+                                mvid = metadataReader.GetGuid(metadataReader.GetModuleDefinition().Mvid);\n+                            }\n+                            if (mvid.Equals(fileState.ModuleVersionID))\n+                            {\n+                                // Correct file path and timestamp\n+                                fileState.LastModified = retVal.getLastWriteTime(fullPath);\n+                                retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                                assembliesFound.Add(relativePath);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to stateFile.\n+        /// </summary>\n+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)\n+        {\n+            Hashtable newInstanceLocalFileStateCache = new Hashtable();\n+            foreach (string path in instanceLocalFileStateCache.Keys)\n+            {\n+                // Add MVID to allow us to verify that we are using the same assembly later\n+                FileState fileState = (FileState)instanceLocalFileStateCache[path];",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: Looking at the usages of this method, wouldn't it look nicer as a generic method?",
              "createdAt": "2020-09-04T15:43:29Z",
              "path": "src/Tasks/StateFileBase.cs",
              "diffHunk": "@@ -64,9 +65,10 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)\n         /// <summary>\n         /// Reads the specified file from disk into a StateFileBase derived object.\n         /// </summary>\n-        internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelper log, Type requiredReturnType)\n+        internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelper log, Type requiredReturnType, bool logWarnings = true)",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: make instanceLocalFileStateCache generic.",
              "createdAt": "2020-09-04T15:52:39Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -548,12 +559,91 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = (SystemState)DeserializeCache(stateFile, log, requiredReturnType, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (DictionaryEntry kvp in sysState.instanceLocalFileStateCache)",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I don't understand. Do you mean to make the type of instanceLocalFileStateCache more generic, change DictionaryEntry to var, make it so this can pull from something other than a system state by making the input to this loop instanceLocalFileStateCache instead of sysState, or something else?",
              "createdAt": "2020-09-08T20:38:20Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -548,12 +559,91 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = (SystemState)DeserializeCache(stateFile, log, requiredReturnType, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (DictionaryEntry kvp in sysState.instanceLocalFileStateCache)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Make it a generic dictionary, `<string, FileState>` or whatever its key and value types are.",
              "createdAt": "2020-09-08T20:58:38Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -548,12 +559,91 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = (SystemState)DeserializeCache(stateFile, log, requiredReturnType, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (DictionaryEntry kvp in sysState.instanceLocalFileStateCache)",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is the mvid check required? What can go wrong if the check didn't exist?",
              "createdAt": "2020-09-04T15:58:08Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -548,12 +559,91 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = (SystemState)DeserializeCache(stateFile, log, requiredReturnType, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (DictionaryEntry kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = (string)kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = (FileState)kvp.Value;\n+                        // Verify that the assembly is correct\n+                        Guid mvid;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile), relativePath));\n+                        if (File.Exists(fullPath))\n+                        {\n+                            using (var reader = new PEReader(File.OpenRead(fullPath)))\n+                            {\n+                                var metadataReader = reader.GetMetadataReader();\n+                                mvid = metadataReader.GetGuid(metadataReader.GetModuleDefinition().Mvid);\n+                            }\n+                            if (mvid.Equals(fileState.ModuleVersionID))",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "This cache is expected to come from another machine, and you could have a different version of the assembly.",
              "createdAt": "2020-09-08T20:34:41Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -548,12 +559,91 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = (SystemState)DeserializeCache(stateFile, log, requiredReturnType, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (DictionaryEntry kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = (string)kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = (FileState)kvp.Value;\n+                        // Verify that the assembly is correct\n+                        Guid mvid;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile), relativePath));\n+                        if (File.Exists(fullPath))\n+                        {\n+                            using (var reader = new PEReader(File.OpenRead(fullPath)))\n+                            {\n+                                var metadataReader = reader.GetMetadataReader();\n+                                mvid = metadataReader.GetGuid(metadataReader.GetModuleDefinition().Mvid);\n+                            }\n+                            if (mvid.Equals(fileState.ModuleVersionID))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I see, and the mvid is the only ID you found that's guaranteed to change, as people can lie about the assembly version (like we do). I wonder whether using the PEReader to parse the assembly mvid is slower or faster than just hashing the assembly contents as a blob.",
              "createdAt": "2020-09-08T20:57:14Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -548,12 +559,91 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = (SystemState)DeserializeCache(stateFile, log, requiredReturnType, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (DictionaryEntry kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = (string)kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = (FileState)kvp.Value;\n+                        // Verify that the assembly is correct\n+                        Guid mvid;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile), relativePath));\n+                        if (File.Exists(fullPath))\n+                        {\n+                            using (var reader = new PEReader(File.OpenRead(fullPath)))\n+                            {\n+                                var metadataReader = reader.GetMetadataReader();\n+                                mvid = metadataReader.GetGuid(metadataReader.GetModuleDefinition().Mvid);\n+                            }\n+                            if (mvid.Equals(fileState.ModuleVersionID))",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Right. I imagine which is faster would depend heavily on how big the assembly is\u2014if it's tiny, you may as well hash the whole thing. If it's huge, mvids are the way to go.",
              "createdAt": "2020-09-08T21:24:39Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -548,12 +559,91 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = (SystemState)DeserializeCache(stateFile, log, requiredReturnType, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (DictionaryEntry kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = (string)kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = (FileState)kvp.Value;\n+                        // Verify that the assembly is correct\n+                        Guid mvid;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile), relativePath));\n+                        if (File.Exists(fullPath))\n+                        {\n+                            using (var reader = new PEReader(File.OpenRead(fullPath)))\n+                            {\n+                                var metadataReader = reader.GetMetadataReader();\n+                                mvid = metadataReader.GetGuid(metadataReader.GetModuleDefinition().Mvid);\n+                            }\n+                            if (mvid.Equals(fileState.ModuleVersionID))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yup. Curious what the median BCL assembly size is.",
              "createdAt": "2020-09-08T22:22:40Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -548,12 +559,91 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = (SystemState)DeserializeCache(stateFile, log, requiredReturnType, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (DictionaryEntry kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = (string)kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = (FileState)kvp.Value;\n+                        // Verify that the assembly is correct\n+                        Guid mvid;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile), relativePath));\n+                        if (File.Exists(fullPath))\n+                        {\n+                            using (var reader = new PEReader(File.OpenRead(fullPath)))\n+                            {\n+                                var metadataReader = reader.GetMetadataReader();\n+                                mvid = metadataReader.GetGuid(metadataReader.GetModuleDefinition().Mvid);\n+                            }\n+                            if (mvid.Equals(fileState.ModuleVersionID))",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "use `FileSystems.Default`",
              "createdAt": "2020-09-04T16:02:24Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -548,12 +559,91 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+\n+            foreach (string stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = (SystemState)DeserializeCache(stateFile, log, requiredReturnType, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (DictionaryEntry kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = (string)kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = (FileState)kvp.Value;\n+                        // Verify that the assembly is correct\n+                        Guid mvid;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile), relativePath));\n+                        if (File.Exists(fullPath))",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How large does the `instanceLocalFileStateCache` dictionary get on average?\r\n\r\nThinking out loud: I wonder what difference it would make to `foreach` over the keys and look up the values vs iterating over the kvp's.",
              "createdAt": "2020-10-16T00:50:40Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +556,90 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            calculateMvid ??= CalculateMvid;\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        // Verify that the assembly is correct\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath) && calculateMvid(fullPath).Equals(fileState.ModuleVersionID))\n+                        {\n+                            // Correct file path and timestamp\n+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                            assembliesFound.Add(relativePath);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to stateFile.\n+        /// </summary>\n+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log, Func<string, Guid> calculateMvid)\n+        {\n+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);\n+            calculateMvid ??= CalculateMvid;\n+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The commit history shows you reverted back to a binaryformatter over json serialization. What was the reason for this again?",
              "createdAt": "2020-10-16T01:06:28Z",
              "path": "src/Tasks/StateFileBase.cs",
              "diffHunk": "@@ -77,32 +78,35 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp\n                     using (FileStream s = new FileStream(stateFile, FileMode.Open))\n                     {\n                         var formatter = new BinaryFormatter();",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Had trouble getting it to work. Made it work in #5704. ",
              "createdAt": "2020-10-16T19:44:54Z",
              "path": "src/Tasks/StateFileBase.cs",
              "diffHunk": "@@ -77,32 +78,35 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp\n                     using (FileStream s = new FileStream(stateFile, FileMode.Open))\n                     {\n                         var formatter = new BinaryFormatter();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this check necessary? You're iterating through a dictionary, there will be no duplicate keys.",
              "createdAt": "2020-10-16T01:15:37Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +556,90 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            calculateMvid ??= CalculateMvid;\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Ah, I see there may be duplicates between files. Will order matter here? Will there be some future file that has more information than a previous one, and therefore that info won't get logged?",
              "createdAt": "2020-10-16T01:19:12Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +556,90 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            calculateMvid ??= CalculateMvid;\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "No because any particular key with a valid mvid will be identical to any identical key/mvid pair.",
              "createdAt": "2020-10-16T19:44:34Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +556,90 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            calculateMvid ??= CalculateMvid;\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `t`, `u`, and `a3` aren't great variable names.",
              "createdAt": "2020-10-16T01:32:15Z",
              "path": "src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Xunit;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class RARPrecomputedCache_Tests\n+    {\n+        private Dictionary<string, Guid> guidStore = new Dictionary<string, Guid>();\n+\n+        private Guid calculateMvid(string path)\n+        {\n+            if (!guidStore.ContainsKey(path))\n+            {\n+                guidStore.Add(path, Guid.NewGuid());\n+            }\n+            return guidStore[path];\n+        }\n+\n+        [Fact]\n+        public void TestPrecomputedCacheOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+                t._cache = new SystemState();\n+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                t._cache.IsDirty = true;\n+                t.StateFile = standardCache.Path;\n+                t.WriteStateFile(calculateMvid);\n+                int standardLen = File.ReadAllText(standardCache.Path).Length;\n+                File.Delete(standardCache.Path);\n+                standardLen.ShouldBeGreaterThan(0);\n+\n+                string precomputedPath = standardCache.Path + \".cache\";\n+                t._cache.IsDirty = true;\n+                t.AssemblyInformationCacheOutputPath = precomputedPath;\n+                t.WriteStateFile(calculateMvid);\n+                File.Exists(standardCache.Path).ShouldBeFalse();\n+                int preLen = File.ReadAllText(precomputedPath).Length;\n+                preLen.ShouldBeGreaterThan(0);\n+                preLen.ShouldNotBe(standardLen);\n+            }\n+        }\n+\n+        [Fact]\n+        public void TestPreComputedCacheInputAndOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create()) {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+                t._cache = new SystemState();\n+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                t.StateFile = standardCache.Path;\n+                t._cache.IsDirty = true;\n+                t.WriteStateFile(calculateMvid);\n+\n+                string dllName = Path.Combine(Path.GetDirectoryName(standardCache.Path), \"randomFolder\", \"dll.dll\");\n+                t._cache.instanceLocalFileStateCache.Add(dllName,\n+                    new SystemState.FileState(DateTime.Now) {\n+                        Assembly = null,\n+                        RuntimeVersion = \"v4.0.30319\",\n+                        FrameworkNameAttribute = new System.Runtime.Versioning.FrameworkName(\".NETFramework\", Version.Parse(\"4.7.2\"), \"Profile\"),\n+                        scatterFiles = new string[] { \"first\", \"second\" } });\n+                string precomputedCachePath = standardCache.Path + \".cache\";\n+                t.AssemblyInformationCacheOutputPath = precomputedCachePath;\n+                t._cache.IsDirty = true;\n+                t.WriteStateFile(calculateMvid);\n+\n+                ResolveAssemblyReference u = new ResolveAssemblyReference();\n+                u.StateFile = standardCache.Path;\n+                u.AssemblyInformationCachePaths = new ITaskItem[]\n+                {\n+                    new TaskItem(precomputedCachePath)\n+                };\n+\n+                u.ReadStateFile(File.GetLastWriteTime, Array.Empty<AssemblyTableInfo>(), calculateMvid, p => true);\n+                u._cache.instanceLocalFileStateCache.ShouldNotContainKey(dllName);\n+                File.Delete(standardCache.Path);\n+                u._cache = null;\n+                u.ReadStateFile(File.GetLastWriteTime, Array.Empty<AssemblyTableInfo>(), calculateMvid, p => true);\n+                u._cache.instanceLocalFileStateCache.ShouldContainKey(dllName);\n+                SystemState.FileState a3 = u._cache.instanceLocalFileStateCache[dllName];",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "+1\r\n\r\n---\r\nIn reply to: [505966901](https://github.com/dotnet/msbuild/pull/5514#discussion_r505966901) [](ancestors = 505966901)",
              "createdAt": "2020-11-12T01:17:33Z",
              "path": "src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Xunit;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class RARPrecomputedCache_Tests\n+    {\n+        private Dictionary<string, Guid> guidStore = new Dictionary<string, Guid>();\n+\n+        private Guid calculateMvid(string path)\n+        {\n+            if (!guidStore.ContainsKey(path))\n+            {\n+                guidStore.Add(path, Guid.NewGuid());\n+            }\n+            return guidStore[path];\n+        }\n+\n+        [Fact]\n+        public void TestPrecomputedCacheOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+                t._cache = new SystemState();\n+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                t._cache.IsDirty = true;\n+                t.StateFile = standardCache.Path;\n+                t.WriteStateFile(calculateMvid);\n+                int standardLen = File.ReadAllText(standardCache.Path).Length;\n+                File.Delete(standardCache.Path);\n+                standardLen.ShouldBeGreaterThan(0);\n+\n+                string precomputedPath = standardCache.Path + \".cache\";\n+                t._cache.IsDirty = true;\n+                t.AssemblyInformationCacheOutputPath = precomputedPath;\n+                t.WriteStateFile(calculateMvid);\n+                File.Exists(standardCache.Path).ShouldBeFalse();\n+                int preLen = File.ReadAllText(precomputedPath).Length;\n+                preLen.ShouldBeGreaterThan(0);\n+                preLen.ShouldNotBe(standardLen);\n+            }\n+        }\n+\n+        [Fact]\n+        public void TestPreComputedCacheInputAndOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create()) {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+                t._cache = new SystemState();\n+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                t.StateFile = standardCache.Path;\n+                t._cache.IsDirty = true;\n+                t.WriteStateFile(calculateMvid);\n+\n+                string dllName = Path.Combine(Path.GetDirectoryName(standardCache.Path), \"randomFolder\", \"dll.dll\");\n+                t._cache.instanceLocalFileStateCache.Add(dllName,\n+                    new SystemState.FileState(DateTime.Now) {\n+                        Assembly = null,\n+                        RuntimeVersion = \"v4.0.30319\",\n+                        FrameworkNameAttribute = new System.Runtime.Versioning.FrameworkName(\".NETFramework\", Version.Parse(\"4.7.2\"), \"Profile\"),\n+                        scatterFiles = new string[] { \"first\", \"second\" } });\n+                string precomputedCachePath = standardCache.Path + \".cache\";\n+                t.AssemblyInformationCacheOutputPath = precomputedCachePath;\n+                t._cache.IsDirty = true;\n+                t.WriteStateFile(calculateMvid);\n+\n+                ResolveAssemblyReference u = new ResolveAssemblyReference();\n+                u.StateFile = standardCache.Path;\n+                u.AssemblyInformationCachePaths = new ITaskItem[]\n+                {\n+                    new TaskItem(precomputedCachePath)\n+                };\n+\n+                u.ReadStateFile(File.GetLastWriteTime, Array.Empty<AssemblyTableInfo>(), calculateMvid, p => true);\n+                u._cache.instanceLocalFileStateCache.ShouldNotContainKey(dllName);\n+                File.Delete(standardCache.Path);\n+                u._cache = null;\n+                u.ReadStateFile(File.GetLastWriteTime, Array.Empty<AssemblyTableInfo>(), calculateMvid, p => true);\n+                u._cache.instanceLocalFileStateCache.ShouldContainKey(dllName);\n+                SystemState.FileState a3 = u._cache.instanceLocalFileStateCache[dllName];",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this a strong enough check? Should we directly compare `File.ReadAllText` to exactly what we think the output should be?",
              "createdAt": "2020-10-16T01:37:15Z",
              "path": "src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Xunit;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class RARPrecomputedCache_Tests\n+    {\n+        private Dictionary<string, Guid> guidStore = new Dictionary<string, Guid>();\n+\n+        private Guid calculateMvid(string path)\n+        {\n+            if (!guidStore.ContainsKey(path))\n+            {\n+                guidStore.Add(path, Guid.NewGuid());\n+            }\n+            return guidStore[path];\n+        }\n+\n+        [Fact]\n+        public void TestPrecomputedCacheOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+                t._cache = new SystemState();\n+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                t._cache.IsDirty = true;\n+                t.StateFile = standardCache.Path;\n+                t.WriteStateFile(calculateMvid);\n+                int standardLen = File.ReadAllText(standardCache.Path).Length;\n+                File.Delete(standardCache.Path);\n+                standardLen.ShouldBeGreaterThan(0);",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I'd love to, but unfortunately, that output would differ depending on serialization method.",
              "createdAt": "2020-10-16T19:44:04Z",
              "path": "src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Xunit;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class RARPrecomputedCache_Tests\n+    {\n+        private Dictionary<string, Guid> guidStore = new Dictionary<string, Guid>();\n+\n+        private Guid calculateMvid(string path)\n+        {\n+            if (!guidStore.ContainsKey(path))\n+            {\n+                guidStore.Add(path, Guid.NewGuid());\n+            }\n+            return guidStore[path];\n+        }\n+\n+        [Fact]\n+        public void TestPrecomputedCacheOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+                t._cache = new SystemState();\n+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                t._cache.IsDirty = true;\n+                t.StateFile = standardCache.Path;\n+                t.WriteStateFile(calculateMvid);\n+                int standardLen = File.ReadAllText(standardCache.Path).Length;\n+                File.Delete(standardCache.Path);\n+                standardLen.ShouldBeGreaterThan(0);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I don't think I understand the purpose of this test. Isn't it a subset of the other one that does a round trip?",
              "createdAt": "2020-12-04T20:23:28Z",
              "path": "src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Xunit;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class RARPrecomputedCache_Tests\n+    {\n+        private Dictionary<string, Guid> guidStore = new Dictionary<string, Guid>();\n+\n+        private Guid calculateMvid(string path)\n+        {\n+            if (!guidStore.ContainsKey(path))\n+            {\n+                guidStore.Add(path, Guid.NewGuid());\n+            }\n+            return guidStore[path];\n+        }\n+\n+        [Fact]\n+        public void TestPrecomputedCacheOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+                t._cache = new SystemState();\n+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                t._cache.IsDirty = true;\n+                t.StateFile = standardCache.Path;\n+                t.WriteStateFile(calculateMvid);\n+                int standardLen = File.ReadAllText(standardCache.Path).Length;\n+                File.Delete(standardCache.Path);\n+                standardLen.ShouldBeGreaterThan(0);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Kinda, yeah. I still favor leaving it in because 1) it's already written, and 2) if there's a problem here (nontrivial possibility, since this is new), having a simpler test will more readily provide insight as to what exactly is broken. But I can get rid of it if you want; it isn't critical.",
              "createdAt": "2020-12-06T17:55:52Z",
              "path": "src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Xunit;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class RARPrecomputedCache_Tests\n+    {\n+        private Dictionary<string, Guid> guidStore = new Dictionary<string, Guid>();\n+\n+        private Guid calculateMvid(string path)\n+        {\n+            if (!guidStore.ContainsKey(path))\n+            {\n+                guidStore.Add(path, Guid.NewGuid());\n+            }\n+            return guidStore[path];\n+        }\n+\n+        [Fact]\n+        public void TestPrecomputedCacheOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+                t._cache = new SystemState();\n+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                t._cache.IsDirty = true;\n+                t.StateFile = standardCache.Path;\n+                t.WriteStateFile(calculateMvid);\n+                int standardLen = File.ReadAllText(standardCache.Path).Length;\n+                File.Delete(standardCache.Path);\n+                standardLen.ShouldBeGreaterThan(0);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\n```suggestion\r\n        private Guid CalculateMvid(string path)\r\n```",
              "createdAt": "2020-10-23T15:22:11Z",
              "path": "src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Xunit;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class RARPrecomputedCache_Tests\n+    {\n+        private Dictionary<string, Guid> guidStore = new Dictionary<string, Guid>();\n+\n+        private Guid calculateMvid(string path)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Leave a comment saying why the entry exists here but not at line 90.",
              "createdAt": "2020-11-12T01:38:30Z",
              "path": "src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Xunit;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class RARPrecomputedCache_Tests\n+    {\n+        private Dictionary<string, Guid> guidStore = new Dictionary<string, Guid>();\n+\n+        private Guid calculateMvid(string path)\n+        {\n+            if (!guidStore.ContainsKey(path))\n+            {\n+                guidStore.Add(path, Guid.NewGuid());\n+            }\n+            return guidStore[path];\n+        }\n+\n+        [Fact]\n+        public void TestPrecomputedCacheOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+                t._cache = new SystemState();\n+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                t._cache.IsDirty = true;\n+                t.StateFile = standardCache.Path;\n+                t.WriteStateFile(calculateMvid);\n+                int standardLen = File.ReadAllText(standardCache.Path).Length;\n+                File.Delete(standardCache.Path);\n+                standardLen.ShouldBeGreaterThan(0);\n+\n+                string precomputedPath = standardCache.Path + \".cache\";\n+                t._cache.IsDirty = true;\n+                t.AssemblyInformationCacheOutputPath = precomputedPath;\n+                t.WriteStateFile(calculateMvid);\n+                File.Exists(standardCache.Path).ShouldBeFalse();\n+                int preLen = File.ReadAllText(precomputedPath).Length;\n+                preLen.ShouldBeGreaterThan(0);\n+                preLen.ShouldNotBe(standardLen);\n+            }\n+        }\n+\n+        [Fact]\n+        public void TestPreComputedCacheInputAndOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create()) {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference t = new ResolveAssemblyReference();\n+                t._cache = new SystemState();\n+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                t.StateFile = standardCache.Path;\n+                t._cache.IsDirty = true;\n+                t.WriteStateFile(calculateMvid);\n+\n+                string dllName = Path.Combine(Path.GetDirectoryName(standardCache.Path), \"randomFolder\", \"dll.dll\");\n+                t._cache.instanceLocalFileStateCache.Add(dllName,\n+                    new SystemState.FileState(DateTime.Now) {\n+                        Assembly = null,\n+                        RuntimeVersion = \"v4.0.30319\",\n+                        FrameworkNameAttribute = new System.Runtime.Versioning.FrameworkName(\".NETFramework\", Version.Parse(\"4.7.2\"), \"Profile\"),\n+                        scatterFiles = new string[] { \"first\", \"second\" } });\n+                string precomputedCachePath = standardCache.Path + \".cache\";\n+                t.AssemblyInformationCacheOutputPath = precomputedCachePath;\n+                t._cache.IsDirty = true;\n+                t.WriteStateFile(calculateMvid);\n+\n+                ResolveAssemblyReference u = new ResolveAssemblyReference();\n+                u.StateFile = standardCache.Path;\n+                u.AssemblyInformationCachePaths = new ITaskItem[]\n+                {\n+                    new TaskItem(precomputedCachePath)\n+                };\n+\n+                u.ReadStateFile(File.GetLastWriteTime, Array.Empty<AssemblyTableInfo>(), calculateMvid, p => true);\n+                u._cache.instanceLocalFileStateCache.ShouldNotContainKey(dllName);\n+                File.Delete(standardCache.Path);\n+                u._cache = null;\n+                u.ReadStateFile(File.GetLastWriteTime, Array.Empty<AssemblyTableInfo>(), calculateMvid, p => true);\n+                u._cache.instanceLocalFileStateCache.ShouldContainKey(dllName);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does it make any sense to run the else branch even when `AssemblyInformationCacheOutputPath` is set?",
              "createdAt": "2020-11-12T01:50:58Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,25 +1855,33 @@ private void LogConflict(Reference reference, string fusionName)\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid = null, Func<string, bool> fileExists = null)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n+            _cache = StateFileBase.DeserializeCache<SystemState>(_stateFile, Log);\n \n-            // Construct the cache if necessary.\n             if (_cache == null)\n             {\n-                _cache = new SystemState();\n+                _cache = SystemState.DeserializePrecomputedCaches(AssemblyInformationCachePaths ?? Array.Empty<ITaskItem>(), Log, typeof(SystemState), getLastWriteTime, installedAssemblyTableInfo, calculateMvid, fileExists);\n+            }\n+            else\n+            {\n+                _cache.SetGetLastWriteTime(getLastWriteTime);\n+                _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n             }\n         }\n \n         /// <summary>\n-        /// Write out the state file if a state name was supplied and the cache is dirty.\n+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile(Func<string, Guid> calculateMvid = null)\n         {\n-            if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n+            if (!string.IsNullOrEmpty(AssemblyInformationCacheOutputPath))\n+            {\n+                _cache.SerializePrecomputedCache(AssemblyInformationCacheOutputPath, Log, calculateMvid);\n+            }\n+            else if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I don't think there's any need to. It wouldn't be a bad idea to switch the order of these; the first is expected to almost never be true, and if it is, you're creating a cache to send to users, and since that would likely only happen on a remote build machine, you probably don't care about local state.",
              "createdAt": "2020-11-12T01:57:25Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,25 +1855,33 @@ private void LogConflict(Reference reference, string fusionName)\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid = null, Func<string, bool> fileExists = null)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n+            _cache = StateFileBase.DeserializeCache<SystemState>(_stateFile, Log);\n \n-            // Construct the cache if necessary.\n             if (_cache == null)\n             {\n-                _cache = new SystemState();\n+                _cache = SystemState.DeserializePrecomputedCaches(AssemblyInformationCachePaths ?? Array.Empty<ITaskItem>(), Log, typeof(SystemState), getLastWriteTime, installedAssemblyTableInfo, calculateMvid, fileExists);\n+            }\n+            else\n+            {\n+                _cache.SetGetLastWriteTime(getLastWriteTime);\n+                _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n             }\n         }\n \n         /// <summary>\n-        /// Write out the state file if a state name was supplied and the cache is dirty.\n+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile(Func<string, Guid> calculateMvid = null)\n         {\n-            if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n+            if (!string.IsNullOrEmpty(AssemblyInformationCacheOutputPath))\n+            {\n+                _cache.SerializePrecomputedCache(AssemblyInformationCacheOutputPath, Log, calculateMvid);\n+            }\n+            else if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Why wouldn't you write the project-local cache file? Wouldn't that speed up SDK repo incremental builds?",
              "createdAt": "2020-12-04T19:46:20Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,25 +1855,33 @@ private void LogConflict(Reference reference, string fusionName)\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid = null, Func<string, bool> fileExists = null)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n+            _cache = StateFileBase.DeserializeCache<SystemState>(_stateFile, Log);\n \n-            // Construct the cache if necessary.\n             if (_cache == null)\n             {\n-                _cache = new SystemState();\n+                _cache = SystemState.DeserializePrecomputedCaches(AssemblyInformationCachePaths ?? Array.Empty<ITaskItem>(), Log, typeof(SystemState), getLastWriteTime, installedAssemblyTableInfo, calculateMvid, fileExists);\n+            }\n+            else\n+            {\n+                _cache.SetGetLastWriteTime(getLastWriteTime);\n+                _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n             }\n         }\n \n         /// <summary>\n-        /// Write out the state file if a state name was supplied and the cache is dirty.\n+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile(Func<string, Guid> calculateMvid = null)\n         {\n-            if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n+            if (!string.IsNullOrEmpty(AssemblyInformationCacheOutputPath))\n+            {\n+                _cache.SerializePrecomputedCache(AssemblyInformationCacheOutputPath, Log, calculateMvid);\n+            }\n+            else if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I guess my question would be \"why are you creating a precomputed cache if you're just doing an incremental build\"? The precomputed caches are for sending to customers, and they're only useful when building from an otherwise cache-free state. Note that if I remember correctly, serializing caches took ~7% of RAR's total time, and serializing two caches would double the time spent on it.",
              "createdAt": "2020-12-06T17:43:35Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1855,25 +1855,33 @@ private void LogConflict(Reference reference, string fusionName)\n \n         #region StateFile\n         /// <summary>\n-        /// Reads the state file (if present) into the cache.\n+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.\n         /// </summary>\n-        private void ReadStateFile()\n+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid = null, Func<string, bool> fileExists = null)\n         {\n-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));\n+            _cache = StateFileBase.DeserializeCache<SystemState>(_stateFile, Log);\n \n-            // Construct the cache if necessary.\n             if (_cache == null)\n             {\n-                _cache = new SystemState();\n+                _cache = SystemState.DeserializePrecomputedCaches(AssemblyInformationCachePaths ?? Array.Empty<ITaskItem>(), Log, typeof(SystemState), getLastWriteTime, installedAssemblyTableInfo, calculateMvid, fileExists);\n+            }\n+            else\n+            {\n+                _cache.SetGetLastWriteTime(getLastWriteTime);\n+                _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n             }\n         }\n \n         /// <summary>\n-        /// Write out the state file if a state name was supplied and the cache is dirty.\n+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.\n         /// </summary>\n-        private void WriteStateFile()\n+        internal void WriteStateFile(Func<string, Guid> calculateMvid = null)\n         {\n-            if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n+            if (!string.IsNullOrEmpty(AssemblyInformationCacheOutputPath))\n+            {\n+                _cache.SerializePrecomputedCache(AssemblyInformationCacheOutputPath, Log, calculateMvid);\n+            }\n+            else if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nice, nice.",
              "createdAt": "2020-11-12T01:58:12Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -31,7 +35,7 @@ internal sealed class SystemState : StateFileBase, ISerializable\n         /// <summary>\n         /// Cache at the SystemState instance level. It is serialized and reused between instances.\n         /// </summary>\n-        private Hashtable instanceLocalFileStateCache = new Hashtable(StringComparer.OrdinalIgnoreCase);\n+        internal Dictionary<string, FileState> instanceLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What about conflicts? You could either error (as a sanity check that conflicts don't happen) or you could keep the newest one.",
              "createdAt": "2020-11-12T02:14:39Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +556,90 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            calculateMvid ??= CalculateMvid;\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "If there are conflicts, the first one was already verified, so I skipped checking later ones that might be invalid to save a little time. I could easily imagine collisions, but if they both have the right mvid, they should be identical.",
              "createdAt": "2020-11-12T02:17:36Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +556,90 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            calculateMvid ??= CalculateMvid;\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "What if two files contain the same relative path but with different mvids?",
              "createdAt": "2020-11-12T02:22:39Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +556,90 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            calculateMvid ??= CalculateMvid;\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why not just silently overwrite?",
              "createdAt": "2020-12-04T18:05:32Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +549,73 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path and timestamp\n+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                            assembliesFound.Add(relativePath);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to stateFile.\n+        /// </summary>\n+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)\n+        {\n+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);\n+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)\n+            {\n+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key);\n+                newInstanceLocalFileStateCache[relativePath] = kvp.Value;\n+            }\n+            instanceLocalFileStateCache = newInstanceLocalFileStateCache;\n+\n+            if (FileUtilities.FileExistsNoThrow(stateFile))\n+            {\n+                log.LogWarningWithCodeFromResources(\"General.StateFileAlreadyPresent\", stateFile);\n+            }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "We decided this in a meeting a while back. Most people won't use this (_making_ a cache) at all, and those who do may be confused as to whether they should be building their solution to create the cache or building a project that uses all the assemblies from their solution to create the cache. This attempts to push for the correct behavior.",
              "createdAt": "2020-12-06T17:21:02Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +549,73 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path and timestamp\n+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                            assembliesFound.Add(relativePath);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to stateFile.\n+        /// </summary>\n+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)\n+        {\n+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);\n+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)\n+            {\n+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key);\n+                newInstanceLocalFileStateCache[relativePath] = kvp.Value;\n+            }\n+            instanceLocalFileStateCache = newInstanceLocalFileStateCache;\n+\n+            if (FileUtilities.FileExistsNoThrow(stateFile))\n+            {\n+                log.LogWarningWithCodeFromResources(\"General.StateFileAlreadyPresent\", stateFile);\n+            }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:indentation",
              "createdAt": "2020-12-04T18:06:05Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +549,73 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path and timestamp\n+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                            assembliesFound.Add(relativePath);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to stateFile.\n+        /// </summary>\n+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)\n+        {\n+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);\n+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)\n+            {\n+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key);\n+                newInstanceLocalFileStateCache[relativePath] = kvp.Value;\n+            }\n+            instanceLocalFileStateCache = newInstanceLocalFileStateCache;\n+\n+            if (FileUtilities.FileExistsNoThrow(stateFile))\n+            {\n+                log.LogWarningWithCodeFromResources(\"General.StateFileAlreadyPresent\", stateFile);\n+            }\n+            SerializeCache(stateFile, log);\n+        }\n+\n+            /// <summary>\n+            /// Cached implementation of GetDirectories.\n+            /// </summary>\n+            /// <param name=\"path\"></param>\n+            /// <param name=\"pattern\"></param>\n+            /// <returns></returns>\n+            private string[] GetDirectories(string path, string pattern)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this relativity assumption valid for how this will get created in the SDK?",
              "createdAt": "2020-12-04T18:06:46Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +549,73 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path and timestamp\n+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                            assembliesFound.Add(relativePath);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to stateFile.\n+        /// </summary>\n+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)\n+        {\n+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);\n+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)\n+            {\n+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I believe so. The cache will be serialized to a particular location relative to the SDK assemblies on the computer that builds the SDK, and when the user downloads both those assemblies and this cache, they will be in the same place relative to each other.",
              "createdAt": "2020-12-06T17:22:46Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +549,73 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path and timestamp\n+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);\n+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;\n+                            assembliesFound.Add(relativePath);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return retVal;\n+        }\n+\n+        /// <summary>\n+        /// Modifies this object to be more portable across machines, then writes it to stateFile.\n+        /// </summary>\n+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)\n+        {\n+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);\n+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)\n+            {\n+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why does this need to be externally accessible? Is it just for testing?",
              "createdAt": "2020-12-04T19:48:48Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -282,6 +287,7 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)\n         internal bool IsDirty\n         {\n             get { return isDirty; }\n+            set { isDirty = value; }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes",
              "createdAt": "2020-12-06T17:23:11Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -282,6 +287,7 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)\n         internal bool IsDirty\n         {\n             get { return isDirty; }\n+            set { isDirty = value; }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "is `stateFile.ToString()` the right approach here? Does it work for items returned from another project that have an `Include` that isn't based in the current working directory?",
              "createdAt": "2020-12-04T19:51:43Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +549,73 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I hadn't been thinking about that. The way I've been using them is passing in full paths, and users could get those from property + relative path if necessary. It's certainly limiting to make this assumption, but since it's new functionality, no one will be broken by it being restricted in that way, and it would certainly be faster to just know that it's a full path to the cache. I could go either way. It sounds like you'd prefer it account for globs and paths from other projects? We might need to talk about that if so, since I don't think I know all of how to do that.",
              "createdAt": "2020-12-06T17:30:45Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +549,73 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why this choice?",
              "createdAt": "2020-12-04T19:52:04Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +549,73 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I think it was a compat concern. Old state file uses serializationMethod_1, but user is using new version of MSBuild that expected seralizationMethod_2 --> we can't read the file, but we shouldn't error. It's better to have one slow build (then revert to normal speed) than to send an error and force the user to try to figure it out. This will hopefully be an edge case anyway, since a lot of the use of these caches is with new users.",
              "createdAt": "2020-12-06T17:35:47Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +549,73 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this the right timestamp? Doesn't it mean that we would potentially get incorrect information if the user updated one of the cached assemblies before a clean build?",
              "createdAt": "2020-12-04T20:09:54Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +549,73 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path and timestamp\n+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes! Thank you for pointing that out. I removed that line entirely, and it would have made the cache (often) wrong. This was good behavior when I was checking for mvids but is no longer correct, and I didn't remove it.",
              "createdAt": "2020-12-06T17:36:46Z",
              "path": "src/Tasks/SystemState.cs",
              "diffHunk": "@@ -544,12 +549,73 @@ out fileState.frameworkName\n         }\n \n         /// <summary>\n-        /// Cached implementation of GetDirectories.\n+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.\n         /// </summary>\n-        /// <param name=\"path\"></param>\n-        /// <param name=\"pattern\"></param>\n-        /// <returns></returns>\n-        private string[] GetDirectories(string path, string pattern)\n+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)\n+        {\n+            SystemState retVal = new SystemState();\n+            retVal.SetGetLastWriteTime(getLastWriteTime);\n+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);\n+            retVal.isDirty = stateFiles.Length > 0;\n+            HashSet<string> assembliesFound = new HashSet<string>();\n+            fileExists ??= FileSystems.Default.FileExists;\n+\n+            foreach (ITaskItem stateFile in stateFiles)\n+            {\n+                // Verify that it's a real stateFile; log message but do not error if not\n+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log, false);\n+                if (sysState == null)\n+                {\n+                    continue;\n+                }\n+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)\n+                {\n+                    string relativePath = kvp.Key;\n+                    if (!assembliesFound.Contains(relativePath))\n+                    {\n+                        FileState fileState = kvp.Value;\n+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));\n+                        if (fileExists(fullPath))\n+                        {\n+                            // Correct file path and timestamp\n+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I find this very confusing. Can you split it into two tests:\r\n\r\n1. \"Normal project-level StateFile cache takes precedence over AssemblyInformationCachePaths\", and\r\n2. \"Writing and then reading AssemblyInformationCachePaths preserves all relevant information\"?",
              "createdAt": "2020-12-04T20:27:14Z",
              "path": "src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs",
              "diffHunk": "@@ -0,0 +1,104 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.UnitTests;\n+using Microsoft.Build.Utilities;\n+using Shouldly;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using Xunit;\n+\n+namespace Microsoft.Build.Tasks.UnitTests\n+{\n+    public class RARPrecomputedCache_Tests\n+    {\n+        [Fact]\n+        public void TestPrecomputedCacheOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create())\n+            {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference t = new ResolveAssemblyReference()\n+                {\n+                    _cache = new SystemState()\n+                };\n+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                t._cache.IsDirty = true;\n+                t.StateFile = standardCache.Path;\n+                t.WriteStateFile();\n+                int standardLen = File.ReadAllText(standardCache.Path).Length;\n+                File.Delete(standardCache.Path);\n+                standardLen.ShouldBeGreaterThan(0);\n+\n+                string precomputedPath = standardCache.Path + \".cache\";\n+                t._cache.IsDirty = true;\n+                t.AssemblyInformationCacheOutputPath = precomputedPath;\n+                t.WriteStateFile();\n+                File.Exists(standardCache.Path).ShouldBeFalse();\n+                int preLen = File.ReadAllText(precomputedPath).Length;\n+                preLen.ShouldBeGreaterThan(0);\n+                preLen.ShouldNotBe(standardLen);\n+            }\n+        }\n+\n+        [Fact]\n+        public void TestPreComputedCacheInputAndOutput()\n+        {\n+            using (TestEnvironment env = TestEnvironment.Create()) {\n+                TransientTestFile standardCache = env.CreateFile(\".cache\");\n+                ResolveAssemblyReference rarWriterTask = new ResolveAssemblyReference()\n+                {\n+                    _cache = new SystemState()\n+                };\n+                rarWriterTask._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {\n+                    { Path.Combine(standardCache.Path, \"assembly1\"), new SystemState.FileState(DateTime.Now) },\n+                    { Path.Combine(standardCache.Path, \"assembly2\"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension(\"hi\") } } };\n+                rarWriterTask.StateFile = standardCache.Path;\n+                rarWriterTask._cache.IsDirty = true;\n+                rarWriterTask.WriteStateFile();\n+\n+                string dllName = Path.Combine(Path.GetDirectoryName(standardCache.Path), \"randomFolder\", \"dll.dll\");\n+                rarWriterTask._cache.instanceLocalFileStateCache.Add(dllName,\n+                    new SystemState.FileState(DateTime.Now) {\n+                        Assembly = null,\n+                        RuntimeVersion = \"v4.0.30319\",\n+                        FrameworkNameAttribute = new System.Runtime.Versioning.FrameworkName(\".NETFramework\", Version.Parse(\"4.7.2\"), \"Profile\"),\n+                        scatterFiles = new string[] { \"first\", \"second\" } });\n+                string precomputedCachePath = standardCache.Path + \".cache\";\n+                rarWriterTask.AssemblyInformationCacheOutputPath = precomputedCachePath;\n+                rarWriterTask._cache.IsDirty = true;\n+                rarWriterTask.WriteStateFile();\n+\n+                ResolveAssemblyReference rarReaderTask = new ResolveAssemblyReference();\n+                rarReaderTask.StateFile = standardCache.Path;\n+                rarReaderTask.AssemblyInformationCachePaths = new ITaskItem[]\n+                {\n+                    new TaskItem(precomputedCachePath)\n+                };\n+\n+                // At this point, we should have created two cache files: one \"normal\" one and one \"precomputed\" one.\n+                // When we read the state file the first time, it should read from the caches produced in a normal\n+                // build, partially because we can read it faster. If that cache does not exist, as with the second\n+                // time we try to read the state file, it defaults to reading the \"precomputed\" cache. In this case,\n+                // the normal cache does not have dll.dll, whereas the precomputed cache does, so it should not be\n+                // present when we read the first time but should be present the second time. Then we verify that the\n+                // information contained in that cache matches what we'd expect.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}