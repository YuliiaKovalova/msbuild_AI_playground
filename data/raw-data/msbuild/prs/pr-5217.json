{
  "number": 5217,
  "title": "Reduce allocations in ItemGroupLoggingHelper.",
  "body": "This code is a very hot path (though only hit when LogTaskInputs is set).\r\nThere was an n^2 string concatenation problem alongside with other easily avoidable allocations.\r\nCache resource strings to avoid extracting them from resources every time.\r\nUse a ThreadStatic field to avoid allocating an array every time.\r\nSorting key value pairs in place is 3x faster than LINQ OrderBy.",
  "state": "CLOSED",
  "createdAt": "2020-04-01T03:19:57Z",
  "updatedAt": "2021-03-04T03:20:49Z",
  "closedAt": "2020-04-02T20:12:24Z",
  "mergedAt": null,
  "additions": 114,
  "deletions": 51,
  "changedFiles": 4,
  "headRefName": "dev/kirillo/ItemGroupLoggingHelper",
  "isDraft": false,
  "author": {
    "login": "KirillOsenkov"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "a7d04a656da619f8a7eb0adfe50b89cb3d85a0aa",
          "message": "Reduce allocations in ItemGroupLoggingHelper.\n\nThis code is a very hot path (though only hit when LogTaskInputs is set).\nThere was an n^2 string concatenation problem alongside with other easily avoidable allocations.\nCache resource strings to avoid extracting them from resources every time.\nUse a ThreadStatic field to avoid allocating an array every time.\nSorting key value pairs in place is 3x faster than LINQ OrderBy.",
          "committedDate": "2020-04-01T03:16:34Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0d49d6044153213fc2e238d6fbd1df55bc4a7e30",
          "message": "Turn off logging item metadata for task parameters.\n\nItem metadata is logged for AddItem and RemoveItem (intrinsic tasks) as well as Output items.\n\nRemove an overload of GetParameterText that accepts params. Everyone calling it was calling an unnecessary ToArray().\nUse List instead of IList to be able to call the overload that accepts IList.\n\nFix a cast error in previous commit. Enumerating a non-generic IDictionary returned DictionaryEntry instead of KeyValuePair<,>. Try cast the IDictionary to IDictionary<K,V> first to get KeyValuePair<,> and if the cast fails, fall back to DictionaryEntry (this codepath shouldn't be hit).",
          "committedDate": "2020-04-01T21:53:03Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f081c34d60d4ffa57eb7d319d217efbe19aca1f2",
          "message": "Add a fast path for getting scalar parameter values.",
          "committedDate": "2020-04-01T23:03:57Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3e533e1194f538c4c63b90304a9152f143d106e0",
          "message": "Add an escape hatch to log all task input item metadata.",
          "committedDate": "2020-04-01T23:06:00Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Relevant benchmark:\r\nhttps://github.com/KirillOsenkov/Benchmarks/blob/e9b3af701eb4bf98a598b866cc252349b50819e3/Benchmarks/Tests/SortDictionary.cs#L56",
        "createdAt": "2020-04-01T03:21:14Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Yes, I should tease these out to be two separate PRs. This kind of evolved as I was learning :)",
        "createdAt": "2020-04-01T23:08:50Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Here's the allocation reduction without the change to metadata logging:\r\nhttps://github.com/microsoft/msbuild/pull/5224",
        "createdAt": "2020-04-01T23:27:10Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "I suggest let's close this PR, and use #5224 instead. After this merges I can start another one for turning off logging of metadata.",
        "createdAt": "2020-04-01T23:30:51Z",
        "author": {
          "login": "KirillOsenkov"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Rather than caching four specific strings (presumably the most oft-used?), could you initialize an empty dictionary and cache strings in there as you need them?",
              "createdAt": "2020-04-01T22:01:48Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -16,18 +16,15 @@ namespace Microsoft.Build.BackEnd\n     /// </summary>\n     internal static class ItemGroupLoggingHelper\n     {\n-        /// <summary>\n-        /// Gets a text serialized value of a parameter for logging.\n-        /// </summary>\n-        internal static string GetParameterText(string prefix, string parameterName, params object[] parameterValues)\n-        {\n-            return GetParameterText(prefix, parameterName, (IList)parameterValues);\n-        }\n+        internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString(\"ItemGroupIncludeLogMessagePrefix\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Actually, these are the only strings that are used in normal conditions, right? So this seems reasonable.",
              "createdAt": "2020-04-01T22:22:49Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -16,18 +16,15 @@ namespace Microsoft.Build.BackEnd\n     /// </summary>\n     internal static class ItemGroupLoggingHelper\n     {\n-        /// <summary>\n-        /// Gets a text serialized value of a parameter for logging.\n-        /// </summary>\n-        internal static string GetParameterText(string prefix, string parameterName, params object[] parameterValues)\n-        {\n-            return GetParameterText(prefix, parameterName, (IList)parameterValues);\n-        }\n+        internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString(\"ItemGroupIncludeLogMessagePrefix\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, the strings are fixed always.\r\n\r\nThere wasn't an OrderBy but I was considering various approaches to sort, and decided to measure properly. Good thing I didn't go with it ;) https://twitter.com/KirillOsenkov/status/1245180011457306624",
              "createdAt": "2020-04-01T22:36:56Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -16,18 +16,15 @@ namespace Microsoft.Build.BackEnd\n     /// </summary>\n     internal static class ItemGroupLoggingHelper\n     {\n-        /// <summary>\n-        /// Gets a text serialized value of a parameter for logging.\n-        /// </summary>\n-        internal static string GetParameterText(string prefix, string parameterName, params object[] parameterValues)\n-        {\n-            return GetParameterText(prefix, parameterName, (IList)parameterValues);\n-        }\n+        internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString(\"ItemGroupIncludeLogMessagePrefix\");",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Is there anything wrong with an unstable sort here? Metadata all have unique names.",
              "createdAt": "2020-04-01T22:40:34Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -16,18 +16,15 @@ namespace Microsoft.Build.BackEnd\n     /// </summary>\n     internal static class ItemGroupLoggingHelper\n     {\n-        /// <summary>\n-        /// Gets a text serialized value of a parameter for logging.\n-        /// </summary>\n-        internal static string GetParameterText(string prefix, string parameterName, params object[] parameterValues)\n-        {\n-            return GetParameterText(prefix, parameterName, (IList)parameterValues);\n-        }\n+        internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString(\"ItemGroupIncludeLogMessagePrefix\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "We should be good here. I doubt they really have to be sorted in the first place. The viewer could sort when loading the binlog. But I guess there's some merit to it if they always appear in the same order, maybe some log parsing tools rely on that. \r\n\r\nAlthough if a log parsing tool isn't using binlog they just deserve the pain they get ;)",
              "createdAt": "2020-04-01T22:43:57Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -16,18 +16,15 @@ namespace Microsoft.Build.BackEnd\n     /// </summary>\n     internal static class ItemGroupLoggingHelper\n     {\n-        /// <summary>\n-        /// Gets a text serialized value of a parameter for logging.\n-        /// </summary>\n-        internal static string GetParameterText(string prefix, string parameterName, params object[] parameterValues)\n-        {\n-            return GetParameterText(prefix, parameterName, (IList)parameterValues);\n-        }\n+        internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString(\"ItemGroupIncludeLogMessagePrefix\");",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I see an argument both ways, since having a consistent order is good, but so is allocating less. I'm tempted to put out a no-sort version under a feature flag and see what people think, but it probably isn't worth it.",
              "createdAt": "2020-04-01T22:47:47Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -16,18 +16,15 @@ namespace Microsoft.Build.BackEnd\n     /// </summary>\n     internal static class ItemGroupLoggingHelper\n     {\n-        /// <summary>\n-        /// Gets a text serialized value of a parameter for logging.\n-        /// </summary>\n-        internal static string GetParameterText(string prefix, string parameterName, params object[] parameterValues)\n-        {\n-            return GetParameterText(prefix, parameterName, (IList)parameterValues);\n-        }\n+        internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString(\"ItemGroupIncludeLogMessagePrefix\");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, there's just so much more low-hanging fruit everywhere. I'd love to fix that first.",
              "createdAt": "2020-04-01T23:08:21Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -16,18 +16,15 @@ namespace Microsoft.Build.BackEnd\n     /// </summary>\n     internal static class ItemGroupLoggingHelper\n     {\n-        /// <summary>\n-        /// Gets a text serialized value of a parameter for logging.\n-        /// </summary>\n-        internal static string GetParameterText(string prefix, string parameterName, params object[] parameterValues)\n-        {\n-            return GetParameterText(prefix, parameterName, (IList)parameterValues);\n-        }\n+        internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString(\"ItemGroupIncludeLogMessagePrefix\");",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "We should take note of other places where we can cache resource strings like this \ud83d\udc4d",
              "createdAt": "2020-04-02T19:07:32Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -16,18 +16,15 @@ namespace Microsoft.Build.BackEnd\n     /// </summary>\n     internal static class ItemGroupLoggingHelper\n     {\n-        /// <summary>\n-        /// Gets a text serialized value of a parameter for logging.\n-        /// </summary>\n-        internal static string GetParameterText(string prefix, string parameterName, params object[] parameterValues)\n-        {\n-            return GetParameterText(prefix, parameterName, (IList)parameterValues);\n-        }\n+        internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString(\"ItemGroupIncludeLogMessagePrefix\");",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "At first, I thought this would allocate a new string for the `=` each time, but I see now it's a character, so that shouldn't be a problem.",
              "createdAt": "2020-04-01T22:03:33Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -56,7 +53,8 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n                     sb.Append(\"\\n    \");\n                 }\n \n-                sb.Append(parameterName + \"=\");\n+                sb.Append(parameterName);\n+                sb.Append('=');",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "String literals that are compile-time constants are stored in the Strings metadata heap and don't need to be allocated.",
              "createdAt": "2020-04-01T22:37:46Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -56,7 +53,8 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n                     sb.Append(\"\\n    \");\n                 }\n \n-                sb.Append(parameterName + \"=\");\n+                sb.Append(parameterName);\n+                sb.Append('=');",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "There's not a way to ensure `count` capacity in the already-allocated case, right? Because setting `Capacity` could result in reallocating to smaller, which isn't what we want.",
              "createdAt": "2020-04-01T22:07:52Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -95,53 +101,76 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n         /// </summary>\n         internal static string GetStringFromParameterValue(object parameterValue)\n         {\n-            var type = parameterValue.GetType();\n-\n-            ErrorUtilities.VerifyThrow(!type.IsArray, \"scalars only\");\n-\n-            if (type == typeof(string))\n+            using (var sb = new ReuseableStringBuilder())\n             {\n-                return (string)parameterValue;\n+                AppendStringFromParameterValue(sb, parameterValue);\n+                return sb.ToString();\n             }\n-            else if (type.GetTypeInfo().IsValueType)\n+        }\n+\n+        // Avoid allocating a temporary list to hold metadata for sorting every time.\n+        // Each thread gets its own copy.\n+        [ThreadStatic]\n+        private static List<KeyValuePair<string, string>> keyValuePairList;\n+\n+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue)\n+        {\n+            if (parameterValue is string text)\n             {\n-                return (string)Convert.ChangeType(parameterValue, typeof(string), CultureInfo.CurrentCulture);\n+                sb.Append(text);\n             }\n-            else if (typeof(ITaskItem).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))\n+            else if (parameterValue is ITaskItem item)\n             {\n-                var item = ((ITaskItem)parameterValue);\n-                string result = item.ItemSpec;\n+                sb.Append(item.ItemSpec);\n \n                 var customMetadata = item.CloneCustomMetadata();\n+                int count = customMetadata.Count;\n \n-                if (customMetadata.Count > 0)\n+                if (count > 0)\n                 {\n-                    result += \"\\n\";\n-                    var names = new List<string>();\n+                    sb.Append('\\n');\n \n-                    foreach (string name in customMetadata.Keys)\n+                    // need to initialize the thread static on each new thread\n+                    if (keyValuePairList == null)\n                     {\n-                        names.Add(name);\n+                        keyValuePairList = new List<KeyValuePair<string, string>>(count);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This list will always grow and never shrink. So once it grows to a sufficient size it stops rejiggering altogether. Clear() at the end keeps the Capacity unchanged.",
              "createdAt": "2020-04-01T22:32:26Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -95,53 +101,76 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n         /// </summary>\n         internal static string GetStringFromParameterValue(object parameterValue)\n         {\n-            var type = parameterValue.GetType();\n-\n-            ErrorUtilities.VerifyThrow(!type.IsArray, \"scalars only\");\n-\n-            if (type == typeof(string))\n+            using (var sb = new ReuseableStringBuilder())\n             {\n-                return (string)parameterValue;\n+                AppendStringFromParameterValue(sb, parameterValue);\n+                return sb.ToString();\n             }\n-            else if (type.GetTypeInfo().IsValueType)\n+        }\n+\n+        // Avoid allocating a temporary list to hold metadata for sorting every time.\n+        // Each thread gets its own copy.\n+        [ThreadStatic]\n+        private static List<KeyValuePair<string, string>> keyValuePairList;\n+\n+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue)\n+        {\n+            if (parameterValue is string text)\n             {\n-                return (string)Convert.ChangeType(parameterValue, typeof(string), CultureInfo.CurrentCulture);\n+                sb.Append(text);\n             }\n-            else if (typeof(ITaskItem).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))\n+            else if (parameterValue is ITaskItem item)\n             {\n-                var item = ((ITaskItem)parameterValue);\n-                string result = item.ItemSpec;\n+                sb.Append(item.ItemSpec);\n \n                 var customMetadata = item.CloneCustomMetadata();\n+                int count = customMetadata.Count;\n \n-                if (customMetadata.Count > 0)\n+                if (count > 0)\n                 {\n-                    result += \"\\n\";\n-                    var names = new List<string>();\n+                    sb.Append('\\n');\n \n-                    foreach (string name in customMetadata.Keys)\n+                    // need to initialize the thread static on each new thread\n+                    if (keyValuePairList == null)\n                     {\n-                        names.Add(name);\n+                        keyValuePairList = new List<KeyValuePair<string, string>>(count);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "There's an EnsureCapacity() on List<T> which is exactly what we want, but it's internal. No biggie, I think it will only resize the first few times and that's it.",
              "createdAt": "2020-04-01T22:34:11Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -95,53 +101,76 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n         /// </summary>\n         internal static string GetStringFromParameterValue(object parameterValue)\n         {\n-            var type = parameterValue.GetType();\n-\n-            ErrorUtilities.VerifyThrow(!type.IsArray, \"scalars only\");\n-\n-            if (type == typeof(string))\n+            using (var sb = new ReuseableStringBuilder())\n             {\n-                return (string)parameterValue;\n+                AppendStringFromParameterValue(sb, parameterValue);\n+                return sb.ToString();\n             }\n-            else if (type.GetTypeInfo().IsValueType)\n+        }\n+\n+        // Avoid allocating a temporary list to hold metadata for sorting every time.\n+        // Each thread gets its own copy.\n+        [ThreadStatic]\n+        private static List<KeyValuePair<string, string>> keyValuePairList;\n+\n+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue)\n+        {\n+            if (parameterValue is string text)\n             {\n-                return (string)Convert.ChangeType(parameterValue, typeof(string), CultureInfo.CurrentCulture);\n+                sb.Append(text);\n             }\n-            else if (typeof(ITaskItem).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))\n+            else if (parameterValue is ITaskItem item)\n             {\n-                var item = ((ITaskItem)parameterValue);\n-                string result = item.ItemSpec;\n+                sb.Append(item.ItemSpec);\n \n                 var customMetadata = item.CloneCustomMetadata();\n+                int count = customMetadata.Count;\n \n-                if (customMetadata.Count > 0)\n+                if (count > 0)\n                 {\n-                    result += \"\\n\";\n-                    var names = new List<string>();\n+                    sb.Append('\\n');\n \n-                    foreach (string name in customMetadata.Keys)\n+                    // need to initialize the thread static on each new thread\n+                    if (keyValuePairList == null)\n                     {\n-                        names.Add(name);\n+                        keyValuePairList = new List<KeyValuePair<string, string>>(count);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Actually we could do if (Capacity < count) Capacity = count; but I'd rather rely on List's internal doubling algorithm.",
              "createdAt": "2020-04-01T22:35:16Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -95,53 +101,76 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n         /// </summary>\n         internal static string GetStringFromParameterValue(object parameterValue)\n         {\n-            var type = parameterValue.GetType();\n-\n-            ErrorUtilities.VerifyThrow(!type.IsArray, \"scalars only\");\n-\n-            if (type == typeof(string))\n+            using (var sb = new ReuseableStringBuilder())\n             {\n-                return (string)parameterValue;\n+                AppendStringFromParameterValue(sb, parameterValue);\n+                return sb.ToString();\n             }\n-            else if (type.GetTypeInfo().IsValueType)\n+        }\n+\n+        // Avoid allocating a temporary list to hold metadata for sorting every time.\n+        // Each thread gets its own copy.\n+        [ThreadStatic]\n+        private static List<KeyValuePair<string, string>> keyValuePairList;\n+\n+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue)\n+        {\n+            if (parameterValue is string text)\n             {\n-                return (string)Convert.ChangeType(parameterValue, typeof(string), CultureInfo.CurrentCulture);\n+                sb.Append(text);\n             }\n-            else if (typeof(ITaskItem).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))\n+            else if (parameterValue is ITaskItem item)\n             {\n-                var item = ((ITaskItem)parameterValue);\n-                string result = item.ItemSpec;\n+                sb.Append(item.ItemSpec);\n \n                 var customMetadata = item.CloneCustomMetadata();\n+                int count = customMetadata.Count;\n \n-                if (customMetadata.Count > 0)\n+                if (count > 0)\n                 {\n-                    result += \"\\n\";\n-                    var names = new List<string>();\n+                    sb.Append('\\n');\n \n-                    foreach (string name in customMetadata.Keys)\n+                    // need to initialize the thread static on each new thread\n+                    if (keyValuePairList == null)\n                     {\n-                        names.Add(name);\n+                        keyValuePairList = new List<KeyValuePair<string, string>>(count);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Just for clarity, since this is under `if (keyValuePairList == null)`, it will only look at count once per thread, so it will resize beyond when one gets to maximum capacity, but it shouldn't get smaller.",
              "createdAt": "2020-04-01T22:36:43Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -95,53 +101,76 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n         /// </summary>\n         internal static string GetStringFromParameterValue(object parameterValue)\n         {\n-            var type = parameterValue.GetType();\n-\n-            ErrorUtilities.VerifyThrow(!type.IsArray, \"scalars only\");\n-\n-            if (type == typeof(string))\n+            using (var sb = new ReuseableStringBuilder())\n             {\n-                return (string)parameterValue;\n+                AppendStringFromParameterValue(sb, parameterValue);\n+                return sb.ToString();\n             }\n-            else if (type.GetTypeInfo().IsValueType)\n+        }\n+\n+        // Avoid allocating a temporary list to hold metadata for sorting every time.\n+        // Each thread gets its own copy.\n+        [ThreadStatic]\n+        private static List<KeyValuePair<string, string>> keyValuePairList;\n+\n+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue)\n+        {\n+            if (parameterValue is string text)\n             {\n-                return (string)Convert.ChangeType(parameterValue, typeof(string), CultureInfo.CurrentCulture);\n+                sb.Append(text);\n             }\n-            else if (typeof(ITaskItem).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))\n+            else if (parameterValue is ITaskItem item)\n             {\n-                var item = ((ITaskItem)parameterValue);\n-                string result = item.ItemSpec;\n+                sb.Append(item.ItemSpec);\n \n                 var customMetadata = item.CloneCustomMetadata();\n+                int count = customMetadata.Count;\n \n-                if (customMetadata.Count > 0)\n+                if (count > 0)\n                 {\n-                    result += \"\\n\";\n-                    var names = new List<string>();\n+                    sb.Append('\\n');\n \n-                    foreach (string name in customMetadata.Keys)\n+                    // need to initialize the thread static on each new thread\n+                    if (keyValuePairList == null)\n                     {\n-                        names.Add(name);\n+                        keyValuePairList = new List<KeyValuePair<string, string>>(count);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we need to clone the metadata or can we just access it?",
              "createdAt": "2020-04-01T22:14:36Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -93,55 +91,92 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n         /// First line is already indented.\n         /// Indent of any subsequent line should be 12 spaces.\n         /// </summary>\n-        internal static string GetStringFromParameterValue(object parameterValue)\n+        internal static string GetStringFromParameterValue(object parameterValue, bool includeMetadata = false)\n         {\n-            var type = parameterValue.GetType();\n-\n-            ErrorUtilities.VerifyThrow(!type.IsArray, \"scalars only\");\n-\n-            if (type == typeof(string))\n+            using (var sb = new ReuseableStringBuilder())\n             {\n-                return (string)parameterValue;\n+                AppendStringFromParameterValue(sb, parameterValue, includeMetadata);\n+                return sb.ToString();\n             }\n-            else if (type.GetTypeInfo().IsValueType)\n+        }\n+\n+        // Avoid allocating a temporary list to hold metadata for sorting every time.\n+        // Each thread gets its own copy.\n+        [ThreadStatic]\n+        private static List<KeyValuePair<string, string>> keyValuePairList;\n+\n+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue, bool includeMetadata = false)\n+        {\n+            if (parameterValue is string text)\n             {\n-                return (string)Convert.ChangeType(parameterValue, typeof(string), CultureInfo.CurrentCulture);\n+                sb.Append(text);\n             }\n-            else if (typeof(ITaskItem).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))\n+            else if (parameterValue is ITaskItem item)\n             {\n-                var item = ((ITaskItem)parameterValue);\n-                string result = item.ItemSpec;\n-\n-                var customMetadata = item.CloneCustomMetadata();\n+                sb.Append(item.ItemSpec);\n \n-                if (customMetadata.Count > 0)\n+                if (includeMetadata)\n                 {\n-                    result += \"\\n\";\n-                    var names = new List<string>();\n+                    var customMetadata = item.CloneCustomMetadata();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The original code had CloneCustomMetadata() and I think it's the blessed way to retrieve a thread-safe read-only snapshot of custom metadata only.",
              "createdAt": "2020-04-01T22:38:45Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -93,55 +91,92 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n         /// First line is already indented.\n         /// Indent of any subsequent line should be 12 spaces.\n         /// </summary>\n-        internal static string GetStringFromParameterValue(object parameterValue)\n+        internal static string GetStringFromParameterValue(object parameterValue, bool includeMetadata = false)\n         {\n-            var type = parameterValue.GetType();\n-\n-            ErrorUtilities.VerifyThrow(!type.IsArray, \"scalars only\");\n-\n-            if (type == typeof(string))\n+            using (var sb = new ReuseableStringBuilder())\n             {\n-                return (string)parameterValue;\n+                AppendStringFromParameterValue(sb, parameterValue, includeMetadata);\n+                return sb.ToString();\n             }\n-            else if (type.GetTypeInfo().IsValueType)\n+        }\n+\n+        // Avoid allocating a temporary list to hold metadata for sorting every time.\n+        // Each thread gets its own copy.\n+        [ThreadStatic]\n+        private static List<KeyValuePair<string, string>> keyValuePairList;\n+\n+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue, bool includeMetadata = false)\n+        {\n+            if (parameterValue is string text)\n             {\n-                return (string)Convert.ChangeType(parameterValue, typeof(string), CultureInfo.CurrentCulture);\n+                sb.Append(text);\n             }\n-            else if (typeof(ITaskItem).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))\n+            else if (parameterValue is ITaskItem item)\n             {\n-                var item = ((ITaskItem)parameterValue);\n-                string result = item.ItemSpec;\n-\n-                var customMetadata = item.CloneCustomMetadata();\n+                sb.Append(item.ItemSpec);\n \n-                if (customMetadata.Count > 0)\n+                if (includeMetadata)\n                 {\n-                    result += \"\\n\";\n-                    var names = new List<string>();\n+                    var customMetadata = item.CloneCustomMetadata();",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "After we've reached this point, the custom metadata won't change, right? In which case, since we're also not modifying it, does it need to be thread-safe or read-only?",
              "createdAt": "2020-04-01T23:10:28Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -93,55 +91,92 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n         /// First line is already indented.\n         /// Indent of any subsequent line should be 12 spaces.\n         /// </summary>\n-        internal static string GetStringFromParameterValue(object parameterValue)\n+        internal static string GetStringFromParameterValue(object parameterValue, bool includeMetadata = false)\n         {\n-            var type = parameterValue.GetType();\n-\n-            ErrorUtilities.VerifyThrow(!type.IsArray, \"scalars only\");\n-\n-            if (type == typeof(string))\n+            using (var sb = new ReuseableStringBuilder())\n             {\n-                return (string)parameterValue;\n+                AppendStringFromParameterValue(sb, parameterValue, includeMetadata);\n+                return sb.ToString();\n             }\n-            else if (type.GetTypeInfo().IsValueType)\n+        }\n+\n+        // Avoid allocating a temporary list to hold metadata for sorting every time.\n+        // Each thread gets its own copy.\n+        [ThreadStatic]\n+        private static List<KeyValuePair<string, string>> keyValuePairList;\n+\n+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue, bool includeMetadata = false)\n+        {\n+            if (parameterValue is string text)\n             {\n-                return (string)Convert.ChangeType(parameterValue, typeof(string), CultureInfo.CurrentCulture);\n+                sb.Append(text);\n             }\n-            else if (typeof(ITaskItem).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))\n+            else if (parameterValue is ITaskItem item)\n             {\n-                var item = ((ITaskItem)parameterValue);\n-                string result = item.ItemSpec;\n-\n-                var customMetadata = item.CloneCustomMetadata();\n+                sb.Append(item.ItemSpec);\n \n-                if (customMetadata.Count > 0)\n+                if (includeMetadata)\n                 {\n-                    result += \"\\n\";\n-                    var names = new List<string>();\n+                    var customMetadata = item.CloneCustomMetadata();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can this string be allocated outside the function so we don't allocate it multiple times?",
              "createdAt": "2020-04-01T22:18:53Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -93,55 +91,92 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n         /// First line is already indented.\n         /// Indent of any subsequent line should be 12 spaces.\n         /// </summary>\n-        internal static string GetStringFromParameterValue(object parameterValue)\n+        internal static string GetStringFromParameterValue(object parameterValue, bool includeMetadata = false)\n         {\n-            var type = parameterValue.GetType();\n-\n-            ErrorUtilities.VerifyThrow(!type.IsArray, \"scalars only\");\n-\n-            if (type == typeof(string))\n+            using (var sb = new ReuseableStringBuilder())\n             {\n-                return (string)parameterValue;\n+                AppendStringFromParameterValue(sb, parameterValue, includeMetadata);\n+                return sb.ToString();\n             }\n-            else if (type.GetTypeInfo().IsValueType)\n+        }\n+\n+        // Avoid allocating a temporary list to hold metadata for sorting every time.\n+        // Each thread gets its own copy.\n+        [ThreadStatic]\n+        private static List<KeyValuePair<string, string>> keyValuePairList;\n+\n+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue, bool includeMetadata = false)\n+        {\n+            if (parameterValue is string text)\n             {\n-                return (string)Convert.ChangeType(parameterValue, typeof(string), CultureInfo.CurrentCulture);\n+                sb.Append(text);\n             }\n-            else if (typeof(ITaskItem).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))\n+            else if (parameterValue is ITaskItem item)\n             {\n-                var item = ((ITaskItem)parameterValue);\n-                string result = item.ItemSpec;\n-\n-                var customMetadata = item.CloneCustomMetadata();\n+                sb.Append(item.ItemSpec);\n \n-                if (customMetadata.Count > 0)\n+                if (includeMetadata)\n                 {\n-                    result += \"\\n\";\n-                    var names = new List<string>();\n+                    var customMetadata = item.CloneCustomMetadata();\n+                    int count = customMetadata.Count;\n \n-                    foreach (string name in customMetadata.Keys)\n+                    if (count > 0)\n                     {\n-                        names.Add(name);\n-                    }\n+                        sb.Append('\\n');\n+\n+                        // need to initialize the thread static on each new thread\n+                        if (keyValuePairList == null)\n+                        {\n+                            keyValuePairList = new List<KeyValuePair<string, string>>(count);\n+                        }\n \n-                    names.Sort();\n+                        var customMetadataDictionary = customMetadata as IDictionary<string, string>;\n+                        if (customMetadataDictionary != null)\n+                        {\n+                            foreach (KeyValuePair<string, string> kvp in customMetadataDictionary)\n+                            {\n+                                keyValuePairList.Add(kvp);\n+                            }\n+                        }\n+                        else\n+                        {\n+                            foreach (DictionaryEntry kvp in customMetadata)\n+                            {\n+                                keyValuePairList.Add(new KeyValuePair<string, string>((string)kvp.Key, (string)kvp.Value));\n+                            }\n+                        }\n \n-                    for (int i = 0; i < names.Count; i++)\n-                    {\n-                        result += \"                \" + names[i] + \"=\" + customMetadata[names[i]];\n+                        if (count > 1)\n+                        {\n+                            keyValuePairList.Sort((l, r) => StringComparer.OrdinalIgnoreCase.Compare(l.Key, r.Key));\n+                        }\n \n-                        if (i < names.Count - 1)\n+                        for (int i = 0; i < count; i++)\n                         {\n-                            result += \"\\n\";\n+                            var kvp = keyValuePairList[i];\n+                            sb.Append(\"                \");",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "These aren't allocated. It's just `ldstr` which gets you a pointer to the Strings metadata heap cheaply: https://sharplab.io/#v2:EYLgZgpghgLgrgJwgZwLRIMaOQSwG4SoAOsMECAdsgDQwg4A2APgAIBMAjALABQLAzAAJ2ggMKCA3r0EzhQlgBZBAWQAUASknTZOlhwCcqgERgA9qaPqA3NpkBfXnaA=",
              "createdAt": "2020-04-01T22:40:09Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs",
              "diffHunk": "@@ -93,55 +91,92 @@ internal static string GetParameterText(string prefix, string parameterName, ILi\n         /// First line is already indented.\n         /// Indent of any subsequent line should be 12 spaces.\n         /// </summary>\n-        internal static string GetStringFromParameterValue(object parameterValue)\n+        internal static string GetStringFromParameterValue(object parameterValue, bool includeMetadata = false)\n         {\n-            var type = parameterValue.GetType();\n-\n-            ErrorUtilities.VerifyThrow(!type.IsArray, \"scalars only\");\n-\n-            if (type == typeof(string))\n+            using (var sb = new ReuseableStringBuilder())\n             {\n-                return (string)parameterValue;\n+                AppendStringFromParameterValue(sb, parameterValue, includeMetadata);\n+                return sb.ToString();\n             }\n-            else if (type.GetTypeInfo().IsValueType)\n+        }\n+\n+        // Avoid allocating a temporary list to hold metadata for sorting every time.\n+        // Each thread gets its own copy.\n+        [ThreadStatic]\n+        private static List<KeyValuePair<string, string>> keyValuePairList;\n+\n+        private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue, bool includeMetadata = false)\n+        {\n+            if (parameterValue is string text)\n             {\n-                return (string)Convert.ChangeType(parameterValue, typeof(string), CultureInfo.CurrentCulture);\n+                sb.Append(text);\n             }\n-            else if (typeof(ITaskItem).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))\n+            else if (parameterValue is ITaskItem item)\n             {\n-                var item = ((ITaskItem)parameterValue);\n-                string result = item.ItemSpec;\n-\n-                var customMetadata = item.CloneCustomMetadata();\n+                sb.Append(item.ItemSpec);\n \n-                if (customMetadata.Count > 0)\n+                if (includeMetadata)\n                 {\n-                    result += \"\\n\";\n-                    var names = new List<string>();\n+                    var customMetadata = item.CloneCustomMetadata();\n+                    int count = customMetadata.Count;\n \n-                    foreach (string name in customMetadata.Keys)\n+                    if (count > 0)\n                     {\n-                        names.Add(name);\n-                    }\n+                        sb.Append('\\n');\n+\n+                        // need to initialize the thread static on each new thread\n+                        if (keyValuePairList == null)\n+                        {\n+                            keyValuePairList = new List<KeyValuePair<string, string>>(count);\n+                        }\n \n-                    names.Sort();\n+                        var customMetadataDictionary = customMetadata as IDictionary<string, string>;\n+                        if (customMetadataDictionary != null)\n+                        {\n+                            foreach (KeyValuePair<string, string> kvp in customMetadataDictionary)\n+                            {\n+                                keyValuePairList.Add(kvp);\n+                            }\n+                        }\n+                        else\n+                        {\n+                            foreach (DictionaryEntry kvp in customMetadata)\n+                            {\n+                                keyValuePairList.Add(new KeyValuePair<string, string>((string)kvp.Key, (string)kvp.Value));\n+                            }\n+                        }\n \n-                    for (int i = 0; i < names.Count; i++)\n-                    {\n-                        result += \"                \" + names[i] + \"=\" + customMetadata[names[i]];\n+                        if (count > 1)\n+                        {\n+                            keyValuePairList.Sort((l, r) => StringComparer.OrdinalIgnoreCase.Compare(l.Key, r.Key));\n+                        }\n \n-                        if (i < names.Count - 1)\n+                        for (int i = 0; i < count; i++)\n                         {\n-                            result += \"\\n\";\n+                            var kvp = keyValuePairList[i];\n+                            sb.Append(\"                \");",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      }
    ]
  }
}