{
  "number": 6324,
  "title": "Remove BinaryFormatter from GetSDKReferenceFiles",
  "body": "I think this is almost right, but TranslatorHelpers needs System.Collections.Concurrent on .NET 3.5, or I need to be able to translate a concurrent dictionary without translating it. (?) Any idea on how I can get around that?\r\n",
  "state": "MERGED",
  "createdAt": "2021-04-03T00:05:25Z",
  "updatedAt": "2021-05-24T21:52:54Z",
  "closedAt": "2021-05-24T21:52:53Z",
  "mergedAt": "2021-05-24T21:52:53Z",
  "additions": 95,
  "deletions": 79,
  "changedFiles": 2,
  "headRefName": "remove-binaryformatter-from-state-files",
  "isDraft": false,
  "author": {
    "login": "Forgind"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "be6f54e140d9513a7cf4b4cf77c9be63f5c7dca6",
          "message": "Remove BF from GetSDKReferenceFiles",
          "committedDate": "2021-04-03T00:03:53Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e68602d6306a9f23c20edb3b6665e961eb6d958a",
          "message": "Private method for translating dictionaries",
          "committedDate": "2021-04-05T19:03:19Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "108c4c851f0360cb7d98e0049a229953e0860f85",
          "message": "Translate count",
          "committedDate": "2021-04-05T21:15:07Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d090c3c6233939374e27a73111f5ff9b0d675edf",
          "message": "Add test and fix bugs",
          "committedDate": "2021-04-09T16:42:14Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aae31331b3f026df4e1480a98ab38351cd545286",
          "message": "Fix capitalization error",
          "committedDate": "2021-04-09T17:29:50Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "855038d277160f0e1a0b88bfe3048be13404c1ef",
          "message": "PR feedback",
          "committedDate": "2021-04-09T21:40:45Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "46f4731995d95bcf425abc5d8f82cadf9efab10c",
          "message": "PR feedback",
          "committedDate": "2021-04-12T14:45:04Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0d1e72354955e9871abc0138559679e1c800c2c4",
          "message": "Switch to non-concurrent dictionary",
          "committedDate": "2021-04-12T18:53:19Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "11e3f9bc2e2e556ae5e65809eef03fe37dc03ce9",
          "message": "ignore case",
          "committedDate": "2021-04-13T18:35:22Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "47e2a3f54b469109935637874e530cb34405e67b",
          "message": "Optimize dictionary passing",
          "committedDate": "2021-04-28T00:04:37Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "be38506d1c77b2e90080824725aa0ffd2308e50c",
          "message": "Ignore case part 2",
          "committedDate": "2021-05-09T03:34:54Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ee7cf13b182240aee5f0b767129f955acff9d732",
          "message": "Remove extraneous dictionary translation",
          "committedDate": "2021-05-14T19:26:49Z",
          "author": {
            "name": "Nathan Mytelka",
            "email": "Forgind@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I would hardcode the translation logic for each type T that we need, and just write the count of key-value pairs, followed by each key and value separately.",
        "createdAt": "2021-04-04T01:29:07Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Can you explain why we need the counts? I haven't looked at how complete our test coverage of this task was, but it seems to pass whatever tests we previously had without it.",
        "createdAt": "2021-04-05T19:03:50Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I might be not understanding it well, but how are you going to read the keys and values if you don\u2019t know how many there are?",
        "createdAt": "2021-04-05T20:11:57Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Looks like the answer is: there weren't tests. Makes it easy to pass them \ud83d\ude0b\r\n\r\nI was imagining something like looking for closing elements. In json, for instance, they have { \"key1\": \"val1\", \"key2\": \"val2\" }. You don't need a count because the opening and closing braces match. I don't know if there's an equivalent here, but I now think it just takes references and gets or sets them based on what sort of data you ask for, so since the dictionary would have started out full in serializing, it would serialize properly. Then, in deserialization, the dictionary would be _null_, and it would throw an exception. If I'd initialized the dictionary, it would still be empty and remain so. I added a count. I should probably add tests.",
        "createdAt": "2021-04-05T21:20:22Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "While you're getting rid of useless summaries, might as well delete this one.",
              "createdAt": "2021-04-09T21:01:54Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1205,7 +1194,7 @@ private static IEnumerable<string> GetAllReferenceDirectories(string sdkRoot)\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n         [Serializable]\n-        private class SdkReferenceInfo\n+        internal class SdkReferenceInfo\n         {\n             /// <summary>\n             /// Constructor",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: remove useless summary",
              "createdAt": "2021-04-09T21:03:59Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1221,105 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n             /// <summary>\n             /// Constructor\n             /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            internal ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n             /// <summary>\n             /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n             /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "This has the bonus of deleting a summary that isn't actually accurate. Turns out if a mapping isn't in the dictionary, it doesn't look for it; it just assumes it isn't there.",
              "createdAt": "2021-04-09T21:36:23Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1221,105 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n             /// <summary>\n             /// Constructor\n             /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            internal ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n             /// <summary>\n             /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n             /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: remove useless summary",
              "createdAt": "2021-04-09T21:04:09Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1221,105 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n             /// <summary>\n             /// Constructor",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is this changed from public to internal, but other properties untouched?",
              "createdAt": "2021-04-09T21:07:00Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1221,105 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n             /// <summary>\n             /// Constructor\n             /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            internal ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I don't think this actually mattered, so I reverted it. See next comment for fiddling.",
              "createdAt": "2021-04-09T21:37:32Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1221,105 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n             /// <summary>\n             /// Constructor\n             /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            internal ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why did this need to change?",
              "createdAt": "2021-04-09T21:25:05Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1221,105 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n             /// <summary>\n             /// Constructor\n             /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            internal ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n             /// <summary>\n             /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n             /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                TranslateConcurrentDictionary<SdkReferenceInfo>(translator, ref pathToReferenceMetadata, (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                });\n \n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                TranslateConcurrentDictionary<List<string>>(translator, ref directoryToFileList, (ITranslator t, ref List<string> fileList) =>\n+                {\n+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });\n+                });\n+\n+                translator.Translate(ref hash);\n+            }\n+        }\n \n-                    return info;\n+        private static void TranslateConcurrentDictionary<T>(ITranslator translator, ref ConcurrentDictionary<string, T> dictionary, ObjectTranslator<T> objTranslator)\n+        {\n+            int count = dictionary.Count;\n+            translator.Translate(ref count);\n+            string[] keys = dictionary.Keys.ToArray();\n+            for (int i = 0; i < count; i++)\n+            {\n+                if (i < keys.Length)\n+                {\n+                    translator.Translate(ref keys[i]);\n+                    T value = dictionary[keys[i]];\n+                    objTranslator(translator, ref value);\n                 }\n+                else\n+                {\n+                    string key = null;\n+                    translator.Translate(ref key);\n+                    T value = default;\n+                    objTranslator(translator, ref value);\n+                    dictionary[key] = value;\n+                }                \n             }\n         }\n \n         /// <summary>\n         /// This class represents the context information used by the background cache serialization thread.\n         /// </summary>\n-        private class SaveContext\n+        internal class SaveContext",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I had to fiddle with a lot of these to make them accessible to the test class. Then I downgraded a couple because properties were more visible than their containing class, which isn't really good style, but the latter wasn't necessary. As long as something prevents it from being public/protected, I don't think it particularly matters.",
              "createdAt": "2021-04-09T21:38:54Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1221,105 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n             /// <summary>\n             /// Constructor\n             /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            internal ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n             /// <summary>\n             /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n             /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                TranslateConcurrentDictionary<SdkReferenceInfo>(translator, ref pathToReferenceMetadata, (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                });\n \n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                TranslateConcurrentDictionary<List<string>>(translator, ref directoryToFileList, (ITranslator t, ref List<string> fileList) =>\n+                {\n+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });\n+                });\n+\n+                translator.Translate(ref hash);\n+            }\n+        }\n \n-                    return info;\n+        private static void TranslateConcurrentDictionary<T>(ITranslator translator, ref ConcurrentDictionary<string, T> dictionary, ObjectTranslator<T> objTranslator)\n+        {\n+            int count = dictionary.Count;\n+            translator.Translate(ref count);\n+            string[] keys = dictionary.Keys.ToArray();\n+            for (int i = 0; i < count; i++)\n+            {\n+                if (i < keys.Length)\n+                {\n+                    translator.Translate(ref keys[i]);\n+                    T value = dictionary[keys[i]];\n+                    objTranslator(translator, ref value);\n                 }\n+                else\n+                {\n+                    string key = null;\n+                    translator.Translate(ref key);\n+                    T value = default;\n+                    objTranslator(translator, ref value);\n+                    dictionary[key] = value;\n+                }                \n             }\n         }\n \n         /// <summary>\n         /// This class represents the context information used by the background cache serialization thread.\n         /// </summary>\n-        private class SaveContext\n+        internal class SaveContext",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Ah, I hadn't reviewed the test so I didn't see _any_ need for it.",
              "createdAt": "2021-04-09T21:42:04Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1221,105 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n             /// <summary>\n             /// Constructor\n             /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            internal ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n             /// <summary>\n             /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n             /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                TranslateConcurrentDictionary<SdkReferenceInfo>(translator, ref pathToReferenceMetadata, (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                });\n \n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                TranslateConcurrentDictionary<List<string>>(translator, ref directoryToFileList, (ITranslator t, ref List<string> fileList) =>\n+                {\n+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });\n+                });\n+\n+                translator.Translate(ref hash);\n+            }\n+        }\n \n-                    return info;\n+        private static void TranslateConcurrentDictionary<T>(ITranslator translator, ref ConcurrentDictionary<string, T> dictionary, ObjectTranslator<T> objTranslator)\n+        {\n+            int count = dictionary.Count;\n+            translator.Translate(ref count);\n+            string[] keys = dictionary.Keys.ToArray();\n+            for (int i = 0; i < count; i++)\n+            {\n+                if (i < keys.Length)\n+                {\n+                    translator.Translate(ref keys[i]);\n+                    T value = dictionary[keys[i]];\n+                    objTranslator(translator, ref value);\n                 }\n+                else\n+                {\n+                    string key = null;\n+                    translator.Translate(ref key);\n+                    T value = default;\n+                    objTranslator(translator, ref value);\n+                    dictionary[key] = value;\n+                }                \n             }\n         }\n \n         /// <summary>\n         /// This class represents the context information used by the background cache serialization thread.\n         /// </summary>\n-        private class SaveContext\n+        internal class SaveContext",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If i < keys.Length once, it won't ever change right? For better at-a-glance-understanding\u2122, I'd suggest creating some `bool translatingOut = i < keys.Length` and using that bool. Or place a comment.",
              "createdAt": "2021-04-09T21:25:06Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1221,105 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n             /// <summary>\n             /// Constructor\n             /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            internal ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n             /// <summary>\n             /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n             /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                TranslateConcurrentDictionary<SdkReferenceInfo>(translator, ref pathToReferenceMetadata, (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                });\n \n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                TranslateConcurrentDictionary<List<string>>(translator, ref directoryToFileList, (ITranslator t, ref List<string> fileList) =>\n+                {\n+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });\n+                });\n+\n+                translator.Translate(ref hash);\n+            }\n+        }\n \n-                    return info;\n+        private static void TranslateConcurrentDictionary<T>(ITranslator translator, ref ConcurrentDictionary<string, T> dictionary, ObjectTranslator<T> objTranslator)\n+        {\n+            int count = dictionary.Count;\n+            translator.Translate(ref count);\n+            string[] keys = dictionary.Keys.ToArray();\n+            for (int i = 0; i < count; i++)\n+            {\n+                if (i < keys.Length)",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "True. I put the if statement first, which should technically be more performant, too, though not in a particularly meaningful way.",
              "createdAt": "2021-04-09T21:41:49Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1221,105 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n             /// <summary>\n             /// Constructor\n             /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            internal ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n             /// <summary>\n             /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n             /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                TranslateConcurrentDictionary<SdkReferenceInfo>(translator, ref pathToReferenceMetadata, (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                });\n \n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                TranslateConcurrentDictionary<List<string>>(translator, ref directoryToFileList, (ITranslator t, ref List<string> fileList) =>\n+                {\n+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });\n+                });\n+\n+                translator.Translate(ref hash);\n+            }\n+        }\n \n-                    return info;\n+        private static void TranslateConcurrentDictionary<T>(ITranslator translator, ref ConcurrentDictionary<string, T> dictionary, ObjectTranslator<T> objTranslator)\n+        {\n+            int count = dictionary.Count;\n+            translator.Translate(ref count);\n+            string[] keys = dictionary.Keys.ToArray();\n+            for (int i = 0; i < count; i++)\n+            {\n+                if (i < keys.Length)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can the dictionary change while the loop runs? If a value is removed, this may throw. Do you need to lock? Also perhaps its better to enumerate key value pairs to avoid looking every key up.",
              "createdAt": "2021-04-09T22:40:43Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1218,102 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n-            /// <summary>\n-            /// Constructor\n-            /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n-            /// <summary>\n-            /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n-            /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                TranslateConcurrentDictionary<SdkReferenceInfo>(translator, ref pathToReferenceMetadata, (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                });\n \n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                TranslateConcurrentDictionary<List<string>>(translator, ref directoryToFileList, (ITranslator t, ref List<string> fileList) =>\n+                {\n+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });\n+                });\n \n-                    return info;\n+                translator.Translate(ref hash);\n+            }\n+        }\n+\n+        private static void TranslateConcurrentDictionary<T>(ITranslator translator, ref ConcurrentDictionary<string, T> dictionary, ObjectTranslator<T> objTranslator)\n+        {\n+            int count = dictionary.Count;\n+            translator.Translate(ref count);\n+            string[] keys = dictionary.Keys.ToArray();\n+            if (keys.Length == 0)\n+            {\n+                for (int i = 0; i < count; i++)\n+                {\n+                    string key = null;\n+                    translator.Translate(ref key);\n+                    T value = default;\n+                    objTranslator(translator, ref value);\n+                    dictionary[key] = value;\n+                }\n+            }\n+            else\n+            {\n+                for (int i = 0; i < count; i++)\n+                {\n+                    translator.Translate(ref keys[i]);\n+                    T value = dictionary[keys[i]];",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "No\u2014before this PR, there was only the property, and it had a getter but no setter, so it really shouldn't be a ConcurrentDictionary. It's been a ConcurrentDictionary since the initial code commit. Do you want me to change it to an ordinary dictionary?",
              "createdAt": "2021-04-12T14:43:28Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1218,102 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n-            /// <summary>\n-            /// Constructor\n-            /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n-            /// <summary>\n-            /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n-            /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                TranslateConcurrentDictionary<SdkReferenceInfo>(translator, ref pathToReferenceMetadata, (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                });\n \n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                TranslateConcurrentDictionary<List<string>>(translator, ref directoryToFileList, (ITranslator t, ref List<string> fileList) =>\n+                {\n+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });\n+                });\n \n-                    return info;\n+                translator.Translate(ref hash);\n+            }\n+        }\n+\n+        private static void TranslateConcurrentDictionary<T>(ITranslator translator, ref ConcurrentDictionary<string, T> dictionary, ObjectTranslator<T> objTranslator)\n+        {\n+            int count = dictionary.Count;\n+            translator.Translate(ref count);\n+            string[] keys = dictionary.Keys.ToArray();\n+            if (keys.Length == 0)\n+            {\n+                for (int i = 0; i < count; i++)\n+                {\n+                    string key = null;\n+                    translator.Translate(ref key);\n+                    T value = default;\n+                    objTranslator(translator, ref value);\n+                    dictionary[key] = value;\n+                }\n+            }\n+            else\n+            {\n+                for (int i = 0; i < count; i++)\n+                {\n+                    translator.Translate(ref keys[i]);\n+                    T value = dictionary[keys[i]];",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "up to you, if it feels safe",
              "createdAt": "2021-04-12T16:42:18Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1218,102 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n-            /// <summary>\n-            /// Constructor\n-            /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n-            /// <summary>\n-            /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n-            /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                TranslateConcurrentDictionary<SdkReferenceInfo>(translator, ref pathToReferenceMetadata, (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                });\n \n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                TranslateConcurrentDictionary<List<string>>(translator, ref directoryToFileList, (ITranslator t, ref List<string> fileList) =>\n+                {\n+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });\n+                });\n \n-                    return info;\n+                translator.Translate(ref hash);\n+            }\n+        }\n+\n+        private static void TranslateConcurrentDictionary<T>(ITranslator translator, ref ConcurrentDictionary<string, T> dictionary, ObjectTranslator<T> objTranslator)\n+        {\n+            int count = dictionary.Count;\n+            translator.Translate(ref count);\n+            string[] keys = dictionary.Keys.ToArray();\n+            if (keys.Length == 0)\n+            {\n+                for (int i = 0; i < count; i++)\n+                {\n+                    string key = null;\n+                    translator.Translate(ref key);\n+                    T value = default;\n+                    objTranslator(translator, ref value);\n+                    dictionary[key] = value;\n+                }\n+            }\n+            else\n+            {\n+                for (int i = 0; i < count; i++)\n+                {\n+                    translator.Translate(ref keys[i]);\n+                    T value = dictionary[keys[i]];",
              "author": {
                "login": "KirillOsenkov"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "is this effectively determining the translation direction (read/write)? If so, is there a more explicit way, perhaps asking the translator?",
              "createdAt": "2021-04-09T22:41:20Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1218,102 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n-            /// <summary>\n-            /// Constructor\n-            /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n-            /// <summary>\n-            /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n-            /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                TranslateConcurrentDictionary<SdkReferenceInfo>(translator, ref pathToReferenceMetadata, (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                });\n \n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                TranslateConcurrentDictionary<List<string>>(translator, ref directoryToFileList, (ITranslator t, ref List<string> fileList) =>\n+                {\n+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });\n+                });\n \n-                    return info;\n+                translator.Translate(ref hash);\n+            }\n+        }\n+\n+        private static void TranslateConcurrentDictionary<T>(ITranslator translator, ref ConcurrentDictionary<string, T> dictionary, ObjectTranslator<T> objTranslator)\n+        {\n+            int count = dictionary.Count;\n+            translator.Translate(ref count);\n+            string[] keys = dictionary.Keys.ToArray();\n+            if (keys.Length == 0)",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Looks like ITranslator has a `TranslationDirection Mode` we can take advantage of here.",
              "createdAt": "2021-04-09T23:07:24Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1218,102 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private ConcurrentDictionary<string, List<string>> directoryToFileList;\n+            private int hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                pathToReferenceMetadata = new();\n+                directoryToFileList = new();\n+                hash = 0;\n+            }\n+\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n \n-            /// <summary>\n-            /// Constructor\n-            /// </summary>\n             public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this.pathToReferenceMetadata = pathToReferenceMetadata;\n+                this.directoryToFileList = directoryToFileList;\n+                this.hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return pathToReferenceMetadata; } }\n \n-            /// <summary>\n-            /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n-            /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get { return directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                TranslateConcurrentDictionary<SdkReferenceInfo>(translator, ref pathToReferenceMetadata, (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                });\n \n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                TranslateConcurrentDictionary<List<string>>(translator, ref directoryToFileList, (ITranslator t, ref List<string> fileList) =>\n+                {\n+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });\n+                });\n \n-                    return info;\n+                translator.Translate(ref hash);\n+            }\n+        }\n+\n+        private static void TranslateConcurrentDictionary<T>(ITranslator translator, ref ConcurrentDictionary<string, T> dictionary, ObjectTranslator<T> objTranslator)\n+        {\n+            int count = dictionary.Count;\n+            translator.Translate(ref count);\n+            string[] keys = dictionary.Keys.ToArray();\n+            if (keys.Length == 0)",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n```\r\n\r\nStale",
              "createdAt": "2021-04-27T16:15:20Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1218,79 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is there a perf impact of this synchronization? Could you instead store an `IDictionary` in the SDKInfo fields and on creation it's `ConcurrentDictionary`/on deserialization it's a plain dictionary?",
              "createdAt": "2021-04-27T16:22:21Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1023,7 +1012,7 @@ internal SDKInfo GetCacheFileInfoFromSDK(string sdkRootDirectory, string[] sdkMa\n \n                 PopulateRedistDictionaryFromPaths(directoryToFileList, redistDirectories);\n \n-                var cacheInfo = new SDKInfo(references, directoryToFileList, FileUtilities.GetPathsHash(directoriesToHash));\n+                var cacheInfo = new SDKInfo(references.ToDictionary(kvp => kvp.Key, kvp => kvp.Value, StringComparer.OrdinalIgnoreCase), directoryToFileList.ToDictionary(kvp => kvp.Key, kvp => kvp.Value, StringComparer.OrdinalIgnoreCase), FileUtilities.GetPathsHash(directoriesToHash));",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Our/runtime's standard naming convention would make these:\r\n\r\n```suggestion\r\n            private Dictionary<string, SdkReferenceInfo> _pathToReferenceMetadata;\r\n            private Dictionary<string, List<string>> _directoryToFileList;\r\n            private int _hash;\r\n```",
              "createdAt": "2021-04-27T16:23:43Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1246,63 +1218,79 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n         /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private Dictionary<string, SdkReferenceInfo> pathToReferenceMetadata;\n+            private Dictionary<string, List<string>> directoryToFileList;\n+            private int hash;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Funny that the duplicate translation worked because the same method handles input/output. Good thing it's not a huge concern and fairly easy to catch.\r\n\r\nI wonder if a certain type of test would catch this? (not blocking on this thought)",
              "createdAt": "2021-05-14T19:32:09Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1219,90 +1205,87 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n             }\n \n             #region Properties\n-            /// <summary>\n-            /// The fusionName\n-            /// </summary>\n-            public string FusionName { get; }\n \n-            /// <summary>\n-            /// Is the file a winmd or not\n-            /// </summary>\n-            public bool IsWinMD { get; }\n-\n-            /// <summary>\n-            /// Is the file a managed winmd or not\n-            /// </summary>\n-            public bool IsManagedWinmd { get; }\n-\n-            /// <summary>\n-            /// What is the imageruntime information on it.\n-            /// </summary>\n-            public string ImageRuntime { get; }\n+            public string FusionName { get; internal set; }\n+            public bool IsWinMD { get; internal set; }\n+            public bool IsManagedWinmd { get; internal set; }\n+            public string ImageRuntime { get; internal set; }\n \n             #endregion\n         }\n \n         /// <summary>\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n-        /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private IDictionary<string, SdkReferenceInfo> _pathToReferenceMetadata;\n+            private IDictionary<string, List<string>> _directoryToFileList;\n+            private int _hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                _pathToReferenceMetadata = new Dictionary<string, SdkReferenceInfo>(StringComparer.OrdinalIgnoreCase);\n+                _directoryToFileList = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);\n+                _hash = 0;\n+            }\n \n-            /// <summary>\n-            /// Constructor\n-            /// </summary>\n-            public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n+\n+            public SDKInfo(IDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, IDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this._pathToReferenceMetadata = pathToReferenceMetadata;\n+                this._directoryToFileList = directoryToFileList;\n+                this._hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            public IDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return _pathToReferenceMetadata; } }\n \n-            /// <summary>\n-            /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n-            /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public IDictionary<string, List<string>> DirectoryToFileList { get { return _directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return _hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                translator.TranslateDictionary(ref _pathToReferenceMetadata, (ITranslator t, ref string s) => t.Translate(ref s), (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n-\n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                }, count => new Dictionary<string, SdkReferenceInfo>(count, StringComparer.OrdinalIgnoreCase));\n+\n+                translator.TranslateDictionary(ref _directoryToFileList, (ITranslator t, ref string s) => t.Translate(ref s), (ITranslator t, ref List<string> fileList) =>",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "Right, but it should work as long as it matches. It serialized the dictionary twice, then deserialized it twice. Setting it the second time overwrote the correct value with the correct value, so everything still worked.\r\n\r\nThat also means I think it would be very hard to write a test for it...the only two options I can think of are having some kind of counter on how many times we accessed/set each variable or having a check at the end for the total size of the serialized form. Neither is trivial, and it isn't a huge deal for something that gets hit as often as this.",
              "createdAt": "2021-05-14T19:35:43Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1219,90 +1205,87 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n             }\n \n             #region Properties\n-            /// <summary>\n-            /// The fusionName\n-            /// </summary>\n-            public string FusionName { get; }\n \n-            /// <summary>\n-            /// Is the file a winmd or not\n-            /// </summary>\n-            public bool IsWinMD { get; }\n-\n-            /// <summary>\n-            /// Is the file a managed winmd or not\n-            /// </summary>\n-            public bool IsManagedWinmd { get; }\n-\n-            /// <summary>\n-            /// What is the imageruntime information on it.\n-            /// </summary>\n-            public string ImageRuntime { get; }\n+            public string FusionName { get; internal set; }\n+            public bool IsWinMD { get; internal set; }\n+            public bool IsManagedWinmd { get; internal set; }\n+            public string ImageRuntime { get; internal set; }\n \n             #endregion\n         }\n \n         /// <summary>\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n-        /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private IDictionary<string, SdkReferenceInfo> _pathToReferenceMetadata;\n+            private IDictionary<string, List<string>> _directoryToFileList;\n+            private int _hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                _pathToReferenceMetadata = new Dictionary<string, SdkReferenceInfo>(StringComparer.OrdinalIgnoreCase);\n+                _directoryToFileList = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);\n+                _hash = 0;\n+            }\n \n-            /// <summary>\n-            /// Constructor\n-            /// </summary>\n-            public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n+\n+            public SDKInfo(IDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, IDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this._pathToReferenceMetadata = pathToReferenceMetadata;\n+                this._directoryToFileList = directoryToFileList;\n+                this._hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            public IDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return _pathToReferenceMetadata; } }\n \n-            /// <summary>\n-            /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n-            /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public IDictionary<string, List<string>> DirectoryToFileList { get { return _directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return _hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                translator.TranslateDictionary(ref _pathToReferenceMetadata, (ITranslator t, ref string s) => t.Translate(ref s), (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n-\n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                }, count => new Dictionary<string, SdkReferenceInfo>(count, StringComparer.OrdinalIgnoreCase));\n+\n+                translator.TranslateDictionary(ref _directoryToFileList, (ITranslator t, ref string s) => t.Translate(ref s), (ITranslator t, ref List<string> fileList) =>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> Setting it the second time overwrote the correct value with the correct value, so everything still worked.\r\n\r\nI see, I was thinking maybe there'd be duplicate data somehow. Agreed that it's fine as is.",
              "createdAt": "2021-05-14T19:37:51Z",
              "path": "src/Tasks/GetSDKReferenceFiles.cs",
              "diffHunk": "@@ -1219,90 +1205,87 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo\n             }\n \n             #region Properties\n-            /// <summary>\n-            /// The fusionName\n-            /// </summary>\n-            public string FusionName { get; }\n \n-            /// <summary>\n-            /// Is the file a winmd or not\n-            /// </summary>\n-            public bool IsWinMD { get; }\n-\n-            /// <summary>\n-            /// Is the file a managed winmd or not\n-            /// </summary>\n-            public bool IsManagedWinmd { get; }\n-\n-            /// <summary>\n-            /// What is the imageruntime information on it.\n-            /// </summary>\n-            public string ImageRuntime { get; }\n+            public string FusionName { get; internal set; }\n+            public bool IsWinMD { get; internal set; }\n+            public bool IsManagedWinmd { get; internal set; }\n+            public string ImageRuntime { get; internal set; }\n \n             #endregion\n         }\n \n         /// <summary>\n         /// Structure that contains the on disk representation of the SDK in memory.\n         /// </summary>\n-        /// <remarks>This is a serialization format. Do not change member naming.</remarks>\n-        [Serializable]\n-        private class SDKInfo\n+        internal class SDKInfo : ITranslatable\n         {\n-            // Current version for serialization. This should be changed when breaking changes\n-            // are made to this class.\n-            private const byte CurrentSerializationVersion = 1;\n+            private IDictionary<string, SdkReferenceInfo> _pathToReferenceMetadata;\n+            private IDictionary<string, List<string>> _directoryToFileList;\n+            private int _hash;\n \n-            // Version this instance is serialized with.\n-            private byte _serializedVersion = CurrentSerializationVersion;\n+            internal SDKInfo()\n+            {\n+                _pathToReferenceMetadata = new Dictionary<string, SdkReferenceInfo>(StringComparer.OrdinalIgnoreCase);\n+                _directoryToFileList = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);\n+                _hash = 0;\n+            }\n \n-            /// <summary>\n-            /// Constructor\n-            /// </summary>\n-            public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)\n+            public SDKInfo(ITranslator translator) : this()\n+            {\n+                Translate(translator);\n+            }\n+\n+            public SDKInfo(IDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, IDictionary<string, List<string>> directoryToFileList, int cacheHash)\n             {\n-                PathToReferenceMetadata = pathToReferenceMetadata;\n-                DirectoryToFileList = directoryToFileList;\n-                Hash = cacheHash;\n+                this._pathToReferenceMetadata = pathToReferenceMetadata;\n+                this._directoryToFileList = directoryToFileList;\n+                this._hash = cacheHash;\n             }\n \n             /// <summary>\n             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.\n             /// </summary>\n-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }\n+            public IDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return _pathToReferenceMetadata; } }\n \n-            /// <summary>\n-            /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.\n-            /// </summary>\n-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }\n+            public IDictionary<string, List<string>> DirectoryToFileList { get { return _directoryToFileList; } }\n \n             /// <summary>\n             /// Hashset\n             /// </summary>\n-            public int Hash { get; }\n+            public int Hash { get { return _hash; } }\n \n-            public static SDKInfo Deserialize(string cacheFile)\n+            public void Translate(ITranslator translator)\n             {\n-                using (var fs = new FileStream(cacheFile, FileMode.Open))\n+                translator.TranslateDictionary(ref _pathToReferenceMetadata, (ITranslator t, ref string s) => t.Translate(ref s), (ITranslator t, ref SdkReferenceInfo info) =>\n                 {\n-                    var formatter = new BinaryFormatter();\n-                    var info = (SDKInfo)formatter.Deserialize(fs);\n-\n-                    // If the serialization versions don't match, don't use the cache\n-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)\n-                    {\n-                        return null;\n-                    }\n+                    info ??= new SdkReferenceInfo(null, null, false, false);\n+                    string fusionName = info.FusionName;\n+                    string imageRuntime = info.ImageRuntime;\n+                    bool isManagedWinmd = info.IsManagedWinmd;\n+                    bool isWinmd = info.IsWinMD;\n+                    t.Translate(ref fusionName);\n+                    t.Translate(ref imageRuntime);\n+                    t.Translate(ref isManagedWinmd);\n+                    t.Translate(ref isWinmd);\n+                    info.FusionName = fusionName;\n+                    info.ImageRuntime = imageRuntime;\n+                    info.IsManagedWinmd = isManagedWinmd;\n+                    info.IsWinMD = isWinmd;\n+                }, count => new Dictionary<string, SdkReferenceInfo>(count, StringComparer.OrdinalIgnoreCase));\n+\n+                translator.TranslateDictionary(ref _directoryToFileList, (ITranslator t, ref string s) => t.Translate(ref s), (ITranslator t, ref List<string> fileList) =>",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      }
    ]
  }
}