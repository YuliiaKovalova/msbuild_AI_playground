{
  "number": 8324,
  "title": "[FancyLogger] Show link to project outputs",
  "body": "Fixes #\r\n\r\n### Context\r\nOne of the key features of the old console logger is showing the path to the output file for each project using the format\r\n``` Project -> path/to/output```.\r\nTo save space, FancyLogger only shows the filename of the output in a clickable link that redirects to the output file following the same format. \r\n![image](https://user-images.githubusercontent.com/5952839/213584958-d5c34e7e-7774-47de-bc37-f290bb5baea0.png)\r\n\r\n\r\n### Changes Made\r\n* Updated `ANSIBuilder.Formatting.Hyperlink` to support [clickable hyperlinks](https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda)\r\n* Updated Regex for matching ANSI codes to also match hyperlinks\r\n* TFMs now show in a white background\r\n\r\n### Testing\r\n\r\n\r\n### Notes\r\n",
  "state": "MERGED",
  "createdAt": "2023-01-19T23:30:59Z",
  "updatedAt": "2023-02-07T02:44:48Z",
  "closedAt": "2023-02-07T02:44:48Z",
  "mergedAt": "2023-02-07T02:44:48Z",
  "additions": 102,
  "deletions": 46,
  "changedFiles": 5,
  "headRefName": "edvilme-flg-project-output",
  "isDraft": false,
  "author": {
    "login": "edvilme"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "cf5391107f7ad87e5ade5fc15f35eb42d7778f38",
          "message": "Added footer",
          "committedDate": "2023-01-18T00:57:06Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c549ce9647382e86f5809542c80f754490c2dc26",
          "message": "Fixed hyperlinks",
          "committedDate": "2023-01-18T21:11:19Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c9153341ad027c9e67fb8ffff601780c3e0f2a2b",
          "message": "Added output and link to project node",
          "committedDate": "2023-01-18T22:46:22Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5d543d7f8579fb9c0af9466741fe2a67077f5393",
          "message": "Solved review comments",
          "committedDate": "2023-01-19T22:31:21Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b08092cd4a7b35bb97e12ddb9ffd594163fcd592",
          "message": "Updade regex to also mathc hyperlinks",
          "committedDate": "2023-01-19T23:26:16Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ce31f0929488cb4aa73455324f49c49f084ae488",
          "message": "Parse filepaths as uris",
          "committedDate": "2023-01-19T23:49:34Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6f903402447d53207c2d6f137d6d6e95e9c4d02d",
          "message": "Fixed typos and cleaned up visuals",
          "committedDate": "2023-01-20T00:00:31Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b2deb6037579598a139bdd9a7434c3b28e47d24e",
          "message": "Output urls now point to containing directory, instead of actual file",
          "committedDate": "2023-01-20T01:51:37Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "13e7ff0b9752c9bbc404fa7c0ffb4907a80c56a5",
          "message": "Simplified code",
          "committedDate": "2023-01-20T02:05:04Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9af27f5b1412a3c7354049978628be43157d99b2",
          "message": "Addressed review comments",
          "committedDate": "2023-01-20T20:03:41Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5738eae3ed145a799e95c9b4ab6f1c2584717cd2",
          "message": "Merge branch 'main' into edvilme-flg-footer",
          "committedDate": "2023-01-20T21:08:57Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e4f0d029a1b1f8b411f76ebd21fcf1a21f710312",
          "message": "Added MessageType.ProjectOutputMessage",
          "committedDate": "2023-01-20T22:50:01Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6c87ddf98b7a6f96991e57c7e940aa04555c56e7",
          "message": "Merge with dotnet/main",
          "committedDate": "2023-01-20T22:51:57Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "264cbb9565446e50b30e57d124d64e11034e015a",
          "message": "Updated design",
          "committedDate": "2023-01-21T01:29:40Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7c440005718b464677a1bf5579091005e213818d",
          "message": "Added comment description to `ANSIBuilder.ANSIBreakpoint`\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2023-01-23T22:53:36Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "eduardo.villalpando.mello@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8893919c7bad99fcaca1bdbb1e9c35fe7489790f",
          "message": "Addressed review comments",
          "committedDate": "2023-01-23T23:03:05Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "64b3ccaab9e090360fb5e4214b2c8c900bf9f35f",
          "message": "Merge with dotnet/main",
          "committedDate": "2023-01-24T19:15:45Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6c9094f08819cc90c3149ec83ffd2c8bf7deeaec",
          "message": "Merge with main",
          "committedDate": "2023-01-24T19:33:16Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f1d115c9b4213ab58c500ce1b81926e7252c138c",
          "message": "Merge with main",
          "committedDate": "2023-01-24T19:34:38Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e1ccbc35224570dc975dc131dac1dfbcb34c2dc1",
          "message": "Merge with dotnet/main",
          "committedDate": "2023-01-27T19:43:54Z",
          "author": {
            "name": "Eduardo Villalpando Mello",
            "email": "t-eduardov@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f8eb8f07d0072bf9238ab6713d7d74f11449f455",
          "message": "Merge branch 'edvilme-flg-llg' into edvilme-flg-footer\n\n Conflicts:\n\tsrc/MSBuild/LiveLogger/LiveLogger.cs\n\tsrc/MSBuild/LiveLogger/TerminalBuffer.cs",
          "committedDate": "2023-02-01T02:47:00Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "26a687dae0d6a978291f033fecab54c6223b028b",
          "message": "Merge remote-tracking branch 'upstream/main' into edvilme-flg-footer",
          "committedDate": "2023-02-01T16:14:02Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "75ef16774b3b2ca44fb414f90db50bf21754b5b2",
          "message": "Merge branch 'edvilme-flg-footer' into edvilme-flg-project-output\n\nConflicts:\n\tsrc/MSBuild/LiveLogger/ANSIBuilder.cs\n\tsrc/MSBuild/LiveLogger/LiveLogger.cs\n\tsrc/MSBuild/LiveLogger/MessageNode.cs\n\tsrc/MSBuild/LiveLogger/ProjectNode.cs",
          "committedDate": "2023-02-01T17:01:35Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "This is really slick, but I think it hurts a critical use case: getting a path to an output so I can run it.\r\n\r\nI often do\r\n\r\n1. `dotnet build`\r\n2. double-click output path message to get full path to a specific output\r\n3. right click (copy)\r\n4. right click (paste)\r\n5. enter (run that thing)\r\n\r\nI find this easier than `dotnet run` because you can build a whole solution and because you can iterate on adding args to the thing more quickly and easily.\r\n\r\nFortunately I think there's an easy fix: don't truncate the path, but still hyperlink it. Then I can copy/paste but also see it in Explorer.",
        "createdAt": "2023-01-20T16:35:41Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "> This is really slick, but I think it hurts a critical use case: getting a path to an output so I can run it.\n> \n> \n> \n> I often do\n> \n> \n> \n> 1. `dotnet build`\n> \n> 2. double-click output path message to get full path to a specific output\n> \n> 3. right click (copy)\n> \n> 4. right click (paste)\n> \n> 5. enter (run that thing)\n> \n> \n> \n> I find this easier than `dotnet run` because you can build a whole solution and because you can iterate on adding args to the thing more quickly and easily.\n> \n> \n> \n> Fortunately I think there's an easy fix: don't truncate the path, but still hyperlink it. Then I can copy/paste but also see it in Explorer.\n\nAlright. Do you think we should clip them if they're too long?",
        "createdAt": "2023-01-20T17:59:11Z",
        "author": {
          "login": "edvilme"
        }
      },
      {
        "body": "> Do you think we should clip them if they're too long?\r\n\r\nI'm torn on this but lean toward \"no, output the whole path\". Would happily receive feedback!",
        "createdAt": "2023-01-20T19:10:12Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "@edvilme can you please merge `main` after we land the 17.5 merge into main (I think doing those together will minimize merge conflicts).",
        "createdAt": "2023-01-26T20:38:04Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I merged #8314 into this speculatively and it's looking good but blocked on that, so drafted for now.",
        "createdAt": "2023-02-01T17:03:12Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Undrafted since #8314 went in. Still LGTM to me, so marking merge-when.",
        "createdAt": "2023-02-06T15:09:56Z",
        "author": {
          "login": "rainersigwald"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This definitely accomplishes the goal! However, it's pretty inefficent on .NET Framework 4.8:\r\n\r\n1. This method is https://referencesource.microsoft.com/#System/regex/system/text/regularexpressions/Regex.cs,798 which calls\r\n2. https://referencesource.microsoft.com/#System/regex/system/text/regularexpressions/Regex.cs,9aef9195b829acff\r\n3. Which creates a new `Regex` object for each call\r\n4. That object's `Match` method is called, creating a `Match` object\r\n5. The `match.Value` allocates a string to hold the latter half of the message.\r\n6. The `Regex` and `Match` objects become garbage after this AddMessage call\r\n\r\nThis isn't quite as bad as it might be because `new Regex`  has a cache that will not require it to parse + compile the expression again, but it's still allocatey.\r\n\r\nThere are a couple of options to fix this. The easiest one is to move the regex to a `static` (so it's never garbage but there's only ever one), but that still allocates a `Match` object.\r\n\r\nSince this regex is pretty simple I prefer a more manual but minimal-allocation approach:\r\n\r\n```suggestion\r\n\r\n            const string FinalOutputMarker = \" -> \";\r\n            var i = args.Message!.IndexOf(FinalOutputMarker, StringComparison.Ordinal);\r\n            if (i > 0)\r\n            {\r\n                ProjectOutputExecutable = args.Message!.Substring(i + FinalOutputMarker.Length);\r\n            }\r\n```\r\n\r\nThe only allocation there is the substring, which could be avoided by preserving a span/memory into the original string, but this will allow the GC to collect the whole `BuildMessageEventArgs`, so I think it's better.\r\n\r\nIt also uses the latest greatest vectorized `IndexOf` which can be shockingly fast.",
              "createdAt": "2023-01-20T17:12:04Z",
              "path": "src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs",
              "diffHunk": "@@ -116,6 +122,12 @@ public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)\n         {\n             if (args.Importance != MessageImportance.High) return null;\n             MessageCount++;\n+            // Detect output messages using regex\n+            // var match = Regex.Match(args.Message, $\"(?<={args.ProjectFile} -> )(.*)\");\n+            var match = Regex.Match(args.Message!, $\"(?<=.* -> )(.*)\");\n+            if (match.Success)\n+                ProjectOutputExecutable = match.Value;\n+",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Can there be a case in which a high priority message in this format but **without** the project name at the beginning exist? ",
              "createdAt": "2023-01-20T17:57:33Z",
              "path": "src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs",
              "diffHunk": "@@ -116,6 +122,12 @@ public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)\n         {\n             if (args.Importance != MessageImportance.High) return null;\n             MessageCount++;\n+            // Detect output messages using regex\n+            // var match = Regex.Match(args.Message, $\"(?<={args.ProjectFile} -> )(.*)\");\n+            var match = Regex.Match(args.Message!, $\"(?<=.* -> )(.*)\");\n+            if (match.Success)\n+                ProjectOutputExecutable = match.Value;\n+",
              "author": {
                "login": "edvilme"
              }
            },
            {
              "body": "Yes, at minimum one could have a target that says `<Message Importance=\"High\" Text=\"X -> Y\" />`, which is basically all the message we're looking for here does:\r\n\r\nhttps://github.com/dotnet/msbuild/blob/5a635cf1218a5d7836114de1e392e7613d569675/src/Tasks/Microsoft.Common.CurrentVersion.targets#L4715\r\n\r\nYou could either check the initial substring or check whether the parent Target is `CopyFilesToOutputDirectory`.",
              "createdAt": "2023-01-20T19:12:33Z",
              "path": "src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs",
              "diffHunk": "@@ -116,6 +122,12 @@ public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)\n         {\n             if (args.Importance != MessageImportance.High) return null;\n             MessageCount++;\n+            // Detect output messages using regex\n+            // var match = Regex.Match(args.Message, $\"(?<={args.ProjectFile} -> )(.*)\");\n+            var match = Regex.Match(args.Message!, $\"(?<=.* -> )(.*)\");\n+            if (match.Success)\n+                ProjectOutputExecutable = match.Value;\n+",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Alright, so I should only check for messages whose parent target is `CopyFilesToOutputDirectory` using `IndexOf` instead of Regex, right?",
              "createdAt": "2023-01-20T21:14:04Z",
              "path": "src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs",
              "diffHunk": "@@ -116,6 +122,12 @@ public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)\n         {\n             if (args.Importance != MessageImportance.High) return null;\n             MessageCount++;\n+            // Detect output messages using regex\n+            // var match = Regex.Match(args.Message, $\"(?<={args.ProjectFile} -> )(.*)\");\n+            var match = Regex.Match(args.Message!, $\"(?<=.* -> )(.*)\");\n+            if (match.Success)\n+                ProjectOutputExecutable = match.Value;\n+",
              "author": {
                "login": "edvilme"
              }
            },
            {
              "body": "For now let's do the `IndexOf` thing + `ProjectFile` initial match--it looks like what we get in the `BuildMessageEventArgs.BuidlEventContext` is a `TargetId` rather than a target name, and maintaining a mapping sounds like a pain to be slightly more accurate (we can always do that later if we have a concrete reason).",
              "createdAt": "2023-01-20T21:45:01Z",
              "path": "src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs",
              "diffHunk": "@@ -116,6 +122,12 @@ public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)\n         {\n             if (args.Importance != MessageImportance.High) return null;\n             MessageCount++;\n+            // Detect output messages using regex\n+            // var match = Regex.Match(args.Message, $\"(?<={args.ProjectFile} -> )(.*)\");\n+            var match = Regex.Match(args.Message!, $\"(?<=.* -> )(.*)\");\n+            if (match.Success)\n+                ProjectOutputExecutable = match.Value;\n+",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "IMO this should be\r\n\r\n```suggestion\r\n        public string? ProjectOutputExecutable;\r\n```\r\n\r\nand assign/check for `null` instead of `Length > 0` elsewhere.",
              "createdAt": "2023-01-20T17:15:02Z",
              "path": "src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs",
              "diffHunk": "@@ -26,6 +27,7 @@ private static string GetUnambiguousPath(string path)\n         public string ProjectPath;\n         public string TargetFramework;\n         public bool Finished;\n+        public string ProjectOutputExecutable;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "For follow-up PR: this should be a `static Regex` constructed with `RegexOptions.Compiled`, which should dramatically reduce overhead of scanning using it. On .NET 7, we should use a `[GeneratedRegex]`.",
              "createdAt": "2023-01-23T15:55:15Z",
              "path": "src/Build/Logging/FancyLogger/ANSIBuilder.cs",
              "diffHunk": "@@ -10,10 +10,45 @@ namespace Microsoft.Build.Logging.FancyLogger\n {\n     internal static class ANSIBuilder\n     {\n-        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])\";\n+        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\";",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "A doc comment on this method would be super nice. Is this accurate?\r\n\r\n```suggestion\r\n        /// <summary>\r\n        /// Find a place to break a string after a number of visible characters, not counting VT-100 codes.\r\n        /// </summary>\r\n        /// <param name=\"text\">String to split.</param>\r\n        /// <param name=\"position\">Number of visible characters to split after.</param>\r\n        /// <returns>Index in <paramref name=\"text\"/> that represents <paramref name=\"position\"/> visible characters.</returns>\r\n        public static int ANSIBreakpoint(string text, int position)\r\n```",
              "createdAt": "2023-01-23T16:02:15Z",
              "path": "src/Build/Logging/FancyLogger/ANSIBuilder.cs",
              "diffHunk": "@@ -10,10 +10,45 @@ namespace Microsoft.Build.Logging.FancyLogger\n {\n     internal static class ANSIBuilder\n     {\n-        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])\";\n+        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\";\n         public static string ANSIRemove(string text)\n         {\n-            return Regex.Replace(text, @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\", \"\");\n+            return Regex.Replace(text, ANSIRegex, \"\");\n+        }\n+\n+        public static int ANSIBreakpoint(string text, int position)",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think a more descriptive name could help here.\r\n```suggestion\r\n            int logicalIndex = 0;\r\n```",
              "createdAt": "2023-01-23T16:10:41Z",
              "path": "src/Build/Logging/FancyLogger/ANSIBuilder.cs",
              "diffHunk": "@@ -10,10 +10,45 @@ namespace Microsoft.Build.Logging.FancyLogger\n {\n     internal static class ANSIBuilder\n     {\n-        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])\";\n+        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\";\n         public static string ANSIRemove(string text)\n         {\n-            return Regex.Replace(text, @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\", \"\");\n+            return Regex.Replace(text, ANSIRegex, \"\");\n+        }\n+\n+        public static int ANSIBreakpoint(string text, int position)\n+        {\n+            if (position >= text.Length) return text.Length;\n+            int nonAnsiIndex = 0;\n+            Match nextMatch = Regex.Match(text, ANSIRegex);\n+            int i = 0;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        public static List<string> ANSIWrap(string text, int maxLength)\r\n        {\r\n            List<string> result = new();\r\n            int breakpoint = ANSIBreakpoint(text, maxLength);\r\n            while (text.Length > breakpoint)\r\n            {\r\n                result.Add(text.Substring(0, breakpoint));\r\n                text = text.Substring(breakpoint);\r\n                breakpoint = ANSIBreakpoint(text, maxLength);\r\n```",
              "createdAt": "2023-01-23T16:12:28Z",
              "path": "src/Build/Logging/FancyLogger/ANSIBuilder.cs",
              "diffHunk": "@@ -10,10 +10,45 @@ namespace Microsoft.Build.Logging.FancyLogger\n {\n     internal static class ANSIBuilder\n     {\n-        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])\";\n+        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\";\n         public static string ANSIRemove(string text)\n         {\n-            return Regex.Replace(text, @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\", \"\");\n+            return Regex.Replace(text, ANSIRegex, \"\");\n+        }\n+\n+        public static int ANSIBreakpoint(string text, int position)\n+        {\n+            if (position >= text.Length) return text.Length;\n+            int nonAnsiIndex = 0;\n+            Match nextMatch = Regex.Match(text, ANSIRegex);\n+            int i = 0;\n+            while (i < text.Length && nonAnsiIndex != position)\n+            {\n+                // Jump over ansi codes\n+                if (i == nextMatch.Index && nextMatch.Length > 0)\n+                {\n+                    i += nextMatch.Length;\n+                    nextMatch = nextMatch.NextMatch();\n+                }\n+                // Increment non ansi index\n+                nonAnsiIndex++;\n+                i++;\n+            }\n+            return i;\n+        }\n+\n+        public static List<string> ANSIWrap(string text, int position)\n+        {\n+            List<string> result = new();\n+            int breakpoint = ANSIBreakpoint(text, position);\n+            while (text.Length > breakpoint)\n+            {\n+                result.Add(text.Substring(0, breakpoint));\n+                text = text.Substring(breakpoint);\n+                breakpoint = ANSIBreakpoint(text, position);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I am in general suspicious of recursion on unbounded-size inputs. We may want to rewrite this to be a loop instead. This can wait though.\r\n\r\nWhen we do this, we should avoid the allocating approach `text = text.Substring(breakpoint);` in favor of spans or index tracking.",
              "createdAt": "2023-01-23T16:17:03Z",
              "path": "src/Build/Logging/FancyLogger/ANSIBuilder.cs",
              "diffHunk": "@@ -10,10 +10,45 @@ namespace Microsoft.Build.Logging.FancyLogger\n {\n     internal static class ANSIBuilder\n     {\n-        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])\";\n+        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\";\n         public static string ANSIRemove(string text)\n         {\n-            return Regex.Replace(text, @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\", \"\");\n+            return Regex.Replace(text, ANSIRegex, \"\");\n+        }\n+\n+        public static int ANSIBreakpoint(string text, int position)\n+        {\n+            if (position >= text.Length) return text.Length;\n+            int nonAnsiIndex = 0;\n+            Match nextMatch = Regex.Match(text, ANSIRegex);\n+            int i = 0;\n+            while (i < text.Length && nonAnsiIndex != position)\n+            {\n+                // Jump over ansi codes\n+                if (i == nextMatch.Index && nextMatch.Length > 0)\n+                {\n+                    i += nextMatch.Length;\n+                    nextMatch = nextMatch.NextMatch();\n+                }\n+                // Increment non ansi index\n+                nonAnsiIndex++;\n+                i++;\n+            }\n+            return i;\n+        }\n+\n+        public static List<string> ANSIWrap(string text, int position)\n+        {\n+            List<string> result = new();\n+            int breakpoint = ANSIBreakpoint(text, position);\n+            while (text.Length > breakpoint)\n+            {\n+                result.Add(text.Substring(0, breakpoint));\n+                text = text.Substring(breakpoint);\n+                breakpoint = ANSIBreakpoint(text, position);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I agree. It was using spans previously, but couldn't find a way to get Regex working with them, so I would end up using the `ToString()` method which IMO defeats the purpose. \nI will find a way later to make it more memory efficient and rewrite it as a loop",
              "createdAt": "2023-01-23T21:52:28Z",
              "path": "src/Build/Logging/FancyLogger/ANSIBuilder.cs",
              "diffHunk": "@@ -10,10 +10,45 @@ namespace Microsoft.Build.Logging.FancyLogger\n {\n     internal static class ANSIBuilder\n     {\n-        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])\";\n+        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\";\n         public static string ANSIRemove(string text)\n         {\n-            return Regex.Replace(text, @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\", \"\");\n+            return Regex.Replace(text, ANSIRegex, \"\");\n+        }\n+\n+        public static int ANSIBreakpoint(string text, int position)\n+        {\n+            if (position >= text.Length) return text.Length;\n+            int nonAnsiIndex = 0;\n+            Match nextMatch = Regex.Match(text, ANSIRegex);\n+            int i = 0;\n+            while (i < text.Length && nonAnsiIndex != position)\n+            {\n+                // Jump over ansi codes\n+                if (i == nextMatch.Index && nextMatch.Length > 0)\n+                {\n+                    i += nextMatch.Length;\n+                    nextMatch = nextMatch.NextMatch();\n+                }\n+                // Increment non ansi index\n+                nonAnsiIndex++;\n+                i++;\n+            }\n+            return i;\n+        }\n+\n+        public static List<string> ANSIWrap(string text, int position)\n+        {\n+            List<string> result = new();\n+            int breakpoint = ANSIBreakpoint(text, position);\n+            while (text.Length > breakpoint)\n+            {\n+                result.Add(text.Substring(0, breakpoint));\n+                text = text.Substring(breakpoint);\n+                breakpoint = ANSIBreakpoint(text, position);",
              "author": {
                "login": "edvilme"
              }
            },
            {
              "body": "I think you'll be interested in [the `Regex.Match(string, int)` overload](https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.match?view=net-7.0#system-text-regularexpressions-regex-match(system-string-system-int32)) which allows you to match a \"substring\" that's actually a string + a start point.",
              "createdAt": "2023-01-23T21:57:37Z",
              "path": "src/Build/Logging/FancyLogger/ANSIBuilder.cs",
              "diffHunk": "@@ -10,10 +10,45 @@ namespace Microsoft.Build.Logging.FancyLogger\n {\n     internal static class ANSIBuilder\n     {\n-        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])\";\n+        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\";\n         public static string ANSIRemove(string text)\n         {\n-            return Regex.Replace(text, @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\", \"\");\n+            return Regex.Replace(text, ANSIRegex, \"\");\n+        }\n+\n+        public static int ANSIBreakpoint(string text, int position)\n+        {\n+            if (position >= text.Length) return text.Length;\n+            int nonAnsiIndex = 0;\n+            Match nextMatch = Regex.Match(text, ANSIRegex);\n+            int i = 0;\n+            while (i < text.Length && nonAnsiIndex != position)\n+            {\n+                // Jump over ansi codes\n+                if (i == nextMatch.Index && nextMatch.Length > 0)\n+                {\n+                    i += nextMatch.Length;\n+                    nextMatch = nextMatch.NextMatch();\n+                }\n+                // Increment non ansi index\n+                nonAnsiIndex++;\n+                i++;\n+            }\n+            return i;\n+        }\n+\n+        public static List<string> ANSIWrap(string text, int position)\n+        {\n+            List<string> result = new();\n+            int breakpoint = ANSIBreakpoint(text, position);\n+            while (text.Length > breakpoint)\n+            {\n+                result.Add(text.Substring(0, breakpoint));\n+                text = text.Substring(breakpoint);\n+                breakpoint = ANSIBreakpoint(text, position);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Ohh, that will be very useful! Will definitely check it out",
              "createdAt": "2023-01-23T22:55:57Z",
              "path": "src/Build/Logging/FancyLogger/ANSIBuilder.cs",
              "diffHunk": "@@ -10,10 +10,45 @@ namespace Microsoft.Build.Logging.FancyLogger\n {\n     internal static class ANSIBuilder\n     {\n-        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])\";\n+        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\";\n         public static string ANSIRemove(string text)\n         {\n-            return Regex.Replace(text, @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\", \"\");\n+            return Regex.Replace(text, ANSIRegex, \"\");\n+        }\n+\n+        public static int ANSIBreakpoint(string text, int position)\n+        {\n+            if (position >= text.Length) return text.Length;\n+            int nonAnsiIndex = 0;\n+            Match nextMatch = Regex.Match(text, ANSIRegex);\n+            int i = 0;\n+            while (i < text.Length && nonAnsiIndex != position)\n+            {\n+                // Jump over ansi codes\n+                if (i == nextMatch.Index && nextMatch.Length > 0)\n+                {\n+                    i += nextMatch.Length;\n+                    nextMatch = nextMatch.NextMatch();\n+                }\n+                // Increment non ansi index\n+                nonAnsiIndex++;\n+                i++;\n+            }\n+            return i;\n+        }\n+\n+        public static List<string> ANSIWrap(string text, int position)\n+        {\n+            List<string> result = new();\n+            int breakpoint = ANSIBreakpoint(text, position);\n+            while (text.Length > breakpoint)\n+            {\n+                result.Add(text.Substring(0, breakpoint));\n+                text = text.Substring(breakpoint);\n+                breakpoint = ANSIBreakpoint(text, position);",
              "author": {
                "login": "edvilme"
              }
            },
            {
              "body": "Perhaps this change would be better suited for #8331, but what do you think?",
              "createdAt": "2023-01-23T23:34:21Z",
              "path": "src/Build/Logging/FancyLogger/ANSIBuilder.cs",
              "diffHunk": "@@ -10,10 +10,45 @@ namespace Microsoft.Build.Logging.FancyLogger\n {\n     internal static class ANSIBuilder\n     {\n-        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])\";\n+        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\";\n         public static string ANSIRemove(string text)\n         {\n-            return Regex.Replace(text, @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\", \"\");\n+            return Regex.Replace(text, ANSIRegex, \"\");\n+        }\n+\n+        public static int ANSIBreakpoint(string text, int position)\n+        {\n+            if (position >= text.Length) return text.Length;\n+            int nonAnsiIndex = 0;\n+            Match nextMatch = Regex.Match(text, ANSIRegex);\n+            int i = 0;\n+            while (i < text.Length && nonAnsiIndex != position)\n+            {\n+                // Jump over ansi codes\n+                if (i == nextMatch.Index && nextMatch.Length > 0)\n+                {\n+                    i += nextMatch.Length;\n+                    nextMatch = nextMatch.NextMatch();\n+                }\n+                // Increment non ansi index\n+                nonAnsiIndex++;\n+                i++;\n+            }\n+            return i;\n+        }\n+\n+        public static List<string> ANSIWrap(string text, int position)\n+        {\n+            List<string> result = new();\n+            int breakpoint = ANSIBreakpoint(text, position);\n+            while (text.Length > breakpoint)\n+            {\n+                result.Add(text.Substring(0, breakpoint));\n+                text = text.Substring(breakpoint);\n+                breakpoint = ANSIBreakpoint(text, position);",
              "author": {
                "login": "edvilme"
              }
            },
            {
              "body": "I'm happy to wait on this!",
              "createdAt": "2023-01-24T11:43:04Z",
              "path": "src/Build/Logging/FancyLogger/ANSIBuilder.cs",
              "diffHunk": "@@ -10,10 +10,45 @@ namespace Microsoft.Build.Logging.FancyLogger\n {\n     internal static class ANSIBuilder\n     {\n-        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])\";\n+        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\";\n         public static string ANSIRemove(string text)\n         {\n-            return Regex.Replace(text, @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\", \"\");\n+            return Regex.Replace(text, ANSIRegex, \"\");\n+        }\n+\n+        public static int ANSIBreakpoint(string text, int position)\n+        {\n+            if (position >= text.Length) return text.Length;\n+            int nonAnsiIndex = 0;\n+            Match nextMatch = Regex.Match(text, ANSIRegex);\n+            int i = 0;\n+            while (i < text.Length && nonAnsiIndex != position)\n+            {\n+                // Jump over ansi codes\n+                if (i == nextMatch.Index && nextMatch.Length > 0)\n+                {\n+                    i += nextMatch.Length;\n+                    nextMatch = nextMatch.NextMatch();\n+                }\n+                // Increment non ansi index\n+                nonAnsiIndex++;\n+                i++;\n+            }\n+            return i;\n+        }\n+\n+        public static List<string> ANSIWrap(string text, int position)\n+        {\n+            List<string> result = new();\n+            int breakpoint = ANSIBreakpoint(text, position);\n+            while (text.Length > breakpoint)\n+            {\n+                result.Add(text.Substring(0, breakpoint));\n+                text = text.Substring(breakpoint);\n+                breakpoint = ANSIBreakpoint(text, position);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It is now up :)",
              "createdAt": "2023-01-24T19:16:17Z",
              "path": "src/Build/Logging/FancyLogger/ANSIBuilder.cs",
              "diffHunk": "@@ -10,10 +10,45 @@ namespace Microsoft.Build.Logging.FancyLogger\n {\n     internal static class ANSIBuilder\n     {\n-        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])\";\n+        public static string ANSIRegex = @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\";\n         public static string ANSIRemove(string text)\n         {\n-            return Regex.Replace(text, @\"\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~]|(?:\\]8;;.*?\\x1b\\\\))\", \"\");\n+            return Regex.Replace(text, ANSIRegex, \"\");\n+        }\n+\n+        public static int ANSIBreakpoint(string text, int position)\n+        {\n+            if (position >= text.Length) return text.Length;\n+            int nonAnsiIndex = 0;\n+            Match nextMatch = Regex.Match(text, ANSIRegex);\n+            int i = 0;\n+            while (i < text.Length && nonAnsiIndex != position)\n+            {\n+                // Jump over ansi codes\n+                if (i == nextMatch.Index && nextMatch.Length > 0)\n+                {\n+                    i += nextMatch.Length;\n+                    nextMatch = nextMatch.NextMatch();\n+                }\n+                // Increment non ansi index\n+                nonAnsiIndex++;\n+                i++;\n+            }\n+            return i;\n+        }\n+\n+        public static List<string> ANSIWrap(string text, int position)\n+        {\n+            List<string> result = new();\n+            int breakpoint = ANSIBreakpoint(text, position);\n+            while (text.Length > breakpoint)\n+            {\n+                result.Add(text.Substring(0, breakpoint));\n+                text = text.Substring(breakpoint);\n+                breakpoint = ANSIBreakpoint(text, position);",
              "author": {
                "login": "edvilme"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Delete comment please.",
              "createdAt": "2023-01-23T16:58:18Z",
              "path": "src/Build/Logging/FancyLogger/FancyLogger.cs",
              "diffHunk": "@@ -171,17 +171,20 @@ public void Shutdown()\n         {\n             FancyLoggerBuffer.Terminate();\n             // TODO: Remove. There is a bug that causes switching to main buffer without deleting the contents of the alternate buffer\n-            Console.Clear();\n+            // Console.Clear();",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Comment \"Explicitly not wrapping here for easy copy/paste of final output\" or similar?",
              "createdAt": "2023-01-23T16:59:34Z",
              "path": "src/Build/Logging/FancyLogger/FancyLogger.cs",
              "diffHunk": "@@ -171,17 +171,20 @@ public void Shutdown()\n         {\n             FancyLoggerBuffer.Terminate();\n             // TODO: Remove. There is a bug that causes switching to main buffer without deleting the contents of the alternate buffer\n-            Console.Clear();\n+            // Console.Clear();\n             int errorCount = 0;\n             int warningCount = 0;\n             foreach (var project in projects)\n             {\n+                if (project.Value.AdditionalDetails.Count == 0) continue;\n+                Console.WriteLine(project.Value.ToANSIString());\n                 errorCount += project.Value.ErrorCount;\n                 warningCount += project.Value.WarningCount;\n                 foreach (var message in project.Value.AdditionalDetails)\n                 {\n-                    Console.WriteLine(message.ToANSIString());\n+                    Console.WriteLine($\"    \u2514\u2500\u2500 {message.ToANSIString()}\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Oh in this case it is because we are not using the alternate `FancyLoggerBuffer` but the normal `Console.WriteLine`",
              "createdAt": "2023-01-23T22:58:00Z",
              "path": "src/Build/Logging/FancyLogger/FancyLogger.cs",
              "diffHunk": "@@ -171,17 +171,20 @@ public void Shutdown()\n         {\n             FancyLoggerBuffer.Terminate();\n             // TODO: Remove. There is a bug that causes switching to main buffer without deleting the contents of the alternate buffer\n-            Console.Clear();\n+            // Console.Clear();\n             int errorCount = 0;\n             int warningCount = 0;\n             foreach (var project in projects)\n             {\n+                if (project.Value.AdditionalDetails.Count == 0) continue;\n+                Console.WriteLine(project.Value.ToANSIString());\n                 errorCount += project.Value.ErrorCount;\n                 warningCount += project.Value.WarningCount;\n                 foreach (var message in project.Value.AdditionalDetails)\n                 {\n-                    Console.WriteLine(message.ToANSIString());\n+                    Console.WriteLine($\"    \u2514\u2500\u2500 {message.ToANSIString()}\");",
              "author": {
                "login": "edvilme"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What does this do, when done in the alt buffer just before switching back?",
              "createdAt": "2023-01-23T17:00:27Z",
              "path": "src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs",
              "diffHunk": "@@ -103,10 +103,12 @@ public static void Initialize()\n         public static void Terminate()\n         {\n             IsTerminated = true;\n+            Console.Write(\n+                ANSIBuilder.Cursor.Home() +\n+                ANSIBuilder.Eraser.DisplayCursorToEnd()\n+            );",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This moves the cursor to the beginning of the screen (0,0) and deletes everything until the end. THat means, deletes everything in the alternate buffer before switching back. This is due to a bug when switching from and to the alt buffer. ",
              "createdAt": "2023-01-23T23:00:03Z",
              "path": "src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs",
              "diffHunk": "@@ -103,10 +103,12 @@ public static void Initialize()\n         public static void Terminate()\n         {\n             IsTerminated = true;\n+            Console.Write(\n+                ANSIBuilder.Cursor.Home() +\n+                ANSIBuilder.Eraser.DisplayCursorToEnd()\n+            );",
              "author": {
                "login": "edvilme"
              }
            },
            {
              "body": "Describe this + the bug it works around in a comment please :)",
              "createdAt": "2023-01-23T23:01:24Z",
              "path": "src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs",
              "diffHunk": "@@ -103,10 +103,12 @@ public static void Initialize()\n         public static void Terminate()\n         {\n             IsTerminated = true;\n+            Console.Write(\n+                ANSIBuilder.Cursor.Home() +\n+                ANSIBuilder.Eraser.DisplayCursorToEnd()\n+            );",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}