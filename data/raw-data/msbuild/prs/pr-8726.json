{
  "number": 8726,
  "title": "Add \"cache add\" functionality to project caching",
  "body": "This change add \"cache add\" functionality to project caching.\r\n\r\nToday project caching exposes a hook to plugins for \"I'm about to build this thing, do you want to take over instead?\" and that's it. This change adds a few more hooks which report file accesses and processes (via Detours) and also for when a project finishes building. This allows a plugin to collect the file accesses and add entries to the cache for future replayability.\r\n\r\nI strongly recommend reviewing each commit as opposed to the whole PR as a whole. I (hopefully) broke it down into reasonably reviewable chunks.\r\n\r\nCC @AndyGerlicher @DmitriyShepelev ",
  "state": "MERGED",
  "createdAt": "2023-05-02T17:28:40Z",
  "updatedAt": "2023-08-29T18:33:44Z",
  "closedAt": "2023-08-29T18:32:29Z",
  "mergedAt": "2023-08-29T18:32:29Z",
  "additions": 2607,
  "deletions": 51,
  "changedFiles": 73,
  "headRefName": "project-cache-vnext",
  "isDraft": false,
  "author": {
    "login": "dfederm"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "919b2e546eef37483a3c081bb25d93de0e0ee8e8",
          "message": "Add -reportFileAccesses command line param",
          "committedDate": "2023-06-13T21:04:58Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b7a0ad5283a002831faf73afb48c19e5e21bba33",
          "message": "Add ReportFileAccesses to BuildParameters",
          "committedDate": "2023-06-13T21:04:58Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "effbcb2c31af0a3a4cac4a75417f98532e9c9e20",
          "message": "Implement FileAccessManager",
          "committedDate": "2023-06-13T23:16:04Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "837f8db50e8af7ddf81aaab55d953bbb5faf8279",
          "message": "Make NodeLauncher a BuildComponent",
          "committedDate": "2023-06-13T23:16:06Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2340b2f205a2517cb2766433e1ef72a01cfdfc97",
          "message": "Launch nodes using BXL's SandboxedProcess",
          "committedDate": "2023-06-13T23:16:07Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f963b7f39d44566e5f8741b6fc5a0d9ad53dfbca",
          "message": "Add new interfaces to ProjectCachePluginBase",
          "committedDate": "2023-06-13T23:16:07Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb9f587960b685e06337023d84b08ad7f1d11f3a",
          "message": "Register and call plugin's file access handlers",
          "committedDate": "2023-06-13T23:22:40Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "796ec8f7633191465fe9e63b7eec9a13c6a711b5",
          "message": "Synchronize node communication with file access reporting",
          "committedDate": "2023-06-13T23:22:40Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9df8ec89783a96d0eeb2327f72e173b938162b83",
          "message": "Exclude file accesses under TempFileDirectory",
          "committedDate": "2023-06-13T23:22:40Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9094e33ed1df066ad52ccdb7f0e1ff22ac3fd8a2",
          "message": "Do not allow task yielding when reporting file accesses",
          "committedDate": "2023-06-13T23:22:40Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8e3b92fa98c75b6b4d0851e023e7a43911574d65",
          "message": "Implement OutOfProcNodeFileAccessManager",
          "committedDate": "2023-06-13T23:22:40Z",
          "author": {
            "name": "David Federman",
            "email": "david.federman@outlook.com"
          }
        }
      },
      {
        "commit": {
          "oid": "823739c6c1bc7a9861e8970ad9508563f4b67394",
          "message": "Enable tasks to report file accesses",
          "committedDate": "2023-06-13T23:22:40Z",
          "author": {
            "name": "Dmitriy Shepelev",
            "email": "dshepelev@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "31a1fe42b74e9de63670fc944bc14244dae75251",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild into project-cache-vnext",
          "committedDate": "2023-06-23T20:11:31Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "420b5265bb9f6630f026586724fed48fbcf6bf06",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild into project-cache-vnext",
          "committedDate": "2023-06-23T22:59:06Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5af7105bb2bd86215afb2a57b352857ad4a67e08",
          "message": "Fix UTs",
          "committedDate": "2023-06-27T03:33:42Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1b8b2b8f31764cd36ffeebefd52f288d8a1adf09",
          "message": "Fix nullability",
          "committedDate": "2023-06-27T03:57:47Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d5b905fa9814910afaf64312048368111e4cef0e",
          "message": "Merge branch 'main' into project-cache-vnext",
          "committedDate": "2023-08-03T16:11:55Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9861d878bf987eb92c4e105a6593d6895176351f",
          "message": "Condition behind a feature flag to target windows-only for now",
          "committedDate": "2023-08-03T17:13:03Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6222f768641f20759a14e098d48d5032714ee1b5",
          "message": "Merge remote-tracking branch 'upstream/main' into project-cache-vnext",
          "committedDate": "2023-08-14T20:35:02Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "784c010f5bcd5d44bd73405cfed0ede1f0d3b8f9",
          "message": "Update SourceBuild Baseline",
          "committedDate": "2023-08-23T14:26:02Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "krivanek.j@hotmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f5e7122e5fd9990df6bdd7a80ff47e293585da39",
          "message": "Remove nuget.org nuget feed",
          "committedDate": "2023-08-23T14:27:09Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7aa4e3f4bb2889c1a04fec87ef50fa73bb857e6b",
          "message": "Revert change to System.Security.Principal.Windows",
          "committedDate": "2023-08-24T15:33:18Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cf5d6c455809bf13b05e29741dc23fbb47520108",
          "message": "Mark types as non-CLS-compliant\n\nInstead of suppressing warnings, explicitly declare CLSCompliant(false).",
          "committedDate": "2023-08-24T16:43:06Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2dac5e18c4f79cc86882931cd0571445a3da2c37",
          "message": "PR comments",
          "committedDate": "2023-08-24T23:25:09Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a67e9acb7e2dc365cb2269f775ed16dc61b6531c",
          "message": "Fix build",
          "committedDate": "2023-08-28T19:36:00Z",
          "author": {
            "name": "David Federman",
            "email": "dfederm@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "Unrelated, but why is GitHub putting my comment above and below my inline comments? I don't think it's done that on other PRs.",
        "createdAt": "2023-05-15T19:55:51Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> Is there a chance that the additional dependencies might be missing by VS after insrtion? I have very vague knowledge here - so not sure how to best verify this other then experimental insertion. But it'd be uncovered after merging this PR anyway - so not a big concern\r\n\r\nI think it's worth a serious look and an exp/ branch. A couple years ago, I added a reference to a new System package, and it prevented us from inserting until we reverted it a couple months later. That was Bad.\r\n\r\nhttps://github.com/dotnet/msbuild/pull/8726/files#r1190408764",
        "createdAt": "2023-05-30T15:33:57Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> > Is there a chance that the additional dependencies might be missing by VS after insrtion? I have very vague knowledge here - so not sure how to best verify this other then experimental insertion. But it'd be uncovered after merging this PR anyway - so not a big concern\r\n> \r\n> I think it's worth a serious look and an exp/ branch. A couple years ago, I added a reference to a new System package, and it prevented us from inserting until we reverted it a couple months later. That was Bad.\r\n> \r\n> https://github.com/dotnet/msbuild/pull/8726/files#r1190408764\r\n\r\nI tried this but am hitting the same errors I see in the PR gate. I'll need help resolving those issues as I have not attempted to introduce new dependencies to MSBuild before.",
        "createdAt": "2023-05-31T00:03:31Z",
        "author": {
          "login": "dfederm"
        }
      },
      {
        "body": "Apologies reviewers for the rebase and force push. I'm hitting issues when merging, which are certainly user error...",
        "createdAt": "2023-06-13T23:56:03Z",
        "author": {
          "login": "dfederm"
        }
      },
      {
        "body": "> Apologies reviewers for the rebase and force push. I'm hitting issues when merging, which are certainly user error...\r\n\r\nCan you point if there are any specific parts that were changed or in need of a closer look? I jumped to the parts I was commenting last time - so wondering if I should focus on anything else.\r\n\r\nOther than that I have no concerns now - just prior signing-off waiting to see if deeper look is needed.\r\n",
        "createdAt": "2023-06-14T09:41:05Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "> > Apologies reviewers for the rebase and force push. I'm hitting issues when merging, which are certainly user error...\r\n> \r\n> Can you point if there are any specific parts that were changed or in need of a closer look? I jumped to the parts I was commenting last time - so wondering if I should focus on anything else.\r\n> \r\n> Other than that I have no concerns now - just prior signing-off waiting to see if deeper look is needed.\r\n\r\nIt should be just addressing comments. The only noteworthy one there IIRC is addressing the comment around locking the handlers.",
        "createdAt": "2023-06-14T23:56:04Z",
        "author": {
          "login": "dfederm"
        }
      },
      {
        "body": "> > > Apologies reviewers for the rebase and force push. I'm hitting issues when merging, which are certainly user error...\r\n> > \r\n> > \r\n> > Can you point if there are any specific parts that were changed or in need of a closer look? I jumped to the parts I was commenting last time - so wondering if I should focus on anything else.\r\n> > Other than that I have no concerns now - just prior signing-off waiting to see if deeper look is needed.\r\n> \r\n> It should be just addressing comments. The only noteworthy one there IIRC is addressing the comment around locking the handlers.\r\n\r\nThanks for pointing! - I missed that one",
        "createdAt": "2023-06-15T10:08:51Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "I made an exp/ branch for this PR (at its current version). Build result [here](https://dev.azure.com/devdiv/DevDiv/_build/results?buildId=7920359&view=results). It looks like we'll have to add BuildXL to the baseline package (list?) used by source build for this to get past the official build stage. Then we can check whether it passes RPS.\r\n\r\nAnyone know how to do that?",
        "createdAt": "2023-06-15T19:57:58Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> I made an exp/ branch for this PR (at its current version). Build result [here](https://dev.azure.com/devdiv/DevDiv/_build/results?buildId=7920359&view=results). It looks like we'll have to add BuildXL to the baseline package (list?) used by source build for this to get past the official build stage. Then we can check whether it passes RPS.\r\n> \r\n> Anyone know how to do that?\r\n\r\nAs for source build - they should be added to source-build-reference-packages - [instructions](https://github.com/dotnet/source-build-reference-packages#reference)\r\nThen we need to make sure we reference appropriate version of source-build-reference-packages - that should happen automagicaly once the issues with https://github.com/dotnet/msbuild/pull/8893 get resolved, as I created darc subscribtion.\r\nThose are basically analogous steps to what I'm going through with https://github.com/dotnet/msbuild/pull/8903.\r\n\r\nAs for adding the binaries to VS and then requesting and getting exception for RPS/DDRit - there I unfortunately have no experience\r\n",
        "createdAt": "2023-06-16T20:55:15Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "> I want an opt-in API to report actual reads from e.g. roslyn compiler server; is that extending this or a separate thing?\r\n\r\nYup, see `EngineServices.ReportFileAccess`. That's how a task would self-report its accesses.",
        "createdAt": "2023-08-24T23:28:32Z",
        "author": {
          "login": "dfederm"
        }
      },
      {
        "body": "Aggregating remaining unaddressed feedback up to this point so I don't forget it (I find GitHub threading a bit hard to track over multiple iterations):\r\n* Audit tests to ensure proper coverage\r\n  * E2E tests would be really nice, although this might be out of scope for now\r\n* Improve docs to properly describe the state of the feature\r\n* Razor compiler server... figure out if we need to allow this to breakaway as well\r\n\r\nReviewers, please let me know if I missed any of your feedback",
        "createdAt": "2023-08-24T23:36:30Z",
        "author": {
          "login": "dfederm"
        }
      },
      {
        "body": "Spoke with @rainersigwald offline.\r\n\r\nSo that this PR can make the 17.8 deadline, we agreed to defer the UTs (and ideally e2e tests) and docs to a separate PR which I'm promising to deliver soon.\r\n\r\nwrt Razor compiler server, I'm hesitant to allow it to break away since that would lose the detours information even when *not* running in server mode (rzc.exe is used for both scenarios). We will likely need to revisit this at some point though...",
        "createdAt": "2023-08-28T20:13:18Z",
        "author": {
          "login": "dfederm"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "We probably need the razor compiler here too?",
              "createdAt": "2023-05-08T15:16:00Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -176,12 +192,83 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)\n                     NativeMethodsShared.CloseHandle(processInfo.hThread);\n                 }\n \n-                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", childProcessId, exeName);\n+                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", childProcessId, msbuildExe);\n                 return Process.GetProcessById(childProcessId);\n             }\n         }\n \n-        private Process DisableMSBuildServer(Func<Process> func)\n+        private static Process StartDetouredProcess(string msbuildExe, string commandLineArgs, IBuildComponentHost componentHost, int nodeId)\n+        {\n+            IFileAccessManager fileAccessManager = (IFileAccessManager)componentHost.GetComponent(BuildComponentType.FileAccessManager);\n+\n+            var eventListener = new DetoursEventListener(fileAccessManager, nodeId);\n+            eventListener.SetMessageHandlingFlags(MessageHandlingFlags.DebugMessageNotify | MessageHandlingFlags.FileAccessNotify | MessageHandlingFlags.ProcessDataNotify | MessageHandlingFlags.ProcessDetoursStatusNotify);\n+\n+            var info = new SandboxedProcessInfo(\n+                fileStorage: null, // Don't write stdout/stderr to files\n+                fileName: msbuildExe,\n+                disableConHostSharing: false,\n+                detoursEventListener: eventListener,\n+                createJobObjectForCurrentProcess: false)\n+            {\n+                SandboxKind = SandboxKind.Default,\n+                PipDescription = \"MSBuild\",\n+                PipSemiStableHash = 0,\n+                Arguments = commandLineArgs,\n+                EnvironmentVariables = EnvironmentalBuildParameters.Instance,\n+\n+                // Allow parent conhost sharing (above) and turn off stream observers to allow passing through stdout, stderr and\n+                // console API calls (e.g. Windows SetConsoleColor()) from child process without taking perf hit of routing through callbacks.\n+                StandardOutputObserver = null,\n+                StandardErrorObserver = null,\n+\n+                // Don't buffer any output\n+                MaxLengthInMemory = 0,\n+            };\n+\n+            // FileAccessManifest.AddScope is used to define the list of files which the running process is allowed to access and what kinds of file accesses are allowed\n+            // Tracker internally uses AbsolutePath.Invalid to represent the root, just like Unix '/' root.\n+            // this code allows all types of accesses for all files\n+            info.FileAccessManifest.AddScope(\n+                AbsolutePath.Invalid,\n+                FileAccessPolicy.MaskNothing,\n+                FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);\n+\n+            // Support shared compilation by allowing VBCSCompiler to break away. Note that this requires observers to observe the shared compilation requests to ensure all\n+            // file accesses are considered. Also allow the MSVC vctip.exe telemetry service process to break away to allow a single vctip.exe to serve multiple parallel targets.\n+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = NativeMethodsShared.IsWindows\n+                ? new string[] { \"VBCSCompiler.exe\", \"vctip.exe\" }\n+                : new string[] { \"VBCSCompiler\" }; ;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Hmmm, not sure about this one. Today in QuickBuild we don't allow `rzc` to break away, but I'm pretty sure it uses the same property to enable shared compilation, so I'm not sure how this works today...\r\n\r\nI think I'll need to look into that a bit deeper. It certainly sucks to have this list to begin with though...",
              "createdAt": "2023-08-24T23:31:34Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -176,12 +192,83 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)\n                     NativeMethodsShared.CloseHandle(processInfo.hThread);\n                 }\n \n-                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", childProcessId, exeName);\n+                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", childProcessId, msbuildExe);\n                 return Process.GetProcessById(childProcessId);\n             }\n         }\n \n-        private Process DisableMSBuildServer(Func<Process> func)\n+        private static Process StartDetouredProcess(string msbuildExe, string commandLineArgs, IBuildComponentHost componentHost, int nodeId)\n+        {\n+            IFileAccessManager fileAccessManager = (IFileAccessManager)componentHost.GetComponent(BuildComponentType.FileAccessManager);\n+\n+            var eventListener = new DetoursEventListener(fileAccessManager, nodeId);\n+            eventListener.SetMessageHandlingFlags(MessageHandlingFlags.DebugMessageNotify | MessageHandlingFlags.FileAccessNotify | MessageHandlingFlags.ProcessDataNotify | MessageHandlingFlags.ProcessDetoursStatusNotify);\n+\n+            var info = new SandboxedProcessInfo(\n+                fileStorage: null, // Don't write stdout/stderr to files\n+                fileName: msbuildExe,\n+                disableConHostSharing: false,\n+                detoursEventListener: eventListener,\n+                createJobObjectForCurrentProcess: false)\n+            {\n+                SandboxKind = SandboxKind.Default,\n+                PipDescription = \"MSBuild\",\n+                PipSemiStableHash = 0,\n+                Arguments = commandLineArgs,\n+                EnvironmentVariables = EnvironmentalBuildParameters.Instance,\n+\n+                // Allow parent conhost sharing (above) and turn off stream observers to allow passing through stdout, stderr and\n+                // console API calls (e.g. Windows SetConsoleColor()) from child process without taking perf hit of routing through callbacks.\n+                StandardOutputObserver = null,\n+                StandardErrorObserver = null,\n+\n+                // Don't buffer any output\n+                MaxLengthInMemory = 0,\n+            };\n+\n+            // FileAccessManifest.AddScope is used to define the list of files which the running process is allowed to access and what kinds of file accesses are allowed\n+            // Tracker internally uses AbsolutePath.Invalid to represent the root, just like Unix '/' root.\n+            // this code allows all types of accesses for all files\n+            info.FileAccessManifest.AddScope(\n+                AbsolutePath.Invalid,\n+                FileAccessPolicy.MaskNothing,\n+                FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);\n+\n+            // Support shared compilation by allowing VBCSCompiler to break away. Note that this requires observers to observe the shared compilation requests to ensure all\n+            // file accesses are considered. Also allow the MSVC vctip.exe telemetry service process to break away to allow a single vctip.exe to serve multiple parallel targets.\n+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = NativeMethodsShared.IsWindows\n+                ? new string[] { \"VBCSCompiler.exe\", \"vctip.exe\" }\n+                : new string[] { \"VBCSCompiler\" }; ;",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we revert these (somehow?) if (!_reportFileAccesses)?",
              "createdAt": "2023-05-08T15:19:13Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -801,6 +804,27 @@ public string OutputResultsCacheFile\n             set => _outputResultsCacheFile = value;\n         }\n \n+        /// <summary>\n+        /// Gets or sets a value indicating whether file accesses should be reported to any configured project cache plugins.\n+        /// </summary>\n+        public bool ReportFileAccesses\n+        {\n+            get => _reportFileAccesses;\n+            set\n+            {\n+                _reportFileAccesses = value;\n+\n+                if (_reportFileAccesses)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I couldn't think of a good way to do that without introducing a bunch of nullables to disambiguate between explicit sets vs these defaultings. I'm open to ideas for how to best deal with this, if at all.",
              "createdAt": "2023-05-10T18:12:40Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -801,6 +804,27 @@ public string OutputResultsCacheFile\n             set => _outputResultsCacheFile = value;\n         }\n \n+        /// <summary>\n+        /// Gets or sets a value indicating whether file accesses should be reported to any configured project cache plugins.\n+        /// </summary>\n+        public bool ReportFileAccesses\n+        {\n+            get => _reportFileAccesses;\n+            set\n+            {\n+                _reportFileAccesses = value;\n+\n+                if (_reportFileAccesses)",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "I'm not 100% sure it actually makes sense to do that, since these are BuildParameters that users presumably don't use over and over again very often (if at all?). I think the normal pattern is to make a new BuildParameters per BuildRequest, but I wanted it at least considered \ud83d\ude42",
              "createdAt": "2023-05-10T21:11:14Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -801,6 +804,27 @@ public string OutputResultsCacheFile\n             set => _outputResultsCacheFile = value;\n         }\n \n+        /// <summary>\n+        /// Gets or sets a value indicating whether file accesses should be reported to any configured project cache plugins.\n+        /// </summary>\n+        public bool ReportFileAccesses\n+        {\n+            get => _reportFileAccesses;\n+            set\n+            {\n+                _reportFileAccesses = value;\n+\n+                if (_reportFileAccesses)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Extra semicolon",
              "createdAt": "2023-05-08T15:36:58Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -176,12 +192,83 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)\n                     NativeMethodsShared.CloseHandle(processInfo.hThread);\n                 }\n \n-                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", childProcessId, exeName);\n+                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", childProcessId, msbuildExe);\n                 return Process.GetProcessById(childProcessId);\n             }\n         }\n \n-        private Process DisableMSBuildServer(Func<Process> func)\n+        private static Process StartDetouredProcess(string msbuildExe, string commandLineArgs, IBuildComponentHost componentHost, int nodeId)\n+        {\n+            IFileAccessManager fileAccessManager = (IFileAccessManager)componentHost.GetComponent(BuildComponentType.FileAccessManager);\n+\n+            var eventListener = new DetoursEventListener(fileAccessManager, nodeId);\n+            eventListener.SetMessageHandlingFlags(MessageHandlingFlags.DebugMessageNotify | MessageHandlingFlags.FileAccessNotify | MessageHandlingFlags.ProcessDataNotify | MessageHandlingFlags.ProcessDetoursStatusNotify);\n+\n+            var info = new SandboxedProcessInfo(\n+                fileStorage: null, // Don't write stdout/stderr to files\n+                fileName: msbuildExe,\n+                disableConHostSharing: false,\n+                detoursEventListener: eventListener,\n+                createJobObjectForCurrentProcess: false)\n+            {\n+                SandboxKind = SandboxKind.Default,\n+                PipDescription = \"MSBuild\",\n+                PipSemiStableHash = 0,\n+                Arguments = commandLineArgs,\n+                EnvironmentVariables = EnvironmentalBuildParameters.Instance,\n+\n+                // Allow parent conhost sharing (above) and turn off stream observers to allow passing through stdout, stderr and\n+                // console API calls (e.g. Windows SetConsoleColor()) from child process without taking perf hit of routing through callbacks.\n+                StandardOutputObserver = null,\n+                StandardErrorObserver = null,\n+\n+                // Don't buffer any output\n+                MaxLengthInMemory = 0,\n+            };\n+\n+            // FileAccessManifest.AddScope is used to define the list of files which the running process is allowed to access and what kinds of file accesses are allowed\n+            // Tracker internally uses AbsolutePath.Invalid to represent the root, just like Unix '/' root.\n+            // this code allows all types of accesses for all files\n+            info.FileAccessManifest.AddScope(\n+                AbsolutePath.Invalid,\n+                FileAccessPolicy.MaskNothing,\n+                FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);\n+\n+            // Support shared compilation by allowing VBCSCompiler to break away. Note that this requires observers to observe the shared compilation requests to ensure all\n+            // file accesses are considered. Also allow the MSVC vctip.exe telemetry service process to break away to allow a single vctip.exe to serve multiple parallel targets.\n+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = NativeMethodsShared.IsWindows\n+                ? new string[] { \"VBCSCompiler.exe\", \"vctip.exe\" }\n+                : new string[] { \"VBCSCompiler\" }; ;",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do we care about CLS-compliance?",
              "createdAt": "2023-05-08T15:44:14Z",
              "path": "src/Framework/FileAccess/FileAccessData.cs",
              "diffHunk": "@@ -0,0 +1,32 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Framework.FileAccess\n+{\n+    /// <summary>\n+    /// File access data.\n+    /// </summary>\n+    /// <param name=\"Operation\">The operation that performed the file access.</param>\n+    /// <param name=\"RequestedAccess\">The requested access.</param>\n+    /// <param name=\"ProcessId\">The process id.</param>\n+    /// <param name=\"Error\">The error code of the operation.</param>\n+    /// <param name=\"DesiredAccess\">The desired access.</param>\n+    /// <param name=\"FlagsAndAttributes\">The file flags and attributes.</param>\n+    /// <param name=\"Path\">The path being accessed.</param>\n+    /// <param name=\"ProcessArgs\">The process arguments.</param>\n+    /// <param name=\"IsAnAugmentedFileAccess\">Whether the file access is augmented.</param>\n+    public readonly record struct FileAccessData(\n+        ReportedFileOperation Operation,\n+        RequestedAccess RequestedAccess,\n+\n+        // TODO dshepelev: Fix suppression.\n+#pragma warning disable CS3001, CS3003 // Argument type is not CLS-compliant; Type is not CLS-compliant.",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "From what I understand, it's only relevant for libraries that expect to be used by arbitrary .NET languages. This is only used by MSBuild, right? If so, it should only be used from C# files, right? If that's the case, I don't think we should need to care about this.",
              "createdAt": "2023-05-08T22:15:04Z",
              "path": "src/Framework/FileAccess/FileAccessData.cs",
              "diffHunk": "@@ -0,0 +1,32 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Framework.FileAccess\n+{\n+    /// <summary>\n+    /// File access data.\n+    /// </summary>\n+    /// <param name=\"Operation\">The operation that performed the file access.</param>\n+    /// <param name=\"RequestedAccess\">The requested access.</param>\n+    /// <param name=\"ProcessId\">The process id.</param>\n+    /// <param name=\"Error\">The error code of the operation.</param>\n+    /// <param name=\"DesiredAccess\">The desired access.</param>\n+    /// <param name=\"FlagsAndAttributes\">The file flags and attributes.</param>\n+    /// <param name=\"Path\">The path being accessed.</param>\n+    /// <param name=\"ProcessArgs\">The process arguments.</param>\n+    /// <param name=\"IsAnAugmentedFileAccess\">Whether the file access is augmented.</param>\n+    public readonly record struct FileAccessData(\n+        ReportedFileOperation Operation,\n+        RequestedAccess RequestedAccess,\n+\n+        // TODO dshepelev: Fix suppression.\n+#pragma warning disable CS3001, CS3003 // Argument type is not CLS-compliant; Type is not CLS-compliant.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Pushing a change to suppress these more cleanly.",
              "createdAt": "2023-08-24T16:59:58Z",
              "path": "src/Framework/FileAccess/FileAccessData.cs",
              "diffHunk": "@@ -0,0 +1,32 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Framework.FileAccess\n+{\n+    /// <summary>\n+    /// File access data.\n+    /// </summary>\n+    /// <param name=\"Operation\">The operation that performed the file access.</param>\n+    /// <param name=\"RequestedAccess\">The requested access.</param>\n+    /// <param name=\"ProcessId\">The process id.</param>\n+    /// <param name=\"Error\">The error code of the operation.</param>\n+    /// <param name=\"DesiredAccess\">The desired access.</param>\n+    /// <param name=\"FlagsAndAttributes\">The file flags and attributes.</param>\n+    /// <param name=\"Path\">The path being accessed.</param>\n+    /// <param name=\"ProcessArgs\">The process arguments.</param>\n+    /// <param name=\"IsAnAugmentedFileAccess\">Whether the file access is augmented.</param>\n+    public readonly record struct FileAccessData(\n+        ReportedFileOperation Operation,\n+        RequestedAccess RequestedAccess,\n+\n+        // TODO dshepelev: Fix suppression.\n+#pragma warning disable CS3001, CS3003 // Argument type is not CLS-compliant; Type is not CLS-compliant.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Think this should also catch aggregate exceptions wrapping OCEs?",
              "createdAt": "2023-05-08T19:17:56Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2366,6 +2382,36 @@ private void HandleResult(int node, BuildResult result)\n                 configuration.ProjectTargets ??= result.ProjectTargets;\n             }\n \n+            // Only report results to the project cache services if it's the result for a build submission.\n+            // Note that graph builds create a submission for each node in the graph, so each node in the graph will be\n+            // handled here. This intentionally mirrors the behavior for cache requests, as it doesn't make sense to\n+            // report for projects which aren't going to be requested. Ideally, *any* request could be handled, but that\n+            // would require moving the cache service interactions to the Scheduler.\n+            if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission buildSubmission))\n+            {\n+                // The result may be associated with the build submission due to it being the submission which\n+                // caused the build, but not the actual request which was used with the build submission. Ensure\n+                // only the actual submission's request is considered.\n+                // Additionally, avoid considering proxy targets which are already the result of a cache hit.\n+                if (buildSubmission.BuildRequest != null\n+                    && buildSubmission.BuildRequest.ConfigurationId == configuration.ConfigurationId\n+                    && buildSubmission.BuildRequest.ProxyTargets == null\n+                    && _projectCacheService.ShouldUseCache(configuration))\n+                {\n+                    BuildEventContext buildEventContext = _projectStartedEvents.TryGetValue(result.SubmissionId, out BuildEventArgs buildEventArgs)\n+                        ? buildEventArgs.BuildEventContext\n+                        : new BuildEventContext(result.SubmissionId, node, configuration.Project?.EvaluationId ?? BuildEventContext.InvalidEvaluationId, configuration.ConfigurationId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);\n+                    try\n+                    {\n+                        _projectCacheService.HandleBuildResultAsync(configuration, result, buildEventContext, _executionCancellationTokenSource.Token).Wait();\n+                    }\n+                    catch (OperationCanceledException)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't think StartInternal is used in other places (unless you added some). Is there a reason the error checking should be in Start as opposed to StartInternal? If we were to add a new thing that calls StartInternal, it feels like it should still verify that MSBuild is there...",
              "createdAt": "2023-05-08T19:38:51Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -41,10 +40,40 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)\n                 throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n             }\n \n+            // Disable MSBuild server for a child process.\n+            // In case of starting msbuild server it prevents an infinite recurson. In case of starting msbuild node we also do not want this variable to be set.\n+            return DisableMSBuildServer(() => StartInternal(msbuildLocation, commandLineArgs, componentHost, nodeId));\n+        }\n+\n+        private static Process StartInternal(string msbuildLocation, string commandLineArgs, IBuildComponentHost componentHost, int nodeId)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I... have no idea why I moved that. Probably remnants of previous changes. I'll move it back, or come back with a reason why I did it.",
              "createdAt": "2023-05-10T18:17:46Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -41,10 +40,40 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)\n                 throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n             }\n \n+            // Disable MSBuild server for a child process.\n+            // In case of starting msbuild server it prevents an infinite recurson. In case of starting msbuild node we also do not want this variable to be set.\n+            return DisableMSBuildServer(() => StartInternal(msbuildLocation, commandLineArgs, componentHost, nodeId));\n+        }\n+\n+        private static Process StartInternal(string msbuildLocation, string commandLineArgs, IBuildComponentHost componentHost, int nodeId)",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think you have to remove this and fall back to dotnet-public.",
              "createdAt": "2023-05-08T19:39:22Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -6,6 +6,8 @@\n     <add key=\"dotnet-public\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public/nuget/v3/index.json\" />\n     <add key=\"dotnet-tools\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json\" />\n     <add key=\"dotnet6\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json\" />\n+    <add key=\"BuildXL\" value=\"https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json\" />\n+    <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this intended to be experimental long-term, or are you just saying it's new, so there may be bugs?",
              "createdAt": "2023-05-08T19:43:17Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -861,6 +861,18 @@\n       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.\n     </comment>\n   </data>\n+  <data name=\"HelpMessage_42_ReportFileAccessesSwitch\" Visibility=\"Public\">\n+    <value>  -reportFileAccesses[:True|False]\n+                     Causes MSBuild to report file accesses to any configured\n+                     project cache plugins.\n+\n+                     This flag is experimental and may not work as intended.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It's just new so may have bugs",
              "createdAt": "2023-05-10T18:18:19Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -861,6 +861,18 @@\n       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.\n     </comment>\n   </data>\n+  <data name=\"HelpMessage_42_ReportFileAccessesSwitch\" Visibility=\"Public\">\n+    <value>  -reportFileAccesses[:True|False]\n+                     Causes MSBuild to report file accesses to any configured\n+                     project cache plugins.\n+\n+                     This flag is experimental and may not work as intended.",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "@rainersigwald is welcome to disagree, but my impulse is to say things that we're committed to keeping in the product shouldn't be labeled experimental. As a user, that would deter me from actually using the feature and filing bugs, and in the long run, that \"experimental\" note would probably stay in the product for a long time. I'd rather just try to be extra aggressive with resolving bugs quickly.",
              "createdAt": "2023-05-10T21:13:43Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -861,6 +861,18 @@\n       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.\n     </comment>\n   </data>\n+  <data name=\"HelpMessage_42_ReportFileAccessesSwitch\" Visibility=\"Public\">\n+    <value>  -reportFileAccesses[:True|False]\n+                     Causes MSBuild to report file accesses to any configured\n+                     project cache plugins.\n+\n+                     This flag is experimental and may not work as intended.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I approve of the current explicit warning.",
              "createdAt": "2023-08-24T16:16:42Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -861,6 +861,18 @@\n       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.\n     </comment>\n   </data>\n+  <data name=\"HelpMessage_42_ReportFileAccessesSwitch\" Visibility=\"Public\">\n+    <value>  -reportFileAccesses[:True|False]\n+                     Causes MSBuild to report file accesses to any configured\n+                     project cache plugins.\n+\n+                     This flag is experimental and may not work as intended.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Perhaps specify the valid values?",
              "createdAt": "2023-05-08T19:43:38Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -1274,6 +1286,15 @@\n     <value>MSBUILD : error MSB1049: The {0} parameter must be specified</value>\n     <comment>{StrBegin=\"MSBUILD : error MSB1049: \"}</comment>\n   </data>\n+  <data name=\"InvalidReportFileAccessesValue\" UESanitized=\"true\" Visibility=\"Public\">\n+    <value>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</value>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This seems really inconsisten. Eg I was going to try just following what the error message is if I did ` /lowPriority:Foo`, but that throws an exception due to a missing resource! This does match the error the `/graph:Foo` gives though.",
              "createdAt": "2023-06-13T21:20:02Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -1274,6 +1286,15 @@\n     <value>MSBUILD : error MSB1049: The {0} parameter must be specified</value>\n     <comment>{StrBegin=\"MSBUILD : error MSB1049: \"}</comment>\n   </data>\n+  <data name=\"InvalidReportFileAccessesValue\" UESanitized=\"true\" Visibility=\"Public\">\n+    <value>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</value>",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Oops \ud83d\ude05 That's a bug.",
              "createdAt": "2023-06-13T22:28:02Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -1274,6 +1286,15 @@\n     <value>MSBUILD : error MSB1049: The {0} parameter must be specified</value>\n     <comment>{StrBegin=\"MSBUILD : error MSB1049: \"}</comment>\n   </data>\n+  <data name=\"InvalidReportFileAccessesValue\" UESanitized=\"true\" Visibility=\"Public\">\n+    <value>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</value>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Made https://github.com/dotnet/msbuild/pull/8880",
              "createdAt": "2023-06-13T22:45:00Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -1274,6 +1286,15 @@\n     <value>MSBUILD : error MSB1049: The {0} parameter must be specified</value>\n     <comment>{StrBegin=\"MSBUILD : error MSB1049: \"}</comment>\n   </data>\n+  <data name=\"InvalidReportFileAccessesValue\" UESanitized=\"true\" Visibility=\"Public\">\n+    <value>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</value>",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How does this affect performance? In the worst case, I'm imagining grabbing this lock every time a file is touched across every thread on every node...which could basically kill any multithreading in tasks if those threads touch a lot of files. I'm particularly interested in how this affects a C++ build with few processes (/m:4, for instance) but many processors.",
              "createdAt": "2023-05-08T21:56:30Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private readonly ReaderWriterLockSlim _handlersLock = new();\n+        private List<Action<BuildRequest, FileAccessData>> _fileAccessHandlers = new();\n+        private List<Action<BuildRequest, ProcessData>> _processHandlers = new();\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new FileAccessManager();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;\n+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _scheduler = null;\n+            _configCache = null;\n+        }\n+\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)\n+        {\n+            BuildRequest? buildRequest = GetBuildRequest(nodeId);\n+            if (buildRequest != null)\n+            {\n+                _handlersLock.EnterReadLock();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "My (possibly flawed) understanding is that locks are pretty cheap if there is no contention, and we're only getting a read lock here, so the only contention would be if there are writes.\r\n\r\nI'm open to suggestions for how to manage this with better perf though.",
              "createdAt": "2023-06-13T21:22:04Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private readonly ReaderWriterLockSlim _handlersLock = new();\n+        private List<Action<BuildRequest, FileAccessData>> _fileAccessHandlers = new();\n+        private List<Action<BuildRequest, ProcessData>> _processHandlers = new();\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new FileAccessManager();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;\n+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _scheduler = null;\n+            _configCache = null;\n+        }\n+\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)\n+        {\n+            BuildRequest? buildRequest = GetBuildRequest(nodeId);\n+            if (buildRequest != null)\n+            {\n+                _handlersLock.EnterReadLock();",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why do we actually care about processes? I ask because I wouldn't have thought the ProjectCache would care about them as far as delivering results.",
              "createdAt": "2023-05-08T21:57:27Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private readonly ReaderWriterLockSlim _handlersLock = new();\n+        private List<Action<BuildRequest, FileAccessData>> _fileAccessHandlers = new();\n+        private List<Action<BuildRequest, ProcessData>> _processHandlers = new();\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new FileAccessManager();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;\n+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _scheduler = null;\n+            _configCache = null;\n+        }\n+\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)\n+        {\n+            BuildRequest? buildRequest = GetBuildRequest(nodeId);\n+            if (buildRequest != null)\n+            {\n+                _handlersLock.EnterReadLock();\n+                try\n+                {\n+                    foreach (Action<BuildRequest, FileAccessData> handler in _fileAccessHandlers)\n+                    {\n+                        handler.Invoke(buildRequest, fileAccessData);\n+                    }\n+                }\n+                finally\n+                {\n+                    _handlersLock.ExitReadLock();\n+                }\n+            }\n+        }\n+\n+        public void ReportProcess(ProcessData processData, int nodeId)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Somewhat for logging, and somewhat for \"extra validation\" that a plugin could do.\r\n\r\nFor example in QuickBuild, we have an interface-aware caching feature (basically ref assemblies), which validates that it can classify every write, and part of that requires knowing which process did the writes. Eg we expect csc to write the dll, but then if we see other non-copy writes to that dll from other processes, we know it's not necessarily a safe output to replay since we have no idea what the build is doing to the file.",
              "createdAt": "2023-05-10T18:20:57Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private readonly ReaderWriterLockSlim _handlersLock = new();\n+        private List<Action<BuildRequest, FileAccessData>> _fileAccessHandlers = new();\n+        private List<Action<BuildRequest, ProcessData>> _processHandlers = new();\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new FileAccessManager();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;\n+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _scheduler = null;\n+            _configCache = null;\n+        }\n+\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)\n+        {\n+            BuildRequest? buildRequest = GetBuildRequest(nodeId);\n+            if (buildRequest != null)\n+            {\n+                _handlersLock.EnterReadLock();\n+                try\n+                {\n+                    foreach (Action<BuildRequest, FileAccessData> handler in _fileAccessHandlers)\n+                    {\n+                        handler.Invoke(buildRequest, fileAccessData);\n+                    }\n+                }\n+                finally\n+                {\n+                    _handlersLock.ExitReadLock();\n+                }\n+            }\n+        }\n+\n+        public void ReportProcess(ProcessData processData, int nodeId)",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why do we care about all of these things? I can imagine it being different if, for instance, we're reading vs. writing the file, but this is a lot more fine-grained than I would've expected.",
              "createdAt": "2023-05-08T22:28:44Z",
              "path": "src/Framework/FileAccess/ReportedFileOperation.cs",
              "diffHunk": "@@ -0,0 +1,257 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Framework.FileAccess\n+{\n+    /// <summary>\n+    /// Which operation resulted in a reported file access.\n+    /// </summary>\n+    public enum ReportedFileOperation : byte\n+    {\n+        /// <summary>\n+        /// Unknown operation.\n+        /// </summary>\n+        Unknown = 0,\n+\n+        /// <summary>\n+        /// CreateFile.\n+        /// </summary>\n+        CreateFile,\n+\n+        /// <summary>\n+        /// CreateProcess.\n+        /// </summary>\n+        CreateProcess,\n+\n+        /// <summary>\n+        /// GetFileAttributes.\n+        /// </summary>\n+        GetFileAttributes,",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It's up to the plugin to determine what it cares about. For example, for QuckBuild (and my prototype plugin), I currently don't care about probes. But BXL does, and that's the more correct thing to do.\r\n\r\nAlso, if you do care about probes, then the file existance is what matters there, while for reads the file content matters.\r\n\r\nIt can also be helpful to know whether the read/write is a copy or not since some optimizations can (in theory) be made if we know information about the source file and can infer that same information about the destination (assuming no other writes to the destination).",
              "createdAt": "2023-05-10T18:23:38Z",
              "path": "src/Framework/FileAccess/ReportedFileOperation.cs",
              "diffHunk": "@@ -0,0 +1,257 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+namespace Microsoft.Build.Framework.FileAccess\n+{\n+    /// <summary>\n+    /// Which operation resulted in a reported file access.\n+    /// </summary>\n+    public enum ReportedFileOperation : byte\n+    {\n+        /// <summary>\n+        /// Unknown operation.\n+        /// </summary>\n+        Unknown = 0,\n+\n+        /// <summary>\n+        /// CreateFile.\n+        /// </summary>\n+        CreateFile,\n+\n+        /// <summary>\n+        /// CreateProcess.\n+        /// </summary>\n+        CreateProcess,\n+\n+        /// <summary>\n+        /// GetFileAttributes.\n+        /// </summary>\n+        GetFileAttributes,",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How does this connect? If it wasn't using S.D.Contract before, what changed?",
              "createdAt": "2023-05-08T22:33:45Z",
              "path": "src/Build/Collections/RetrievableEntryHashSet/HashSet.cs",
              "diffHunk": "@@ -38,6 +38,8 @@\n \n #nullable disable\n \n+#pragma warning disable RA001 // Do not use System.Diagnostics.Contract class.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This is silly :(. The `RuntimeContracts` package adds an analyzer which forbids the use of `System.Diagnostics.Contract`. So effectively if your dependencies use `RuntimeContracts`, it attempts to force itself on your as well.\r\n\r\nWe should evaluate the `RuntimeContracts` dependency.",
              "createdAt": "2023-05-10T18:25:00Z",
              "path": "src/Build/Collections/RetrievableEntryHashSet/HashSet.cs",
              "diffHunk": "@@ -38,6 +38,8 @@\n \n #nullable disable\n \n+#pragma warning disable RA001 // Do not use System.Diagnostics.Contract class.",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Please put this in the comment :)",
              "createdAt": "2023-08-24T16:55:40Z",
              "path": "src/Build/Collections/RetrievableEntryHashSet/HashSet.cs",
              "diffHunk": "@@ -38,6 +38,8 @@\n \n #nullable disable\n \n+#pragma warning disable RA001 // Do not use System.Diagnostics.Contract class.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this already in VS? Sorry if that's a stupid question \ud83d\ude42",
              "createdAt": "2023-05-08T22:37:06Z",
              "path": "eng/dependabot/Packages.props",
              "diffHunk": "@@ -13,6 +13,9 @@\n     <PackageVersion Include=\"BenchmarkDotNet\" Version=\"0.13.1\" />\n     <PackageVersion Update=\"BenchmarkDotNet\" Condition=\"'$(BenchmarkDotNetVersion)' != ''\" Version=\"$(BenchmarkDotNetVersion)\" />\n \n+    <PackageVersion Include=\"Microsoft.BuildXL.Processes\" Version=\"0.1.0-20230428.1\" />\n+    <PackageVersion Update=\"Microsoft.BuildXL.Processes\" Condition=\"'$(BuildXLProcessesVersion)' != ''\" Version=\"$(BuildXLProcessesVersion)\" />",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Nope, VS doesn't know about BXL at all.\r\n\r\nFor this Include/Update pattern, I'm just following the patterns in this file, so definitely correct me if I've done something wonky. I'm kinda assuming I'll need to make changes for this new dependency anyway though.",
              "createdAt": "2023-05-10T18:26:23Z",
              "path": "eng/dependabot/Packages.props",
              "diffHunk": "@@ -13,6 +13,9 @@\n     <PackageVersion Include=\"BenchmarkDotNet\" Version=\"0.13.1\" />\n     <PackageVersion Update=\"BenchmarkDotNet\" Condition=\"'$(BenchmarkDotNetVersion)' != ''\" Version=\"$(BenchmarkDotNetVersion)\" />\n \n+    <PackageVersion Include=\"Microsoft.BuildXL.Processes\" Version=\"0.1.0-20230428.1\" />\n+    <PackageVersion Update=\"Microsoft.BuildXL.Processes\" Condition=\"'$(BuildXLProcessesVersion)' != ''\" Version=\"$(BuildXLProcessesVersion)\" />",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Can you make an exp/ branch to validate VS is ok with this? I'm not 100% clear on when VS notices that we have a new dependency and gets unhappy\u2014I think it's specifically if we load the assembly at any point in a scenario they test, but it's possible it's anything we even claim we sometimes need. In any event, adding new assemblies to VS can be quite annoying, so if VS is unhappy about it, I would try to add it (separately?) then come back to this afterwards.",
              "createdAt": "2023-05-10T21:25:27Z",
              "path": "eng/dependabot/Packages.props",
              "diffHunk": "@@ -13,6 +13,9 @@\n     <PackageVersion Include=\"BenchmarkDotNet\" Version=\"0.13.1\" />\n     <PackageVersion Update=\"BenchmarkDotNet\" Condition=\"'$(BenchmarkDotNetVersion)' != ''\" Version=\"$(BenchmarkDotNetVersion)\" />\n \n+    <PackageVersion Include=\"Microsoft.BuildXL.Processes\" Version=\"0.1.0-20230428.1\" />\n+    <PackageVersion Update=\"Microsoft.BuildXL.Processes\" Condition=\"'$(BuildXLProcessesVersion)' != ''\" Version=\"$(BuildXLProcessesVersion)\" />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If I remember correctly, this is most often either MSBuild.exe or dotnet.exe depending on if it's framework or core. But it can also be `<random process>` if you load MSBuild via MSBuildLocator, so I think this is sometimes inaccurate.",
              "createdAt": "2023-05-08T22:40:27Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -121,14 +137,14 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)\n                     throw new NodeFailedToLaunchException(ex);\n                 }\n \n-                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", process.Id, exeName);\n+                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", process.Id, msbuildExe);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I don't really know why I renamed this other than it being named `\"msbuildLocation\"` in the common case anyway. But the rename itself isn't really important to my change.",
              "createdAt": "2023-05-10T18:28:10Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -121,14 +137,14 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)\n                     throw new NodeFailedToLaunchException(ex);\n                 }\n \n-                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", process.Id, exeName);\n+                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", process.Id, msbuildExe);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "I agree but would prefer to not make assumptions that aren't true in less common cases \ud83d\ude42",
              "createdAt": "2023-05-10T21:28:25Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -121,14 +137,14 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)\n                     throw new NodeFailedToLaunchException(ex);\n                 }\n \n-                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", process.Id, exeName);\n+                CommunicationsUtilities.Trace(\"Successfully launched {1} node with PID {0}\", process.Id, msbuildExe);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I know it's only stack allocations, since these are structs, but there are _a lot_ of them, and then we copy them around every time we send them to any handlers registered (though there's presumably only one of those) and push that through a bunch of layers of function calls. Maybe it's silly to worry about that sort of thing, but it would be nice to have some validation the impact of this.",
              "createdAt": "2023-05-08T22:45:21Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -200,5 +287,91 @@ private Process DisableMSBuildServer(Func<Process> func)\n                 }\n             }\n         }\n+\n+        private sealed class EnvironmentalBuildParameters : BuildParameters.IBuildParameters\n+        {\n+            private readonly Dictionary<string, string> _envVars;\n+\n+            private EnvironmentalBuildParameters()\n+            {\n+                var envVars = new Dictionary<string, string>();\n+                foreach (DictionaryEntry baseVar in Environment.GetEnvironmentVariables())\n+                {\n+                    envVars.Add((string)baseVar.Key, (string)baseVar.Value);\n+                }\n+\n+                _envVars = envVars;\n+            }\n+\n+            private EnvironmentalBuildParameters(Dictionary<string, string> envVars)\n+            {\n+                _envVars = envVars;\n+            }\n+\n+            public static EnvironmentalBuildParameters Instance { get; } = new EnvironmentalBuildParameters();\n+\n+            public string this[string key] => _envVars[key];\n+\n+            public BuildParameters.IBuildParameters Select(IEnumerable<string> keys)\n+                => new EnvironmentalBuildParameters(keys.ToDictionary(key => key, key => _envVars[key]));\n+\n+            public BuildParameters.IBuildParameters Override(IEnumerable<KeyValuePair<string, string>> parameters)\n+            {\n+                var copy = new Dictionary<string, string>(_envVars);\n+                foreach (KeyValuePair<string, string> param in parameters)\n+                {\n+                    copy[param.Key] = param.Value;\n+                }\n+\n+                return new EnvironmentalBuildParameters(copy);\n+            }\n+\n+            public IReadOnlyDictionary<string, string> ToDictionary() => _envVars;\n+\n+            public bool ContainsKey(string key) => _envVars.ContainsKey(key);\n+        }\n+\n+        private sealed class DetoursEventListener : IDetoursEventListener\n+        {\n+            private readonly IFileAccessManager _fileAccessManager;\n+            private readonly int _nodeId;\n+\n+            public DetoursEventListener(IFileAccessManager fileAccessManager, int nodeId)\n+            {\n+                _fileAccessManager = fileAccessManager;\n+                _nodeId = nodeId;\n+            }\n+\n+            public override void HandleDebugMessage(DebugData debugData)\n+            {\n+            }\n+\n+            public override void HandleFileAccess(FileAccessData fileAccessData) => _fileAccessManager.ReportFileAccess(\n+                new Framework.FileAccess.FileAccessData(",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yes, there's certainly some impact here. Detours itself adds ~10% overhead on its own, so the idea behind this would be that caching would need to make up for the increased overhead.",
              "createdAt": "2023-05-10T18:29:28Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -200,5 +287,91 @@ private Process DisableMSBuildServer(Func<Process> func)\n                 }\n             }\n         }\n+\n+        private sealed class EnvironmentalBuildParameters : BuildParameters.IBuildParameters\n+        {\n+            private readonly Dictionary<string, string> _envVars;\n+\n+            private EnvironmentalBuildParameters()\n+            {\n+                var envVars = new Dictionary<string, string>();\n+                foreach (DictionaryEntry baseVar in Environment.GetEnvironmentVariables())\n+                {\n+                    envVars.Add((string)baseVar.Key, (string)baseVar.Value);\n+                }\n+\n+                _envVars = envVars;\n+            }\n+\n+            private EnvironmentalBuildParameters(Dictionary<string, string> envVars)\n+            {\n+                _envVars = envVars;\n+            }\n+\n+            public static EnvironmentalBuildParameters Instance { get; } = new EnvironmentalBuildParameters();\n+\n+            public string this[string key] => _envVars[key];\n+\n+            public BuildParameters.IBuildParameters Select(IEnumerable<string> keys)\n+                => new EnvironmentalBuildParameters(keys.ToDictionary(key => key, key => _envVars[key]));\n+\n+            public BuildParameters.IBuildParameters Override(IEnumerable<KeyValuePair<string, string>> parameters)\n+            {\n+                var copy = new Dictionary<string, string>(_envVars);\n+                foreach (KeyValuePair<string, string> param in parameters)\n+                {\n+                    copy[param.Key] = param.Value;\n+                }\n+\n+                return new EnvironmentalBuildParameters(copy);\n+            }\n+\n+            public IReadOnlyDictionary<string, string> ToDictionary() => _envVars;\n+\n+            public bool ContainsKey(string key) => _envVars.ContainsKey(key);\n+        }\n+\n+        private sealed class DetoursEventListener : IDetoursEventListener\n+        {\n+            private readonly IFileAccessManager _fileAccessManager;\n+            private readonly int _nodeId;\n+\n+            public DetoursEventListener(IFileAccessManager fileAccessManager, int nodeId)\n+            {\n+                _fileAccessManager = fileAccessManager;\n+                _nodeId = nodeId;\n+            }\n+\n+            public override void HandleDebugMessage(DebugData debugData)\n+            {\n+            }\n+\n+            public override void HandleFileAccess(FileAccessData fileAccessData) => _fileAccessManager.ReportFileAccess(\n+                new Framework.FileAccess.FileAccessData(",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Ok. I look forward to seeing the net impact.",
              "createdAt": "2023-05-10T21:29:35Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeLauncher.cs",
              "diffHunk": "@@ -200,5 +287,91 @@ private Process DisableMSBuildServer(Func<Process> func)\n                 }\n             }\n         }\n+\n+        private sealed class EnvironmentalBuildParameters : BuildParameters.IBuildParameters\n+        {\n+            private readonly Dictionary<string, string> _envVars;\n+\n+            private EnvironmentalBuildParameters()\n+            {\n+                var envVars = new Dictionary<string, string>();\n+                foreach (DictionaryEntry baseVar in Environment.GetEnvironmentVariables())\n+                {\n+                    envVars.Add((string)baseVar.Key, (string)baseVar.Value);\n+                }\n+\n+                _envVars = envVars;\n+            }\n+\n+            private EnvironmentalBuildParameters(Dictionary<string, string> envVars)\n+            {\n+                _envVars = envVars;\n+            }\n+\n+            public static EnvironmentalBuildParameters Instance { get; } = new EnvironmentalBuildParameters();\n+\n+            public string this[string key] => _envVars[key];\n+\n+            public BuildParameters.IBuildParameters Select(IEnumerable<string> keys)\n+                => new EnvironmentalBuildParameters(keys.ToDictionary(key => key, key => _envVars[key]));\n+\n+            public BuildParameters.IBuildParameters Override(IEnumerable<KeyValuePair<string, string>> parameters)\n+            {\n+                var copy = new Dictionary<string, string>(_envVars);\n+                foreach (KeyValuePair<string, string> param in parameters)\n+                {\n+                    copy[param.Key] = param.Value;\n+                }\n+\n+                return new EnvironmentalBuildParameters(copy);\n+            }\n+\n+            public IReadOnlyDictionary<string, string> ToDictionary() => _envVars;\n+\n+            public bool ContainsKey(string key) => _envVars.ContainsKey(key);\n+        }\n+\n+        private sealed class DetoursEventListener : IDetoursEventListener\n+        {\n+            private readonly IFileAccessManager _fileAccessManager;\n+            private readonly int _nodeId;\n+\n+            public DetoursEventListener(IFileAccessManager fileAccessManager, int nodeId)\n+            {\n+                _fileAccessManager = fileAccessManager;\n+                _nodeId = nodeId;\n+            }\n+\n+            public override void HandleDebugMessage(DebugData debugData)\n+            {\n+            }\n+\n+            public override void HandleFileAccess(FileAccessData fileAccessData) => _fileAccessManager.ReportFileAccess(\n+                new Framework.FileAccess.FileAccessData(",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is it not inefficient to make a new dictionary every time we want to indicate that we accessed a file? I'll admit that we can't necessarily know that the global properties are all the same...if we cached something and copied it only when we notice it's different than it should be, that would improve things...but it would be nice to not even have to do that. (I do think this is another case in which I'm overly concerned about something reasonably minor, since I'm guessing these are on the order of 10-15 rather than 1000-1500, but I think it's still worth looking into, since it seems like we'll call this a lot.)",
              "createdAt": "2023-05-08T22:50:16Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -218,18 +229,45 @@ private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectIn\n                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheInitializationFailed\");\n                 }\n \n-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);\n+                FileAccessManager.HandlerRegistration handlerRegistration = _fileAccessManager.RegisterHandlers(\n+                    (buildRequest, fileAccessData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);\n+                    },\n+                    (buildRequest, processData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleProcess(fileAccessContext, processData);\n+                    });\n+\n+                return new ProjectCachePlugin(pluginTypeName, pluginInstance, handlerRegistration);\n             }\n             catch (Exception e)\n             {\n-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));\n+                return new ProjectCachePlugin(pluginTypeName, Instance: null, HandlerRegistration: null, ExceptionDispatchInfo.Capture(e));\n             }\n             finally\n             {\n                 MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);\n             }\n         }\n \n+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)\n+        {\n+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];\n+\n+            var globalProperties = new Dictionary<string, string>(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I'd love to avoid the allocations here. Personally I'd like to just expose `configuration.GlobalProperties` directly, but that's not a public type.\r\n\r\nIt would be possible to create a cache of dictionaries if we think that the unique set of global properties is small compared to the number of projects, and if the dictionary operations are fast enough (comparer impl). I'm not convinced it worth it, but I'm also not convinced it's not.",
              "createdAt": "2023-05-10T18:32:07Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -218,18 +229,45 @@ private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectIn\n                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheInitializationFailed\");\n                 }\n \n-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);\n+                FileAccessManager.HandlerRegistration handlerRegistration = _fileAccessManager.RegisterHandlers(\n+                    (buildRequest, fileAccessData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);\n+                    },\n+                    (buildRequest, processData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleProcess(fileAccessContext, processData);\n+                    });\n+\n+                return new ProjectCachePlugin(pluginTypeName, pluginInstance, handlerRegistration);\n             }\n             catch (Exception e)\n             {\n-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));\n+                return new ProjectCachePlugin(pluginTypeName, Instance: null, HandlerRegistration: null, ExceptionDispatchInfo.Capture(e));\n             }\n             finally\n             {\n                 MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);\n             }\n         }\n \n+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)\n+        {\n+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];\n+\n+            var globalProperties = new Dictionary<string, string>(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "You mean that PropertyDictionary isn't public? It's an IDictionary; can you just use that?\r\n\r\nThe main reasons I know of for global properties to change is for multitargeting and with the MSBuild task. The former should be a pretty small space of options, but I'll admit the latter...not so much.",
              "createdAt": "2023-05-10T21:58:41Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -218,18 +229,45 @@ private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectIn\n                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheInitializationFailed\");\n                 }\n \n-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);\n+                FileAccessManager.HandlerRegistration handlerRegistration = _fileAccessManager.RegisterHandlers(\n+                    (buildRequest, fileAccessData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);\n+                    },\n+                    (buildRequest, processData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleProcess(fileAccessContext, processData);\n+                    });\n+\n+                return new ProjectCachePlugin(pluginTypeName, pluginInstance, handlerRegistration);\n             }\n             catch (Exception e)\n             {\n-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));\n+                return new ProjectCachePlugin(pluginTypeName, Instance: null, HandlerRegistration: null, ExceptionDispatchInfo.Capture(e));\n             }\n             finally\n             {\n                 MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);\n             }\n         }\n \n+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)\n+        {\n+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];\n+\n+            var globalProperties = new Dictionary<string, string>(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I was wrong about the type being public (I was thinking `BuildRequestConfiguration`), however `PropertyDictionary` is an `IDictionary<string, ProjectPropertyInstance>` and `ProjectPropertyInstance` is mutable.",
              "createdAt": "2023-05-15T17:07:08Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -218,18 +229,45 @@ private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectIn\n                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheInitializationFailed\");\n                 }\n \n-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);\n+                FileAccessManager.HandlerRegistration handlerRegistration = _fileAccessManager.RegisterHandlers(\n+                    (buildRequest, fileAccessData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);\n+                    },\n+                    (buildRequest, processData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleProcess(fileAccessContext, processData);\n+                    });\n+\n+                return new ProjectCachePlugin(pluginTypeName, pluginInstance, handlerRegistration);\n             }\n             catch (Exception e)\n             {\n-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));\n+                return new ProjectCachePlugin(pluginTypeName, Instance: null, HandlerRegistration: null, ExceptionDispatchInfo.Capture(e));\n             }\n             finally\n             {\n                 MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);\n             }\n         }\n \n+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)\n+        {\n+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];\n+\n+            var globalProperties = new Dictionary<string, string>(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nDo you have to ToList here? Wondering if you can leave it as a set and pass that to the FileAccessContext below.",
              "createdAt": "2023-05-08T22:52:11Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -587,6 +631,82 @@ private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildReq\n             }\n         }\n \n+        public async Task HandleBuildResultAsync(\n+            BuildRequestConfiguration requestConfiguration,\n+            BuildResult buildResult,\n+            BuildEventContext buildEventContext,\n+            CancellationToken cancellationToken)\n+        {\n+            ErrorUtilities.VerifyThrowInternalNull(requestConfiguration.Project, nameof(requestConfiguration.Project));\n+\n+            if (_projectCachePlugins.IsEmpty)\n+            {\n+                return;\n+            }\n+\n+            // Filter to plugins which apply to the project, if any\n+            List<ProjectCacheDescriptor> projectCacheDescriptors = GetProjectCacheDescriptors(requestConfiguration.Project).ToList();\n+            if (projectCacheDescriptors.Count == 0)\n+            {\n+                return;\n+            }\n+\n+            var globalProperties = new Dictionary<string, string>(requestConfiguration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);\n+            foreach (ProjectPropertyInstance property in requestConfiguration.GlobalProperties)\n+            {\n+                globalProperties.Add(property.Name, property.EvaluatedValue);\n+            }\n+\n+            List<string> targets = buildResult.ResultsByTarget.Keys.ToList();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`FileAccessContext` exposes it as a `IReadOnlyList<string>`. I didn't want to expose the `ICollection<string>` directly since that has `Add` methods on it, although I guess I don't know if those would just throw or not. `IReadOnlyList<string>` is a \"better\" thing to expose, but the question I suppose is whether that's worth the allocation.",
              "createdAt": "2023-05-10T18:34:31Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -587,6 +631,82 @@ private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildReq\n             }\n         }\n \n+        public async Task HandleBuildResultAsync(\n+            BuildRequestConfiguration requestConfiguration,\n+            BuildResult buildResult,\n+            BuildEventContext buildEventContext,\n+            CancellationToken cancellationToken)\n+        {\n+            ErrorUtilities.VerifyThrowInternalNull(requestConfiguration.Project, nameof(requestConfiguration.Project));\n+\n+            if (_projectCachePlugins.IsEmpty)\n+            {\n+                return;\n+            }\n+\n+            // Filter to plugins which apply to the project, if any\n+            List<ProjectCacheDescriptor> projectCacheDescriptors = GetProjectCacheDescriptors(requestConfiguration.Project).ToList();\n+            if (projectCacheDescriptors.Count == 0)\n+            {\n+                return;\n+            }\n+\n+            var globalProperties = new Dictionary<string, string>(requestConfiguration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);\n+            foreach (ProjectPropertyInstance property in requestConfiguration.GlobalProperties)\n+            {\n+                globalProperties.Add(property.Name, property.EvaluatedValue);\n+            }\n+\n+            List<string> targets = buildResult.ResultsByTarget.Keys.ToList();",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\ud83d\udc4d\r\n\r\nThough you can consider whether you want to just log these on Stop rather than logging them twice. Since it looks like targetNames is only used for this log message, you can even consider creating it lazily only when MSBuildEventSource.Log.IsEnabled and this fires.",
              "createdAt": "2023-05-08T22:55:04Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -587,6 +631,82 @@ private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildReq\n             }\n         }\n \n+        public async Task HandleBuildResultAsync(\n+            BuildRequestConfiguration requestConfiguration,\n+            BuildResult buildResult,\n+            BuildEventContext buildEventContext,\n+            CancellationToken cancellationToken)\n+        {\n+            ErrorUtilities.VerifyThrowInternalNull(requestConfiguration.Project, nameof(requestConfiguration.Project));\n+\n+            if (_projectCachePlugins.IsEmpty)\n+            {\n+                return;\n+            }\n+\n+            // Filter to plugins which apply to the project, if any\n+            List<ProjectCacheDescriptor> projectCacheDescriptors = GetProjectCacheDescriptors(requestConfiguration.Project).ToList();\n+            if (projectCacheDescriptors.Count == 0)\n+            {\n+                return;\n+            }\n+\n+            var globalProperties = new Dictionary<string, string>(requestConfiguration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);\n+            foreach (ProjectPropertyInstance property in requestConfiguration.GlobalProperties)\n+            {\n+                globalProperties.Add(property.Name, property.EvaluatedValue);\n+            }\n+\n+            List<string> targets = buildResult.ResultsByTarget.Keys.ToList();\n+            string? targetNames = string.Join(\", \", targets);\n+\n+            FileAccessContext fileAccessContext = new(requestConfiguration.ProjectFullPath, globalProperties, targets);\n+\n+            var buildEventFileInfo = new BuildEventFileInfo(requestConfiguration.ProjectFullPath);\n+            var pluginLogger = new LoggingServiceToPluginLoggerAdapter(\n+                _loggingService,\n+                buildEventContext,\n+                buildEventFileInfo);\n+\n+            Task[] tasks = new Task[projectCacheDescriptors.Count];\n+            int idx = 0;\n+            foreach (ProjectCacheDescriptor projectCacheDescriptor in projectCacheDescriptors)\n+            {\n+                tasks[idx++] = Task.Run(\n+                    async () =>\n+                    {\n+                        ProjectCachePlugin plugin = await _projectCachePlugins[projectCacheDescriptor].Value;\n+\n+                        // Rethrow any initialization exception.\n+                        plugin.InitializationException?.Throw();\n+\n+                        ErrorUtilities.VerifyThrow(plugin.Instance != null, \"Plugin '{0}' instance is null\", plugin.Name);\n+\n+                        MSBuildEventSource.Log.ProjectCacheHandleBuildResultStart(plugin.Name, fileAccessContext.ProjectFullPath, targetNames);\n+                        try\n+                        {\n+                            await plugin.Instance!.HandleProjectFinishedAsync(fileAccessContext, buildResult, pluginLogger, cancellationToken);\n+                        }\n+                        catch (Exception e) when (e is not ProjectCacheException)\n+                        {\n+                            HandlePluginException(e, nameof(ProjectCachePluginBase.HandleProjectFinishedAsync));\n+                        }\n+                        finally\n+                        {\n+                            MSBuildEventSource.Log.ProjectCacheHandleBuildResultStop(plugin.Name, fileAccessContext.ProjectFullPath, targetNames);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this not throw with characters like `{`?",
              "createdAt": "2023-05-08T23:02:12Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -107,6 +134,25 @@ private void UnregisterHandlers(Action<BuildRequest, FileAccessData> fileAccessH\n             }\n         }\n \n+        public static void NotifyFileAccessCompletion(int globalRequestId)\n+        {\n+            // Make a dummy file access to use as a notification that the file accesses should be completed for a project.\n+            string filePath = FileAccessCompletionPrefix + globalRequestId.ToString();\n+            _ = File.Exists(filePath);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`{` isn't invalid :)\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/6445614/303dd060-316f-47ee-beea-5cbe9bc2ec22)\r\n",
              "createdAt": "2023-05-10T18:35:41Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -107,6 +134,25 @@ private void UnregisterHandlers(Action<BuildRequest, FileAccessData> fileAccessH\n             }\n         }\n \n+        public static void NotifyFileAccessCompletion(int globalRequestId)\n+        {\n+            // Make a dummy file access to use as a notification that the file accesses should be completed for a project.\n+            string filePath = FileAccessCompletionPrefix + globalRequestId.ToString();\n+            _ = File.Exists(filePath);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "\ud83d\ude2e",
              "createdAt": "2023-05-10T22:04:14Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -107,6 +134,25 @@ private void UnregisterHandlers(Action<BuildRequest, FileAccessData> fileAccessH\n             }\n         }\n \n+        public static void NotifyFileAccessCompletion(int globalRequestId)\n+        {\n+            // Make a dummy file access to use as a notification that the file accesses should be completed for a project.\n+            string filePath = FileAccessCompletionPrefix + globalRequestId.ToString();\n+            _ = File.Exists(filePath);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is GlobalRequestId project-specific? It sounds BuildRequest-specific, in which case I think you might have one project signaling that another is complete, so I figure it's smaller than that.",
              "createdAt": "2023-05-08T23:12:43Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -651,6 +653,11 @@ private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildReq\n                 return;\n             }\n \n+            if (_componentHost.BuildParameters.ReportFileAccesses)\n+            {\n+                _fileAccessManager.WaitForFileAccessReportCompletion(buildResult.GlobalRequestId, cancellationToken);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Based on the name, I assumed that `GlobalRequestId` is, well, global. Like unique to the build session.\r\n\r\nIf there's a better identifier to use, let me know.",
              "createdAt": "2023-05-10T18:36:44Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -651,6 +653,11 @@ private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildReq\n                 return;\n             }\n \n+            if (_componentHost.BuildParameters.ReportFileAccesses)\n+            {\n+                _fileAccessManager.WaitForFileAccessReportCompletion(buildResult.GlobalRequestId, cancellationToken);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Oh, I think I see what you're saying. It is intentional that this is BuildRequest specific, and yes that does mean that for a badly-described graph build there could be multiple BuildRequests per project with different sets of targets. However, BuildRequest is 1:1 with BuildResult, which is what is reported to the plugin, so that should be fine.",
              "createdAt": "2023-05-10T18:38:12Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -651,6 +653,11 @@ private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildReq\n                 return;\n             }\n \n+            if (_componentHost.BuildParameters.ReportFileAccesses)\n+            {\n+                _fileAccessManager.WaitForFileAccessReportCompletion(buildResult.GlobalRequestId, cancellationToken);",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why are we putting this after ReleaseAllCores? Seems like if we are skipping Reacquire, we should fully skip it...\r\n\r\nAlso, wouldn't skipping yield and reacquire have rather bad perf implications, potentially?",
              "createdAt": "2023-05-15T19:27:14Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -364,6 +370,12 @@ public void Reacquire()\n             // to release explicitly granted cores when reacquiring the node may lead to deadlocks.\n             ReleaseAllCores();\n \n+            // If file accesses are being reported yielding is a no-op so reacquire should be too.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "`RequestCores` (and `ReleaseCores`) are separate calls which are made. Although a caller *shouldn't* do this, they may rely on all the requested cores to be released on `Reacquire`. So we still want that behavior.\r\n\r\n> Also, wouldn't skipping yield and reacquire have rather bad perf implications, potentially?\r\n\r\nDoesn't seems like it at least in this case. Either way though, yielding doesn't work with Detours since we can't know who to attribute it to.",
              "createdAt": "2023-06-13T21:27:23Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -364,6 +370,12 @@ public void Reacquire()\n             // to release explicitly granted cores when reacquiring the node may lead to deadlocks.\n             ReleaseAllCores();\n \n+            // If file accesses are being reported yielding is a no-op so reacquire should be too.",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "It looks like this method is implemented exactly twice...I generally feel that interface methods should be properly implemented in every class that implements the interface if possible, and when you're the one creating the interface, do you think you could make a more restricted interface rather than having one implementation and one \"NotImplementedException\"?",
              "createdAt": "2023-05-15T19:36:07Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    /// <summary>\n+    /// Reports file accesses and process data to the in-proc node.\n+    /// </summary>\n+    internal sealed class OutOfProcNodeFileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        /// <summary>\n+        /// The <see cref=\"Action\"/> to report file accesses and process\n+        /// data to the in-proc node.\n+        /// </summary>\n+        private readonly Action<INodePacket> _sendPacket;\n+\n+        private OutOfProcNodeFileAccessManager(Action<INodePacket> sendPacket) => _sendPacket = sendPacket;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type, Action<INodePacket> sendPacket)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new OutOfProcNodeFileAccessManager(sendPacket);\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Reports a file access to the in-proc node.\n+        /// </summary>\n+        /// <param name=\"fileAccessData\">The file access to report to the in-proc node.</param>\n+        /// <param name=\"nodeId\">The id of the reporting out-of-proc node.</param>\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId) => _sendPacket(new FileAccessReport(fileAccessData));\n+\n+        /// <summary>\n+        /// Reports process data to the in-proc node.\n+        /// </summary>\n+        /// <param name=\"processData\">The process data to report to the in-proc node.</param>\n+        /// <param name=\"nodeId\">The id of the reporting out-of-proc node.</param>\n+        public void ReportProcess(ProcessData processData, int nodeId) => _sendPacket(new ProcessReport(processData));\n+\n+        // This method should not be called in OOP nodes.\n+        public FileAccessManager.HandlerRegistration RegisterHandlers(\n+            Action<BuildRequest, FileAccessData> fileAccessHandler,\n+            Action<BuildRequest, ProcessData> processHandler) =>\n+            throw new NotImplementedException();\n+\n+        // This method should not be called in OOP nodes.\n+        public void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken) =>",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This seems to be a common pattern for the out-of-proc implementations of various components. See `OutOfProecTaskHostNode.RequestCores/ReleaseCores` and `NodeProviderInProc.GetProcesses`.\r\n\r\nThe alternative would be I guess to have 2 separate interfaces/component types (`IFileAccessManager` and `IFileAccessReporter`?) where the concrete `FileAccessManager` implements both and the out-of-proc one doesn't have a registration for one of them. I'm not really sure this extra abstraction makes a ton of sense though and might just add confusion?",
              "createdAt": "2023-06-13T21:48:09Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    /// <summary>\n+    /// Reports file accesses and process data to the in-proc node.\n+    /// </summary>\n+    internal sealed class OutOfProcNodeFileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        /// <summary>\n+        /// The <see cref=\"Action\"/> to report file accesses and process\n+        /// data to the in-proc node.\n+        /// </summary>\n+        private readonly Action<INodePacket> _sendPacket;\n+\n+        private OutOfProcNodeFileAccessManager(Action<INodePacket> sendPacket) => _sendPacket = sendPacket;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type, Action<INodePacket> sendPacket)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new OutOfProcNodeFileAccessManager(sendPacket);\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Reports a file access to the in-proc node.\n+        /// </summary>\n+        /// <param name=\"fileAccessData\">The file access to report to the in-proc node.</param>\n+        /// <param name=\"nodeId\">The id of the reporting out-of-proc node.</param>\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId) => _sendPacket(new FileAccessReport(fileAccessData));\n+\n+        /// <summary>\n+        /// Reports process data to the in-proc node.\n+        /// </summary>\n+        /// <param name=\"processData\">The process data to report to the in-proc node.</param>\n+        /// <param name=\"nodeId\">The id of the reporting out-of-proc node.</param>\n+        public void ReportProcess(ProcessData processData, int nodeId) => _sendPacket(new ProcessReport(processData));\n+\n+        // This method should not be called in OOP nodes.\n+        public FileAccessManager.HandlerRegistration RegisterHandlers(\n+            Action<BuildRequest, FileAccessData> fileAccessHandler,\n+            Action<BuildRequest, ProcessData> processHandler) =>\n+            throw new NotImplementedException();\n+\n+        // This method should not be called in OOP nodes.\n+        public void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken) =>",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Why do you need an interface for every single method in each? I'd just have concrete types with methods not present in their interfaces.",
              "createdAt": "2023-06-13T23:01:01Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    /// <summary>\n+    /// Reports file accesses and process data to the in-proc node.\n+    /// </summary>\n+    internal sealed class OutOfProcNodeFileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        /// <summary>\n+        /// The <see cref=\"Action\"/> to report file accesses and process\n+        /// data to the in-proc node.\n+        /// </summary>\n+        private readonly Action<INodePacket> _sendPacket;\n+\n+        private OutOfProcNodeFileAccessManager(Action<INodePacket> sendPacket) => _sendPacket = sendPacket;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type, Action<INodePacket> sendPacket)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new OutOfProcNodeFileAccessManager(sendPacket);\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Reports a file access to the in-proc node.\n+        /// </summary>\n+        /// <param name=\"fileAccessData\">The file access to report to the in-proc node.</param>\n+        /// <param name=\"nodeId\">The id of the reporting out-of-proc node.</param>\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId) => _sendPacket(new FileAccessReport(fileAccessData));\n+\n+        /// <summary>\n+        /// Reports process data to the in-proc node.\n+        /// </summary>\n+        /// <param name=\"processData\">The process data to report to the in-proc node.</param>\n+        /// <param name=\"nodeId\">The id of the reporting out-of-proc node.</param>\n+        public void ReportProcess(ProcessData processData, int nodeId) => _sendPacket(new ProcessReport(processData));\n+\n+        // This method should not be called in OOP nodes.\n+        public FileAccessManager.HandlerRegistration RegisterHandlers(\n+            Action<BuildRequest, FileAccessData> fileAccessHandler,\n+            Action<BuildRequest, ProcessData> processHandler) =>\n+            throw new NotImplementedException();\n+\n+        // This method should not be called in OOP nodes.\n+        public void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken) =>",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How often is the Register/Unregister expected to be called?\r\nI'd imagine just a single/very few times (basicaly once per build host) and probably only on start of the build - is that correct?\r\n\r\nThan - can we replace those with some readonly collections (probably simple array would be best) and replace it on each register/unregister call - this way we can completely get rid of locking for read scenario, with same behavior.\r\n\r\nThe Register/Unregister would still need to be under lock - to prevent lost writes. The reader (ReportFileAccess) would get snapshot of the structure valid before it started operation (it just should copy it into local variable) - which is same as if it'd manage to grab reader lock and Register call would wait to perform it's change.",
              "createdAt": "2023-05-29T09:08:31Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private readonly ReaderWriterLockSlim _handlersLock = new();\n+        private List<Action<BuildRequest, FileAccessData>> _fileAccessHandlers = new();\n+        private List<Action<BuildRequest, ProcessData>> _processHandlers = new();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Alternatively - can this code be commented with justification for need for lock per each read?",
              "createdAt": "2023-05-29T12:41:14Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private readonly ReaderWriterLockSlim _handlersLock = new();\n+        private List<Action<BuildRequest, FileAccessData>> _fileAccessHandlers = new();\n+        private List<Action<BuildRequest, ProcessData>> _processHandlers = new();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "These should only be written to infrequently, but it can't be a readonly collection as the registrations may end up coming at some later time in the build for some yet-to-be-discovered project (implying the graph is also incomplete).",
              "createdAt": "2023-05-30T23:54:39Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private readonly ReaderWriterLockSlim _handlersLock = new();\n+        private List<Action<BuildRequest, FileAccessData>> _fileAccessHandlers = new();\n+        private List<Action<BuildRequest, ProcessData>> _processHandlers = new();",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "> These should only be written to infrequently\r\n\r\nPerfect!\r\n\r\n> but it can't be a readonly collection as the registrations may end up coming at some later time in the build for some yet-to-be-discovered project (implying the graph is also incomplete).\r\n\r\nI was thinking of completely swapping the references - similarly as how the multicast delegate works; just with proper handling of writer side (lock or CompareExchange atomic swap) to prevent missed writes.\r\n\r\nSomething like:\r\n\r\n_Reader:_\r\n```\r\nvar localCollection = _collection;\r\nforeach(var item in localCollection) { ... }\r\n```\r\n\r\n_Writer:_\r\n```\r\nlock(_locker)\r\n{\r\n  _collection = _collection .Append(newItem).ToArray();\r\n}\r\n```",
              "createdAt": "2023-05-31T10:18:55Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private readonly ReaderWriterLockSlim _handlersLock = new();\n+        private List<Action<BuildRequest, FileAccessData>> _fileAccessHandlers = new();\n+        private List<Action<BuildRequest, ProcessData>> _processHandlers = new();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Good point, let me try this.",
              "createdAt": "2023-06-13T21:51:52Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private readonly ReaderWriterLockSlim _handlersLock = new();\n+        private List<Action<BuildRequest, FileAccessData>> _fileAccessHandlers = new();\n+        private List<Action<BuildRequest, ProcessData>> _processHandlers = new();",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Done. Certainly could use more eyes on it to ensure there's no off-by-one",
              "createdAt": "2023-06-13T23:57:14Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,135 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private readonly ReaderWriterLockSlim _handlersLock = new();\n+        private List<Action<BuildRequest, FileAccessData>> _fileAccessHandlers = new();\n+        private List<Action<BuildRequest, ProcessData>> _processHandlers = new();",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "What is the intent for this enum? I do not see it being used in this PR",
              "createdAt": "2023-05-29T12:49:08Z",
              "path": "src/Framework/FileAccess/FileAccessStatus.cs",
              "diffHunk": "@@ -0,0 +1,34 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework.FileAccess\n+{\n+    /// <summary>\n+    /// Flags indicating the status of a file access.\n+    /// </summary>\n+    [Flags]\n+    public enum FileAccessStatus : byte",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "To provide the plugin with the information. It's not used in the PR since this is provided to plugins.",
              "createdAt": "2023-05-30T23:55:38Z",
              "path": "src/Framework/FileAccess/FileAccessStatus.cs",
              "diffHunk": "@@ -0,0 +1,34 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework.FileAccess\n+{\n+    /// <summary>\n+    /// Flags indicating the status of a file access.\n+    /// </summary>\n+    [Flags]\n+    public enum FileAccessStatus : byte",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Oh wait, you're right, this specific enum may not be needed",
              "createdAt": "2023-05-30T23:56:38Z",
              "path": "src/Framework/FileAccess/FileAccessStatus.cs",
              "diffHunk": "@@ -0,0 +1,34 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework.FileAccess\n+{\n+    /// <summary>\n+    /// Flags indicating the status of a file access.\n+    /// </summary>\n+    [Flags]\n+    public enum FileAccessStatus : byte",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is bit confusing to me :-) Why conditioned for Mono and then skipped for Mono :-)",
              "createdAt": "2023-05-29T13:45:19Z",
              "path": "src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,223 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using BuildXL.Processes;\n+using BuildXL.Utilities.Core;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.FileAccesses;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent\n+    {\n+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();\n+\n+        private IFileAccessManager _fileAccessManager;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));\n+            return new DetouredNodeLauncher();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _fileAccessManager = null;\n+\n+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)\n+            {\n+                sandboxedProcess.Dispose();\n+            }\n+\n+            _sandboxedProcesses.Clear();\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process\n+        /// </summary>\n+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)\n+        {\n+            // Should always have been set already.\n+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));\n+\n+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));\n+\n+            if (!FileSystems.Default.FileExists(msbuildLocation))\n+            {\n+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n+            }\n+\n+            // Repeat the executable name as the first token of the command line because the command line\n+            // parser logic expects it and will otherwise skip the first argument\n+            commandLineArgs = $\"\\\"{msbuildLocation}\\\" {commandLineArgs}\";\n+\n+            CommunicationsUtilities.Trace(\"Launching node from {0}\", msbuildLocation);\n+\n+            string exeName = msbuildLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+            // Mono automagically uses the current mono, to execute a managed assembly\n+            if (!NativeMethodsShared.IsMono)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "This mirrors the existing logic in [`NodeLauncher.cs`](https://github.com/dotnet/msbuild/blob/246217d1f6e3352d308d5d0811962000e381e291/src/Build/BackEnd/Components/Communications/NodeLauncher.cs#L84)",
              "createdAt": "2023-05-30T23:58:22Z",
              "path": "src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,223 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using BuildXL.Processes;\n+using BuildXL.Utilities.Core;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.FileAccesses;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent\n+    {\n+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();\n+\n+        private IFileAccessManager _fileAccessManager;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));\n+            return new DetouredNodeLauncher();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _fileAccessManager = null;\n+\n+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)\n+            {\n+                sandboxedProcess.Dispose();\n+            }\n+\n+            _sandboxedProcesses.Clear();\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process\n+        /// </summary>\n+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)\n+        {\n+            // Should always have been set already.\n+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));\n+\n+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));\n+\n+            if (!FileSystems.Default.FileExists(msbuildLocation))\n+            {\n+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n+            }\n+\n+            // Repeat the executable name as the first token of the command line because the command line\n+            // parser logic expects it and will otherwise skip the first argument\n+            commandLineArgs = $\"\\\"{msbuildLocation}\\\" {commandLineArgs}\";\n+\n+            CommunicationsUtilities.Trace(\"Launching node from {0}\", msbuildLocation);\n+\n+            string exeName = msbuildLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+            // Mono automagically uses the current mono, to execute a managed assembly\n+            if (!NativeMethodsShared.IsMono)",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "OK - understood then",
              "createdAt": "2023-05-31T10:19:42Z",
              "path": "src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,223 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using BuildXL.Processes;\n+using BuildXL.Utilities.Core;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.FileAccesses;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent\n+    {\n+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();\n+\n+        private IFileAccessManager _fileAccessManager;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));\n+            return new DetouredNodeLauncher();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _fileAccessManager = null;\n+\n+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)\n+            {\n+                sandboxedProcess.Dispose();\n+            }\n+\n+            _sandboxedProcesses.Clear();\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process\n+        /// </summary>\n+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)\n+        {\n+            // Should always have been set already.\n+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));\n+\n+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));\n+\n+            if (!FileSystems.Default.FileExists(msbuildLocation))\n+            {\n+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n+            }\n+\n+            // Repeat the executable name as the first token of the command line because the command line\n+            // parser logic expects it and will otherwise skip the first argument\n+            commandLineArgs = $\"\\\"{msbuildLocation}\\\" {commandLineArgs}\";\n+\n+            CommunicationsUtilities.Trace(\"Launching node from {0}\", msbuildLocation);\n+\n+            string exeName = msbuildLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+            // Mono automagically uses the current mono, to execute a managed assembly\n+            if (!NativeMethodsShared.IsMono)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this translate to the npipe name? Is there any disambiguator automatically added by the detours api? Just trying to see this is safe for multinode builds or/and multiple independent parallel builds.",
              "createdAt": "2023-05-29T13:48:01Z",
              "path": "src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,223 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using BuildXL.Processes;\n+using BuildXL.Utilities.Core;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.FileAccesses;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent\n+    {\n+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();\n+\n+        private IFileAccessManager _fileAccessManager;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));\n+            return new DetouredNodeLauncher();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _fileAccessManager = null;\n+\n+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)\n+            {\n+                sandboxedProcess.Dispose();\n+            }\n+\n+            _sandboxedProcesses.Clear();\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process\n+        /// </summary>\n+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)\n+        {\n+            // Should always have been set already.\n+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));\n+\n+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));\n+\n+            if (!FileSystems.Default.FileExists(msbuildLocation))\n+            {\n+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n+            }\n+\n+            // Repeat the executable name as the first token of the command line because the command line\n+            // parser logic expects it and will otherwise skip the first argument\n+            commandLineArgs = $\"\\\"{msbuildLocation}\\\" {commandLineArgs}\";\n+\n+            CommunicationsUtilities.Trace(\"Launching node from {0}\", msbuildLocation);\n+\n+            string exeName = msbuildLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+            // Mono automagically uses the current mono, to execute a managed assembly\n+            if (!NativeMethodsShared.IsMono)\n+            {\n+                // Run the child process with the same host as the currently-running process.\n+                exeName = CurrentHost.GetCurrentHost();\n+            }\n+#endif\n+\n+            var eventListener = new DetoursEventListener(_fileAccessManager, nodeId);\n+            eventListener.SetMessageHandlingFlags(MessageHandlingFlags.DebugMessageNotify | MessageHandlingFlags.FileAccessNotify | MessageHandlingFlags.ProcessDataNotify | MessageHandlingFlags.ProcessDetoursStatusNotify);\n+\n+            var info = new SandboxedProcessInfo(\n+                fileStorage: null, // Don't write stdout/stderr to files\n+                fileName: exeName,\n+                disableConHostSharing: false,\n+                detoursEventListener: eventListener,\n+                createJobObjectForCurrentProcess: false)\n+            {\n+                SandboxKind = SandboxKind.Default,\n+                PipDescription = \"MSBuild\",",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Nope, it's just for logging. Unfortunately it's required despite not being used in this scenario.",
              "createdAt": "2023-05-30T23:59:31Z",
              "path": "src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,223 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using BuildXL.Processes;\n+using BuildXL.Utilities.Core;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.FileAccesses;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent\n+    {\n+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();\n+\n+        private IFileAccessManager _fileAccessManager;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));\n+            return new DetouredNodeLauncher();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _fileAccessManager = null;\n+\n+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)\n+            {\n+                sandboxedProcess.Dispose();\n+            }\n+\n+            _sandboxedProcesses.Clear();\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process\n+        /// </summary>\n+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)\n+        {\n+            // Should always have been set already.\n+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));\n+\n+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));\n+\n+            if (!FileSystems.Default.FileExists(msbuildLocation))\n+            {\n+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n+            }\n+\n+            // Repeat the executable name as the first token of the command line because the command line\n+            // parser logic expects it and will otherwise skip the first argument\n+            commandLineArgs = $\"\\\"{msbuildLocation}\\\" {commandLineArgs}\";\n+\n+            CommunicationsUtilities.Trace(\"Launching node from {0}\", msbuildLocation);\n+\n+            string exeName = msbuildLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+            // Mono automagically uses the current mono, to execute a managed assembly\n+            if (!NativeMethodsShared.IsMono)\n+            {\n+                // Run the child process with the same host as the currently-running process.\n+                exeName = CurrentHost.GetCurrentHost();\n+            }\n+#endif\n+\n+            var eventListener = new DetoursEventListener(_fileAccessManager, nodeId);\n+            eventListener.SetMessageHandlingFlags(MessageHandlingFlags.DebugMessageNotify | MessageHandlingFlags.FileAccessNotify | MessageHandlingFlags.ProcessDataNotify | MessageHandlingFlags.ProcessDetoursStatusNotify);\n+\n+            var info = new SandboxedProcessInfo(\n+                fileStorage: null, // Don't write stdout/stderr to files\n+                fileName: exeName,\n+                disableConHostSharing: false,\n+                detoursEventListener: eventListener,\n+                createJobObjectForCurrentProcess: false)\n+            {\n+                SandboxKind = SandboxKind.Default,\n+                PipDescription = \"MSBuild\",",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Neat trick :-)",
              "createdAt": "2023-05-29T16:03:57Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,190 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        // In order to synchronize between the node communication and the file access reporting, a special file access\n+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen\n+        // and the build result is reported can plugins be notified about project completion.\n+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @\":\\{MSBuildFileAccessCompletion}\\\";\n+\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private readonly ReaderWriterLockSlim _handlersLock = new();\n+        private List<Action<BuildRequest, FileAccessData>> _fileAccessHandlers = new();\n+        private List<Action<BuildRequest, ProcessData>> _processHandlers = new();\n+        private string? _tempDirectory;\n+\n+        // Keyed on global request id\n+        private readonly ConcurrentDictionary<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles = new();\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new FileAccessManager();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;\n+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;\n+            _tempDirectory = FileUtilities.EnsureNoTrailingSlash(FileUtilities.TempFileDirectory);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _scheduler = null;\n+            _configCache = null;\n+            _tempDirectory = null;\n+            _fileAccessCompletionWaitHandles.Clear();\n+        }\n+\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)\n+        {\n+            string fileAccessPath = fileAccessData.Path;\n+\n+            // Intercept and avoid forwarding the file access completion\n+            if (fileAccessPath.StartsWith(FileAccessCompletionPrefix, StringComparison.Ordinal))\n+            {\n+                // Parse out the global request id. Note, this must match what NotifyFileAccessCompletion does.\n+                int globalRequestId = int.Parse(fileAccessPath.Substring(FileAccessCompletionPrefix.Length));\n+\n+                ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());\n+                handle.Set();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Moving the reasoning from comment into the exception message might help troubleshooting possible issues",
              "createdAt": "2023-05-29T16:32:42Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    /// <summary>\n+    /// Reports file accesses and process data to the in-proc node.\n+    /// </summary>\n+    internal sealed class OutOfProcNodeFileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        /// <summary>\n+        /// The <see cref=\"Action\"/> to report file accesses and process\n+        /// data to the in-proc node.\n+        /// </summary>\n+        private readonly Action<INodePacket> _sendPacket;\n+\n+        private OutOfProcNodeFileAccessManager(Action<INodePacket> sendPacket) => _sendPacket = sendPacket;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type, Action<INodePacket> sendPacket)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new OutOfProcNodeFileAccessManager(sendPacket);\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Reports a file access to the in-proc node.\n+        /// </summary>\n+        /// <param name=\"fileAccessData\">The file access to report to the in-proc node.</param>\n+        /// <param name=\"nodeId\">The id of the reporting out-of-proc node.</param>\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId) => _sendPacket(new FileAccessReport(fileAccessData));\n+\n+        /// <summary>\n+        /// Reports process data to the in-proc node.\n+        /// </summary>\n+        /// <param name=\"processData\">The process data to report to the in-proc node.</param>\n+        /// <param name=\"nodeId\">The id of the reporting out-of-proc node.</param>\n+        public void ReportProcess(ProcessData processData, int nodeId) => _sendPacket(new ProcessReport(processData));\n+\n+        // This method should not be called in OOP nodes.\n+        public FileAccessManager.HandlerRegistration RegisterHandlers(\n+            Action<BuildRequest, FileAccessData> fileAccessHandler,\n+            Action<BuildRequest, ProcessData> processHandler) =>\n+            throw new NotImplementedException();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Done",
              "createdAt": "2023-06-13T23:56:42Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    /// <summary>\n+    /// Reports file accesses and process data to the in-proc node.\n+    /// </summary>\n+    internal sealed class OutOfProcNodeFileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        /// <summary>\n+        /// The <see cref=\"Action\"/> to report file accesses and process\n+        /// data to the in-proc node.\n+        /// </summary>\n+        private readonly Action<INodePacket> _sendPacket;\n+\n+        private OutOfProcNodeFileAccessManager(Action<INodePacket> sendPacket) => _sendPacket = sendPacket;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type, Action<INodePacket> sendPacket)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new OutOfProcNodeFileAccessManager(sendPacket);\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+        }\n+\n+        /// <summary>\n+        /// Reports a file access to the in-proc node.\n+        /// </summary>\n+        /// <param name=\"fileAccessData\">The file access to report to the in-proc node.</param>\n+        /// <param name=\"nodeId\">The id of the reporting out-of-proc node.</param>\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId) => _sendPacket(new FileAccessReport(fileAccessData));\n+\n+        /// <summary>\n+        /// Reports process data to the in-proc node.\n+        /// </summary>\n+        /// <param name=\"processData\">The process data to report to the in-proc node.</param>\n+        /// <param name=\"nodeId\">The id of the reporting out-of-proc node.</param>\n+        public void ReportProcess(ProcessData processData, int nodeId) => _sendPacket(new ProcessReport(processData));\n+\n+        // This method should not be called in OOP nodes.\n+        public FileAccessManager.HandlerRegistration RegisterHandlers(\n+            Action<BuildRequest, FileAccessData> fileAccessHandler,\n+            Action<BuildRequest, ProcessData> processHandler) =>\n+            throw new NotImplementedException();",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just curious - why are the global properties of concern at all?\r\nI'd naively think that for deterministic build only the initial state would be of concern (plus the list of all the files participating in the build). Or is it so that we can skip portions (targets?) of the project build, while still building others? If yes - is there a granularity unit (target?) for which we can group updates and create the context just once?",
              "createdAt": "2023-05-30T08:24:42Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -218,18 +231,46 @@ private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectIn\n                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheInitializationFailed\");\n                 }\n \n-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);\n+                FileAccessManager.HandlerRegistration handlerRegistration = _fileAccessManager.RegisterHandlers(\n+                    (buildRequest, fileAccessData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);\n+                    },\n+                    (buildRequest, processData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleProcess(fileAccessContext, processData);\n+                    });\n+\n+                return new ProjectCachePlugin(pluginTypeName, pluginInstance, handlerRegistration);\n             }\n             catch (Exception e)\n             {\n-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));\n+                return new ProjectCachePlugin(pluginTypeName, Instance: null, HandlerRegistration: null, ExceptionDispatchInfo.Capture(e));\n             }\n             finally\n             {\n                 MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);\n             }\n         }\n \n+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)\n+        {\n+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];\n+\n+            // TODO dfederm: This allocates a lot.\n+            var globalProperties = new Dictionary<string, string>(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);\n+            foreach (ProjectPropertyInstance property in configuration.GlobalProperties)\n+            {\n+                globalProperties.Add(property.Name, property.EvaluatedValue);\n+            }\n+\n+            return new FileAccessContext(configuration.ProjectFullPath, globalProperties, buildRequest.Targets);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "In general MSBuild operates on \"configurations\" which differs per global property set. If the global properties differ, MSBuild will in fact build the project multiple times. In fact, this is exactly how multitargetting works.\r\n\r\nProject caching uses the same granularity as MSBuild uses for \"build requests\".",
              "createdAt": "2023-05-31T00:02:25Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -218,18 +231,46 @@ private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectIn\n                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheInitializationFailed\");\n                 }\n \n-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);\n+                FileAccessManager.HandlerRegistration handlerRegistration = _fileAccessManager.RegisterHandlers(\n+                    (buildRequest, fileAccessData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);\n+                    },\n+                    (buildRequest, processData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleProcess(fileAccessContext, processData);\n+                    });\n+\n+                return new ProjectCachePlugin(pluginTypeName, pluginInstance, handlerRegistration);\n             }\n             catch (Exception e)\n             {\n-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));\n+                return new ProjectCachePlugin(pluginTypeName, Instance: null, HandlerRegistration: null, ExceptionDispatchInfo.Capture(e));\n             }\n             finally\n             {\n                 MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);\n             }\n         }\n \n+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)\n+        {\n+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];\n+\n+            // TODO dfederm: This allocates a lot.\n+            var globalProperties = new Dictionary<string, string>(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);\n+            foreach (ProjectPropertyInstance property in configuration.GlobalProperties)\n+            {\n+                globalProperties.Add(property.Name, property.EvaluatedValue);\n+            }\n+\n+            return new FileAccessContext(configuration.ProjectFullPath, globalProperties, buildRequest.Targets);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Sorry for being slower here :-) The handler is still invoked for each single file access - and the `globalProperties` dictionary is created for each invocation. Is that correct?\r\nI suppose the build request do not interleave - do they? Can we simply create the new 'build request associated data object' only if we do not have it some preexisting variable/field or if the build request identifier differs? This way we can balance between downsides of creating it for each single file access and caching all build request related data per all projects.\r\n\r\nOr am I totally misunderstanding this?",
              "createdAt": "2023-05-31T10:28:36Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -218,18 +231,46 @@ private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectIn\n                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheInitializationFailed\");\n                 }\n \n-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);\n+                FileAccessManager.HandlerRegistration handlerRegistration = _fileAccessManager.RegisterHandlers(\n+                    (buildRequest, fileAccessData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);\n+                    },\n+                    (buildRequest, processData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleProcess(fileAccessContext, processData);\n+                    });\n+\n+                return new ProjectCachePlugin(pluginTypeName, pluginInstance, handlerRegistration);\n             }\n             catch (Exception e)\n             {\n-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));\n+                return new ProjectCachePlugin(pluginTypeName, Instance: null, HandlerRegistration: null, ExceptionDispatchInfo.Capture(e));\n             }\n             finally\n             {\n                 MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);\n             }\n         }\n \n+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)\n+        {\n+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];\n+\n+            // TODO dfederm: This allocates a lot.\n+            var globalProperties = new Dictionary<string, string>(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);\n+            foreach (ProjectPropertyInstance property in configuration.GlobalProperties)\n+            {\n+                globalProperties.Add(property.Name, property.EvaluatedValue);\n+            }\n+\n+            return new FileAccessContext(configuration.ProjectFullPath, globalProperties, buildRequest.Targets);",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "I created a cache",
              "createdAt": "2023-06-13T23:56:32Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -218,18 +231,46 @@ private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectIn\n                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheInitializationFailed\");\n                 }\n \n-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);\n+                FileAccessManager.HandlerRegistration handlerRegistration = _fileAccessManager.RegisterHandlers(\n+                    (buildRequest, fileAccessData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);\n+                    },\n+                    (buildRequest, processData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleProcess(fileAccessContext, processData);\n+                    });\n+\n+                return new ProjectCachePlugin(pluginTypeName, pluginInstance, handlerRegistration);\n             }\n             catch (Exception e)\n             {\n-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));\n+                return new ProjectCachePlugin(pluginTypeName, Instance: null, HandlerRegistration: null, ExceptionDispatchInfo.Capture(e));\n             }\n             finally\n             {\n                 MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);\n             }\n         }\n \n+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)\n+        {\n+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];\n+\n+            // TODO dfederm: This allocates a lot.\n+            var globalProperties = new Dictionary<string, string>(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);\n+            foreach (ProjectPropertyInstance property in configuration.GlobalProperties)\n+            {\n+                globalProperties.Add(property.Name, property.EvaluatedValue);\n+            }\n+\n+            return new FileAccessContext(configuration.ProjectFullPath, globalProperties, buildRequest.Targets);",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "Thank you.\r\n\r\nForbid my fundamental lack of knowledge here - is it expected that requests here will NOT be grouped by the configurations? I was thinking if we can just throw away the previously cached globalProperties as soon as we get request for a new configuration.",
              "createdAt": "2023-06-14T09:34:44Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -218,18 +231,46 @@ private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectIn\n                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheInitializationFailed\");\n                 }\n \n-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);\n+                FileAccessManager.HandlerRegistration handlerRegistration = _fileAccessManager.RegisterHandlers(\n+                    (buildRequest, fileAccessData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);\n+                    },\n+                    (buildRequest, processData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin\n+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);\n+                        pluginInstance.HandleProcess(fileAccessContext, processData);\n+                    });\n+\n+                return new ProjectCachePlugin(pluginTypeName, pluginInstance, handlerRegistration);\n             }\n             catch (Exception e)\n             {\n-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));\n+                return new ProjectCachePlugin(pluginTypeName, Instance: null, HandlerRegistration: null, ExceptionDispatchInfo.Capture(e));\n             }\n             finally\n             {\n                 MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);\n             }\n         }\n \n+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)\n+        {\n+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];\n+\n+            // TODO dfederm: This allocates a lot.\n+            var globalProperties = new Dictionary<string, string>(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);\n+            foreach (ProjectPropertyInstance property in configuration.GlobalProperties)\n+            {\n+                globalProperties.Add(property.Name, property.EvaluatedValue);\n+            }\n+\n+            return new FileAccessContext(configuration.ProjectFullPath, globalProperties, buildRequest.Targets);",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "looks perfect - thanks!",
              "createdAt": "2023-06-15T10:07:27Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,181 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);\n+\n+        // In order to synchronize between the node communication and the file access reporting, a special file access\n+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen\n+        // and the build result is reported can plugins be notified about project completion.\n+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @\":\\{MSBuildFileAccessCompletion}\\\";\n+\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private object _handlersWriteLock = new object();\n+        private Handlers[] _handlers = Array.Empty<Handlers>();\n+        private string? _tempDirectory;\n+\n+        // Keyed on global request id\n+        private readonly ConcurrentDictionary<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles = new();\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new FileAccessManager();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;\n+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;\n+            _tempDirectory = FileUtilities.EnsureNoTrailingSlash(FileUtilities.TempFileDirectory);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _scheduler = null;\n+            _configCache = null;\n+            _tempDirectory = null;\n+            _fileAccessCompletionWaitHandles.Clear();\n+        }\n+\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)\n+        {\n+            string fileAccessPath = fileAccessData.Path;\n+\n+            // Intercept and avoid forwarding the file access completion\n+            if (fileAccessPath.StartsWith(FileAccessCompletionPrefix, StringComparison.Ordinal))\n+            {\n+                // Parse out the global request id. Note, this must match what NotifyFileAccessCompletion does.\n+                int globalRequestId = int.Parse(fileAccessPath.Substring(FileAccessCompletionPrefix.Length));\n+\n+                ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());\n+                handle.Set();\n+            }\n+            else if (_tempDirectory != null && fileAccessPath.StartsWith(_tempDirectory))\n+            {\n+                // Ignore the temp directory as these are related to internal MSBuild functionality and not always directly related to the execution of the project itself,\n+                // so should not be exposed to handlers.\n+                return;\n+            }\n+            else\n+            {\n+                // Forward the file access to handlers.\n+                BuildRequest? buildRequest = GetBuildRequest(nodeId);\n+                if (buildRequest != null)\n+                {\n+                    Handlers[] localHandlers = _handlers;\n+                    foreach (Handlers handlers in localHandlers)\n+                    {\n+                        handlers.FileAccessHander.Invoke(buildRequest, fileAccessData);\n+                    }\n+                }\n+            }\n+        }\n+\n+        public void ReportProcess(ProcessData processData, int nodeId)\n+        {\n+            BuildRequest? buildRequest = GetBuildRequest(nodeId);\n+            if (buildRequest != null)\n+            {\n+                Handlers[] localHandlers = _handlers;\n+                foreach (Handlers handlers in localHandlers)\n+                {\n+                    handlers.ProcessHandler.Invoke(buildRequest, processData);\n+                }\n+            }\n+        }\n+\n+        public HandlerRegistration RegisterHandlers(Action<BuildRequest, FileAccessData> fileAccessHandler, Action<BuildRequest, ProcessData> processHandler)\n+        {\n+            lock (_handlersWriteLock)\n+            {\n+                Handlers[] newHandlers = new Handlers[_handlers.Length + 1];\n+                _handlers.CopyTo(newHandlers, 0);\n+\n+                Handlers addedHandlers = new(fileAccessHandler, processHandler);\n+                newHandlers[_handlers.Length] = addedHandlers;\n+\n+                _handlers = newHandlers;\n+\n+                return new HandlerRegistration(() => UnregisterHandlers(addedHandlers));\n+            }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@MichaelSimons - are we OK keeping this feed, or does the `Microsoft.BuildXL.Processes` need to move to different feed?\r\nIt's close sourced and conditionaly referenced only by FullFW build",
              "createdAt": "2023-08-23T14:30:35Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -8,6 +8,7 @@\n     <add key=\"dotnet6\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json\" />\n     <add key=\"dotnet8\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json\" />\n     <add key=\"dotnet8-transport\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json\" />\n+    <add key=\"BuildXL\" value=\"https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json\" />",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "It's actually open source: https://github.com/microsoft/BuildXL",
              "createdAt": "2023-08-23T14:36:19Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -8,6 +8,7 @@\n     <add key=\"dotnet6\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json\" />\n     <add key=\"dotnet8\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json\" />\n     <add key=\"dotnet8-transport\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json\" />\n+    <add key=\"BuildXL\" value=\"https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json\" />",
              "author": {
                "login": "dfederm"
              }
            },
            {
              "body": "I have no opinion on this.  It doesn't matter to source-build since the packages are conditionally referenced only for netFX.  Source-build dynamically removes all feeds when it builds and dynamically injects the source-built feeds.  Source build must build everything from source so it is only valid to reference the built packages.",
              "createdAt": "2023-08-24T13:10:43Z",
              "path": "NuGet.config",
              "diffHunk": "@@ -8,6 +8,7 @@\n     <add key=\"dotnet6\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json\" />\n     <add key=\"dotnet8\" value=\"https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json\" />\n     <add key=\"dotnet8-transport\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json\" />\n+    <add key=\"BuildXL\" value=\"https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json\" />",
              "author": {
                "login": "MichaelSimons"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is a prebuilt and adding an exclusion here is going to break the product source-build.  Previously it looks like version 5.0.0 was referenced.  A [reference package](https://github.com/dotnet/source-build-reference-packages/tree/main/src/referencePackages/src/system.security.principal.windows/5.0.0) was being utilized during source-build to satisfy the windows-only dependency.  Since this is being upgraded, a new reference package will need to be created.  You can add this by following the instructions at https://github.com/dotnet/source-build-reference-packages/blob/main/README.md#adding-new-packages.\r\n\r\nOne question I have is why are we taking a dependency on a preview package?  We frown upon adding reference packages for non-stable versions.  I see this package has been in preview for over 2 years.  That smells to me.",
              "createdAt": "2023-08-24T13:07:47Z",
              "path": "eng/SourceBuildPrebuiltBaseline.xml",
              "diffHunk": "@@ -12,6 +12,9 @@\n     <UsagePattern IdentityGlob=\"System.Reflection.MetadataLoadContext/*7.0.0*\" />\n     <UsagePattern IdentityGlob=\"System.Security.Cryptography.ProtectedData/*7.0.0*\" />\n     <UsagePattern IdentityGlob=\"System.Text.Json/*7.0.3*\" />\n+\n+    <!-- This is for windows-only project caching acceleration -->\n+    <UsagePattern IdentityGlob=\"System.Security.Principal.Windows/*6.0.0*\" />",
              "author": {
                "login": "MichaelSimons"
              }
            },
            {
              "body": "Looks like this is moot and I can revert the change to this package version. BXL's package only depends on this version for net6, and since originally sending this PR MSBuild has updated to net7.\r\n\r\n![image](https://github.com/dotnet/msbuild/assets/6445614/486504d1-09e2-4087-93b5-9fa120928a5f)\r\n",
              "createdAt": "2023-08-24T15:33:11Z",
              "path": "eng/SourceBuildPrebuiltBaseline.xml",
              "diffHunk": "@@ -12,6 +12,9 @@\n     <UsagePattern IdentityGlob=\"System.Reflection.MetadataLoadContext/*7.0.0*\" />\n     <UsagePattern IdentityGlob=\"System.Security.Cryptography.ProtectedData/*7.0.0*\" />\n     <UsagePattern IdentityGlob=\"System.Text.Json/*7.0.3*\" />\n+\n+    <!-- This is for windows-only project caching acceleration -->\n+    <UsagePattern IdentityGlob=\"System.Security.Principal.Windows/*6.0.0*\" />",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@rokonec should these new entries go before the `ServerNode*` ones?\r\n\r\nRight now this decompiles to\r\n\r\n```c#\r\ninternal enum NodePacketType : byte\r\n{\r\n\tNodeConfiguration = 0,\r\n\tBuildRequestConfiguration = 1,\r\n\tBuildRequestConfigurationResponse = 2,\r\n\tProjectLoadInfo = 3,\r\n\tBuildRequestBlocker = 4,\r\n\tBuildRequestUnblocker = 5,\r\n\tBuildRequest = 6,\r\n\tBuildResult = 7,\r\n\tLogMessage = 8,\r\n\tNodeBuildComplete = 9,\r\n\tNodeShutdown = 10,\r\n\tTaskHostConfiguration = 11,\r\n\tTaskHostTaskComplete = 12,\r\n\tTaskHostTaskCancelled = 13,\r\n\tResolveSdkRequest = 14,\r\n\tResolveSdkResponse = 15,\r\n\tResourceRequest = 16,\r\n\tResourceResponse = 17,\r\n\tServerNodeBuildCommand = 240,\r\n\tServerNodeBuildResult = 241,\r\n\tServerNodeConsoleWrite = 242,\r\n\tServerNodeBuildCancel = 243,\r\n\tFileAccessReport = 244,\r\n\tProcessReport = 245\r\n}\r\n```\r\n\r\nWhich reads a bit funny to me.",
              "createdAt": "2023-08-24T16:22:28Z",
              "path": "src/Shared/INodePacket.cs",
              "diffHunk": "@@ -213,6 +213,16 @@ internal enum NodePacketType : byte\n         /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n         /// </summary>\n         ServerNodeBuildCancel = 0xF3,\n+\n+        /// <summary>\n+        /// Message sent from a node reporting a file access.\n+        /// </summary>\n+        FileAccessReport,\n+\n+        /// <summary>\n+        /// Message sent from a node reporting process data.\n+        /// </summary>\n+        ProcessReport,",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I'll pre-emptively move them for clarity. Because of the handshaking, not sure the actual enum values matter a ton (according to comments, it actually does?), but yea definitely looks weird.",
              "createdAt": "2023-08-24T21:55:45Z",
              "path": "src/Shared/INodePacket.cs",
              "diffHunk": "@@ -213,6 +213,16 @@ internal enum NodePacketType : byte\n         /// Keep this enum value constant intact as this is part of contract with dotnet CLI\n         /// </summary>\n         ServerNodeBuildCancel = 0xF3,\n+\n+        /// <summary>\n+        /// Message sent from a node reporting a file access.\n+        /// </summary>\n+        FileAccessReport,\n+\n+        /// <summary>\n+        /// Message sent from a node reporting process data.\n+        /// </summary>\n+        ProcessReport,",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    <value>MSB4269: The project cache failed while handling a build result for the following project: {0}.</value>\r\n```\r\n\r\nShould there be details about the failure here, like an exception/stack trace/message from the cache plugin?",
              "createdAt": "2023-08-24T16:24:35Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -1906,6 +1906,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n   <data name=\"ProjectCacheShutdownFailed\" xml:space=\"preserve\">\n     <value>MSB4268: The project cache failed to shut down properly.</value>\n   </data>\n+  <data name=\"ProjectCacheHandleBuildResultFailed\" xml:space=\"preserve\">\n+    <value>MSB4269: The project cache failed while handling build result for the following project: {0}.</value>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "The logic around this is:\r\n\r\n```cs\r\n            if (pluginLogger.HasLoggedErrors)\r\n            {\r\n                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheHandleBuildResultFailed\", fileAccessContext.ProjectFullPath);\r\n            }\r\n```\r\n\r\nSo the plugin already logged specific errors, this is just kind of a \"look at the error above\" sort of message I guess, and provides context.",
              "createdAt": "2023-08-24T21:58:52Z",
              "path": "src/Build/Resources/Strings.resx",
              "diffHunk": "@@ -1906,6 +1906,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>\n   <data name=\"ProjectCacheShutdownFailed\" xml:space=\"preserve\">\n     <value>MSB4268: The project cache failed to shut down properly.</value>\n   </data>\n+  <data name=\"ProjectCacheHandleBuildResultFailed\" xml:space=\"preserve\">\n+    <value>MSB4269: The project cache failed while handling build result for the following project: {0}.</value>",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "A few of these enums feel a bit funky to have in MSBuild proper rather than at the Windows or BXL level . . . can you explain a bit why we need these types?",
              "createdAt": "2023-08-24T16:30:53Z",
              "path": "src/Framework/FileAccess/DesiredAccess.cs",
              "diffHunk": "@@ -0,0 +1,109 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework.FileAccess\n+{\n+    /// <summary>\n+    /// The requested access to the file or device.\n+    /// </summary>\n+    /// <remarks>\n+    /// See https://learn.microsoft.com/en-us/windows/win32/fileio/file-access-rights-constants for a full list of values.\n+    /// </remarks>\n+    [Flags]\n+\n+    // TODO dshepelev: Fix suppression.\n+#pragma warning disable CS3009 // Base type is not CLS-compliant.\n+    public enum DesiredAccess : uint",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Also, for a lot of these enums: this isn't a new definition, right? It's a bridge to existing definitions elsewhere? Please link those definitions (if we need the duplication).",
              "createdAt": "2023-08-24T16:50:28Z",
              "path": "src/Framework/FileAccess/DesiredAccess.cs",
              "diffHunk": "@@ -0,0 +1,109 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework.FileAccess\n+{\n+    /// <summary>\n+    /// The requested access to the file or device.\n+    /// </summary>\n+    /// <remarks>\n+    /// See https://learn.microsoft.com/en-us/windows/win32/fileio/file-access-rights-constants for a full list of values.\n+    /// </remarks>\n+    [Flags]\n+\n+    // TODO dshepelev: Fix suppression.\n+#pragma warning disable CS3009 // Base type is not CLS-compliant.\n+    public enum DesiredAccess : uint",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "These are exposed to the plugin so I wanted to translate BXL's enums to MSBuild copies in order to not expose BXL directly as part of the public API.\r\n\r\nI'll add comments explaining that they need to be kept in sync and why.",
              "createdAt": "2023-08-24T22:00:28Z",
              "path": "src/Framework/FileAccess/DesiredAccess.cs",
              "diffHunk": "@@ -0,0 +1,109 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+\n+namespace Microsoft.Build.Framework.FileAccess\n+{\n+    /// <summary>\n+    /// The requested access to the file or device.\n+    /// </summary>\n+    /// <remarks>\n+    /// See https://learn.microsoft.com/en-us/windows/win32/fileio/file-access-rights-constants for a full list of values.\n+    /// </remarks>\n+    [Flags]\n+\n+    // TODO dshepelev: Fix suppression.\n+#pragma warning disable CS3009 // Base type is not CLS-compliant.\n+    public enum DesiredAccess : uint",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: whitespace",
              "createdAt": "2023-08-24T16:50:56Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -531,23 +543,31 @@ public override bool IsTaskInputLoggingEnabled\n                     return _taskHost._currentConfiguration.IsTaskInputLoggingEnabled;\n                 }\n             }\n+\n+            /// <inheritdoc/>\n+            public override void ReportFileAccess(FileAccessData fileAccessData)\n+            {\n+#if FEATURE_REPORTFILEACCESSES\n+                _taskHost._fileAccessData.Add(fileAccessData);\n+#endif\n+            }\n         }\n \n         public EngineServices EngineServices { get; }\n \n-        #endregion\n+#endregion\n \n #endif\n \n-        #region INodePacketFactory Members\n+                #region INodePacketFactory Members\n \n-        /// <summary>\n-        /// Registers the specified handler for a particular packet type.\n-        /// </summary>\n-        /// <param name=\"packetType\">The packet type.</param>\n-        /// <param name=\"factory\">The factory for packets of the specified type.</param>\n-        /// <param name=\"handler\">The handler to be called when packets of the specified type are received.</param>\n-        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+                /// <summary>\n+                /// Registers the specified handler for a particular packet type.\n+                /// </summary>\n+                /// <param name=\"packetType\">The packet type.</param>\n+                /// <param name=\"factory\">The factory for packets of the specified type.</param>\n+                /// <param name=\"handler\">The handler to be called when packets of the specified type are received.</param>\n+                public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Lol how did this happen =P",
              "createdAt": "2023-08-24T22:09:33Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -531,23 +543,31 @@ public override bool IsTaskInputLoggingEnabled\n                     return _taskHost._currentConfiguration.IsTaskInputLoggingEnabled;\n                 }\n             }\n+\n+            /// <inheritdoc/>\n+            public override void ReportFileAccess(FileAccessData fileAccessData)\n+            {\n+#if FEATURE_REPORTFILEACCESSES\n+                _taskHost._fileAccessData.Add(fileAccessData);\n+#endif\n+            }\n         }\n \n         public EngineServices EngineServices { get; }\n \n-        #endregion\n+#endregion\n \n #endif\n \n-        #region INodePacketFactory Members\n+                #region INodePacketFactory Members\n \n-        /// <summary>\n-        /// Registers the specified handler for a particular packet type.\n-        /// </summary>\n-        /// <param name=\"packetType\">The packet type.</param>\n-        /// <param name=\"factory\">The factory for packets of the specified type.</param>\n-        /// <param name=\"handler\">The handler to be called when packets of the specified type are received.</param>\n-        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)\n+                /// <summary>\n+                /// Registers the specified handler for a particular packet type.\n+                /// </summary>\n+                /// <param name=\"packetType\">The packet type.</param>\n+                /// <param name=\"factory\">The factory for packets of the specified type.</param>\n+                /// <param name=\"handler\">The handler to be called when packets of the specified type are received.</param>\n+                public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this need to be done in the ctor or could it be in the field? The ifdefs make it ugly :)",
              "createdAt": "2023-08-24T16:52:16Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -193,6 +202,9 @@ public OutOfProcTaskHostNode()\n \n #if !CLR2COMPATIBILITY\n             EngineServices = new EngineServicesImpl(this);\n+#endif\n+#if FEATURE_REPORTFILEACCESSES\n+            _fileAccessData = new List<FileAccessData>();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Moved to be a field initializer",
              "createdAt": "2023-08-24T22:11:02Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -193,6 +202,9 @@ public OutOfProcTaskHostNode()\n \n #if !CLR2COMPATIBILITY\n             EngineServices = new EngineServicesImpl(this);\n+#endif\n+#if FEATURE_REPORTFILEACCESSES\n+            _fileAccessData = new List<FileAccessData>();",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you call getcomponent outside the foreach so it only has to be done once?",
              "createdAt": "2023-08-24T16:55:03Z",
              "path": "src/Build/Instance/TaskFactories/TaskHostTask.cs",
              "diffHunk": "@@ -433,6 +435,14 @@ private void HandlePacket(INodePacket packet, out bool taskFinished)\n         /// </summary>\n         private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplete)\n         {\n+#if FEATURE_REPORTFILEACCESSES\n+            foreach (FileAccessData fileAccessData in taskHostTaskComplete.FileAccessData)\n+            {\n+                ((IFileAccessManager)_buildComponentHost.GetComponent(BuildComponentType.FileAccessManager))",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I see two options\r\n* check in those setters too\r\n* Check at read time and throw if there's an inconsistent set.\r\n\r\nI'm indifferent between the two.",
              "createdAt": "2023-08-24T19:42:43Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -801,6 +804,30 @@ public string OutputResultsCacheFile\n             set => _outputResultsCacheFile = value;\n         }\n \n+#if FEATURE_REPORTFILEACCESSES\n+        /// <summary>\n+        /// Gets or sets a value indicating whether file accesses should be reported to any configured project cache plugins.\n+        /// </summary>\n+        public bool ReportFileAccesses\n+        {\n+            get => _reportFileAccesses;\n+            set\n+            {\n+                _reportFileAccesses = value;\n+\n+                // TODO dfederm: What if either of these are set after ReportFileAccesses is? Do we need to move this elsewhere?",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I'm taking a slightly different route. I'm just moving this to `BuildManager.BeginBuild`. It just forces these to the correct values when `ReportFileAccesses` is enabled.\r\n\r\nThat's... maybe going against the users wishes, but also just doesn't allow them to do the wrong thing. Without making everything more complex like tracking whether these params were explicitly set or not, I think this might be an OK solution.",
              "createdAt": "2023-08-24T22:35:39Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -801,6 +804,30 @@ public string OutputResultsCacheFile\n             set => _outputResultsCacheFile = value;\n         }\n \n+#if FEATURE_REPORTFILEACCESSES\n+        /// <summary>\n+        /// Gets or sets a value indicating whether file accesses should be reported to any configured project cache plugins.\n+        /// </summary>\n+        public bool ReportFileAccesses\n+        {\n+            get => _reportFileAccesses;\n+            set\n+            {\n+                _reportFileAccesses = value;\n+\n+                // TODO dfederm: What if either of these are set after ReportFileAccesses is? Do we need to move this elsewhere?",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd remove the Mono stuff, since we don't support it any more.",
              "createdAt": "2023-08-24T19:46:50Z",
              "path": "src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,225 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if FEATURE_REPORTFILEACCESSES\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using BuildXL.Processes;\n+using BuildXL.Utilities.Core;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.FileAccesses;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent\n+    {\n+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();\n+\n+        private IFileAccessManager _fileAccessManager;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));\n+            return new DetouredNodeLauncher();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _fileAccessManager = null;\n+\n+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)\n+            {\n+                sandboxedProcess.Dispose();\n+            }\n+\n+            _sandboxedProcesses.Clear();\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process\n+        /// </summary>\n+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)\n+        {\n+            // Should always have been set already.\n+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));\n+\n+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));\n+\n+            if (!FileSystems.Default.FileExists(msbuildLocation))\n+            {\n+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n+            }\n+\n+            // Repeat the executable name as the first token of the command line because the command line\n+            // parser logic expects it and will otherwise skip the first argument\n+            commandLineArgs = $\"\\\"{msbuildLocation}\\\" {commandLineArgs}\";\n+\n+            CommunicationsUtilities.Trace(\"Launching node from {0}\", msbuildLocation);\n+\n+            string exeName = msbuildLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Nice. Maybe I'll create a separate PR some time to get rid of `MONO`. Maybe...",
              "createdAt": "2023-08-24T22:37:21Z",
              "path": "src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,225 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if FEATURE_REPORTFILEACCESSES\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using BuildXL.Processes;\n+using BuildXL.Utilities.Core;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.FileAccesses;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent\n+    {\n+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();\n+\n+        private IFileAccessManager _fileAccessManager;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));\n+            return new DetouredNodeLauncher();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _fileAccessManager = null;\n+\n+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)\n+            {\n+                sandboxedProcess.Dispose();\n+            }\n+\n+            _sandboxedProcesses.Clear();\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process\n+        /// </summary>\n+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)\n+        {\n+            // Should always have been set already.\n+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));\n+\n+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));\n+\n+            if (!FileSystems.Default.FileExists(msbuildLocation))\n+            {\n+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n+            }\n+\n+            // Repeat the executable name as the first token of the command line because the command line\n+            // parser logic expects it and will otherwise skip the first argument\n+            commandLineArgs = $\"\\\"{msbuildLocation}\\\" {commandLineArgs}\";\n+\n+            CommunicationsUtilities.Trace(\"Launching node from {0}\", msbuildLocation);\n+\n+            string exeName = msbuildLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Domino? \ud83d\ude07 ",
              "createdAt": "2023-08-24T19:48:53Z",
              "path": "src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,225 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if FEATURE_REPORTFILEACCESSES\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using BuildXL.Processes;\n+using BuildXL.Utilities.Core;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.FileAccesses;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent\n+    {\n+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();\n+\n+        private IFileAccessManager _fileAccessManager;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));\n+            return new DetouredNodeLauncher();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _fileAccessManager = null;\n+\n+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)\n+            {\n+                sandboxedProcess.Dispose();\n+            }\n+\n+            _sandboxedProcesses.Clear();\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process\n+        /// </summary>\n+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)\n+        {\n+            // Should always have been set already.\n+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));\n+\n+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));\n+\n+            if (!FileSystems.Default.FileExists(msbuildLocation))\n+            {\n+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n+            }\n+\n+            // Repeat the executable name as the first token of the command line because the command line\n+            // parser logic expects it and will otherwise skip the first argument\n+            commandLineArgs = $\"\\\"{msbuildLocation}\\\" {commandLineArgs}\";\n+\n+            CommunicationsUtilities.Trace(\"Launching node from {0}\", msbuildLocation);\n+\n+            string exeName = msbuildLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+            // Mono automagically uses the current mono, to execute a managed assembly\n+            if (!NativeMethodsShared.IsMono)\n+            {\n+                // Run the child process with the same host as the currently-running process.\n+                exeName = CurrentHost.GetCurrentHost();\n+            }\n+#endif\n+\n+            var eventListener = new DetoursEventListener(_fileAccessManager, nodeId);\n+            eventListener.SetMessageHandlingFlags(MessageHandlingFlags.DebugMessageNotify | MessageHandlingFlags.FileAccessNotify | MessageHandlingFlags.ProcessDataNotify | MessageHandlingFlags.ProcessDetoursStatusNotify);\n+\n+            var info = new SandboxedProcessInfo(\n+                fileStorage: null, // Don't write stdout/stderr to files\n+                fileName: exeName,\n+                disableConHostSharing: false,\n+                detoursEventListener: eventListener,\n+                createJobObjectForCurrentProcess: false)\n+            {\n+                SandboxKind = SandboxKind.Default,\n+                PipDescription = \"MSBuild\",\n+                PipSemiStableHash = 0,\n+                Arguments = commandLineArgs,\n+                EnvironmentVariables = EnvironmentalBuildParameters.Instance,\n+                MaxLengthInMemory = 0, // Don't buffer any output\n+            };\n+\n+            // FileAccessManifest.AddScope is used to define the list of files which the running process is allowed to access and what kinds of file accesses are allowed\n+            // Tracker internally uses AbsolutePath.Invalid to represent the root, just like Unix '/' root.\n+            // this code allows all types of accesses for all files\n+            info.FileAccessManifest.AddScope(\n+                AbsolutePath.Invalid,\n+                FileAccessPolicy.MaskNothing,\n+                FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);\n+\n+            // Support shared compilation\n+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = new string[] { NativeMethodsShared.IsWindows ? \"VBCSCompiler.exe\" : \"VBCSCompiler\" };\n+            info.FileAccessManifest.MonitorChildProcesses = true;\n+            info.FileAccessManifest.IgnoreReparsePoints = true;\n+            info.FileAccessManifest.UseExtraThreadToDrainNtClose = false;\n+            info.FileAccessManifest.UseLargeNtClosePreallocatedList = true;\n+            info.FileAccessManifest.LogProcessData = true;\n+\n+            // needed for logging process arguments when a new process is invoked; see DetoursEventListener.cs\n+            info.FileAccessManifest.ReportProcessArgs = true;\n+\n+            // By default, Domino sets the timestamp of all input files to January 1, 1970",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Wow, bad copy/paste from a place that also incorrectly has this :)",
              "createdAt": "2023-08-24T22:38:25Z",
              "path": "src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs",
              "diffHunk": "@@ -0,0 +1,225 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#if FEATURE_REPORTFILEACCESSES\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Linq;\n+using BuildXL.Processes;\n+using BuildXL.Utilities.Core;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.FileAccesses;\n+using Microsoft.Build.Internal;\n+using Microsoft.Build.Shared;\n+using Microsoft.Build.Shared.FileSystem;\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.BackEnd\n+{\n+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent\n+    {\n+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();\n+\n+        private IFileAccessManager _fileAccessManager;\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));\n+            return new DetouredNodeLauncher();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _fileAccessManager = null;\n+\n+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)\n+            {\n+                sandboxedProcess.Dispose();\n+            }\n+\n+            _sandboxedProcesses.Clear();\n+        }\n+\n+        /// <summary>\n+        /// Creates a new MSBuild process\n+        /// </summary>\n+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)\n+        {\n+            // Should always have been set already.\n+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));\n+\n+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));\n+\n+            if (!FileSystems.Default.FileExists(msbuildLocation))\n+            {\n+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(\"CouldNotFindMSBuildExe\", msbuildLocation));\n+            }\n+\n+            // Repeat the executable name as the first token of the command line because the command line\n+            // parser logic expects it and will otherwise skip the first argument\n+            commandLineArgs = $\"\\\"{msbuildLocation}\\\" {commandLineArgs}\";\n+\n+            CommunicationsUtilities.Trace(\"Launching node from {0}\", msbuildLocation);\n+\n+            string exeName = msbuildLocation;\n+\n+#if RUNTIME_TYPE_NETCORE || MONO\n+            // Mono automagically uses the current mono, to execute a managed assembly\n+            if (!NativeMethodsShared.IsMono)\n+            {\n+                // Run the child process with the same host as the currently-running process.\n+                exeName = CurrentHost.GetCurrentHost();\n+            }\n+#endif\n+\n+            var eventListener = new DetoursEventListener(_fileAccessManager, nodeId);\n+            eventListener.SetMessageHandlingFlags(MessageHandlingFlags.DebugMessageNotify | MessageHandlingFlags.FileAccessNotify | MessageHandlingFlags.ProcessDataNotify | MessageHandlingFlags.ProcessDetoursStatusNotify);\n+\n+            var info = new SandboxedProcessInfo(\n+                fileStorage: null, // Don't write stdout/stderr to files\n+                fileName: exeName,\n+                disableConHostSharing: false,\n+                detoursEventListener: eventListener,\n+                createJobObjectForCurrentProcess: false)\n+            {\n+                SandboxKind = SandboxKind.Default,\n+                PipDescription = \"MSBuild\",\n+                PipSemiStableHash = 0,\n+                Arguments = commandLineArgs,\n+                EnvironmentVariables = EnvironmentalBuildParameters.Instance,\n+                MaxLengthInMemory = 0, // Don't buffer any output\n+            };\n+\n+            // FileAccessManifest.AddScope is used to define the list of files which the running process is allowed to access and what kinds of file accesses are allowed\n+            // Tracker internally uses AbsolutePath.Invalid to represent the root, just like Unix '/' root.\n+            // this code allows all types of accesses for all files\n+            info.FileAccessManifest.AddScope(\n+                AbsolutePath.Invalid,\n+                FileAccessPolicy.MaskNothing,\n+                FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);\n+\n+            // Support shared compilation\n+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = new string[] { NativeMethodsShared.IsWindows ? \"VBCSCompiler.exe\" : \"VBCSCompiler\" };\n+            info.FileAccessManifest.MonitorChildProcesses = true;\n+            info.FileAccessManifest.IgnoreReparsePoints = true;\n+            info.FileAccessManifest.UseExtraThreadToDrainNtClose = false;\n+            info.FileAccessManifest.UseLargeNtClosePreallocatedList = true;\n+            info.FileAccessManifest.LogProcessData = true;\n+\n+            // needed for logging process arguments when a new process is invoked; see DetoursEventListener.cs\n+            info.FileAccessManifest.ReportProcessArgs = true;\n+\n+            // By default, Domino sets the timestamp of all input files to January 1, 1970",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I do not understand this comment--perhaps something was renamed?",
              "createdAt": "2023-08-24T19:52:35Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,24 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal interface IFileAccessManager\n+    {\n+        void ReportFileAccess(FileAccessData fileAccessData, int nodeId);\n+\n+        void ReportProcess(ProcessData processData, int nodeId);\n+\n+        // Note: HandlerRegistration is exposed directly instead of IDisposable to avoid boxing.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I'll clarify the comment, but it means `FileAccessManager.HandlerRegistration`, ie the return type. It's a struct which implements `IDisposable` and so instead of the return type being `IDisposable`, it's the struct type so that it doesn't get boxed.\r\n\r\nTbh, this is called exactly once per plugin, of which there will likely be exactly 1 in most cases, if any. So this doesn't actually save much =P",
              "createdAt": "2023-08-24T22:41:00Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,24 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Framework.FileAccess;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal interface IFileAccessManager\n+    {\n+        void ReportFileAccess(FileAccessData fileAccessData, int nodeId);\n+\n+        void ReportProcess(ProcessData processData, int nodeId);\n+\n+        // Note: HandlerRegistration is exposed directly instead of IDisposable to avoid boxing.",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "?",
              "createdAt": "2023-08-24T19:54:40Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -421,6 +427,83 @@ public void Translate(ref BuildEventContext value)\n                     _reader.ReadInt32());\n             }\n \n+            /// <inheritdoc/>\n+            public void Translate(ref FileAccessData fileAccessData)\n+            {\n+                ReportedFileOperation reportedFileOperation = default;\n+                RequestedAccess requestedAccess = default;\n+                uint processId = default;\n+                uint error = default;\n+                DesiredAccess desiredAccess = default;\n+                FlagsAndAttributes flagsAndAttributes = default;\n+                string path = default;\n+#nullable enable",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Seems like this file has a bunch of enabling/disabling nullable. I'm not sure enabling just for this one line adds anything though lol. I'll remove this one.",
              "createdAt": "2023-08-24T22:43:59Z",
              "path": "src/Framework/BinaryTranslator.cs",
              "diffHunk": "@@ -421,6 +427,83 @@ public void Translate(ref BuildEventContext value)\n                     _reader.ReadInt32());\n             }\n \n+            /// <inheritdoc/>\n+            public void Translate(ref FileAccessData fileAccessData)\n+            {\n+                ReportedFileOperation reportedFileOperation = default;\n+                RequestedAccess requestedAccess = default;\n+                uint processId = default;\n+                uint error = default;\n+                DesiredAccess desiredAccess = default;\n+                FlagsAndAttributes flagsAndAttributes = default;\n+                string path = default;\n+#nullable enable",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could/should this be behind the ifdef?",
              "createdAt": "2023-08-24T19:56:24Z",
              "path": "src/Build/BackEnd/Node/OutOfProcNode.cs",
              "diffHunk": "@@ -153,10 +154,11 @@ public OutOfProcNode()\n \n             // Create a factory for the out-of-proc SDK resolver service which can pass our SendPacket delegate to be used for sending packets to the main node\n             OutOfProcNodeSdkResolverServiceFactory sdkResolverServiceFactory = new OutOfProcNodeSdkResolverServiceFactory(SendPacket);\n-\n             ((IBuildComponentHost)this).RegisterFactory(BuildComponentType.SdkResolverService, sdkResolverServiceFactory.CreateInstance);\n-\n             _sdkResolverService = (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;\n+            ((IBuildComponentHost)this).RegisterFactory(\n+                BuildComponentType.FileAccessManager,\n+                (componentType) => OutOfProcNodeFileAccessManager.CreateComponent(componentType, SendPacket));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yup, I'll even ifdef this entire `BuildComponentType` and the `IFileAccessManager` interface. This should help things blow up harder if code paths which shouldn't be hit are. And I don't think it'll make all the ifdefs *too* messy.",
              "createdAt": "2023-08-24T22:57:24Z",
              "path": "src/Build/BackEnd/Node/OutOfProcNode.cs",
              "diffHunk": "@@ -153,10 +154,11 @@ public OutOfProcNode()\n \n             // Create a factory for the out-of-proc SDK resolver service which can pass our SendPacket delegate to be used for sending packets to the main node\n             OutOfProcNodeSdkResolverServiceFactory sdkResolverServiceFactory = new OutOfProcNodeSdkResolverServiceFactory(SendPacket);\n-\n             ((IBuildComponentHost)this).RegisterFactory(BuildComponentType.SdkResolverService, sdkResolverServiceFactory.CreateInstance);\n-\n             _sdkResolverService = (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;\n+            ((IBuildComponentHost)this).RegisterFactory(\n+                BuildComponentType.FileAccessManager,\n+                (componentType) => OutOfProcNodeFileAccessManager.CreateComponent(componentType, SendPacket));",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't get it, can you elaborate?",
              "createdAt": "2023-08-24T20:02:10Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2367,6 +2390,38 @@ private void HandleResult(int node, BuildResult result)\n                 configuration.ProjectTargets ??= result.ProjectTargets;\n             }\n \n+            // Only report results to the project cache services if it's the result for a build submission.\n+            // Note that graph builds create a submission for each node in the graph, so each node in the graph will be\n+            // handled here. This intentionally mirrors the behavior for cache requests, as it doesn't make sense to\n+            // report for projects which aren't going to be requested. Ideally, *any* request could be handled, but that\n+            // would require moving the cache service interactions to the Scheduler.\n+            if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission buildSubmission))\n+            {\n+                // The result may be associated with the build submission due to it being the submission which\n+                // caused the build, but not the actual request which was used with the build submission. Ensure\n+                // only the actual submission's request is considered.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Sure, I'll clarify the comment but basically if a build submission causes other build requests to fire off (ie dependencies), then we'll get results for those and it will have the submission if that kicked the whole thing off, but what we're looking for here is just the result for the \"top level\" request.\r\n\r\nIn a well-described graph, all results would be for top-level requests :)",
              "createdAt": "2023-08-24T23:03:11Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2367,6 +2390,38 @@ private void HandleResult(int node, BuildResult result)\n                 configuration.ProjectTargets ??= result.ProjectTargets;\n             }\n \n+            // Only report results to the project cache services if it's the result for a build submission.\n+            // Note that graph builds create a submission for each node in the graph, so each node in the graph will be\n+            // handled here. This intentionally mirrors the behavior for cache requests, as it doesn't make sense to\n+            // report for projects which aren't going to be requested. Ideally, *any* request could be handled, but that\n+            // would require moving the cache service interactions to the Scheduler.\n+            if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission buildSubmission))\n+            {\n+                // The result may be associated with the build submission due to it being the submission which\n+                // caused the build, but not the actual request which was used with the build submission. Ensure\n+                // only the actual submission's request is considered.",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This is Windows-specific which is fine but I'd like to annotate it for futureproofness. Adding `[SupportedOSPlatform(\"windows\")]` popped up a few places where I'm not sure what the right thing is.",
              "createdAt": "2023-08-24T20:10:55Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,181 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);\n+\n+        // In order to synchronize between the node communication and the file access reporting, a special file access\n+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen\n+        // and the build result is reported can plugins be notified about project completion.\n+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @\":\\{MSBuildFileAccessCompletion}\\\";",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this be under the ifdef? I am a bit surprised to see it everywhere but may not understand the layering you're thinking of.",
              "createdAt": "2023-08-24T20:11:36Z",
              "path": "src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs",
              "diffHunk": "@@ -80,6 +82,8 @@ public void RegisterDefaultFactories()\n \n             // SDK resolution\n             _componentEntriesByType[BuildComponentType.SdkResolverService] = new BuildComponentEntry(BuildComponentType.SdkResolverService, MainNodeSdkResolverService.CreateComponent, CreationPattern.Singleton);\n+\n+            _componentEntriesByType[BuildComponentType.FileAccessManager] = new BuildComponentEntry(BuildComponentType.FileAccessManager, FileAccessManager.CreateComponent, CreationPattern.Singleton);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yup, I was a little too conservative with the ifdefs to avoid sprinkling it everywhere. It wasn't too bad though so just went ahead and did it.",
              "createdAt": "2023-08-24T23:11:01Z",
              "path": "src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs",
              "diffHunk": "@@ -80,6 +82,8 @@ public void RegisterDefaultFactories()\n \n             // SDK resolution\n             _componentEntriesByType[BuildComponentType.SdkResolverService] = new BuildComponentEntry(BuildComponentType.SdkResolverService, MainNodeSdkResolverService.CreateComponent, CreationPattern.Singleton);\n+\n+            _componentEntriesByType[BuildComponentType.FileAccessManager] = new BuildComponentEntry(BuildComponentType.FileAccessManager, FileAccessManager.CreateComponent, CreationPattern.Singleton);",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This justification strikes me as a bit sketchy. MSBuild certainly _can_ use files in the temp folder for its own stuff--but so can random tools. Is it more like \"you shouldn't have real tracked inputs under TEMP\" at the project level?",
              "createdAt": "2023-08-24T20:16:03Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,181 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);\n+\n+        // In order to synchronize between the node communication and the file access reporting, a special file access\n+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen\n+        // and the build result is reported can plugins be notified about project completion.\n+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @\":\\{MSBuildFileAccessCompletion}\\\";\n+\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private object _handlersWriteLock = new object();\n+        private Handlers[] _handlers = Array.Empty<Handlers>();\n+        private string? _tempDirectory;\n+\n+        // Keyed on global request id\n+        private readonly ConcurrentDictionary<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles = new();\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new FileAccessManager();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;\n+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;\n+            _tempDirectory = FileUtilities.EnsureNoTrailingSlash(FileUtilities.TempFileDirectory);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _scheduler = null;\n+            _configCache = null;\n+            _tempDirectory = null;\n+            _fileAccessCompletionWaitHandles.Clear();\n+        }\n+\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)\n+        {\n+            string fileAccessPath = fileAccessData.Path;\n+\n+            // Intercept and avoid forwarding the file access completion\n+            if (fileAccessPath.StartsWith(FileAccessCompletionPrefix, StringComparison.Ordinal))\n+            {\n+                // Parse out the global request id. Note, this must match what NotifyFileAccessCompletion does.\n+                int globalRequestId = int.Parse(fileAccessPath.Substring(FileAccessCompletionPrefix.Length));\n+\n+                ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());\n+                handle.Set();\n+            }\n+            else if (_tempDirectory != null && fileAccessPath.StartsWith(_tempDirectory))\n+            {\n+                // Ignore the temp directory as these are related to internal MSBuild functionality and not always directly related to the execution of the project itself,\n+                // so should not be exposed to handlers.\n+                return;\n+            }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I'll clarify the comment. This actually isn't `%TEMP%` but instead MSBuild's temp dir which is `%TEMP%\\MSBuildTemp<user><extrabits>`, or the Linux equivalent. If people are using that for build outputs, I'll riot",
              "createdAt": "2023-08-24T23:12:32Z",
              "path": "src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs",
              "diffHunk": "@@ -0,0 +1,181 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.IO;\n+using System.Threading;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework.FileAccess;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.FileAccesses\n+{\n+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent\n+    {\n+        private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);\n+\n+        // In order to synchronize between the node communication and the file access reporting, a special file access\n+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen\n+        // and the build result is reported can plugins be notified about project completion.\n+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @\":\\{MSBuildFileAccessCompletion}\\\";\n+\n+        private IScheduler? _scheduler;\n+        private IConfigCache? _configCache;\n+\n+        private object _handlersWriteLock = new object();\n+        private Handlers[] _handlers = Array.Empty<Handlers>();\n+        private string? _tempDirectory;\n+\n+        // Keyed on global request id\n+        private readonly ConcurrentDictionary<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles = new();\n+\n+        public static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));\n+            return new FileAccessManager();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;\n+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;\n+            _tempDirectory = FileUtilities.EnsureNoTrailingSlash(FileUtilities.TempFileDirectory);\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            _scheduler = null;\n+            _configCache = null;\n+            _tempDirectory = null;\n+            _fileAccessCompletionWaitHandles.Clear();\n+        }\n+\n+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)\n+        {\n+            string fileAccessPath = fileAccessData.Path;\n+\n+            // Intercept and avoid forwarding the file access completion\n+            if (fileAccessPath.StartsWith(FileAccessCompletionPrefix, StringComparison.Ordinal))\n+            {\n+                // Parse out the global request id. Note, this must match what NotifyFileAccessCompletion does.\n+                int globalRequestId = int.Parse(fileAccessPath.Substring(FileAccessCompletionPrefix.Length));\n+\n+                ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());\n+                handle.Set();\n+            }\n+            else if (_tempDirectory != null && fileAccessPath.StartsWith(_tempDirectory))\n+            {\n+                // Ignore the temp directory as these are related to internal MSBuild functionality and not always directly related to the execution of the project itself,\n+                // so should not be exposed to handlers.\n+                return;\n+            }",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Required? Something that will actually get done?",
              "createdAt": "2023-08-24T20:28:43Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -218,18 +234,53 @@ private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectIn\n                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheInitializationFailed\");\n                 }\n \n-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);\n+                FileAccessManager.HandlerRegistration handlerRegistration = _fileAccessManager.RegisterHandlers(\n+                    (buildRequest, fileAccessData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "It's a bit of a niche scenario so not something I've prioritized. If two projects configured different plugins, both would get accesses from both projects, but only be queried for the projects which configured it. Any reasonable plugin would just ignore the extra stuff, and because this is such an edge case I'm not considering this a hard requirement to fix, but ideally I'd like to tighten this up at some point.",
              "createdAt": "2023-08-24T23:17:00Z",
              "path": "src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs",
              "diffHunk": "@@ -218,18 +234,53 @@ private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectIn\n                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache(\"ProjectCacheInitializationFailed\");\n                 }\n \n-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);\n+                FileAccessManager.HandlerRegistration handlerRegistration = _fileAccessManager.RegisterHandlers(\n+                    (buildRequest, fileAccessData) =>\n+                    {\n+                        // TODO: Filter out projects which do not configure this plugin",
              "author": {
                "login": "dfederm"
              }
            }
          ]
        }
      }
    ]
  }
}