{
  "number": 5859,
  "title": "Introduce cross-process resource management for tasks",
  "body": "Add `RequestCores` and `ReleaseCores` APIs to `IBuildEngine8`.\r\n\r\nThese APIs can advise a task that wishes to do work with its own internal parallelism. The task can request as many (abstracted) CPU cores as it desires, and the MSBuild engine will keep track of how many have been requested and prevent the machine from being completely overloaded.\r\n\r\nSince this is advisory only, existing tasks will be unaffected. The Visual C++ tasks plan to opt into this.\r\n\r\nSee `resource-management.md` for more design and implementation details.\r\n\r\nFixes #74\r\n",
  "state": "MERGED",
  "createdAt": "2020-11-05T17:26:35Z",
  "updatedAt": "2021-10-25T11:20:01Z",
  "closedAt": "2021-03-30T15:25:48Z",
  "mergedAt": "2021-03-30T15:25:48Z",
  "additions": 1592,
  "deletions": 137,
  "changedFiles": 50,
  "headRefName": "exp/resource-management",
  "isDraft": false,
  "author": {
    "login": "rainersigwald"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "ladipro"
      }
    ]
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "f48f3d9db4ea9389fc9e2d6041c7148854921822",
          "message": "Initial draft of changes.",
          "committedDate": "2020-02-25T20:54:53Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "villalobosb93@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bcccfea9d4a57b257188f6cc9a6928e922e898aa",
          "message": "Modified mockengine to support ibuildengine7\n\nGot straightforward unit tests working.\nAdded null check and cached the Semaphore.",
          "committedDate": "2020-02-26T23:03:05Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "villalobosb93@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "73b3466b056c456a6419a2ac9b12ce36f562d635",
          "message": "Simpler null checks",
          "committedDate": "2020-02-28T22:33:12Z",
          "author": {
            "name": "Ben Villalobos",
            "email": "villalobosb93@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a8df6ac1974fadfab4b967508d6d6b658ca78ef6",
          "message": "Merge remote-tracking branch 'upstream/master' into 74-cpp-parallel",
          "committedDate": "2020-03-04T20:15:22Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "963a785f77f11c22863034b2d978d2fdaff235f0",
          "message": "Clean up API surface",
          "committedDate": "2020-04-27T14:51:17Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e1a30e6f405b7e2667637dbb7435e80dde501233",
          "message": "Tasks type name",
          "committedDate": "2020-04-27T14:51:17Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "055116a4ad000093082dce23a4c4298d3b616d9e",
          "message": "simple project",
          "committedDate": "2020-04-27T14:51:17Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "10f6eedcdbb6af2b54abbe9296aac7caedf367ef",
          "message": "Simplify if-appdomain in NodeConfiguration",
          "committedDate": "2020-04-27T14:51:18Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aa3f3855d5ec2a4bff78e3981431eb539b73cdd1",
          "message": "Checkpoint",
          "committedDate": "2020-04-27T14:51:18Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "57a5c936ab1e2e3dc05b189858280905ccce9931",
          "message": "Remove FEATURE_VARIOUS_EXCEPTIONS",
          "committedDate": "2020-04-27T14:51:19Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "92291220c31fca9085cd97bee35257a453403e99",
          "message": "Checkpoint: works on full only, doesn't properly block when all resources consumed but want to start a task",
          "committedDate": "2020-04-27T14:51:20Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b9198344329857dc72be98c047e0828165343d40",
          "message": "Make TaskHost.MarkAsInactive work on Core",
          "committedDate": "2020-04-27T14:51:20Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "01953aa70297b872ffd63cb4de881906fdcf58c0",
          "message": "Tweak test to show cross-process handling",
          "committedDate": "2020-04-27T14:51:21Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1183e877562bea3f4a7496d1e9a5f3fe3aaeb213",
          "message": "Introduce RequireCores",
          "committedDate": "2020-04-27T14:51:22Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0437c325f622cd5da215817ed86fe2d9356a890e",
          "message": "WIP",
          "committedDate": "2020-04-27T14:51:22Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1bf3017575c03d18352f6c757d772997913f044a",
          "message": "Revert \"WIP\"\n\nThis reverts commit f60c66a605c667d4190405af63050f972cca8b80.",
          "committedDate": "2020-04-27T14:51:23Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1ada7c2a134202712739e80620bb4c6b0be2f2b1",
          "message": "Horrible pile of WIP hacks to debug hang",
          "committedDate": "2020-04-27T14:51:23Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e9436558ba0ebaad880d85f2a6faf282dbc9ee32",
          "message": "Revert \"Horrible pile of WIP hacks to debug hang\"\n\nThis reverts commit 3c7a3f87ee22011cfd63090960fee0c7a55c2d22.",
          "committedDate": "2020-04-27T14:51:23Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ca6697d34081a4598e3137a5fbeacaa0c2304240",
          "message": "Move requiring core to ExecuteInstantiatedTask\n\nThis should alleviate hangs that were happening as a result of leaks\nthat happened when MSBuild/CallTarget got a resource, then\nwe started building other projects.",
          "committedDate": "2020-04-27T14:51:24Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "63a324ba2711c0210b7f4315d130517d5796f72d",
          "message": "Merge remote-tracking branch 'upstream/master' into exp/resource-management",
          "committedDate": "2020-04-27T14:53:19Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "09618ecb527d29512fced7d40e9bcc015015870b",
          "message": "Release core when yielding (hopefully working around hang when many threads yielded + reacquiring)",
          "committedDate": "2020-05-01T22:33:39Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5a7ad2be2751191455ca470145a1ce77cf37b2a4",
          "message": "WIP: new semaphore name per session (by default)",
          "committedDate": "2020-06-10T14:45:19Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "141c57cffc8abbaed344714169df2726b2f4b32e",
          "message": "Merge remote-tracking branch 'upstream/master' into exp/resource-management",
          "committedDate": "2020-06-11T20:54:50Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "007d9f3b9ce7ea1cb39e0b92e4f7b23a1e64205b",
          "message": "Release a core when calling BuildProjectFiles\n\nOtherwise, we can deadlock: outer task gets a resource, (logically) yields to build other projects; they block on getting a resource.",
          "committedDate": "2020-06-16T15:51:53Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6b2be21676459677772192a0ba4f8c10d33e1e44",
          "message": "Switch expression for MockHost.GetComponent",
          "committedDate": "2020-06-16T15:56:31Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5d4987646032d3729a8ebd7e319d9c0679aabc13",
          "message": "Resource manager in MockHost",
          "committedDate": "2020-06-16T16:00:20Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0486730db23ffbaadb38582971625674ba6ef2bf",
          "message": "Just don't do resource management on non-Windows",
          "committedDate": "2020-06-16T17:14:59Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2f85924da1613b317fdb880de974ba677486afbf",
          "message": "Delete bogus tests",
          "committedDate": "2020-06-16T19:19:30Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5e4b0357a05b5dc3d7521f117ba7faad63fad38c",
          "message": "Doc for RequestCores",
          "committedDate": "2020-06-17T20:25:33Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a9d37a2fcb49b5dbdf358b3a8f7c664c2e08ee73",
          "message": "Merge remote-tracking branch 'upstream/master' into exp/resource-management",
          "committedDate": "2020-06-17T20:31:36Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "43bdec02f668f274836c7a60256af673baa54130",
          "message": "Merge remote-tracking branch 'upstream/master' into exp/resource-management",
          "committedDate": "2020-07-15T19:41:55Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "479cdfcd1a78b8e671f4e47e0dcaba03daca047d",
          "message": "Add BlockingWaitForCore",
          "committedDate": "2020-07-15T20:55:28Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9db29bbbd16858eeb36e5d5e4886e28eb886b5b4",
          "message": "Treat resources as a separate pool; don't auto-acquire for tasks",
          "committedDate": "2020-07-15T21:13:38Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e1c3bff21d7a05505fe26aaf1aedda27db1bc55b",
          "message": "fixup! Add BlockingWaitForCore",
          "committedDate": "2020-07-15T21:14:00Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "58fa35545104cf39901b80a1c5d7b596d5f55622",
          "message": "Doc updates",
          "committedDate": "2020-07-15T21:35:35Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a6a9d6dce6c2e5448eed9823c064c2853213d9d9",
          "message": "Merge remote-tracking branch 'upstream/master' into exp/resource-management",
          "committedDate": "2020-09-16T14:47:08Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "91fe07ab1ca40241ccd964dee4474d28b8c1dad3",
          "message": "Block for at least one core in RequestCores",
          "committedDate": "2020-09-16T15:16:43Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c9b3c7832c37a316566e246f7bda6abd18b8b70a",
          "message": "Merge remote-tracking branch 'upstream/master' into exp/resource-management",
          "committedDate": "2020-10-21T15:03:32Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ba2db9aa3a137b93fa2109da9c3586fad2e12e0f",
          "message": "Remove BlockingWaitForCore() since it's now redundant",
          "committedDate": "2020-10-21T18:31:34Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cc60df991d3a6560f8c282a094f76bca5c566fa4",
          "message": "fixup! Block for at least one core in RequestCores",
          "committedDate": "2020-10-21T18:59:22Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0ab04815b65684ac5758b050a507255c92bae011",
          "message": "Move to IBuildEngine8 since 7 shipped already",
          "committedDate": "2020-10-21T19:20:50Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f1e26c3c7fb313ce0bc6b5d4db42010f9249df73",
          "message": "remove test-project.proj",
          "committedDate": "2020-11-03T19:09:50Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "dfced2f76d61fee2790ecdb78456f20da18c6bbb",
          "message": "Remove SemaphoreCPUTask",
          "committedDate": "2020-11-03T19:15:15Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ed6a404ac708b96f037e8144da598d57d2bef1d9",
          "message": "??",
          "committedDate": "2020-11-03T19:16:03Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "45458583817aaea0662ca4f14eed3f5e8824aea1",
          "message": "sort usings in MockHost",
          "committedDate": "2020-11-05T16:44:37Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3de11c0011be59cbcf259fc420bf12a99a6b6275",
          "message": "fixup! Treat resources as a separate pool; don't auto-acquire for tasks",
          "committedDate": "2020-11-05T16:45:42Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "608bed76c0d17a26f011a104e2037656b8231798",
          "message": "fixup! Remove BlockingWaitForCore() since it's now redundant",
          "committedDate": "2020-11-05T16:47:16Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7a3da6b3b9b97a67c574f0767da1ad8bab291f2f",
          "message": "fixup! Treat resources as a separate pool; don't auto-acquire for tasks",
          "committedDate": "2020-11-05T16:48:13Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d87903f113591330ff210e1317ec01eba2b35da4",
          "message": "Remove RequireCores",
          "committedDate": "2020-11-05T16:58:36Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9a83f35275b6e03160b7e994a4d8e28c160f7746",
          "message": "Better non-Windows behavior\n\nAssert TODOs were invalid because it's no longer a simple check",
          "committedDate": "2020-11-05T16:59:27Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "77344e23cdc282805ec867c9a00398e9a51720e4",
          "message": "fixup! Move to IBuildEngine8 since 7 shipped already",
          "committedDate": "2020-11-05T17:00:05Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7fffd46c2d7b67595bdc6f71474c88d0c79448d9",
          "message": "Generalize MockEngine semaphore",
          "committedDate": "2020-11-05T17:07:35Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7d8b35924824208659c34cc3ae7fdb13dbc9e043",
          "message": "Return nullable int to indicate whether resource management is possible",
          "committedDate": "2020-12-07T19:56:57Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "82a25c4c40dbbd09ec535b264fe5f51c28208947",
          "message": "fixup! Remove RequireCores",
          "committedDate": "2020-12-07T19:57:26Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c6d1a8a36453ffccb084cee167ccbcc42615ad2e",
          "message": "Merge remote-tracking branch 'upstream/master' into HEAD",
          "committedDate": "2020-12-08T16:31:12Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b8b52cca2eb769b5bbb6c09addcbe574ab573bef",
          "message": "Nix whitespace-only changes in ProjectCollection",
          "committedDate": "2020-12-08T16:31:42Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f3e347ed9fe4e465f11c0eac19e3dbd940099c2c",
          "message": "fixup! fixup! Remove BlockingWaitForCore() since it's now redundant",
          "committedDate": "2020-12-08T16:32:35Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ab384aa8061be8ec32446fbbc03dab658e390332",
          "message": "Task whitespace fixes",
          "committedDate": "2020-12-08T16:32:40Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a9d8061fc39792935f03aefe8f6df2fb049960a1",
          "message": "Update doc for non-Windows behavior",
          "committedDate": "2020-12-08T16:32:40Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "25ec10cfc904e4d1be92eda66a861a517658e304",
          "message": "Update doc with better example, caveats",
          "committedDate": "2020-12-08T16:32:40Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b3626006c5518c7fa9c6a9c7edd92ab70884dedf",
          "message": "Whitespace fixes in TaskBuilder",
          "committedDate": "2020-12-08T16:32:41Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b830c49bd65b5e166179d4e3d9a1c0d18e6de9c3",
          "message": "Whitespace cleanup in TaskHost",
          "committedDate": "2020-12-08T16:32:41Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb2d9475ddfec8530dd8e921f5ba0eb0d4765616",
          "message": "Clarity in MockHost",
          "committedDate": "2020-12-08T16:32:42Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "59af8421315be4edb3189cf08328444eec35be9f",
          "message": "fixup! fixup! fixup! Remove BlockingWaitForCore() since it's now redundant",
          "committedDate": "2020-12-08T16:32:42Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cacc2ac989945568b03d30f07e0880e8e984c3a9",
          "message": "Log resource requests/releases\n\nThis may be a perf hog; we should consider demoting these messages to\nETW events. But for v1 they might be very valuable, so log.",
          "committedDate": "2020-12-08T16:33:24Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3c0a8e78937d78925a01e8e12bfd581845a13d80",
          "message": "Move clamp on release to service layer",
          "committedDate": "2020-12-08T16:34:28Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ded86d5234c9b6942ab111d458829047a3c2edee",
          "message": "Switch system off more gracefully on non-Windows",
          "committedDate": "2020-12-08T16:41:08Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ad77314c394390ad766868f5944d59a29b5d5889",
          "message": "Merge remote-tracking branch 'upstream/master' into exp/resource-management",
          "committedDate": "2020-12-14T16:42:01Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0c0c0b4361b90b617c53b795aee3fa2c7599a6b7",
          "message": "Release nodes on reacquire",
          "committedDate": "2020-12-15T16:09:28Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a16ca54e73a2674a4cc89dccb3f5df70c799816e",
          "message": "Merge remote-tracking branch 'upstream/master' into exp/resource-management",
          "committedDate": "2020-12-15T16:25:36Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1a497d7f66bfa77fe794e037c3bc2c9994eeb1db",
          "message": "Merge remote-tracking branch 'upstream/master' into exp/resource-management",
          "committedDate": "2020-12-15T16:38:12Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7a4e1e05d2124fb4d4e8582bc910410427965846",
          "message": "Implicit core for nonblocking 1 return",
          "committedDate": "2021-01-05T22:41:32Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3d2575c37819c51eb0f460787c265fa406123164",
          "message": "Allow environment variable MSBUILDRESOURCEMANAGEROVERSUBSCRIPTION to control oversubscription",
          "committedDate": "2021-01-05T22:48:13Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c416bf55b2d6bf111a9e94522357a0f02fdb39f7",
          "message": "Revert \"Release nodes on reacquire\"\n\nThis reverts commit 0c0c0b4361b90b617c53b795aee3fa2c7599a6b7.",
          "committedDate": "2021-01-05T23:05:46Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "444ffde90b2953cd3597eec0c77303dd5c017610",
          "message": "WIP: acquire/release resources in the scheduler",
          "committedDate": "2021-01-15T21:54:29Z",
          "author": {
            "name": "Rainer Sigwald",
            "email": "raines@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "761fb6a0722d76e8956e5ec006f49d2c2bb1628e",
          "message": "Update documentation/specs/resource-management.md\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2021-01-15T22:17:14Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2fb578993b6919dbe4bdf9031e5b372ec8aeb0e0",
          "message": "Merge remote-tracking branch 'dotnet/master' into exp/resource-management",
          "committedDate": "2021-02-17T12:31:20Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2ce2af86da1fa2463dcc98c2e5aaa2a084845b9b",
          "message": "Remove Semaphore-based logic",
          "committedDate": "2021-02-22T09:05:57Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e3439e40b4b22a800331d40509c9d28921eaf0a4",
          "message": "Plumbing to pass ResourceRequest to scheduler and ResourceResponse back to task",
          "committedDate": "2021-02-22T09:06:37Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "16538064d17ee5a871d06220905bf86efd1e20ac",
          "message": "Add missing files: ResourceRequest.cs, ResourceResponse.cs",
          "committedDate": "2021-02-22T10:32:22Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6d27a28389ef9e85d08269095f7b572669288613",
          "message": "Plumbing fixes",
          "committedDate": "2021-02-24T13:36:28Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "df40170eb5f43a3d9101e86c5b960d639b0fc8fd",
          "message": "Implement scheduling policy",
          "committedDate": "2021-02-24T13:37:20Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3d03f8634af3b898c2495b1db65ca663c6a6f0cb",
          "message": "Use 'implicit core' always, not only when scheduler returns 0",
          "committedDate": "2021-03-01T08:19:51Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ba264dafe86e254a6d5497f5c12b7082a9fb5f09",
          "message": "Use different limits for scheduling and explicit core requests",
          "committedDate": "2021-03-01T09:10:52Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d12bd75294561985613d2330f2ed0777cd0306b3",
          "message": "Make RequestCores ignore the executing request count",
          "committedDate": "2021-03-05T16:35:10Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1a6326e936e77f1fa59d538e2a1a8de57b65fb4a",
          "message": "Subtract one from _coreLimit",
          "committedDate": "2021-03-05T16:48:56Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0b1a48769ba9f9b1d6d7e374d8bf3710819fda4c",
          "message": "Change return value of RequestCores to int (null is no longer used)",
          "committedDate": "2021-03-12T15:38:09Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d38500b1e0c9505808591aa1494a8ca56013dccb",
          "message": "Do not assume that RequestCores calls come only from Executing requests",
          "committedDate": "2021-03-12T15:42:22Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "445ec333ddf0d07d93a89995324f2c23a4e286d1",
          "message": "Make RequestCores block and wait for at least one core",
          "committedDate": "2021-03-16T12:13:02Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a98adee78d0ad9a557669214aef09df8834aa0ab",
          "message": "Revert \"Use 'implicit core' always, not only when scheduler returns 0\"\n\nThis reverts commit 3d03f8634af3b898c2495b1db65ca663c6a6f0cb.",
          "committedDate": "2021-03-16T12:14:46Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "15121becd7b62f9a67952072efaee82a66305f79",
          "message": "Make the first RequestCores call non-blocking (via 'implicit' core)",
          "committedDate": "2021-03-16T12:52:39Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "02bce34ffc21a4978c2459763772054af5522be8",
          "message": "Make the implicit core the last one to release (LIFO)",
          "committedDate": "2021-03-16T13:09:16Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b382aab5e32bdb6497408e9553d37ae22c3e0753",
          "message": "Introduce MSBUILDNODECOREALLOCATIONWEIGHT",
          "committedDate": "2021-03-16T15:41:55Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8dbe0550a6a8a1a583a0ff3639c0b77a8619d913",
          "message": "Merge remote-tracking branch 'dotnet/main' into exp/resource-management",
          "committedDate": "2021-03-19T10:03:19Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "14c5d3d5d7208f31c2eb7c2e5ee135e1105c12ca",
          "message": "Allow calling RequestCores/ReleaseCores after Yield",
          "committedDate": "2021-03-23T20:57:59Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "aad6f76b1717b226d8ed49bb21704412c7472569",
          "message": "Update resource-management.md",
          "committedDate": "2021-03-24T11:46:49Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3a554b8ffbd3b94cf8f9267d72d0c51a2cd6fe58",
          "message": "Comments, renames, and tweaks",
          "committedDate": "2021-03-24T15:21:47Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "63d782e7fdbfceb8c8416c9a30cfde373006fc76",
          "message": "Remove the now unused ResourceManagerService",
          "committedDate": "2021-03-24T16:02:31Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "874ecf3eed996dba845b554aeb99ce7f6a789a69",
          "message": "Comments, renames, and tweaks",
          "committedDate": "2021-03-25T12:27:17Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8ed06ad47ecf6a2e5b34e6c29aa9459735b0a571",
          "message": "Comments, renames, and tweaks",
          "committedDate": "2021-03-25T12:58:35Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "The current implementation deadlocks when a task acquires all available resources then yields. The next task comes along, blocks on acquiring resources, and can't complete, so the first task stays blocked in reacquire:\r\n\r\n![image](https://user-images.githubusercontent.com/3347530/102147609-a3a84b80-3e30-11eb-9c93-b9a1cad3d3eb.png)\r\n",
        "createdAt": "2020-12-14T23:20:23Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Going back to https://github.com/dotnet/msbuild/pull/5859#discussion_r518468686, the thing that yields is the same thing that asks for cores. You could specify that if you ever yield, you release all cores, and if you try to reacquire, you need to ask for them again.",
        "createdAt": "2020-12-14T23:31:21Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "When the task yields it does NOT release the resources,  it only releases one msbuild node. I believe you need to include msbuild nodes into account somehow and ensure that if a node executes a task it can get always get at least one core. And if no cores are available, the node should not execute a new build. \r\n",
        "createdAt": "2020-12-15T02:03:10Z",
        "author": {
          "login": "olgaark"
        }
      },
      {
        "body": "> I believe you need to include msbuild nodes into account somehow and ensure that if a node executes a task it can get always get at least one core. And if no cores are available, the node should not execute a new build.\r\n\r\nThis is basically back to my original design that caused a variety of problems. We moved to the \"separate pool\" approach to avoid them, but it doesn't actually avoid them, it seems! I just pushed a possible path forward: release all cores at `Reacquire()` time. That's generally called late, after the task has done its work and is ready to exit. But it's not super obvious that it's happening so I don't love it. Will validate that it resolves the problem and then we can discuss it as an option.",
        "createdAt": "2020-12-15T16:11:42Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I'm not going to make any progress on this before I head out on parental leave. So here's a set of rough notes about what I've figured out so far:\r\n\r\n1. The existing implementation isn't great because it allows not just the MSBuild + pool-resource oversubscription but also the sheduler's default oversubscription\r\n\r\nhttps://github.com/dotnet/msbuild/blob/c70d520b5b8df990f651f0d00cd186a68cb277c6/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1275-L1295\r\n\r\n2. That makes the limits extremely hard to reason about, and Olga saw evidence that it wasn't helping overall perf anyway.\r\n3. It does suggest a path forward, though: request and release cores in the scheduler when moving SchedulableRequests to the Executing/Blocked/Complete states, as well as through the new IBuildEngine APIs for tasks that do so explicitly.\r\n4. That's what we were aiming for with the initial implementation but it was a big problem to get all the corners and edges correct when doing it inside TaskHost--doing it in the scheduler makes much more sense\r\n   a. It doesn't get constantly flipped back and forth when doing a straight-line single-project build\r\n   b. It's inherently aware of yielding/blocking/completion.\r\n5. That's the direction I'd go down. I've started but done very badly. In a second I'll push a terrible \u00bc-working commit that might be useless but hopefully is illustrative.",
        "createdAt": "2021-01-15T21:52:43Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "I will continue working on this while Rainer is on parental leave. My first proposal is to not use semaphore for tracking the available number of cores, at least initially.\r\n- Semaphore synchronization is tricky here as the existing \"all cores are saturated\" condition is rather complex and cannot be easily checked against a pre-set constant limit.\r\n\r\n```C#\r\n            return _schedulingData.ExecutingRequestsCount + _schedulingData.YieldingRequestsCount >= limit ||\r\n                   _schedulingData.ExecutingRequestsCount >= _componentHost.BuildParameters.MaxNodeCount;\t                   _schedulingData.ExecutingRequestsCount >= _componentHost.BuildParameters.MaxNodeCount;\r\n```\r\n\r\nAlso, implementing the latest design change requires instrumenting all code paths that mutate `ExecutingRequestsCount` or `YieldingRequestsCount` and handling the case that we're out of cores there. This looks like a non-trivial refactor.\r\n\r\n- Semaphore waits are leaked when a process unexpectedly exits. May not be a problem when using a fresh new semaphore name for each build request but makes it harder to reason about hangs as it's adding one additional \"deadlock vector\" into the system.\r\n\r\n- Semaphore is a Windows-only concept and while it's fine for the current requirements, it is reasonable to expect that this may be ultimately adopted by portable tasks as well.\r\n\r\nI'd like to try passing explicit messages between tasks and the scheduler, similar to the current `Yield` and `Reacquire` calls. The scheduler, being the central resource arbiter, is then free to implement whatever policy it chooses, not limited to representing the state of the system with one integer (the semaphore count).\r\n\r\nLater, if this proves too slow, it could be useful to try to optimize it, but better start with a simpler version, in my opinion.",
        "createdAt": "2021-02-19T09:54:57Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "First off, have you talked with @olgaark about the new design?\r\n\r\nWhat were you thinking would be present in the messages passed between tasks and the scheduler? Something like \"I want x cores\" with the response \"you get y cores\" and \"I give up m cores\" with no response? As I understand it, this would be fairly similar to a reimplementation of a semaphore except it works across OSs and may be able to handle hangs/unexpected exits if you have something that pings executing tasks every once in a while to make sure they're still doing stuff. Added reliability there may or may not be balanced by some chance of failures with node communication, and with the pinging approach, if a message doesn't get through for some reason, you could have a correctly executing task that is either killed or its results are ignored after it finishes because it was presumed failed.",
        "createdAt": "2021-02-19T17:03:14Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I am OK with whatever design which would work not only when build is driven by msbuild.exe but also inside IDE when driven by solution build manager.\r\nI agree that semaphores are too rigid, though they provide a very simple way of cross process communication. If you can figure out another way to communicate resource usage between a node and the server, I agree, it would be more flexible. \r\n\r\nIt also appears that the current yielding strategy allows too many builds to run in parallel (~ 2*number of cores) contributing to oversubscription. And that was causing the main trouble for the semaphore design. So if we can figure out how to make it more reasonable, this might help too.\r\n",
        "createdAt": "2021-02-19T18:42:50Z",
        "author": {
          "login": "olgaark"
        }
      },
      {
        "body": "> What were you thinking would be present in the messages passed between tasks and the scheduler? Something like \"I want x cores\" with the response \"you get y cores\" and \"I give up m cores\" with no response?\r\n\r\n@Forgind yes, exactly what you wrote. Recovery would be handled similarly to existing logic - i.e. a node can die today and the scheduler must realize that the core it had \"reserved\" is now up for grabs. Same for cores granted using the new mechanism.\r\n\r\n> It also appears that the current yielding strategy allows too many builds to run in parallel (~ 2*number of cores) contributing to oversubscription. \r\n\r\n@olgaark thank you. To make sure I understand, are C++ tasks going to call `Yield` in addition to requesting cores using the new API? Or are you worried about other tasks which may be yielding?",
        "createdAt": "2021-02-19T20:22:29Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "All tools tasks (i.e. the tasks which just construct the command line and launch a build tool process) yield right after they launch the tool and reacquire when the tool's process exits. Most of the cpp tasks are tool tasks. \r\n\r\nIIRC, the reason yielding was introduced is to allow ref resolution to happen on an msbuild node which has already built the project before (node affinity) while the build it is running just waiting for an external tool to do its work. The problem without yielding was that msbuild could not proceed with, say, project B build if B is referencing A, which has been built on node 1 and node 1 is building project C at the moment.\r\n\r\nBut yielding was done in a way allowing any build to use a yielded node (not just ones that has already been processed by the node) and I believe this is wrong from resource usage perspective as yielding msbuild node just releases the node, but not the resources used by the build tool, which is still running.",
        "createdAt": "2021-02-19T21:40:19Z",
        "author": {
          "login": "olgaark"
        }
      },
      {
        "body": "As far as resource utilization, I think releasing _one_ node is appropriate, but the problem is that the task only claimed to be using one node in the first place, which is where the problem comes in. The \"entrypoint\" node is truly no longer in use and can be reused. The \"worker\" nodes are still in use but were never considered, so the ideal solution here would be for something (semaphore, effective IPC, etc.) to tell the scheduler that task A that just yielded had been using 8 processes, and yielding only frees up one of them. As I recall from my conversation with rainersigwald about this, we thought decrementing the number of nodes in use, as far as the scheduler knows, whenever a node yields might help with the deadlock problem without introducing any actual resource misutilization. Then the only problem is tasks that don't use this but do spawn multiple other processes, but I don't think there's a way around that without carefully monitoring how many processes are created by a given process.\r\n\r\nSpeaking of, I don't know much about them, but is that the sort of thing that could be contained in a Job object? Meaning, could we have a job object associated with each task and not allow them to make more processes unless they specifically ask for more, at which point we can properly keep track of resources? My only hesitancy with this, beyond not knowing if I got that right, is that then every task that spawns multiple processes would have to buy into this, which would be work on our customers' part for (presumably) no obvious gain.\r\n\r\n> the scheduler must realize that the core it had \"reserved\" is now up for grabs.\r\n\r\nThe only difficulty here is that then the scheduler has to keep track of how many nodes each task had been given. Not the end of the world but a little more complicated.",
        "createdAt": "2021-02-19T22:34:46Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I just pushed commits with necessary plumbing to switch from semaphore to explicit messages. Next up, let's agree on the policy to be implemented in the scheduler.\r\n\r\n@olgaark from your comment it looks as though for CPP tasks you'd prefer yielding to have no impact on the number of available cores. So if a task calls `RequestCores` then it is assumed to be CPU-bound and `Yield` means that the scheduler can run another task on the node as long as it has available cores but does **not** mean that cores used by the task are freed up. This addresses the concern with the current strategy allowing too many builds to run in parallel (~ 2*number of cores) as you pointed out above.\r\n\r\n@Forgind I think it's safe to assume that tasks are cooperating and don't lie about their resource utilization. Trying to sandbox or monitor them would likely be out of scope for now.\r\n\r\n> ... so the ideal solution here would be for something (semaphore, effective IPC, etc.) to tell the scheduler that task A that just yielded had been using 8 processes, and yielding only frees up one of them. As I recall from my conversation with rainersigwald about this, we thought decrementing the number of nodes in use, as far as the scheduler knows, whenever a node yields might help with the deadlock problem without introducing any actual resource misutilization\r\n\r\nI'd like to understand this more. If yielding does not free any cores, what would be the scenario where we could run into a deadlock? My understanding is that the issue described in [this comment](https://github.com/dotnet/msbuild/pull/5859#issuecomment-744787318) has been addressed by exposing a non-blocking `RequestCores` and making it always return at least 1 (for the implicit one core reserved by the task).\r\n\r\n",
        "createdAt": "2021-02-22T10:15:20Z",
        "author": {
          "login": "ladipro"
        }
      },
      {
        "body": "I agree with Ladi's comments about yielding not releasing resources and assumption and tasks should cooperate.\r\n\r\nIf we make RequestCores non blocking and always return at least 1 code (which I believe is the right idea), but don't change how many builds can run in parallel now due to yielding (i.e. don't really acquire that one resource for the build from a common pool)\r\nwe are still using too many resources, at least with semaphore implementation and the case where there are always a project to build (i.e. no P2P restriction). In that case the first (/MP) project grabs all cores and yields. The next projects get only one core, but, again, due to yielding, there are ~2n builds running in parallel, so we have ~3n cores usage while ideally we should have somewhere between n and 2n (some oversubscription is good).\r\n\r\n\r\n\r\n",
        "createdAt": "2021-02-22T18:57:21Z",
        "author": {
          "login": "olgaark"
        }
      },
      {
        "body": "@olgaark, I don't think your entire comment posted. It seems to end with \"When \"",
        "createdAt": "2021-02-22T19:48:15Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Sorry, just typo, removed.",
        "createdAt": "2021-02-22T20:00:07Z",
        "author": {
          "login": "olgaark"
        }
      },
      {
        "body": "@olgaark I have implemented the policy as discussed above. That is, explicit core requests count against the same pool used by regular project scheduling. The limit is `MaxNodeCount` plus a small fixed delta and a configurable delta (the switch expression pasted in [Rainer's comment](https://github.com/dotnet/msbuild/pull/5859#issuecomment-761218054). Also, if a task has requested cores via the new API, a `Yield` call will not make the node \"available\" anymore, preventing the undesired 2*number of cores oversubscription. We're basically saying that if a task calls `RequestCores` and then `Yield`, it means that the work being done in the yield state is CPU-bound and `Yield` should not be freeing any cores.\r\n\r\nAn experimental VS build with this change is available in https://dev.azure.com/devdiv/DevDiv/_git/VS/pullrequest/306539. Can you please give it a try?",
        "createdAt": "2021-02-24T20:56:16Z",
        "author": {
          "login": "ladipro"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This can just be deleted.",
              "createdAt": "2020-11-05T17:35:00Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -1161,5 +1161,20 @@ private void LogErrorFromResource(string messageResource)\n \n             LogErrorEvent(error);\n         }\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            throw new NotImplementedException();\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            throw new NotImplementedException();\n+        }\n+\n+        public void BlockingWaitForCore()\n+        {\n+            throw new NotImplementedException();\n+        }",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not sure what to do here in the OOP taskhost node.\r\n\r\nOptions:\r\n\r\n1. As is, just throw (pros: done! cons: tasks don't necessarily know or care that they're in such a node)\r\n2. Just return 1 (pros: easy! cons: doesn't do what it says on the tin)\r\n3. Make sure the service is available here too and works (pros: ... works, cons: not sure how hard for not-huge benefit)",
              "createdAt": "2020-11-05T17:36:52Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -1161,5 +1161,20 @@ private void LogErrorFromResource(string messageResource)\n \n             LogErrorEvent(error);\n         }\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            throw new NotImplementedException();\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            throw new NotImplementedException();\n+        }",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "For (3), why can't you just copy the code from TaskHost?",
              "createdAt": "2020-11-06T01:27:46Z",
              "path": "src/MSBuild/OutOfProcTaskHostNode.cs",
              "diffHunk": "@@ -1161,5 +1161,20 @@ private void LogErrorFromResource(string messageResource)\n \n             LogErrorEvent(error);\n         }\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            throw new NotImplementedException();\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            throw new NotImplementedException();\n+        }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I wanted to suggest you make this an autoproperty:\r\n```suggestion\r\n        public string ResourceManagerSemaphoreName { get; set; } = $\"MSBuild.{Guid.NewGuid().ToString()}\";\r\n```\r\n\r\nbut that wouldn't work with translation \ud83d\ude22 ",
              "createdAt": "2020-11-06T01:09:22Z",
              "path": "src/Build/BackEnd/BuildManager/BuildParameters.cs",
              "diffHunk": "@@ -770,6 +771,12 @@ public string OutputResultsCacheFile\n             set => _outputResultsCacheFile = value;\n         }\n \n+        public string ResourceManagerSemaphoreName\n+        {\n+            get => _resourceManagerSemaphoreName;\n+            set => _resourceManagerSemaphoreName = value;\n+        }",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nI'm fine with adding a space, but I'd move it one higher to put the \"Reacquire\" parts together.",
              "createdAt": "2020-11-06T01:13:14Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -368,6 +369,7 @@ public void Reacquire()\n                 ErrorUtilities.VerifyThrow(_yieldThreadId == Thread.CurrentThread.ManagedThreadId, \"Cannot call Reacquire() on thread {0} when Yield() was called on thread {1}\", Thread.CurrentThread.ManagedThreadId, _yieldThreadId);\n                 MSBuildEventSource.Log.ExecuteTaskYieldStop(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);\n                 MSBuildEventSource.Log.ExecuteTaskReacquireStart(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);\n+",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I know you didn't change this, but why is `IBuildEngine Members` between `IBuildEngine3 Members` and `IBuildEngine4 Members`?",
              "createdAt": "2020-11-06T01:18:30Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -368,6 +369,7 @@ public void Reacquire()\n                 ErrorUtilities.VerifyThrow(_yieldThreadId == Thread.CurrentThread.ManagedThreadId, \"Cannot call Reacquire() on thread {0} when Yield() was called on thread {1}\", Thread.CurrentThread.ManagedThreadId, _yieldThreadId);\n                 MSBuildEventSource.Log.ExecuteTaskYieldStop(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);\n                 MSBuildEventSource.Log.ExecuteTaskReacquireStart(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);\n+",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "\ud83e\udd37\ud83c\udffb\u200d\u2642\ufe0f",
              "createdAt": "2020-11-20T20:38:26Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -368,6 +369,7 @@ public void Reacquire()\n                 ErrorUtilities.VerifyThrow(_yieldThreadId == Thread.CurrentThread.ManagedThreadId, \"Cannot call Reacquire() on thread {0} when Yield() was called on thread {1}\", Thread.CurrentThread.ManagedThreadId, _yieldThreadId);\n                 MSBuildEventSource.Log.ExecuteTaskYieldStop(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);\n                 MSBuildEventSource.Log.ExecuteTaskReacquireStart(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);\n+",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        private int runningTotal = 0;\r\n```\r\n? Also, I assume you put this here because it has to do directly with Request/ReleaseCores, but do you think that merits a comment?",
              "createdAt": "2020-11-06T01:16:05Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -670,10 +672,51 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie\n         #endregion\n \n         #region IBuildEngine7 Members\n+\n         /// <summary>\n         /// Enables or disables emitting a default error when a task fails without logging errors\n         /// </summary>\n         public bool AllowFailureWithoutError { get; set; } = false;\n+\n+        #endregion\n+\n+        #region IBuildEngine8 Members\n+\n+        int runningTotal = 0;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Is this used?",
              "createdAt": "2020-11-06T01:19:45Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -670,10 +672,51 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie\n         #endregion\n \n         #region IBuildEngine7 Members\n+\n         /// <summary>\n         /// Enables or disables emitting a default error when a task fails without logging errors\n         /// </summary>\n         public bool AllowFailureWithoutError { get; set; } = false;\n+\n+        #endregion\n+\n+        #region IBuildEngine8 Members\n+\n+        int runningTotal = 0;\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;\n+\n+            int coresAcquiredBeforeMoreCoresGetAcquired = runningTotal;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Wouldn't this mean you could request to release more cores than you own? I imagine that could have rather disastrous effects.",
              "createdAt": "2020-11-06T01:21:25Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -670,10 +672,51 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie\n         #endregion\n \n         #region IBuildEngine7 Members\n+\n         /// <summary>\n         /// Enables or disables emitting a default error when a task fails without logging errors\n         /// </summary>\n         public bool AllowFailureWithoutError { get; set; } = false;\n+\n+        #endregion\n+\n+        #region IBuildEngine8 Members\n+\n+        int runningTotal = 0;\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;\n+\n+            int coresAcquiredBeforeMoreCoresGetAcquired = runningTotal;\n+\n+            var coresAcquired = rms.RequestCores(requestedCores);\n+\n+            runningTotal += coresAcquired;\n+\n+            return coresAcquired;\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;\n+\n+            coresToRelease = Math.Min(runningTotal, coresToRelease);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It would be good to log something in diagnostic logging if a task releases more cores than it has requested.",
              "createdAt": "2020-11-10T19:30:45Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -670,10 +672,51 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie\n         #endregion\n \n         #region IBuildEngine7 Members\n+\n         /// <summary>\n         /// Enables or disables emitting a default error when a task fails without logging errors\n         /// </summary>\n         public bool AllowFailureWithoutError { get; set; } = false;\n+\n+        #endregion\n+\n+        #region IBuildEngine8 Members\n+\n+        int runningTotal = 0;\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;\n+\n+            int coresAcquiredBeforeMoreCoresGetAcquired = runningTotal;\n+\n+            var coresAcquired = rms.RequestCores(requestedCores);\n+\n+            runningTotal += coresAcquired;\n+\n+            return coresAcquired;\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;\n+\n+            coresToRelease = Math.Min(runningTotal, coresToRelease);",
              "author": {
                "login": "olgaark"
              }
            },
            {
              "body": "> I imagine that could have rather disastrous effects.\r\n\r\nWhat disastrous effects? You can request whatever you want and this reduces it to what you currently have.",
              "createdAt": "2020-11-20T23:25:25Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -670,10 +672,51 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie\n         #endregion\n \n         #region IBuildEngine7 Members\n+\n         /// <summary>\n         /// Enables or disables emitting a default error when a task fails without logging errors\n         /// </summary>\n         public bool AllowFailureWithoutError { get; set; } = false;\n+\n+        #endregion\n+\n+        #region IBuildEngine8 Members\n+\n+        int runningTotal = 0;\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;\n+\n+            int coresAcquiredBeforeMoreCoresGetAcquired = runningTotal;\n+\n+            var coresAcquired = rms.RequestCores(requestedCores);\n+\n+            runningTotal += coresAcquired;\n+\n+            return coresAcquired;\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;\n+\n+            coresToRelease = Math.Min(runningTotal, coresToRelease);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I was imagining something like:\r\n100 processes each request 1 core.\r\n1 process releases 100 cores.\r\nRepeat.\r\n\r\nThat may sound malicious, but if the last task requested 100 cores but got one, it might not realize it in the \"release\" part. If the execution as a whole is long-lived, this could promote inefficiencies.",
              "createdAt": "2020-11-24T16:35:24Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -670,10 +672,51 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie\n         #endregion\n \n         #region IBuildEngine7 Members\n+\n         /// <summary>\n         /// Enables or disables emitting a default error when a task fails without logging errors\n         /// </summary>\n         public bool AllowFailureWithoutError { get; set; } = false;\n+\n+        #endregion\n+\n+        #region IBuildEngine8 Members\n+\n+        int runningTotal = 0;\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;\n+\n+            int coresAcquiredBeforeMoreCoresGetAcquired = runningTotal;\n+\n+            var coresAcquired = rms.RequestCores(requestedCores);\n+\n+            runningTotal += coresAcquired;\n+\n+            return coresAcquired;\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;\n+\n+            coresToRelease = Math.Min(runningTotal, coresToRelease);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This is the code that prevents that: you can only release up to the current number of cores you had, as expressed by this `Math.Min` operation.",
              "createdAt": "2020-11-24T16:37:05Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -670,10 +672,51 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie\n         #endregion\n \n         #region IBuildEngine7 Members\n+\n         /// <summary>\n         /// Enables or disables emitting a default error when a task fails without logging errors\n         /// </summary>\n         public bool AllowFailureWithoutError { get; set; } = false;\n+\n+        #endregion\n+\n+        #region IBuildEngine8 Members\n+\n+        int runningTotal = 0;\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;\n+\n+            int coresAcquiredBeforeMoreCoresGetAcquired = runningTotal;\n+\n+            var coresAcquired = rms.RequestCores(requestedCores);\n+\n+            runningTotal += coresAcquired;\n+\n+            return coresAcquired;\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;\n+\n+            coresToRelease = Math.Min(runningTotal, coresToRelease);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you think there should be some mechanism for doing something similar when someone yields? Also wondering if it might make sense to make IBuildEngines Disposable so we could have a predefined set of things that happen whenever an IBuildEngine stops being used for any reason.",
              "createdAt": "2020-11-06T01:23:08Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -795,15 +839,18 @@ internal void MarkAsInactive()\n                 VerifyActiveProxy();\n                 _activeProxy = false;\n \n+                ReleaseAllCores();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "No, yielding does not really release the cores - a build tool is running and using them. The yielding just means that msbuild can use the node for something else. ",
              "createdAt": "2020-11-10T19:33:47Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -795,15 +839,18 @@ internal void MarkAsInactive()\n                 VerifyActiveProxy();\n                 _activeProxy = false;\n \n+                ReleaseAllCores();",
              "author": {
                "login": "olgaark"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        private int totalCoresAcquired = 0;\r\n```\r\n?",
              "createdAt": "2020-11-06T01:30:07Z",
              "path": "src/Shared/UnitTests/MockEngine.cs",
              "diffHunk": "@@ -485,5 +487,51 @@ public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime life\n             _objectCache.TryRemove(key, out object obj);\n             return obj;\n         }\n+\n+        int runningTotal = 0;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "+1, but name it `_totalCoresAcquired` as it's private",
              "createdAt": "2020-11-24T02:17:28Z",
              "path": "src/Shared/UnitTests/MockEngine.cs",
              "diffHunk": "@@ -485,5 +487,51 @@ public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime life\n             _objectCache.TryRemove(key, out object obj);\n             return obj;\n         }\n+\n+        int runningTotal = 0;",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think this would be clearer if you made it:\r\n```\r\nint coresAcquired = 0;\r\n...\r\nif (cpuCount.WaitOne(0))\r\n{\r\n    coresAcquired++;\r\n}\r\n...\r\nrunningTotal += coresAcquired;\r\nreturn coresAcquired;",
              "createdAt": "2020-11-06T01:31:42Z",
              "path": "src/Shared/UnitTests/MockEngine.cs",
              "diffHunk": "@@ -485,5 +487,51 @@ public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime life\n             _objectCache.TryRemove(key, out object obj);\n             return obj;\n         }\n+\n+        int runningTotal = 0;\n+        Semaphore cpuCount;\n+        public int RequestCores(int requestedCores)\n+        {\n+            cpuCount ??= Semaphore.OpenExisting(ResourceSemaphoreName);\n+\n+            int coresAcquiredBeforeMoreCoresGetAcquired = runningTotal;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you think it would be worth checking at the start to see if it's already been initialized?",
              "createdAt": "2020-11-06T01:37:04Z",
              "path": "src/Build/BackEnd/Components/ResourceManager/ResourceManagerService.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.BackEnd.Components.ResourceManager\n+{\n+    class ResourceManagerService : IBuildComponent\n+    {\n+        Semaphore? s = null;\n+\n+#if DEBUG\n+        public int TotalNumberHeld = -1;\n+        public string? SemaphoreName;\n+#endif\n+\n+        internal static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrow(type == BuildComponentType.TaskResourceManager, \"Cannot create components of type {0}\", type);\n+\n+            return new ResourceManagerService();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            string semaphoreName = host.BuildParameters.ResourceManagerSemaphoreName;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "What do you mean by this?",
              "createdAt": "2020-11-20T15:47:52Z",
              "path": "src/Build/BackEnd/Components/ResourceManager/ResourceManagerService.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.BackEnd.Components.ResourceManager\n+{\n+    class ResourceManagerService : IBuildComponent\n+    {\n+        Semaphore? s = null;\n+\n+#if DEBUG\n+        public int TotalNumberHeld = -1;\n+        public string? SemaphoreName;\n+#endif\n+\n+        internal static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrow(type == BuildComponentType.TaskResourceManager, \"Cannot create components of type {0}\", type);\n+\n+            return new ResourceManagerService();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            string semaphoreName = host.BuildParameters.ResourceManagerSemaphoreName;",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How is TotalNumberHeld actually used? It looks like you just reset it.",
              "createdAt": "2020-11-06T01:41:07Z",
              "path": "src/Build/BackEnd/Components/ResourceManager/ResourceManagerService.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.BackEnd.Components.ResourceManager\n+{\n+    class ResourceManagerService : IBuildComponent\n+    {\n+        Semaphore? s = null;\n+\n+#if DEBUG\n+        public int TotalNumberHeld = -1;\n+        public string? SemaphoreName;\n+#endif\n+\n+        internal static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrow(type == BuildComponentType.TaskResourceManager, \"Cannot create components of type {0}\", type);\n+\n+            return new ResourceManagerService();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            string semaphoreName = host.BuildParameters.ResourceManagerSemaphoreName;\n+\n+            int resourceCount = host.BuildParameters.MaxNodeCount; // TODO: tweakability\n+\n+#if DEBUG\n+            TotalNumberHeld = 0;\n+            SemaphoreName = semaphoreName;\n+#endif\n+\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                s = new Semaphore(resourceCount, resourceCount, semaphoreName); // TODO: SemaphoreSecurity?\n+            }\n+            else\n+            {\n+                // UNDONE: just don't support gathering additional cores on non-Windows\n+                s = new Semaphore(1, 1);\n+            }\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            s?.Dispose();\n+            s = null;\n+\n+#if DEBUG\n+            TotalNumberHeld = -2;\n+#endif\n+        }\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            if (s is null)\n+            {\n+                if (!NativeMethodsShared.IsWindows)\n+                {\n+                    // Since the current implementation of the cross-process resource count uses\n+                    // named semaphores, it's not usable on non-Windows, so just return the\n+                    // guaranteed resource.\n+                    return 1;\n+                }\n+\n+                throw new InternalErrorException($\"{nameof(ResourceManagerService)} was called while uninitialized\");\n+            }\n+\n+            int i = 0;\n+\n+            // First core gets a blocking wait: the user task wants to do *something*\n+            s.WaitOne();\n+\n+            // Keep requesting cores until we can't anymore, or we've gotten the number of cores we wanted.\n+            for (i = 1; i < requestedCores; i++)\n+            {\n+                if (!s.WaitOne(0))\n+                {\n+                    return i;\n+                }\n+            }\n+\n+            return i;\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            if (s is null)\n+            {\n+                if (!NativeMethodsShared.IsWindows)\n+                {\n+                    // Since the current implementation of the cross-process resource count uses\n+                    // named semaphores, it's not usable on non-Windows, so just continue.\n+                    return;\n+                }\n+\n+                throw new InternalErrorException($\"{nameof(ResourceManagerService)} was called while uninitialized\");\n+            }\n+\n+            ErrorUtilities.VerifyThrow(coresToRelease > 0, \"Tried to release {0} cores\", coresToRelease);\n+\n+            s.Release(coresToRelease);\n+\n+#if DEBUG\n+            TotalNumberHeld -= coresToRelease;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Can we add some diagnostic logging to be able to see how the cores are requested/released?",
              "createdAt": "2020-11-10T19:37:51Z",
              "path": "src/Build/BackEnd/Components/ResourceManager/ResourceManagerService.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.BackEnd.Components.ResourceManager\n+{\n+    class ResourceManagerService : IBuildComponent\n+    {\n+        Semaphore? s = null;\n+\n+#if DEBUG\n+        public int TotalNumberHeld = -1;\n+        public string? SemaphoreName;\n+#endif\n+\n+        internal static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrow(type == BuildComponentType.TaskResourceManager, \"Cannot create components of type {0}\", type);\n+\n+            return new ResourceManagerService();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            string semaphoreName = host.BuildParameters.ResourceManagerSemaphoreName;\n+\n+            int resourceCount = host.BuildParameters.MaxNodeCount; // TODO: tweakability\n+\n+#if DEBUG\n+            TotalNumberHeld = 0;\n+            SemaphoreName = semaphoreName;\n+#endif\n+\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                s = new Semaphore(resourceCount, resourceCount, semaphoreName); // TODO: SemaphoreSecurity?\n+            }\n+            else\n+            {\n+                // UNDONE: just don't support gathering additional cores on non-Windows\n+                s = new Semaphore(1, 1);\n+            }\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            s?.Dispose();\n+            s = null;\n+\n+#if DEBUG\n+            TotalNumberHeld = -2;\n+#endif\n+        }\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            if (s is null)\n+            {\n+                if (!NativeMethodsShared.IsWindows)\n+                {\n+                    // Since the current implementation of the cross-process resource count uses\n+                    // named semaphores, it's not usable on non-Windows, so just return the\n+                    // guaranteed resource.\n+                    return 1;\n+                }\n+\n+                throw new InternalErrorException($\"{nameof(ResourceManagerService)} was called while uninitialized\");\n+            }\n+\n+            int i = 0;\n+\n+            // First core gets a blocking wait: the user task wants to do *something*\n+            s.WaitOne();\n+\n+            // Keep requesting cores until we can't anymore, or we've gotten the number of cores we wanted.\n+            for (i = 1; i < requestedCores; i++)\n+            {\n+                if (!s.WaitOne(0))\n+                {\n+                    return i;\n+                }\n+            }\n+\n+            return i;\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            if (s is null)\n+            {\n+                if (!NativeMethodsShared.IsWindows)\n+                {\n+                    // Since the current implementation of the cross-process resource count uses\n+                    // named semaphores, it's not usable on non-Windows, so just continue.\n+                    return;\n+                }\n+\n+                throw new InternalErrorException($\"{nameof(ResourceManagerService)} was called while uninitialized\");\n+            }\n+\n+            ErrorUtilities.VerifyThrow(coresToRelease > 0, \"Tried to release {0} cores\", coresToRelease);\n+\n+            s.Release(coresToRelease);\n+\n+#if DEBUG\n+            TotalNumberHeld -= coresToRelease;",
              "author": {
                "login": "olgaark"
              }
            },
            {
              "body": "I was primarily poking it in the debugger.\r\n\r\nI'm a bit concerned about I'm concerned about the chattiness of logging these events, but let's put it in and see if we need to back it out later.",
              "createdAt": "2020-11-20T15:49:41Z",
              "path": "src/Build/BackEnd/Components/ResourceManager/ResourceManagerService.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.BackEnd.Components.ResourceManager\n+{\n+    class ResourceManagerService : IBuildComponent\n+    {\n+        Semaphore? s = null;\n+\n+#if DEBUG\n+        public int TotalNumberHeld = -1;\n+        public string? SemaphoreName;\n+#endif\n+\n+        internal static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrow(type == BuildComponentType.TaskResourceManager, \"Cannot create components of type {0}\", type);\n+\n+            return new ResourceManagerService();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            string semaphoreName = host.BuildParameters.ResourceManagerSemaphoreName;\n+\n+            int resourceCount = host.BuildParameters.MaxNodeCount; // TODO: tweakability\n+\n+#if DEBUG\n+            TotalNumberHeld = 0;\n+            SemaphoreName = semaphoreName;\n+#endif\n+\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                s = new Semaphore(resourceCount, resourceCount, semaphoreName); // TODO: SemaphoreSecurity?\n+            }\n+            else\n+            {\n+                // UNDONE: just don't support gathering additional cores on non-Windows\n+                s = new Semaphore(1, 1);\n+            }\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            s?.Dispose();\n+            s = null;\n+\n+#if DEBUG\n+            TotalNumberHeld = -2;\n+#endif\n+        }\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            if (s is null)\n+            {\n+                if (!NativeMethodsShared.IsWindows)\n+                {\n+                    // Since the current implementation of the cross-process resource count uses\n+                    // named semaphores, it's not usable on non-Windows, so just return the\n+                    // guaranteed resource.\n+                    return 1;\n+                }\n+\n+                throw new InternalErrorException($\"{nameof(ResourceManagerService)} was called while uninitialized\");\n+            }\n+\n+            int i = 0;\n+\n+            // First core gets a blocking wait: the user task wants to do *something*\n+            s.WaitOne();\n+\n+            // Keep requesting cores until we can't anymore, or we've gotten the number of cores we wanted.\n+            for (i = 1; i < requestedCores; i++)\n+            {\n+                if (!s.WaitOne(0))\n+                {\n+                    return i;\n+                }\n+            }\n+\n+            return i;\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            if (s is null)\n+            {\n+                if (!NativeMethodsShared.IsWindows)\n+                {\n+                    // Since the current implementation of the cross-process resource count uses\n+                    // named semaphores, it's not usable on non-Windows, so just continue.\n+                    return;\n+                }\n+\n+                throw new InternalErrorException($\"{nameof(ResourceManagerService)} was called while uninitialized\");\n+            }\n+\n+            ErrorUtilities.VerifyThrow(coresToRelease > 0, \"Tried to release {0} cores\", coresToRelease);\n+\n+            s.Release(coresToRelease);\n+\n+#if DEBUG\n+            TotalNumberHeld -= coresToRelease;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "ETW traces?",
              "createdAt": "2020-11-24T16:37:34Z",
              "path": "src/Build/BackEnd/Components/ResourceManager/ResourceManagerService.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.BackEnd.Components.ResourceManager\n+{\n+    class ResourceManagerService : IBuildComponent\n+    {\n+        Semaphore? s = null;\n+\n+#if DEBUG\n+        public int TotalNumberHeld = -1;\n+        public string? SemaphoreName;\n+#endif\n+\n+        internal static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrow(type == BuildComponentType.TaskResourceManager, \"Cannot create components of type {0}\", type);\n+\n+            return new ResourceManagerService();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            string semaphoreName = host.BuildParameters.ResourceManagerSemaphoreName;\n+\n+            int resourceCount = host.BuildParameters.MaxNodeCount; // TODO: tweakability\n+\n+#if DEBUG\n+            TotalNumberHeld = 0;\n+            SemaphoreName = semaphoreName;\n+#endif\n+\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                s = new Semaphore(resourceCount, resourceCount, semaphoreName); // TODO: SemaphoreSecurity?\n+            }\n+            else\n+            {\n+                // UNDONE: just don't support gathering additional cores on non-Windows\n+                s = new Semaphore(1, 1);\n+            }\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            s?.Dispose();\n+            s = null;\n+\n+#if DEBUG\n+            TotalNumberHeld = -2;\n+#endif\n+        }\n+\n+        public int RequestCores(int requestedCores)\n+        {\n+            if (s is null)\n+            {\n+                if (!NativeMethodsShared.IsWindows)\n+                {\n+                    // Since the current implementation of the cross-process resource count uses\n+                    // named semaphores, it's not usable on non-Windows, so just return the\n+                    // guaranteed resource.\n+                    return 1;\n+                }\n+\n+                throw new InternalErrorException($\"{nameof(ResourceManagerService)} was called while uninitialized\");\n+            }\n+\n+            int i = 0;\n+\n+            // First core gets a blocking wait: the user task wants to do *something*\n+            s.WaitOne();\n+\n+            // Keep requesting cores until we can't anymore, or we've gotten the number of cores we wanted.\n+            for (i = 1; i < requestedCores; i++)\n+            {\n+                if (!s.WaitOne(0))\n+                {\n+                    return i;\n+                }\n+            }\n+\n+            return i;\n+        }\n+\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            if (s is null)\n+            {\n+                if (!NativeMethodsShared.IsWindows)\n+                {\n+                    // Since the current implementation of the cross-process resource count uses\n+                    // named semaphores, it's not usable on non-Windows, so just continue.\n+                    return;\n+                }\n+\n+                throw new InternalErrorException($\"{nameof(ResourceManagerService)} was called while uninitialized\");\n+            }\n+\n+            ErrorUtilities.VerifyThrow(coresToRelease > 0, \"Tried to release {0} cores\", coresToRelease);\n+\n+            s.Release(coresToRelease);\n+\n+#if DEBUG\n+            TotalNumberHeld -= coresToRelease;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This section is well-written, but it reads to me as general statement of purpose --> example --> actually, we only care about the example. Although cl.exe was the motivating example, I imagine others will start using it later, so I'd focus on describing this generally rather than diving into a specific example in the first section. On a related note, are you planning to make documentation not in the `specs` folder? If so, this may be a moot point.",
              "createdAt": "2020-11-10T17:51:58Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,41 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.\n+\n+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Now you mention it, is this the right choice? If all tasks opt into this, that would mean you're forcing some of the cores to be idle for no reason.",
              "createdAt": "2020-11-10T17:57:03Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,41 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.\n+\n+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.\n+\n+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.\n+\n+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.\n+\n+## Design\n+\n+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`BlockingWaitForCore`). These will be advisory only\u2014a task can still do as much work as it desires with as many threads and processes as it desires.\n+\n+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.\n+\n+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`.\n+\n+MSBuild will respect core reservations given to tasks for tasks that opt into resource management only. If a project/task is eligible for execution, MSBuild will not wait until a resource is freed before starting execution of the new task. As a result, the machine can be oversubscribed, but only by a finite amount: the resource pool's core count.\n+\n+Task `Yield()`ing has no effect on the resources held by a task.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should it always return 1? I imagine users wouldn't use more cores than they're given unless users complain.",
              "createdAt": "2020-11-10T18:03:32Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,41 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.\n+\n+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.\n+\n+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.\n+\n+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.\n+\n+## Design\n+\n+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`BlockingWaitForCore`). These will be advisory only\u2014a task can still do as much work as it desires with as many threads and processes as it desires.\n+\n+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.\n+\n+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`.\n+\n+MSBuild will respect core reservations given to tasks for tasks that opt into resource management only. If a project/task is eligible for execution, MSBuild will not wait until a resource is freed before starting execution of the new task. As a result, the machine can be oversubscribed, but only by a finite amount: the resource pool's core count.\n+\n+Task `Yield()`ing has no effect on the resources held by a task.\n+\n+## Example\n+\n+In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.\n+\n+Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls\n+\n+TODO: what's the best calling pattern here? the thread thing I hacked up in the sample task seems bad.\n+\n+```C#\n+int allowedParallelism = BuildEngine7.RequestCores(Inputs.Count); // Inputs.Count == 25\n+```\n+\n+When `Work` returns, MSBuild automatically returns all resources reserved by the task to the pool. Before moving on with its processing, `Work2` calls `RequestCores` again, and this time receives a larger reservation.\n+\n+## Implementation\n+\n+The initial implementation of the system will use a Win32 [named semaphore](https://docs.microsoft.com/windows/win32/sync/semaphore-objects) to track resource use. This was the implementation of `MultiToolTask` in the VC++ toolchain and is a performant implementation of a counter that can be shared across processes.\n+\n+On platforms where named semaphores are not supported (.NET Core MSBuild running on macOS, Linux, or other UNIXes), `RequestCores` will always return `0`. We will consider implementing full support using a cross-process semaphore (or an addition to the existing MSBuild communication protocol, if it isn't prohibitively costly to do the packet exchange and processing) on these platforms in the future.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I think you should either return 0 (indicating that there is no RM) or min of what is requested and the number of cores, which will be pretty much what we have today without RM.",
              "createdAt": "2020-11-10T19:27:58Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,41 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.\n+\n+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.\n+\n+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.\n+\n+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.\n+\n+## Design\n+\n+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`BlockingWaitForCore`). These will be advisory only\u2014a task can still do as much work as it desires with as many threads and processes as it desires.\n+\n+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.\n+\n+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`.\n+\n+MSBuild will respect core reservations given to tasks for tasks that opt into resource management only. If a project/task is eligible for execution, MSBuild will not wait until a resource is freed before starting execution of the new task. As a result, the machine can be oversubscribed, but only by a finite amount: the resource pool's core count.\n+\n+Task `Yield()`ing has no effect on the resources held by a task.\n+\n+## Example\n+\n+In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.\n+\n+Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls\n+\n+TODO: what's the best calling pattern here? the thread thing I hacked up in the sample task seems bad.\n+\n+```C#\n+int allowedParallelism = BuildEngine7.RequestCores(Inputs.Count); // Inputs.Count == 25\n+```\n+\n+When `Work` returns, MSBuild automatically returns all resources reserved by the task to the pool. Before moving on with its processing, `Work2` calls `RequestCores` again, and this time receives a larger reservation.\n+\n+## Implementation\n+\n+The initial implementation of the system will use a Win32 [named semaphore](https://docs.microsoft.com/windows/win32/sync/semaphore-objects) to track resource use. This was the implementation of `MultiToolTask` in the VC++ toolchain and is a performant implementation of a counter that can be shared across processes.\n+\n+On platforms where named semaphores are not supported (.NET Core MSBuild running on macOS, Linux, or other UNIXes), `RequestCores` will always return `0`. We will consider implementing full support using a cross-process semaphore (or an addition to the existing MSBuild communication protocol, if it isn't prohibitively costly to do the packet exchange and processing) on these platforms in the future.",
              "author": {
                "login": "olgaark"
              }
            },
            {
              "body": "With the change to blocking/get-at-least-1, I think immediately returning 1 makes the most sense here--and that's what I actually implemented; this doc was stale. Do you think the default for an \"enlightened\" task should be to overburden the machine, rather than underburden it?",
              "createdAt": "2020-11-20T15:37:49Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,41 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.\n+\n+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.\n+\n+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.\n+\n+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.\n+\n+## Design\n+\n+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`BlockingWaitForCore`). These will be advisory only\u2014a task can still do as much work as it desires with as many threads and processes as it desires.\n+\n+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.\n+\n+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`.\n+\n+MSBuild will respect core reservations given to tasks for tasks that opt into resource management only. If a project/task is eligible for execution, MSBuild will not wait until a resource is freed before starting execution of the new task. As a result, the machine can be oversubscribed, but only by a finite amount: the resource pool's core count.\n+\n+Task `Yield()`ing has no effect on the resources held by a task.\n+\n+## Example\n+\n+In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.\n+\n+Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls\n+\n+TODO: what's the best calling pattern here? the thread thing I hacked up in the sample task seems bad.\n+\n+```C#\n+int allowedParallelism = BuildEngine7.RequestCores(Inputs.Count); // Inputs.Count == 25\n+```\n+\n+When `Work` returns, MSBuild automatically returns all resources reserved by the task to the pool. Before moving on with its processing, `Work2` calls `RequestCores` again, and this time receives a larger reservation.\n+\n+## Implementation\n+\n+The initial implementation of the system will use a Win32 [named semaphore](https://docs.microsoft.com/windows/win32/sync/semaphore-objects) to track resource use. This was the implementation of `MultiToolTask` in the VC++ toolchain and is a performant implementation of a counter that can be shared across processes.\n+\n+On platforms where named semaphores are not supported (.NET Core MSBuild running on macOS, Linux, or other UNIXes), `RequestCores` will always return `0`. We will consider implementing full support using a cross-process semaphore (or an addition to the existing MSBuild communication protocol, if it isn't prohibitively costly to do the packet exchange and processing) on these platforms in the future.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I think returning 1 is confusing as different tasks would do different things with and without RM and they need to know if RM is actually working or not. Maybe we should just add an explicit method for this, like \"IsRMSupported\", and then it would be not so important what we return here.",
              "createdAt": "2020-11-20T23:46:24Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,41 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.\n+\n+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.\n+\n+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.\n+\n+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.\n+\n+## Design\n+\n+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`BlockingWaitForCore`). These will be advisory only\u2014a task can still do as much work as it desires with as many threads and processes as it desires.\n+\n+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.\n+\n+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`.\n+\n+MSBuild will respect core reservations given to tasks for tasks that opt into resource management only. If a project/task is eligible for execution, MSBuild will not wait until a resource is freed before starting execution of the new task. As a result, the machine can be oversubscribed, but only by a finite amount: the resource pool's core count.\n+\n+Task `Yield()`ing has no effect on the resources held by a task.\n+\n+## Example\n+\n+In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.\n+\n+Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls\n+\n+TODO: what's the best calling pattern here? the thread thing I hacked up in the sample task seems bad.\n+\n+```C#\n+int allowedParallelism = BuildEngine7.RequestCores(Inputs.Count); // Inputs.Count == 25\n+```\n+\n+When `Work` returns, MSBuild automatically returns all resources reserved by the task to the pool. Before moving on with its processing, `Work2` calls `RequestCores` again, and this time receives a larger reservation.\n+\n+## Implementation\n+\n+The initial implementation of the system will use a Win32 [named semaphore](https://docs.microsoft.com/windows/win32/sync/semaphore-objects) to track resource use. This was the implementation of `MultiToolTask` in the VC++ toolchain and is a performant implementation of a counter that can be shared across processes.\n+\n+On platforms where named semaphores are not supported (.NET Core MSBuild running on macOS, Linux, or other UNIXes), `RequestCores` will always return `0`. We will consider implementing full support using a cross-process semaphore (or an addition to the existing MSBuild communication protocol, if it isn't prohibitively costly to do the packet exchange and processing) on these platforms in the future.",
              "author": {
                "login": "olgaark"
              }
            },
            {
              "body": "I guess it depends on whether we expect users are going to inspect the output before using it. If they intend to immediately use it, returning 1 or min(requested, #cores) makes sense for underloading or overloading the machine respectively. If they're going to inspect it, -1 is easiest as an indicator of \"failure\" that can't have other meanings like \"all cores in use.\"",
              "createdAt": "2020-11-24T16:46:10Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,41 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.\n+\n+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.\n+\n+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.\n+\n+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.\n+\n+## Design\n+\n+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`BlockingWaitForCore`). These will be advisory only\u2014a task can still do as much work as it desires with as many threads and processes as it desires.\n+\n+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.\n+\n+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`.\n+\n+MSBuild will respect core reservations given to tasks for tasks that opt into resource management only. If a project/task is eligible for execution, MSBuild will not wait until a resource is freed before starting execution of the new task. As a result, the machine can be oversubscribed, but only by a finite amount: the resource pool's core count.\n+\n+Task `Yield()`ing has no effect on the resources held by a task.\n+\n+## Example\n+\n+In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.\n+\n+Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls\n+\n+TODO: what's the best calling pattern here? the thread thing I hacked up in the sample task seems bad.\n+\n+```C#\n+int allowedParallelism = BuildEngine7.RequestCores(Inputs.Count); // Inputs.Count == 25\n+```\n+\n+When `Work` returns, MSBuild automatically returns all resources reserved by the task to the pool. Before moving on with its processing, `Work2` calls `RequestCores` again, and this time receives a larger reservation.\n+\n+## Implementation\n+\n+The initial implementation of the system will use a Win32 [named semaphore](https://docs.microsoft.com/windows/win32/sync/semaphore-objects) to track resource use. This was the implementation of `MultiToolTask` in the VC++ toolchain and is a performant implementation of a counter that can be shared across processes.\n+\n+On platforms where named semaphores are not supported (.NET Core MSBuild running on macOS, Linux, or other UNIXes), `RequestCores` will always return `0`. We will consider implementing full support using a cross-process semaphore (or an addition to the existing MSBuild communication protocol, if it isn't prohibitively costly to do the packet exchange and processing) on these platforms in the future.",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Where is this sample task? I imagined something like:\r\n// Construct 20x1000 array of data\r\n// Request 20 cores\r\n// Create new Thread[20]\r\n// Only start the first <received cores> threads\r\n// Join them all, and as they finish, start new ones running.\r\n\r\nThe last step is a little messy, but it can probably be cleaned up by making callback functions:\r\n\r\n```C#\r\n            Thread[] threads = new Thread[20];\r\n             for (int i = 0; i < 20; i++)\r\n                      // Give threads work;\r\n             int i = 0;\r\n             void run(i) { thread[i].Join(); thread[i++].Start(); Task.Run(run); }\r\n             for (; i < coresReceived; i++) {\r\n                      thread[i].Start();\r\n                      Task.Run(run);\r\n```\r\n\r\nOr, even better, something similar using `async`. What do you think?",
              "createdAt": "2020-11-10T18:23:01Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,41 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.\n+\n+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.\n+\n+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.\n+\n+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.\n+\n+## Design\n+\n+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`BlockingWaitForCore`). These will be advisory only\u2014a task can still do as much work as it desires with as many threads and processes as it desires.\n+\n+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.\n+\n+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`.\n+\n+MSBuild will respect core reservations given to tasks for tasks that opt into resource management only. If a project/task is eligible for execution, MSBuild will not wait until a resource is freed before starting execution of the new task. As a result, the machine can be oversubscribed, but only by a finite amount: the resource pool's core count.\n+\n+Task `Yield()`ing has no effect on the resources held by a task.\n+\n+## Example\n+\n+In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.\n+\n+Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls\n+\n+TODO: what's the best calling pattern here? the thread thing I hacked up in the sample task seems bad.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I deleted the sample task because it was no longer useful--but we need one for tests so I'll have to write another.\r\n\r\nI don't think it's feasible to provide a single example here. If you're using tasks/the threadpool, you might not want to use this, since the threadpool has its own ideas of resource management (which I believe but can't confirm go cross-process). And the work you'd likely do with dedicated threads is probably fairly different from the work to launch multiple processes. The actual C++ tasks have their own fairly complicated approach that isn't a great example.",
              "createdAt": "2020-11-20T16:37:19Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,41 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.\n+\n+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.\n+\n+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.\n+\n+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.\n+\n+## Design\n+\n+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`BlockingWaitForCore`). These will be advisory only\u2014a task can still do as much work as it desires with as many threads and processes as it desires.\n+\n+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.\n+\n+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`.\n+\n+MSBuild will respect core reservations given to tasks for tasks that opt into resource management only. If a project/task is eligible for execution, MSBuild will not wait until a resource is freed before starting execution of the new task. As a result, the machine can be oversubscribed, but only by a finite amount: the resource pool's core count.\n+\n+Task `Yield()`ing has no effect on the resources held by a task.\n+\n+## Example\n+\n+In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.\n+\n+Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls\n+\n+TODO: what's the best calling pattern here? the thread thing I hacked up in the sample task seems bad.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Since the current plan is to ignore non-windows, why initialize s at all? Also, can you move this to the top of this function to avoid doing unnecessary work? Note that giving it a value, as you do just below, means it will be treated as \"non-null\" as far as requesting/releasing cores --> the nullable changes you made won't have any effect.",
              "createdAt": "2020-12-07T22:01:37Z",
              "path": "src/Build/BackEnd/Components/ResourceManager/ResourceManagerService.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.BackEnd.Components.ResourceManager\n+{\n+    class ResourceManagerService : IBuildComponent\n+    {\n+        Semaphore? s = null;\n+\n+#if DEBUG\n+        public int TotalNumberHeld = -1;\n+        public string? SemaphoreName;\n+#endif\n+\n+        internal static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrow(type == BuildComponentType.TaskResourceManager, \"Cannot create components of type {0}\", type);\n+\n+            return new ResourceManagerService();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            string semaphoreName = host.BuildParameters.ResourceManagerSemaphoreName;\n+\n+            int resourceCount = host.BuildParameters.MaxNodeCount; // TODO: tweakability\n+\n+#if DEBUG\n+            TotalNumberHeld = 0;\n+            SemaphoreName = semaphoreName;\n+#endif\n+\n+            if (NativeMethodsShared.IsWindows)",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Not sure if `GetComponent` is a very expensive call or not, but could we cache the resource manager?",
              "createdAt": "2020-12-08T01:36:00Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -670,10 +672,54 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie\n         #endregion\n \n         #region IBuildEngine7 Members\n+\n         /// <summary>\n         /// Enables or disables emitting a default error when a task fails without logging errors\n         /// </summary>\n         public bool AllowFailureWithoutError { get; set; } = false;\n+\n+        #endregion\n+\n+        #region IBuildEngine8 Members\n+\n+        int runningTotal = 0;\n+\n+        public int? RequestCores(int requestedCores)\n+        {\n+            var rms = _host.GetComponent(BuildComponentType.TaskResourceManager) as ResourceManagerService;",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Add a summary while it's fresh in the mind.",
              "createdAt": "2020-12-08T01:36:30Z",
              "path": "src/Build/BackEnd/Components/ResourceManager/ResourceManagerService.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.BackEnd.Components.ResourceManager\n+{\n+    class ResourceManagerService : IBuildComponent",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Nit: \r\n```suggestion\r\n\r\n```",
              "createdAt": "2020-12-08T02:00:43Z",
              "path": "src/Utilities/Task.cs",
              "diffHunk": "@@ -94,6 +94,12 @@ protected Task(ResourceManager taskResources, string helpKeywordPrefix)\n         /// </summary>\n         public IBuildEngine7 BuildEngine7 => (IBuildEngine7)BuildEngine;\n \n+        /// <summary>\n+        /// Retrieves the <see cref=\"IBuildEngine8\" /> version of the build engine interface provided by the host.\n+        /// </summary>\n+        public IBuildEngine8 BuildEngine8 => (IBuildEngine8)BuildEngine;\n+\n+",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why specifically -2?",
              "createdAt": "2020-12-08T02:16:37Z",
              "path": "src/Build/BackEnd/Components/ResourceManager/ResourceManagerService.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.BackEnd.Components.ResourceManager\n+{\n+    class ResourceManagerService : IBuildComponent\n+    {\n+        Semaphore? s = null;\n+\n+#if DEBUG\n+        public int TotalNumberHeld = -1;\n+        public string? SemaphoreName;\n+#endif\n+\n+        internal static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrow(type == BuildComponentType.TaskResourceManager, \"Cannot create components of type {0}\", type);\n+\n+            return new ResourceManagerService();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            string semaphoreName = host.BuildParameters.ResourceManagerSemaphoreName;\n+\n+            int resourceCount = host.BuildParameters.MaxNodeCount; // TODO: tweakability\n+\n+#if DEBUG\n+            TotalNumberHeld = 0;\n+            SemaphoreName = semaphoreName;\n+#endif\n+\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                s = new Semaphore(resourceCount, resourceCount, semaphoreName); // TODO: SemaphoreSecurity?\n+            }\n+            else\n+            {\n+                // UNDONE: just don't support gathering additional cores on non-Windows\n+                s = new Semaphore(1, 1);\n+            }\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            s?.Dispose();\n+            s = null;\n+\n+#if DEBUG\n+            TotalNumberHeld = -2;",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Add to TotalNumberHeld here, under an #if DEBUG",
              "createdAt": "2020-12-08T02:19:11Z",
              "path": "src/Build/BackEnd/Components/ResourceManager/ResourceManagerService.cs",
              "diffHunk": "@@ -0,0 +1,114 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using Microsoft.Build.Shared;\n+using System.Threading;\n+\n+#nullable enable\n+\n+namespace Microsoft.Build.BackEnd.Components.ResourceManager\n+{\n+    class ResourceManagerService : IBuildComponent\n+    {\n+        Semaphore? s = null;\n+\n+#if DEBUG\n+        public int TotalNumberHeld = -1;\n+        public string? SemaphoreName;\n+#endif\n+\n+        internal static IBuildComponent CreateComponent(BuildComponentType type)\n+        {\n+            ErrorUtilities.VerifyThrow(type == BuildComponentType.TaskResourceManager, \"Cannot create components of type {0}\", type);\n+\n+            return new ResourceManagerService();\n+        }\n+\n+        public void InitializeComponent(IBuildComponentHost host)\n+        {\n+            string semaphoreName = host.BuildParameters.ResourceManagerSemaphoreName;\n+\n+            int resourceCount = host.BuildParameters.MaxNodeCount; // TODO: tweakability\n+\n+#if DEBUG\n+            TotalNumberHeld = 0;\n+            SemaphoreName = semaphoreName;\n+#endif\n+\n+            if (NativeMethodsShared.IsWindows)\n+            {\n+                s = new Semaphore(resourceCount, resourceCount, semaphoreName); // TODO: SemaphoreSecurity?\n+            }\n+            else\n+            {\n+                // UNDONE: just don't support gathering additional cores on non-Windows\n+                s = new Semaphore(1, 1);\n+            }\n+        }\n+\n+        public void ShutdownComponent()\n+        {\n+            s?.Dispose();\n+            s = null;\n+\n+#if DEBUG\n+            TotalNumberHeld = -2;\n+#endif\n+        }\n+\n+        public int? RequestCores(int requestedCores)\n+        {\n+            if (s is null)\n+            {\n+                if (!NativeMethodsShared.IsWindows)\n+                {\n+                    // Since the current implementation of the cross-process resource count uses\n+                    // named semaphores, it's not usable on non-Windows, so just return the\n+                    // guaranteed resource.\n+                    return null;\n+                }\n+\n+                throw new InternalErrorException($\"{nameof(ResourceManagerService)} was called while uninitialized\");\n+            }\n+\n+            int i = 0;\n+\n+            // First core gets a blocking wait: the user task wants to do *something*\n+            s.WaitOne();\n+\n+            // Keep requesting cores until we can't anymore, or we've gotten the number of cores we wanted.\n+            for (i = 1; i < requestedCores; i++)\n+            {",
              "author": {
                "login": "benvillalobos"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This comment is stale right?",
              "createdAt": "2021-01-14T01:45:48Z",
              "path": "src/Framework/IBuildEngine8.cs",
              "diffHunk": "@@ -0,0 +1,26 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// This interface extends <see cref=\"IBuildEngine7\" /> to allow tasks to set whether they want to",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The string `NUM_PROCS` does not exist in MSBuild. Maybe write a paragraph or two detailing where it comes from.",
              "createdAt": "2021-01-14T01:48:56Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,45 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "```suggestion\r\nMSBuild supports building projects in parallel using multiple processes. Most users opt into `Environment.ProcessorCount` parallelism at the MSBuild layer.\r\n```",
              "createdAt": "2021-01-15T21:48:57Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,45 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Paragraph ends in cliffhanger :)",
              "createdAt": "2021-01-14T01:53:10Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,45 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.\n+\n+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.\n+\n+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.\n+\n+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.\n+\n+## Design\n+\n+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`BlockingWaitForCore`). These will be advisory only\u2014a task can still do as much work as it desires with as many threads and processes as it desires.\n+\n+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.\n+\n+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`.\n+\n+MSBuild will respect core reservations given to tasks for tasks that opt into resource management only. If a project/task is eligible for execution, MSBuild will not wait until a resource is freed before starting execution of the new task. As a result, the machine can be oversubscribed, but only by a finite amount: the resource pool's core count.\n+\n+Task `Yield()`ing has no effect on the resources held by a task.\n+\n+## Example\n+\n+In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.\n+\n+Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls\n+\n+```C#\n+int allowedParallelism = BuildEngine8.RequestCores(Inputs.Count); // Inputs.Count == 25\n+```\n+\n+and gets `16`--the number of cores available to the build overall. Other tasks that do not call `RequestCores` do not affect this value.\n+\n+While `A` runs `Work`, projects `B` and `C` run another task `Work2` that also calls `RequestCores` with a high value. Since `Work` in `A` has reserved all cores, the calls in `B` and `C` block, waiting on `Work` to release cores (or return).\n+\n+When `Work` returns, MSBuild automatically returns all resources reserved by the task to the pool. At that time `Work2`'s calls to `RequestCores` unblock, and",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "\". . . and everything works!\"\r\n\r\nSeriously though this is probably not the right behavior and should be rewritten to reflect whatever we land on (hopefully the scheduler thing which is conceptually easier too).",
              "createdAt": "2021-01-15T22:22:42Z",
              "path": "documentation/specs/resource-management.md",
              "diffHunk": "@@ -0,0 +1,45 @@\n+# Managing tools with their own parallelism in MSBuild\n+\n+MSBuild supports building projects in parallel using multiple processes. Most users opt into `NUM_PROCS` parallelism at the MSBuild layer.\n+\n+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.\n+\n+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.\n+\n+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.\n+\n+## Design\n+\n+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`BlockingWaitForCore`). These will be advisory only\u2014a task can still do as much work as it desires with as many threads and processes as it desires.\n+\n+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.\n+\n+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`.\n+\n+MSBuild will respect core reservations given to tasks for tasks that opt into resource management only. If a project/task is eligible for execution, MSBuild will not wait until a resource is freed before starting execution of the new task. As a result, the machine can be oversubscribed, but only by a finite amount: the resource pool's core count.\n+\n+Task `Yield()`ing has no effect on the resources held by a task.\n+\n+## Example\n+\n+In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.\n+\n+Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls\n+\n+```C#\n+int allowedParallelism = BuildEngine8.RequestCores(Inputs.Count); // Inputs.Count == 25\n+```\n+\n+and gets `16`--the number of cores available to the build overall. Other tasks that do not call `RequestCores` do not affect this value.\n+\n+While `A` runs `Work`, projects `B` and `C` run another task `Work2` that also calls `RequestCores` with a high value. Since `Work` in `A` has reserved all cores, the calls in `B` and `C` block, waiting on `Work` to release cores (or return).\n+\n+When `Work` returns, MSBuild automatically returns all resources reserved by the task to the pool. At that time `Work2`'s calls to `RequestCores` unblock, and",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this increment to IBE9? I know we talked about branching off of IBE's after 8, but seeing as this has been in flight for a while I'm okay having another version. previous IBE's have typically been isolated between features.",
              "createdAt": "2021-03-26T22:12:10Z",
              "path": "src/Framework/IBuildEngine8.cs",
              "diffHunk": "@@ -11,6 +9,20 @@ namespace Microsoft.Build.Framework\n     /// </summary>\n     public interface IBuildEngine8 : IBuildEngine7",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "After mulling it over here and there, I do think this should be isolated to IBE9.",
              "createdAt": "2021-03-28T23:09:12Z",
              "path": "src/Framework/IBuildEngine8.cs",
              "diffHunk": "@@ -11,6 +9,20 @@ namespace Microsoft.Build.Framework\n     /// </summary>\n     public interface IBuildEngine8 : IBuildEngine7",
              "author": {
                "login": "benvillalobos"
              }
            },
            {
              "body": "I have added IBE9 as suggested, although I'm wondering if extending IBE8 would not be OK since it shipped in 16.10 which is still in preview.",
              "createdAt": "2021-03-29T10:30:01Z",
              "path": "src/Framework/IBuildEngine8.cs",
              "diffHunk": "@@ -11,6 +9,20 @@ namespace Microsoft.Build.Framework\n     /// </summary>\n     public interface IBuildEngine8 : IBuildEngine7",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This makes me a little uncomfortable because a user can misuse it and get a hard-to-diagnose hang pretty readily if they gate a task's completion on a particular RequestCores call completing. I saw that it should guarantee returning quickly the first time, but I could still imagine someone with few cores having a deadlock in a particular task if it only has one core available, and it has that one core block on results from a second parallel process that doesn't actually start because RequestCores never returned. I think it's ok because, as far as we know, C++ is the only user, and they'll presumably get it right. Just thought I'd mention it.",
              "createdAt": "2021-03-26T22:43:19Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2174,6 +2180,30 @@ private void HandleNewRequest(int node, BuildRequestBlocker blocker)\n             PerformSchedulingActions(response);\n         }\n \n+        /// <summary>\n+        /// Handles a resource request coming from a node.\n+        /// </summary>\n+        private void HandleResourceRequest(int node, ResourceRequest request)\n+        {\n+            if (request.IsResourceAcquire)\n+            {\n+                // Resource request requires a response and may be blocking. Our continuation is effectively a callback\n+                // to be called once at least one core becomes available.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The tasks that opt in must cooperate and release resources they don't use any longer. It would be good though to have logging (if not already)  of all RequestCores/ReleaseCores calls with the tasks name and the number of cores requested/acquired or released. ",
              "createdAt": "2021-03-27T06:46:48Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2174,6 +2180,30 @@ private void HandleNewRequest(int node, BuildRequestBlocker blocker)\n             PerformSchedulingActions(response);\n         }\n \n+        /// <summary>\n+        /// Handles a resource request coming from a node.\n+        /// </summary>\n+        private void HandleResourceRequest(int node, ResourceRequest request)\n+        {\n+            if (request.IsResourceAcquire)\n+            {\n+                // Resource request requires a response and may be blocking. Our continuation is effectively a callback\n+                // to be called once at least one core becomes available.",
              "author": {
                "login": "olgaark"
              }
            },
            {
              "body": "I have added logging as suggested.",
              "createdAt": "2021-03-30T09:51:14Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2174,6 +2180,30 @@ private void HandleNewRequest(int node, BuildRequestBlocker blocker)\n             PerformSchedulingActions(response);\n         }\n \n+        /// <summary>\n+        /// Handles a resource request coming from a node.\n+        /// </summary>\n+        private void HandleResourceRequest(int node, ResourceRequest request)\n+        {\n+            if (request.IsResourceAcquire)\n+            {\n+                // Resource request requires a response and may be blocking. Our continuation is effectively a callback\n+                // to be called once at least one core becomes available.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "There could be an issue if the ReleaseCores call for a process that uses a lot of cores gets lost somehow. I'm wondering if, in addition to being able to release cores, there should be an auto-release after a certain amount of time. Perhaps the scheduler pings the task, and if it responds that it still needs cores, it resets it; otherwise, it reclaims them?",
              "createdAt": "2021-03-26T22:48:05Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2174,6 +2180,30 @@ private void HandleNewRequest(int node, BuildRequestBlocker blocker)\n             PerformSchedulingActions(response);\n         }\n \n+        /// <summary>\n+        /// Handles a resource request coming from a node.\n+        /// </summary>\n+        private void HandleResourceRequest(int node, ResourceRequest request)\n+        {\n+            if (request.IsResourceAcquire)\n+            {\n+                // Resource request requires a response and may be blocking. Our continuation is effectively a callback\n+                // to be called once at least one core becomes available.\n+                _scheduler.RequestCores(request.GlobalRequestId, request.NumCores, request.IsBlocking).ContinueWith((Task<int> task) =>\n+                {\n+                    var response = new ResourceResponse(request.GlobalRequestId, task.Result);\n+                    _nodeManager.SendData(node, response);\n+                }, TaskContinuationOptions.ExecuteSynchronously);\n+            }\n+            else\n+            {\n+                // Resource release is a one-way call, no response is expected. We release the cores as instructed",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "There are countless ways a task can hang the build. Yes, the new API needs to be used carefully. With great power comes great responsibility, as they say. What you are suggesting sounds too complicated and it would not prevent all hangs. I can imagine tasks would use a hard-coded \"yes\" when asked if they still need cores and pass `int.MaxValue` for timeout.",
              "createdAt": "2021-03-29T08:18:24Z",
              "path": "src/Build/BackEnd/BuildManager/BuildManager.cs",
              "diffHunk": "@@ -2174,6 +2180,30 @@ private void HandleNewRequest(int node, BuildRequestBlocker blocker)\n             PerformSchedulingActions(response);\n         }\n \n+        /// <summary>\n+        /// Handles a resource request coming from a node.\n+        /// </summary>\n+        private void HandleResourceRequest(int node, ResourceRequest request)\n+        {\n+            if (request.IsResourceAcquire)\n+            {\n+                // Resource request requires a response and may be blocking. Our continuation is effectively a callback\n+                // to be called once at least one core becomes available.\n+                _scheduler.RequestCores(request.GlobalRequestId, request.NumCores, request.IsBlocking).ContinueWith((Task<int> task) =>\n+                {\n+                    var response = new ResourceResponse(request.GlobalRequestId, task.Result);\n+                    _nodeManager.SendData(node, response);\n+                }, TaskContinuationOptions.ExecuteSynchronously);\n+            }\n+            else\n+            {\n+                // Resource release is a one-way call, no response is expected. We release the cores as instructed",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Would it read to a deadlock or underutilization? I thought the scheduler would still schedule numProcs tasks running in parallel, and each would be guaranteed at least one core, so if a task exits with several cores without releasing them, it's just that other tasks wouldn't be able to be parallelized if they opt in.",
              "createdAt": "2021-03-26T22:57:39Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -361,6 +361,10 @@ public void Yield()\n         /// </summary>\n         public void Reacquire()\n         {\n+            // Release all cores on reacquire. The assumption here is that the task is done with CPU intensive work at this point and forgetting\n+            // to release explicitly granted cores when reacquiring the node may lead to deadlocks.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It could be a deadlock. The scheduler takes explicitly acquired cores into account when scheduling tasks. See the changes in `Scheduler.AtSchedulingLimit`: https://github.com/dotnet/msbuild/pull/5859/files#diff-a2f4cd20814bb6daa732376fd25d008cfdbabb8afad0eb9778a68e6165e43d5eR1389\r\n\r\nPrevious iterations of this PR used a \"core counter\" completely independent of task scheduling but my understanding is that it was a consequence of the implementation (semaphore), rather than done deliberately. We generally don't want to oversubscribe the machine much.\r\n",
              "createdAt": "2021-03-29T08:25:46Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -361,6 +361,10 @@ public void Yield()\n         /// </summary>\n         public void Reacquire()\n         {\n+            // Release all cores on reacquire. The assumption here is that the task is done with CPU intensive work at this point and forgetting\n+            // to release explicitly granted cores when reacquiring the node may lead to deadlocks.",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm assuming this always returns at least 1. Does that mean that if you're allocating the implicit core (for the task) that you're always going to get at least 2? And it might still block?",
              "createdAt": "2021-03-26T23:07:48Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -712,6 +729,90 @@ public bool ShouldTreatWarningAsError(string warningCode)\n             // An empty set means all warnings are errors.\n             return WarningsAsErrors.Count == 0 || WarningsAsErrors.Contains(warningCode);\n         }\n+\n+        /// <summary>\n+        /// Allocates shared CPU resources. Called by a task when it's about to do potentially multi-threaded/multi-process work.\n+        /// </summary>\n+        /// <param name=\"requestedCores\">The number of cores the task wants to use.</param>\n+        /// <returns>The number of cores the task is allowed to use given the current state of the build. This number is always between\n+        /// 1 and <paramref name=\"requestedCores\"/>. If the task has allocated its one implicit core, this call may block, waiting for\n+        /// at least one core to become available.</returns>\n+        public int RequestCores(int requestedCores)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(requestedCores > 0, nameof(requestedCores));\n+\n+            lock (_callbackMonitor)\n+            {\n+                IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;\n+\n+                int coresAcquired = 0;\n+                bool allocatingImplicitCore = false;\n+                if (_isImplicitCoreUsed)\n+                {\n+                    coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores, waitForCores: true);\n+                }\n+                else\n+                {\n+                    _isImplicitCoreUsed = true;\n+                    allocatingImplicitCore = true;\n+                    if (requestedCores > 1)\n+                    {\n+                        coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores - 1, waitForCores: false);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Passing `waitForCores: false` makes 0 a possible return value from the builder callback. So this will return at least 1 (for the implicit core). Only if further calls are made do we take the other branch which blocks.",
              "createdAt": "2021-03-29T09:06:57Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -712,6 +729,90 @@ public bool ShouldTreatWarningAsError(string warningCode)\n             // An empty set means all warnings are errors.\n             return WarningsAsErrors.Count == 0 || WarningsAsErrors.Contains(warningCode);\n         }\n+\n+        /// <summary>\n+        /// Allocates shared CPU resources. Called by a task when it's about to do potentially multi-threaded/multi-process work.\n+        /// </summary>\n+        /// <param name=\"requestedCores\">The number of cores the task wants to use.</param>\n+        /// <returns>The number of cores the task is allowed to use given the current state of the build. This number is always between\n+        /// 1 and <paramref name=\"requestedCores\"/>. If the task has allocated its one implicit core, this call may block, waiting for\n+        /// at least one core to become available.</returns>\n+        public int RequestCores(int requestedCores)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(requestedCores > 0, nameof(requestedCores));\n+\n+            lock (_callbackMonitor)\n+            {\n+                IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;\n+\n+                int coresAcquired = 0;\n+                bool allocatingImplicitCore = false;\n+                if (_isImplicitCoreUsed)\n+                {\n+                    coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores, waitForCores: true);\n+                }\n+                else\n+                {\n+                    _isImplicitCoreUsed = true;\n+                    allocatingImplicitCore = true;\n+                    if (requestedCores > 1)\n+                    {\n+                        coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores - 1, waitForCores: false);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should you also reset _isImplicitCoreUsed? It shouldn't matter if this is called just before the task exits, and it's internal, but I think someone could theoretically Reacquire then do more work, right?",
              "createdAt": "2021-03-26T23:14:39Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -712,6 +729,90 @@ public bool ShouldTreatWarningAsError(string warningCode)\n             // An empty set means all warnings are errors.\n             return WarningsAsErrors.Count == 0 || WarningsAsErrors.Contains(warningCode);\n         }\n+\n+        /// <summary>\n+        /// Allocates shared CPU resources. Called by a task when it's about to do potentially multi-threaded/multi-process work.\n+        /// </summary>\n+        /// <param name=\"requestedCores\">The number of cores the task wants to use.</param>\n+        /// <returns>The number of cores the task is allowed to use given the current state of the build. This number is always between\n+        /// 1 and <paramref name=\"requestedCores\"/>. If the task has allocated its one implicit core, this call may block, waiting for\n+        /// at least one core to become available.</returns>\n+        public int RequestCores(int requestedCores)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(requestedCores > 0, nameof(requestedCores));\n+\n+            lock (_callbackMonitor)\n+            {\n+                IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;\n+\n+                int coresAcquired = 0;\n+                bool allocatingImplicitCore = false;\n+                if (_isImplicitCoreUsed)\n+                {\n+                    coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores, waitForCores: true);\n+                }\n+                else\n+                {\n+                    _isImplicitCoreUsed = true;\n+                    allocatingImplicitCore = true;\n+                    if (requestedCores > 1)\n+                    {\n+                        coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores - 1, waitForCores: false);\n+                    }\n+                }\n+                _additionalAcquiredCores += coresAcquired;\n+\n+                if (allocatingImplicitCore)\n+                {\n+                    // Pad the result with the one implicit core if it was still available.\n+                    // This ensures that first call never blocks and always returns >= 1.\n+                    coresAcquired++;\n+                }\n+\n+                Debug.Assert(coresAcquired >= 1);\n+                return coresAcquired;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Frees shared CPU resources. Called by a task when it's finished doing multi-threaded/multi-process work.\n+        /// </summary>\n+        /// <param name=\"coresToRelease\">The number of cores the task wants to return. This number must be between 0 and the number of cores\n+        /// granted and not yet released.</param>\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(coresToRelease > 0, nameof(coresToRelease));\n+\n+            lock (_callbackMonitor)\n+            {\n+                if (_isImplicitCoreUsed && coresToRelease > _additionalAcquiredCores)\n+                {\n+                    // Release the implicit core last, i.e. only if we're asked to release everything.\n+                    coresToRelease -= 1;\n+                    _isImplicitCoreUsed = false;\n+                }\n+\n+                if (coresToRelease >= 1)\n+                {\n+                    IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;\n+                    builderCallback.ReleaseCores(coresToRelease);\n+                    _additionalAcquiredCores -= coresToRelease;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Frees all CPU resources granted so far.\n+        /// </summary>\n+        internal void ReleaseAllCores()\n+        {\n+            int coresToRelease = _additionalAcquiredCores + (_isImplicitCoreUsed ? 1 : 0);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The flag is reset inside `ReleaseCore`. This is covered with the `SingleCoreRequestWithReacquire` test case. The test requests a large number of cores, then yields and reacquires, then requests the same number of cores again. It verifies that the second request does not block and returns the same number as the first one, meaning that `Reacquire` properly reset everything.",
              "createdAt": "2021-03-29T09:14:14Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs",
              "diffHunk": "@@ -712,6 +729,90 @@ public bool ShouldTreatWarningAsError(string warningCode)\n             // An empty set means all warnings are errors.\n             return WarningsAsErrors.Count == 0 || WarningsAsErrors.Contains(warningCode);\n         }\n+\n+        /// <summary>\n+        /// Allocates shared CPU resources. Called by a task when it's about to do potentially multi-threaded/multi-process work.\n+        /// </summary>\n+        /// <param name=\"requestedCores\">The number of cores the task wants to use.</param>\n+        /// <returns>The number of cores the task is allowed to use given the current state of the build. This number is always between\n+        /// 1 and <paramref name=\"requestedCores\"/>. If the task has allocated its one implicit core, this call may block, waiting for\n+        /// at least one core to become available.</returns>\n+        public int RequestCores(int requestedCores)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(requestedCores > 0, nameof(requestedCores));\n+\n+            lock (_callbackMonitor)\n+            {\n+                IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;\n+\n+                int coresAcquired = 0;\n+                bool allocatingImplicitCore = false;\n+                if (_isImplicitCoreUsed)\n+                {\n+                    coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores, waitForCores: true);\n+                }\n+                else\n+                {\n+                    _isImplicitCoreUsed = true;\n+                    allocatingImplicitCore = true;\n+                    if (requestedCores > 1)\n+                    {\n+                        coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores - 1, waitForCores: false);\n+                    }\n+                }\n+                _additionalAcquiredCores += coresAcquired;\n+\n+                if (allocatingImplicitCore)\n+                {\n+                    // Pad the result with the one implicit core if it was still available.\n+                    // This ensures that first call never blocks and always returns >= 1.\n+                    coresAcquired++;\n+                }\n+\n+                Debug.Assert(coresAcquired >= 1);\n+                return coresAcquired;\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Frees shared CPU resources. Called by a task when it's finished doing multi-threaded/multi-process work.\n+        /// </summary>\n+        /// <param name=\"coresToRelease\">The number of cores the task wants to return. This number must be between 0 and the number of cores\n+        /// granted and not yet released.</param>\n+        public void ReleaseCores(int coresToRelease)\n+        {\n+            ErrorUtilities.VerifyThrowArgumentOutOfRange(coresToRelease > 0, nameof(coresToRelease));\n+\n+            lock (_callbackMonitor)\n+            {\n+                if (_isImplicitCoreUsed && coresToRelease > _additionalAcquiredCores)\n+                {\n+                    // Release the implicit core last, i.e. only if we're asked to release everything.\n+                    coresToRelease -= 1;\n+                    _isImplicitCoreUsed = false;\n+                }\n+\n+                if (coresToRelease >= 1)\n+                {\n+                    IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;\n+                    builderCallback.ReleaseCores(coresToRelease);\n+                    _additionalAcquiredCores -= coresToRelease;\n+                }\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Frees all CPU resources granted so far.\n+        /// </summary>\n+        internal void ReleaseAllCores()\n+        {\n+            int coresToRelease = _additionalAcquiredCores + (_isImplicitCoreUsed ? 1 : 0);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Releasing and acquiring cores look very similar. Just the presence or absence of a boolean, it seems. Little confusing.",
              "createdAt": "2021-03-26T23:16:13Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -460,6 +482,58 @@ public void ExitMSBuildCallbackState()\n             _inMSBuildCallback = false;\n         }\n \n+        /// <summary>\n+        /// Requests CPU resources from the scheduler.\n+        /// </summary>\n+        public int RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)\n+        {\n+            ErrorUtilities.VerifyThrow(Monitor.IsEntered(monitorLockObject), \"Not running under the given lock\");\n+            VerifyIsNotZombie();\n+\n+            ResourceResponse responseObject = null;\n+            using AutoResetEvent responseEvent = new AutoResetEvent(false);\n+            _pendingResourceRequests.Enqueue((ResourceResponse response) =>\n+            {\n+                responseObject = response;\n+                responseEvent.Set();\n+            });\n+\n+            RaiseResourceRequest(new ResourceRequest(_requestEntry.Request.GlobalRequestId, requestedCores, waitForCores));",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That's a great point, I have refactored it to use static factory methods with descriptive names.",
              "createdAt": "2021-03-29T10:26:19Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -460,6 +482,58 @@ public void ExitMSBuildCallbackState()\n             _inMSBuildCallback = false;\n         }\n \n+        /// <summary>\n+        /// Requests CPU resources from the scheduler.\n+        /// </summary>\n+        public int RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)\n+        {\n+            ErrorUtilities.VerifyThrow(Monitor.IsEntered(monitorLockObject), \"Not running under the given lock\");\n+            VerifyIsNotZombie();\n+\n+            ResourceResponse responseObject = null;\n+            using AutoResetEvent responseEvent = new AutoResetEvent(false);\n+            _pendingResourceRequests.Enqueue((ResourceResponse response) =>\n+            {\n+                responseObject = response;\n+                responseEvent.Set();\n+            });\n+\n+            RaiseResourceRequest(new ResourceRequest(_requestEntry.Request.GlobalRequestId, requestedCores, waitForCores));",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How can you get multiple requests in this queue? The first one is non-blocking (so  the queue gets one item which is removed before this method exists), and subsequent calls are blocking. May be worth making your answer a code comment :)",
              "createdAt": "2021-03-28T02:26:42Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs",
              "diffHunk": "@@ -460,6 +482,58 @@ public void ExitMSBuildCallbackState()\n             _inMSBuildCallback = false;\n         }\n \n+        /// <summary>\n+        /// Requests CPU resources from the scheduler.\n+        /// </summary>\n+        public int RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)\n+        {\n+            ErrorUtilities.VerifyThrow(Monitor.IsEntered(monitorLockObject), \"Not running under the given lock\");\n+            VerifyIsNotZombie();\n+\n+            ResourceResponse responseObject = null;\n+            using AutoResetEvent responseEvent = new AutoResetEvent(false);\n+            _pendingResourceRequests.Enqueue((ResourceResponse response) =>",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "How can these request / release calls get called on the target builder? May be worth documenting as code comment.",
              "createdAt": "2021-03-28T02:35:44Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs",
              "diffHunk": "@@ -363,6 +363,22 @@ void IRequestBuilderCallback.ExitMSBuildCallbackState()\n             _requestBuilderCallback.ExitMSBuildCallbackState();\n         }\n \n+        /// <summary>\n+        /// Requests CPU resources from the scheduler.\n+        /// </summary>\n+        int IRequestBuilderCallback.RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I know you said you were testing this out, but this is probably the most confusing part of this PR from a user's perspective to me.",
              "createdAt": "2021-03-29T19:20:56Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -181,6 +197,17 @@ public Scheduler()\n                 }\n             }\n \n+            if (!int.TryParse(Environment.GetEnvironmentVariable(\"MSBUILDCORELIMIT\"), out _coreLimit) || _coreLimit <= 0)\n+            {\n+                _coreLimit = NativeMethodsShared.GetLogicalCoreCount();\n+            }\n+            if (!int.TryParse(Environment.GetEnvironmentVariable(\"MSBUILDNODECOREALLOCATIONWEIGHT\"), out _nodeCoreAllocationWeight)\n+                || _nodeCoreAllocationWeight <= 0\n+                || _nodeCoreAllocationWeight > 100)\n+            {\n+                _nodeCoreAllocationWeight = 0;\n+            }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I have added more comments in this section, apologies for the terse code.",
              "createdAt": "2021-03-30T09:52:41Z",
              "path": "src/Build/BackEnd/Components/Scheduler/Scheduler.cs",
              "diffHunk": "@@ -181,6 +197,17 @@ public Scheduler()\n                 }\n             }\n \n+            if (!int.TryParse(Environment.GetEnvironmentVariable(\"MSBUILDCORELIMIT\"), out _coreLimit) || _coreLimit <= 0)\n+            {\n+                _coreLimit = NativeMethodsShared.GetLogicalCoreCount();\n+            }\n+            if (!int.TryParse(Environment.GetEnvironmentVariable(\"MSBUILDNODECOREALLOCATIONWEIGHT\"), out _nodeCoreAllocationWeight)\n+                || _nodeCoreAllocationWeight <= 0\n+                || _nodeCoreAllocationWeight > 100)\n+            {\n+                _nodeCoreAllocationWeight = 0;\n+            }",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "As I mentioned in the meeting, I slightly prefer reusing IBuildEngine8, but this is fine.",
              "createdAt": "2021-03-29T19:22:23Z",
              "path": "src/Utilities/Task.cs",
              "diffHunk": "@@ -99,6 +99,11 @@ protected Task(ResourceManager taskResources, string helpKeywordPrefix)\n         /// </summary>\n         public IBuildEngine8 BuildEngine8 => (IBuildEngine8)BuildEngine;\n \n+        /// <summary>\n+        /// Retrieves the <see cref=\"IBuildEngine9\" /> version of the build engine interface provided by the host.\n+        /// </summary>\n+        public IBuildEngine9 BuildEngine9 => (IBuildEngine9)BuildEngine;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}