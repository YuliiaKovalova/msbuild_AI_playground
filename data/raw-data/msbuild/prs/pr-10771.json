{
  "number": 10771,
  "title": "Expose Properties and Items data enumeration",
  "body": "Fixes #10770\r\n\r\n### Context\r\nThe `ProjectEvaluationFinishedEventArgs` and `ProjectStartedEventArgs` Properties and Items members are nongeneric and need involved custom code to enumerate.\r\nWhile we do not want to expose exact internals to prevent ourselves from future changes - we should at least expose the way how the data can be traversed in string form.\r\n\r\n#### Previous state\r\n\r\nUsers needed to recreate [EnumerateItems](https://github.com/dotnet/msbuild/blob/94941d9cb26bb86045452b4a174a357b65a30c99/src/Build/Utilities/Utilities.cs#L682-L739) and [EnumerateProperties](https://github.com/dotnet/msbuild/blob/main/src/Build/Utilities/Utilities.cs#L626-L680) methods, which calls other internal helper methods and together use several internal types (`ItemDictionary`, `IItem`, `IProperty`, `IKeyed`, etc.) - so some of the cases need to be skipped by the custome code, and hence despite involved, the code is usually single purpose.\r\n\r\nSample of that can be found e.g. here:\r\n\r\nhttps://devdiv.visualstudio.com/DevDiv/_git/vs-code-coverage/pullrequest/582161?path=/src/cts/Build/BinlogReader.cs&version=GBmain&line=108&lineEnd=128&lineStartColumn=1&lineEndColumn=20&type=2&lineStyle=plain&_a=files&iteration=11&base=0\r\n\r\nwith\r\n\r\nhttps://devdiv.visualstudio.com/DevDiv/_git/vs-code-coverage/pullrequest/582161?path=/src/cts/Build/MSBuildHelper.cs&version=GBmain&line=36&lineEnd=60&lineStartColumn=1&lineEndColumn=6&type=2&lineStyle=plain&_a=files&iteration=11&base=0\r\n\r\nSo something like:\r\n\r\n```csharp\r\n        // the helper needs to be defined as well - attempting various casting. Similar to the internal EnumerateItems linked above\r\n        MSBuildHelper.EnumerateItems(projectEvaluationFinishedEventArgs.Items, entry =>\r\n        {\r\n            if (entry.Key.Equals(ProjectReferencePropertyName))\r\n            {\r\n                if (entry.Value is ITaskItem)\r\n                {\r\n                    string referenceProjectPath = ((ITaskItem)entry.Value).ItemSpec;\r\n\r\n                    // ...\r\n                }\r\n            }\r\n        });\r\n```\r\n\r\n#### Proposed\r\n\r\nThe discussed code would change to:\r\n\r\n```csharp\r\n        foreach (ItemData itemData in projectEvaluationFinishedEventArgs\r\n                     .EnumerateItems()\r\n                     .Where(i => i.itemType.Equals(ProjectReferencePropertyName)))\r\n        {\r\n            string referenceProjectPath = itemData.EvaluatedInclude;\r\n            IEnumerable<KeyValuePair<string, string>> metadata = itemData.EnumerateMetadata();\r\n            // ...\r\n        }\r\n```\r\n\r\nThe enumeration is as well demonstrated by tailored unit tests: [src/Build.UnitTests/BuildEventArgsDataEnumeration.cs](https://github.com/dotnet/msbuild/pull/10771/files#diff-437430f95753a8116c2893072bf1fb554bb7d200258225f483be9c9e76d938d3)\r\n\r\n### Notes\r\n\r\nThe decision on *extension methods vs. member methods* \r\n\r\nIn some cases (e.g. the `EnumerateMetadata` and `GetEvaluatedInclude` for `ITemData`) it was necessity not to break backward compatibility of interfaces. Nor could I introduce new interfaces and return wrapped types - as some of the existing consumers (including our code) relies on casting of enumerated data to specific types. Wrapping the data would break this.\r\n\r\nAs for the `EnumerateItems` and `EnumerateProperties` methods for data on BuildEventArgs - I have no strong opinions on this, and ready to flip to member methods if it seems better fit.\r\n\r\n### Testing\r\n - Added enumeration unit tests\r\n - Manual (via project the prototype project that cosumed the data)\r\n\r\n\r\nFYI @jakubch1 \r\n",
  "state": "MERGED",
  "createdAt": "2024-10-08T12:38:31Z",
  "updatedAt": "2024-10-31T13:12:42Z",
  "closedAt": "2024-10-31T13:12:41Z",
  "mergedAt": "2024-10-31T13:12:41Z",
  "additions": 493,
  "deletions": 79,
  "changedFiles": 10,
  "headRefName": "proto/expose-eventargs-enumeration",
  "isDraft": false,
  "author": {
    "login": "JanKrivanek"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "913b00e13a78924f4a7b4a72082cc33019ffd7e0",
          "message": "Expose Properties and Items data enumeration",
          "committedDate": "2024-10-08T12:33:23Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7a96d24dc158e3e3c6ebd1438894261decaafc63",
          "message": "Merge branch 'main' into proto/expose-eventargs-enumeration",
          "committedDate": "2024-10-09T12:02:52Z",
          "author": {
            "name": "YuliiaKovalova",
            "email": "95473390+YuliiaKovalova@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "137ec1fc867b770d29c01273cddf0f84c6339105",
          "message": "Add stronger type guarantee",
          "committedDate": "2024-10-10T10:37:01Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b4926c9aa3e829dc3c93a3feed113505cf8f97e7",
          "message": "Merge branch 'main' into proto/expose-eventargs-enumeration",
          "committedDate": "2024-10-10T12:27:08Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5d83e49bd316342dd5e3417772a47da0bdd46910",
          "message": "Add stronger typing for enumerating items",
          "committedDate": "2024-10-10T12:49:40Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d25b4e00fec20771febd9df2a9530a015b764379",
          "message": "Remove extra newlines",
          "committedDate": "2024-10-10T12:57:26Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7139ad09a65605b9ffa0351cd269733c183843f4",
          "message": "Do not wrap the underlying item objects",
          "committedDate": "2024-10-11T09:01:16Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "080bf5a170fda9b0316873e859a6da5521664afa",
          "message": "Fix styling",
          "committedDate": "2024-10-11T09:58:11Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9b7c56591700cfa3b78b707e0b5ed261a8675710",
          "message": "Add unit tests",
          "committedDate": "2024-10-11T10:50:30Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a5e4303ce2f972c8830198d57b72a6fbe190e3a4",
          "message": "Add explicit types for the API",
          "committedDate": "2024-10-18T13:10:08Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4d6cd7df1c86001b5eed20d859ff88e759109374",
          "message": "Remove breaking API change to ITaskItem",
          "committedDate": "2024-10-24T07:45:55Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fbead3b584ce324cf2a3d11967773f51b29d6355",
          "message": "Add comments",
          "committedDate": "2024-10-24T07:52:58Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "db8f24f32049035dfb028e66cc28f41afadc6508",
          "message": "Allow for item types without common base",
          "committedDate": "2024-10-24T11:15:56Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d3a1200f0dbd3866a01185611f9809d2a600afbd",
          "message": "Reflect PR suggestions",
          "committedDate": "2024-10-30T14:30:22Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "438125de1182ed574793b8bdb1989609e990cf93",
          "message": "Add unit test",
          "committedDate": "2024-10-30T14:30:34Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "758d261db35abf387133f70f47ccc31f8d89b6da",
          "message": "Remove redundant nullability",
          "committedDate": "2024-10-30T14:31:17Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7e8b35bc2a3a38290998bad74d0fffb170ff0e27",
          "message": "Move the extensions codefile",
          "committedDate": "2024-10-31T12:19:33Z",
          "author": {
            "name": "Jan Krivanek",
            "email": "jankrivanek@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "> Can you write up some motivation for doing it with extension methods, and what an old/new calling pattern would be?\r\n\r\n@rainersigwald I've added a motivation + sample to the description - please have a look if it makes sense.\r\n\r\nAs for 'extension vs member methods' - no strong opinions :-) it can be changed easily if it feels more proper.",
        "createdAt": "2024-10-10T12:56:18Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "> > The discussed code would change to:\r\n> > ```cs\r\n> >         foreach ((string itemType, IItemData itemValue) tuple in projectEvaluationFinishedEventArgs\r\n> >                      .EnumerateItems()\r\n> >                      .Where(i => i.itemType.Equals(ProjectReferencePropertyName)))\r\n> >         {\r\n> >             string referenceProjectPath = tuple.itemValue.GetEvaluatedInclude();\r\n> >             // ...\r\n> >         }\r\n> > ```\r\n> \r\n> Is this what we want to expose, or should it be something more like what we expose on `Project{Instance}`, such as [`ProjectInstance.GetItems(string type)`](https://learn.microsoft.com/dotnet/api/microsoft.build.execution.projectinstance.getitems)?\r\n\r\nI'd prefer to avoid that - while already public, those types are R/W. So let's expose a common base of those types - that still gives read access to important data (EvaluatedInclude, Metadata a string-string map) - which is more than what's made available today, and we can allways expose more if needed.\r\n\r\nWhat do you think?",
        "createdAt": "2024-10-24T07:49:34Z",
        "author": {
          "login": "JanKrivanek"
        }
      },
      {
        "body": "> > > The discussed code would change to:\r\n> > > ```cs\r\n> > >         foreach ((string itemType, IItemData itemValue) tuple in projectEvaluationFinishedEventArgs\r\n> > >                      .EnumerateItems()\r\n> > >                      .Where(i => i.itemType.Equals(ProjectReferencePropertyName)))\r\n> > >         {\r\n> > >             string referenceProjectPath = tuple.itemValue.GetEvaluatedInclude();\r\n> > >             // ...\r\n> > >         }\r\n> > > ```\r\n> > \r\n> > \r\n> > Is this what we want to expose, or should it be something more like what we expose on `Project{Instance}`, such as [`ProjectInstance.GetItems(string type)`](https://learn.microsoft.com/dotnet/api/microsoft.build.execution.projectinstance.getitems)?\r\n> \r\n> I'd prefer to avoid that - while already public, those types are R/W. So let's expose a common base of those types - that still gives read access to important data (EvaluatedInclude, Metadata a string-string map) - which is more than what's made available today, and we can allways expose more if needed.\r\n> \r\n> What do you think?\r\n\r\nActualy it's even more complicated - we pass only `ProjectItem` and `ProjectItemInstance` to the EventArgs during creation, but on node-2-node translation and binlog de/serialization those can be changed to `TaskItemData`. So without breaking existing public API we do not have any common type hierarchy. At the same type we cannot wrap - not to break consumers that cast the items.\r\n\r\nSo the way around is via an accessor object (something like flyweight pattern) - the target object is still just original `object` and can be casted, but the iterator provides accessor methods for strong-type-like accessing EvaluatedInclude and metadata.",
        "createdAt": "2024-10-24T11:20:05Z",
        "author": {
          "login": "JanKrivanek"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "We really can't do better than `object`?",
              "createdAt": "2024-10-08T22:17:52Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsExtensions.cs",
              "diffHunk": "@@ -0,0 +1,54 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Logging;\n+\n+/// <summary>\n+/// Helper extension methods for working with data passed via\n+/// <see cref=\"ProjectEvaluationFinishedEventArgs\"/> and <see cref=\"ProjectStartedEventArgs\"/>\n+/// </summary>\n+public static class BuildEventArgsExtensions\n+{\n+    /// <summary>\n+    /// Lazy enumerates and strong types properties from Properties property.\n+    /// </summary>\n+    public static IEnumerable<(string propertyName, string propertyValue)> EnumerateProperties(\n+        this ProjectEvaluationFinishedEventArgs eventArgs)\n+        => EnumerateProperties(eventArgs.Properties);\n+\n+    /// <summary>\n+    /// Lazy enumerates and strong types properties from Properties property.\n+    /// </summary>\n+    public static IEnumerable<(string propertyName, string propertyValue)> EnumerateProperties(\n+        this ProjectStartedEventArgs eventArgs)\n+        => EnumerateProperties(eventArgs.Properties);\n+\n+    /// <summary>\n+    /// Lazy enumerates and partially strong types items from Items property.\n+    /// The actual item value is of nongeneric <see cref=\"object\"/> type.\n+    /// The actual type need to be inferred during runtime based on the itemType.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Currently there is unfortunately really no common base.\r\nThough I agree the `object` is not very helpful.\r\n\r\nSo I've done some extracting + wrapping - now we are giving strongly typed interface",
              "createdAt": "2024-10-10T12:51:11Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsExtensions.cs",
              "diffHunk": "@@ -0,0 +1,54 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using Microsoft.Build.Framework;\n+\n+namespace Microsoft.Build.Logging;\n+\n+/// <summary>\n+/// Helper extension methods for working with data passed via\n+/// <see cref=\"ProjectEvaluationFinishedEventArgs\"/> and <see cref=\"ProjectStartedEventArgs\"/>\n+/// </summary>\n+public static class BuildEventArgsExtensions\n+{\n+    /// <summary>\n+    /// Lazy enumerates and strong types properties from Properties property.\n+    /// </summary>\n+    public static IEnumerable<(string propertyName, string propertyValue)> EnumerateProperties(\n+        this ProjectEvaluationFinishedEventArgs eventArgs)\n+        => EnumerateProperties(eventArgs.Properties);\n+\n+    /// <summary>\n+    /// Lazy enumerates and strong types properties from Properties property.\n+    /// </summary>\n+    public static IEnumerable<(string propertyName, string propertyValue)> EnumerateProperties(\n+        this ProjectStartedEventArgs eventArgs)\n+        => EnumerateProperties(eventArgs.Properties);\n+\n+    /// <summary>\n+    /// Lazy enumerates and partially strong types items from Items property.\n+    /// The actual item value is of nongeneric <see cref=\"object\"/> type.\n+    /// The actual type need to be inferred during runtime based on the itemType.",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "any localization concerns about retrieving the strng?s",
              "createdAt": "2024-10-16T07:34:32Z",
              "path": "src/Build.UnitTests/BuildEventArgsDataEnumeration.cs",
              "diffHunk": "@@ -0,0 +1,86 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Logging;\n+using Microsoft.Build.Shared;\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.Build.UnitTests\n+{\n+    public class BuildEventArgsDataEnumeration\n+    {\n+        [Fact]\n+        public void SamplePropertiesEnumeration()\n+        {\n+            var projectFile = @\"C:\\foo\\bar.proj\";\n+            var args = new ProjectEvaluationFinishedEventArgs(",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "This is a resource already used in prod code - so no extra localization is needed because of this",
              "createdAt": "2024-10-17T07:34:21Z",
              "path": "src/Build.UnitTests/BuildEventArgsDataEnumeration.cs",
              "diffHunk": "@@ -0,0 +1,86 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Logging;\n+using Microsoft.Build.Shared;\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.Build.UnitTests\n+{\n+    public class BuildEventArgsDataEnumeration\n+    {\n+        [Fact]\n+        public void SamplePropertiesEnumeration()\n+        {\n+            var projectFile = @\"C:\\foo\\bar.proj\";\n+            var args = new ProjectEvaluationFinishedEventArgs(",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "would it be better to create a data type instead of the types specified for the Tuple in the generic List?",
              "createdAt": "2024-10-16T07:38:50Z",
              "path": "src/Build.UnitTests/BuildEventArgsDataEnumeration.cs",
              "diffHunk": "@@ -0,0 +1,86 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Logging;\n+using Microsoft.Build.Shared;\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.Build.UnitTests\n+{\n+    public class BuildEventArgsDataEnumeration\n+    {\n+        [Fact]\n+        public void SamplePropertiesEnumeration()\n+        {\n+            var projectFile = @\"C:\\foo\\bar.proj\";\n+            var args = new ProjectEvaluationFinishedEventArgs(\n+                ResourceUtilities.GetResourceString(\"EvaluationFinished\"),\n+                projectFile)\n+            {\n+                BuildEventContext = BuildEventContext.Invalid,\n+                ProjectFile = @\"C:\\foo\\bar.proj\",\n+                GlobalProperties = new Dictionary<string, string>() { { \"GlobalKey\", \"GlobalValue\" } },\n+                Properties = new List<object>()\n+                {\n+                    new DictionaryEntry(\"Key\", \"Value\"),\n+                    ProjectPropertyInstance.Create(\"prop\", \"val\"),\n+                    new KeyValuePair<string, string>(\"foo\",\"bar\")\n+                },\n+                Items = null\n+            };\n+\n+            List<(string propertyName, string propertyValue)> results = args.EnumerateProperties().ToList();\n+            results.Count.ShouldBe(3);\n+            results[0].ShouldBe((\"Key\", \"Value\"));\n+            results[1].ShouldBe((\"prop\", \"val\"));\n+            results[2].ShouldBe((\"foo\", \"bar\"));\n+        }\n+\n+        [Fact]\n+        public void SampleItemsEnumeration()\n+        {\n+            string projectFile = @\"C:\\foo\\bar.proj\";\n+            ProjectEvaluationFinishedEventArgs args = new ProjectEvaluationFinishedEventArgs(\n+                ResourceUtilities.GetResourceString(\"EvaluationFinished\"),\n+                projectFile)\n+            {\n+                BuildEventContext = BuildEventContext.Invalid,\n+                ProjectFile = @\"C:\\foo\\bar.proj\",\n+                GlobalProperties = new Dictionary<string, string>() { { \"GlobalKey\", \"GlobalValue\" } },\n+                Properties = null,\n+                Items = new List<DictionaryEntry>()\n+                {\n+                    new DictionaryEntry(\"Key\", new MyTaskItem() { ItemSpec = \"TestItemSpec\" }),\n+                    new DictionaryEntry(\"Key2\",\n+                        new TaskItemData(\"spec\",\n+                            new Dictionary<string, string>() { { \"metadat1\", \"val1\" }, { \"metadat2\", \"val2\" } })),\n+                }\n+            };\n+\n+            List<(string itemType, IItemData itemValue)> results = args.EnumerateItems().ToList();",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "This is a fair concern. We cannot go wrong with explictly defined record here - I'll update.\r\nThanks!",
              "createdAt": "2024-10-17T07:37:51Z",
              "path": "src/Build.UnitTests/BuildEventArgsDataEnumeration.cs",
              "diffHunk": "@@ -0,0 +1,86 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Logging;\n+using Microsoft.Build.Shared;\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.Build.UnitTests\n+{\n+    public class BuildEventArgsDataEnumeration\n+    {\n+        [Fact]\n+        public void SamplePropertiesEnumeration()\n+        {\n+            var projectFile = @\"C:\\foo\\bar.proj\";\n+            var args = new ProjectEvaluationFinishedEventArgs(\n+                ResourceUtilities.GetResourceString(\"EvaluationFinished\"),\n+                projectFile)\n+            {\n+                BuildEventContext = BuildEventContext.Invalid,\n+                ProjectFile = @\"C:\\foo\\bar.proj\",\n+                GlobalProperties = new Dictionary<string, string>() { { \"GlobalKey\", \"GlobalValue\" } },\n+                Properties = new List<object>()\n+                {\n+                    new DictionaryEntry(\"Key\", \"Value\"),\n+                    ProjectPropertyInstance.Create(\"prop\", \"val\"),\n+                    new KeyValuePair<string, string>(\"foo\",\"bar\")\n+                },\n+                Items = null\n+            };\n+\n+            List<(string propertyName, string propertyValue)> results = args.EnumerateProperties().ToList();\n+            results.Count.ShouldBe(3);\n+            results[0].ShouldBe((\"Key\", \"Value\"));\n+            results[1].ShouldBe((\"prop\", \"val\"));\n+            results[2].ShouldBe((\"foo\", \"bar\"));\n+        }\n+\n+        [Fact]\n+        public void SampleItemsEnumeration()\n+        {\n+            string projectFile = @\"C:\\foo\\bar.proj\";\n+            ProjectEvaluationFinishedEventArgs args = new ProjectEvaluationFinishedEventArgs(\n+                ResourceUtilities.GetResourceString(\"EvaluationFinished\"),\n+                projectFile)\n+            {\n+                BuildEventContext = BuildEventContext.Invalid,\n+                ProjectFile = @\"C:\\foo\\bar.proj\",\n+                GlobalProperties = new Dictionary<string, string>() { { \"GlobalKey\", \"GlobalValue\" } },\n+                Properties = null,\n+                Items = new List<DictionaryEntry>()\n+                {\n+                    new DictionaryEntry(\"Key\", new MyTaskItem() { ItemSpec = \"TestItemSpec\" }),\n+                    new DictionaryEntry(\"Key2\",\n+                        new TaskItemData(\"spec\",\n+                            new Dictionary<string, string>() { { \"metadat1\", \"val1\" }, { \"metadat2\", \"val2\" } })),\n+                }\n+            };\n+\n+            List<(string itemType, IItemData itemValue)> results = args.EnumerateItems().ToList();",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Explicit types added",
              "createdAt": "2024-10-18T13:11:25Z",
              "path": "src/Build.UnitTests/BuildEventArgsDataEnumeration.cs",
              "diffHunk": "@@ -0,0 +1,86 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Framework;\n+using Microsoft.Build.Logging;\n+using Microsoft.Build.Shared;\n+using Shouldly;\n+using Xunit;\n+\n+namespace Microsoft.Build.UnitTests\n+{\n+    public class BuildEventArgsDataEnumeration\n+    {\n+        [Fact]\n+        public void SamplePropertiesEnumeration()\n+        {\n+            var projectFile = @\"C:\\foo\\bar.proj\";\n+            var args = new ProjectEvaluationFinishedEventArgs(\n+                ResourceUtilities.GetResourceString(\"EvaluationFinished\"),\n+                projectFile)\n+            {\n+                BuildEventContext = BuildEventContext.Invalid,\n+                ProjectFile = @\"C:\\foo\\bar.proj\",\n+                GlobalProperties = new Dictionary<string, string>() { { \"GlobalKey\", \"GlobalValue\" } },\n+                Properties = new List<object>()\n+                {\n+                    new DictionaryEntry(\"Key\", \"Value\"),\n+                    ProjectPropertyInstance.Create(\"prop\", \"val\"),\n+                    new KeyValuePair<string, string>(\"foo\",\"bar\")\n+                },\n+                Items = null\n+            };\n+\n+            List<(string propertyName, string propertyValue)> results = args.EnumerateProperties().ToList();\n+            results.Count.ShouldBe(3);\n+            results[0].ShouldBe((\"Key\", \"Value\"));\n+            results[1].ShouldBe((\"prop\", \"val\"));\n+            results[2].ShouldBe((\"foo\", \"bar\"));\n+        }\n+\n+        [Fact]\n+        public void SampleItemsEnumeration()\n+        {\n+            string projectFile = @\"C:\\foo\\bar.proj\";\n+            ProjectEvaluationFinishedEventArgs args = new ProjectEvaluationFinishedEventArgs(\n+                ResourceUtilities.GetResourceString(\"EvaluationFinished\"),\n+                projectFile)\n+            {\n+                BuildEventContext = BuildEventContext.Invalid,\n+                ProjectFile = @\"C:\\foo\\bar.proj\",\n+                GlobalProperties = new Dictionary<string, string>() { { \"GlobalKey\", \"GlobalValue\" } },\n+                Properties = null,\n+                Items = new List<DictionaryEntry>()\n+                {\n+                    new DictionaryEntry(\"Key\", new MyTaskItem() { ItemSpec = \"TestItemSpec\" }),\n+                    new DictionaryEntry(\"Key2\",\n+                        new TaskItemData(\"spec\",\n+                            new Dictionary<string, string>() { { \"metadat1\", \"val1\" }, { \"metadat2\", \"val2\" } })),\n+                }\n+            };\n+\n+            List<(string itemType, IItemData itemValue)> results = args.EnumerateItems().ToList();",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "this property was previously initialized to '\"foo\"', is it now uninitialized by design?",
              "createdAt": "2024-10-16T07:40:56Z",
              "path": "src/Build.UnitTests/MockTask.cs",
              "diffHunk": "@@ -425,17 +425,7 @@ internal sealed class MyTaskItem : ITaskItem\n     {\n         #region ITaskItem Members\n \n-        public string ItemSpec\n-        {\n-            get\n-            {\n-                return \"foo\";\n-            }\n-            set\n-            {\n-                // do nothing\n-            }\n-        }\n+        public string ItemSpec { get; set; }",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "It was a dummy mock implementation that was actually never used - so I could go fwd without risk of breaking anything (it's only used in our tests). More real-like behavior was needed for new detailed tests",
              "createdAt": "2024-10-17T07:39:28Z",
              "path": "src/Build.UnitTests/MockTask.cs",
              "diffHunk": "@@ -425,17 +425,7 @@ internal sealed class MyTaskItem : ITaskItem\n     {\n         #region ITaskItem Members\n \n-        public string ItemSpec\n-        {\n-            get\n-            {\n-                return \"foo\";\n-            }\n-            set\n-            {\n-                // do nothing\n-            }\n-        }\n+        public string ItemSpec { get; set; }",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "do you wish to throttle how many critical sections are entered? if so consider type [semaphoreSlim,](https://learn.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim?view=net-8.0)",
              "createdAt": "2024-10-16T07:44:52Z",
              "path": "src/Build/Collections/PropertyDictionary.cs",
              "diffHunk": "@@ -529,17 +529,25 @@ internal Dictionary<string, string> ToDictionary()\n             }\n         }\n \n-        internal void Enumerate(Action<string, string> keyValueCallback)\n+        internal IEnumerable<(string propertyName, string propertyValue)> Enumerate()\n         {\n             lock (_properties)",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "I do not intend to change the concurency specific of this code here.\r\nWould we want that - we'd probably need to change underlying structure to be thread safe.\r\n\r\nBut - not needed in scope of this change and not identified as hot perf issue - so not pursuing now",
              "createdAt": "2024-10-17T08:14:48Z",
              "path": "src/Build/Collections/PropertyDictionary.cs",
              "diffHunk": "@@ -529,17 +529,25 @@ internal Dictionary<string, string> ToDictionary()\n             }\n         }\n \n-        internal void Enumerate(Action<string, string> keyValueCallback)\n+        internal IEnumerable<(string propertyName, string propertyValue)> Enumerate()\n         {\n             lock (_properties)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "what happens if no match for 'kvp. Key'?",
              "createdAt": "2024-10-16T07:45:57Z",
              "path": "src/Build/Collections/PropertyDictionary.cs",
              "diffHunk": "@@ -529,17 +529,25 @@ internal Dictionary<string, string> ToDictionary()\n             }\n         }\n \n-        internal void Enumerate(Action<string, string> keyValueCallback)\n+        internal IEnumerable<(string propertyName, string propertyValue)> Enumerate()\n         {\n             lock (_properties)\n             {\n                 foreach (var kvp in (ICollection<T>)_properties)\n                 {\n-                    keyValueCallback(kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));\n+                    yield return (kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "I might not uderstand the concern here. The code returns all properties - it's not searching for a specific one",
              "createdAt": "2024-10-17T07:42:29Z",
              "path": "src/Build/Collections/PropertyDictionary.cs",
              "diffHunk": "@@ -529,17 +529,25 @@ internal Dictionary<string, string> ToDictionary()\n             }\n         }\n \n-        internal void Enumerate(Action<string, string> keyValueCallback)\n+        internal IEnumerable<(string propertyName, string propertyValue)> Enumerate()\n         {\n             lock (_properties)\n             {\n                 foreach (var kvp in (ICollection<T>)_properties)\n                 {\n-                    keyValueCallback(kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));\n+                    yield return (kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "are you creating a custom observer pattern? if so, consider the reactive extensions",
              "createdAt": "2024-10-16T07:46:58Z",
              "path": "src/Build/Collections/PropertyDictionary.cs",
              "diffHunk": "@@ -529,17 +529,25 @@ internal Dictionary<string, string> ToDictionary()\n             }\n         }\n \n-        internal void Enumerate(Action<string, string> keyValueCallback)\n+        internal IEnumerable<(string propertyName, string propertyValue)> Enumerate()\n         {\n             lock (_properties)\n             {\n                 foreach (var kvp in (ICollection<T>)_properties)\n                 {\n-                    keyValueCallback(kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));\n+                    yield return (kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));\n                 }\n             }\n         }\n \n+        internal void Enumerate(Action<string, string> keyValueCallback)",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "I do not thing Rx.NET would be a good investment choice for msbuild at this point of time - but since this is being brought up repetitively:\r\n* https://github.com/dotnet/msbuild/pull/10768#discussion_r1793369957\r\n* https://github.com/dotnet/msbuild/pull/9132#discussion_r1303075800\r\n\r\nLet's discuss offline what it would mean (extra binary dependency, changes to public API, rewriting subscribing model to observing model) and what would be the  added value in return.",
              "createdAt": "2024-10-17T08:19:29Z",
              "path": "src/Build/Collections/PropertyDictionary.cs",
              "diffHunk": "@@ -529,17 +529,25 @@ internal Dictionary<string, string> ToDictionary()\n             }\n         }\n \n-        internal void Enumerate(Action<string, string> keyValueCallback)\n+        internal IEnumerable<(string propertyName, string propertyValue)> Enumerate()\n         {\n             lock (_properties)\n             {\n                 foreach (var kvp in (ICollection<T>)_properties)\n                 {\n-                    keyValueCallback(kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));\n+                    yield return (kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));\n                 }\n             }\n         }\n \n+        internal void Enumerate(Action<string, string> keyValueCallback)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "is '__this__' needed?",
              "createdAt": "2024-10-16T07:48:34Z",
              "path": "src/Build/Definition/ProjectItem.cs",
              "diffHunk": "@@ -143,6 +144,12 @@ internal ProjectItem(\n \n         internal virtual ProjectItemLink Link => null;\n \n+        /// <inheritdoc cref=\"IItemData.ItemSpec\"/>\n+        string IItemData.ItemSpec => this.EvaluatedInclude;\n+\n+        /// <inheritdoc cref=\"IItemDataWithMetadata.EnumerateMetadata\"/>\n+        IEnumerable<KeyValuePair<string, string>> IItemDataWithMetadata.EnumerateMetadata() => this.Metadata.Select(m => new KeyValuePair<string, string>(m.Name, m.EvaluatedValue));",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Removing..",
              "createdAt": "2024-10-17T08:25:25Z",
              "path": "src/Build/Definition/ProjectItem.cs",
              "diffHunk": "@@ -143,6 +144,12 @@ internal ProjectItem(\n \n         internal virtual ProjectItemLink Link => null;\n \n+        /// <inheritdoc cref=\"IItemData.ItemSpec\"/>\n+        string IItemData.ItemSpec => this.EvaluatedInclude;\n+\n+        /// <inheritdoc cref=\"IItemDataWithMetadata.EnumerateMetadata\"/>\n+        IEnumerable<KeyValuePair<string, string>> IItemDataWithMetadata.EnumerateMetadata() => this.Metadata.Select(m => new KeyValuePair<string, string>(m.Name, m.EvaluatedValue));",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "consider 'IEnumerable<T>.Empty();'",
              "createdAt": "2024-10-16T07:52:04Z",
              "path": "src/Build/Utilities/Utilities.cs",
              "diffHunk": "@@ -623,46 +626,45 @@ public static T[] ToArray<T>(this IEnumerator<T> enumerator)\n             return enumerator.ToEnumerable().ToArray();\n         }\n \n-        public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, Action<TArg, KeyValuePair<string, string>> callback)\n+        public static IEnumerable<(string propertyName, string propertyValue)> EnumerateProperties(IEnumerable properties)\n         {\n             if (properties == null)\n             {\n-                return;\n+                return [];",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "The [collection expression](https://learn.microsoft.com/dotnet/csharp/whats-new/csharp-12#collection-expressions) is basically always superior these days--it lets the compiler use (or synthesize) the best type.",
              "createdAt": "2024-10-16T10:36:55Z",
              "path": "src/Build/Utilities/Utilities.cs",
              "diffHunk": "@@ -623,46 +626,45 @@ public static T[] ToArray<T>(this IEnumerator<T> enumerator)\n             return enumerator.ToEnumerable().ToArray();\n         }\n \n-        public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, Action<TArg, KeyValuePair<string, string>> callback)\n+        public static IEnumerable<(string propertyName, string propertyValue)> EnumerateProperties(IEnumerable properties)\n         {\n             if (properties == null)\n             {\n-                return;\n+                return [];",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "why? we are moving to new C# collection expression syntax everywhere!",
              "createdAt": "2024-10-17T07:53:13Z",
              "path": "src/Build/Utilities/Utilities.cs",
              "diffHunk": "@@ -623,46 +626,45 @@ public static T[] ToArray<T>(this IEnumerator<T> enumerator)\n             return enumerator.ToEnumerable().ToArray();\n         }\n \n-        public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, Action<TArg, KeyValuePair<string, string>> callback)\n+        public static IEnumerable<(string propertyName, string propertyValue)> EnumerateProperties(IEnumerable properties)\n         {\n             if (properties == null)\n             {\n-                return;\n+                return [];",
              "author": {
                "login": "kasperk81"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "consider returning the results of calling the empty method in __IEnumerable__",
              "createdAt": "2024-10-16T07:54:57Z",
              "path": "src/Build/Utilities/Utilities.cs",
              "diffHunk": "@@ -679,31 +681,54 @@ public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, A\n             }\n         }\n \n-        public static void EnumerateItems(IEnumerable items, Action<DictionaryEntry> callback)\n+        public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, Action<TArg, KeyValuePair<string, string>> callback)\n         {\n+            foreach (var tuple in EnumerateProperties(properties))\n+            {\n+                callback(arg, new KeyValuePair<string, string>(tuple.propertyName, tuple.propertyValue));\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Enumerates the given nongeneric enumeration and tries to match or wrap appropriate item types\n+        /// </summary>\n+        public static IEnumerable<(string itemType, IItemData itemValue)> EnumerateItems(IEnumerable items)\n+        {\n+            // The actual type of the item data can be of types:\n+            //  * <see cref=\"ProjectItemInstance\"/>\n+            //  * <see cref=\"ProjectItem\"/>\n+            //  * <see cref=\"IItem\"/>\n+            //  * <see cref=\"ITaskItem\"/>\n+            //  * possibly others\n+            // That's why we here wrap with ItemAccessor if needed\n+\n+            if (items == null)\n+            {",
              "author": {
                "login": "donJoseLuis"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "what if the length of items is zero?",
              "createdAt": "2024-10-16T07:55:38Z",
              "path": "src/Build/Utilities/Utilities.cs",
              "diffHunk": "@@ -679,31 +681,54 @@ public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, A\n             }\n         }\n \n-        public static void EnumerateItems(IEnumerable items, Action<DictionaryEntry> callback)\n+        public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, Action<TArg, KeyValuePair<string, string>> callback)\n         {\n+            foreach (var tuple in EnumerateProperties(properties))\n+            {\n+                callback(arg, new KeyValuePair<string, string>(tuple.propertyName, tuple.propertyValue));\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Enumerates the given nongeneric enumeration and tries to match or wrap appropriate item types\n+        /// </summary>\n+        public static IEnumerable<(string itemType, IItemData itemValue)> EnumerateItems(IEnumerable items)\n+        {\n+            // The actual type of the item data can be of types:\n+            //  * <see cref=\"ProjectItemInstance\"/>\n+            //  * <see cref=\"ProjectItem\"/>\n+            //  * <see cref=\"IItem\"/>\n+            //  * <see cref=\"ITaskItem\"/>\n+            //  * possibly others\n+            // That's why we here wrap with ItemAccessor if needed\n+\n+            if (items == null)",
              "author": {
                "login": "donJoseLuis"
              }
            },
            {
              "body": "Empty result would be returned.\r\nIt just cannot be special checked - as it'd require enumerating the enumeration",
              "createdAt": "2024-10-17T08:24:50Z",
              "path": "src/Build/Utilities/Utilities.cs",
              "diffHunk": "@@ -679,31 +681,54 @@ public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, A\n             }\n         }\n \n-        public static void EnumerateItems(IEnumerable items, Action<DictionaryEntry> callback)\n+        public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, Action<TArg, KeyValuePair<string, string>> callback)\n         {\n+            foreach (var tuple in EnumerateProperties(properties))\n+            {\n+                callback(arg, new KeyValuePair<string, string>(tuple.propertyName, tuple.propertyValue));\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Enumerates the given nongeneric enumeration and tries to match or wrap appropriate item types\n+        /// </summary>\n+        public static IEnumerable<(string itemType, IItemData itemValue)> EnumerateItems(IEnumerable items)\n+        {\n+            // The actual type of the item data can be of types:\n+            //  * <see cref=\"ProjectItemInstance\"/>\n+            //  * <see cref=\"ProjectItem\"/>\n+            //  * <see cref=\"IItem\"/>\n+            //  * <see cref=\"ITaskItem\"/>\n+            //  * possibly others\n+            // That's why we here wrap with ItemAccessor if needed\n+\n+            if (items == null)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this mean that tasks that implement `ITaskItem` are broken by this change?",
              "createdAt": "2024-10-16T10:32:12Z",
              "path": "src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs",
              "diffHunk": "@@ -415,6 +415,8 @@ IDictionary ITaskItem.CloneCustomMetadata()\n             {\n                 throw new NotImplementedException();\n             }\n+\n+            string IItemData.ItemSpec => ((ITaskItem)this).ItemSpec;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "You are indeed right. Implicit implementors are fine, explicit implementors will get broken.\r\n\r\nThis goes in line with the official recommendation from https://learn.microsoft.com/en-us/dotnet/core/compatibility/library-change-rules:\r\n\r\n\r\n> \u274c DISALLOWED: Adding an interface to the set of base types of an interface\r\n> \r\n> If an interface implements an interface that it previously did not implement, all types that implemented the original version of the interface are broken.\r\n\r\n\r\nSo not sure why it wasn't caught by API compat. cc @ViktorHofer \r\n\r\nI'll rethink this + enter bug for api compat.\r\nThanks @rainersigwald! ",
              "createdAt": "2024-10-24T07:03:56Z",
              "path": "src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs",
              "diffHunk": "@@ -415,6 +415,8 @@ IDictionary ITaskItem.CloneCustomMetadata()\n             {\n                 throw new NotImplementedException();\n             }\n+\n+            string IItemData.ItemSpec => ((ITaskItem)this).ItemSpec;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "https://github.com/dotnet/sdk/issues/44426",
              "createdAt": "2024-10-24T07:10:43Z",
              "path": "src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs",
              "diffHunk": "@@ -415,6 +415,8 @@ IDictionary ITaskItem.CloneCustomMetadata()\n             {\n                 throw new NotImplementedException();\n             }\n+\n+            string IItemData.ItemSpec => ((ITaskItem)this).ItemSpec;",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Removed the extension of the interface",
              "createdAt": "2024-10-24T07:53:36Z",
              "path": "src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs",
              "diffHunk": "@@ -415,6 +415,8 @@ IDictionary ITaskItem.CloneCustomMetadata()\n             {\n                 throw new NotImplementedException();\n             }\n+\n+            string IItemData.ItemSpec => ((ITaskItem)this).ItemSpec;",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Missing XML comment.",
              "createdAt": "2024-10-22T14:59:17Z",
              "path": "src/Build/Utilities/Utilities.cs",
              "diffHunk": "@@ -623,46 +626,45 @@ public static T[] ToArray<T>(this IEnumerator<T> enumerator)\n             return enumerator.ToEnumerable().ToArray();\n         }\n \n-        public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, Action<TArg, KeyValuePair<string, string>> callback)\n+        public static IEnumerable<PropertyData> EnumerateProperties(IEnumerable properties)",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Another XML comment.",
              "createdAt": "2024-10-22T14:59:29Z",
              "path": "src/Build/Utilities/Utilities.cs",
              "diffHunk": "@@ -730,12 +755,34 @@ public static void EnumerateItems(IEnumerable items, Action<DictionaryEntry> cal\n                         }\n                     }\n \n-                    if (!String.IsNullOrEmpty(itemType))\n+                    IItemData data = null;\n+\n+                    if (itemValue != null)\n                     {\n-                        callback(new DictionaryEntry(itemType, itemValue));\n+                        if (itemValue is IItemData dt)\n+                        {\n+                            data = dt;\n+                        }\n+                        else\n+                        {\n+                            Debug.Fail($\"In {nameof(EnumerateItems)}(): Unexpected {nameof(itemValue)} {itemValue} of type {itemValue?.GetType().ToString()}\");\n+                        }\n+                    }\n+\n+                    if (data != null)\n+                    {\n+                        yield return new(itemType!, data);\n                     }\n                 }\n             }\n         }\n+\n+        public static void EnumerateItems(IEnumerable items, Action<DictionaryEntry> callback)",
              "author": {
                "login": "maridematte"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why suggest instead of making it private and enforce it?",
              "createdAt": "2024-10-24T16:12:12Z",
              "path": "src/Framework/IItemData.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Represents a metadata that can natively provide it's metadata.\n+/// </summary>\n+public interface IItemData\n+{\n+    /// <summary>\n+    /// Gets the item evaluated include data. It is in fact a 'specification' of the item (e.g. path on disk to a specific ProjectReference)\n+    /// </summary>\n+    string EvaluatedInclude\n+    {\n+        get;\n+    }\n+\n+    /// <summary>\n+    /// The item metadata\n+    /// </summary>\n+    IEnumerable<KeyValuePair<string, string>> EnumerateMetadata();\n+}\n+\n+\n+/// <summary>\n+/// Structure defining single MSBuild property instance.\n+/// </summary>\n+/// <param name=\"Name\">The name of property - e.g. 'TargetFramework'.</param>\n+/// <param name=\"Value\">The actual value of property - e.g. 'net9'.</param>\n+public readonly record struct PropertyData(string Name, string Value);\n+\n+/// <summary>\n+/// Structure defining single MSBuild item instance.\n+/// </summary>\n+/// <remarks>\n+/// The underlying Value property can be of various distinct types - so it's suggested to use provided accessor methods",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "You are right - let's not expose that. Making internal (to keep supporting the case described below - I'll create followup PR where we'll be able to hide it alltogether - but I'd prefer that as a separate change)\r\n\r\nPreexisting code provided the `EnumerateItems` helper, that took a callback and provided the underlying value for casting - so I'll keep that and refactor in the next step.\r\nBut there is no need to expose this unfortunate in the newly added data type and helper method ",
              "createdAt": "2024-10-30T13:20:23Z",
              "path": "src/Framework/IItemData.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Represents a metadata that can natively provide it's metadata.\n+/// </summary>\n+public interface IItemData\n+{\n+    /// <summary>\n+    /// Gets the item evaluated include data. It is in fact a 'specification' of the item (e.g. path on disk to a specific ProjectReference)\n+    /// </summary>\n+    string EvaluatedInclude\n+    {\n+        get;\n+    }\n+\n+    /// <summary>\n+    /// The item metadata\n+    /// </summary>\n+    IEnumerable<KeyValuePair<string, string>> EnumerateMetadata();\n+}\n+\n+\n+/// <summary>\n+/// Structure defining single MSBuild property instance.\n+/// </summary>\n+/// <param name=\"Name\">The name of property - e.g. 'TargetFramework'.</param>\n+/// <param name=\"Value\">The actual value of property - e.g. 'net9'.</param>\n+public readonly record struct PropertyData(string Name, string Value);\n+\n+/// <summary>\n+/// Structure defining single MSBuild item instance.\n+/// </summary>\n+/// <remarks>\n+/// The underlying Value property can be of various distinct types - so it's suggested to use provided accessor methods",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Done",
              "createdAt": "2024-10-30T14:30:01Z",
              "path": "src/Framework/IItemData.cs",
              "diffHunk": "@@ -0,0 +1,95 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Microsoft.Build.Framework;\n+\n+/// <summary>\n+/// Represents a metadata that can natively provide it's metadata.\n+/// </summary>\n+public interface IItemData\n+{\n+    /// <summary>\n+    /// Gets the item evaluated include data. It is in fact a 'specification' of the item (e.g. path on disk to a specific ProjectReference)\n+    /// </summary>\n+    string EvaluatedInclude\n+    {\n+        get;\n+    }\n+\n+    /// <summary>\n+    /// The item metadata\n+    /// </summary>\n+    IEnumerable<KeyValuePair<string, string>> EnumerateMetadata();\n+}\n+\n+\n+/// <summary>\n+/// Structure defining single MSBuild property instance.\n+/// </summary>\n+/// <param name=\"Name\">The name of property - e.g. 'TargetFramework'.</param>\n+/// <param name=\"Value\">The actual value of property - e.g. 'net9'.</param>\n+public readonly record struct PropertyData(string Name, string Value);\n+\n+/// <summary>\n+/// Structure defining single MSBuild item instance.\n+/// </summary>\n+/// <remarks>\n+/// The underlying Value property can be of various distinct types - so it's suggested to use provided accessor methods",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why is this in the BinaryLogger folder? It's not actually specific to that is it?",
              "createdAt": "2024-10-25T17:04:45Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsExtensions.cs",
              "diffHunk": "",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I could use some suggestions here:\r\n* [Build/Definition](https://github.com/dotnet/msbuild/tree/main/src/Build/Definition)? But that might have different purpose\r\n* [Build/Logging](https://github.com/dotnet/msbuild/tree/main/src/Build/Logging)? It's intended for BuildChecks as well - so not only logging\r\n* just root of Build?\r\n* ?\r\n\r\nIt needs to be in Microsoft.Build assembly (due to helpers and underlying types it's using).",
              "createdAt": "2024-10-30T14:28:59Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsExtensions.cs",
              "diffHunk": "",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "`Build/Logging` IMO. Regardless of use, `*EventArgs` are a logging concept. That's also the namespace you chose :)",
              "createdAt": "2024-10-30T19:05:05Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsExtensions.cs",
              "diffHunk": "",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I still think we should expose a `public static IEnumerable<ItemData> EnumerateItemsOfType(this ProjectStartedEventArgs eventArgs, string typeName)` that can use the O(1) operations in `ItemDictionary`. It feels to me like \"look at `@(Foo)`\" is a pretty common case for an individual analysis.",
              "createdAt": "2024-10-25T17:07:48Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsExtensions.cs",
              "diffHunk": "@@ -0,0 +1,57 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Framework;\n+using static Microsoft.Build.Internal.Utilities;\n+\n+namespace Microsoft.Build.Logging;\n+\n+/// <summary>\n+/// Helper extension methods for working with data passed via\n+/// <see cref=\"ProjectEvaluationFinishedEventArgs\"/> and <see cref=\"ProjectStartedEventArgs\"/>\n+/// </summary>\n+public static class BuildEventArgsExtensions\n+{\n+    /// <summary>\n+    /// Lazy enumerates and strong types properties from Properties property.\n+    /// </summary>\n+    public static IEnumerable<PropertyData> EnumerateProperties(\n+        this ProjectEvaluationFinishedEventArgs eventArgs)\n+        => EnumerateProperties(eventArgs.Properties);\n+\n+    /// <summary>\n+    /// Lazy enumerates and strong types properties from Properties property.\n+    /// </summary>\n+    public static IEnumerable<PropertyData> EnumerateProperties(\n+        this ProjectStartedEventArgs eventArgs)\n+        => EnumerateProperties(eventArgs.Properties);\n+\n+    /// <summary>\n+    /// Lazy enumerates and partially strong types items from Items property.\n+    /// The actual item value might be wrapped to be able to provide defined interface\n+    /// </summary>\n+    /// <returns></returns>\n+    public static IEnumerable<ItemData> EnumerateItems(\n+        this ProjectEvaluationFinishedEventArgs eventArgs)\n+        => EnumerateItems(eventArgs.Items);\n+\n+    /// <summary>\n+    /// Lazy enumerates and strong types items from Items property.\n+    /// The actual item value might be wrapped to be able to provide defined interface\n+    /// </summary>\n+    public static IEnumerable<ItemData> EnumerateItems(\n+        this ProjectStartedEventArgs eventArgs)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Oh - thanks for insisting and clarifying! - I completely missed that indexing part of your original suggestion.\r\nI'll add that for sure.\r\nIt'll however guarantee O(1) only if the underlying structure supports it - which is only after creation within the worker node. After the data is transfered to main node, it changes to enumeration of `TaskItemData` - so there is no indexing possible already. But we might optimize a bit by relying on some ordering guarantee",
              "createdAt": "2024-10-30T13:26:26Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsExtensions.cs",
              "diffHunk": "@@ -0,0 +1,57 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Framework;\n+using static Microsoft.Build.Internal.Utilities;\n+\n+namespace Microsoft.Build.Logging;\n+\n+/// <summary>\n+/// Helper extension methods for working with data passed via\n+/// <see cref=\"ProjectEvaluationFinishedEventArgs\"/> and <see cref=\"ProjectStartedEventArgs\"/>\n+/// </summary>\n+public static class BuildEventArgsExtensions\n+{\n+    /// <summary>\n+    /// Lazy enumerates and strong types properties from Properties property.\n+    /// </summary>\n+    public static IEnumerable<PropertyData> EnumerateProperties(\n+        this ProjectEvaluationFinishedEventArgs eventArgs)\n+        => EnumerateProperties(eventArgs.Properties);\n+\n+    /// <summary>\n+    /// Lazy enumerates and strong types properties from Properties property.\n+    /// </summary>\n+    public static IEnumerable<PropertyData> EnumerateProperties(\n+        this ProjectStartedEventArgs eventArgs)\n+        => EnumerateProperties(eventArgs.Properties);\n+\n+    /// <summary>\n+    /// Lazy enumerates and partially strong types items from Items property.\n+    /// The actual item value might be wrapped to be able to provide defined interface\n+    /// </summary>\n+    /// <returns></returns>\n+    public static IEnumerable<ItemData> EnumerateItems(\n+        this ProjectEvaluationFinishedEventArgs eventArgs)\n+        => EnumerateItems(eventArgs.Items);\n+\n+    /// <summary>\n+    /// Lazy enumerates and strong types items from Items property.\n+    /// The actual item value might be wrapped to be able to provide defined interface\n+    /// </summary>\n+    public static IEnumerable<ItemData> EnumerateItems(\n+        this ProjectStartedEventArgs eventArgs)",
              "author": {
                "login": "JanKrivanek"
              }
            },
            {
              "body": "Done + tests",
              "createdAt": "2024-10-30T14:29:53Z",
              "path": "src/Build/Logging/BinaryLogger/BuildEventArgsExtensions.cs",
              "diffHunk": "@@ -0,0 +1,57 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Framework;\n+using static Microsoft.Build.Internal.Utilities;\n+\n+namespace Microsoft.Build.Logging;\n+\n+/// <summary>\n+/// Helper extension methods for working with data passed via\n+/// <see cref=\"ProjectEvaluationFinishedEventArgs\"/> and <see cref=\"ProjectStartedEventArgs\"/>\n+/// </summary>\n+public static class BuildEventArgsExtensions\n+{\n+    /// <summary>\n+    /// Lazy enumerates and strong types properties from Properties property.\n+    /// </summary>\n+    public static IEnumerable<PropertyData> EnumerateProperties(\n+        this ProjectEvaluationFinishedEventArgs eventArgs)\n+        => EnumerateProperties(eventArgs.Properties);\n+\n+    /// <summary>\n+    /// Lazy enumerates and strong types properties from Properties property.\n+    /// </summary>\n+    public static IEnumerable<PropertyData> EnumerateProperties(\n+        this ProjectStartedEventArgs eventArgs)\n+        => EnumerateProperties(eventArgs.Properties);\n+\n+    /// <summary>\n+    /// Lazy enumerates and partially strong types items from Items property.\n+    /// The actual item value might be wrapped to be able to provide defined interface\n+    /// </summary>\n+    /// <returns></returns>\n+    public static IEnumerable<ItemData> EnumerateItems(\n+        this ProjectEvaluationFinishedEventArgs eventArgs)\n+        => EnumerateItems(eventArgs.Items);\n+\n+    /// <summary>\n+    /// Lazy enumerates and strong types items from Items property.\n+    /// The actual item value might be wrapped to be able to provide defined interface\n+    /// </summary>\n+    public static IEnumerable<ItemData> EnumerateItems(\n+        this ProjectStartedEventArgs eventArgs)",
              "author": {
                "login": "JanKrivanek"
              }
            }
          ]
        }
      }
    ]
  }
}