{
  "number": 6053,
  "title": "When sharing the terminal with child nodes, wait for the children to terminate before exiting ourselves.",
  "body": "This is an attempt to fix https://github.com/microsoft/vstest/issues/2282.\r\n\r\n@Forgind ptal.\r\n\r\nHow can I use the build output of this repository and combine it with an sdk so I can try out some things?\r\n\r\ncc @rainersigwald ",
  "state": "MERGED",
  "createdAt": "2021-01-21T09:01:53Z",
  "updatedAt": "2021-02-25T16:49:38Z",
  "closedAt": "2021-02-25T16:49:38Z",
  "mergedAt": "2021-02-25T16:49:38Z",
  "additions": 264,
  "deletions": 73,
  "changedFiles": 26,
  "headRefName": "wait_for_child_nodes",
  "isDraft": false,
  "author": {
    "login": "tmds"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "6ed2049446a6c8f72050d64208254e7d328b44d4",
          "message": "When sharing the terminal with child nodes, wait\nfor the children to terminate before exiting ourselves.\n\nThis avoids issues where the child changes terminal configuration\nafter our own exit.",
          "committedDate": "2021-01-21T08:58:38Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "412452e2667762fad9cb928d9ba250d87874c160",
          "message": "Kill node after timeout. Only wait when close sent.",
          "committedDate": "2021-01-25T13:39:26Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "812a0c9151e6717aecb1e11f606c17454719e663",
          "message": "Deploy-MSBuild.ps1: fix filename casing",
          "committedDate": "2021-01-25T14:11:47Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c6e5870605e8bfadb0b30999a91911d3b0523165",
          "message": "Keep a usable Process instance in the NodeContext",
          "committedDate": "2021-01-26T08:24:52Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d0091f40c0d923ab2fdfd0536f16e239b105ddef",
          "message": "Deploy-MSBuild: copy from net5.0",
          "committedDate": "2021-01-26T08:25:12Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cdefa6cce63a1e4863f664fe3d47a9e09c5c5641",
          "message": "style nit",
          "committedDate": "2021-01-26T08:31:29Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5d26c34a6138208271383ded178a0c57e7c31c69",
          "message": "Merge branch 'master' into wait_for_child_nodes",
          "committedDate": "2021-01-26T08:38:46Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f2c3945a94bbf485b0538af8fd47557f4ca3368c",
          "message": "Exec_Tests: update expected exit codes for using SIGKILL",
          "committedDate": "2021-01-26T09:53:10Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "83524bf1a2149b92cfc74ddb9aa41495d21bac0c",
          "message": "Fix Windows build",
          "committedDate": "2021-01-26T14:33:45Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2cc72534b97a59d3d561199834123e19cf4bb294",
          "message": "PR feedback",
          "committedDate": "2021-01-28T08:03:01Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8d4ecbc21967f40d1303b3731b92fe7b208ff42e",
          "message": "Remove timeouts on WaitForExit which can cause unexpected behavior.",
          "committedDate": "2021-02-02T08:43:56Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f14d6a229889132a96f65d91b27fb54bed9f31e6",
          "message": "TimeoutFailsEvenWhenExitCodeIsIgnored: on mono we expect 137 due to removing WaitForExit timeout",
          "committedDate": "2021-02-02T09:36:30Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "888068ab50dd37bb58f0bd23e5dfb59064bb7477",
          "message": "Add KillTree test",
          "committedDate": "2021-02-02T09:36:51Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "12d14e71e09e46559c5a80ee87faa9d6a25f433d",
          "message": "Log a warning when a node is killed",
          "committedDate": "2021-02-05T12:31:20Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "0ce5d234dfa29ca3ba03898f7ba03191c3c114d4",
          "message": "Add back timeouts",
          "committedDate": "2021-02-09T17:03:04Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f2722dfaa253fc5c4c7a10644caa8590da0526f6",
          "message": "Merge master.",
          "committedDate": "2021-02-09T20:51:34Z",
          "author": {
            "name": "Kirill Osenkov",
            "email": "github@osenkov.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f863718d8ced59aea68795b84479e93a076a29ff",
          "message": "Update exit packet tracking",
          "committedDate": "2021-02-11T14:08:32Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1b0177ce40e30b9187e156b91c30b00f7160fefb",
          "message": "Use resource string for logging kill",
          "committedDate": "2021-02-11T14:28:26Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6f67a094c58c5c3990692740fe557cd57ba605ff",
          "message": "TimeoutFailsEvenWhenExitCodeIsIgnored: add back STILL_ACTIVE",
          "committedDate": "2021-02-11T15:44:10Z",
          "author": {
            "name": "Tom Deseyn",
            "email": "tom.deseyn@gmail.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "[Deploy-MSBuild](https://github.com/dotnet/msbuild/blob/master/documentation/Deploy-MSBuild.md) with the Core note at the bottom.",
        "createdAt": "2021-01-21T16:15:18Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> Deploy-MSBuild with the Core note at the bottom.\r\n\r\n@Forgind @cdmihai I'm giving it a try and it is not working as expected yet. I'll be making some more changes.",
        "createdAt": "2021-01-25T15:33:33Z",
        "author": {
          "login": "tmds"
        }
      },
      {
        "body": "With these changes the scenario from https://github.com/microsoft/vstest/issues/2282#issuecomment-605665646 results in this behavior:\r\n```\r\nexecve(\"/tmp/dotnet-5.0/dotnet\", [\"dotnet\", \"test\"], 0x7ffe69586fa8 /* 62 vars */) = 0\r\n[pid 115692] execve(\"/tmp/dotnet-5.0/dotnet\", [\"dotnet\", \"exec\", \"/tmp/dotnet-5.0/sdk/5.0.102/MSBu\"..., \"-maxcpucount\", \"-verbosity:m\", \"-restore\", \"-target:VSTest\", \"-nodereuse:false\", \"-nologo\", \"-distributedlogger:Microsoft.Dot\"...], 0x7f2d08022e00 /* 67 vars */) = 0\r\n[pid 115716] execve(\"/tmp/dotnet-5.0/dotnet\", [\"/tmp/dotnet-5.0/dotnet\", \"/tmp/dotnet-5.0/sdk/5.0.102/MSBu\"..., \"/tmp/dotnet-5.0/sdk/5.0.102/MSBu\"..., \"/nologo\", \"/nodemode:1\", \"/nodeReuse:false\", \"/low:false\"], 0x7f1c28065ac0 /* 68 vars */) = 0\r\n[pid 115741] execve(\"/tmp/dotnet-5.0/dotnet\", [\"/tmp/dotnet-5.0/dotnet\", \"/tmp/dotnet-5.0/sdk/5.0.102/MSBu\"..., \"/tmp/dotnet-5.0/sdk/5.0.102/MSBu\"..., \"/nologo\", \"/nodemode:1\", \"/nodeReuse:false\", \"/low:false\"], 0x7f1bfc000f60 /* 68 vars */) = 0\r\n  Determining projects to restore...\r\n  All projects are up-to-date for restore.\r\n  Project2 -> /tmp/repro/TestTerminalIssues/Project2/bin/Debug/net5.0/Project2.dll\r\nTest run for /tmp/repro/TestTerminalIssues/Project2/bin/Debug/net5.0/Project2.dll (.NETCoreApp,Version=v5.0)\r\n[pid 115808] execve(\"/tmp/dotnet-5.0/dotnet\", [\"dotnet\", \"exec\", \"/tmp/dotnet-5.0/sdk/5.0.102/vste\"..., \"--testAdapterPath:/home/tmds/.nu\"..., \"--framework:.NETCoreApp,Version=\"..., \"/tmp/repro/TestTerminalIssues/Pr\"...], 0x7f8888003400 /* 67 vars */) = 0\r\n  Project1 -> /tmp/repro/TestTerminalIssues/Project1/bin/Debug/net5.0/Project1.dll\r\nTest run for /tmp/repro/TestTerminalIssues/Project1/bin/Debug/net5.0/Project1.dll (.NETCoreApp,Version=v5.0)\r\n[pid 115816] execve(\"/tmp/dotnet-5.0/dotnet\", [\"dotnet\", \"exec\", \"/tmp/dotnet-5.0/sdk/5.0.102/vste\"..., \"--testAdapterPath:/home/tmds/.nu\"..., \"--framework:.NETCoreApp,Version=\"..., \"/tmp/repro/TestTerminalIssues/Pr\"...], 0x7f1bc8001e40 /* 68 vars */) = 0\r\nMicrosoft (R) Test Execution Command Line Tool Version 16.8.3\r\nCopyright (c) Microsoft Corporation.  All rights reserved.\r\n\r\nMicrosoft (R) Test Execution Command Line Tool Version 16.8.3\r\nCopyright (c) Microsoft Corporation.  All rights reserved.\r\n\r\nStarting test execution, please wait...\r\nA total of 1 test files matched the specified pattern.\r\nStarting test execution, please wait...\r\nA total of 1 test files matched the specified pattern.\r\n[pid 115846] execve(\"/tmp/dotnet-5.0/dotnet\", [\"/tmp/dotnet-5.0/dotnet\", \"exec\", \"--runtimeconfig\", \"/tmp/repro/TestTerminalIssues/Pr\"..., \"--depsfile\", \"/tmp/repro/TestTerminalIssues/Pr\"..., \"/home/tmds/.nuget/packages/micro\"..., \"--port\", \"45027\", \"--endpoint\", \"127.0.0.1:045027\", \"--role\", \"client\", \"--parentprocessid\", \"115808\", \"--telemetryoptedin\", \"false\"], 0x7f5a4c0090f0 /* 67 vars */) = 0\r\n[pid 115850] execve(\"/tmp/dotnet-5.0/dotnet\", [\"/tmp/dotnet-5.0/dotnet\", \"exec\", \"--runtimeconfig\", \"/tmp/repro/TestTerminalIssues/Pr\"..., \"--depsfile\", \"/tmp/repro/TestTerminalIssues/Pr\"..., \"/home/tmds/.nuget/packages/micro\"..., \"--port\", \"44499\", \"--endpoint\", \"127.0.0.1:044499\", \"--role\", \"client\", \"--parentprocessid\", \"115816\", \"--telemetryoptedin\", \"false\"], 0x7fa7d8007f40 /* 68 vars */) = 0\r\n[pid 115841] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=115846, si_uid=1000, si_status=0, si_utime=126, si_stime=18} ---\r\n[pid 115835] wait4(115846, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 115846\r\n\r\nPassed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: 2 ms - /tmp/repro/TestTerminalIssues/Project2/bin/Debug/net5.0/Project2.dll (net5.0)\r\n[pid 115759] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=115808, si_uid=1000, si_status=0, si_utime=76, si_stime=14} ---\r\n[pid 115731] wait4(115808, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 115808\r\n[pid 115843] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=115850, si_uid=1000, si_status=0, si_utime=124, si_stime=23} ---\r\n[pid 115838] wait4(115850, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 115850\r\n\r\nPassed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: 5 ms - /tmp/repro/TestTerminalIssues/Project1/bin/Debug/net5.0/Project1.dll (net5.0)\r\n[pid 115769] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=115816, si_uid=1000, si_status=0, si_utime=86, si_stime=14} ---\r\n[pid 115701] wait4(115816, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 115816\r\n[pid 115705] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=115741, si_uid=1000, si_status=0, si_utime=182, si_stime=39} ---\r\n[pid 115701] wait4(115741, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 115741\r\n[pid 115705] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=115716, si_uid=1000, si_status=0, si_utime=293, si_stime=61} ---\r\n[pid 115701] wait4(115716, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 115716\r\n[pid 115672] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=115692, si_uid=1000, si_status=0, si_utime=377, si_stime=96} ---\r\n[pid 115691] wait4(115692, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 115692\r\n```\r\n\r\nNote that every process that gets started (`exec`) is explicitly waited for (`wait4`).\r\nThis PR makes it happen for the msbuild node processes: `115716`, `115741`.",
        "createdAt": "2021-01-26T08:38:00Z",
        "author": {
          "login": "tmds"
        }
      },
      {
        "body": "@tmds This might make the code more complicated, but can you please log a warning whenever a node has to be forcefully killed after the timeout? Nodes should terminate gracefully when sent the shutdown packet. A node not terminating when asked to is a failure, since the node should terminate running targets / tasks and exit. The warning should contain the node id and process id.\r\n\r\nA different approach is to not kill the node at all, but log an error including the node id and process id. Then, users can dump the node process and look at its call stacks. And hopefully open an issue on msbuild to get it fixed :)",
        "createdAt": "2021-01-28T19:57:33Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "Adding @dsplaisted as an expert on cross-node communication - this is a very tricky area so needs careful review. Things can break if you look at it too hard. And we need to think of Windows, MacOS and Linux.",
        "createdAt": "2021-01-31T00:09:10Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "We'll need to decide in which order we want to merge this vs. https://github.com/dotnet/msbuild/pull/6023, because after the first PR goes in the second PR will need some work to adapt and resolve conflicts and re-test. I'm OK to go in later if needed.",
        "createdAt": "2021-01-31T00:11:33Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "Team triage:\r\nWould you mind adding a unit test and a warning message when you're forced to kill a node?",
        "createdAt": "2021-02-01T16:16:12Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "> adding a unit test\r\n\r\nI've added a test.\r\n\r\n> and a warning message when you're forced to kill a node?\r\n\r\nHow do I get hold of a logger in `NodeProviderOutOfProcBase`?",
        "createdAt": "2021-02-02T09:37:40Z",
        "author": {
          "login": "tmds"
        }
      },
      {
        "body": "@KirillOsenkov I've removed timeouts on `WaitForExit` calls. These timeouts are not needed because the processes that are waited for are expected to terminate in a timely fashion. In case the processes take a bit longer and the timeout is triggered we end up in rare cases like the one causing https://github.com/dotnet/msbuild/issues/5506. By removing timeouts we avoid that.\r\n\r\nI can add back the timeouts if you consider them necessary on some paths.",
        "createdAt": "2021-02-02T09:43:36Z",
        "author": {
          "login": "tmds"
        }
      },
      {
        "body": "> How do I get hold of a logger in `NodeProviderOutOfProcBase`?\r\n\r\nI'd probably count this as related to communication, so I'd use CommunicationsUtilities.Trace. It won't show up in the normal log, but it would show up if you turn on comm traces. It won't show up as an actual warning, but I'm not sure how to do that from here.",
        "createdAt": "2021-02-02T16:28:36Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "Hi @tmds apologies that my PR came in first.\r\n\r\nI have created a merge PR for your PR that merges it with latest master, to help solve the conflict in NodeProviderOutOfProcBase.cs:\r\nhttps://github.com/tmds/msbuild/pull/1\r\n\r\nHope it helps.",
        "createdAt": "2021-02-09T21:04:34Z",
        "author": {
          "login": "KirillOsenkov"
        }
      },
      {
        "body": "@Forgind @KirillOsenkov ptal at the recent changes.",
        "createdAt": "2021-02-11T17:08:18Z",
        "author": {
          "login": "tmds"
        }
      },
      {
        "body": "I wanted to verify this once more using the deploy script, but it is no longer working for me.\r\n\r\nMy patched sdk crashes with:\r\n```\r\nMSBUILD : error MSB1025: An internal failure occurred while running MSBuild.\r\nSystem.IO.FileNotFoundException: Could not load file or assembly 'Microsoft.NET.StringTools, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.\r\n```\r\n\r\nI see there is a `./sdk/5.0.102/Microsoft.NET.StringTools.dll` file in the SDK. I don't know why it is not found.",
        "createdAt": "2021-02-12T14:52:33Z",
        "author": {
          "login": "tmds"
        }
      },
      {
        "body": "We hit that internally, too. Our deploy-msbuild copies files over but for .NET Core, dependencies have to be listed in MSBuild.deps.json as well. If you're patching a an older SDK without StringTools this dependency is missing and runtime is not even trying to find the assembly.\r\n\r\nI put an updated MSBuild.deps.json below.\r\n\r\n(Credit to ladipro and rokonec)\r\n\r\n[MSBuild.deps.zip](https://github.com/dotnet/msbuild/files/5972797/MSBuild.deps.zip)",
        "createdAt": "2021-02-12T15:43:38Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "@Forgind thanks. I'm not sure if I did something wrong, but I still got an exception. I managed to get past it by using another SDK at that step. `dotnet test` ran without issue on my patched SDK and gave this trace:\r\n\r\n```\r\n[pid 18247] execve(\"/tmp/dotnet-5/dotnet\", [\"dotnet\", \"exec\", \"/tmp/dotnet-5/sdk/5.0.102/MSBuil\"..., \"-maxcpucount\", \"-verbosity:m\", \"-restore\", \"-target:VSTest\", \"-nodereuse:false\", \"-nologo\", \"-distributedlogger:Microsoft.Dot\"...], 0x5616103eee80 /* 65 vars */) = 0\r\n[pid 18272] execve(\"/tmp/dotnet-5/dotnet\", [\"/tmp/dotnet-5/dotnet\", \"/tmp/dotnet-5/sdk/5.0.102/MSBuil\"..., \"/tmp/dotnet-5/sdk/5.0.102/MSBuil\"..., \"/nologo\", \"/nodemode:1\", \"/nodeReuse:false\", \"/low:false\"], 0x7f6334066cc0 /* 66 vars */) = 0\r\n[pid 18291] execve(\"/tmp/dotnet-5/dotnet\", [\"/tmp/dotnet-5/dotnet\", \"/tmp/dotnet-5/sdk/5.0.102/MSBuil\"..., \"/tmp/dotnet-5/sdk/5.0.102/MSBuil\"..., \"/nologo\", \"/nodemode:1\", \"/nodeReuse:false\", \"/low:false\"], 0x7f6334066cc0 /* 66 vars */) = 0\r\n[pid 18351] execve(\"/tmp/dotnet-5/dotnet\", [\"dotnet\", \"exec\", \"/tmp/dotnet-5/sdk/5.0.102/vstest\"..., \"--testAdapterPath:/home/tmds/.nu\"..., \"--framework:.NETCoreApp,Version=\"..., \"/tmp/TestTerminalIssues/Project1\"...], 0x7f62f4009740 /* 66 vars */) = 0\r\n[pid 18353] execve(\"/tmp/dotnet-5/dotnet\", [\"dotnet\", \"exec\", \"/tmp/dotnet-5/sdk/5.0.102/vstest\"..., \"--testAdapterPath:/home/tmds/.nu\"..., \"--framework:.NETCoreApp,Version=\"..., \"/tmp/TestTerminalIssues/Project2\"...], 0x5574b0bc9d30 /* 65 vars */) = 0\r\n[pid 18384] execve(\"/tmp/dotnet-5/dotnet\", [\"/tmp/dotnet-5/dotnet\", \"exec\", \"--runtimeconfig\", \"/tmp/TestTerminalIssues/Project2\"..., \"--depsfile\", \"/tmp/TestTerminalIssues/Project2\"..., \"/home/tmds/.nuget/packages/micro\"..., \"--port\", \"40365\", \"--endpoint\", \"127.0.0.1:040365\", \"--role\", \"client\", \"--parentprocessid\", \"18353\", \"--telemetryoptedin\", \"false\"], 0x7fadcc0069e0 /* 65 vars */) = 0\r\n[pid 18390] execve(\"/tmp/dotnet-5/dotnet\", [\"/tmp/dotnet-5/dotnet\", \"exec\", \"--runtimeconfig\", \"/tmp/TestTerminalIssues/Project1\"..., \"--depsfile\", \"/tmp/TestTerminalIssues/Project1\"..., \"/home/tmds/.nuget/packages/micro\"..., \"--port\", \"41041\", \"--endpoint\", \"127.0.0.1:041041\", \"--role\", \"client\", \"--parentprocessid\", \"18351\", \"--telemetryoptedin\", \"false\"], 0x7fc310006890 /* 66 vars */) = 0\r\n[pid 18370] wait4(18390, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 18390\r\n[pid 18371] wait4(18384, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 18384\r\n[pid 18260] wait4(18351, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 18351\r\n[pid 18287] wait4(18353, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 18353\r\n[pid 18260] wait4(18291, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 18291\r\n[pid 18260] wait4(18272, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 18272\r\n[pid 18246] wait4(18247, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 18247\r\n```\r\nAs shown in the trace: every process that gets started (`execve`) gets waited for (`wait4`).",
        "createdAt": "2021-02-15T14:41:20Z",
        "author": {
          "login": "tmds"
        }
      },
      {
        "body": "Sounds good! We'll merge this pretty soon.",
        "createdAt": "2021-02-19T00:18:39Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "I definitely like the idea of an escape hatch, but do you think a [change wave](https://github.com/dotnet/msbuild/blob/master/documentation/wiki/ChangeWaves.md) might be better?",
              "createdAt": "2021-01-21T16:56:10Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I haven't added an EscapeHatch, but I'm reusing an existing one.\r\n\r\n`EnsureStdOutForChildNodesIsPrimaryStdout` captures a node is 'interactive', that means the user will consume its output on the terminal and can provide console input.",
              "createdAt": "2021-01-25T08:27:25Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;",
              "author": {
                "login": "tmds"
              }
            },
            {
              "body": "Neat! I wasn't aware of that one. Thanks!",
              "createdAt": "2021-01-25T15:44:22Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why does input redirection matter?",
              "createdAt": "2021-01-21T16:56:41Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "When the streams are redirected, the application can not change terminal settings.\r\n\r\n.NET uses stdin to know if it can change terminal settings:\r\n\r\nhttps://github.com/dotnet/runtime/blob/2f1def8c556403ca85d1de50609492fef664b638/src/libraries/Native/Unix/System.Native/pal_console.c#L455",
              "createdAt": "2021-01-25T08:30:49Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems like it's waiting for each child process individually before telling the next one to shut down. Could we send all the shut down messages, then wait for them all instead?",
              "createdAt": "2021-01-21T17:00:28Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)\n+                {\n+                    nodeContext.WaitForExit();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Good point, this should be concurrent.\r\nIn addition, the RPS tests for VS shutdown times might get triggered by this, even when concurrent. Nodes should be waited only when MSBuild is run from the cmdline. Couple of ways to detect this:\r\n- `AssemblyUtilities.EntryAssembly` is MSBuild.{exe, dll}. Hopefully it doesn't appear as dotnet on .net core :). If you go down this path might as well add a new `bool BuildEnvironmentHelper.IsRunningInCommandLine` (also tests)\r\n- Don't wait when `BuildEnvironment.RunningInVisualStudio == true`. But this will ignore any other process that's using the BuildManager APIs to build.\r\n\r\nSadly I can't think of a straightforward way to test this.",
              "createdAt": "2021-01-22T01:22:34Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)\n+                {\n+                    nodeContext.WaitForExit();",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "> Nodes should be waited only when MSBuild is run from the cmdline. \r\n\r\nI think the `!Console.IsInputRedirected` may be covering this requirement?",
              "createdAt": "2021-01-25T08:32:08Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)\n+                {\n+                    nodeContext.WaitForExit();",
              "author": {
                "login": "tmds"
              }
            },
            {
              "body": "> Could we send all the shut down messages, then wait for them all instead?\r\n\r\nI've changed it to concurrent waits.",
              "createdAt": "2021-01-25T13:53:16Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)\n+                {\n+                    nodeContext.WaitForExit();",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just because there can be unanticipated errors, I'd feel much more comfortable if this had a timeout.",
              "createdAt": "2021-01-21T17:01:17Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -802,6 +817,30 @@ public void Close()\n                 _terminateDelegate(_nodeId);\n             }\n \n+            /// <summary>\n+            /// Waits for the child node process to exit.\n+            /// </summary>\n+            public void WaitForExit()\n+            {\n+                int processId = _processId;\n+                if (processId != -1)\n+                {\n+                    Process childProcess;\n+                    try\n+                    {\n+                        childProcess = Process.GetProcessById(processId);\n+                    }\n+                    catch (System.ArgumentException)\n+                    {\n+                        // The process has terminated already.\n+                        return;\n+                    }\n+                    // Wait for the process to terminate.\n+                    CommunicationsUtilities.Trace(\"Waiting for node with pid = {0} to terminate\", processId);\n+                    childProcess.WaitForExit();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I've added a timeout. Followed by a Kill + blocking wait.",
              "createdAt": "2021-01-25T13:46:23Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -802,6 +817,30 @@ public void Close()\n                 _terminateDelegate(_nodeId);\n             }\n \n+            /// <summary>\n+            /// Waits for the child node process to exit.\n+            /// </summary>\n+            public void WaitForExit()\n+            {\n+                int processId = _processId;\n+                if (processId != -1)\n+                {\n+                    Process childProcess;\n+                    try\n+                    {\n+                        childProcess = Process.GetProcessById(processId);\n+                    }\n+                    catch (System.ArgumentException)\n+                    {\n+                        // The process has terminated already.\n+                        return;\n+                    }\n+                    // Wait for the process to terminate.\n+                    CommunicationsUtilities.Trace(\"Waiting for node with pid = {0} to terminate\", processId);\n+                    childProcess.WaitForExit();",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think you have to add a `bool waitForExit` parameter to the method. I looked at the callers of this method and some expect this to be async:\r\n\r\n![image](https://user-images.githubusercontent.com/2255729/105433550-ab68c600-5c0e-11eb-8e3e-83695f5505b7.png)\r\n",
              "createdAt": "2021-01-22T01:33:09Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "ShutdownConnectedNodesAsync doesn't seem to have the async keyword. Am I missing something?",
              "createdAt": "2021-01-22T01:36:52Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I think it's from before C# had async / await, so its meaning is more like `ShutdownConnectedNodesWithoutWaiting`.",
              "createdAt": "2021-01-22T19:45:04Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "I think in case of `ShutdownConnectedNodesAsync(bool abort)` with `abort:true` we may want to `Kill` the children, and still `WaitForExit`. Does that make sense?",
              "createdAt": "2021-01-25T08:42:43Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)",
              "author": {
                "login": "tmds"
              }
            },
            {
              "body": "I've added some of the `Kill` logic into the `WaitForExitAsync` method, and a timeout.\r\n\r\nI haven't added an extra parameter to the method to indicate the timeout should be skipped and the node should be killed immediately. Do you think it is still needed?",
              "createdAt": "2021-01-25T13:51:59Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)",
              "author": {
                "login": "tmds"
              }
            },
            {
              "body": "Regarding `ShutdownConnectedNodesAsync`, the method name becomes misleading if nodes are now waited. At the least remove `Async` from the method name. Though I do worry that it might trigger RPS tests around VS shutdown time. @Forgind could you please trigger an RPS run for the PR?",
              "createdAt": "2021-01-28T02:38:26Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +96,23 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think rainersigwald told me it was bad to kill child processes explicitly because it left our logging incomplete and could leave VS in a bad state when starting up again. The latter doesn't matter for command line builds, clearly.\r\n\r\nAlso, if we're planning to kill it explicitly, NativeMethodsShared.KillTree does that.",
              "createdAt": "2021-01-25T16:20:45Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -802,6 +828,56 @@ public void Close()\n                 _terminateDelegate(_nodeId);\n             }\n \n+            /// <summary>\n+            /// Waits for the child node process to exit.\n+            /// </summary>\n+            public async Task WaitForExitAsync()\n+            {\n+                int processId = _processId;\n+                if (processId != -1)\n+                {\n+                    Process childProcess;\n+                    try\n+                    {\n+                        childProcess = Process.GetProcessById(processId);\n+                    }\n+                    catch (System.ArgumentException)\n+                    {\n+                        // The process has terminated already.\n+                        return;\n+                    }\n+\n+                    // Wait for the process to terminate.\n+                    CommunicationsUtilities.Trace(\"Waiting for node with pid = {0} to terminate\", processId);\n+\n+                    if (_closeSent)\n+                    {\n+                        // .NET 5 introduces a real WaitForExitAsyc.\n+                        // This is a poor man's implementation that uses polling.\n+                        int timeout = TimeoutForWaitForExit;\n+                        int delay = 5;\n+                        while (timeout > 0)\n+                        {\n+                            bool exited = childProcess.WaitForExit(milliseconds: 0);\n+                            if (exited)\n+                            {\n+                                return;\n+                            }\n+                            timeout -= delay;\n+                            await Task.Delay(delay).ConfigureAwait(false);\n+\n+                            // Double delay up to 500ms.\n+                            delay = Math.Min(delay * 2, 500);\n+                        }\n+                    }\n+\n+                    // Kill the child and do a blocking wait.\n+                    CommunicationsUtilities.Trace(\"Killing node with pid = {0}\", processId);\n+                    childProcess.Kill();",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "tiny nit:\r\n```suggestion\r\n            Task[] waitForExitTasks = waitForExit && contextsToShutDown.Count > 0 ? new Task[contextsToShutDown.Count] : null;\r\n```",
              "createdAt": "2021-01-25T16:21:20Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +101,29 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n+            Task[] waitForExitTasks = waitForExit && contextsToShutDown.Count > 0? new Task[contextsToShutDown.Count] : null;",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you think this this is the right timeout? Node creation takes longer than exiting, I would have thought.",
              "createdAt": "2021-01-25T16:22:32Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -50,6 +50,11 @@ internal abstract class NodeProviderOutOfProcBase\n         /// </summary>\n         private const int TimeoutForNewNodeCreation = 30000;\n \n+        /// <summary>\n+        /// The amount of time to wait for an out-of-proc node to exit.\n+        /// </summary>\n+        private const int TimeoutForWaitForExit = 30000;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "It depends if we expect it to be common for nodes to fail to shut down when asked to.\r\nIf we think in the common case they should be able to shut down, we can keep the long timeout.\r\nIf in the common case they won't shut down when asked to and we don't care about the reason, we can use a lower timeout.",
              "createdAt": "2021-01-26T08:30:49Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -50,6 +50,11 @@ internal abstract class NodeProviderOutOfProcBase\n         /// </summary>\n         private const int TimeoutForNewNodeCreation = 30000;\n \n+        /// <summary>\n+        /// The amount of time to wait for an out-of-proc node to exit.\n+        /// </summary>\n+        private const int TimeoutForWaitForExit = 30000;",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Ugh, this is terrible. The capitalization is different for netcoreapp and net framework. I'm not a powershell expert, but could you make it copy this file if Core and the other one if not?",
              "createdAt": "2021-01-25T16:27:06Z",
              "path": "scripts/Deploy-MSBuild.ps1",
              "diffHunk": "@@ -73,11 +73,11 @@ $filesToCopyToBin = @(\n     FileToCopy \"$bootstrapBinDirectory\\Microsoft.Managed.targets\"\n     FileToCopy \"$bootstrapBinDirectory\\Microsoft.Managed.Before.targets\"\n     FileToCopy \"$bootstrapBinDirectory\\Microsoft.Managed.After.targets\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.Net.props\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.CurrentVersion.props\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.CurrentVersion.targets\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.props\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.targets\"\n+    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NET.props\"",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "The change is needed because Linux file systems are case sensitive.\r\nWindows filesystems are case insensitive. So this should continue to work on Windows as before.",
              "createdAt": "2021-01-26T08:29:11Z",
              "path": "scripts/Deploy-MSBuild.ps1",
              "diffHunk": "@@ -73,11 +73,11 @@ $filesToCopyToBin = @(\n     FileToCopy \"$bootstrapBinDirectory\\Microsoft.Managed.targets\"\n     FileToCopy \"$bootstrapBinDirectory\\Microsoft.Managed.Before.targets\"\n     FileToCopy \"$bootstrapBinDirectory\\Microsoft.Managed.After.targets\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.Net.props\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.CurrentVersion.props\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.CurrentVersion.targets\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.props\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.targets\"\n+    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NET.props\"",
              "author": {
                "login": "tmds"
              }
            },
            {
              "body": "Right, but it won't necessarily work on macOS mono because that will look in the net framework package.",
              "createdAt": "2021-01-26T15:24:08Z",
              "path": "scripts/Deploy-MSBuild.ps1",
              "diffHunk": "@@ -73,11 +73,11 @@ $filesToCopyToBin = @(\n     FileToCopy \"$bootstrapBinDirectory\\Microsoft.Managed.targets\"\n     FileToCopy \"$bootstrapBinDirectory\\Microsoft.Managed.Before.targets\"\n     FileToCopy \"$bootstrapBinDirectory\\Microsoft.Managed.After.targets\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.Net.props\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.CurrentVersion.props\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.CurrentVersion.targets\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.props\"\n-    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NetFramework.targets\"\n+    FileToCopy \"$bootstrapBinDirectory\\Microsoft.NET.props\"",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why does this need to be public?",
              "createdAt": "2021-01-26T15:46:45Z",
              "path": "src/Utilities/ProcessExtensions.cs",
              "diffHunk": "@@ -9,7 +9,7 @@\n \n namespace Microsoft.Build.Utilities\n {\n-    internal static class ProcessExtensions\n+    public static class ProcessExtensions",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yea, leave it internal and move to shared. The scope of the PR does not warrant increase public API surface.",
              "createdAt": "2021-01-28T02:04:36Z",
              "path": "src/Utilities/ProcessExtensions.cs",
              "diffHunk": "@@ -9,7 +9,7 @@\n \n namespace Microsoft.Build.Utilities\n {\n-    internal static class ProcessExtensions\n+    public static class ProcessExtensions",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "> Please read \"Shared Code.doc\" for guidelines on using shared code in MSBuild.\r\n\r\nMaybe make this an `.md` file?\r\n\r\nShared Code.doc:\r\n\r\n```\r\nMicrosoft Confidential\r\n```\r\n\r\n`/me` stops reading.\r\n\r\ncc @omajid, maybe we care about this for source-build.",
              "createdAt": "2021-01-28T07:43:25Z",
              "path": "src/Utilities/ProcessExtensions.cs",
              "diffHunk": "@@ -9,7 +9,7 @@\n \n namespace Microsoft.Build.Utilities\n {\n-    internal static class ProcessExtensions\n+    public static class ProcessExtensions",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'd prefer to move the process extensions to shared.",
              "createdAt": "2021-01-26T15:50:33Z",
              "path": "src/Build/Microsoft.Build.csproj",
              "diffHunk": "@@ -29,6 +29,7 @@\n   <ItemGroup>\n     <ProjectReference Include=\"..\\Framework\\Microsoft.Build.Framework.csproj\" />\n     <ProjectReference Include=\"..\\StringTools\\StringTools.csproj\" />\n+    <ProjectReference Include=\"..\\Utilities\\Microsoft.Build.Utilities.csproj\" />",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "private?",
              "createdAt": "2021-01-26T15:51:23Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -802,6 +829,40 @@ public void Close()\n                 _terminateDelegate(_nodeId);\n             }\n \n+            /// <summary>\n+            /// Waits for the child node process to exit.\n+            /// </summary>\n+            public async Task WaitForExitAsync()",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Still a little uncomfortable with this, but we'll see what others say.",
              "createdAt": "2021-01-28T01:12:59Z",
              "path": "src/Utilities/ProcessExtensions.cs",
              "diffHunk": "@@ -77,10 +77,16 @@ private static void GetAllChildIdsUnix(int parentId, ISet<int> children)\n \n         private static void KillProcessUnix(int processId)\n         {\n-            RunProcessAndWaitForExit(\n-                \"kill\",\n-                $\"-TERM {processId}\",\n-                out string _);\n+            try\n+            {\n+                using Process process = Process.GetProcessById(processId);\n+                process.Kill();",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "If you ask the kernel to kill one of your child processes, it should be able to do that. There are no expected cases where this won't work.",
              "createdAt": "2021-01-28T08:01:35Z",
              "path": "src/Utilities/ProcessExtensions.cs",
              "diffHunk": "@@ -77,10 +77,16 @@ private static void GetAllChildIdsUnix(int parentId, ISet<int> children)\n \n         private static void KillProcessUnix(int processId)\n         {\n-            RunProcessAndWaitForExit(\n-                \"kill\",\n-                $\"-TERM {processId}\",\n-                out string _);\n+            try\n+            {\n+                using Process process = Process.GetProcessById(processId);\n+                process.Kill();",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: use a List<Task> instead to avoid doing array index arithmetic. Not that hot of a path to warrant it.",
              "createdAt": "2021-01-28T02:12:58Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +103,29 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n+            Task[] waitForExitTasks = waitForExit && contextsToShutDown.Count > 0 ? new Task[contextsToShutDown.Count] : null;\n+            int i = 0;\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)\n+                {\n+                    waitForExitTasks[i++] = nodeContext.WaitForExitAsync();",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Ah, Task.WaitAll only takes in arrays ...",
              "createdAt": "2021-01-28T02:15:15Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -96,9 +103,29 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool\n             // Send the build completion message to the nodes, causing them to shutdown or reset.\n             _processesToIgnore.Clear();\n \n+            // We wait for child nodes to exit to avoid them changing the terminal\n+            // after this process terminates.\n+            bool waitForExit =  !enableReuse &&\n+                                !Console.IsInputRedirected &&\n+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;\n+\n+            Task[] waitForExitTasks = waitForExit && contextsToShutDown.Count > 0 ? new Task[contextsToShutDown.Count] : null;\n+            int i = 0;\n             foreach (NodeContext nodeContext in contextsToShutDown)\n             {\n-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));\n+                if (nodeContext is null)\n+                {\n+                    continue;\n+                }\n+                nodeContext.SendData(new NodeBuildComplete(enableReuse));\n+                if (waitForExit)\n+                {\n+                    waitForExitTasks[i++] = nodeContext.WaitForExitAsync();",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think it's InvalidOperationException not ArgumentException: [https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.kill?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.kill?view=netframework-4.8)",
              "createdAt": "2021-01-28T02:21:23Z",
              "path": "src/Utilities/ProcessExtensions.cs",
              "diffHunk": "@@ -77,10 +77,16 @@ private static void GetAllChildIdsUnix(int parentId, ISet<int> children)\n \n         private static void KillProcessUnix(int processId)\n         {\n-            RunProcessAndWaitForExit(\n-                \"kill\",\n-                $\"-TERM {processId}\",\n-                out string _);\n+            try\n+            {\n+                using Process process = Process.GetProcessById(processId);\n+                process.Kill();\n+            }\n+            catch (ArgumentException)",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "It's both. `GetProcessById` throws `ArgumentException` and `Kill` throws `InvalidOperationException`.\r\n\r\nFrom .NET Core 3 onward, `Kill` no longer throws `InvalidOperationException` when the process has already exited.",
              "createdAt": "2021-01-28T07:51:57Z",
              "path": "src/Utilities/ProcessExtensions.cs",
              "diffHunk": "@@ -77,10 +77,16 @@ private static void GetAllChildIdsUnix(int parentId, ISet<int> children)\n \n         private static void KillProcessUnix(int processId)\n         {\n-            RunProcessAndWaitForExit(\n-                \"kill\",\n-                $\"-TERM {processId}\",\n-                out string _);\n+            try\n+            {\n+                using Process process = Process.GetProcessById(processId);\n+                process.Kill();\n+            }\n+            catch (ArgumentException)",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@cdmihai this message is printed when the node is killed forcefully. I think this addresses your request in https://github.com/dotnet/msbuild/pull/6053#issuecomment-769340348?",
              "createdAt": "2021-01-29T07:54:02Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -802,6 +829,40 @@ public void Close()\n                 _terminateDelegate(_nodeId);\n             }\n \n+            /// <summary>\n+            /// Waits for the child node process to exit.\n+            /// </summary>\n+            public async Task WaitForExitAsync()\n+            {\n+                // Wait for the process to exit.\n+                if (_isExiting)\n+                {\n+                    CommunicationsUtilities.Trace(\"Waiting for node with pid = {0} to exit\", _process.Id);\n+\n+                    // .NET 5 introduces a real WaitForExitAsyc.\n+                    // This is a poor man's implementation that uses polling.\n+                    int timeout = TimeoutForWaitForExit;\n+                    int delay = 5;\n+                    while (timeout > 0)\n+                    {\n+                        bool exited = _process.WaitForExit(milliseconds: 0);\n+                        if (exited)\n+                        {\n+                            return;\n+                        }\n+                        timeout -= delay;\n+                        await Task.Delay(delay).ConfigureAwait(false);\n+\n+                        // Double delay up to 500ms.\n+                        delay = Math.Min(delay * 2, 500);\n+                    }\n+                }\n+\n+                // Kill the child and do a blocking wait.\n+                CommunicationsUtilities.Trace(\"Killing node with pid = {0}\", _process.Id);",
              "author": {
                "login": "tmds"
              }
            },
            {
              "body": "The node communication tracing logs are pretty obscure and I doubt many users know about them. I was thinking that a LoggingService based warning that actually pops up in the terminal would make the event visible to users so they can investigate or open issues against MSBuild. I find this is the appropriate level of visibility since I think nonresponsive nodes is buggy behaviour on either MSBuild's or the task's part (if there's a long running task that cannot be preempted). I could also be wrong about this requirement (it's not like anyone documented these requirements, who does that? :P). We'll discuss this at our next PR review meeting this Monday and let you know.",
              "createdAt": "2021-01-29T16:54:40Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -802,6 +829,40 @@ public void Close()\n                 _terminateDelegate(_nodeId);\n             }\n \n+            /// <summary>\n+            /// Waits for the child node process to exit.\n+            /// </summary>\n+            public async Task WaitForExitAsync()\n+            {\n+                // Wait for the process to exit.\n+                if (_isExiting)\n+                {\n+                    CommunicationsUtilities.Trace(\"Waiting for node with pid = {0} to exit\", _process.Id);\n+\n+                    // .NET 5 introduces a real WaitForExitAsyc.\n+                    // This is a poor man's implementation that uses polling.\n+                    int timeout = TimeoutForWaitForExit;\n+                    int delay = 5;\n+                    while (timeout > 0)\n+                    {\n+                        bool exited = _process.WaitForExit(milliseconds: 0);\n+                        if (exited)\n+                        {\n+                            return;\n+                        }\n+                        timeout -= delay;\n+                        await Task.Delay(delay).ConfigureAwait(false);\n+\n+                        // Double delay up to 500ms.\n+                        delay = Math.Min(delay * 2, 500);\n+                    }\n+                }\n+\n+                // Kill the child and do a blocking wait.\n+                CommunicationsUtilities.Trace(\"Killing node with pid = {0}\", _process.Id);",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "will this break Mac?",
              "createdAt": "2021-01-30T23:56:01Z",
              "path": "src/Tasks.UnitTests/Exec_Tests.cs",
              "diffHunk": "@@ -103,8 +103,8 @@ public void ExitCodeCausesFailure()\n         [Fact]\n         public void Timeout()\n         {\n-            // On non-Windows the exit code of a killed process is SIGTERM (143)\n-            int expectedExitCode = NativeMethodsShared.IsWindows ? -1 : 143;\n+            // On non-Windows the exit code of a killed process is SIGKILL (137)\n+            int expectedExitCode = NativeMethodsShared.IsWindows ? -1 : 137;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "This works on Mac also. By convention exit code when terminated by signal are calculated as `128 + signo`.\r\nThe signal number for `SIGKILL` is `9` on any OS I know.\r\nOtherwise these guys need to update their lyrics: https://www.youtube.com/watch?v=Fow7iUaKrq4 :smile:.",
              "createdAt": "2021-02-02T08:20:12Z",
              "path": "src/Tasks.UnitTests/Exec_Tests.cs",
              "diffHunk": "@@ -103,8 +103,8 @@ public void ExitCodeCausesFailure()\n         [Fact]\n         public void Timeout()\n         {\n-            // On non-Windows the exit code of a killed process is SIGTERM (143)\n-            int expectedExitCode = NativeMethodsShared.IsWindows ? -1 : 143;\n+            // On non-Windows the exit code of a killed process is SIGKILL (137)\n+            int expectedExitCode = NativeMethodsShared.IsWindows ? -1 : 137;",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Could you please see in https://github.com/dotnet/msbuild/issues/5506 if you have any insights about that?",
              "createdAt": "2021-01-30T23:57:01Z",
              "path": "src/Tasks.UnitTests/Exec_Tests.cs",
              "diffHunk": "@@ -141,13 +141,13 @@ public void TimeoutFailsEvenWhenExitCodeIsIgnored()\n                 // The standard check for SIGTERM fails intermittently on macOS Mono\n                 // https://github.com/dotnet/msbuild/issues/5506\n                 // To avoid test flakiness, allow 259 even though I can't justify it.\n-                exec.ExitCode.ShouldBeOneOf(143, 259);\n+                exec.ExitCode.ShouldBeOneOf(137, 259);",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "I've removed the timeout on `WaitForExit` which caused this test to fail (https://github.com/dotnet/msbuild/issues/5506#issuecomment-770654527) and updated the test accordingly.",
              "createdAt": "2021-02-02T09:40:03Z",
              "path": "src/Tasks.UnitTests/Exec_Tests.cs",
              "diffHunk": "@@ -141,13 +141,13 @@ public void TimeoutFailsEvenWhenExitCodeIsIgnored()\n                 // The standard check for SIGTERM fails intermittently on macOS Mono\n                 // https://github.com/dotnet/msbuild/issues/5506\n                 // To avoid test flakiness, allow 259 even though I can't justify it.\n-                exec.ExitCode.ShouldBeOneOf(143, 259);\n+                exec.ExitCode.ShouldBeOneOf(137, 259);",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just as an FYI, this will conflict with another PR: \r\nhttps://github.com/dotnet/msbuild/pull/6023/files#diff-f0e57cbf17e0f7fb207f255deb11445afccbb5c7bf0499a24b8065ff057fcdf3L764\r\n\r\nI'm happy to resolve conflicts if needed in either PR (depending on whichever one goes first).",
              "createdAt": "2021-01-30T23:59:16Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -761,7 +787,7 @@ public void SendData(INodePacket packet)\n #else\n                             _serverToClientStream.WriteAsync(writeStreamBuffer, i, lengthToWrite);\n #endif\n-                            return;\n+                            break;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Also keep in mind @tmds that the logic in SendData here is as follows: for large packets, we break them up in 1 MB chunks, and we write all chunks synchronously, except for the last one. The last chunk is fire-and-forget (the WriteAsync starts the write and returns). For small packets (the vast majority), the write is async and we never wait for the write to finish. In fact we see cases where the next invocation comes in and issues another write before the previous write has finished. We're just getting lucky that the framework seems to be good at serializing this. \r\n\r\nIn my PR https://github.com/dotnet/msbuild/pull/6023 I optimize memory allocations, which required to make all the writes synchronous (so we can reuse the byte array buffer that we pass to Write). To compensate for that, we made the entire SendData method fire-and-forget. \r\n\r\nI haven't look into this PR deeply enough to decide whether one needs to await writing packets to the socket connected to the node process before any shutdown/killing happens. Before my PR 6023 it would be a bit harder to await each async write before killing or shutting down. After my PR you can just await the `_packetWriteDrainTask` here: https://github.com/dotnet/msbuild/pull/6023/files#diff-f0e57cbf17e0f7fb207f255deb11445afccbb5c7bf0499a24b8065ff057fcdf3R774 But again, I'm not sure if blocking or awaiting here is needed or not. Can we be in a situation where we still have outstanding packet writes to the node and the node dies? Do we need a try/catch somewhere?",
              "createdAt": "2021-01-31T00:08:10Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -761,7 +787,7 @@ public void SendData(INodePacket packet)\n #else\n                             _serverToClientStream.WriteAsync(writeStreamBuffer, i, lengthToWrite);\n #endif\n-                            return;\n+                            break;",
              "author": {
                "login": "KirillOsenkov"
              }
            },
            {
              "body": "Right, we shouldn't set `_isExiting` when we were unable to flush all pending data.\r\nIf we get to that point, we assume the node will act on our request to terminate.\r\nAnd if it doesn't we'll end up waiting `TimeoutForWaitForExit`.\r\n\r\nLet's look at how this needs to be changed after https://github.com/dotnet/msbuild/pull/6023 is merged.",
              "createdAt": "2021-02-02T08:27:30Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -761,7 +787,7 @@ public void SendData(INodePacket packet)\n #else\n                             _serverToClientStream.WriteAsync(writeStreamBuffer, i, lengthToWrite);\n #endif\n-                            return;\n+                            break;",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@Forgind I think this takes care of https://github.com/dotnet/msbuild/pull/6053#issuecomment-771762934?",
              "createdAt": "2021-02-03T15:29:07Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -802,6 +829,40 @@ public void Close()\n                 _terminateDelegate(_nodeId);\n             }\n \n+            /// <summary>\n+            /// Waits for the child node process to exit.\n+            /// </summary>\n+            public async Task WaitForExitAsync()\n+            {\n+                // Wait for the process to exit.\n+                if (_isExiting)\n+                {\n+                    CommunicationsUtilities.Trace(\"Waiting for node with pid = {0} to exit\", _process.Id);\n+\n+                    // .NET 5 introduces a real WaitForExitAsyc.\n+                    // This is a poor man's implementation that uses polling.\n+                    int timeout = TimeoutForWaitForExit;\n+                    int delay = 5;\n+                    while (timeout > 0)\n+                    {\n+                        bool exited = _process.WaitForExit(milliseconds: 0);\n+                        if (exited)\n+                        {\n+                            return;\n+                        }\n+                        timeout -= delay;\n+                        await Task.Delay(delay).ConfigureAwait(false);\n+\n+                        // Double delay up to 500ms.\n+                        delay = Math.Min(delay * 2, 500);\n+                    }\n+                }\n+\n+                // Kill the child and do a blocking wait.\n+                CommunicationsUtilities.Trace(\"Killing node with pid = {0}\", _process.Id);",
              "author": {
                "login": "tmds"
              }
            },
            {
              "body": "@cdmihai commented (https://github.com/dotnet/msbuild/pull/6053/files#r566958454) we may want to do something with higher visibility?",
              "createdAt": "2021-02-03T15:30:40Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -802,6 +829,40 @@ public void Close()\n                 _terminateDelegate(_nodeId);\n             }\n \n+            /// <summary>\n+            /// Waits for the child node process to exit.\n+            /// </summary>\n+            public async Task WaitForExitAsync()\n+            {\n+                // Wait for the process to exit.\n+                if (_isExiting)\n+                {\n+                    CommunicationsUtilities.Trace(\"Waiting for node with pid = {0} to exit\", _process.Id);\n+\n+                    // .NET 5 introduces a real WaitForExitAsyc.\n+                    // This is a poor man's implementation that uses polling.\n+                    int timeout = TimeoutForWaitForExit;\n+                    int delay = 5;\n+                    while (timeout > 0)\n+                    {\n+                        bool exited = _process.WaitForExit(milliseconds: 0);\n+                        if (exited)\n+                        {\n+                            return;\n+                        }\n+                        timeout -= delay;\n+                        await Task.Delay(delay).ConfigureAwait(false);\n+\n+                        // Double delay up to 500ms.\n+                        delay = Math.Min(delay * 2, 500);\n+                    }\n+                }\n+\n+                // Kill the child and do a blocking wait.\n+                CommunicationsUtilities.Trace(\"Killing node with pid = {0}\", _process.Id);",
              "author": {
                "login": "tmds"
              }
            },
            {
              "body": "I talked with @cdmihai about this. We think it would be good to have both the comm trace (that you already added) and a warning to make it more visible. NodeProviderOutOfProcBase has an IBuildComponentHost (_componentHost) with access to the LoggingService. You can leave BuildEventContext and BuildEventFileInfo undefined as in the [build manager](https://github.com/dotnet/msbuild/blob/4b9f6122dfc8397ee0d939d7932df9cd5818c90c/src/Build/BackEnd/BuildManager/BuildManager.cs#L2855-L2861).",
              "createdAt": "2021-02-04T18:40:33Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -802,6 +829,40 @@ public void Close()\n                 _terminateDelegate(_nodeId);\n             }\n \n+            /// <summary>\n+            /// Waits for the child node process to exit.\n+            /// </summary>\n+            public async Task WaitForExitAsync()\n+            {\n+                // Wait for the process to exit.\n+                if (_isExiting)\n+                {\n+                    CommunicationsUtilities.Trace(\"Waiting for node with pid = {0} to exit\", _process.Id);\n+\n+                    // .NET 5 introduces a real WaitForExitAsyc.\n+                    // This is a poor man's implementation that uses polling.\n+                    int timeout = TimeoutForWaitForExit;\n+                    int delay = 5;\n+                    while (timeout > 0)\n+                    {\n+                        bool exited = _process.WaitForExit(milliseconds: 0);\n+                        if (exited)\n+                        {\n+                            return;\n+                        }\n+                        timeout -= delay;\n+                        await Task.Delay(delay).ConfigureAwait(false);\n+\n+                        // Double delay up to 500ms.\n+                        delay = Math.Min(delay * 2, 500);\n+                    }\n+                }\n+\n+                // Kill the child and do a blocking wait.\n+                CommunicationsUtilities.Trace(\"Killing node with pid = {0}\", _process.Id);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm wondering if it would make sense to look for processes with parent id == processId in this case and kill those. Not sure. Also, why are there two exceptions for one error case?",
              "createdAt": "2021-02-06T00:39:11Z",
              "path": "src/Shared/ProcessExtensions.cs",
              "diffHunk": "@@ -77,13 +77,24 @@ private static void GetAllChildIdsUnix(int parentId, ISet<int> children)\n \n         private static void KillProcessUnix(int processId)\n         {\n-            RunProcessAndWaitForExit(\n-                \"kill\",\n-                $\"-TERM {processId}\",\n-                out string _);\n+            try\n+            {\n+                using Process process = Process.GetProcessById(processId);\n+                process.Kill();\n+            }\n+            catch (ArgumentException)\n+            {\n+                // Process already terminated.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> I'm wondering if it would make sense to look for processes with parent id == processId in \r\nThat's what `GetAllChildIdsUnix` does.\r\n\r\n> Also, why are there two exceptions for one error case?\r\n\r\n`ArgumentException` is thrown by `GetProcessById`.\r\n`InvalidOperationException` is thrown by `Kill` (pre .NET 3.0).",
              "createdAt": "2021-02-10T12:55:25Z",
              "path": "src/Shared/ProcessExtensions.cs",
              "diffHunk": "@@ -77,13 +77,24 @@ private static void GetAllChildIdsUnix(int parentId, ISet<int> children)\n \n         private static void KillProcessUnix(int processId)\n         {\n-            RunProcessAndWaitForExit(\n-                \"kill\",\n-                $\"-TERM {processId}\",\n-                out string _);\n+            try\n+            {\n+                using Process process = Process.GetProcessById(processId);\n+                process.Kill();\n+            }\n+            catch (ArgumentException)\n+            {\n+                // Process already terminated.",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why did you eliminate the timeouts here? Seems good not to hang while trying to kill processes \ud83d\ude09",
              "createdAt": "2021-02-06T00:41:43Z",
              "path": "src/Shared/ProcessExtensions.cs",
              "diffHunk": "@@ -7,11 +7,11 @@\n using System.IO;\n using Microsoft.Build.Shared;\n \n-namespace Microsoft.Build.Utilities\n+namespace Microsoft.Build.Shared\n {\n     internal static class ProcessExtensions\n     {\n-        public static void KillTree(this Process process, int timeout)\n+        public static void KillTree(this Process process)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "I've added back the timeouts.\r\n\r\nI guess the main reason for these timeouts is that descendent of the child proces may keep WaitForExit from returning. I'm making attempt at improving that in the BCL: https://github.com/dotnet/runtime/pull/48101 which would eliminate the need for these timeouts.",
              "createdAt": "2021-02-10T12:53:04Z",
              "path": "src/Shared/ProcessExtensions.cs",
              "diffHunk": "@@ -7,11 +7,11 @@\n using System.IO;\n using Microsoft.Build.Shared;\n \n-namespace Microsoft.Build.Utilities\n+namespace Microsoft.Build.Shared\n {\n     internal static class ProcessExtensions\n     {\n-        public static void KillTree(this Process process, int timeout)\n+        public static void KillTree(this Process process)",
              "author": {
                "login": "tmds"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "If you put the string in a strings.resx file and build, then use it here, it will automatically be translated into a number of languages.",
              "createdAt": "2021-02-06T00:45:08Z",
              "path": "src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs",
              "diffHunk": "@@ -802,6 +832,48 @@ public void Close()\n                 _terminateDelegate(_nodeId);\n             }\n \n+            /// <summary>\n+            /// Waits for the child node process to exit.\n+            /// </summary>\n+            public async Task WaitForExitAsync(ILoggingService loggingService)\n+            {\n+                // Wait for the process to exit.\n+                if (_isExiting)\n+                {\n+                    CommunicationsUtilities.Trace(\"Waiting for node with pid = {0} to exit\", _process.Id);\n+\n+                    // .NET 5 introduces a real WaitForExitAsyc.\n+                    // This is a poor man's implementation that uses polling.\n+                    int timeout = TimeoutForWaitForExit;\n+                    int delay = 5;\n+                    while (timeout > 0)\n+                    {\n+                        bool exited = _process.WaitForExit(milliseconds: 0);\n+                        if (exited)\n+                        {\n+                            return;\n+                        }\n+                        timeout -= delay;\n+                        await Task.Delay(delay).ConfigureAwait(false);\n+\n+                        // Double delay up to 500ms.\n+                        delay = Math.Min(delay * 2, 500);\n+                    }\n+                }\n+\n+                // Kill the child and do a blocking wait.\n+                loggingService?.LogWarningFromText(\n+                    BuildEventContext.Invalid,\n+                    null,\n+                    null,\n+                    null,\n+                    BuildEventFileInfo.Empty,\n+                    $\"Killing node with pid = {_process.Id}\");\n+                CommunicationsUtilities.Trace(\"Killing node with pid = {0}\", _process.Id);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      }
    ]
  }
}