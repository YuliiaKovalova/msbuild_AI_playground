{
  "number": 8012,
  "title": "Add question flag to \"question\" the build if it is incremental",
  "body": "Fixes #7348 \r\n\r\nThis PR adds \"question\" switch to msbuild.exe that will error out if a target or a task fails incremental check.  Targets will fail if both Inputs and Outputs are present and not skip.  Tasks changes are individually modified to support the interface IIncrementalTask, which sets the question boolean.  Each task will need to be updated this interface take part. \r\n\r\nI have started with the following tasks and fixed some of the issues within MSBuild enlistment.  And there are more, see the notes below.  Tasks updated: ToolTask, Copy, MakeDir, Touch, WriteLinesTofile, RemoveDir, DownloadFile, Move, ZipDirectory, Unzip, GenerateResource, GenerateBindingRedirects.\r\n\r\nUsing question investigate incremental issues is orders of magnitude easier.  Reading the logs is simpler and repros are more consistent.  In this PR, it includes a few fixes to the common targets which address some issues.\r\n\r\nExample of a Target I/O error.\r\n![image](https://user-images.githubusercontent.com/19828377/193940908-54073146-94b0-441b-b7a0-aee3b0827cd1.png)\r\n\r\n<details>\r\n<summary>External Packages Incremental Notes</summary>\r\ndotnet\\sdk\\7.0.100-rc.1.22431.12\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.Publish.targets\r\n  Target Name=\"_IncrementalCleanPublishDirectory\"\r\n          DependsOnTargets=\"_GetCurrentAndPriorPublishFileWrites\"\r\n    WriteLinesToFile\r\n        File=\"$(IntermediateOutputPath)$(_PublishCleanFile)\"\r\n        Lines=\"@(_CurrentPublishFileWrites)\"\r\n        Overwrite=\"true\" <b>WriteOnlyWhenDifferent=\"true\"</b>\r\n\r\n.nuget\\packages\\microsoft.dotnet.arcade.sdk\\6.0.0-beta.22458.2\\tools\\VisualStudio.VsixBuild.targets\r\nSome Copy task are missing <b>SkipUnchangedFiles=\"true\"</b>\r\n\r\nBootStrapMSBuild.targets, copy is overwriting files, thus it would never be incremental.  A small refactor is required.\r\n\r\nRAR sometimes touches the cache and cause GenerateBindingRedirects to run.\r\nThe FileState .dependencies are missing from the cache so it dirty the cache to fetched again. \r\n See SystemState.GetAssemblyMetadata().\r\n\r\nmicrosoft.sourcelink.github\\1.0.0\\build\\Microsoft.SourceLink.GitHub.targets\r\nTarget Name=\"_InitializeAzureReposGitSourceLinkUrl\" <b>Inputs=\"@(SourceRoot)\" Outputs=\"|%(Identity)|\"</b>\r\n</details>",
  "state": "MERGED",
  "createdAt": "2022-09-28T22:14:12Z",
  "updatedAt": "2023-04-04T20:02:16Z",
  "closedAt": "2023-04-04T20:02:16Z",
  "mergedAt": "2023-04-04T20:02:16Z",
  "additions": 1352,
  "deletions": 140,
  "changedFiles": 79,
  "headRefName": "main",
  "isDraft": false,
  "author": {
    "login": "yuehuang010"
  },
  "milestone": {
    "title": "VS 17.7"
  },
  "assignees": {
    "nodes": [
      {
        "login": "rainersigwald"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "cbefe8779a5f3dcfda982f8c161e11217a0c0514",
          "message": "Add Question switch to stop the build when targets are not incremental.",
          "committedDate": "2022-09-23T01:41:19Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "cde2e06e15e0c3d9c5692faea50a74e25df78a97",
          "message": "Add question property to tasks.",
          "committedDate": "2022-09-23T22:32:09Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "97ef72914dc64f31eebcfa9fdbccce44bf4e234e",
          "message": "Add tests",
          "committedDate": "2022-09-24T02:01:27Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "202098c6a69b5a7cb914a67b75e33871e922d5f9",
          "message": "Clean up IIncrementalTask interface.",
          "committedDate": "2022-09-29T01:11:09Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e687090b9c4b7b198836f9028c8a0d005a9c01d1",
          "message": "Add additional tasks.",
          "committedDate": "2022-10-03T22:09:34Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "96abc8a80bc5f8aa20bf115ebc8faeda748c32d5",
          "message": "Test and Question on this repro.",
          "committedDate": "2022-10-04T02:07:58Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "12727c14832880def776b08a230d7b04219aca9a",
          "message": "fix build",
          "committedDate": "2022-10-04T20:20:27Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "878c8efe12c5a0017d5d0c763c8da459963ebd48",
          "message": "Fix question in -m.  Fix BindingRedirect to target incremental.",
          "committedDate": "2022-10-04T22:08:44Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f9a373040813e7b1fbde36671234f00acbc0e6a7",
          "message": "Fix tests for Linux.",
          "committedDate": "2022-10-05T01:45:30Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3cdbf950227d0af15725a8154d0a286583e8f118",
          "message": "WIP",
          "committedDate": "2022-10-18T00:59:57Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bf6520138972a0043b09ffea753dfc87ebbfb878",
          "message": "Fix feedbacks",
          "committedDate": "2022-10-18T19:38:20Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4ac5d1e4fd209bc2eadfd72fad4515fdd75ec4dc",
          "message": ".",
          "committedDate": "2022-10-19T02:17:01Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "36bf99d8e857701e2a0be773f2b501139ef2381b",
          "message": "Revert condition.",
          "committedDate": "2022-10-19T22:00:47Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5ec1a34002c86d5d95ea351c8ca35e90ce2ba86c",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild",
          "committedDate": "2022-10-24T22:28:20Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2e0caf9d078cc560ea857fe02320cd6b041ca575",
          "message": "fix feedback.",
          "committedDate": "2022-10-25T04:29:32Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f172c47d6cc2a2a047cd3ca617b0f1abc75ed961",
          "message": "touch to rerun.",
          "committedDate": "2022-10-25T21:06:40Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c40dce0ec46e1c1c579b0fe6b4460745a72025d4",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild",
          "committedDate": "2023-01-19T22:36:30Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d616c8fcf71eb201e9b58b4b0854869d0b4a5f60",
          "message": "Fix merge.",
          "committedDate": "2023-01-19T22:51:08Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bc79ec146311c59d59e9a8c1a404d4c351959064",
          "message": "Fix merge pt2",
          "committedDate": "2023-01-19T23:27:58Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2eaf929377a1b1ed82e7373618275112d0b6ff22",
          "message": "Merge branch 'main' into main",
          "committedDate": "2023-01-20T21:01:26Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c2268ccf6a2c7fd4f0aba562e8d588e63314e568",
          "message": "Fix merge p3",
          "committedDate": "2023-01-20T21:18:16Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6ddf7a3f163d7791fcb7a4ed503bdc9d8ebac9dc",
          "message": "Fix fileState when it couldn't resolve some files.",
          "committedDate": "2023-01-26T21:24:55Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "9d9046af4d08fe8cbd47c9ec6ce7e1d4dc0cb941",
          "message": "Merge branch 'main' of https://github.com/yuehuang010/msbuild",
          "committedDate": "2023-01-26T21:27:35Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "3375f4e9c22e0bec0941e73e778f085cdec8b9ff",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild",
          "committedDate": "2023-01-26T21:31:09Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8edabee4ea2629f1bb809941decef0bffcbfb7e5",
          "message": "Fix merge",
          "committedDate": "2023-01-26T21:40:17Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "4c95b88e5ca13a21852a1f4207edf5ab33738d81",
          "message": "Address feedbacks",
          "committedDate": "2023-01-26T22:31:03Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fccbd33084002d31700b9aec0bee37407db1d43d",
          "message": "Fix test.",
          "committedDate": "2023-01-26T23:07:55Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "787d39ff79712eda7eebbb4cd35ef80a1401695d",
          "message": "Clean up.",
          "committedDate": "2023-01-27T00:02:25Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "412817c57da0a6009dae2968117215984e469c9e",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild",
          "committedDate": "2023-02-02T19:07:46Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "ac1bca4bb62153e6c466971970256545974a71ea",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild",
          "committedDate": "2023-02-06T23:44:46Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bc8438f3790f90a85a517aa4a4f6f186d9beb6d0",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild",
          "committedDate": "2023-02-14T16:48:13Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b32b17bb1daaf71f62c82adec93ebc741b301f1d",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild",
          "committedDate": "2023-02-28T22:20:35Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e68be0b967167ebfc9c101dcdf49bad2752cc223",
          "message": "Fix Feedback",
          "committedDate": "2023-02-28T23:56:58Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fbe74f22dcd1d5b753fe150fec9ef21c9060015e",
          "message": "Fix Feedback.",
          "committedDate": "2023-03-01T00:06:37Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bc9987394c5609b22c17d634f4e2284fce7daf04",
          "message": "Update tests",
          "committedDate": "2023-03-01T00:34:14Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "78f5bbe5222ae06fb009b2db50a1488bdb7e176f",
          "message": "Address some feedbacks.",
          "committedDate": "2023-03-02T00:20:08Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "93272568e7abf63eb7d12c81a77360c1ab847212",
          "message": "Update help message",
          "committedDate": "2023-03-02T18:26:59Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "7326095fea045740222fa6265e003a92a3cc6a4e",
          "message": "With xlf",
          "committedDate": "2023-03-02T18:30:46Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "8299d543280d2d3da0ca7d6c28e7eb184db9b913",
          "message": "update string 80 char or less.",
          "committedDate": "2023-03-02T19:16:20Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b23ed15b547052db59a64107f88a43f3278b4d40",
          "message": "Update comments.",
          "committedDate": "2023-03-02T21:35:20Z",
          "author": {
            "name": "Yue (Felix) Huang",
            "email": "yuehuang010@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "2364b0b13f668de6e5a0f5cd643ca7a1ba55b309",
          "message": "Merge branch 'main' of https://github.com/dotnet/msbuild",
          "committedDate": "2023-04-04T17:24:27Z",
          "author": {
            "name": "Felix Huang",
            "email": "yuehuang@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I am very skeptical of this approach. In general, incremental build problems are hard to debug because _so many things_ are out-of-date--if there's only one thing that's broken, searching for the incremental build key phrases (`is newer than`) will quickly point to what's wrong. But usually there are both many things that are expected to run on every build, and an unpleasant cascade of builds from a single source of problems.\r\n\r\nCan you give an example of a concrete real-world incremental build problem where this would help investigate? That might help understand the value.",
        "createdAt": "2022-10-04T22:17:45Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "The analogy is maintaining code in hard without tests.  Once tests are in place and reliable, then confidence grows and the product is more manageable.\r\n\r\nThe goal of this feature is to 1) provide a fast way to investigate the issue by stopping on first incremental issue.  This will shorten investigation time and more fixing time.  2) is to establish a way to validate incremental (aka testing).  At the moment, there is too existing issues for 2 to be in place, but hopefully, this will lay the foundation going forward.\r\n\r\nHere is an example of an issue fixed in this PR.  With the target \"GenerateBindingRedirects\" can hit an state where the IO will run indefinitely.  Touch the project file without changing anything.  This will trigger $(MSBuildAllProjects) on the input.  The GenerateBindingRedirects task will run but won't write a new file because the content are same.  The output wasn't modified and the target will repeat.  While this task won't lead to disk write, it causes \"noise\" in the (````is newer than````) search.",
        "createdAt": "2022-10-04T22:39:03Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "@rainersigwald Ping.",
        "createdAt": "2022-11-03T21:30:31Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "This is on my to-do list, hopefully early this week.",
        "createdAt": "2022-11-07T16:20:40Z",
        "author": {
          "login": "rainersigwald"
        }
      },
      {
        "body": "Ping.",
        "createdAt": "2023-01-19T01:07:02Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "> I hit a bad case testing this on our repo:\r\n> \r\n> ```\r\n> MSBUILD : error : Building target \"_InitializeGitHubSourceLinkUrl\" completely. [S:\\msbuild\\src\\Samples\\TaskUsageLogger\\TaskUsageLogger.csproj::TargetFramework=netstandard2.0]\r\n> ```\r\n> \r\n> That uses outputs for target batching:\r\n> \r\n> ```\r\n>   <Target Name=\"_InitializeGitHubSourceLinkUrl\" Inputs=\"@(SourceRoot)\" Outputs=\"|%(Identity)|\">\r\n> ```\r\n> \r\n> Which is definitely a code smell, and could be fixed in this case. However, it seems like the error should at least say `Output |github.com| does not exist`.\r\n\r\nI tried erroring on each item, but I felt it overloaded the screen with too much RED.  Perhaps it is something to consider with more user feedback.\r\n\r\nYes, SourceLink has this \"bug\".  I fixed the target locally to get pass that point and submitted (https://github.com/dotnet/sourcelink/pull/901).  ",
        "createdAt": "2023-01-26T22:22:30Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "Hi, @rainersigwald.  Do you have any further questions?  I would like to get this merged so I can start next part of fixing the incremental issues.  Thanks.",
        "createdAt": "2023-02-18T01:04:47Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "Ping @rainersigwald ",
        "createdAt": "2023-03-22T19:46:56Z",
        "author": {
          "login": "yuehuang010"
        }
      },
      {
        "body": "@rainersigwald, looks like resource files are unhappy; may need to build + push again",
        "createdAt": "2023-04-04T16:20:10Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I think I screwed up \ud83d\ude22 ",
        "createdAt": "2023-04-04T16:27:26Z",
        "author": {
          "login": "Forgind"
        }
      },
      {
        "body": "I have a meeting but will try to fix afterwards",
        "createdAt": "2023-04-04T16:27:54Z",
        "author": {
          "login": "Forgind"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems like a slightly misleading name. canBeIncremental should be that it has inputs and outputs; Question is just whether we care in this case.",
              "createdAt": "2022-10-17T21:23:55Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs",
              "diffHunk": "@@ -463,15 +463,23 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re\n                         // UNDONE: (Refactor) Refactor TargetUpToDateChecker to take a logging context, not a logging service.\n                         MSBuildEventSource.Log.TargetUpToDateStart();\n                         TargetUpToDateChecker dependencyAnalyzer = new TargetUpToDateChecker(requestEntry.RequestConfiguration.Project, _target, targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext);\n-                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, out changedTargetInputs, out upToDateTargetInputs);\n+                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, this._host.BuildParameters.Question, out changedTargetInputs, out upToDateTargetInputs);\n                         MSBuildEventSource.Log.TargetUpToDateStop((int)dependencyResult);\n+                        bool canBeIncremental = !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs) && this._host.BuildParameters.Question;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "What name would you recommend?",
              "createdAt": "2022-10-18T19:39:34Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs",
              "diffHunk": "@@ -463,15 +463,23 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re\n                         // UNDONE: (Refactor) Refactor TargetUpToDateChecker to take a logging context, not a logging service.\n                         MSBuildEventSource.Log.TargetUpToDateStart();\n                         TargetUpToDateChecker dependencyAnalyzer = new TargetUpToDateChecker(requestEntry.RequestConfiguration.Project, _target, targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext);\n-                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, out changedTargetInputs, out upToDateTargetInputs);\n+                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, this._host.BuildParameters.Question, out changedTargetInputs, out upToDateTargetInputs);\n                         MSBuildEventSource.Log.TargetUpToDateStop((int)dependencyResult);\n+                        bool canBeIncremental = !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs) && this._host.BuildParameters.Question;",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "If you want to leave it as-is, perhaps `shouldCheckIfIncremental`. My personal preference would probably be leaving it canBeIncremental but making it `!string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs)`, then checking Question later.",
              "createdAt": "2022-10-21T23:00:41Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs",
              "diffHunk": "@@ -463,15 +463,23 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re\n                         // UNDONE: (Refactor) Refactor TargetUpToDateChecker to take a logging context, not a logging service.\n                         MSBuildEventSource.Log.TargetUpToDateStart();\n                         TargetUpToDateChecker dependencyAnalyzer = new TargetUpToDateChecker(requestEntry.RequestConfiguration.Project, _target, targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext);\n-                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, out changedTargetInputs, out upToDateTargetInputs);\n+                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, this._host.BuildParameters.Question, out changedTargetInputs, out upToDateTargetInputs);\n                         MSBuildEventSource.Log.TargetUpToDateStop((int)dependencyResult);\n+                        bool canBeIncremental = !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs) && this._host.BuildParameters.Question;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Removed the variable.  Inline the condition.",
              "createdAt": "2022-10-25T21:16:50Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs",
              "diffHunk": "@@ -463,15 +463,23 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re\n                         // UNDONE: (Refactor) Refactor TargetUpToDateChecker to take a logging context, not a logging service.\n                         MSBuildEventSource.Log.TargetUpToDateStart();\n                         TargetUpToDateChecker dependencyAnalyzer = new TargetUpToDateChecker(requestEntry.RequestConfiguration.Project, _target, targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext);\n-                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, out changedTargetInputs, out upToDateTargetInputs);\n+                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, this._host.BuildParameters.Question, out changedTargetInputs, out upToDateTargetInputs);\n                         MSBuildEventSource.Log.TargetUpToDateStop((int)dependencyResult);\n+                        bool canBeIncremental = !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs) && this._host.BuildParameters.Question;",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                        // For the full build decision there are three possible outcomes\r\n```\r\n\r\nWhat do you mean by this?",
              "createdAt": "2022-10-17T22:52:57Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs",
              "diffHunk": "@@ -264,15 +266,23 @@ internal DependencyAnalysisResult PerformDependencyAnalysis\n         /// Does appropriate logging to indicate why this target is being built fully or partially.\n         /// </summary>\n         /// <param name=\"result\"></param>\n-        private void LogReasonForBuildingTarget(DependencyAnalysisResult result)\n+        /// <param name=\"question\"></param>\n+        private void LogReasonForBuildingTarget(DependencyAnalysisResult result, bool question)\n         {\n             // Only if we are not logging just critical events should we be logging the details\n             if (!_loggingService.OnlyLogCriticalEvents)\n             {\n                 if (result == DependencyAnalysisResult.FullBuild && _dependencyAnalysisDetail.Count > 0)\n                 {\n-                    // For the full build decision the are three possible outcomes\n-                    _loggingService.LogComment(_buildEventContext, MessageImportance.Low, \"BuildTargetCompletely\", _targetToAnalyze.Name);\n+                    if (question)\n+                    {\n+                        _loggingService.LogError(_buildEventContext, new BuildEventFileInfo(String.Empty), \"BuildTargetCompletely\", _targetToAnalyze.Name);\n+                    }\n+                    else\n+                    {\n+                        // For the full build decision the are three possible outcomes",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can we move these under if (question) and leave the later parts as they were? This means it would do extra unnecessary work if (UseHardLinksIfPossible || UseSymboliclinksIfPossible || ErrorIfLinkFails).",
              "createdAt": "2022-10-17T23:05:21Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -268,6 +280,15 @@ private void LogDiagnostic(string message, params object[] messageArgs)\n                 _directoriesKnownToExist.TryAdd(destinationFolder, true);\n             }\n \n+            string sourceFilePath = FileUtilities.GetFullPathNoThrow(sourceFileState.Name);",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Moved.",
              "createdAt": "2022-10-18T19:36:38Z",
              "path": "src/Tasks/Copy.cs",
              "diffHunk": "@@ -268,6 +280,15 @@ private void LogDiagnostic(string message, params object[] messageArgs)\n                 _directoriesKnownToExist.TryAdd(destinationFolder, true);\n             }\n \n+            string sourceFilePath = FileUtilities.GetFullPathNoThrow(sourceFileState.Name);",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think the official guidance is to only include a period if the preceding words form a complete sentence, which isn't true here. That said, I don't really care.",
              "createdAt": "2022-10-18T15:28:26Z",
              "path": "src/Tasks/Delegate.cs",
              "diffHunk": "@@ -15,13 +15,13 @@\n namespace Microsoft.Build.Tasks\n {\n     /// <summary>\n-    /// File.GetAttributes delegate\n+    /// File.GetAttributes delegate.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Reverted file.",
              "createdAt": "2022-10-18T19:33:15Z",
              "path": "src/Tasks/Delegate.cs",
              "diffHunk": "@@ -15,13 +15,13 @@\n namespace Microsoft.Build.Tasks\n {\n     /// <summary>\n-    /// File.GetAttributes delegate\n+    /// File.GetAttributes delegate.",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This seems like a potentially noticeable change? I'm assuming you added this to make it not error when the files are the same.",
              "createdAt": "2022-10-18T15:32:07Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -5701,7 +5701,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     <WriteLinesToFile\n         File=\"$(IntermediateOutputPath)$(CleanFile)\"\n         Lines=\"@(_CleanUniqueFileWrites)\"\n-        Overwrite=\"true\" />\n+        Overwrite=\"true\"\n+        WriteOnlyWhenDifferent=\"true\" />",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Correct.  /t:Clean then /t:Clean /question should pass.  In most cases, it was writing an empty file over itself.",
              "createdAt": "2022-10-18T19:26:48Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -5701,7 +5701,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     <WriteLinesToFile\n         File=\"$(IntermediateOutputPath)$(CleanFile)\"\n         Lines=\"@(_CleanUniqueFileWrites)\"\n-        Overwrite=\"true\" />\n+        Overwrite=\"true\"\n+        WriteOnlyWhenDifferent=\"true\" />",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "Alternative, I could condition on Delete, if delete task removed no files, then can skip WriteLines.",
              "createdAt": "2022-10-19T20:16:26Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -5701,7 +5701,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     <WriteLinesToFile\n         File=\"$(IntermediateOutputPath)$(CleanFile)\"\n         Lines=\"@(_CleanUniqueFileWrites)\"\n-        Overwrite=\"true\" />\n+        Overwrite=\"true\"\n+        WriteOnlyWhenDifferent=\"true\" />",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nPrefer `argumentName: value` over `value /* comment */`",
              "createdAt": "2022-10-18T15:33:29Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -125,6 +141,24 @@ SetLastWriteTime fileSetLastWriteTime\n         /// <returns></returns>\n         public override bool Execute()\n         {\n+            if (string.IsNullOrEmpty(Importance))\n+            {\n+                messageImportance = MessageImportance.Normal;\n+            }\n+            else\n+            {\n+                try\n+                {\n+                    // Parse the raw importance string into a strongly typed enumeration.  \n+                    messageImportance = (MessageImportance)Enum.Parse(typeof(MessageImportance), Importance, true /* case-insensitive */);",
              "author": {
                "login": "Forgind"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Individual reasons are already logged?",
              "createdAt": "2023-01-26T16:50:41Z",
              "path": "src/Tasks/GenerateResource.cs",
              "diffHunk": "@@ -719,6 +723,10 @@ public override bool Execute()\n \n                     Log.LogMessageFromResources(\"GenerateResource.NothingOutOfDate\");\n                 }\n+                else if (question)\n+                {\n+                    Log.LogErrorFromResources(\"GenerateResource.OutOfDate\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yes, reasons are logged in GetResourcesToProcess()",
              "createdAt": "2023-01-26T22:19:59Z",
              "path": "src/Tasks/GenerateResource.cs",
              "diffHunk": "@@ -719,6 +723,10 @@ public override bool Execute()\n \n                     Log.LogMessageFromResources(\"GenerateResource.NothingOutOfDate\");\n                 }\n+                else if (question)\n+                {\n+                    Log.LogErrorFromResources(\"GenerateResource.OutOfDate\");",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why `Canceled` instead of `Failed`?",
              "createdAt": "2023-01-26T16:58:44Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs",
              "diffHunk": "@@ -472,6 +472,13 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re\n                             case DependencyAnalysisResult.FullBuild:\n                             case DependencyAnalysisResult.IncrementalBuild:\n                             case DependencyAnalysisResult.SkipUpToDate:\n+                                if (dependencyResult != DependencyAnalysisResult.SkipUpToDate && _host.BuildParameters.Question && !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs))\n+                                {\n+                                    targetSuccess = false;\n+                                    aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Canceled, WorkUnitActionCode.Stop, null));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I am not sure what are the difference.",
              "createdAt": "2023-01-26T22:14:35Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs",
              "diffHunk": "@@ -472,6 +472,13 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re\n                             case DependencyAnalysisResult.FullBuild:\n                             case DependencyAnalysisResult.IncrementalBuild:\n                             case DependencyAnalysisResult.SkipUpToDate:\n+                                if (dependencyResult != DependencyAnalysisResult.SkipUpToDate && _host.BuildParameters.Question && !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs))\n+                                {\n+                                    targetSuccess = false;\n+                                    aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Canceled, WorkUnitActionCode.Stop, null));",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "@rainersigwald ",
              "createdAt": "2023-01-27T18:55:54Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs",
              "diffHunk": "@@ -472,6 +472,13 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re\n                             case DependencyAnalysisResult.FullBuild:\n                             case DependencyAnalysisResult.IncrementalBuild:\n                             case DependencyAnalysisResult.SkipUpToDate:\n+                                if (dependencyResult != DependencyAnalysisResult.SkipUpToDate && _host.BuildParameters.Question && !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs))\n+                                {\n+                                    targetSuccess = false;\n+                                    aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Canceled, WorkUnitActionCode.Stop, null));",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "I think the `Canceled` would not invoke the OnError events.  But the tasks `return false` would still trigger OnError.  It is something to look into later.",
              "createdAt": "2023-03-01T00:13:03Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs",
              "diffHunk": "@@ -472,6 +472,13 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re\n                             case DependencyAnalysisResult.FullBuild:\n                             case DependencyAnalysisResult.IncrementalBuild:\n                             case DependencyAnalysisResult.SkipUpToDate:\n+                                if (dependencyResult != DependencyAnalysisResult.SkipUpToDate && _host.BuildParameters.Question && !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs))\n+                                {\n+                                    targetSuccess = false;\n+                                    aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Canceled, WorkUnitActionCode.Stop, null));",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "My first instinct was to avoid that first semi-redundant check with\r\n\r\n```suggestion\r\n                            case DependencyAnalysisResult.FullBuild:\r\n                            case DependencyAnalysisResult.IncrementalBuild:\r\n                                if (_host.BuildParameters.Question && !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs))\r\n                                {\r\n                                    targetSuccess = false;\r\n                                    aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Canceled, WorkUnitActionCode.Stop, null));\r\n                                    break;\r\n                                }\r\n                                \r\n                                // Fallthrough in cases other than question-mode incremental failure\r\n                            case DependencyAnalysisResult.SkipUpToDate:\r\n```\r\n\r\nBut I'm not sure I actually like this better.",
              "createdAt": "2023-01-26T17:03:31Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs",
              "diffHunk": "@@ -472,6 +472,13 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re\n                             case DependencyAnalysisResult.FullBuild:\n                             case DependencyAnalysisResult.IncrementalBuild:\n                             case DependencyAnalysisResult.SkipUpToDate:\n+                                if (dependencyResult != DependencyAnalysisResult.SkipUpToDate && _host.BuildParameters.Question && !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs))\n+                                {\n+                                    targetSuccess = false;\n+                                    aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Canceled, WorkUnitActionCode.Stop, null));\n+                                    break;\n+                                }\n+",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "C# fallthrough use goto: which makes it look less clean, imo.",
              "createdAt": "2023-01-26T22:13:33Z",
              "path": "src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs",
              "diffHunk": "@@ -472,6 +472,13 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re\n                             case DependencyAnalysisResult.FullBuild:\n                             case DependencyAnalysisResult.IncrementalBuild:\n                             case DependencyAnalysisResult.SkipUpToDate:\n+                                if (dependencyResult != DependencyAnalysisResult.SkipUpToDate && _host.BuildParameters.Question && !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs))\n+                                {\n+                                    targetSuccess = false;\n+                                    aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Canceled, WorkUnitActionCode.Stop, null));\n+                                    break;\n+                                }\n+",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Doing it this way feels like it pushes a bunch of boilerplate into the implementations. Could it be\r\n\r\n```suggestion\r\n        bool Question { get; set; }\r\n```\r\n\r\n?",
              "createdAt": "2023-01-26T17:40:03Z",
              "path": "src/Framework/IIncrementalTask.cs",
              "diffHunk": "@@ -0,0 +1,15 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Interface for tasks which is incremental\n+    /// </summary>\n+    public interface IIncrementalTask\n+    {\n+        void  SetQuestion(bool question);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I'm also not sure about the name here. I prefer a more descriptive name, maybe something like `StopWhenOutOfDate` or `StopWhenNotUpToDate` or `FailIfNotIncremental`?",
              "createdAt": "2023-01-26T17:41:22Z",
              "path": "src/Framework/IIncrementalTask.cs",
              "diffHunk": "@@ -0,0 +1,15 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Interface for tasks which is incremental\n+    /// </summary>\n+    public interface IIncrementalTask\n+    {\n+        void  SetQuestion(bool question);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Changed to   bool Question { get; set; }.",
              "createdAt": "2023-01-26T22:49:28Z",
              "path": "src/Framework/IIncrementalTask.cs",
              "diffHunk": "@@ -0,0 +1,15 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Interface for tasks which is incremental\n+    /// </summary>\n+    public interface IIncrementalTask\n+    {\n+        void  SetQuestion(bool question);",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n    /// <remarks>The tasks implementing this interface should return false to stop the build when in <see cref=\"FailIfNotIncremental\"/> is true and task is not fully incremental.  Try to provide helpful information to diagnose incremental behavior.</remarks>\r\n```",
              "createdAt": "2023-02-28T21:23:03Z",
              "path": "src/Framework/IIncrementalTask.cs",
              "diffHunk": "@@ -0,0 +1,19 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Interface for tasks which is supports incrementality.\n+    /// </summary>\n+    /// <remarks>The tasks implementing this interface should return false to stop the build when in <see cref=\"FailIfNotIncremental\"/> is true and task is not fully incremental.  Try to provide helpful information diagnose incremental behavior.</remarks>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                if (!Enum.TryParse(Importance, ignoreCase: true, out messageImportance))\r\n                {\r\n                    Log.LogErrorWithCodeFromResources(\"Message.InvalidImportance\", Importance);\r\n                    return false;\r\n                }\r\n```",
              "createdAt": "2023-02-28T21:34:04Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -120,6 +134,24 @@ public class Touch : TaskExtension\n         /// <returns></returns>\n         public override bool Execute()\n         {\n+            if (string.IsNullOrEmpty(Importance))\n+            {\n+                messageImportance = MessageImportance.Normal;\n+            }\n+            else\n+            {\n+                try\n+                {\n+                    // Parse the raw importance string into a strongly typed enumeration.  \n+                    messageImportance = (MessageImportance)Enum.Parse(typeof(MessageImportance), Importance, ignoreCase: true);\n+                }\n+                catch (ArgumentException)\n+                {\n+                    Log.LogErrorWithCodeFromResources(\"Message.InvalidImportance\", Importance);\n+                    return false;\n+                }\n+            }",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why change the target hook here?",
              "createdAt": "2023-02-28T21:37:09Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -2489,20 +2490,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     ====================================================================================================\n   -->\n   <Target Name=\"GenerateBindingRedirectsUpdateAppConfig\"\n-    AfterTargets=\"GenerateBindingRedirects\"",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "The issue is related this target skipped early in the build, but later the condition became true, which then changed the build outputs.  \r\nI remember I had a hard time getting the AfterTargets to get the behavior I wanted, so it was easier to add it to the ResolveReferencesDependsOn property.",
              "createdAt": "2023-02-28T23:38:32Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -2489,20 +2490,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     ====================================================================================================\n   -->\n   <Target Name=\"GenerateBindingRedirectsUpdateAppConfig\"\n-    AfterTargets=\"GenerateBindingRedirects\"",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm not sure removing this is safe--I can imagine a custom target that uses `$(AppConfig)` and wants the updated one. Does it need to change?",
              "createdAt": "2023-02-28T21:40:47Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -2489,20 +2490,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     ====================================================================================================\n   -->\n   <Target Name=\"GenerateBindingRedirectsUpdateAppConfig\"\n-    AfterTargets=\"GenerateBindingRedirects\"\n-    Condition=\"'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')\">\n-\n-    <PropertyGroup>\n-      <AppConfig>$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I think it was a simplification of the exists check.  I will revert.",
              "createdAt": "2023-02-28T23:39:25Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -2489,20 +2490,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     ====================================================================================================\n   -->\n   <Target Name=\"GenerateBindingRedirectsUpdateAppConfig\"\n-    AfterTargets=\"GenerateBindingRedirects\"\n-    Condition=\"'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')\">\n-\n-    <PropertyGroup>\n-      <AppConfig>$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't understand this. Isn't `Touch` inherently non-incremental since it'll update the modtime? Shouldn't this be a failure case?",
              "createdAt": "2023-02-28T21:46:31Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +226,12 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n-            else\n+\n+            Log.LogMessageFromResources(messageImportance, \"Touch.Touching\", file);\n+\n+            if (FailIfNotIncremental)\n             {\n-                Log.LogMessageFromResources(MessageImportance.Normal, \"Touch.Touching\", file);\n+                return true;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Touch function itself is non-incremental, but in practice, the touch task is like an Exec task for \"touch.exe\". It is wrapped with incremental output check such that as long as the output exists, then it can skip.\r\n\r\nAnother way to think about is how to check if this task ran last build.",
              "createdAt": "2023-02-28T23:07:41Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +226,12 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n-            else\n+\n+            Log.LogMessageFromResources(messageImportance, \"Touch.Touching\", file);\n+\n+            if (FailIfNotIncremental)\n             {\n-                Log.LogMessageFromResources(MessageImportance.Normal, \"Touch.Touching\", file);\n+                return true;",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "Sorry, this isn't clicking with me. In a non-question build, if we touch an input to any later target/task, it'll break incremental behavior downstream. Why wouldn't question report that?",
              "createdAt": "2023-02-28T23:20:52Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +226,12 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n-            else\n+\n+            Log.LogMessageFromResources(messageImportance, \"Touch.Touching\", file);\n+\n+            if (FailIfNotIncremental)\n             {\n-                Log.LogMessageFromResources(MessageImportance.Normal, \"Touch.Touching\", file);\n+                return true;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Good catch.",
              "createdAt": "2023-03-01T00:05:31Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +226,12 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n-            else\n+\n+            Log.LogMessageFromResources(messageImportance, \"Touch.Touching\", file);\n+\n+            if (FailIfNotIncremental)\n             {\n-                Log.LogMessageFromResources(MessageImportance.Normal, \"Touch.Touching\", file);\n+                return true;",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "After some testing, I have found this case in microsoft.net.compilers.toolset \\ Microsoft.Managed.Core.targets\r\n```\r\n  <!-- We touch and create a semaphore file after build to indicate the time stamp for last build with skipAnalyzers flag. -->\r\n  <Target Name=\"_TouchLastBuildWithSkipAnalyzers\" Condition=\"'$(_SkipAnalyzers)' == 'true'\" AfterTargets=\"CoreCompile\">\r\n    <Touch AlwaysCreate=\"true\" Files=\"$(_LastBuildWithSkipAnalyzers)\"/>\r\n  </Target>\r\n```\r\n@rainersigwald , Do you have thoughts about how strict should question mode be.  If the touch task doesn't affect the build, should it error?\r\n",
              "createdAt": "2023-03-02T00:40:43Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +226,12 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n-            else\n+\n+            Log.LogMessageFromResources(messageImportance, \"Touch.Touching\", file);\n+\n+            if (FailIfNotIncremental)\n             {\n-                Log.LogMessageFromResources(MessageImportance.Normal, \"Touch.Touching\", file);\n+                return true;",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "How are you determining `doesn't affect the build` at the time when you touched it?",
              "createdAt": "2023-03-02T00:44:42Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +226,12 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n-            else\n+\n+            Log.LogMessageFromResources(messageImportance, \"Touch.Touching\", file);\n+\n+            if (FailIfNotIncremental)\n             {\n-                Log.LogMessageFromResources(MessageImportance.Normal, \"Touch.Touching\", file);\n+                return true;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "> \r\n\r\nThis file doesn't affect the inputs and outputs of build.  For example, some tools will touch a file to trigger a file watcher to start testing or analysis. ",
              "createdAt": "2023-03-02T00:52:55Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +226,12 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n-            else\n+\n+            Log.LogMessageFromResources(messageImportance, \"Touch.Touching\", file);\n+\n+            if (FailIfNotIncremental)\n             {\n-                Log.LogMessageFromResources(MessageImportance.Normal, \"Touch.Touching\", file);\n+                return true;",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "> \r\n\r\nNo way determining the effect.  It is all or none.",
              "createdAt": "2023-03-02T00:53:43Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +226,12 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n-            else\n+\n+            Log.LogMessageFromResources(messageImportance, \"Touch.Touching\", file);\n+\n+            if (FailIfNotIncremental)\n             {\n-                Log.LogMessageFromResources(MessageImportance.Normal, \"Touch.Touching\", file);\n+                return true;",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "So in that case, it sounds like Touch should just never be \"incremental\" to me.",
              "createdAt": "2023-03-02T02:08:31Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +226,12 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n-            else\n+\n+            Log.LogMessageFromResources(messageImportance, \"Touch.Touching\", file);\n+\n+            if (FailIfNotIncremental)\n             {\n-                Log.LogMessageFromResources(MessageImportance.Normal, \"Touch.Touching\", file);\n+                return true;",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Sounds good.",
              "createdAt": "2023-03-02T18:27:23Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +226,12 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n-            else\n+\n+            Log.LogMessageFromResources(messageImportance, \"Touch.Touching\", file);\n+\n+            if (FailIfNotIncremental)\n             {\n-                Log.LogMessageFromResources(MessageImportance.Normal, \"Touch.Touching\", file);\n+                return true;",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Can you please revert the tooling changes here? They make it hard to review the real changes.",
              "createdAt": "2023-02-28T21:47:40Z",
              "path": "src/Utilities/Resources/Strings.resx",
              "diffHunk": "@@ -1,304 +1,306 @@\n \ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n <root>\n-    <!--\n-        Microsoft ResX Schema\n-\n-        Version 1.3\n-\n-        The primary goals of this format is to allow a simple XML format\n-        that is mostly human readable. The generation and parsing of the\n-        various data types are done through the TypeConverter classes\n-        associated with the data types.\n-\n-        Example:\n-\n-        ... ado.net/XML headers & schema ...\n-        <resheader name=\"resmimetype\">text/microsoft-resx</resheader>\n-        <resheader name=\"version\">1.3</resheader>\n-        <resheader name=\"reader\">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>\n-        <resheader name=\"writer\">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>\n-        <data name=\"Name1\">this is my long string</data>\n-        <data name=\"Color1\" type=\"System.Drawing.Color, System.Drawing\">Blue</data>\n-        <data name=\"Bitmap1\" mimetype=\"application/x-microsoft.net.object.binary.base64\">\n-            [base64 mime encoded serialized .NET Framework object]\n-        </data>\n-        <data name=\"Icon1\" type=\"System.Drawing.Icon, System.Drawing\" mimetype=\"application/x-microsoft.net.object.bytearray.base64\">\n-            [base64 mime encoded string representing a byte array form of the .NET Framework object]\n-        </data>\n-\n-        There are any number of \"resheader\" rows that contain simple\n-        name/value pairs.\n-\n-        Each data row contains a name, and value. The row also contains a\n-        type or mimetype. Type corresponds to a .NET class that support\n-        text/value conversion through the TypeConverter architecture.\n-        Classes that don't support this are serialized and stored with the\n-        mimetype set.\n-\n-        The mimetype is used for serialized objects, and tells the\n-        ResXResourceReader how to depersist the object. This is currently not\n-        extensible. For a given mimetype the value must be set accordingly:\n-\n-        Note - application/x-microsoft.net.object.binary.base64 is the format\n-        that the ResXResourceWriter will generate, however the reader can\n-        read any of the formats listed below.\n-\n-        mimetype: application/x-microsoft.net.object.binary.base64\n-        value   : The object must be serialized with\n-            : System.Serialization.Formatters.Binary.BinaryFormatter\n+  <!-- \n+    Microsoft ResX Schema \n+    \n+    Version 2.0",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Reverted.",
              "createdAt": "2023-03-01T00:08:04Z",
              "path": "src/Utilities/Resources/Strings.resx",
              "diffHunk": "@@ -1,304 +1,306 @@\n \ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n <root>\n-    <!--\n-        Microsoft ResX Schema\n-\n-        Version 1.3\n-\n-        The primary goals of this format is to allow a simple XML format\n-        that is mostly human readable. The generation and parsing of the\n-        various data types are done through the TypeConverter classes\n-        associated with the data types.\n-\n-        Example:\n-\n-        ... ado.net/XML headers & schema ...\n-        <resheader name=\"resmimetype\">text/microsoft-resx</resheader>\n-        <resheader name=\"version\">1.3</resheader>\n-        <resheader name=\"reader\">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>\n-        <resheader name=\"writer\">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>\n-        <data name=\"Name1\">this is my long string</data>\n-        <data name=\"Color1\" type=\"System.Drawing.Color, System.Drawing\">Blue</data>\n-        <data name=\"Bitmap1\" mimetype=\"application/x-microsoft.net.object.binary.base64\">\n-            [base64 mime encoded serialized .NET Framework object]\n-        </data>\n-        <data name=\"Icon1\" type=\"System.Drawing.Icon, System.Drawing\" mimetype=\"application/x-microsoft.net.object.bytearray.base64\">\n-            [base64 mime encoded string representing a byte array form of the .NET Framework object]\n-        </data>\n-\n-        There are any number of \"resheader\" rows that contain simple\n-        name/value pairs.\n-\n-        Each data row contains a name, and value. The row also contains a\n-        type or mimetype. Type corresponds to a .NET class that support\n-        text/value conversion through the TypeConverter architecture.\n-        Classes that don't support this are serialized and stored with the\n-        mimetype set.\n-\n-        The mimetype is used for serialized objects, and tells the\n-        ResXResourceReader how to depersist the object. This is currently not\n-        extensible. For a given mimetype the value must be set accordingly:\n-\n-        Note - application/x-microsoft.net.object.binary.base64 is the format\n-        that the ResXResourceWriter will generate, however the reader can\n-        read any of the formats listed below.\n-\n-        mimetype: application/x-microsoft.net.object.binary.base64\n-        value   : The object must be serialized with\n-            : System.Serialization.Formatters.Binary.BinaryFormatter\n+  <!-- \n+    Microsoft ResX Schema \n+    \n+    Version 2.0",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why? This seems kinda counter to the PR purpose.",
              "createdAt": "2023-02-28T21:54:38Z",
              "path": "src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs",
              "diffHunk": "@@ -131,11 +133,19 @@ public override bool Execute()\n \n             if (writeOutput)\n             {\n+                Log.LogMessageFromResources(MessageImportance.Low, \"GenerateBindingRedirects.CreatingBindingRedirectionFile\", OutputAppConfigFile.ItemSpec);\n                 using (var stream = FileUtilities.OpenWrite(OutputAppConfigFile.ItemSpec, false))\n                 {\n                     doc.Save(stream);\n                 }\n             }\n+            else if (outputExists)\n+            {\n+                // if the file exists and the content is up to date, then touch the output file.",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "This is not related to /question flag, but it is a fix the incremental issue.  I call it double incremental issue.\r\nThis task is used in a \\<Target\\> that also has inputs and output.  When the inputs changed, the target will run, but the task would decide to skip (not producing an output).  This would cause the target to run again as its output is not updated.  \r\nBoth the task and target are incremental in a slightly different way. This change will force the task to touch the output without modifying the content.",
              "createdAt": "2023-02-28T22:47:39Z",
              "path": "src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs",
              "diffHunk": "@@ -131,11 +133,19 @@ public override bool Execute()\n \n             if (writeOutput)\n             {\n+                Log.LogMessageFromResources(MessageImportance.Low, \"GenerateBindingRedirects.CreatingBindingRedirectionFile\", OutputAppConfigFile.ItemSpec);\n                 using (var stream = FileUtilities.OpenWrite(OutputAppConfigFile.ItemSpec, false))\n                 {\n                     doc.Save(stream);\n                 }\n             }\n+            else if (outputExists)\n+            {\n+                // if the file exists and the content is up to date, then touch the output file.",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n                     a target or task that can be incremental (has\r\n                     inputs and outputs) but isn't.\r\n```",
              "createdAt": "2023-03-01T19:04:06Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -848,6 +847,18 @@\n       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.\n     </comment>\n   </data>\n+  <data name=\"HelpMessage_41_QuestionSwitch\" Visibility=\"Public\">\n+    <value>  -question          (Experimental) Question the build if it is incremental.\n+                     MSBuild will stop and error out as soon as it detects\n+                     a target or task that isn't incremental.",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Rephrased.",
              "createdAt": "2023-03-02T00:28:45Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -848,6 +847,18 @@\n       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.\n     </comment>\n   </data>\n+  <data name=\"HelpMessage_41_QuestionSwitch\" Visibility=\"Public\">\n+    <value>  -question          (Experimental) Question the build if it is incremental.\n+                     MSBuild will stop and error out as soon as it detects\n+                     a target or task that isn't incremental.",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This should probably go above the [Output]s.\r\n\r\nIs anyone other than us expected to use this directly? If not, we can consider just making it built-in.",
              "createdAt": "2023-03-01T19:08:17Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1039,6 +1039,8 @@ public String DependsOnNETStandard\n         [Output]\n         public ITaskItem[] UnresolvedAssemblyConflicts => _unresolvedConflicts.ToArray();\n \n+        public bool FailIfNotIncremental { get; set; }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Moved.",
              "createdAt": "2023-03-02T00:28:30Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -1039,6 +1039,8 @@ public String DependsOnNETStandard\n         [Output]\n         public ITaskItem[] UnresolvedAssemblyConflicts => _unresolvedConflicts.ToArray();\n \n+        public bool FailIfNotIncremental { get; set; }",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should this be { get; set; }? It seems like you override it in classes implementing this interface, though it's possible that's necessary anyway for our task infrastructure to work.",
              "createdAt": "2023-03-01T19:10:33Z",
              "path": "src/Framework/IIncrementalTask.cs",
              "diffHunk": "@@ -0,0 +1,19 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Interface for tasks which is supports incrementality.\n+    /// </summary>\n+    /// <remarks>The tasks implementing this interface should return false to stop the build when in <see cref=\"FailIfNotIncremental\"/> is true and task is not fully incremental.  Try to provide helpful information to diagnose incremental behavior.</remarks>\n+    public interface IIncrementalTask\n+    {\n+        /// <summary>\n+        /// Set by MSBuild when Question flag is used.\n+        /// </summary>\n+        bool FailIfNotIncremental { set; }",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This interface is for build engine to set for the Task.  I don't for see a reason for the Task of communicating this property back to the build engine.\r\nAs a side note, I didn't see a way for Tasks to get the BuildParameters.  It is most by design.",
              "createdAt": "2023-03-01T22:52:31Z",
              "path": "src/Framework/IIncrementalTask.cs",
              "diffHunk": "@@ -0,0 +1,19 @@\n+\ufeff// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#nullable disable\n+\n+namespace Microsoft.Build.Framework\n+{\n+    /// <summary>\n+    /// Interface for tasks which is supports incrementality.\n+    /// </summary>\n+    /// <remarks>The tasks implementing this interface should return false to stop the build when in <see cref=\"FailIfNotIncremental\"/> is true and task is not fully incremental.  Try to provide helpful information to diagnose incremental behavior.</remarks>\n+    public interface IIncrementalTask\n+    {\n+        /// <summary>\n+        /// Set by MSBuild when Question flag is used.\n+        /// </summary>\n+        bool FailIfNotIncremental { set; }",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This isn't the only output of RAR, right? Why is this the only one we care about? Because it's the only one saved to disk?",
              "createdAt": "2023-03-01T19:42:30Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -2051,6 +2053,12 @@ internal void WriteStateFile()\n             }\n             else if (!String.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n             {\n+                if (FailIfNotIncremental)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "This is not a complete incremental implementation for RAR.  I only add this changes here to detect when cache file is changed.  There are enough cases where the RAR's output is the same but the cache is modified.  Because of the added risk, I started a separate PR that addressing some of the RAR issues.  #8173\r\n",
              "createdAt": "2023-03-01T22:45:40Z",
              "path": "src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs",
              "diffHunk": "@@ -2051,6 +2053,12 @@ internal void WriteStateFile()\n             }\n             else if (!String.IsNullOrEmpty(_stateFile) && _cache.IsDirty)\n             {\n+                if (FailIfNotIncremental)",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm a little concerned by creeping disk pings in the common case for things like this. Is there any way we can make it go away?",
              "createdAt": "2023-03-01T19:47:03Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -2489,20 +2490,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     ====================================================================================================\n   -->\n   <Target Name=\"GenerateBindingRedirectsUpdateAppConfig\"\n-    AfterTargets=\"GenerateBindingRedirects\"\n-    Condition=\"'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')\">\n+    Condition=\"'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'\">\n \n-    <PropertyGroup>\n+    <PropertyGroup Condition=\"Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')\">",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Merged into a property.",
              "createdAt": "2023-03-02T00:28:19Z",
              "path": "src/Tasks/Microsoft.Common.CurrentVersion.targets",
              "diffHunk": "@@ -2489,20 +2490,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n     ====================================================================================================\n   -->\n   <Target Name=\"GenerateBindingRedirectsUpdateAppConfig\"\n-    AfterTargets=\"GenerateBindingRedirects\"\n-    Condition=\"'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')\">\n+    Condition=\"'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'\">\n \n-    <PropertyGroup>\n+    <PropertyGroup Condition=\"Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')\">",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "No need for a failure message in the failure case?",
              "createdAt": "2023-03-01T19:47:55Z",
              "path": "src/Tasks/Move.cs",
              "diffHunk": "@@ -149,7 +157,7 @@ public override bool Execute()\n \n                 try\n                 {\n-                    if (MoveFileWithLogging(sourceFile, destinationFile))\n+                    if (!FailIfNotIncremental && MoveFileWithLogging(sourceFile, destinationFile))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Move is interesting as it is used to move files A->B, then B->C.  This leads to files A and B are missing.  \r\nI think it is too hard or impossible to be correct here.  The question mode just skips move operation and let a downstream incremental detection find the issue.",
              "createdAt": "2023-03-01T22:30:40Z",
              "path": "src/Tasks/Move.cs",
              "diffHunk": "@@ -149,7 +157,7 @@ public override bool Execute()\n \n                 try\n                 {\n-                    if (MoveFileWithLogging(sourceFile, destinationFile))\n+                    if (!FailIfNotIncremental && MoveFileWithLogging(sourceFile, destinationFile))",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "IMO `Move` is, like `Touch`, inherently broken in incremental scenarios. It can be used within a target, but that target needs to skip.",
              "createdAt": "2023-03-01T22:44:22Z",
              "path": "src/Tasks/Move.cs",
              "diffHunk": "@@ -149,7 +157,7 @@ public override bool Execute()\n \n                 try\n                 {\n-                    if (MoveFileWithLogging(sourceFile, destinationFile))\n+                    if (!FailIfNotIncremental && MoveFileWithLogging(sourceFile, destinationFile))",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm wondering if we should take into account some of the failure cases below before erroring here.",
              "createdAt": "2023-03-01T19:50:56Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +221,16 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n+\n+            // Ignore touching the disk when FailIfNotIncremental.\n+            if (FailIfNotIncremental)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Question mode would stop before any write action.  Those failure modes are afterwards that makes it awkward to support.  \r\nI am fine with Question mode only checking would write than can write.",
              "createdAt": "2023-03-01T22:25:58Z",
              "path": "src/Tasks/Touch.cs",
              "diffHunk": "@@ -185,9 +221,16 @@ public override bool Execute()\n                     return false;\n                 }\n             }\n+\n+            // Ignore touching the disk when FailIfNotIncremental.\n+            if (FailIfNotIncremental)",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This feels a little weird to me. If we already zipped the directory, then we should fail as not incremental?",
              "createdAt": "2023-03-01T19:53:16Z",
              "path": "src/Tasks/ZipDirectory.cs",
              "diffHunk": "@@ -47,7 +49,7 @@ public override bool Execute()\n             {\n                 if (destinationFile.Exists)\n                 {\n-                    if (!Overwrite)\n+                    if (!Overwrite || FailIfNotIncremental)",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Sadly, this task is an not incremental.  The best I could do is error out before File.Delete.",
              "createdAt": "2023-03-01T23:28:42Z",
              "path": "src/Tasks/ZipDirectory.cs",
              "diffHunk": "@@ -47,7 +49,7 @@ public override bool Execute()\n             {\n                 if (destinationFile.Exists)\n                 {\n-                    if (!Overwrite)\n+                    if (!Overwrite || FailIfNotIncremental)",
              "author": {
                "login": "yuehuang010"
              }
            },
            {
              "body": "I will add a comment.",
              "createdAt": "2023-03-01T23:29:04Z",
              "path": "src/Tasks/ZipDirectory.cs",
              "diffHunk": "@@ -47,7 +49,7 @@ public override bool Execute()\n             {\n                 if (destinationFile.Exists)\n                 {\n-                    if (!Overwrite)\n+                    if (!Overwrite || FailIfNotIncremental)",
              "author": {
                "login": "yuehuang010"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\n                     (Experimental) Question whether there is any build work to do.\n```\nOr something else but what you have is not grammatical",
              "createdAt": "2023-03-02T03:14:32Z",
              "path": "src/MSBuild/Resources/Strings.resx",
              "diffHunk": "@@ -848,6 +847,20 @@\n       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.\n     </comment>\n   </data>\n+  <data name=\"HelpMessage_41_QuestionSwitch\" Visibility=\"Public\">\n+    <value>  -question\n+                     (Experimental) Question the build if it is fully built.",
              "author": {
                "login": "danmoseley"
              }
            }
          ]
        }
      }
    ]
  }
}