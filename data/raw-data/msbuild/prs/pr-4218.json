{
  "number": 4218,
  "title": "Graph cross targeting take two",
  "body": "Reimplementation of #4143 to address its issues by adding explicit nodes for inner builds instead of trying to hide their complexity away. It does so by imposing a contract on what crosstargeting means, and requiring the sdk to be self-descriptive about its crosstargeting structure (the property name of the inner build (e.g. `TargetFramework`), and the property name of the inner build values (e.g. `TargetFrameworks`)).\r\n- no more races on inner builds. They get deduped in the graph.\r\n- inner builds can have non overlapping references\r\n- inner builds can have arbitrary incoming edges\r\n- clear path forward on how to filter the graph per TargetFramework. Right now if project A depends on crosstargeting project B, all of Bs innerbuilds will be added as speculative edges of A. This is no different from building a solution today, which builds all TFs. If one wants to filter, then they have to flow the desired TF through the graph (using Nuget's GetNearestTF) and clip out the unused speculative edges.\r\n\r\nFuture PRs:\r\n- update documentation\r\n- tag nodes and edges of interest with extra metadata: outer builds, inner builds, speculative edges\r\n- refactorings, better inner build detection to avoid overbuilding some targets",
  "state": "MERGED",
  "createdAt": "2019-03-07T21:53:02Z",
  "updatedAt": "2020-12-30T22:53:43Z",
  "closedAt": "2019-03-22T22:52:51Z",
  "mergedAt": "2019-03-22T22:52:51Z",
  "additions": 1739,
  "deletions": 465,
  "changedFiles": 25,
  "headRefName": "graph2",
  "isDraft": false,
  "author": {
    "login": "cdmihai"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "335267ca3f55741d97df191e94bff114e8ef1fc8",
          "message": "Entry targets apply to graph roots, not entry points",
          "committedDate": "2019-03-22T20:48:54Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d44fdf0971d17c5c4bade985ab5577adc3de271e",
          "message": "Add IsGraphBuild global property",
          "committedDate": "2019-03-22T20:48:54Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "28b95bb235263a8f3ec27cacb9cd547b792bf45f",
          "message": "Move project reference protocol to Microsoft.CSharp.targets\n\nWhere it's visible by crosstargeting projects too.",
          "committedDate": "2019-03-22T20:48:54Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "b3fad42b3309f9548469929c1b7a46f73ba3e306",
          "message": "Move common logic to Microsoft.ManagedLanguages.targets",
          "committedDate": "2019-03-22T20:48:54Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "30600a59d5052c2d937325954b19972f99e43294",
          "message": "Only disable implicit project references when we're building them\n\n.",
          "committedDate": "2019-03-22T20:48:54Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5b486c14886f801d1b3040a9d2e800e4ca625dd5",
          "message": "Refactorings",
          "committedDate": "2019-03-22T20:48:54Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "29cb22e6e7d9547a182bb26f54e11b6d8c39ff93",
          "message": "Extract reference generation",
          "committedDate": "2019-03-22T20:48:54Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6e4ef5777388655a6502a3141b0b9651d38cec45",
          "message": "Remove ProjectGraphNode.GlobalProperties\n\nIt is confusing to have the same data accessible from ProjectGraphNode.GlobalProperties and ProjectGraphNode.ProjectInstance.GlobalProperties",
          "committedDate": "2019-03-22T20:48:54Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a233ba2109572c119fea3640324608db2855c55f",
          "message": "Add outer / inner build information to graph",
          "committedDate": "2019-03-22T20:48:54Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bb4cec134e7a4dc206d52113c5f0f558efce4217",
          "message": "ProjectReferenceTargets with crosstargeting",
          "committedDate": "2019-03-22T20:48:55Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "606701cf5840ab85b6f1f4169c04a68790a97ba0",
          "message": "crosstargeting->multitargeting",
          "committedDate": "2019-03-22T20:48:55Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "457e8d3fc3ebde115da1d9845ee93235e18c3e5e",
          "message": "feedback",
          "committedDate": "2019-03-22T20:48:55Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "a042117e6070b7e92503a814a7be99858bc439fc",
          "message": "Microsoft.ManagedLanguages.targets -> Microsoft.Managed.targets",
          "committedDate": "2019-03-22T20:48:55Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "bbe7a64cc22cfa4c1b8cfef3490a4a9030573a83",
          "message": "emphasize outer build constraint",
          "committedDate": "2019-03-22T21:09:51Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c5b496f273fedb118f239bdbaf76fde3e7fa4d97",
          "message": "fixup! feedback",
          "committedDate": "2019-03-22T21:40:16Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "50f318d86f30b56ee9127e250ece9f15ba5c3ae2",
          "message": "add test for overbuild scenario",
          "committedDate": "2019-03-22T22:23:36Z",
          "author": {
            "name": "Mihai Codoban",
            "email": "micodoba@microsoft.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "cc @erikma @dannyvv @yash256 ",
        "createdAt": "2019-03-07T21:54:35Z",
        "author": {
          "login": "cdmihai"
        }
      },
      {
        "body": "Looks good! Only think I see is the `ToDot` which the more I think about it the more I think it should go.",
        "createdAt": "2019-03-11T18:05:56Z",
        "author": {
          "login": "AndyGerlicher"
        }
      },
      {
        "body": "Can you add some negative tests? Like \"doesn't provide the correct metadata to understand the inner build\" -- what's the failure look like? `InvalidProjectFileException`?",
        "createdAt": "2019-03-21T16:16:25Z",
        "author": {
          "login": "rainersigwald"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "Not sure we'd want this in the public API. It's pretty trivial to create it after the fact. If it helps for testing, it could be made internal?",
              "createdAt": "2019-03-11T17:43:40Z",
              "path": "ref/Microsoft.Build/net/Microsoft.Build.cs",
              "diffHunk": "@@ -1427,6 +1427,7 @@ public sealed partial class ProjectGraph\n         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.Graph.ProjectGraphNode> ProjectNodes { get { throw null; } }\n         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.Graph.ProjectGraphNode> ProjectNodesTopologicallySorted { get { throw null; } }\n         public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Experimental.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>> GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) { throw null; }\n+        public string ToDot() { throw null; }",
              "author": {
                "login": "AndyGerlicher"
              }
            },
            {
              "body": "I was thinking it would help have it public in case we decorate the Dot spec with internal information. But maybe this adds even more support to the fact that we need to decorate nodes with tags / metadata like `InnerBuild`, `SpeculativeEdge`, etc",
              "createdAt": "2019-03-11T18:10:03Z",
              "path": "ref/Microsoft.Build/net/Microsoft.Build.cs",
              "diffHunk": "@@ -1427,6 +1427,7 @@ public sealed partial class ProjectGraph\n         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.Graph.ProjectGraphNode> ProjectNodes { get { throw null; } }\n         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.Graph.ProjectGraphNode> ProjectNodesTopologicallySorted { get { throw null; } }\n         public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Experimental.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>> GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) { throw null; }\n+        public string ToDot() { throw null; }",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Need doc comment",
              "createdAt": "2019-03-11T18:20:34Z",
              "path": "src/Shared/UnitTests/TestEnvironment.cs",
              "diffHunk": "@@ -331,6 +331,11 @@ public void WriteLine(string format, params object[] args)\n                 Console.WriteLine(format, args);\n             }\n         }\n+\n+        public void DoNotLaunchDebugger()",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\"there is no list\" => \"there is a list\" to match the logic below",
              "createdAt": "2019-03-11T18:23:54Z",
              "path": "src/Tasks/Microsoft.ManagedLanguages.targets",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff<!--\n+***********************************************************************************************\n+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\n+          created a backup copy.  Incorrect changes to this file will make it\n+          impossible to load or build your projects from the command-line or the IDE.\n+\n+This file defines common build logic for all managed languaged: C#, VisualBasic, F#\n+\n+Copyright (C) Microsoft Corporation. All rights reserved.\n+***********************************************************************************************\n+-->\n+\n+<Project>\n+   <!-- \n+        We are doing a cross-targeting build if there is no list of target frameworks specified",
              "author": {
                "login": "erikmav"
              }
            },
            {
              "body": "Good catch",
              "createdAt": "2019-03-12T00:33:05Z",
              "path": "src/Tasks/Microsoft.ManagedLanguages.targets",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff<!--\n+***********************************************************************************************\n+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\n+          created a backup copy.  Incorrect changes to this file will make it\n+          impossible to load or build your projects from the command-line or the IDE.\n+\n+This file defines common build logic for all managed languaged: C#, VisualBasic, F#\n+\n+Copyright (C) Microsoft Corporation. All rights reserved.\n+***********************************************************************************************\n+-->\n+\n+<Project>\n+   <!-- \n+        We are doing a cross-targeting build if there is no list of target frameworks specified",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "msbuild => MSBuild",
              "createdAt": "2019-03-11T18:30:23Z",
              "path": "src/Tasks/Microsoft.ManagedLanguages.targets",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff<!--\n+***********************************************************************************************\n+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\n+          created a backup copy.  Incorrect changes to this file will make it\n+          impossible to load or build your projects from the command-line or the IDE.\n+\n+This file defines common build logic for all managed languaged: C#, VisualBasic, F#\n+\n+Copyright (C) Microsoft Corporation. All rights reserved.\n+***********************************************************************************************\n+-->\n+\n+<Project>\n+   <!-- \n+        We are doing a cross-targeting build if there is no list of target frameworks specified\n+        nor is there a current target framework being built individually. In that case, a crosstargeting\n+        project file like Microsoft.<language>.CrossTargeting.targets gets imported.\n+   -->\n+   <PropertyGroup Condition=\"'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''\">\n+      <IsCrossTargetingBuild>true</IsCrossTargetingBuild>\n+   </PropertyGroup>\n+\n+   <PropertyGroup>\n+      <InnerBuildProperty>TargetFramework</InnerBuildProperty>\n+      <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>\n+   </PropertyGroup>\n+\n+   <PropertyGroup Condition=\"'$(IsGraphBuild)' == 'true'\">\n+      <!-- Microsoft.Net.Sdk adds all transitive project references to @ProjectReference. It does this at build time\n+           via a target. This fails the undeclared msbuild reference /isolate constraint, so disable transitive\n+           references.\n+           Do not disable transitive references if BuildProjectReferences is false. If building references is false,\n+           then msbuild won't try to build the transitive references, which won't trigger undeclared reference constraints.",
              "author": {
                "login": "erikmav"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I thought we always set this for tests. Did a failure cause a test hang?",
              "createdAt": "2019-03-14T17:17:50Z",
              "path": "src/Shared/UnitTests/TestEnvironment.cs",
              "diffHunk": "@@ -331,6 +331,14 @@ public void WriteLine(string format, params object[] args)\n                 Console.WriteLine(format, args);\n             }\n         }\n+\n+        /// <summary>\n+        /// MSBuild launches the debugger on ErrorUtilities exceptions when in DEBUG. Disable this in tests that assert these exceptions.\n+        /// </summary>\n+        public void DoNotLaunchDebugger()\n+        {\n+            SetEnvironmentVariable(\"MSBUILDDONOTLAUNCHDEBUGGER\", \"1\");",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I had written a few tests to assert failures from ErrorUtilities.Verify* which crashed due to the debugger window launching, and setting that env var fixed them. But then I deleted those tests (because I deleted the underlying code they tested), and I decided to keep this helper because it sounds useful to have.",
              "createdAt": "2019-03-14T22:45:20Z",
              "path": "src/Shared/UnitTests/TestEnvironment.cs",
              "diffHunk": "@@ -331,6 +331,14 @@ public void WriteLine(string format, params object[] args)\n                 Console.WriteLine(format, args);\n             }\n         }\n+\n+        /// <summary>\n+        /// MSBuild launches the debugger on ErrorUtilities exceptions when in DEBUG. Disable this in tests that assert these exceptions.\n+        /// </summary>\n+        public void DoNotLaunchDebugger()\n+        {\n+            SetEnvironmentVariable(\"MSBUILDDONOTLAUNCHDEBUGGER\", \"1\");",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "F# will need this too, eventually?",
              "createdAt": "2019-03-14T17:19:56Z",
              "path": "src/Tasks/Microsoft.CSharp.targets",
              "diffHunk": "@@ -165,6 +156,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <Import Project=\"$(MSBuildExtensionsPath)\\4.0\\Microsoft.NETFramework.props\\ImportBefore\\*\" Condition=\"'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\\4.0\\Microsoft.NETFramework.props\\ImportBefore')\"/>\n    </ImportGroup> \n \n+   <Import Project=\"$(MSBuildToolsPath)\\Microsoft.ManagedLanguages.targets\" />",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Yeah, eventually, as this flows to master and releases. And especially once we start pilling more common code in there.",
              "createdAt": "2019-03-14T22:46:46Z",
              "path": "src/Tasks/Microsoft.CSharp.targets",
              "diffHunk": "@@ -165,6 +156,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.\n       <Import Project=\"$(MSBuildExtensionsPath)\\4.0\\Microsoft.NETFramework.props\\ImportBefore\\*\" Condition=\"'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\\4.0\\Microsoft.NETFramework.props\\ImportBefore')\"/>\n    </ImportGroup> \n \n+   <Import Project=\"$(MSBuildToolsPath)\\Microsoft.ManagedLanguages.targets\" />",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does structuring this as a property mean there can be only one dimension for inner builds? That's a current limitation of cross-targeting but people keep hoping we relax it somehow.",
              "createdAt": "2019-03-14T17:21:06Z",
              "path": "src/Tasks/Microsoft.ManagedLanguages.targets",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff<!--\n+***********************************************************************************************\n+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\n+          created a backup copy.  Incorrect changes to this file will make it\n+          impossible to load or build your projects from the command-line or the IDE.\n+\n+This file defines common build logic for all managed languaged: C#, VisualBasic, F#\n+\n+Copyright (C) Microsoft Corporation. All rights reserved.\n+***********************************************************************************************\n+-->\n+\n+<Project>\n+   <!-- \n+        We are doing a cross-targeting build if there is a non-empty list of target frameworks specified\n+        and there is no current target framework being built individually. In that case, a crosstargeting\n+        project file like Microsoft.<language>.CrossTargeting.targets gets imported.\n+   -->\n+   <PropertyGroup Condition=\"'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''\">\n+      <IsCrossTargetingBuild>true</IsCrossTargetingBuild>\n+   </PropertyGroup>\n+\n+   <PropertyGroup>\n+      <InnerBuildProperty>TargetFramework</InnerBuildProperty>\n+      <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "I decided against generalization and went with the minimum to support the current sdk. The idea is we'll expand when necessary.\r\nIdeally, `InnerBuildProperty` would be a set of global property names that define the inner build, and `InnerBuildPropertyValues` would contain all possible values somehow:\r\n```\r\n<InnerBuildProperties>TargetFramework;TargetPlatform ...\r\n<InnerBuildPropertyValues>TargetFramework={net472;netcoreapp2.2}; TargetPlatform={win-x64;osx-x64} ...\r\n```\r\nOr, if one does not want a cross product of all values:\r\n```\r\n<InnerBuildProperties>TargetFramework;TargetPlatform ...\r\n<InnerBuildPropertyValues>\r\n  {\r\n    {TargetFramework=net472; TargetPlatform=win-x64},\r\n    {TargetFramework=netcoreapp2.2; TargetPlatform=osx-x64}\r\n  }\r\n```\r\n\r\nBut since these are not needed yet, not thinking about them speeds this current PR up. Let me know if we should think about them now though :)",
              "createdAt": "2019-03-14T22:56:16Z",
              "path": "src/Tasks/Microsoft.ManagedLanguages.targets",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff<!--\n+***********************************************************************************************\n+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\n+          created a backup copy.  Incorrect changes to this file will make it\n+          impossible to load or build your projects from the command-line or the IDE.\n+\n+This file defines common build logic for all managed languaged: C#, VisualBasic, F#\n+\n+Copyright (C) Microsoft Corporation. All rights reserved.\n+***********************************************************************************************\n+-->\n+\n+<Project>\n+   <!-- \n+        We are doing a cross-targeting build if there is a non-empty list of target frameworks specified\n+        and there is no current target framework being built individually. In that case, a crosstargeting\n+        project file like Microsoft.<language>.CrossTargeting.targets gets imported.\n+   -->\n+   <PropertyGroup Condition=\"'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''\">\n+      <IsCrossTargetingBuild>true</IsCrossTargetingBuild>\n+   </PropertyGroup>\n+\n+   <PropertyGroup>\n+      <InnerBuildProperty>TargetFramework</InnerBuildProperty>\n+      <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Another possible source of inspiration here is the Azure Pipelines YAML format for specifying a [variable matrix](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema#matrix).",
              "createdAt": "2019-03-21T15:34:26Z",
              "path": "src/Tasks/Microsoft.ManagedLanguages.targets",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff<!--\n+***********************************************************************************************\n+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\n+          created a backup copy.  Incorrect changes to this file will make it\n+          impossible to load or build your projects from the command-line or the IDE.\n+\n+This file defines common build logic for all managed languaged: C#, VisualBasic, F#\n+\n+Copyright (C) Microsoft Corporation. All rights reserved.\n+***********************************************************************************************\n+-->\n+\n+<Project>\n+   <!-- \n+        We are doing a cross-targeting build if there is a non-empty list of target frameworks specified\n+        and there is no current target framework being built individually. In that case, a crosstargeting\n+        project file like Microsoft.<language>.CrossTargeting.targets gets imported.\n+   -->\n+   <PropertyGroup Condition=\"'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''\">\n+      <IsCrossTargetingBuild>true</IsCrossTargetingBuild>\n+   </PropertyGroup>\n+\n+   <PropertyGroup>\n+      <InnerBuildProperty>TargetFramework</InnerBuildProperty>\n+      <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should we rename to `MSBuildIsGraphBuild` and make it a reserved property, so you can't set it manually?",
              "createdAt": "2019-03-14T17:21:45Z",
              "path": "src/Tasks/Microsoft.ManagedLanguages.targets",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff<!--\n+***********************************************************************************************\n+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\n+          created a backup copy.  Incorrect changes to this file will make it\n+          impossible to load or build your projects from the command-line or the IDE.\n+\n+This file defines common build logic for all managed languaged: C#, VisualBasic, F#\n+\n+Copyright (C) Microsoft Corporation. All rights reserved.\n+***********************************************************************************************\n+-->\n+\n+<Project>\n+   <!-- \n+        We are doing a cross-targeting build if there is a non-empty list of target frameworks specified\n+        and there is no current target framework being built individually. In that case, a crosstargeting\n+        project file like Microsoft.<language>.CrossTargeting.targets gets imported.\n+   -->\n+   <PropertyGroup Condition=\"'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''\">\n+      <IsCrossTargetingBuild>true</IsCrossTargetingBuild>\n+   </PropertyGroup>\n+\n+   <PropertyGroup>\n+      <InnerBuildProperty>TargetFramework</InnerBuildProperty>\n+      <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>\n+   </PropertyGroup>\n+\n+   <PropertyGroup Condition=\"'$(IsGraphBuild)' == 'true'\">",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "@AndyGerlicher suggests not constraining it: https://github.com/Microsoft/msbuild/pull/4143#issuecomment-461198290\r\n\r\nMaking it reserved avoids an entire class of problems that can result from people manually setting this. On the other hand, power users might enjoy carefully shooting themselves right between the toes :)",
              "createdAt": "2019-03-14T23:00:48Z",
              "path": "src/Tasks/Microsoft.ManagedLanguages.targets",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff<!--\n+***********************************************************************************************\n+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\n+          created a backup copy.  Incorrect changes to this file will make it\n+          impossible to load or build your projects from the command-line or the IDE.\n+\n+This file defines common build logic for all managed languaged: C#, VisualBasic, F#\n+\n+Copyright (C) Microsoft Corporation. All rights reserved.\n+***********************************************************************************************\n+-->\n+\n+<Project>\n+   <!-- \n+        We are doing a cross-targeting build if there is a non-empty list of target frameworks specified\n+        and there is no current target framework being built individually. In that case, a crosstargeting\n+        project file like Microsoft.<language>.CrossTargeting.targets gets imported.\n+   -->\n+   <PropertyGroup Condition=\"'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''\">\n+      <IsCrossTargetingBuild>true</IsCrossTargetingBuild>\n+   </PropertyGroup>\n+\n+   <PropertyGroup>\n+      <InnerBuildProperty>TargetFramework</InnerBuildProperty>\n+      <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>\n+   </PropertyGroup>\n+\n+   <PropertyGroup Condition=\"'$(IsGraphBuild)' == 'true'\">",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Does this do anything, or is it just for debugging purposes?",
              "createdAt": "2019-03-21T14:34:58Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -600,8 +628,232 @@ public void GetTargetListsNullEntryTargets()\n \n                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, new Dictionary<string, string[]> {{\"A\", new[] {\"B\"}}}, \"A\").Path;\n+                var root2 = CreateProjectFile(env, 2, new[] {3}, new Dictionary<string, string[]> {{\"B\", new[] {\"C\"}}, {\"X\", new[] {\"Y\"}}}, \"X\").Path;\n+                CreateProjectFile(env, 3);\n+                \n+\n+                var projectGraph = new ProjectGraph(new []{root1, root2});\n+                projectGraph.ProjectNodes.Count.ShouldBe(3);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { \"C\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Just for debugging purposes. it's quite useful to visualize the graph when something goes wrong.",
              "createdAt": "2019-03-21T17:01:34Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -600,8 +628,232 @@ public void GetTargetListsNullEntryTargets()\n \n                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, new Dictionary<string, string[]> {{\"A\", new[] {\"B\"}}}, \"A\").Path;\n+                var root2 = CreateProjectFile(env, 2, new[] {3}, new Dictionary<string, string[]> {{\"B\", new[] {\"C\"}}, {\"X\", new[] {\"Y\"}}}, \"X\").Path;\n+                CreateProjectFile(env, 3);\n+                \n+\n+                var projectGraph = new ProjectGraph(new []{root1, root2});\n+                projectGraph.ProjectNodes.Count.ShouldBe(3);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { \"C\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I think it'd help understand these tests if every call to `CreateProjectFile` used explicit argument names:\r\n\r\n```suggestion\r\n                var root1 = CreateProjectFile(\r\n                    env,\r\n                    projectNumber: 1,\r\n                    projectReferences: new[] { 2 },\r\n                    projectReferenceTargets: null,\r\n                    defaultTargets: null,\r\n                    extraContent: ProjectReferenceTargetsWithMultitargeting).Path;\r\n```",
              "createdAt": "2019-03-21T14:38:40Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -600,8 +628,232 @@ public void GetTargetListsNullEntryTargets()\n \n                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, new Dictionary<string, string[]> {{\"A\", new[] {\"B\"}}}, \"A\").Path;\n+                var root2 = CreateProjectFile(env, 2, new[] {3}, new Dictionary<string, string[]> {{\"B\", new[] {\"C\"}}, {\"X\", new[] {\"Y\"}}}, \"X\").Path;\n+                CreateProjectFile(env, 3);\n+                \n+\n+                var projectGraph = new ProjectGraph(new []{root1, root2});\n+                projectGraph.ProjectNodes.Count.ShouldBe(3);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { \"C\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Well, R# automatically displays argument names as of some recent version.\r\n![image](https://user-images.githubusercontent.com/2255729/54770540-abd24900-4bc0-11e9-876c-3df72ae1fb67.png)\r\n\r\nBut yeah, I'll add explicit arguments.",
              "createdAt": "2019-03-21T17:04:25Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -600,8 +628,232 @@ public void GetTargetListsNullEntryTargets()\n \n                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, new Dictionary<string, string[]> {{\"A\", new[] {\"B\"}}}, \"A\").Path;\n+                var root2 = CreateProjectFile(env, 2, new[] {3}, new Dictionary<string, string[]> {{\"B\", new[] {\"C\"}}, {\"X\", new[] {\"Y\"}}}, \"X\").Path;\n+                CreateProjectFile(env, 3);\n+                \n+\n+                var projectGraph = new ProjectGraph(new []{root1, root2});\n+                projectGraph.ProjectNodes.Count.ShouldBe(3);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { \"C\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "The names confused me here: I didn't grok that it meant \"possibly-multitargeting project\" instead of \"actually multitargeting project\". Maybe call it\r\n```suggestion\r\n                string singleTargetedSpec = OuterBuildSpecificationWithProjectReferenceTargets +\r\n```\r\n\r\n?",
              "createdAt": "2019-03-21T14:46:38Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -600,8 +628,232 @@ public void GetTargetListsNullEntryTargets()\n \n                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, new Dictionary<string, string[]> {{\"A\", new[] {\"B\"}}}, \"A\").Path;\n+                var root2 = CreateProjectFile(env, 2, new[] {3}, new Dictionary<string, string[]> {{\"B\", new[] {\"C\"}}, {\"X\", new[] {\"Y\"}}}, \"X\").Path;\n+                CreateProjectFile(env, 3);\n+                \n+\n+                var projectGraph = new ProjectGraph(new []{root1, root2});\n+                projectGraph.ProjectNodes.Count.ShouldBe(3);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { \"C\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListInnerBuildToInnerBuild()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                string outerBuildSpec = OuterBuildSpecificationWithProjectReferenceTargets +",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I had some confusion thinking of this as `InnerBuild`. Maybe `InnerBuildDimension` or `InnerBuildQualifier` or `InnerBuildProperty`?",
              "createdAt": "2019-03-21T14:55:40Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -6,17 +6,45 @@\n using System.Collections.Immutable;\n using System.IO;\n using System.Linq;\n+using System.Text.RegularExpressions;\n using Microsoft.Build.BackEnd;\n using Microsoft.Build.Evaluation;\n using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Shared;\n using Microsoft.Build.UnitTests;\n using Shouldly;\n using Xunit;\n+using Xunit.Abstractions;\n \n namespace Microsoft.Build.Experimental.Graph.UnitTests\n {\n-    public class ProjectGraphTests\n+    public class ProjectGraphTests : IDisposable\n     {\n+        private TestEnvironment _env;\n+\n+        private static readonly ImmutableDictionary<string, string> EmptyGlobalProperties = new Dictionary<string, string> {{PropertyNames.IsGraphBuild, \"true\"}}.ToImmutableDictionary();\n+\n+        private static readonly string InnerBuildProperty = \"InnerBuild\";",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I'm confused on this one. \r\n\r\n![image](https://user-images.githubusercontent.com/3347530/54761733-a5dc6800-4bc0-11e9-855c-dcbbafe3b930.png)\r\n\r\nWhy do we get the speculative `[p1 ib=b] -> [p6 outer]` and `[p6 ib=a]` edges? My read on https://github.com/Microsoft/msbuild/blob/56e10566f8491faab2421221f9b68b109b06a014/documentation/specs/static-graph.md#multitargeting was that only references to outer builds (subject to TF negotiation) would get the speculative links.",
              "createdAt": "2019-03-21T15:03:46Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -600,8 +628,232 @@ public void GetTargetListsNullEntryTargets()\n \n                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, new Dictionary<string, string[]> {{\"A\", new[] {\"B\"}}}, \"A\").Path;\n+                var root2 = CreateProjectFile(env, 2, new[] {3}, new Dictionary<string, string[]> {{\"B\", new[] {\"C\"}}, {\"X\", new[] {\"Y\"}}}, \"X\").Path;\n+                CreateProjectFile(env, 3);\n+                \n+\n+                var projectGraph = new ProjectGraph(new []{root1, root2});\n+                projectGraph.ProjectNodes.Count.ShouldBe(3);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { \"C\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListInnerBuildToInnerBuild()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                string outerBuildSpec = OuterBuildSpecificationWithProjectReferenceTargets +\n+                        $@\"<PropertyGroup>\n+                            <{InnerBuildProperty}>a</{InnerBuildProperty}>\n+                          </PropertyGroup>\";\n+\n+                var root1 =\n+                    CreateProjectFile(\n+                        env,\n+                        1,\n+                        new[] {2},\n+                        null,\n+                        null,\n+                        outerBuildSpec)\n+                        .Path;\n+                CreateProjectFile(\n+                    env,\n+                    2,\n+                    null,\n+                    null,\n+                    null,\n+                    outerBuildSpec);\n+                \n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2, null, null, null, OuterBuildSpecificationWithProjectReferenceTargets);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(4);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                var root = GetFirstNodeWithProjectNumber(projectGraph, 1);\n+\n+                var outerBuild = GetNodesWithProjectNumber(projectGraph, 2).First(IsOuterBuild);\n+                var innerBuilds = GetNodesWithProjectNumber(projectGraph, 2).Where(IsInnerBuild).ToArray();\n+\n+                targetLists[root].ShouldBe(new[] { \"A\" });\n+                targetLists[outerBuild].ShouldBe(OuterBuildTargets);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    targetLists[innerBuild].ShouldBe(NonOuterBuildTargets);\n+                }\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsForComplexMultitargetingGraph()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(\n+                    env,\n+                    1,\n+                    null,\n+                    null,\n+                    null,\n+                    OuterBuildSpecificationWithProjectReferenceTargets +\n+                    $@\"<ItemGroup>\n+                            <ProjectReference Include=`3.proj` Condition=`'$({InnerBuildProperty})'=='a'`/>\n+\n+                            <ProjectReference Include=`4.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`5.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`6.proj` Condition=`'$({InnerBuildProperty})'=='b'` Properties=`{InnerBuildProperty}=a`/>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "(Also, while I agree with Andy that `ToDot()` should stay internal--it's awesome :))",
              "createdAt": "2019-03-21T15:05:04Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -600,8 +628,232 @@ public void GetTargetListsNullEntryTargets()\n \n                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, new Dictionary<string, string[]> {{\"A\", new[] {\"B\"}}}, \"A\").Path;\n+                var root2 = CreateProjectFile(env, 2, new[] {3}, new Dictionary<string, string[]> {{\"B\", new[] {\"C\"}}, {\"X\", new[] {\"Y\"}}}, \"X\").Path;\n+                CreateProjectFile(env, 3);\n+                \n+\n+                var projectGraph = new ProjectGraph(new []{root1, root2});\n+                projectGraph.ProjectNodes.Count.ShouldBe(3);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { \"C\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListInnerBuildToInnerBuild()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                string outerBuildSpec = OuterBuildSpecificationWithProjectReferenceTargets +\n+                        $@\"<PropertyGroup>\n+                            <{InnerBuildProperty}>a</{InnerBuildProperty}>\n+                          </PropertyGroup>\";\n+\n+                var root1 =\n+                    CreateProjectFile(\n+                        env,\n+                        1,\n+                        new[] {2},\n+                        null,\n+                        null,\n+                        outerBuildSpec)\n+                        .Path;\n+                CreateProjectFile(\n+                    env,\n+                    2,\n+                    null,\n+                    null,\n+                    null,\n+                    outerBuildSpec);\n+                \n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2, null, null, null, OuterBuildSpecificationWithProjectReferenceTargets);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(4);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                var root = GetFirstNodeWithProjectNumber(projectGraph, 1);\n+\n+                var outerBuild = GetNodesWithProjectNumber(projectGraph, 2).First(IsOuterBuild);\n+                var innerBuilds = GetNodesWithProjectNumber(projectGraph, 2).Where(IsInnerBuild).ToArray();\n+\n+                targetLists[root].ShouldBe(new[] { \"A\" });\n+                targetLists[outerBuild].ShouldBe(OuterBuildTargets);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    targetLists[innerBuild].ShouldBe(NonOuterBuildTargets);\n+                }\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsForComplexMultitargetingGraph()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(\n+                    env,\n+                    1,\n+                    null,\n+                    null,\n+                    null,\n+                    OuterBuildSpecificationWithProjectReferenceTargets +\n+                    $@\"<ItemGroup>\n+                            <ProjectReference Include=`3.proj` Condition=`'$({InnerBuildProperty})'=='a'`/>\n+\n+                            <ProjectReference Include=`4.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`5.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`6.proj` Condition=`'$({InnerBuildProperty})'=='b'` Properties=`{InnerBuildProperty}=a`/>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Wow, good catch! It appears to be a bug. Maybe. `[p1 ib=b]` is directly referencing the inner build `[p6 ib=a]` by setting `Properties=\"InnerBuild=a\"` metadata on `ProjectReference`. But at the same time, inner builds set the inner build property as an `UndefineProperty`, to avoid propagating their TF to the references. This undefine removes the effect of `Properties=\"InnerBuild=a\"` and leads to P6 being transformed into an outer build.\r\n\r\nI'll go debug how vanilla msbuild handles this situation, and adjust to that behaviour.",
              "createdAt": "2019-03-21T20:57:32Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -600,8 +628,232 @@ public void GetTargetListsNullEntryTargets()\n \n                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, new Dictionary<string, string[]> {{\"A\", new[] {\"B\"}}}, \"A\").Path;\n+                var root2 = CreateProjectFile(env, 2, new[] {3}, new Dictionary<string, string[]> {{\"B\", new[] {\"C\"}}, {\"X\", new[] {\"Y\"}}}, \"X\").Path;\n+                CreateProjectFile(env, 3);\n+                \n+\n+                var projectGraph = new ProjectGraph(new []{root1, root2});\n+                projectGraph.ProjectNodes.Count.ShouldBe(3);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { \"C\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListInnerBuildToInnerBuild()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                string outerBuildSpec = OuterBuildSpecificationWithProjectReferenceTargets +\n+                        $@\"<PropertyGroup>\n+                            <{InnerBuildProperty}>a</{InnerBuildProperty}>\n+                          </PropertyGroup>\";\n+\n+                var root1 =\n+                    CreateProjectFile(\n+                        env,\n+                        1,\n+                        new[] {2},\n+                        null,\n+                        null,\n+                        outerBuildSpec)\n+                        .Path;\n+                CreateProjectFile(\n+                    env,\n+                    2,\n+                    null,\n+                    null,\n+                    null,\n+                    outerBuildSpec);\n+                \n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2, null, null, null, OuterBuildSpecificationWithProjectReferenceTargets);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(4);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                var root = GetFirstNodeWithProjectNumber(projectGraph, 1);\n+\n+                var outerBuild = GetNodesWithProjectNumber(projectGraph, 2).First(IsOuterBuild);\n+                var innerBuilds = GetNodesWithProjectNumber(projectGraph, 2).Where(IsInnerBuild).ToArray();\n+\n+                targetLists[root].ShouldBe(new[] { \"A\" });\n+                targetLists[outerBuild].ShouldBe(OuterBuildTargets);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    targetLists[innerBuild].ShouldBe(NonOuterBuildTargets);\n+                }\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsForComplexMultitargetingGraph()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(\n+                    env,\n+                    1,\n+                    null,\n+                    null,\n+                    null,\n+                    OuterBuildSpecificationWithProjectReferenceTargets +\n+                    $@\"<ItemGroup>\n+                            <ProjectReference Include=`3.proj` Condition=`'$({InnerBuildProperty})'=='a'`/>\n+\n+                            <ProjectReference Include=`4.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`5.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`6.proj` Condition=`'$({InnerBuildProperty})'=='b'` Properties=`{InnerBuildProperty}=a`/>",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Mkay, this is how the sdk works when inner build A(net472) references B(net462) via `Properties=\"TargetFramework=net462\"` metadata:\r\n- A gets to call B(no global props), the outer build, with `GetTargetFrameworks` (GTF) and B(net462) with Build, GetNativeManifest, etc\r\n  - Calling B(no global props) with GTF is wasted work, as the information won't get used since the Properties metadata overwrites any TF negotiation\r\n  - A(net472) calls GTF on B outer build because [TargetFramework gets explicitly removed for calls to GTF](https://github.com/Microsoft/msbuild/blob/a972ec96c3920705e4e8d03d7ac8b6c3328450bd/src/Tasks/Microsoft.Common.CurrentVersion.targets#L1642)\r\n- The scenario ends up working in reality because the [SDK does not remove `TargetFramework`](https://github.com/Microsoft/msbuild/blob/a972ec96c3920705e4e8d03d7ac8b6c3328450bd/src/Tasks/Microsoft.Common.CurrentVersion.targets#L1686-L1688) for the inner targets (Build, GetNativeManifest etc) when Nuget finds a `NearestTargetFramework` and the reference has multiple target frameworks. The static graph, on the other hand, always removes the `TargetFramework` on an inner build's references, which leads to B(net462) getting converted to an outer build instead.\r\n\r\nSo, in this case, the static graph accidentally overbuilds, which I guess is better than underbuilding, which would cause cache miss build breaks at runtime. Since having inner builds manually reference other inner builds seems like an edge case, I propose fixing it in a separate PR. Let me know if you think otherwise.\r\n\r\n",
              "createdAt": "2019-03-22T16:22:05Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -600,8 +628,232 @@ public void GetTargetListsNullEntryTargets()\n \n                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, new Dictionary<string, string[]> {{\"A\", new[] {\"B\"}}}, \"A\").Path;\n+                var root2 = CreateProjectFile(env, 2, new[] {3}, new Dictionary<string, string[]> {{\"B\", new[] {\"C\"}}, {\"X\", new[] {\"Y\"}}}, \"X\").Path;\n+                CreateProjectFile(env, 3);\n+                \n+\n+                var projectGraph = new ProjectGraph(new []{root1, root2});\n+                projectGraph.ProjectNodes.Count.ShouldBe(3);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { \"C\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListInnerBuildToInnerBuild()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                string outerBuildSpec = OuterBuildSpecificationWithProjectReferenceTargets +\n+                        $@\"<PropertyGroup>\n+                            <{InnerBuildProperty}>a</{InnerBuildProperty}>\n+                          </PropertyGroup>\";\n+\n+                var root1 =\n+                    CreateProjectFile(\n+                        env,\n+                        1,\n+                        new[] {2},\n+                        null,\n+                        null,\n+                        outerBuildSpec)\n+                        .Path;\n+                CreateProjectFile(\n+                    env,\n+                    2,\n+                    null,\n+                    null,\n+                    null,\n+                    outerBuildSpec);\n+                \n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2, null, null, null, OuterBuildSpecificationWithProjectReferenceTargets);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(4);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                var root = GetFirstNodeWithProjectNumber(projectGraph, 1);\n+\n+                var outerBuild = GetNodesWithProjectNumber(projectGraph, 2).First(IsOuterBuild);\n+                var innerBuilds = GetNodesWithProjectNumber(projectGraph, 2).Where(IsInnerBuild).ToArray();\n+\n+                targetLists[root].ShouldBe(new[] { \"A\" });\n+                targetLists[outerBuild].ShouldBe(OuterBuildTargets);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    targetLists[innerBuild].ShouldBe(NonOuterBuildTargets);\n+                }\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsForComplexMultitargetingGraph()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(\n+                    env,\n+                    1,\n+                    null,\n+                    null,\n+                    null,\n+                    OuterBuildSpecificationWithProjectReferenceTargets +\n+                    $@\"<ItemGroup>\n+                            <ProjectReference Include=`3.proj` Condition=`'$({InnerBuildProperty})'=='a'`/>\n+\n+                            <ProjectReference Include=`4.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`5.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`6.proj` Condition=`'$({InnerBuildProperty})'=='b'` Properties=`{InnerBuildProperty}=a`/>",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Separate PR sounds fine--can you file an issue please?",
              "createdAt": "2019-03-22T19:12:47Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -600,8 +628,232 @@ public void GetTargetListsNullEntryTargets()\n \n                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, new Dictionary<string, string[]> {{\"A\", new[] {\"B\"}}}, \"A\").Path;\n+                var root2 = CreateProjectFile(env, 2, new[] {3}, new Dictionary<string, string[]> {{\"B\", new[] {\"C\"}}, {\"X\", new[] {\"Y\"}}}, \"X\").Path;\n+                CreateProjectFile(env, 3);\n+                \n+\n+                var projectGraph = new ProjectGraph(new []{root1, root2});\n+                projectGraph.ProjectNodes.Count.ShouldBe(3);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { \"C\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListInnerBuildToInnerBuild()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                string outerBuildSpec = OuterBuildSpecificationWithProjectReferenceTargets +\n+                        $@\"<PropertyGroup>\n+                            <{InnerBuildProperty}>a</{InnerBuildProperty}>\n+                          </PropertyGroup>\";\n+\n+                var root1 =\n+                    CreateProjectFile(\n+                        env,\n+                        1,\n+                        new[] {2},\n+                        null,\n+                        null,\n+                        outerBuildSpec)\n+                        .Path;\n+                CreateProjectFile(\n+                    env,\n+                    2,\n+                    null,\n+                    null,\n+                    null,\n+                    outerBuildSpec);\n+                \n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2, null, null, null, OuterBuildSpecificationWithProjectReferenceTargets);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(4);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                var root = GetFirstNodeWithProjectNumber(projectGraph, 1);\n+\n+                var outerBuild = GetNodesWithProjectNumber(projectGraph, 2).First(IsOuterBuild);\n+                var innerBuilds = GetNodesWithProjectNumber(projectGraph, 2).Where(IsInnerBuild).ToArray();\n+\n+                targetLists[root].ShouldBe(new[] { \"A\" });\n+                targetLists[outerBuild].ShouldBe(OuterBuildTargets);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    targetLists[innerBuild].ShouldBe(NonOuterBuildTargets);\n+                }\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsForComplexMultitargetingGraph()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(\n+                    env,\n+                    1,\n+                    null,\n+                    null,\n+                    null,\n+                    OuterBuildSpecificationWithProjectReferenceTargets +\n+                    $@\"<ItemGroup>\n+                            <ProjectReference Include=`3.proj` Condition=`'$({InnerBuildProperty})'=='a'`/>\n+\n+                            <ProjectReference Include=`4.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`5.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`6.proj` Condition=`'$({InnerBuildProperty})'=='b'` Properties=`{InnerBuildProperty}=a`/>",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "https://github.com/Microsoft/msbuild/issues/4262",
              "createdAt": "2019-03-22T22:26:25Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -600,8 +628,232 @@ public void GetTargetListsNullEntryTargets()\n \n                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, new Dictionary<string, string[]> {{\"A\", new[] {\"B\"}}}, \"A\").Path;\n+                var root2 = CreateProjectFile(env, 2, new[] {3}, new Dictionary<string, string[]> {{\"B\", new[] {\"C\"}}, {\"X\", new[] {\"Y\"}}}, \"X\").Path;\n+                CreateProjectFile(env, 3);\n+                \n+\n+                var projectGraph = new ProjectGraph(new []{root1, root2});\n+                projectGraph.ProjectNodes.Count.ShouldBe(3);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { \"B\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { \"C\" });\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetsListInnerBuildToInnerBuild()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                string outerBuildSpec = OuterBuildSpecificationWithProjectReferenceTargets +\n+                        $@\"<PropertyGroup>\n+                            <{InnerBuildProperty}>a</{InnerBuildProperty}>\n+                          </PropertyGroup>\";\n+\n+                var root1 =\n+                    CreateProjectFile(\n+                        env,\n+                        1,\n+                        new[] {2},\n+                        null,\n+                        null,\n+                        outerBuildSpec)\n+                        .Path;\n+                CreateProjectFile(\n+                    env,\n+                    2,\n+                    null,\n+                    null,\n+                    null,\n+                    outerBuildSpec);\n+                \n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(2);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { \"A\" });\n+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(NonOuterBuildTargets);\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(env, 1, new[] {2}, null, null, ProjectReferenceTargetsWithMultitargeting).Path;\n+                CreateProjectFile(env, 2, null, null, null, OuterBuildSpecificationWithProjectReferenceTargets);\n+                \n+                var projectGraph = new ProjectGraph(root1);\n+\n+                var dot = projectGraph.ToDot();\n+\n+                projectGraph.ProjectNodes.Count.ShouldBe(4);\n+\n+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string>{\"A\"});\n+\n+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);\n+                var root = GetFirstNodeWithProjectNumber(projectGraph, 1);\n+\n+                var outerBuild = GetNodesWithProjectNumber(projectGraph, 2).First(IsOuterBuild);\n+                var innerBuilds = GetNodesWithProjectNumber(projectGraph, 2).Where(IsInnerBuild).ToArray();\n+\n+                targetLists[root].ShouldBe(new[] { \"A\" });\n+                targetLists[outerBuild].ShouldBe(OuterBuildTargets);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    targetLists[innerBuild].ShouldBe(NonOuterBuildTargets);\n+                }\n+            }\n+        }\n+\n+        [Fact]\n+        public void GetTargetListsForComplexMultitargetingGraph()\n+        {\n+            using (var env = TestEnvironment.Create())\n+            {\n+                var root1 = CreateProjectFile(\n+                    env,\n+                    1,\n+                    null,\n+                    null,\n+                    null,\n+                    OuterBuildSpecificationWithProjectReferenceTargets +\n+                    $@\"<ItemGroup>\n+                            <ProjectReference Include=`3.proj` Condition=`'$({InnerBuildProperty})'=='a'`/>\n+\n+                            <ProjectReference Include=`4.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`5.proj` Condition=`'$({InnerBuildProperty})'=='b'`/>\n+                            <ProjectReference Include=`6.proj` Condition=`'$({InnerBuildProperty})'=='b'` Properties=`{InnerBuildProperty}=a`/>",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        public void NonMultitargetingBuildProjectsInTheMiddle()\r\n```\r\n?",
              "createdAt": "2019-03-21T15:15:14Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -842,14 +1094,486 @@ public void TopologicalSortShouldTopologicallySort(Dictionary<int, int[]> edges)\n             }\n         }\n \n-        private static ProjectGraphNode GetNodeForProject(ProjectGraph graph, int projectNum) => graph.ProjectNodes.First(node => node.ProjectInstance.FullPath.EndsWith(projectNum + \".proj\"));\n+        [Theory]\n+        [MemberData(nameof(Graphs))]\n+        public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)\n+        {\n+            var graph = Helpers.CreateProjectGraph(\n+                _env,\n+                edges,\n+                new Dictionary<string, string> {{\"a\", \"b\"}});\n+\n+\n+            Func<ProjectGraphNode, string> nodeIdProvider = GetProjectFileName;\n+\n+            var dot = graph.ToDot(nodeIdProvider);\n+\n+            var edgeCount = 0;\n+\n+            foreach (var node in graph.ProjectNodes)\n+            {\n+                var nodeId = nodeIdProvider(node);\n+\n+                foreach (var globalProperty in node.ProjectInstance.GlobalProperties)\n+                {\n+                    dot.ShouldMatch($@\"{nodeId}\\s*\\[.*{globalProperty.Key}.*{globalProperty.Value}.*\\]\");\n+                }\n+\n+                foreach (var reference in node.ProjectReferences)\n+                {\n+                    edgeCount++;\n+                    dot.ShouldMatch($@\"{nodeId}\\s*->\\s*{nodeIdProvider(reference)}\");\n+                }\n+            }\n+\n+            // edge count\n+            Regex.Matches(dot,\"->\").Count.ShouldBe(edgeCount);\n+\n+            // node count\n+            Regex.Matches(dot,\"label\").Count.ShouldBe(graph.ProjectNodes.Count);\n+        }\n+\n+        private static void AssertOuterBuildAsRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ReferencingProjects.ShouldBeEmpty();\n+            outerBuild.ProjectReferences.Count.ShouldBe(2);\n+\n+            foreach (var innerBuild in outerBuild.ProjectReferences)\n+            {\n+                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+            }\n+        }\n+\n+        private static void AssertOuterBuildAsNonRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ProjectReferences.ShouldBeEmpty();\n+            outerBuild.ReferencingProjects.ShouldNotBeEmpty();\n+\n+            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)\n+            {\n+                var innerBuilds =\n+                    outerBuildReferencer.ProjectReferences.Where(\n+                        p =>\n+                            IsInnerBuild(p)\n+                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();\n+\n+                innerBuilds.Length.ShouldBe(2);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+                }\n+            }\n+        }\n+\n+        private static bool IsOuterBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;\n+        }\n+\n+        private static bool IsInnerBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;\n+        }\n+\n+        private static bool IsNotMultitargeting(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonMultitargeting;\n+        }\n+\n+        private static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            IsNotMultitargeting(node).ShouldBeTrue();\n+            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+            node.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+        }\n+\n+        private static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(outerBuild).ShouldBeTrue();\n+            IsInnerBuild(outerBuild).ShouldBeFalse();\n+\n+            outerBuild.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+        }\n+\n+        private static void AssertInnerBuildEvaluation(\n+            ProjectGraphNode innerBuild,\n+            bool InnerBuildPropertyIsSetViaGlobalProperty,\n+            Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(innerBuild).ShouldBeFalse();\n+            IsInnerBuild(innerBuild).ShouldBeTrue();\n+\n+            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildProperty);\n+\n+            innerBuildPropertyValue.ShouldNotBeNullOrEmpty();\n+\n+            if (InnerBuildPropertyIsSetViaGlobalProperty)\n+            {\n+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(\n+                    EmptyGlobalProperties\n+                        .Add(InnerBuildProperty, innerBuildPropertyValue)\n+                        .AddRange(additionalGlobalProperties));\n+            }\n+        }\n+\n+        [Fact]\n+        public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()\n+        {\n+            var projectFile = _env.CreateTestProjectWithFiles($@\"<Project>{OuterBuildSpecification}</Project>\").ProjectFile;\n+\n+            var graph = new ProjectGraph(projectFile);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(3);\n+            \n+            var outerBuild = graph.GraphRoots.First();\n+\n+            AssertOuterBuildAsRoot(outerBuild);\n+        }\n+\n+        [Fact]\n+        public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGlobalProperties()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(4);\n+\n+            AssertOuterBuildAsRoot(graph.GraphRoots.First());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var innerBuildViaLocalProperty = OuterBuildSpecification + $\"<PropertyGroup><{InnerBuildProperty}>foo</{InnerBuildProperty}></PropertyGroup>\";\n+\n+            var root = CreateProjectFile(\n+                _env,\n+                1,\n+                new[] {2},\n+                null,\n+                null,\n+                innerBuildViaLocalProperty).Path;\n+\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), false, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root, new Dictionary<string, string>{{InnerBuildProperty, \"foo\"}});\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), true, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void NonOuterBuildProjectsInTheMiddle()",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Also assert 2 inner builds of p4?",
              "createdAt": "2019-03-21T15:16:09Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -842,14 +1094,486 @@ public void TopologicalSortShouldTopologicallySort(Dictionary<int, int[]> edges)\n             }\n         }\n \n-        private static ProjectGraphNode GetNodeForProject(ProjectGraph graph, int projectNum) => graph.ProjectNodes.First(node => node.ProjectInstance.FullPath.EndsWith(projectNum + \".proj\"));\n+        [Theory]\n+        [MemberData(nameof(Graphs))]\n+        public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)\n+        {\n+            var graph = Helpers.CreateProjectGraph(\n+                _env,\n+                edges,\n+                new Dictionary<string, string> {{\"a\", \"b\"}});\n+\n+\n+            Func<ProjectGraphNode, string> nodeIdProvider = GetProjectFileName;\n+\n+            var dot = graph.ToDot(nodeIdProvider);\n+\n+            var edgeCount = 0;\n+\n+            foreach (var node in graph.ProjectNodes)\n+            {\n+                var nodeId = nodeIdProvider(node);\n+\n+                foreach (var globalProperty in node.ProjectInstance.GlobalProperties)\n+                {\n+                    dot.ShouldMatch($@\"{nodeId}\\s*\\[.*{globalProperty.Key}.*{globalProperty.Value}.*\\]\");\n+                }\n+\n+                foreach (var reference in node.ProjectReferences)\n+                {\n+                    edgeCount++;\n+                    dot.ShouldMatch($@\"{nodeId}\\s*->\\s*{nodeIdProvider(reference)}\");\n+                }\n+            }\n+\n+            // edge count\n+            Regex.Matches(dot,\"->\").Count.ShouldBe(edgeCount);\n+\n+            // node count\n+            Regex.Matches(dot,\"label\").Count.ShouldBe(graph.ProjectNodes.Count);\n+        }\n+\n+        private static void AssertOuterBuildAsRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ReferencingProjects.ShouldBeEmpty();\n+            outerBuild.ProjectReferences.Count.ShouldBe(2);\n+\n+            foreach (var innerBuild in outerBuild.ProjectReferences)\n+            {\n+                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+            }\n+        }\n+\n+        private static void AssertOuterBuildAsNonRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ProjectReferences.ShouldBeEmpty();\n+            outerBuild.ReferencingProjects.ShouldNotBeEmpty();\n+\n+            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)\n+            {\n+                var innerBuilds =\n+                    outerBuildReferencer.ProjectReferences.Where(\n+                        p =>\n+                            IsInnerBuild(p)\n+                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();\n+\n+                innerBuilds.Length.ShouldBe(2);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+                }\n+            }\n+        }\n+\n+        private static bool IsOuterBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;\n+        }\n+\n+        private static bool IsInnerBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;\n+        }\n+\n+        private static bool IsNotMultitargeting(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonMultitargeting;\n+        }\n+\n+        private static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            IsNotMultitargeting(node).ShouldBeTrue();\n+            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+            node.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+        }\n+\n+        private static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(outerBuild).ShouldBeTrue();\n+            IsInnerBuild(outerBuild).ShouldBeFalse();\n+\n+            outerBuild.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+        }\n+\n+        private static void AssertInnerBuildEvaluation(\n+            ProjectGraphNode innerBuild,\n+            bool InnerBuildPropertyIsSetViaGlobalProperty,\n+            Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(innerBuild).ShouldBeFalse();\n+            IsInnerBuild(innerBuild).ShouldBeTrue();\n+\n+            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildProperty);\n+\n+            innerBuildPropertyValue.ShouldNotBeNullOrEmpty();\n+\n+            if (InnerBuildPropertyIsSetViaGlobalProperty)\n+            {\n+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(\n+                    EmptyGlobalProperties\n+                        .Add(InnerBuildProperty, innerBuildPropertyValue)\n+                        .AddRange(additionalGlobalProperties));\n+            }\n+        }\n+\n+        [Fact]\n+        public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()\n+        {\n+            var projectFile = _env.CreateTestProjectWithFiles($@\"<Project>{OuterBuildSpecification}</Project>\").ProjectFile;\n+\n+            var graph = new ProjectGraph(projectFile);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(3);\n+            \n+            var outerBuild = graph.GraphRoots.First();\n+\n+            AssertOuterBuildAsRoot(outerBuild);\n+        }\n+\n+        [Fact]\n+        public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGlobalProperties()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(4);\n+\n+            AssertOuterBuildAsRoot(graph.GraphRoots.First());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var innerBuildViaLocalProperty = OuterBuildSpecification + $\"<PropertyGroup><{InnerBuildProperty}>foo</{InnerBuildProperty}></PropertyGroup>\";\n+\n+            var root = CreateProjectFile(\n+                _env,\n+                1,\n+                new[] {2},\n+                null,\n+                null,\n+                innerBuildViaLocalProperty).Path;\n+\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), false, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root, new Dictionary<string, string>{{InnerBuildProperty, \"foo\"}});\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), true, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void NonOuterBuildProjectsInTheMiddle()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2, 3}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2, new[] {4});\n+            CreateProjectFile(_env, 3, new[] {4});\n+            CreateProjectFile(_env, 4, null, null, null, OuterBuildSpecification);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(8);\n+\n+            AssertOuterBuildAsRoot(graph.GraphRoots.First());\n+            AssertOuterBuildAsNonRoot(GetNodesWithProjectNumber(graph, 4).First(IsOuterBuild));",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Already asserted in the two `AssertOuterBuildAs*` methods.",
              "createdAt": "2019-03-22T16:55:17Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -842,14 +1094,486 @@ public void TopologicalSortShouldTopologicallySort(Dictionary<int, int[]> edges)\n             }\n         }\n \n-        private static ProjectGraphNode GetNodeForProject(ProjectGraph graph, int projectNum) => graph.ProjectNodes.First(node => node.ProjectInstance.FullPath.EndsWith(projectNum + \".proj\"));\n+        [Theory]\n+        [MemberData(nameof(Graphs))]\n+        public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)\n+        {\n+            var graph = Helpers.CreateProjectGraph(\n+                _env,\n+                edges,\n+                new Dictionary<string, string> {{\"a\", \"b\"}});\n+\n+\n+            Func<ProjectGraphNode, string> nodeIdProvider = GetProjectFileName;\n+\n+            var dot = graph.ToDot(nodeIdProvider);\n+\n+            var edgeCount = 0;\n+\n+            foreach (var node in graph.ProjectNodes)\n+            {\n+                var nodeId = nodeIdProvider(node);\n+\n+                foreach (var globalProperty in node.ProjectInstance.GlobalProperties)\n+                {\n+                    dot.ShouldMatch($@\"{nodeId}\\s*\\[.*{globalProperty.Key}.*{globalProperty.Value}.*\\]\");\n+                }\n+\n+                foreach (var reference in node.ProjectReferences)\n+                {\n+                    edgeCount++;\n+                    dot.ShouldMatch($@\"{nodeId}\\s*->\\s*{nodeIdProvider(reference)}\");\n+                }\n+            }\n+\n+            // edge count\n+            Regex.Matches(dot,\"->\").Count.ShouldBe(edgeCount);\n+\n+            // node count\n+            Regex.Matches(dot,\"label\").Count.ShouldBe(graph.ProjectNodes.Count);\n+        }\n+\n+        private static void AssertOuterBuildAsRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ReferencingProjects.ShouldBeEmpty();\n+            outerBuild.ProjectReferences.Count.ShouldBe(2);\n+\n+            foreach (var innerBuild in outerBuild.ProjectReferences)\n+            {\n+                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+            }\n+        }\n+\n+        private static void AssertOuterBuildAsNonRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ProjectReferences.ShouldBeEmpty();\n+            outerBuild.ReferencingProjects.ShouldNotBeEmpty();\n+\n+            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)\n+            {\n+                var innerBuilds =\n+                    outerBuildReferencer.ProjectReferences.Where(\n+                        p =>\n+                            IsInnerBuild(p)\n+                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();\n+\n+                innerBuilds.Length.ShouldBe(2);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+                }\n+            }\n+        }\n+\n+        private static bool IsOuterBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;\n+        }\n+\n+        private static bool IsInnerBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;\n+        }\n+\n+        private static bool IsNotMultitargeting(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonMultitargeting;\n+        }\n+\n+        private static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            IsNotMultitargeting(node).ShouldBeTrue();\n+            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+            node.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+        }\n+\n+        private static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(outerBuild).ShouldBeTrue();\n+            IsInnerBuild(outerBuild).ShouldBeFalse();\n+\n+            outerBuild.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+        }\n+\n+        private static void AssertInnerBuildEvaluation(\n+            ProjectGraphNode innerBuild,\n+            bool InnerBuildPropertyIsSetViaGlobalProperty,\n+            Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(innerBuild).ShouldBeFalse();\n+            IsInnerBuild(innerBuild).ShouldBeTrue();\n+\n+            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildProperty);\n+\n+            innerBuildPropertyValue.ShouldNotBeNullOrEmpty();\n+\n+            if (InnerBuildPropertyIsSetViaGlobalProperty)\n+            {\n+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(\n+                    EmptyGlobalProperties\n+                        .Add(InnerBuildProperty, innerBuildPropertyValue)\n+                        .AddRange(additionalGlobalProperties));\n+            }\n+        }\n+\n+        [Fact]\n+        public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()\n+        {\n+            var projectFile = _env.CreateTestProjectWithFiles($@\"<Project>{OuterBuildSpecification}</Project>\").ProjectFile;\n+\n+            var graph = new ProjectGraph(projectFile);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(3);\n+            \n+            var outerBuild = graph.GraphRoots.First();\n+\n+            AssertOuterBuildAsRoot(outerBuild);\n+        }\n+\n+        [Fact]\n+        public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGlobalProperties()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(4);\n+\n+            AssertOuterBuildAsRoot(graph.GraphRoots.First());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var innerBuildViaLocalProperty = OuterBuildSpecification + $\"<PropertyGroup><{InnerBuildProperty}>foo</{InnerBuildProperty}></PropertyGroup>\";\n+\n+            var root = CreateProjectFile(\n+                _env,\n+                1,\n+                new[] {2},\n+                null,\n+                null,\n+                innerBuildViaLocalProperty).Path;\n+\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), false, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root, new Dictionary<string, string>{{InnerBuildProperty, \"foo\"}});\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), true, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void NonOuterBuildProjectsInTheMiddle()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2, 3}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2, new[] {4});\n+            CreateProjectFile(_env, 3, new[] {4});\n+            CreateProjectFile(_env, 4, null, null, null, OuterBuildSpecification);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(8);\n+\n+            AssertOuterBuildAsRoot(graph.GraphRoots.First());\n+            AssertOuterBuildAsNonRoot(GetNodesWithProjectNumber(graph, 4).First(IsOuterBuild));",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why does this not produce 4outer->4innerA,4innerB edges?\r\n\r\n![image](https://user-images.githubusercontent.com/3347530/54762835-d9b88d00-4bc2-11e9-9704-2034555671bd.png)\r\n",
              "createdAt": "2019-03-21T15:19:48Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -842,14 +1094,486 @@ public void TopologicalSortShouldTopologicallySort(Dictionary<int, int[]> edges)\n             }\n         }\n \n-        private static ProjectGraphNode GetNodeForProject(ProjectGraph graph, int projectNum) => graph.ProjectNodes.First(node => node.ProjectInstance.FullPath.EndsWith(projectNum + \".proj\"));\n+        [Theory]\n+        [MemberData(nameof(Graphs))]\n+        public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)\n+        {\n+            var graph = Helpers.CreateProjectGraph(\n+                _env,\n+                edges,\n+                new Dictionary<string, string> {{\"a\", \"b\"}});\n+\n+\n+            Func<ProjectGraphNode, string> nodeIdProvider = GetProjectFileName;\n+\n+            var dot = graph.ToDot(nodeIdProvider);\n+\n+            var edgeCount = 0;\n+\n+            foreach (var node in graph.ProjectNodes)\n+            {\n+                var nodeId = nodeIdProvider(node);\n+\n+                foreach (var globalProperty in node.ProjectInstance.GlobalProperties)\n+                {\n+                    dot.ShouldMatch($@\"{nodeId}\\s*\\[.*{globalProperty.Key}.*{globalProperty.Value}.*\\]\");\n+                }\n+\n+                foreach (var reference in node.ProjectReferences)\n+                {\n+                    edgeCount++;\n+                    dot.ShouldMatch($@\"{nodeId}\\s*->\\s*{nodeIdProvider(reference)}\");\n+                }\n+            }\n+\n+            // edge count\n+            Regex.Matches(dot,\"->\").Count.ShouldBe(edgeCount);\n+\n+            // node count\n+            Regex.Matches(dot,\"label\").Count.ShouldBe(graph.ProjectNodes.Count);\n+        }\n+\n+        private static void AssertOuterBuildAsRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ReferencingProjects.ShouldBeEmpty();\n+            outerBuild.ProjectReferences.Count.ShouldBe(2);\n+\n+            foreach (var innerBuild in outerBuild.ProjectReferences)\n+            {\n+                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+            }\n+        }\n+\n+        private static void AssertOuterBuildAsNonRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ProjectReferences.ShouldBeEmpty();\n+            outerBuild.ReferencingProjects.ShouldNotBeEmpty();\n+\n+            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)\n+            {\n+                var innerBuilds =\n+                    outerBuildReferencer.ProjectReferences.Where(\n+                        p =>\n+                            IsInnerBuild(p)\n+                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();\n+\n+                innerBuilds.Length.ShouldBe(2);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+                }\n+            }\n+        }\n+\n+        private static bool IsOuterBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;\n+        }\n+\n+        private static bool IsInnerBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;\n+        }\n+\n+        private static bool IsNotMultitargeting(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonMultitargeting;\n+        }\n+\n+        private static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            IsNotMultitargeting(node).ShouldBeTrue();\n+            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+            node.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+        }\n+\n+        private static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(outerBuild).ShouldBeTrue();\n+            IsInnerBuild(outerBuild).ShouldBeFalse();\n+\n+            outerBuild.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+        }\n+\n+        private static void AssertInnerBuildEvaluation(\n+            ProjectGraphNode innerBuild,\n+            bool InnerBuildPropertyIsSetViaGlobalProperty,\n+            Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(innerBuild).ShouldBeFalse();\n+            IsInnerBuild(innerBuild).ShouldBeTrue();\n+\n+            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildProperty);\n+\n+            innerBuildPropertyValue.ShouldNotBeNullOrEmpty();\n+\n+            if (InnerBuildPropertyIsSetViaGlobalProperty)\n+            {\n+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(\n+                    EmptyGlobalProperties\n+                        .Add(InnerBuildProperty, innerBuildPropertyValue)\n+                        .AddRange(additionalGlobalProperties));\n+            }\n+        }\n+\n+        [Fact]\n+        public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()\n+        {\n+            var projectFile = _env.CreateTestProjectWithFiles($@\"<Project>{OuterBuildSpecification}</Project>\").ProjectFile;\n+\n+            var graph = new ProjectGraph(projectFile);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(3);\n+            \n+            var outerBuild = graph.GraphRoots.First();\n+\n+            AssertOuterBuildAsRoot(outerBuild);\n+        }\n+\n+        [Fact]\n+        public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGlobalProperties()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(4);\n+\n+            AssertOuterBuildAsRoot(graph.GraphRoots.First());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var innerBuildViaLocalProperty = OuterBuildSpecification + $\"<PropertyGroup><{InnerBuildProperty}>foo</{InnerBuildProperty}></PropertyGroup>\";\n+\n+            var root = CreateProjectFile(\n+                _env,\n+                1,\n+                new[] {2},\n+                null,\n+                null,\n+                innerBuildViaLocalProperty).Path;\n+\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), false, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root, new Dictionary<string, string>{{InnerBuildProperty, \"foo\"}});\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), true, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void NonOuterBuildProjectsInTheMiddle()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2, 3}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2, new[] {4});\n+            CreateProjectFile(_env, 3, new[] {4});\n+            CreateProjectFile(_env, 4, null, null, null, OuterBuildSpecification);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(8);\n+\n+            AssertOuterBuildAsRoot(graph.GraphRoots.First());\n+            AssertOuterBuildAsNonRoot(GetNodesWithProjectNumber(graph, 4).First(IsOuterBuild));\n+\n+            AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2));\n+            AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));\n+        }\n+\n+        [Fact]\n+        public void InnerBuildsCanHaveSeparateReferences()\n+        {\n+            var extraInnerBuildReferenceSpec = OuterBuildSpecification +\n+                                          $@\"<ItemGroup>\n+                                                <ProjectReference Condition=`'$({InnerBuildProperty})'=='b'` Include=`4.proj;5.proj`/>\n+                                            </ItemGroup>\".Cleanup();\n+\n+            var root = CreateProjectFile(_env, 1, new[] {2, 3}, null, null, extraInnerBuildReferenceSpec).Path;\n+            CreateProjectFile(_env, 2, null, null, null, OuterBuildSpecification);\n+            CreateProjectFile(_env, 3);\n+            CreateProjectFile(_env, 4, null, null, null, OuterBuildSpecification);",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Answered in https://github.com/Microsoft/msbuild/pull/4218#discussion_r267830872 right?",
              "createdAt": "2019-03-22T17:06:53Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -842,14 +1094,486 @@ public void TopologicalSortShouldTopologicallySort(Dictionary<int, int[]> edges)\n             }\n         }\n \n-        private static ProjectGraphNode GetNodeForProject(ProjectGraph graph, int projectNum) => graph.ProjectNodes.First(node => node.ProjectInstance.FullPath.EndsWith(projectNum + \".proj\"));\n+        [Theory]\n+        [MemberData(nameof(Graphs))]\n+        public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)\n+        {\n+            var graph = Helpers.CreateProjectGraph(\n+                _env,\n+                edges,\n+                new Dictionary<string, string> {{\"a\", \"b\"}});\n+\n+\n+            Func<ProjectGraphNode, string> nodeIdProvider = GetProjectFileName;\n+\n+            var dot = graph.ToDot(nodeIdProvider);\n+\n+            var edgeCount = 0;\n+\n+            foreach (var node in graph.ProjectNodes)\n+            {\n+                var nodeId = nodeIdProvider(node);\n+\n+                foreach (var globalProperty in node.ProjectInstance.GlobalProperties)\n+                {\n+                    dot.ShouldMatch($@\"{nodeId}\\s*\\[.*{globalProperty.Key}.*{globalProperty.Value}.*\\]\");\n+                }\n+\n+                foreach (var reference in node.ProjectReferences)\n+                {\n+                    edgeCount++;\n+                    dot.ShouldMatch($@\"{nodeId}\\s*->\\s*{nodeIdProvider(reference)}\");\n+                }\n+            }\n+\n+            // edge count\n+            Regex.Matches(dot,\"->\").Count.ShouldBe(edgeCount);\n+\n+            // node count\n+            Regex.Matches(dot,\"label\").Count.ShouldBe(graph.ProjectNodes.Count);\n+        }\n+\n+        private static void AssertOuterBuildAsRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ReferencingProjects.ShouldBeEmpty();\n+            outerBuild.ProjectReferences.Count.ShouldBe(2);\n+\n+            foreach (var innerBuild in outerBuild.ProjectReferences)\n+            {\n+                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+            }\n+        }\n+\n+        private static void AssertOuterBuildAsNonRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ProjectReferences.ShouldBeEmpty();\n+            outerBuild.ReferencingProjects.ShouldNotBeEmpty();\n+\n+            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)\n+            {\n+                var innerBuilds =\n+                    outerBuildReferencer.ProjectReferences.Where(\n+                        p =>\n+                            IsInnerBuild(p)\n+                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();\n+\n+                innerBuilds.Length.ShouldBe(2);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+                }\n+            }\n+        }\n+\n+        private static bool IsOuterBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;\n+        }\n+\n+        private static bool IsInnerBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;\n+        }\n+\n+        private static bool IsNotMultitargeting(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonMultitargeting;\n+        }\n+\n+        private static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            IsNotMultitargeting(node).ShouldBeTrue();\n+            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+            node.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+        }\n+\n+        private static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(outerBuild).ShouldBeTrue();\n+            IsInnerBuild(outerBuild).ShouldBeFalse();\n+\n+            outerBuild.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+        }\n+\n+        private static void AssertInnerBuildEvaluation(\n+            ProjectGraphNode innerBuild,\n+            bool InnerBuildPropertyIsSetViaGlobalProperty,\n+            Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(innerBuild).ShouldBeFalse();\n+            IsInnerBuild(innerBuild).ShouldBeTrue();\n+\n+            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildProperty);\n+\n+            innerBuildPropertyValue.ShouldNotBeNullOrEmpty();\n+\n+            if (InnerBuildPropertyIsSetViaGlobalProperty)\n+            {\n+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(\n+                    EmptyGlobalProperties\n+                        .Add(InnerBuildProperty, innerBuildPropertyValue)\n+                        .AddRange(additionalGlobalProperties));\n+            }\n+        }\n+\n+        [Fact]\n+        public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()\n+        {\n+            var projectFile = _env.CreateTestProjectWithFiles($@\"<Project>{OuterBuildSpecification}</Project>\").ProjectFile;\n+\n+            var graph = new ProjectGraph(projectFile);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(3);\n+            \n+            var outerBuild = graph.GraphRoots.First();\n+\n+            AssertOuterBuildAsRoot(outerBuild);\n+        }\n+\n+        [Fact]\n+        public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGlobalProperties()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(4);\n+\n+            AssertOuterBuildAsRoot(graph.GraphRoots.First());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var innerBuildViaLocalProperty = OuterBuildSpecification + $\"<PropertyGroup><{InnerBuildProperty}>foo</{InnerBuildProperty}></PropertyGroup>\";\n+\n+            var root = CreateProjectFile(\n+                _env,\n+                1,\n+                new[] {2},\n+                null,\n+                null,\n+                innerBuildViaLocalProperty).Path;\n+\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), false, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root, new Dictionary<string, string>{{InnerBuildProperty, \"foo\"}});\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), true, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void NonOuterBuildProjectsInTheMiddle()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2, 3}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2, new[] {4});\n+            CreateProjectFile(_env, 3, new[] {4});\n+            CreateProjectFile(_env, 4, null, null, null, OuterBuildSpecification);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(8);\n+\n+            AssertOuterBuildAsRoot(graph.GraphRoots.First());\n+            AssertOuterBuildAsNonRoot(GetNodesWithProjectNumber(graph, 4).First(IsOuterBuild));\n+\n+            AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2));\n+            AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));\n+        }\n+\n+        [Fact]\n+        public void InnerBuildsCanHaveSeparateReferences()\n+        {\n+            var extraInnerBuildReferenceSpec = OuterBuildSpecification +\n+                                          $@\"<ItemGroup>\n+                                                <ProjectReference Condition=`'$({InnerBuildProperty})'=='b'` Include=`4.proj;5.proj`/>\n+                                            </ItemGroup>\".Cleanup();\n+\n+            var root = CreateProjectFile(_env, 1, new[] {2, 3}, null, null, extraInnerBuildReferenceSpec).Path;\n+            CreateProjectFile(_env, 2, null, null, null, OuterBuildSpecification);\n+            CreateProjectFile(_env, 3);\n+            CreateProjectFile(_env, 4, null, null, null, OuterBuildSpecification);",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Yes",
              "createdAt": "2019-03-22T19:10:37Z",
              "path": "src/Build.UnitTests/Graph/ProjectGraph_Tests.cs",
              "diffHunk": "@@ -842,14 +1094,486 @@ public void TopologicalSortShouldTopologicallySort(Dictionary<int, int[]> edges)\n             }\n         }\n \n-        private static ProjectGraphNode GetNodeForProject(ProjectGraph graph, int projectNum) => graph.ProjectNodes.First(node => node.ProjectInstance.FullPath.EndsWith(projectNum + \".proj\"));\n+        [Theory]\n+        [MemberData(nameof(Graphs))]\n+        public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)\n+        {\n+            var graph = Helpers.CreateProjectGraph(\n+                _env,\n+                edges,\n+                new Dictionary<string, string> {{\"a\", \"b\"}});\n+\n+\n+            Func<ProjectGraphNode, string> nodeIdProvider = GetProjectFileName;\n+\n+            var dot = graph.ToDot(nodeIdProvider);\n+\n+            var edgeCount = 0;\n+\n+            foreach (var node in graph.ProjectNodes)\n+            {\n+                var nodeId = nodeIdProvider(node);\n+\n+                foreach (var globalProperty in node.ProjectInstance.GlobalProperties)\n+                {\n+                    dot.ShouldMatch($@\"{nodeId}\\s*\\[.*{globalProperty.Key}.*{globalProperty.Value}.*\\]\");\n+                }\n+\n+                foreach (var reference in node.ProjectReferences)\n+                {\n+                    edgeCount++;\n+                    dot.ShouldMatch($@\"{nodeId}\\s*->\\s*{nodeIdProvider(reference)}\");\n+                }\n+            }\n+\n+            // edge count\n+            Regex.Matches(dot,\"->\").Count.ShouldBe(edgeCount);\n+\n+            // node count\n+            Regex.Matches(dot,\"label\").Count.ShouldBe(graph.ProjectNodes.Count);\n+        }\n+\n+        private static void AssertOuterBuildAsRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ReferencingProjects.ShouldBeEmpty();\n+            outerBuild.ProjectReferences.Count.ShouldBe(2);\n+\n+            foreach (var innerBuild in outerBuild.ProjectReferences)\n+            {\n+                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+            }\n+        }\n+\n+        private static void AssertOuterBuildAsNonRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);\n+\n+            outerBuild.ProjectReferences.ShouldBeEmpty();\n+            outerBuild.ReferencingProjects.ShouldNotBeEmpty();\n+\n+            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)\n+            {\n+                var innerBuilds =\n+                    outerBuildReferencer.ProjectReferences.Where(\n+                        p =>\n+                            IsInnerBuild(p)\n+                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();\n+\n+                innerBuilds.Length.ShouldBe(2);\n+\n+                foreach (var innerBuild in innerBuilds)\n+                {\n+                    AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);\n+                }\n+            }\n+        }\n+\n+        private static bool IsOuterBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;\n+        }\n+\n+        private static bool IsInnerBuild(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;\n+        }\n+\n+        private static bool IsNotMultitargeting(ProjectGraphNode project)\n+        {\n+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonMultitargeting;\n+        }\n+\n+        private static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)\n+        {\n+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();\n+\n+            IsNotMultitargeting(node).ShouldBeTrue();\n+            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+            node.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+        }\n+\n+        private static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(outerBuild).ShouldBeTrue();\n+            IsInnerBuild(outerBuild).ShouldBeFalse();\n+\n+            outerBuild.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();\n+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));\n+        }\n+\n+        private static void AssertInnerBuildEvaluation(\n+            ProjectGraphNode innerBuild,\n+            bool InnerBuildPropertyIsSetViaGlobalProperty,\n+            Dictionary<string, string> additionalGlobalProperties)\n+        {\n+            additionalGlobalProperties.ShouldNotBeNull();\n+\n+            IsOuterBuild(innerBuild).ShouldBeFalse();\n+            IsInnerBuild(innerBuild).ShouldBeTrue();\n+\n+            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildProperty);\n+\n+            innerBuildPropertyValue.ShouldNotBeNullOrEmpty();\n+\n+            if (InnerBuildPropertyIsSetViaGlobalProperty)\n+            {\n+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(\n+                    EmptyGlobalProperties\n+                        .Add(InnerBuildProperty, innerBuildPropertyValue)\n+                        .AddRange(additionalGlobalProperties));\n+            }\n+        }\n+\n+        [Fact]\n+        public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()\n+        {\n+            var projectFile = _env.CreateTestProjectWithFiles($@\"<Project>{OuterBuildSpecification}</Project>\").ProjectFile;\n+\n+            var graph = new ProjectGraph(projectFile);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(3);\n+            \n+            var outerBuild = graph.GraphRoots.First();\n+\n+            AssertOuterBuildAsRoot(outerBuild);\n+        }\n+\n+        [Fact]\n+        public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGlobalProperties()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(4);\n+\n+            AssertOuterBuildAsRoot(graph.GraphRoots.First());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var innerBuildViaLocalProperty = OuterBuildSpecification + $\"<PropertyGroup><{InnerBuildProperty}>foo</{InnerBuildProperty}></PropertyGroup>\";\n+\n+            var root = CreateProjectFile(\n+                _env,\n+                1,\n+                new[] {2},\n+                null,\n+                null,\n+                innerBuildViaLocalProperty).Path;\n+\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), false, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropertyToReference()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2);\n+\n+            var graph = new ProjectGraph(root, new Dictionary<string, string>{{InnerBuildProperty, \"foo\"}});\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(2);\n+\n+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), true, new Dictionary<string, string>());\n+\n+            var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);\n+\n+            AssertNonMultitargetingNode(nonMultitargetingNode);\n+        }\n+\n+        [Fact]\n+        public void NonOuterBuildProjectsInTheMiddle()\n+        {\n+            var root = CreateProjectFile(_env, 1, new[] {2, 3}, null, null, OuterBuildSpecification).Path;\n+            CreateProjectFile(_env, 2, new[] {4});\n+            CreateProjectFile(_env, 3, new[] {4});\n+            CreateProjectFile(_env, 4, null, null, null, OuterBuildSpecification);\n+\n+            var graph = new ProjectGraph(root);\n+\n+            var dot = graph.ToDot();\n+\n+            graph.ProjectNodes.Count.ShouldBe(8);\n+\n+            AssertOuterBuildAsRoot(graph.GraphRoots.First());\n+            AssertOuterBuildAsNonRoot(GetNodesWithProjectNumber(graph, 4).First(IsOuterBuild));\n+\n+            AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2));\n+            AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));\n+        }\n+\n+        [Fact]\n+        public void InnerBuildsCanHaveSeparateReferences()\n+        {\n+            var extraInnerBuildReferenceSpec = OuterBuildSpecification +\n+                                          $@\"<ItemGroup>\n+                                                <ProjectReference Condition=`'$({InnerBuildProperty})'=='b'` Include=`4.proj;5.proj`/>\n+                                            </ItemGroup>\".Cleanup();\n+\n+            var root = CreateProjectFile(_env, 1, new[] {2, 3}, null, null, extraInnerBuildReferenceSpec).Path;\n+            CreateProjectFile(_env, 2, null, null, null, OuterBuildSpecification);\n+            CreateProjectFile(_env, 3);\n+            CreateProjectFile(_env, 4, null, null, null, OuterBuildSpecification);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        internal const string IsGraphBuild = nameof(IsGraphBuild);\r\n```\r\n\r\nAnd likewise below?",
              "createdAt": "2019-03-21T15:29:06Z",
              "path": "src/Shared/Constants.cs",
              "diffHunk": "@@ -106,6 +105,30 @@ internal static class MSBuildConstants\n         internal static readonly char[] PathSeparatorChar = { Path.PathSeparator };\n     }\n \n+    internal static class PropertyNames\n+    {\n+        /// <summary>\n+        /// Specifies whether the current evaluation / build is happening during a graph build\n+        /// </summary>\n+        internal const string IsGraphBuild = \"IsGraphBuild\";",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Love this but can you please pull it into a different PR?",
              "createdAt": "2019-03-21T15:31:03Z",
              "path": "src/Tasks.UnitTests/Copy_Tests.cs",
              "diffHunk": "@@ -533,11 +533,11 @@ public void DoCopyOverDifferentFile()\n         [InlineData(true)]\n         public void DoCopyOverCopiedFile(bool skipUnchangedFiles)\n         {\n-            var sourceFile = FileUtilities.GetTemporaryFile(null, \"src\", false);\n-            var destinationFile = FileUtilities.GetTemporaryFile(null, \"dst\", false);\n-\n-            try\n+            using (var env = TestEnvironment.Create())",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "We should find a place to write down the implication of this: an outer build **cannot** have its own distinct `ProjectReference`s. That's the case today, but I could see a situation where you might want it: a packaging project that packs its inner build outputs + \"other non-TF-specific stuff\" acquired through reference).\r\n\r\nI don't think this is a bad limitation. Just worth formalizing.",
              "createdAt": "2019-03-21T15:38:06Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -0,0 +1,387 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Globalization;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal sealed class ProjectInterpretation\n+    {\n+        private const string FullPathMetadataName = \"FullPath\";\n+        private const string ToolsVersionMetadataName = \"ToolsVersion\";\n+        private const string SetConfigurationMetadataName = \"SetConfiguration\";\n+        private const string SetPlatformMetadataName = \"SetPlatform\";\n+        private const string SetTargetFrameworkMetadataName = \"SetTargetFramework\";\n+        private const string GlobalPropertiesToRemoveMetadataName = \"GlobalPropertiesToRemove\";\n+        private const string ProjectReferenceTargetIsOuterBuildMetadataName = \"OuterBuild\";\n+\n+        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;\n+\n+        public static ProjectInterpretation Instance = new ProjectInterpretation();\n+\n+        private ProjectInterpretation()\n+        {\n+        }\n+\n+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();\n+\n+        internal enum ProjectType\n+        {\n+            OuterBuild, InnerBuild, NonMultitargeting\n+        }\n+\n+        public IEnumerable<ConfigurationMetadata> GetReferences(ProjectInstance requesterInstance)\n+        {\n+            IEnumerable<ProjectItemInstance> references;\n+            IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;\n+\n+            switch (GetProjectType(requesterInstance))\n+            {\n+                case ProjectType.OuterBuild:\n+                    references = GetInnerBuildReferences(requesterInstance);",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Ah, my confusion reduces:\r\n\r\nThis removes links from outer->inner builds of any build that is not a graph root, because the what-targets-should-we-run-on-a-ProjectInstance code has already decided not to run `Build` (really DispatchToInnerBuilds) on the outer build.\r\n\r\nThe referencing project, then, is given results for\r\n\r\n* Outer build: GetTargetFrameworks\r\n* Inner builds: Actual build\r\n\r\nAnd can call its negotiation code followed by an inner build using those results.\r\n\r\nThis makes sense but has a surprising (to me) property: adding a new graph root that just calls the prior graph root changes the graph in such a way that **the new graph is not a subgraph of the old one**. Is that ok? I think it probably is, but deserves documentation.\r\n\r\nThis might have negative implications for graph caching. Is the edge removal required?",
              "createdAt": "2019-03-21T15:58:41Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -0,0 +1,387 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Globalization;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal sealed class ProjectInterpretation\n+    {\n+        private const string FullPathMetadataName = \"FullPath\";\n+        private const string ToolsVersionMetadataName = \"ToolsVersion\";\n+        private const string SetConfigurationMetadataName = \"SetConfiguration\";\n+        private const string SetPlatformMetadataName = \"SetPlatform\";\n+        private const string SetTargetFrameworkMetadataName = \"SetTargetFramework\";\n+        private const string GlobalPropertiesToRemoveMetadataName = \"GlobalPropertiesToRemove\";\n+        private const string ProjectReferenceTargetIsOuterBuildMetadataName = \"OuterBuild\";\n+\n+        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;\n+\n+        public static ProjectInterpretation Instance = new ProjectInterpretation();\n+\n+        private ProjectInterpretation()\n+        {\n+        }\n+\n+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();\n+\n+        internal enum ProjectType\n+        {\n+            OuterBuild, InnerBuild, NonMultitargeting\n+        }\n+\n+        public IEnumerable<ConfigurationMetadata> GetReferences(ProjectInstance requesterInstance)\n+        {\n+            IEnumerable<ProjectItemInstance> references;\n+            IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;\n+\n+            switch (GetProjectType(requesterInstance))\n+            {\n+                case ProjectType.OuterBuild:\n+                    references = GetInnerBuildReferences(requesterInstance);\n+                    break;\n+                case ProjectType.InnerBuild:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                case ProjectType.NonMultitargeting:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes;\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                default:\n+                    throw new ArgumentOutOfRangeException();\n+            }\n+\n+            foreach (var projectReference in references)\n+            {\n+                if (!String.IsNullOrEmpty(projectReference.GetMetadataValue(ToolsVersionMetadataName)))\n+                {\n+                    throw new InvalidOperationException(\n+                        String.Format(\n+                            CultureInfo.InvariantCulture,\n+                            ResourceUtilities.GetResourceString(\n+                                \"ProjectGraphDoesNotSupportProjectReferenceWithToolset\"),\n+                            projectReference.EvaluatedInclude,\n+                            requesterInstance.FullPath));\n+                }\n+\n+                var projectReferenceFullPath = projectReference.GetMetadataValue(FullPathMetadataName);\n+\n+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReference, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);\n+\n+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);\n+\n+                yield return referenceConfig;\n+            }\n+        }\n+\n+        private static string GetInnerBuildPropertyValue(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(GetInnerBuildPropertyName(project));\n+        }\n+\n+        private static string GetInnerBuildPropertyName(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(PropertyNames.InnerBuildProperty);\n+        }\n+\n+        private static string GetInnerBuildPropertyValues(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(project.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));\n+        }\n+\n+        internal static ProjectType GetProjectType(ProjectInstance project)\n+        {\n+            var isOuterBuild = String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project)) && !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValues(project));\n+            var isInnerBuild = !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project));\n+\n+            ErrorUtilities.VerifyThrow(!(isOuterBuild && isInnerBuild), $\"A project cannot be an outer and inner build at the same time: ${project.FullPath}\");\n+\n+            return isOuterBuild\n+                ? ProjectType.OuterBuild\n+                : isInnerBuild\n+                    ? ProjectType.InnerBuild\n+                    : ProjectType.NonMultitargeting;\n+        }\n+\n+        public static void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)\n+        {\n+            foreach (var nodeKvp in allNodes)\n+            {\n+                var outerBuild = nodeKvp.Value;\n+\n+                if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)\n+                {\n+                    foreach (var innerBuild in outerBuild.ProjectReferences)\n+                    {\n+                        foreach (var referencingProject in outerBuild.ReferencingProjects)\n+                        {\n+                            referencingProject.AddProjectReference(innerBuild);\n+                        }\n+                    }\n+\n+                    outerBuild.RemoveReferences();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "The edge removal is there to have the graph be a more truthful representation of the runtime graph. The outer -> inner edges for non root outer builds do not appear in reality. Because of this, anyone who reasons about the graph would need to know about three little idiosyncrasies:\r\n1. that outer -> inner edges are not there in reality. So one cannot reason about a single node in isolation, one always needs to check for this case.\r\n2. out of all the outer -> inner edges, only one manifests in reality.\r\n3. the edge to the outer build node is a true edge\r\n\r\nWith the edge removal, the number of idiosyncrasies get reduced to only one, a variation of 2: When referencing a multitargeting node, the referencing node considers all TFs and gets to pick one. The graph contains all the edges, similar to symbolic execution, but at runtime only one path is taken.\r\n\r\nYou are right, the structural difference between outer builds as roots and outer builds as non roots destroys the nice complete-structural-sharing property for graph caching. Here's some thoughts on that:\r\n- This issue exists with vanilla msbuild, it's not an additional artificial static graph consequence\r\n- Even though it's not 100% sharing, I think there's still significant structural sharing. Given a graph G, we can decompose it into the graph of roots, Gr, and the graph of non-roots, Gnr. When a new node N is added to depend on G via an edge inside Gr, Gr cannot be reused, but Gnr can. The trick will be to keep track of Gr and Gnr.\r\n\r\nOptions\r\n1. change the graph to enable full structural sharing of subgraphs. The compromise here is that the new graph structure might depart from the actual runtime graph\r\n2. keep the graph in tune with the runtime graph, but make graph caching more complex.\r\n\r\nFor now I'd just go with 2. I'll update the spec to account for this though.",
              "createdAt": "2019-03-22T18:19:56Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -0,0 +1,387 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Globalization;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal sealed class ProjectInterpretation\n+    {\n+        private const string FullPathMetadataName = \"FullPath\";\n+        private const string ToolsVersionMetadataName = \"ToolsVersion\";\n+        private const string SetConfigurationMetadataName = \"SetConfiguration\";\n+        private const string SetPlatformMetadataName = \"SetPlatform\";\n+        private const string SetTargetFrameworkMetadataName = \"SetTargetFramework\";\n+        private const string GlobalPropertiesToRemoveMetadataName = \"GlobalPropertiesToRemove\";\n+        private const string ProjectReferenceTargetIsOuterBuildMetadataName = \"OuterBuild\";\n+\n+        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;\n+\n+        public static ProjectInterpretation Instance = new ProjectInterpretation();\n+\n+        private ProjectInterpretation()\n+        {\n+        }\n+\n+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();\n+\n+        internal enum ProjectType\n+        {\n+            OuterBuild, InnerBuild, NonMultitargeting\n+        }\n+\n+        public IEnumerable<ConfigurationMetadata> GetReferences(ProjectInstance requesterInstance)\n+        {\n+            IEnumerable<ProjectItemInstance> references;\n+            IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;\n+\n+            switch (GetProjectType(requesterInstance))\n+            {\n+                case ProjectType.OuterBuild:\n+                    references = GetInnerBuildReferences(requesterInstance);\n+                    break;\n+                case ProjectType.InnerBuild:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                case ProjectType.NonMultitargeting:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes;\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                default:\n+                    throw new ArgumentOutOfRangeException();\n+            }\n+\n+            foreach (var projectReference in references)\n+            {\n+                if (!String.IsNullOrEmpty(projectReference.GetMetadataValue(ToolsVersionMetadataName)))\n+                {\n+                    throw new InvalidOperationException(\n+                        String.Format(\n+                            CultureInfo.InvariantCulture,\n+                            ResourceUtilities.GetResourceString(\n+                                \"ProjectGraphDoesNotSupportProjectReferenceWithToolset\"),\n+                            projectReference.EvaluatedInclude,\n+                            requesterInstance.FullPath));\n+                }\n+\n+                var projectReferenceFullPath = projectReference.GetMetadataValue(FullPathMetadataName);\n+\n+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReference, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);\n+\n+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);\n+\n+                yield return referenceConfig;\n+            }\n+        }\n+\n+        private static string GetInnerBuildPropertyValue(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(GetInnerBuildPropertyName(project));\n+        }\n+\n+        private static string GetInnerBuildPropertyName(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(PropertyNames.InnerBuildProperty);\n+        }\n+\n+        private static string GetInnerBuildPropertyValues(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(project.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));\n+        }\n+\n+        internal static ProjectType GetProjectType(ProjectInstance project)\n+        {\n+            var isOuterBuild = String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project)) && !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValues(project));\n+            var isInnerBuild = !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project));\n+\n+            ErrorUtilities.VerifyThrow(!(isOuterBuild && isInnerBuild), $\"A project cannot be an outer and inner build at the same time: ${project.FullPath}\");\n+\n+            return isOuterBuild\n+                ? ProjectType.OuterBuild\n+                : isInnerBuild\n+                    ? ProjectType.InnerBuild\n+                    : ProjectType.NonMultitargeting;\n+        }\n+\n+        public static void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)\n+        {\n+            foreach (var nodeKvp in allNodes)\n+            {\n+                var outerBuild = nodeKvp.Value;\n+\n+                if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)\n+                {\n+                    foreach (var innerBuild in outerBuild.ProjectReferences)\n+                    {\n+                        foreach (var referencingProject in outerBuild.ReferencingProjects)\n+                        {\n+                            referencingProject.AddProjectReference(innerBuild);\n+                        }\n+                    }\n+\n+                    outerBuild.RemoveReferences();",
              "author": {
                "login": "cdmihai"
              }
            },
            {
              "body": "Sounds like a good plan.",
              "createdAt": "2019-03-22T19:10:00Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -0,0 +1,387 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Globalization;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal sealed class ProjectInterpretation\n+    {\n+        private const string FullPathMetadataName = \"FullPath\";\n+        private const string ToolsVersionMetadataName = \"ToolsVersion\";\n+        private const string SetConfigurationMetadataName = \"SetConfiguration\";\n+        private const string SetPlatformMetadataName = \"SetPlatform\";\n+        private const string SetTargetFrameworkMetadataName = \"SetTargetFramework\";\n+        private const string GlobalPropertiesToRemoveMetadataName = \"GlobalPropertiesToRemove\";\n+        private const string ProjectReferenceTargetIsOuterBuildMetadataName = \"OuterBuild\";\n+\n+        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;\n+\n+        public static ProjectInterpretation Instance = new ProjectInterpretation();\n+\n+        private ProjectInterpretation()\n+        {\n+        }\n+\n+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();\n+\n+        internal enum ProjectType\n+        {\n+            OuterBuild, InnerBuild, NonMultitargeting\n+        }\n+\n+        public IEnumerable<ConfigurationMetadata> GetReferences(ProjectInstance requesterInstance)\n+        {\n+            IEnumerable<ProjectItemInstance> references;\n+            IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;\n+\n+            switch (GetProjectType(requesterInstance))\n+            {\n+                case ProjectType.OuterBuild:\n+                    references = GetInnerBuildReferences(requesterInstance);\n+                    break;\n+                case ProjectType.InnerBuild:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                case ProjectType.NonMultitargeting:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes;\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                default:\n+                    throw new ArgumentOutOfRangeException();\n+            }\n+\n+            foreach (var projectReference in references)\n+            {\n+                if (!String.IsNullOrEmpty(projectReference.GetMetadataValue(ToolsVersionMetadataName)))\n+                {\n+                    throw new InvalidOperationException(\n+                        String.Format(\n+                            CultureInfo.InvariantCulture,\n+                            ResourceUtilities.GetResourceString(\n+                                \"ProjectGraphDoesNotSupportProjectReferenceWithToolset\"),\n+                            projectReference.EvaluatedInclude,\n+                            requesterInstance.FullPath));\n+                }\n+\n+                var projectReferenceFullPath = projectReference.GetMetadataValue(FullPathMetadataName);\n+\n+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReference, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);\n+\n+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);\n+\n+                yield return referenceConfig;\n+            }\n+        }\n+\n+        private static string GetInnerBuildPropertyValue(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(GetInnerBuildPropertyName(project));\n+        }\n+\n+        private static string GetInnerBuildPropertyName(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(PropertyNames.InnerBuildProperty);\n+        }\n+\n+        private static string GetInnerBuildPropertyValues(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(project.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));\n+        }\n+\n+        internal static ProjectType GetProjectType(ProjectInstance project)\n+        {\n+            var isOuterBuild = String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project)) && !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValues(project));\n+            var isInnerBuild = !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project));\n+\n+            ErrorUtilities.VerifyThrow(!(isOuterBuild && isInnerBuild), $\"A project cannot be an outer and inner build at the same time: ${project.FullPath}\");\n+\n+            return isOuterBuild\n+                ? ProjectType.OuterBuild\n+                : isInnerBuild\n+                    ? ProjectType.InnerBuild\n+                    : ProjectType.NonMultitargeting;\n+        }\n+\n+        public static void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)\n+        {\n+            foreach (var nodeKvp in allNodes)\n+            {\n+                var outerBuild = nodeKvp.Value;\n+\n+                if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)\n+                {\n+                    foreach (var innerBuild in outerBuild.ProjectReferences)\n+                    {\n+                        foreach (var referencingProject in outerBuild.ReferencingProjects)\n+                        {\n+                            referencingProject.AddProjectReference(innerBuild);\n+                        }\n+                    }\n+\n+                    outerBuild.RemoveReferences();",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Hopefully in hindsight it still will have sounded like a good plan :)\r\ncc @AndyGerlicher @dannyvv for visibility.",
              "createdAt": "2019-03-22T20:38:04Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -0,0 +1,387 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Globalization;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal sealed class ProjectInterpretation\n+    {\n+        private const string FullPathMetadataName = \"FullPath\";\n+        private const string ToolsVersionMetadataName = \"ToolsVersion\";\n+        private const string SetConfigurationMetadataName = \"SetConfiguration\";\n+        private const string SetPlatformMetadataName = \"SetPlatform\";\n+        private const string SetTargetFrameworkMetadataName = \"SetTargetFramework\";\n+        private const string GlobalPropertiesToRemoveMetadataName = \"GlobalPropertiesToRemove\";\n+        private const string ProjectReferenceTargetIsOuterBuildMetadataName = \"OuterBuild\";\n+\n+        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;\n+\n+        public static ProjectInterpretation Instance = new ProjectInterpretation();\n+\n+        private ProjectInterpretation()\n+        {\n+        }\n+\n+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();\n+\n+        internal enum ProjectType\n+        {\n+            OuterBuild, InnerBuild, NonMultitargeting\n+        }\n+\n+        public IEnumerable<ConfigurationMetadata> GetReferences(ProjectInstance requesterInstance)\n+        {\n+            IEnumerable<ProjectItemInstance> references;\n+            IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;\n+\n+            switch (GetProjectType(requesterInstance))\n+            {\n+                case ProjectType.OuterBuild:\n+                    references = GetInnerBuildReferences(requesterInstance);\n+                    break;\n+                case ProjectType.InnerBuild:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                case ProjectType.NonMultitargeting:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes;\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                default:\n+                    throw new ArgumentOutOfRangeException();\n+            }\n+\n+            foreach (var projectReference in references)\n+            {\n+                if (!String.IsNullOrEmpty(projectReference.GetMetadataValue(ToolsVersionMetadataName)))\n+                {\n+                    throw new InvalidOperationException(\n+                        String.Format(\n+                            CultureInfo.InvariantCulture,\n+                            ResourceUtilities.GetResourceString(\n+                                \"ProjectGraphDoesNotSupportProjectReferenceWithToolset\"),\n+                            projectReference.EvaluatedInclude,\n+                            requesterInstance.FullPath));\n+                }\n+\n+                var projectReferenceFullPath = projectReference.GetMetadataValue(FullPathMetadataName);\n+\n+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReference, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);\n+\n+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);\n+\n+                yield return referenceConfig;\n+            }\n+        }\n+\n+        private static string GetInnerBuildPropertyValue(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(GetInnerBuildPropertyName(project));\n+        }\n+\n+        private static string GetInnerBuildPropertyName(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(PropertyNames.InnerBuildProperty);\n+        }\n+\n+        private static string GetInnerBuildPropertyValues(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(project.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));\n+        }\n+\n+        internal static ProjectType GetProjectType(ProjectInstance project)\n+        {\n+            var isOuterBuild = String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project)) && !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValues(project));\n+            var isInnerBuild = !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project));\n+\n+            ErrorUtilities.VerifyThrow(!(isOuterBuild && isInnerBuild), $\"A project cannot be an outer and inner build at the same time: ${project.FullPath}\");\n+\n+            return isOuterBuild\n+                ? ProjectType.OuterBuild\n+                : isInnerBuild\n+                    ? ProjectType.InnerBuild\n+                    : ProjectType.NonMultitargeting;\n+        }\n+\n+        public static void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)\n+        {\n+            foreach (var nodeKvp in allNodes)\n+            {\n+                var outerBuild = nodeKvp.Value;\n+\n+                if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)\n+                {\n+                    foreach (var innerBuild in outerBuild.ProjectReferences)\n+                    {\n+                        foreach (var referencingProject in outerBuild.ReferencingProjects)\n+                        {\n+                            referencingProject.AddProjectReference(innerBuild);\n+                        }\n+                    }\n+\n+                    outerBuild.RemoveReferences();",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\n        public static void PromoteInnerBuildReferencesToReferencingProjects(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)\r\n```\r\n\r\n? If this is the way to keep it.",
              "createdAt": "2019-03-21T15:59:38Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -0,0 +1,387 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Globalization;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal sealed class ProjectInterpretation\n+    {\n+        private const string FullPathMetadataName = \"FullPath\";\n+        private const string ToolsVersionMetadataName = \"ToolsVersion\";\n+        private const string SetConfigurationMetadataName = \"SetConfiguration\";\n+        private const string SetPlatformMetadataName = \"SetPlatform\";\n+        private const string SetTargetFrameworkMetadataName = \"SetTargetFramework\";\n+        private const string GlobalPropertiesToRemoveMetadataName = \"GlobalPropertiesToRemove\";\n+        private const string ProjectReferenceTargetIsOuterBuildMetadataName = \"OuterBuild\";\n+\n+        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;\n+\n+        public static ProjectInterpretation Instance = new ProjectInterpretation();\n+\n+        private ProjectInterpretation()\n+        {\n+        }\n+\n+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();\n+\n+        internal enum ProjectType\n+        {\n+            OuterBuild, InnerBuild, NonMultitargeting\n+        }\n+\n+        public IEnumerable<ConfigurationMetadata> GetReferences(ProjectInstance requesterInstance)\n+        {\n+            IEnumerable<ProjectItemInstance> references;\n+            IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;\n+\n+            switch (GetProjectType(requesterInstance))\n+            {\n+                case ProjectType.OuterBuild:\n+                    references = GetInnerBuildReferences(requesterInstance);\n+                    break;\n+                case ProjectType.InnerBuild:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                case ProjectType.NonMultitargeting:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes;\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                default:\n+                    throw new ArgumentOutOfRangeException();\n+            }\n+\n+            foreach (var projectReference in references)\n+            {\n+                if (!String.IsNullOrEmpty(projectReference.GetMetadataValue(ToolsVersionMetadataName)))\n+                {\n+                    throw new InvalidOperationException(\n+                        String.Format(\n+                            CultureInfo.InvariantCulture,\n+                            ResourceUtilities.GetResourceString(\n+                                \"ProjectGraphDoesNotSupportProjectReferenceWithToolset\"),\n+                            projectReference.EvaluatedInclude,\n+                            requesterInstance.FullPath));\n+                }\n+\n+                var projectReferenceFullPath = projectReference.GetMetadataValue(FullPathMetadataName);\n+\n+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReference, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);\n+\n+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);\n+\n+                yield return referenceConfig;\n+            }\n+        }\n+\n+        private static string GetInnerBuildPropertyValue(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(GetInnerBuildPropertyName(project));\n+        }\n+\n+        private static string GetInnerBuildPropertyName(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(PropertyNames.InnerBuildProperty);\n+        }\n+\n+        private static string GetInnerBuildPropertyValues(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(project.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));\n+        }\n+\n+        internal static ProjectType GetProjectType(ProjectInstance project)\n+        {\n+            var isOuterBuild = String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project)) && !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValues(project));\n+            var isInnerBuild = !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project));\n+\n+            ErrorUtilities.VerifyThrow(!(isOuterBuild && isInnerBuild), $\"A project cannot be an outer and inner build at the same time: ${project.FullPath}\");\n+\n+            return isOuterBuild\n+                ? ProjectType.OuterBuild\n+                : isInnerBuild\n+                    ? ProjectType.InnerBuild\n+                    : ProjectType.NonMultitargeting;\n+        }\n+\n+        public static void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Not sure, depends how the abstractions turn out. Right now I tried to keep ProjectGraph pretty agnostic of xml contents. It does not even know about multitargeting. ProjectInterpretation is the one that knows about evaluation particularities, what multitargeting is, etc. The vague intent is to potentially decouple ProjectInterpretation into plugins provided by SDKs.",
              "createdAt": "2019-03-22T18:38:37Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -0,0 +1,387 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Globalization;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal sealed class ProjectInterpretation\n+    {\n+        private const string FullPathMetadataName = \"FullPath\";\n+        private const string ToolsVersionMetadataName = \"ToolsVersion\";\n+        private const string SetConfigurationMetadataName = \"SetConfiguration\";\n+        private const string SetPlatformMetadataName = \"SetPlatform\";\n+        private const string SetTargetFrameworkMetadataName = \"SetTargetFramework\";\n+        private const string GlobalPropertiesToRemoveMetadataName = \"GlobalPropertiesToRemove\";\n+        private const string ProjectReferenceTargetIsOuterBuildMetadataName = \"OuterBuild\";\n+\n+        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;\n+\n+        public static ProjectInterpretation Instance = new ProjectInterpretation();\n+\n+        private ProjectInterpretation()\n+        {\n+        }\n+\n+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();\n+\n+        internal enum ProjectType\n+        {\n+            OuterBuild, InnerBuild, NonMultitargeting\n+        }\n+\n+        public IEnumerable<ConfigurationMetadata> GetReferences(ProjectInstance requesterInstance)\n+        {\n+            IEnumerable<ProjectItemInstance> references;\n+            IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;\n+\n+            switch (GetProjectType(requesterInstance))\n+            {\n+                case ProjectType.OuterBuild:\n+                    references = GetInnerBuildReferences(requesterInstance);\n+                    break;\n+                case ProjectType.InnerBuild:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                case ProjectType.NonMultitargeting:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes;\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                default:\n+                    throw new ArgumentOutOfRangeException();\n+            }\n+\n+            foreach (var projectReference in references)\n+            {\n+                if (!String.IsNullOrEmpty(projectReference.GetMetadataValue(ToolsVersionMetadataName)))\n+                {\n+                    throw new InvalidOperationException(\n+                        String.Format(\n+                            CultureInfo.InvariantCulture,\n+                            ResourceUtilities.GetResourceString(\n+                                \"ProjectGraphDoesNotSupportProjectReferenceWithToolset\"),\n+                            projectReference.EvaluatedInclude,\n+                            requesterInstance.FullPath));\n+                }\n+\n+                var projectReferenceFullPath = projectReference.GetMetadataValue(FullPathMetadataName);\n+\n+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReference, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);\n+\n+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);\n+\n+                yield return referenceConfig;\n+            }\n+        }\n+\n+        private static string GetInnerBuildPropertyValue(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(GetInnerBuildPropertyName(project));\n+        }\n+\n+        private static string GetInnerBuildPropertyName(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(PropertyNames.InnerBuildProperty);\n+        }\n+\n+        private static string GetInnerBuildPropertyValues(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(project.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));\n+        }\n+\n+        internal static ProjectType GetProjectType(ProjectInstance project)\n+        {\n+            var isOuterBuild = String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project)) && !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValues(project));\n+            var isInnerBuild = !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project));\n+\n+            ErrorUtilities.VerifyThrow(!(isOuterBuild && isInnerBuild), $\"A project cannot be an outer and inner build at the same time: ${project.FullPath}\");\n+\n+            return isOuterBuild\n+                ? ProjectType.OuterBuild\n+                : isInnerBuild\n+                    ? ProjectType.InnerBuild\n+                    : ProjectType.NonMultitargeting;\n+        }\n+\n+        public static void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: should these be `ImmutableList.Builder`s since they're going to get turned into that later?",
              "createdAt": "2019-03-21T18:36:44Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -0,0 +1,387 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Globalization;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal sealed class ProjectInterpretation\n+    {\n+        private const string FullPathMetadataName = \"FullPath\";\n+        private const string ToolsVersionMetadataName = \"ToolsVersion\";\n+        private const string SetConfigurationMetadataName = \"SetConfiguration\";\n+        private const string SetPlatformMetadataName = \"SetPlatform\";\n+        private const string SetTargetFrameworkMetadataName = \"SetTargetFramework\";\n+        private const string GlobalPropertiesToRemoveMetadataName = \"GlobalPropertiesToRemove\";\n+        private const string ProjectReferenceTargetIsOuterBuildMetadataName = \"OuterBuild\";\n+\n+        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;\n+\n+        public static ProjectInterpretation Instance = new ProjectInterpretation();\n+\n+        private ProjectInterpretation()\n+        {\n+        }\n+\n+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();\n+\n+        internal enum ProjectType\n+        {\n+            OuterBuild, InnerBuild, NonMultitargeting\n+        }\n+\n+        public IEnumerable<ConfigurationMetadata> GetReferences(ProjectInstance requesterInstance)\n+        {\n+            IEnumerable<ProjectItemInstance> references;\n+            IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;\n+\n+            switch (GetProjectType(requesterInstance))\n+            {\n+                case ProjectType.OuterBuild:\n+                    references = GetInnerBuildReferences(requesterInstance);\n+                    break;\n+                case ProjectType.InnerBuild:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                case ProjectType.NonMultitargeting:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes;\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                default:\n+                    throw new ArgumentOutOfRangeException();\n+            }\n+\n+            foreach (var projectReference in references)\n+            {\n+                if (!String.IsNullOrEmpty(projectReference.GetMetadataValue(ToolsVersionMetadataName)))\n+                {\n+                    throw new InvalidOperationException(\n+                        String.Format(\n+                            CultureInfo.InvariantCulture,\n+                            ResourceUtilities.GetResourceString(\n+                                \"ProjectGraphDoesNotSupportProjectReferenceWithToolset\"),\n+                            projectReference.EvaluatedInclude,\n+                            requesterInstance.FullPath));\n+                }\n+\n+                var projectReferenceFullPath = projectReference.GetMetadataValue(FullPathMetadataName);\n+\n+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReference, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);\n+\n+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);\n+\n+                yield return referenceConfig;\n+            }\n+        }\n+\n+        private static string GetInnerBuildPropertyValue(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(GetInnerBuildPropertyName(project));\n+        }\n+\n+        private static string GetInnerBuildPropertyName(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(PropertyNames.InnerBuildProperty);\n+        }\n+\n+        private static string GetInnerBuildPropertyValues(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(project.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));\n+        }\n+\n+        internal static ProjectType GetProjectType(ProjectInstance project)\n+        {\n+            var isOuterBuild = String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project)) && !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValues(project));\n+            var isInnerBuild = !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project));\n+\n+            ErrorUtilities.VerifyThrow(!(isOuterBuild && isInnerBuild), $\"A project cannot be an outer and inner build at the same time: ${project.FullPath}\");\n+\n+            return isOuterBuild\n+                ? ProjectType.OuterBuild\n+                : isInnerBuild\n+                    ? ProjectType.InnerBuild\n+                    : ProjectType.NonMultitargeting;\n+        }\n+\n+        public static void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)\n+        {\n+            foreach (var nodeKvp in allNodes)\n+            {\n+                var outerBuild = nodeKvp.Value;\n+\n+                if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)\n+                {\n+                    foreach (var innerBuild in outerBuild.ProjectReferences)\n+                    {\n+                        foreach (var referencingProject in outerBuild.ReferencingProjects)\n+                        {\n+                            referencingProject.AddProjectReference(innerBuild);\n+                        }\n+                    }\n+\n+                    outerBuild.RemoveReferences();\n+                }\n+            }\n+        }\n+\n+        private static IEnumerable<ProjectItemInstance> GetInnerBuildReferences(ProjectInstance outerBuild)\n+        {\n+            var globalPropertyName = GetInnerBuildPropertyName(outerBuild);\n+            var globalPropertyValues = GetInnerBuildPropertyValues(outerBuild);\n+\n+            ErrorUtilities.VerifyThrow(!String.IsNullOrWhiteSpace(globalPropertyName), \"Must have an inner build property\");\n+            ErrorUtilities.VerifyThrow(!String.IsNullOrWhiteSpace(globalPropertyValues), \"Must have values for the inner build property\");\n+\n+            foreach (var globalPropertyValue in ExpressionShredder.SplitSemiColonSeparatedList(globalPropertyValues))\n+            {\n+                yield return new ProjectItemInstance(\n+                    outerBuild,\n+                    \"_ProjectSelfReference\",\n+                    outerBuild.FullPath,\n+                    new[] {new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $\"{globalPropertyName}={globalPropertyValue}\")},\n+                    outerBuild.FullPath);\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Gets the effective global properties for a project reference item.\n+        /// </summary>\n+        /// <remarks>\n+        ///     The behavior of this method should match the logic in the SDK\n+        /// </remarks>\n+        private static GlobalPropertyPartsForMSBuildTask ProjectReferenceGlobalPropertiesModifier(\n+            GlobalPropertyPartsForMSBuildTask defaultParts,\n+            ProjectItemInstance projectReference\n+        )\n+        {\n+            // ProjectReference defines yet another metadata name containing properties to undefine. Merge it in if non empty.\n+            var globalPropertiesToRemove = SplitPropertyNames(projectReference.GetMetadataValue(GlobalPropertiesToRemoveMetadataName));\n+\n+            var newUndefineProperties = defaultParts.UndefineProperties;\n+\n+            newUndefineProperties = newUndefineProperties.AddRange(defaultParts.UndefineProperties);\n+            newUndefineProperties = newUndefineProperties.AddRange(globalPropertiesToRemove);\n+\n+            newUndefineProperties.Add(\"InnerBuildProperty\");\n+\n+            var newProperties = defaultParts.Properties;\n+\n+            // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n+            if (newProperties.Count == 0)\n+            {\n+                // TODO: Mimic AssignProjectConfiguration's behavior for determining the values for these.\n+                var setConfigurationString = projectReference.GetMetadataValue(SetConfigurationMetadataName);\n+                var setPlatformString = projectReference.GetMetadataValue(SetPlatformMetadataName);\n+                var setTargetFrameworkString = projectReference.GetMetadataValue(SetTargetFrameworkMetadataName);\n+\n+                if (!String.IsNullOrEmpty(setConfigurationString) || !String.IsNullOrEmpty(setPlatformString) || !String.IsNullOrEmpty(setTargetFrameworkString))\n+                {\n+                    newProperties = SplitPropertyNameValuePairs(\n+                        ItemMetadataNames.PropertiesMetadataName,\n+                        $\"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}\").ToImmutableDictionary();\n+                }\n+            }\n+\n+            return new GlobalPropertyPartsForMSBuildTask(newProperties, defaultParts.AdditionalProperties, newUndefineProperties);\n+        }\n+\n+        private readonly struct GlobalPropertyPartsForMSBuildTask\n+        {\n+            public ImmutableDictionary<string, string> Properties { get; }\n+            public ImmutableDictionary<string, string> AdditionalProperties { get; }\n+            public ImmutableList<string> UndefineProperties { get; }\n+\n+            public GlobalPropertyPartsForMSBuildTask(\n+                ImmutableDictionary<string, string> properties,\n+                ImmutableDictionary<string, string> additionalProperties,\n+                ImmutableList<string> undefineProperties)\n+            {\n+                Properties = properties;\n+                AdditionalProperties = additionalProperties;\n+                UndefineProperties = undefineProperties;\n+            }\n+\n+            public bool AllEmpty()\n+            {\n+                return Properties.Count == 0 && AdditionalProperties.Count == 0 && UndefineProperties.Count == 0;\n+            }\n+\n+            public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyToUndefine)\n+            {\n+                return new GlobalPropertyPartsForMSBuildTask(Properties, AdditionalProperties, UndefineProperties.Add(propertyToUndefine));\n+            }\n+        }\n+\n+        delegate GlobalPropertyPartsForMSBuildTask GlobalPropertiesModifier(GlobalPropertyPartsForMSBuildTask defaultParts, ProjectItemInstance projectReference);\n+\n+        /// <summary>\n+        ///     Gets the effective global properties for an item that will get passed to <see cref=\"MSBuild.Projects\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        ///     The behavior of this method matches the hardcoded behaviour of the msbuild task\n+        ///     and the <paramref name=\"globalPropertyModifiers\"/> parameter can contain other mutations done at build time in targets / tasks\n+        /// </remarks>\n+        private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesForItem(\n+            ProjectItemInstance projectReference,\n+            PropertyDictionary<ProjectPropertyInstance> requesterGlobalProperties,\n+            IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers = null)\n+        {\n+            ErrorUtilities.VerifyThrowInternalNull(projectReference, nameof(projectReference));\n+            ErrorUtilities.VerifyThrowArgumentNull(requesterGlobalProperties, nameof(requesterGlobalProperties));\n+\n+            var properties = SplitPropertyNameValuePairs(ItemMetadataNames.PropertiesMetadataName, projectReference.GetMetadataValue(ItemMetadataNames.PropertiesMetadataName));\n+            var additionalProperties = SplitPropertyNameValuePairs(ItemMetadataNames.AdditionalPropertiesMetadataName, projectReference.GetMetadataValue(ItemMetadataNames.AdditionalPropertiesMetadataName));\n+            var undefineProperties = SplitPropertyNames(projectReference.GetMetadataValue(ItemMetadataNames.UndefinePropertiesMetadataName));\n+\n+            var defaultParts = new GlobalPropertyPartsForMSBuildTask(properties.ToImmutableDictionary(), additionalProperties.ToImmutableDictionary(), undefineProperties.ToImmutableList());\n+\n+            var globalPropertyParts = globalPropertyModifiers?.Aggregate(defaultParts, (currentProperties, modifier) => modifier(currentProperties, projectReference)) ?? defaultParts;\n+\n+            if (globalPropertyParts.AllEmpty())\n+            {\n+                return requesterGlobalProperties;\n+            }\n+\n+            // Make a copy to avoid mutating the requester\n+            var globalProperties = new PropertyDictionary<ProjectPropertyInstance>(requesterGlobalProperties);\n+\n+            // Append and remove properties as specified by the various metadata\n+            MergeIntoPropertyDictionary(globalProperties, globalPropertyParts.Properties);\n+            MergeIntoPropertyDictionary(globalProperties, globalPropertyParts.AdditionalProperties);\n+            RemoveFromPropertyDictionary(globalProperties, globalPropertyParts.UndefineProperties);\n+\n+            return globalProperties;\n+        }\n+\n+        private static void MergeIntoPropertyDictionary(\n+            PropertyDictionary<ProjectPropertyInstance> destination,\n+            IReadOnlyDictionary<string, string> source)\n+        {\n+            foreach (var pair in source)\n+            {\n+                destination[pair.Key] = ProjectPropertyInstance.Create(pair.Key, pair.Value);\n+            }\n+        }\n+\n+        private static IReadOnlyDictionary<string, string> SplitPropertyNameValuePairs(string syntaxName, string propertyNameAndValuesString)\n+        {\n+            if (String.IsNullOrEmpty(propertyNameAndValuesString))\n+            {\n+                return ImmutableDictionary<string, string>.Empty;\n+            }\n+\n+            if (PropertyParser.GetTableWithEscaping(\n+                null,\n+                null,\n+                null,\n+                propertyNameAndValuesString.Split(PropertySeparator, StringSplitOptions.RemoveEmptyEntries),\n+                out var propertiesTable))\n+            {\n+                return propertiesTable;\n+            }\n+\n+            throw new InvalidProjectFileException(\n+                String.Format(\n+                    CultureInfo.InvariantCulture,\n+                    ResourceUtilities.GetResourceString(\"General.InvalidPropertyError\"),\n+                    syntaxName,\n+                    propertyNameAndValuesString));\n+        }\n+\n+        private static IReadOnlyCollection<string> SplitPropertyNames(string propertyNamesString)\n+        {\n+            if (String.IsNullOrEmpty(propertyNamesString))\n+            {\n+                return ImmutableArray<string>.Empty;\n+            }\n+\n+            return propertyNamesString.Split(PropertySeparator, StringSplitOptions.RemoveEmptyEntries);\n+        }\n+\n+        private static void RemoveFromPropertyDictionary(\n+            PropertyDictionary<ProjectPropertyInstance> properties,\n+            IReadOnlyCollection<string> propertyNamesToRemove)\n+        {\n+            foreach (var propertyName in propertyNamesToRemove)\n+            {\n+                properties.Remove(propertyName);\n+            }\n+        }\n+\n+        public readonly struct TargetsToPropagate\n+        {\n+            private readonly ImmutableList<string> _outerBuildTargets;\n+            private readonly ImmutableList<string> _allTargets;\n+\n+            private TargetsToPropagate(ImmutableList<string> outerBuildTargets, ImmutableList<string> nonOuterBuildTargets)\n+            {\n+                _outerBuildTargets = outerBuildTargets;\n+\n+                // Since non outer builds act both as outer and inner builds, they need to implement both sets of targets\n+                // Outer build targets go first because at build time outer builds are built before inner builds\n+                _allTargets = outerBuildTargets.AddRange(nonOuterBuildTargets);\n+            }\n+\n+            public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance project, ImmutableList<string> entryTargets)\n+            {\n+                var targetsForOuterBuild = new List<string>();\n+                var targetsForInnerBuild = new List<string>();",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I don't understand this comment. Can you elaborate, please?",
              "createdAt": "2019-03-21T18:38:09Z",
              "path": "src/Build/Graph/ProjectInterpretation.cs",
              "diffHunk": "@@ -0,0 +1,387 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n+using System.Collections.Immutable;\n+using System.Globalization;\n+using System.Linq;\n+using Microsoft.Build.BackEnd;\n+using Microsoft.Build.Collections;\n+using Microsoft.Build.Evaluation;\n+using Microsoft.Build.Exceptions;\n+using Microsoft.Build.Execution;\n+using Microsoft.Build.Shared;\n+\n+namespace Microsoft.Build.Experimental.Graph\n+{\n+    internal sealed class ProjectInterpretation\n+    {\n+        private const string FullPathMetadataName = \"FullPath\";\n+        private const string ToolsVersionMetadataName = \"ToolsVersion\";\n+        private const string SetConfigurationMetadataName = \"SetConfiguration\";\n+        private const string SetPlatformMetadataName = \"SetPlatform\";\n+        private const string SetTargetFrameworkMetadataName = \"SetTargetFramework\";\n+        private const string GlobalPropertiesToRemoveMetadataName = \"GlobalPropertiesToRemove\";\n+        private const string ProjectReferenceTargetIsOuterBuildMetadataName = \"OuterBuild\";\n+\n+        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;\n+\n+        public static ProjectInterpretation Instance = new ProjectInterpretation();\n+\n+        private ProjectInterpretation()\n+        {\n+        }\n+\n+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();\n+\n+        internal enum ProjectType\n+        {\n+            OuterBuild, InnerBuild, NonMultitargeting\n+        }\n+\n+        public IEnumerable<ConfigurationMetadata> GetReferences(ProjectInstance requesterInstance)\n+        {\n+            IEnumerable<ProjectItemInstance> references;\n+            IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;\n+\n+            switch (GetProjectType(requesterInstance))\n+            {\n+                case ProjectType.OuterBuild:\n+                    references = GetInnerBuildReferences(requesterInstance);\n+                    break;\n+                case ProjectType.InnerBuild:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                case ProjectType.NonMultitargeting:\n+                    globalPropertiesModifiers = ModifierForNonMultitargetingNodes;\n+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);\n+                    break;\n+                default:\n+                    throw new ArgumentOutOfRangeException();\n+            }\n+\n+            foreach (var projectReference in references)\n+            {\n+                if (!String.IsNullOrEmpty(projectReference.GetMetadataValue(ToolsVersionMetadataName)))\n+                {\n+                    throw new InvalidOperationException(\n+                        String.Format(\n+                            CultureInfo.InvariantCulture,\n+                            ResourceUtilities.GetResourceString(\n+                                \"ProjectGraphDoesNotSupportProjectReferenceWithToolset\"),\n+                            projectReference.EvaluatedInclude,\n+                            requesterInstance.FullPath));\n+                }\n+\n+                var projectReferenceFullPath = projectReference.GetMetadataValue(FullPathMetadataName);\n+\n+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReference, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);\n+\n+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);\n+\n+                yield return referenceConfig;\n+            }\n+        }\n+\n+        private static string GetInnerBuildPropertyValue(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(GetInnerBuildPropertyName(project));\n+        }\n+\n+        private static string GetInnerBuildPropertyName(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(PropertyNames.InnerBuildProperty);\n+        }\n+\n+        private static string GetInnerBuildPropertyValues(ProjectInstance project)\n+        {\n+            return project.GetPropertyValue(project.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));\n+        }\n+\n+        internal static ProjectType GetProjectType(ProjectInstance project)\n+        {\n+            var isOuterBuild = String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project)) && !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValues(project));\n+            var isInnerBuild = !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project));\n+\n+            ErrorUtilities.VerifyThrow(!(isOuterBuild && isInnerBuild), $\"A project cannot be an outer and inner build at the same time: ${project.FullPath}\");\n+\n+            return isOuterBuild\n+                ? ProjectType.OuterBuild\n+                : isInnerBuild\n+                    ? ProjectType.InnerBuild\n+                    : ProjectType.NonMultitargeting;\n+        }\n+\n+        public static void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)\n+        {\n+            foreach (var nodeKvp in allNodes)\n+            {\n+                var outerBuild = nodeKvp.Value;\n+\n+                if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)\n+                {\n+                    foreach (var innerBuild in outerBuild.ProjectReferences)\n+                    {\n+                        foreach (var referencingProject in outerBuild.ReferencingProjects)\n+                        {\n+                            referencingProject.AddProjectReference(innerBuild);\n+                        }\n+                    }\n+\n+                    outerBuild.RemoveReferences();\n+                }\n+            }\n+        }\n+\n+        private static IEnumerable<ProjectItemInstance> GetInnerBuildReferences(ProjectInstance outerBuild)\n+        {\n+            var globalPropertyName = GetInnerBuildPropertyName(outerBuild);\n+            var globalPropertyValues = GetInnerBuildPropertyValues(outerBuild);\n+\n+            ErrorUtilities.VerifyThrow(!String.IsNullOrWhiteSpace(globalPropertyName), \"Must have an inner build property\");\n+            ErrorUtilities.VerifyThrow(!String.IsNullOrWhiteSpace(globalPropertyValues), \"Must have values for the inner build property\");\n+\n+            foreach (var globalPropertyValue in ExpressionShredder.SplitSemiColonSeparatedList(globalPropertyValues))\n+            {\n+                yield return new ProjectItemInstance(\n+                    outerBuild,\n+                    \"_ProjectSelfReference\",\n+                    outerBuild.FullPath,\n+                    new[] {new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $\"{globalPropertyName}={globalPropertyValue}\")},\n+                    outerBuild.FullPath);\n+            }\n+        }\n+\n+        /// <summary>\n+        ///     Gets the effective global properties for a project reference item.\n+        /// </summary>\n+        /// <remarks>\n+        ///     The behavior of this method should match the logic in the SDK\n+        /// </remarks>\n+        private static GlobalPropertyPartsForMSBuildTask ProjectReferenceGlobalPropertiesModifier(\n+            GlobalPropertyPartsForMSBuildTask defaultParts,\n+            ProjectItemInstance projectReference\n+        )\n+        {\n+            // ProjectReference defines yet another metadata name containing properties to undefine. Merge it in if non empty.\n+            var globalPropertiesToRemove = SplitPropertyNames(projectReference.GetMetadataValue(GlobalPropertiesToRemoveMetadataName));\n+\n+            var newUndefineProperties = defaultParts.UndefineProperties;\n+\n+            newUndefineProperties = newUndefineProperties.AddRange(defaultParts.UndefineProperties);\n+            newUndefineProperties = newUndefineProperties.AddRange(globalPropertiesToRemove);\n+\n+            newUndefineProperties.Add(\"InnerBuildProperty\");\n+\n+            var newProperties = defaultParts.Properties;\n+\n+            // The properties on the project reference supersede the ones from the MSBuild task instead of appending.\n+            if (newProperties.Count == 0)\n+            {\n+                // TODO: Mimic AssignProjectConfiguration's behavior for determining the values for these.\n+                var setConfigurationString = projectReference.GetMetadataValue(SetConfigurationMetadataName);\n+                var setPlatformString = projectReference.GetMetadataValue(SetPlatformMetadataName);\n+                var setTargetFrameworkString = projectReference.GetMetadataValue(SetTargetFrameworkMetadataName);\n+\n+                if (!String.IsNullOrEmpty(setConfigurationString) || !String.IsNullOrEmpty(setPlatformString) || !String.IsNullOrEmpty(setTargetFrameworkString))\n+                {\n+                    newProperties = SplitPropertyNameValuePairs(\n+                        ItemMetadataNames.PropertiesMetadataName,\n+                        $\"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}\").ToImmutableDictionary();\n+                }\n+            }\n+\n+            return new GlobalPropertyPartsForMSBuildTask(newProperties, defaultParts.AdditionalProperties, newUndefineProperties);\n+        }\n+\n+        private readonly struct GlobalPropertyPartsForMSBuildTask\n+        {\n+            public ImmutableDictionary<string, string> Properties { get; }\n+            public ImmutableDictionary<string, string> AdditionalProperties { get; }\n+            public ImmutableList<string> UndefineProperties { get; }\n+\n+            public GlobalPropertyPartsForMSBuildTask(\n+                ImmutableDictionary<string, string> properties,\n+                ImmutableDictionary<string, string> additionalProperties,\n+                ImmutableList<string> undefineProperties)\n+            {\n+                Properties = properties;\n+                AdditionalProperties = additionalProperties;\n+                UndefineProperties = undefineProperties;\n+            }\n+\n+            public bool AllEmpty()\n+            {\n+                return Properties.Count == 0 && AdditionalProperties.Count == 0 && UndefineProperties.Count == 0;\n+            }\n+\n+            public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyToUndefine)\n+            {\n+                return new GlobalPropertyPartsForMSBuildTask(Properties, AdditionalProperties, UndefineProperties.Add(propertyToUndefine));\n+            }\n+        }\n+\n+        delegate GlobalPropertyPartsForMSBuildTask GlobalPropertiesModifier(GlobalPropertyPartsForMSBuildTask defaultParts, ProjectItemInstance projectReference);\n+\n+        /// <summary>\n+        ///     Gets the effective global properties for an item that will get passed to <see cref=\"MSBuild.Projects\"/>.\n+        /// </summary>\n+        /// <remarks>\n+        ///     The behavior of this method matches the hardcoded behaviour of the msbuild task\n+        ///     and the <paramref name=\"globalPropertyModifiers\"/> parameter can contain other mutations done at build time in targets / tasks\n+        /// </remarks>\n+        private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesForItem(\n+            ProjectItemInstance projectReference,\n+            PropertyDictionary<ProjectPropertyInstance> requesterGlobalProperties,\n+            IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers = null)\n+        {\n+            ErrorUtilities.VerifyThrowInternalNull(projectReference, nameof(projectReference));\n+            ErrorUtilities.VerifyThrowArgumentNull(requesterGlobalProperties, nameof(requesterGlobalProperties));\n+\n+            var properties = SplitPropertyNameValuePairs(ItemMetadataNames.PropertiesMetadataName, projectReference.GetMetadataValue(ItemMetadataNames.PropertiesMetadataName));\n+            var additionalProperties = SplitPropertyNameValuePairs(ItemMetadataNames.AdditionalPropertiesMetadataName, projectReference.GetMetadataValue(ItemMetadataNames.AdditionalPropertiesMetadataName));\n+            var undefineProperties = SplitPropertyNames(projectReference.GetMetadataValue(ItemMetadataNames.UndefinePropertiesMetadataName));\n+\n+            var defaultParts = new GlobalPropertyPartsForMSBuildTask(properties.ToImmutableDictionary(), additionalProperties.ToImmutableDictionary(), undefineProperties.ToImmutableList());\n+\n+            var globalPropertyParts = globalPropertyModifiers?.Aggregate(defaultParts, (currentProperties, modifier) => modifier(currentProperties, projectReference)) ?? defaultParts;\n+\n+            if (globalPropertyParts.AllEmpty())\n+            {\n+                return requesterGlobalProperties;\n+            }\n+\n+            // Make a copy to avoid mutating the requester\n+            var globalProperties = new PropertyDictionary<ProjectPropertyInstance>(requesterGlobalProperties);\n+\n+            // Append and remove properties as specified by the various metadata\n+            MergeIntoPropertyDictionary(globalProperties, globalPropertyParts.Properties);\n+            MergeIntoPropertyDictionary(globalProperties, globalPropertyParts.AdditionalProperties);\n+            RemoveFromPropertyDictionary(globalProperties, globalPropertyParts.UndefineProperties);\n+\n+            return globalProperties;\n+        }\n+\n+        private static void MergeIntoPropertyDictionary(\n+            PropertyDictionary<ProjectPropertyInstance> destination,\n+            IReadOnlyDictionary<string, string> source)\n+        {\n+            foreach (var pair in source)\n+            {\n+                destination[pair.Key] = ProjectPropertyInstance.Create(pair.Key, pair.Value);\n+            }\n+        }\n+\n+        private static IReadOnlyDictionary<string, string> SplitPropertyNameValuePairs(string syntaxName, string propertyNameAndValuesString)\n+        {\n+            if (String.IsNullOrEmpty(propertyNameAndValuesString))\n+            {\n+                return ImmutableDictionary<string, string>.Empty;\n+            }\n+\n+            if (PropertyParser.GetTableWithEscaping(\n+                null,\n+                null,\n+                null,\n+                propertyNameAndValuesString.Split(PropertySeparator, StringSplitOptions.RemoveEmptyEntries),\n+                out var propertiesTable))\n+            {\n+                return propertiesTable;\n+            }\n+\n+            throw new InvalidProjectFileException(\n+                String.Format(\n+                    CultureInfo.InvariantCulture,\n+                    ResourceUtilities.GetResourceString(\"General.InvalidPropertyError\"),\n+                    syntaxName,\n+                    propertyNameAndValuesString));\n+        }\n+\n+        private static IReadOnlyCollection<string> SplitPropertyNames(string propertyNamesString)\n+        {\n+            if (String.IsNullOrEmpty(propertyNamesString))\n+            {\n+                return ImmutableArray<string>.Empty;\n+            }\n+\n+            return propertyNamesString.Split(PropertySeparator, StringSplitOptions.RemoveEmptyEntries);\n+        }\n+\n+        private static void RemoveFromPropertyDictionary(\n+            PropertyDictionary<ProjectPropertyInstance> properties,\n+            IReadOnlyCollection<string> propertyNamesToRemove)\n+        {\n+            foreach (var propertyName in propertyNamesToRemove)\n+            {\n+                properties.Remove(propertyName);\n+            }\n+        }\n+\n+        public readonly struct TargetsToPropagate\n+        {\n+            private readonly ImmutableList<string> _outerBuildTargets;\n+            private readonly ImmutableList<string> _allTargets;\n+\n+            private TargetsToPropagate(ImmutableList<string> outerBuildTargets, ImmutableList<string> nonOuterBuildTargets)\n+            {\n+                _outerBuildTargets = outerBuildTargets;\n+\n+                // Since non outer builds act both as outer and inner builds, they need to implement both sets of targets\n+                // Outer build targets go first because at build time outer builds are built before inner builds",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Just wasted work, not a correctness problem? I can live with that for a while.",
              "createdAt": "2019-03-21T19:45:57Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -479,28 +673,19 @@ private static IReadOnlyCollection<ProjectGraphNode> TopologicalSort(IReadOnlyCo\n                     projectToEvaluate = projectsToEvaluate.Dequeue();\n                     var task = new Task(() =>\n                     {\n-                        ProjectGraphNode parsedProject = CreateNewNode(projectToEvaluate, projectCollection, projectInstanceFactory);\n-                        IEnumerable<ProjectItemInstance> projectReferenceItems = parsedProject.ProjectInstance.GetItems(MSBuildConstants.ProjectReferenceItemName);\n-                        foreach (var projectReferenceToParse in projectReferenceItems)\n-                        {\n-                            if (!string.IsNullOrEmpty(projectReferenceToParse.GetMetadataValue(ToolsVersionMetadataName)))\n-                            {\n-                                throw new InvalidOperationException(string.Format(\n-                                    CultureInfo.InvariantCulture,\n-                                    ResourceUtilities.GetResourceString(\n-                                        \"ProjectGraphDoesNotSupportProjectReferenceWithToolset\"),\n-                                    projectReferenceToParse.EvaluatedInclude,\n-                                    parsedProject.ProjectInstance.FullPath));\n-                            }\n+                        var parsedProject = CreateNewNode(projectToEvaluate, projectCollection, projectInstanceFactory, allParsedProjects);\n \n-                            string projectReferenceFullPath = projectReferenceToParse.GetMetadataValue(FullPathMetadataName);\n-                            PropertyDictionary<ProjectPropertyInstance> projectReferenceGlobalProperties = GetProjectReferenceGlobalProperties(projectReferenceToParse, projectToEvaluate.GlobalProperties);\n-                            var projectReferenceConfigurationMetadata = new ConfigurationMetadata(projectReferenceFullPath, projectReferenceGlobalProperties);\n-                            if (!tasksInProgress.ContainsKey(projectReferenceConfigurationMetadata))\n+                        foreach (var referenceConfig in projectInterpretation.GetReferences(parsedProject.ProjectInstance))\n+                        {\n+                             /*todo: fix the following double check-then-act concurrency bug: one thread can pass the two checks, loose context,\n+                             meanwhile another thread passes the same checks with the same data and inserts its reference. The initial thread regains context\n+                             and duplicates the information, leading to wasted work",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "As far as I can tell, not a correctness problem.",
              "createdAt": "2019-03-22T18:40:00Z",
              "path": "src/Build/Graph/ProjectGraph.cs",
              "diffHunk": "@@ -479,28 +673,19 @@ private static IReadOnlyCollection<ProjectGraphNode> TopologicalSort(IReadOnlyCo\n                     projectToEvaluate = projectsToEvaluate.Dequeue();\n                     var task = new Task(() =>\n                     {\n-                        ProjectGraphNode parsedProject = CreateNewNode(projectToEvaluate, projectCollection, projectInstanceFactory);\n-                        IEnumerable<ProjectItemInstance> projectReferenceItems = parsedProject.ProjectInstance.GetItems(MSBuildConstants.ProjectReferenceItemName);\n-                        foreach (var projectReferenceToParse in projectReferenceItems)\n-                        {\n-                            if (!string.IsNullOrEmpty(projectReferenceToParse.GetMetadataValue(ToolsVersionMetadataName)))\n-                            {\n-                                throw new InvalidOperationException(string.Format(\n-                                    CultureInfo.InvariantCulture,\n-                                    ResourceUtilities.GetResourceString(\n-                                        \"ProjectGraphDoesNotSupportProjectReferenceWithToolset\"),\n-                                    projectReferenceToParse.EvaluatedInclude,\n-                                    parsedProject.ProjectInstance.FullPath));\n-                            }\n+                        var parsedProject = CreateNewNode(projectToEvaluate, projectCollection, projectInstanceFactory, allParsedProjects);\n \n-                            string projectReferenceFullPath = projectReferenceToParse.GetMetadataValue(FullPathMetadataName);\n-                            PropertyDictionary<ProjectPropertyInstance> projectReferenceGlobalProperties = GetProjectReferenceGlobalProperties(projectReferenceToParse, projectToEvaluate.GlobalProperties);\n-                            var projectReferenceConfigurationMetadata = new ConfigurationMetadata(projectReferenceFullPath, projectReferenceGlobalProperties);\n-                            if (!tasksInProgress.ContainsKey(projectReferenceConfigurationMetadata))\n+                        foreach (var referenceConfig in projectInterpretation.GetReferences(parsedProject.ProjectInstance))\n+                        {\n+                             /*todo: fix the following double check-then-act concurrency bug: one thread can pass the two checks, loose context,\n+                             meanwhile another thread passes the same checks with the same data and inserts its reference. The initial thread regains context\n+                             and duplicates the information, leading to wasted work",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "@nguerrera @livarcocc and maybe @jaredpar or @agocke: any objections to introducing this new common targets file, intended to be imported from `Microsoft.CSharp.targets` and similar for other languages?\r\n\r\n",
              "createdAt": "2019-03-21T19:48:55Z",
              "path": "src/Tasks/Microsoft.ManagedLanguages.targets",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff<!--\n+***********************************************************************************************\n+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\n+          created a backup copy.  Incorrect changes to this file will make it\n+          impossible to load or build your projects from the command-line or the IDE.\n+\n+This file defines common build logic for all managed languaged: C#, VisualBasic, F#",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "No real concerns, but let me bikeshed on the name while I'm here. :)\r\n\r\nThere are two analogs to this already:\r\n\r\n* [Microsoft.Managed.Core.targets](https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/MSBuildTask/Microsoft.Managed.Core.targets)\r\n* [Microsoft.Managed.DesignTime.targets](https://github.com/dotnet/project-system/blob/master/src/Microsoft.VisualStudio.ProjectSystem.Managed/ProjectSystem/DesignTimeTargets/Microsoft.Managed.DesignTime.targets)\r\n\r\nFollowing an emergent pattern, this one should be Microsoft.Managed.targets.\r\n\r\nThe pattern I see is X.targets -> msbuild, X.DesignTime.targets -> project-system., X.Core.targets -> roslyn\r\n\r\n",
              "createdAt": "2019-03-21T19:59:11Z",
              "path": "src/Tasks/Microsoft.ManagedLanguages.targets",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff<!--\n+***********************************************************************************************\n+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\n+          created a backup copy.  Incorrect changes to this file will make it\n+          impossible to load or build your projects from the command-line or the IDE.\n+\n+This file defines common build logic for all managed languaged: C#, VisualBasic, F#",
              "author": {
                "login": "nguerrera"
              }
            },
            {
              "body": "Good observation. I'll rename it to `Microsoft.Managed.targets`",
              "createdAt": "2019-03-21T21:02:03Z",
              "path": "src/Tasks/Microsoft.ManagedLanguages.targets",
              "diffHunk": "@@ -0,0 +1,64 @@\n+\ufeff<!--\n+***********************************************************************************************\n+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\n+          created a backup copy.  Incorrect changes to this file will make it\n+          impossible to load or build your projects from the command-line or the IDE.\n+\n+This file defines common build logic for all managed languaged: C#, VisualBasic, F#",
              "author": {
                "login": "cdmihai"
              }
            }
          ]
        }
      }
    ]
  }
}