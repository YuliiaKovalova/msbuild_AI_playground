{
  "number": 9588,
  "title": "Add NGEN documentation (NETFramework-NGEN.md)",
  "body": "### Context\r\n\r\nAdding a brain-dump document focused on NGEN as there's been some recent work in the area.\r\n\r\n### Changes Made\r\n\r\nA new file + fixing the name of an existing docs file.",
  "state": "MERGED",
  "createdAt": "2024-01-03T14:49:38Z",
  "updatedAt": "2024-01-08T08:24:38Z",
  "closedAt": "2024-01-08T08:24:38Z",
  "mergedAt": "2024-01-08T08:24:38Z",
  "additions": 119,
  "deletions": 0,
  "changedFiles": 2,
  "headRefName": "fx-loading-docs",
  "isDraft": false,
  "author": {
    "login": "ladipro"
  },
  "milestone": null,
  "assignees": {
    "nodes": [
      {
        "login": "ladipro"
      }
    ]
  },
  "labels": [],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "0904f9b52c94e4e2499785a04f94d76348c12766",
          "message": "Add NGEN documentation",
          "committedDate": "2024-01-03T14:46:15Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "f2fccb106dc1fe092c6005db245c71191874908a",
          "message": "Fix typos",
          "committedDate": "2024-01-03T20:48:21Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "6f758c1cf86d1d5ae4015af9e63a424a3892cf4b",
          "message": "Update based on @jeffkl's feedback",
          "committedDate": "2024-01-04T14:53:00Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "laprosek@microsoft.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d42e1d2312ceb95cd76fc3c9d2dbe6a835396d12",
          "message": "Apply suggestions from code review\n\nCo-authored-by: Rainer Sigwald <raines@microsoft.com>",
          "committedDate": "2024-01-08T07:51:58Z",
          "author": {
            "name": "Ladi Prosek",
            "email": "ladi.prosek@gmail.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": []
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "@jeffkl I believe you've also looked at optimizing NuGet resolver startup/JITting. Curious if you have any insights. Thank you!",
              "createdAt": "2024-01-03T20:46:54Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,118 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.\n+\n+```\n+<qualifyAssembly partialName=\"Microsoft.DotNet.MSBuildSdkResolver\" fullName=\"Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\" />\n+```\n+\n+This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`\n+directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.\n+\n+The resolver loading logic in MSBuild has been updated to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the\n+simple name of the assembly, e.g. `Microsoft.DotNet.MSBuildSdkResolver`, as well as its `CodeBase` (file path). This way the CLR assembly\n+loader will try to load the assembly into the default context first - a necessary condition for the native image to be used - and fall back\n+to LoadFrom if the simple name wasn't resolved.\n+\n+### Microsoft.Build.NuGetSdkResolver\n+\n+The NuGet resolver has many dependencies and its version is frequently changing. Due to the way Visual Studio is composed, MSBuild does\n+not know at its build time the exact version it will be loading at run-time. We would need a creative installer solution to be able to\n+have MSbuild.exe.config contain the right entries to load this resolver the same way as `Microsoft.DotNet.MSBuildSdkResolver``. A more\n+promising direction is loading this resolver into a separate AppDomain (see the section about NuGet.Frameworks below).\n+\n+The problem of JITting `Microsoft.Build.NuGetSdkResolver` remains unsolved for now.",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I was going to investigate doing the following:\r\n\r\n1. ILMerge everything into the NuGet-based MSBuild project SDK resolver so its only a single assembly\r\n2. Stop changing the assembly version and only change the informational version\r\n3. Ship it next to MSBuild by \"inserting\" it into MSBuild or add a `codeBase` entry in the `MSBuild.exe.config` since it can be relative.\r\n\r\n#1 provided a surprising amount of improvement but some people are opposed to merging \r\n#2 should be a no-brainer in my opinion, I stopped rev'ing assembly versions a long time ago for everything I own\r\n\r\nI did a test of this in early 2023 where I ILMerged the SDK resolver, manually edited the `MSBuild.exe.config` and built a local copy of MSBuild with changes to SDK resolver loading that worked against an assembly name rather than a path.  I saw a big performance increase for startup times when using the NuGet-based MSBuild project SDK resolver.  Let me know if you want me to dig up the branch where I made changes to MSBuild to load SDK resolvers by name instead of path.",
              "createdAt": "2024-01-03T20:56:20Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,118 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.\n+\n+```\n+<qualifyAssembly partialName=\"Microsoft.DotNet.MSBuildSdkResolver\" fullName=\"Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\" />\n+```\n+\n+This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`\n+directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.\n+\n+The resolver loading logic in MSBuild has been updated to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the\n+simple name of the assembly, e.g. `Microsoft.DotNet.MSBuildSdkResolver`, as well as its `CodeBase` (file path). This way the CLR assembly\n+loader will try to load the assembly into the default context first - a necessary condition for the native image to be used - and fall back\n+to LoadFrom if the simple name wasn't resolved.\n+\n+### Microsoft.Build.NuGetSdkResolver\n+\n+The NuGet resolver has many dependencies and its version is frequently changing. Due to the way Visual Studio is composed, MSBuild does\n+not know at its build time the exact version it will be loading at run-time. We would need a creative installer solution to be able to\n+have MSbuild.exe.config contain the right entries to load this resolver the same way as `Microsoft.DotNet.MSBuildSdkResolver``. A more\n+promising direction is loading this resolver into a separate AppDomain (see the section about NuGet.Frameworks below).\n+\n+The problem of JITting `Microsoft.Build.NuGetSdkResolver` remains unsolved for now.",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "Thank you for the prompt response.\r\n\r\n> Let me know if you want me to dig up the branch where I made changes to MSBuild to load SDK resolvers by name instead of path.\r\n\r\nThis is actually [already merged](https://github.com/dotnet/msbuild/pull/9439) and shipping in 17.9, affecting only `Microsoft.DotNet.MSBuildSdkResolver` which we were able to version-freeze. The impact on startup perf was indeed quite dramatic and it would be awesome if we can apply to the NuGet resolver as well.\r\n\r\nIs there anything I can do to help make this happen?",
              "createdAt": "2024-01-03T21:09:36Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,118 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.\n+\n+```\n+<qualifyAssembly partialName=\"Microsoft.DotNet.MSBuildSdkResolver\" fullName=\"Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\" />\n+```\n+\n+This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`\n+directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.\n+\n+The resolver loading logic in MSBuild has been updated to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the\n+simple name of the assembly, e.g. `Microsoft.DotNet.MSBuildSdkResolver`, as well as its `CodeBase` (file path). This way the CLR assembly\n+loader will try to load the assembly into the default context first - a necessary condition for the native image to be used - and fall back\n+to LoadFrom if the simple name wasn't resolved.\n+\n+### Microsoft.Build.NuGetSdkResolver\n+\n+The NuGet resolver has many dependencies and its version is frequently changing. Due to the way Visual Studio is composed, MSBuild does\n+not know at its build time the exact version it will be loading at run-time. We would need a creative installer solution to be able to\n+have MSbuild.exe.config contain the right entries to load this resolver the same way as `Microsoft.DotNet.MSBuildSdkResolver``. A more\n+promising direction is loading this resolver into a separate AppDomain (see the section about NuGet.Frameworks below).\n+\n+The problem of JITting `Microsoft.Build.NuGetSdkResolver` remains unsolved for now.",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "The NuGet-based MSBuild project SDK resolver is loaded [via a manifest](https://github.com/dotnet/msbuild/blob/main/src/MSBuild/SdkResolvers/VS/Microsoft.Build.NuGetSdkResolver.xml), I had originally envisioned us updating the manifest reading code to look for a `name` element instead of a `path` but I suppose your change would work as well.  We'd need to ILMerge the SDK resolver and lock the version which is pretty simple.  Unfortunately, I'm not sure I'll have time in January to work on this.",
              "createdAt": "2024-01-03T21:20:36Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,118 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.\n+\n+```\n+<qualifyAssembly partialName=\"Microsoft.DotNet.MSBuildSdkResolver\" fullName=\"Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\" />\n+```\n+\n+This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`\n+directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.\n+\n+The resolver loading logic in MSBuild has been updated to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the\n+simple name of the assembly, e.g. `Microsoft.DotNet.MSBuildSdkResolver`, as well as its `CodeBase` (file path). This way the CLR assembly\n+loader will try to load the assembly into the default context first - a necessary condition for the native image to be used - and fall back\n+to LoadFrom if the simple name wasn't resolved.\n+\n+### Microsoft.Build.NuGetSdkResolver\n+\n+The NuGet resolver has many dependencies and its version is frequently changing. Due to the way Visual Studio is composed, MSBuild does\n+not know at its build time the exact version it will be loading at run-time. We would need a creative installer solution to be able to\n+have MSbuild.exe.config contain the right entries to load this resolver the same way as `Microsoft.DotNet.MSBuildSdkResolver``. A more\n+promising direction is loading this resolver into a separate AppDomain (see the section about NuGet.Frameworks below).\n+\n+The problem of JITting `Microsoft.Build.NuGetSdkResolver` remains unsolved for now.",
              "author": {
                "login": "jeffkl"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThis is the most-commonly-used resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK and .NET SDK workloads. Since the resolver assembly\r\n```",
              "createdAt": "2024-01-05T16:17:40Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,119 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nfreeze the version of the resolver plus dependencies, so that their full names can be specified in `MSBuild.exe.config`, e.g.\r\n```",
              "createdAt": "2024-01-05T16:22:12Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,119 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "````suggestion\r\n```xml\r\n````",
              "createdAt": "2024-01-05T16:22:25Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,119 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "````suggestion\r\n```xml\r\n````",
              "createdAt": "2024-01-05T16:23:11Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,119 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.\n+\n+```",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "\r\n```suggestion\r\nAdditionally, `MSBuild.exe.config` has the following entry, which enables us to refer to the resolver by simple name.\r\n```",
              "createdAt": "2024-01-05T16:23:20Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,119 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nThe resolver loading logic in MSBuild [has been updated](https://github.com/dotnet/msbuild/pull/9439) to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the\r\n```",
              "createdAt": "2024-01-05T16:24:02Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,119 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.\n+\n+```\n+<qualifyAssembly partialName=\"Microsoft.DotNet.MSBuildSdkResolver\" fullName=\"Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\" />\n+```\n+\n+This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`\n+directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.\n+\n+The resolver loading logic in MSBuild has been updated to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\ndoes not apply in its current state. However, the NuGet team is looking to address this by:\r\n```",
              "createdAt": "2024-01-05T16:25:34Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,119 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.\n+\n+```\n+<qualifyAssembly partialName=\"Microsoft.DotNet.MSBuildSdkResolver\" fullName=\"Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\" />\n+```\n+\n+This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`\n+directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.\n+\n+The resolver loading logic in MSBuild has been updated to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the\n+simple name of the assembly, e.g. `Microsoft.DotNet.MSBuildSdkResolver`, as well as its `CodeBase` (file path). This way the CLR assembly\n+loader will try to load the assembly into the default context first - a necessary condition for the native image to be used - and fall back\n+to LoadFrom if the simple name wasn't resolved.\n+\n+### Microsoft.Build.NuGetSdkResolver\n+\n+The NuGet resolver has many dependencies and its version is frequently changing, so the technique used for `Microsoft.DotNet.MSBuildSdkResolver`\n+does not apply in its current state. However, the NuGet team it looking to address this by:",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Got a link for this? I didn't see a bug on nuget/home beyond the long-closed https://github.com/NuGet/Home/issues/4350",
              "createdAt": "2024-01-05T16:25:45Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,119 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.\n+\n+```\n+<qualifyAssembly partialName=\"Microsoft.DotNet.MSBuildSdkResolver\" fullName=\"Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\" />\n+```\n+\n+This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`\n+directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.\n+\n+The resolver loading logic in MSBuild has been updated to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the\n+simple name of the assembly, e.g. `Microsoft.DotNet.MSBuildSdkResolver`, as well as its `CodeBase` (file path). This way the CLR assembly\n+loader will try to load the assembly into the default context first - a necessary condition for the native image to be used - and fall back\n+to LoadFrom if the simple name wasn't resolved.\n+\n+### Microsoft.Build.NuGetSdkResolver\n+\n+The NuGet resolver has many dependencies and its version is frequently changing, so the technique used for `Microsoft.DotNet.MSBuildSdkResolver`\n+does not apply in its current state. However, the NuGet team it looking to address this by:",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Nothing specific yet, but the tracking epic is at https://github.com/NuGet/Home/issues/11441",
              "createdAt": "2024-01-05T16:32:13Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,119 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.\n+\n+```\n+<qualifyAssembly partialName=\"Microsoft.DotNet.MSBuildSdkResolver\" fullName=\"Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\" />\n+```\n+\n+This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`\n+directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.\n+\n+The resolver loading logic in MSBuild has been updated to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the\n+simple name of the assembly, e.g. `Microsoft.DotNet.MSBuildSdkResolver`, as well as its `CodeBase` (file path). This way the CLR assembly\n+loader will try to load the assembly into the default context first - a necessary condition for the native image to be used - and fall back\n+to LoadFrom if the simple name wasn't resolved.\n+\n+### Microsoft.Build.NuGetSdkResolver\n+\n+The NuGet resolver has many dependencies and its version is frequently changing, so the technique used for `Microsoft.DotNet.MSBuildSdkResolver`\n+does not apply in its current state. However, the NuGet team it looking to address this by:",
              "author": {
                "login": "jeffkl"
              }
            },
            {
              "body": "That's plenty, thanks!\r\n\r\n```suggestion\r\ndoes not apply in its current state. However, the NuGet team is [looking to address this](https://github.com/NuGet/Home/issues/11441) by:\r\n```",
              "createdAt": "2024-01-05T16:38:15Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,119 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.\n+\n+```\n+<qualifyAssembly partialName=\"Microsoft.DotNet.MSBuildSdkResolver\" fullName=\"Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\" />\n+```\n+\n+This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`\n+directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.\n+\n+The resolver loading logic in MSBuild has been updated to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the\n+simple name of the assembly, e.g. `Microsoft.DotNet.MSBuildSdkResolver`, as well as its `CodeBase` (file path). This way the CLR assembly\n+loader will try to load the assembly into the default context first - a necessary condition for the native image to be used - and fall back\n+to LoadFrom if the simple name wasn't resolved.\n+\n+### Microsoft.Build.NuGetSdkResolver\n+\n+The NuGet resolver has many dependencies and its version is frequently changing, so the technique used for `Microsoft.DotNet.MSBuildSdkResolver`\n+does not apply in its current state. However, the NuGet team it looking to address this by:",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "```suggestion\r\nin each installed SDK would need to be NGENed against each installed version of VS).\r\n```",
              "createdAt": "2024-01-05T16:27:51Z",
              "path": "documentation/NETFramework-NGEN.md",
              "diffHunk": "@@ -0,0 +1,119 @@\n+# .NET Framework NGEN Considerations\n+\n+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,\n+NGEN has the following key characteristics:\n+- Native code is always stored in separate images located in a machine-wide cache.\n+- Native images are generated on user machines, typically during app installation, by an elevated process.\n+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.\n+\n+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.\n+\n+## NGEN in Visual Studio\n+\n+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be\n+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,\n+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the\n+machine is idle. To force native images to be generated, one can execute the following command in an elevated\n+terminal window:\n+\n+```\n+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ngen eqi\n+```\n+\n+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`\n+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild\n+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.\n+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\\MSBuild\\Current\\Bin`\n+or `[VS install dir]\\MSBuild\\Current\\Bin\\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -\n+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.\n+The special `[installDir]\\Common7\\IDE\\vsn.exe` entry represents devenv.\n+\n+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or\n+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good\n+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected\n+by the VS PR gates so they are fixed before MSBuild is inserted into the product.\n+\n+## NGEN image loading rules\n+\n+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of \"NGEN rejections\" where a native\n+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly\n+and JITting code on demand, leading to sub-optimal performance.\n+\n+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice\n+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.\n+This is bad news for any app with an add-in system where extension assemblies are loaded by path.\n+\n+## SDK resolvers\n+\n+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover\n+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually\n+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is\n+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to\n+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions\n+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.\n+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)\n+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. \n+\n+### Microsoft.DotNet.MSBuildSdkResolver\n+\n+This is the base resolver, capable of resolving \"in-box\" SDKs that ship with the .NET SDK, and workloads. Since the resolver assembly\n+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to\n+freeze the version of the resolver plus dependencies, so that their full names can be specified in MSBuild.exe.config, e.g.\n+\n+```\n+    <dependentAssembly>\n+      <assemblyIdentity name=\"Microsoft.DotNet.MSBuildSdkResolver\" culture=\"neutral\" publicKeyToken=\"adb9793829ddae60\" />\n+      <codeBase version=\"8.0.100.0\" href=\".\\SdkResolvers\\Microsoft.DotNet.MSBuildSdkResolver\\Microsoft.DotNet.MSBuildSdkResolver.dll\" />\n+    </dependentAssembly>\n+```\n+\n+Additionally, MSBuild.exe.config has the following entry, which enables us to refer to the resolver by simple name.\n+\n+```\n+<qualifyAssembly partialName=\"Microsoft.DotNet.MSBuildSdkResolver\" fullName=\"Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\" />\n+```\n+\n+This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`\n+directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.\n+\n+The resolver loading logic in MSBuild has been updated to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the\n+simple name of the assembly, e.g. `Microsoft.DotNet.MSBuildSdkResolver`, as well as its `CodeBase` (file path). This way the CLR assembly\n+loader will try to load the assembly into the default context first - a necessary condition for the native image to be used - and fall back\n+to LoadFrom if the simple name wasn't resolved.\n+\n+### Microsoft.Build.NuGetSdkResolver\n+\n+The NuGet resolver has many dependencies and its version is frequently changing, so the technique used for `Microsoft.DotNet.MSBuildSdkResolver`\n+does not apply in its current state. However, the NuGet team it looking to address this by:\n+\n+1) ILMerge'ing the resolver with its dependencies into a single assembly.\n+2) Freezing the version of the assembly.\n+\n+When this happens, the cost of JITting `Microsoft.Build.NuGetSdkResolver` will be eliminated as well.\n+\n+## NuGet.Frameworks\n+\n+When evaluating certain property functions, MSBuild requires functionality from `NuGet.Frameworks.dll`, which is not part of MSBuild proper.\n+The assembly is loaded lazily from a path calculated based on the environment where MSBuild is running and the functionality is invoked\n+via reflection. Similar to the NuGet resolver, the version is changing and it is not easy to know it statically at MSBuild's build time.\n+But, since there are only a handful of APIs used by MSBuild and they take simple types such as strings and versions, this has been\n+addressed by loading the assembly into a separate AppDomain. The AppDomain's config file is created in memory on the fly to contain the\n+right binding redirects, allowing MSBuild to use `Assembly.Load` and get the native image loaded if it exists.\n+\n+This approach has some small startup cost (building the config, creating AppDomain & a `MarshalByRefObject`) and a small run-time overhead\n+of cross-domain calls. The former is orders of magnitude smaller that the startup hit of JITting and the latter is negligible as long as\n+the types moved across the AppDomain boundary do not require expensive marshaling.\n+\n+## Task assemblies\n+\n+This is the proverbial elephant in the room. MSBuild learns about tasks dynamically as it parses project files. The `UsingTask`\n+element tends to specify the `AssemblyFile` attribute, pointing to the task assembly by path. Consequently MSBuild uses\n+`Assembly.LoadFrom` and no native images are loaded. Even task assemblies located in the SDK are problematic because MSBuild is\n+paired with an SDK on users machine at run-time. Unlike SDK resolvers and NuGet.Frameworks, which are part of the same installation\n+unit, this is a true dynamic inter-product dependency. Additionally, the task API is complex and involves a lot of functionality\n+provided to tasks via callbacks (e.g. logging) so the overhead of cross-domain calls may be significant. And that's assuming that\n+suitable native images exist in the first place, something that both VS and SDK installers would need to handle (task assemblies\n+in each installed SDK are NGENed against each installed version of VS).",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      }
    ]
  }
}