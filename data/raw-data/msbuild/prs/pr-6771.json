{
  "number": 6771,
  "title": "Add Microsoft.IO.Redist for directory enumeration.",
  "body": "Fixes #6075\r\n\r\n### Context\r\nMicrosoft.IO.Redist brings some of the new .NET Core System.IO functionality to .NET Framework. In particular, enumeration in Microsoft.IO was optimized comparing to System.IO: new enumeration API was added and old one was improved. We consider it is beneficial to switch default file system enumeration to the old API from Microsoft.IO.Redist.\r\n\r\n### Changes Made\r\n\r\n- Added Microsoft.IO.Redist\r\n- Default file system enumeration uses Microsoft.IO instead of System.IO\r\n\r\n### Testing\r\nUnit tests & DDRITs\r\n\r\n### Notes\r\nWe should be wary of possible regressions. There were differences in behavior, see `.NET Framework only` notes in [doc](https://docs.microsoft.com/en-us/dotnet/api/system.io.directory.enumeratefiles?view=net-5.0). The change therefore is under change wave 17_0.",
  "state": "MERGED",
  "createdAt": "2021-08-18T12:55:35Z",
  "updatedAt": "2021-10-15T08:51:11Z",
  "closedAt": "2021-10-15T08:51:11Z",
  "mergedAt": "2021-10-15T08:51:09Z",
  "additions": 106,
  "deletions": 4,
  "changedFiles": 13,
  "headRefName": "add-microsoft-io-redist-3",
  "isDraft": false,
  "author": {
    "login": "AR-May"
  },
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": [
    "Area: Performance",
    "merge-when-branch-open"
  ],
  "commits": {
    "nodes": [
      {
        "commit": {
          "oid": "eb07877f179e6243c84cf578ab0a9d08957908a5",
          "message": "Add Microsoft.IO.Redist.",
          "committedDate": "2021-09-08T09:39:35Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "eb73956558aa426a8e62fcf9a48f9f5f9fbce0dc",
          "message": "Add Microsoft.IO.Redist to Deploy-MSBuild.ps1.",
          "committedDate": "2021-09-08T09:39:35Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "81311bdbcf551036d93889f0ada5acc23258deff",
          "message": "Use Microsoft.IO to for enumeration in ManagedFileSystem.",
          "committedDate": "2021-09-08T09:39:36Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "e3976159de085ec5ec60961fcba0a654a58d047c",
          "message": "Fix outdated unit test.",
          "committedDate": "2021-09-08T09:39:36Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "c80ababb79fbe020a636cc21dc3001639374ddb0",
          "message": "Fix Microsoft.IO.Redist version & ngen settings.",
          "committedDate": "2021-09-08T09:39:36Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "55addd2f5f894a8e5697d734b35cdd4848489699",
          "message": "Improve an obscure error message.",
          "committedDate": "2021-10-01T13:47:06Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "1a37ff2b4f5d4f83445eccd4c32fb50cba2dd4c5",
          "message": "Move try-catch block to a separate function.",
          "committedDate": "2021-10-01T13:47:12Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "fc9d8b162a5fb7478f6c7986e8f29d1afdfd477f",
          "message": "Address PR comments.",
          "committedDate": "2021-10-08T11:08:37Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "5e1ae3f13af0fc7036d08cd2bdaa91b4e269dde9",
          "message": "Remove IVT to Microsoft.Build.Engine.OM.UnitTests.",
          "committedDate": "2021-10-13T09:00:07Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      },
      {
        "commit": {
          "oid": "d6b2109bef8ba582dc31a08985be4cbbffd4ea4c",
          "message": "Workaround the sanity check breaking.",
          "committedDate": "2021-10-14T11:45:27Z",
          "author": {
            "name": "AR-May",
            "email": "67507805+AR-May@users.noreply.github.com"
          }
        }
      }
    ]
  },
  "comments": {
    "nodes": [
      {
        "body": "I measured CPU and memory of the enumeration requests from FileMatcher.cs functions for 3 cases. \r\n\r\n- Enumeration uses old API from .NET Framework System.IO.\r\n- Enumeration uses old API from Microsoft.IO\r\n- New enumeration, using the new API from Microsoft.IO\r\n\r\nMeasurements are done for the rebuild of OrchardCore repo, it is average of 3 attempts.\r\n\r\n| Description | CPU (msec) | Memory (bytes) |\r\n|:-----|----------|----------|\r\n| System.IO old API | 9996  | 63933  |\r\n| Microsoft.IO old API | 4656 |  44133  |\r\n| Microsoft.IO new API | 3927  | 52133 |\r\n\r\nConsidering that the difference is not that big and implementation with old API is much easier (no need to change in our public interfaces or work around it) we decided to use old API from Microsoft.IO.\r\n\r\n\r\n\r\n",
        "createdAt": "2021-08-18T13:32:14Z",
        "author": {
          "login": "AR-May"
        }
      },
      {
        "body": "So far, it seems that I was able to resolve problems with the VS experimental insertion. \r\nThe absence of the binding redirect was indeed the root cause of the failures that I saw (but not for Microsoft.IO.Redist, for one of the dependency assemblies). \r\nThe actual exception \"Could not load file or assembly 'System.Buffers, Version=4.0.2.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies. The system cannot find the file specified.\" was covered with a nonsense error \"System.ArgumentException: Illegal characters in path.\" and mislead me.\r\n\r\nThe other errors that I saw should be flukes or not related, as far as I could see. I will run the final version through the experimental insertion one more time to confirm resolution of the errors.",
        "createdAt": "2021-09-03T15:48:57Z",
        "author": {
          "login": "AR-May"
        }
      }
    ]
  },
  "reviewThreads": {
    "nodes": [
      {
        "comments": {
          "nodes": [
            {
              "body": "This is the unit test that I broke. I must say, I am not quite sure about it. Behavior of GetFiles changed in this test. Before the change it returned the input verbatim and now it returns an empty array. Which one is a correct behavior is a question.\r\n\r\nThe reason of the change is that Directory.EnumerateFiles no more throws exception when the filespec pattern is too long, it allows much longer strings.\r\nAs in the summary comment to the function `GetFiles` it is stated \"never throw IO exceptions: if there is no match, returns the input verbatim.\"  If it is just no matches, it returns just empty array. I have not found more specific approach to define when to return the \"input verbatim\" and when to return an empty array.",
              "createdAt": "2021-08-18T13:55:49Z",
              "path": "src/Shared/UnitTests/FileMatcher_Tests.cs",
              "diffHunk": "@@ -1241,6 +1241,7 @@ public void IllegalPaths()\n             ValidateIllegal(\"http://www.website.com\");\n         }\n \n+#if !FEATURE_MSIOREDIST",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "How is this passing, exactly? Shouldn't it be failing when it actually hits the OS APIs? Or is it passing in some cases because the OS flag to allow long paths is turned on?",
              "createdAt": "2021-08-18T14:47:13Z",
              "path": "src/Shared/UnitTests/FileMatcher_Tests.cs",
              "diffHunk": "@@ -1241,6 +1241,7 @@ public void IllegalPaths()\n             ValidateIllegal(\"http://www.website.com\");\n         }\n \n+#if !FEATURE_MSIOREDIST",
              "author": {
                "login": "rainersigwald"
              }
            },
            {
              "body": "Hmm, it runs only for Windows platform. So, it is not called at all in the result. I suppose I can just delete this test. The question about this test, however, stays: does the function still behaves well.",
              "createdAt": "2021-08-18T15:00:18Z",
              "path": "src/Shared/UnitTests/FileMatcher_Tests.cs",
              "diffHunk": "@@ -1241,6 +1241,7 @@ public void IllegalPaths()\n             ValidateIllegal(\"http://www.website.com\");\n         }\n \n+#if !FEATURE_MSIOREDIST",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "I am not sure which errors could be hit when it it fails with exception, but no-exceptions behavior is asked in the func description.",
              "createdAt": "2021-08-18T15:06:34Z",
              "path": "src/Shared/UnitTests/FileMatcher_Tests.cs",
              "diffHunk": "@@ -1241,6 +1241,7 @@ public void IllegalPaths()\n             ValidateIllegal(\"http://www.website.com\");\n         }\n \n+#if !FEATURE_MSIOREDIST",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "> How is this passing\r\n\r\nWell, for .NET Framework GetFiles catches IO exception about the long path and returns filespec as the only match. And I am not quite sure that was correct behavior, as it is written in the test that it is only to avoid a crash. Unfortunately, I cannot go to the history of the test there and find more info about a crash: it is initial commit",
              "createdAt": "2021-08-18T15:41:57Z",
              "path": "src/Shared/UnitTests/FileMatcher_Tests.cs",
              "diffHunk": "@@ -1241,6 +1241,7 @@ public void IllegalPaths()\n             ValidateIllegal(\"http://www.website.com\");\n         }\n \n+#if !FEATURE_MSIOREDIST",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "You're looking for (internal link, VPN required): https://vstfdevdiv/DevDiv2/DevDiv/_versionControl/changeset/65580/",
              "createdAt": "2021-08-18T16:02:07Z",
              "path": "src/Shared/UnitTests/FileMatcher_Tests.cs",
              "diffHunk": "@@ -1241,6 +1241,7 @@ public void IllegalPaths()\n             ValidateIllegal(\"http://www.website.com\");\n         }\n \n+#if !FEATURE_MSIOREDIST",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I would expect this to need to be ngened in the `vsn.exe` (that is, `devenv.exe`/Visual Studio) context as well, since evaluation should hit these codepaths in-process.",
              "createdAt": "2021-08-18T14:48:36Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -32,6 +32,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(X86BinPath)Microsoft.Build.Framework.tlb\n   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenApplications=\"[installDir]\\Common7\\IDE\\vsn.exe\" vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenApplications=\"[installDir]\\Common7\\IDE\\vsn.exe\" vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "rainersigwald"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Do you need the first vs.file.ngenApplications here? Can you explain that?",
              "createdAt": "2021-08-23T17:26:36Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -32,6 +32,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(X86BinPath)Microsoft.Build.Framework.tlb\n   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenApplications=\"[installDir]\\Common7\\IDE\\vsn.exe\" vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenApplications=\"[installDir]\\Common7\\IDE\\vsn.exe\" vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications=\"[installDir]\\Common7\\IDE\\vsn.exe\" vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Yeah, we need it, see [comment](https://github.com/dotnet/msbuild/pull/6771#discussion_r691312635).",
              "createdAt": "2021-09-03T17:34:39Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -32,6 +32,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(X86BinPath)Microsoft.Build.Framework.tlb\n   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenApplications=\"[installDir]\\Common7\\IDE\\vsn.exe\" vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenApplications=\"[installDir]\\Common7\\IDE\\vsn.exe\" vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications=\"[installDir]\\Common7\\IDE\\vsn.exe\" vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "super-nit: I would move this line down so it's closer to other dependencies. I understand you put it here so it's alphabetically ordered but it may be nicer to list all files we build (i.e. up to `MSBuildTaskHost.exe.config`) and then all dependencies.",
              "createdAt": "2021-10-04T09:20:59Z",
              "path": "src/Package/MSBuild.VSSetup/files.swr",
              "diffHunk": "@@ -32,6 +32,7 @@ folder InstallDir:\\MSBuild\\Current\\Bin\n   file source=$(X86BinPath)Microsoft.Build.Framework.tlb\n   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenApplications=\"[installDir]\\Common7\\IDE\\vsn.exe\" vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenApplications=\"[installDir]\\Common7\\IDE\\vsn.exe\" vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1\n+  file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications=\"[installDir]\\Common7\\IDE\\vsn.exe\" vs.file.ngenApplications=\"[installDir]\\MSBuild\\Current\\Bin\\MSBuild.exe\" vs.file.ngenArchitecture=all vs.file.ngenPriority=1",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Should be able to remove this.",
              "createdAt": "2021-08-23T17:26:47Z",
              "path": "src/Framework/Properties/AssemblyInfo.cs",
              "diffHunk": "@@ -44,6 +44,7 @@\n [assembly: InternalsVisibleTo(\"MSBuild, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n [assembly: InternalsVisibleTo(\"Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n \n+[assembly: InternalsVisibleTo(\"Microsoft.Build.Engine.OM.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4\")]",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "We use a ChangeWaves class for one of the tests, and it is internal. So, we need it.",
              "createdAt": "2021-09-03T17:32:53Z",
              "path": "src/Framework/Properties/AssemblyInfo.cs",
              "diffHunk": "@@ -44,6 +44,7 @@\n [assembly: InternalsVisibleTo(\"MSBuild, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n [assembly: InternalsVisibleTo(\"Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n \n+[assembly: InternalsVisibleTo(\"Microsoft.Build.Engine.OM.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4\")]",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Are you sure it's still needed? I suggest moving the test from `Microsoft.Build.Engine.OM.UnitTests` to another assembly (`Microsoft.Build.Engine.UnitTests`?) instead of adding this attribute. I believe it's intentional the \"OM\" test suite accesses only the public Object Model.",
              "createdAt": "2021-09-21T11:49:52Z",
              "path": "src/Framework/Properties/AssemblyInfo.cs",
              "diffHunk": "@@ -44,6 +44,7 @@\n [assembly: InternalsVisibleTo(\"MSBuild, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n [assembly: InternalsVisibleTo(\"Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n \n+[assembly: InternalsVisibleTo(\"Microsoft.Build.Engine.OM.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4\")]",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "We talked about this online a couple weeks ago, and as I recall, the test made more sense in Engine.OM.UnitTests because it's testing our public API surface, but the way it's implemented under the hood, because it involves Microsoft.IO.Redist, involves a ChangeWave, and the infrastructure we have set up to test that is internal. Ideally, I think we'd make a note of this and remove both the test and this IVT after ChangeWave17_0 goes out of support.",
              "createdAt": "2021-09-21T15:36:48Z",
              "path": "src/Framework/Properties/AssemblyInfo.cs",
              "diffHunk": "@@ -44,6 +44,7 @@\n [assembly: InternalsVisibleTo(\"MSBuild, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n [assembly: InternalsVisibleTo(\"Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n \n+[assembly: InternalsVisibleTo(\"Microsoft.Build.Engine.OM.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4\")]",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Sorry, I was wrong. The test is already in `Microsoft.Build.Engine.UnitTests` and is not problematic. The problem is in `ManagedFileSystem` class. It is a shared class and it is used in `Microsoft.Build.Engine.OM.UnitTests`. It comes there through `Microsoft.Build.Tasks.csproj` reference. Now `ManagedFileSystem` needs the `ChangeWaves` class, which is internal class of `Microsoft.Build.Framework`. Therefore, `Microsoft.Build.Engine.OM.UnitTests` wants access to internals of `Microsoft.Build.Framework`. \r\nThe whole situation appeared because a Shared class needs  internals of `Microsoft.Build.Framework`.",
              "createdAt": "2021-10-01T15:14:35Z",
              "path": "src/Framework/Properties/AssemblyInfo.cs",
              "diffHunk": "@@ -44,6 +44,7 @@\n [assembly: InternalsVisibleTo(\"MSBuild, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n [assembly: InternalsVisibleTo(\"Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293\")]\n \n+[assembly: InternalsVisibleTo(\"Microsoft.Build.Engine.OM.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4\")]",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "I am not quite sure here should I or should I not move this change in `IsIoRelatedException` function. I feel should be possible, but I can not guarantee it for all the places where we use this function. So, I would prefer to keep it here just in case. ",
              "createdAt": "2021-09-20T08:42:47Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2499,13 +2499,13 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n             catch (AggregateException ex)\n             {\n                 // Flatten to get exceptions than are thrown inside a nested Parallel.ForEach\n-                if (ex.Flatten().InnerExceptions.All(ExceptionHandling.IsIoRelatedException))\n+                if (ex.Flatten().InnerExceptions.All(ex => ExceptionHandling.IsIoRelatedException(ex) && !(ex is FileLoadException)))\n                 {\n                     return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);\n                 }\n                 throw;\n             }\n-            catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))\n+            catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex) && !(ex is FileLoadException))",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "Decided to move that to ManagedFileSystem class.",
              "createdAt": "2021-10-01T13:51:56Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2499,13 +2499,13 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n             catch (AggregateException ex)\n             {\n                 // Flatten to get exceptions than are thrown inside a nested Parallel.ForEach\n-                if (ex.Flatten().InnerExceptions.All(ExceptionHandling.IsIoRelatedException))\n+                if (ex.Flatten().InnerExceptions.All(ex => ExceptionHandling.IsIoRelatedException(ex) && !(ex is FileLoadException)))\n                 {\n                     return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);\n                 }\n                 throw;\n             }\n-            catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))\n+            catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex) && !(ex is FileLoadException))",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit:\r\nmove this up to\r\n`catch (AggregateException ex) when...`\r\n?",
              "createdAt": "2021-09-20T19:37:16Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2499,13 +2499,13 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n             catch (AggregateException ex)\n             {\n                 // Flatten to get exceptions than are thrown inside a nested Parallel.ForEach\n-                if (ex.Flatten().InnerExceptions.All(ExceptionHandling.IsIoRelatedException))\n+                if (ex.Flatten().InnerExceptions.All(ex => ExceptionHandling.IsIoRelatedException(ex) && !(ex is FileLoadException)))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "That won't be equivalent. The `ex` here is different from the `ex` being caught on line 2499. Suggestion: rename the lambda parameter.",
              "createdAt": "2021-09-21T11:53:12Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2499,13 +2499,13 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n             catch (AggregateException ex)\n             {\n                 // Flatten to get exceptions than are thrown inside a nested Parallel.ForEach\n-                if (ex.Flatten().InnerExceptions.All(ExceptionHandling.IsIoRelatedException))\n+                if (ex.Flatten().InnerExceptions.All(ex => ExceptionHandling.IsIoRelatedException(ex) && !(ex is FileLoadException)))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Different from the second one, but I was thinking like:\r\n`catch (AggregateException ex) when (ex.Flatten().InnerExceptions.Any(e => !ExceptionHandling.IsIoRelatedException(e) || (ex is FileLoadException)))`",
              "createdAt": "2021-09-21T15:33:08Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2499,13 +2499,13 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n             catch (AggregateException ex)\n             {\n                 // Flatten to get exceptions than are thrown inside a nested Parallel.ForEach\n-                if (ex.Flatten().InnerExceptions.All(ExceptionHandling.IsIoRelatedException))\n+                if (ex.Flatten().InnerExceptions.All(ex => ExceptionHandling.IsIoRelatedException(ex) && !(ex is FileLoadException)))",
              "author": {
                "login": "Forgind"
              }
            },
            {
              "body": "Apologies, I misunderstood. Moving everything to an exception filter is a great idea!",
              "createdAt": "2021-09-21T15:45:13Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2499,13 +2499,13 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n             catch (AggregateException ex)\n             {\n                 // Flatten to get exceptions than are thrown inside a nested Parallel.ForEach\n-                if (ex.Flatten().InnerExceptions.All(ExceptionHandling.IsIoRelatedException))\n+                if (ex.Flatten().InnerExceptions.All(ex => ExceptionHandling.IsIoRelatedException(ex) && !(ex is FileLoadException)))",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Decided that it is better to rethrow the FileLoadException as a InvalidOperationException directly in ManagedFileSystem class and not here. It will allow to throw a proper error if enumeration is used elsewhere besides FileMatcher class  some time in future. So, no need for this line anymore, but thank you for your suggestions!",
              "createdAt": "2021-10-01T13:58:00Z",
              "path": "src/Shared/FileMatcher.cs",
              "diffHunk": "@@ -2499,13 +2499,13 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn\n             catch (AggregateException ex)\n             {\n                 // Flatten to get exceptions than are thrown inside a nested Parallel.ForEach\n-                if (ex.Flatten().InnerExceptions.All(ExceptionHandling.IsIoRelatedException))\n+                if (ex.Flatten().InnerExceptions.All(ex => ExceptionHandling.IsIoRelatedException(ex) && !(ex is FileLoadException)))",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Why this version and not the latest (5.0.0)?",
              "createdAt": "2021-09-21T11:30:02Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -13,6 +13,7 @@\n     <PackageReference Update=\"Microsoft.CodeQuality.Analyzers\" Version=\"3.3.0\" PrivateAssets=\"all\" />\n     <PackageReference Update=\"Microsoft.DotNet.GenAPI\" Version=\"2.1.0-prerelease-02404-02\" />\n     <PackageReference Update=\"Microsoft.DotNet.XUnitExtensions\" Version=\"$(MicrosoftDotNetXUnitExtensionsVersion)\" />\n+    <PackageReference Update=\"Microsoft.IO.Redist\" Version=\"4.7.1\" />",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "I do remember I tried put here the oldest version, but it failed on the exp. insertion, because VS uses v4.7.1.",
              "createdAt": "2021-09-23T08:52:52Z",
              "path": "eng/Packages.props",
              "diffHunk": "@@ -13,6 +13,7 @@\n     <PackageReference Update=\"Microsoft.CodeQuality.Analyzers\" Version=\"3.3.0\" PrivateAssets=\"all\" />\n     <PackageReference Update=\"Microsoft.DotNet.GenAPI\" Version=\"2.1.0-prerelease-02404-02\" />\n     <PackageReference Update=\"Microsoft.DotNet.XUnitExtensions\" Version=\"$(MicrosoftDotNetXUnitExtensionsVersion)\" />\n+    <PackageReference Update=\"Microsoft.IO.Redist\" Version=\"4.7.1\" />",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "Isn't the `FusionLog` property available only if fusion logging is actually enabled?\r\n\r\nI don't see `FileNotFoundException` listed as an exception thrown by `Directory.Enumerate*` so it looks like it should work without the `when`.",
              "createdAt": "2021-10-04T09:38:34Z",
              "path": "src/Shared/FileSystem/ManagedFileSystem.cs",
              "diffHunk": "@@ -38,19 +39,64 @@ public byte[] ReadFileAllBytes(string path)\n             return File.ReadAllBytes(path);\n         }\n \n+#if FEATURE_MSIOREDIST\n+        private IEnumerable<string> HandleFileLoadException(\n+            Func<string, string, Microsoft.IO.SearchOption, IEnumerable<string>> enumerateFunctionDelegate,\n+            string path,\n+            string searchPattern,\n+            Microsoft.IO.SearchOption searchOption\n+        )\n+        {\n+            try\n+            {\n+                return enumerateFunctionDelegate(path, searchPattern, searchOption);\n+            }\n+            // Microsoft.IO.Redist has a dependency on System.Buffers and if System.Buffers assembly is not found the line above throws an exception.\n+            // However, FileMatcher class (that in most cases calls the enumeration) does not allow to fail on a IO-related exception. Such behavior hides the actual exception and makes it obscure.\n+            // We rethrow it to make it fail with a proper error message and call stack.\n+            catch (FileLoadException ex)\n+            {\n+                throw new InvalidOperationException(\"Could not load file or assembly.\", ex);\n+            }\n+            // Sometimes FileNotFoundException is thrown when there is an assembly load failure. In this case it should have FusionLog.\n+            catch (FileNotFoundException ex) when (ex.FusionLog != null)",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "It works when fusion logging is disabled. The FusionLog in this case consists of a warning \"WRN: Assembly binding logging is turned OFF. To enable assembly bind failure logging, set the registry value [HKLM\\Software\\Microsoft\\Fusion!EnableLog] (DWORD) to 1.\"\r\n\r\nIf `Directory.Enumerate` indeed does not throw `FileNotFoundException`, then additional check in `when` should not have any performance implications, cause it is used in rare case when we indeed have a failure. And I felt like it is safer to have it than not not have. \r\n\r\nBut I suppose you are right and we can remove this `when` from this line.",
              "createdAt": "2021-10-04T10:48:22Z",
              "path": "src/Shared/FileSystem/ManagedFileSystem.cs",
              "diffHunk": "@@ -38,19 +39,64 @@ public byte[] ReadFileAllBytes(string path)\n             return File.ReadAllBytes(path);\n         }\n \n+#if FEATURE_MSIOREDIST\n+        private IEnumerable<string> HandleFileLoadException(\n+            Func<string, string, Microsoft.IO.SearchOption, IEnumerable<string>> enumerateFunctionDelegate,\n+            string path,\n+            string searchPattern,\n+            Microsoft.IO.SearchOption searchOption\n+        )\n+        {\n+            try\n+            {\n+                return enumerateFunctionDelegate(path, searchPattern, searchOption);\n+            }\n+            // Microsoft.IO.Redist has a dependency on System.Buffers and if System.Buffers assembly is not found the line above throws an exception.\n+            // However, FileMatcher class (that in most cases calls the enumeration) does not allow to fail on a IO-related exception. Such behavior hides the actual exception and makes it obscure.\n+            // We rethrow it to make it fail with a proper error message and call stack.\n+            catch (FileLoadException ex)\n+            {\n+                throw new InvalidOperationException(\"Could not load file or assembly.\", ex);\n+            }\n+            // Sometimes FileNotFoundException is thrown when there is an assembly load failure. In this case it should have FusionLog.\n+            catch (FileNotFoundException ex) when (ex.FusionLog != null)",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: OK to use a non-localized string here? Is it possible that the exception bubbles up to non-MSBuild code or do we always catch it internally?",
              "createdAt": "2021-10-04T09:48:30Z",
              "path": "src/Shared/FileSystem/ManagedFileSystem.cs",
              "diffHunk": "@@ -38,19 +39,64 @@ public byte[] ReadFileAllBytes(string path)\n             return File.ReadAllBytes(path);\n         }\n \n+#if FEATURE_MSIOREDIST\n+        private IEnumerable<string> HandleFileLoadException(\n+            Func<string, string, Microsoft.IO.SearchOption, IEnumerable<string>> enumerateFunctionDelegate,\n+            string path,\n+            string searchPattern,\n+            Microsoft.IO.SearchOption searchOption\n+        )\n+        {\n+            try\n+            {\n+                return enumerateFunctionDelegate(path, searchPattern, searchOption);\n+            }\n+            // Microsoft.IO.Redist has a dependency on System.Buffers and if System.Buffers assembly is not found the line above throws an exception.\n+            // However, FileMatcher class (that in most cases calls the enumeration) does not allow to fail on a IO-related exception. Such behavior hides the actual exception and makes it obscure.\n+            // We rethrow it to make it fail with a proper error message and call stack.\n+            catch (FileLoadException ex)\n+            {\n+                throw new InvalidOperationException(\"Could not load file or assembly.\", ex);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "So, when the exception goes outside MSBuild we always want it to be localized? I will update it here in this case. \r\nI did not localize it because I do not expect it to be seen by many. But this exception indeed goes outside MSBuild. It is actually the main purpose of this exception: not to be caught.   ",
              "createdAt": "2021-10-04T10:51:17Z",
              "path": "src/Shared/FileSystem/ManagedFileSystem.cs",
              "diffHunk": "@@ -38,19 +39,64 @@ public byte[] ReadFileAllBytes(string path)\n             return File.ReadAllBytes(path);\n         }\n \n+#if FEATURE_MSIOREDIST\n+        private IEnumerable<string> HandleFileLoadException(\n+            Func<string, string, Microsoft.IO.SearchOption, IEnumerable<string>> enumerateFunctionDelegate,\n+            string path,\n+            string searchPattern,\n+            Microsoft.IO.SearchOption searchOption\n+        )\n+        {\n+            try\n+            {\n+                return enumerateFunctionDelegate(path, searchPattern, searchOption);\n+            }\n+            // Microsoft.IO.Redist has a dependency on System.Buffers and if System.Buffers assembly is not found the line above throws an exception.\n+            // However, FileMatcher class (that in most cases calls the enumeration) does not allow to fail on a IO-related exception. Such behavior hides the actual exception and makes it obscure.\n+            // We rethrow it to make it fail with a proper error message and call stack.\n+            catch (FileLoadException ex)\n+            {\n+                throw new InvalidOperationException(\"Could not load file or assembly.\", ex);",
              "author": {
                "login": "AR-May"
              }
            },
            {
              "body": "> So, when the exception goes outside MSBuild we always want it to be localized?\r\n\r\nNot sure how much we care. I see examples of both localized and non-localized exception messages in the source tree. Maybe bring it up in today's PR reviews call?",
              "createdAt": "2021-10-04T12:00:45Z",
              "path": "src/Shared/FileSystem/ManagedFileSystem.cs",
              "diffHunk": "@@ -38,19 +39,64 @@ public byte[] ReadFileAllBytes(string path)\n             return File.ReadAllBytes(path);\n         }\n \n+#if FEATURE_MSIOREDIST\n+        private IEnumerable<string> HandleFileLoadException(\n+            Func<string, string, Microsoft.IO.SearchOption, IEnumerable<string>> enumerateFunctionDelegate,\n+            string path,\n+            string searchPattern,\n+            Microsoft.IO.SearchOption searchOption\n+        )\n+        {\n+            try\n+            {\n+                return enumerateFunctionDelegate(path, searchPattern, searchOption);\n+            }\n+            // Microsoft.IO.Redist has a dependency on System.Buffers and if System.Buffers assembly is not found the line above throws an exception.\n+            // However, FileMatcher class (that in most cases calls the enumeration) does not allow to fail on a IO-related exception. Such behavior hides the actual exception and makes it obscure.\n+            // We rethrow it to make it fail with a proper error message and call stack.\n+            catch (FileLoadException ex)\n+            {\n+                throw new InvalidOperationException(\"Could not load file or assembly.\", ex);",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "This creates a new `Func` delegate on each call, a small but avoidable allocation.\r\n\r\n![image](https://user-images.githubusercontent.com/12206368/135832141-f5777a49-f7bd-4eba-a048-a3ff38b9c31c.png)\r\n\r\nYou should be able to get C# cache the delegate if you use a lambda:\r\n\r\n```suggestion\r\n                ? HandleFileLoadException((path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateDirectories(path, searchPattern, searchOption), path, searchPattern, (Microsoft.IO.SearchOption)searchOption)\r\n```\r\n\r\nor pass an enum to `HandleFileLoadException` and use a switch when making the actual call.",
              "createdAt": "2021-10-04T10:08:32Z",
              "path": "src/Shared/FileSystem/ManagedFileSystem.cs",
              "diffHunk": "@@ -38,19 +39,64 @@ public byte[] ReadFileAllBytes(string path)\n             return File.ReadAllBytes(path);\n         }\n \n+#if FEATURE_MSIOREDIST\n+        private IEnumerable<string> HandleFileLoadException(\n+            Func<string, string, Microsoft.IO.SearchOption, IEnumerable<string>> enumerateFunctionDelegate,\n+            string path,\n+            string searchPattern,\n+            Microsoft.IO.SearchOption searchOption\n+        )\n+        {\n+            try\n+            {\n+                return enumerateFunctionDelegate(path, searchPattern, searchOption);\n+            }\n+            // Microsoft.IO.Redist has a dependency on System.Buffers and if System.Buffers assembly is not found the line above throws an exception.\n+            // However, FileMatcher class (that in most cases calls the enumeration) does not allow to fail on a IO-related exception. Such behavior hides the actual exception and makes it obscure.\n+            // We rethrow it to make it fail with a proper error message and call stack.\n+            catch (FileLoadException ex)\n+            {\n+                throw new InvalidOperationException(\"Could not load file or assembly.\", ex);\n+            }\n+            // Sometimes FileNotFoundException is thrown when there is an assembly load failure. In this case it should have FusionLog.\n+            catch (FileNotFoundException ex) when (ex.FusionLog != null)\n+            {\n+                throw new InvalidOperationException(\"Could not load file or assembly.\", ex);\n+            }\n+        }\n+#endif\n+\n         public virtual IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)\n         {\n+#if FEATURE_MSIOREDIST\n+            return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)\n+                    ? HandleFileLoadException(Microsoft.IO.Directory.EnumerateFiles, path, searchPattern, (Microsoft.IO.SearchOption)searchOption)",
              "author": {
                "login": "ladipro"
              }
            }
          ]
        }
      },
      {
        "comments": {
          "nodes": [
            {
              "body": "nit: `readonly` and perhaps even `static` since the change wave setting is not supposed to change during the lifetime of the process.",
              "createdAt": "2021-10-13T09:33:07Z",
              "path": "src/Shared/ManagedFileSystemChangeWavesExtension.cs",
              "diffHunk": "@@ -0,0 +1,23 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+// This file is a workaround from PR https://github.com/dotnet/msbuild/pull/6771.\n+// We need to avoid using ChangeWaves.cs in Microsoft.Build.Engine.OM.UnitTests.\n+// Usage of ChangeWaves class in ManagedFileSystem is done in this separate file.\n+// In Microsoft.Build.Engine.OM.UnitTests this part is mocked (see MockManagedFileSystemChangeWavesExtension.cs).\n+// After deleting changewave 17_0 delete this file as well.\n+\n+#if FEATURE_MSIOREDIST\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Shared.FileSystem\n+{\n+    /// <summary>\n+    /// Implementation of file system operations directly over the dot net managed layer\n+    /// </summary>\n+    internal partial class ManagedFileSystem : IFileSystem\n+    {\n+        private bool ShouldUseMicrosoftIO = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0);",
              "author": {
                "login": "ladipro"
              }
            },
            {
              "body": "Right. I had a feeling that I forgot something, and it was about that `static` modifier. \r\nHowever, now failing tests show that we need not to kind of \"cache\" this value by computing it once. We compute it too early and tests can not rewrite this value as needed. So, we need to call `ChangeWaves.AreFeaturesEnabled` each time when access ShouldUseMicrosoftIO (ChangeWaves seem to be smart enough not to go checking env variable each time for that, so i suppose it should be fine...). So, i actually will go very opposite way with this line. ",
              "createdAt": "2021-10-13T14:36:13Z",
              "path": "src/Shared/ManagedFileSystemChangeWavesExtension.cs",
              "diffHunk": "@@ -0,0 +1,23 @@\n+\ufeff// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+// This file is a workaround from PR https://github.com/dotnet/msbuild/pull/6771.\n+// We need to avoid using ChangeWaves.cs in Microsoft.Build.Engine.OM.UnitTests.\n+// Usage of ChangeWaves class in ManagedFileSystem is done in this separate file.\n+// In Microsoft.Build.Engine.OM.UnitTests this part is mocked (see MockManagedFileSystemChangeWavesExtension.cs).\n+// After deleting changewave 17_0 delete this file as well.\n+\n+#if FEATURE_MSIOREDIST\n+using Microsoft.Build.Utilities;\n+\n+namespace Microsoft.Build.Shared.FileSystem\n+{\n+    /// <summary>\n+    /// Implementation of file system operations directly over the dot net managed layer\n+    /// </summary>\n+    internal partial class ManagedFileSystem : IFileSystem\n+    {\n+        private bool ShouldUseMicrosoftIO = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0);",
              "author": {
                "login": "AR-May"
              }
            }
          ]
        }
      }
    ]
  }
}